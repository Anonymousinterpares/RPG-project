# Project Documentation: world_configurator
Generated on: 2025-05-31 22:40:59

## Project Structure

```
world_configurator/
├── data/
├── logs/
├── models/
│   ├── __init__.py
│   ├── base_models.py
│   ├── location_data.py
│   ├── origin_data.py
│   ├── world_config.py
│   └── world_data.py
├── selected_files_documentation_31.05.2025_22_40_59_output/
├── ui/
│   ├── dialogs/
│   │   ├── __init__.py
│   │   ├── export_dialog.py
│   │   ├── new_project_dialog.py
│   │   └── settings_dialog.py
│   ├── editors/
│   │   ├── __init__.py
│   │   ├── class_editor.py
│   │   ├── culture_editor.py
│   │   ├── history_editor.py
│   │   ├── location_editor.py
│   │   ├── magic_systems_editor.py
│   │   ├── origin_editor.py
│   │   ├── quest_editor.py
│   │   └── race_editor.py
│   ├── __init__.py
│   └── main_window.py
├── utils/
│   ├── __init__.py
│   ├── data_validator.py
│   ├── file_manager.py
│   └── logging_setup.py
├── __init__.py
└── main.py
```

## Files Content

### File: ..\gui\components\character_sheet.py

```python
#!/usr/bin/env python3
"""
Character sheet widget for the RPG game GUI.
This module provides a widget for displaying the player character's information.
"""

import logging
import re
from typing import Optional, Dict, Any, List, Union, Callable
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, QTextEdit,
    QScrollArea, QFrame, QGroupBox, QProgressBar, QMenu, QToolTip
)
from PySide6.QtCore import Qt, Slot, QTimer, QPoint
from PySide6.QtGui import QFont, QPixmap, QCursor, QMouseEvent

from core.base.state import get_state_manager
from core.interaction.enums import InteractionMode
from core.stats.modifier import StatModifier
from core.stats.stats_base import StatType, DerivedStatType, Stat, StatCategory
from core.stats.stats_manager import get_stats_manager
from core.utils.logging_config import get_logger

logger = get_logger("GUI")

class StatLabel(QLabel):
    """A label for displaying a stat that shows details on right-click."""
    
    def __init__(self, text: str, stat_name: str, parent=None):
        """
        Initialize the stat label.

        Args:
            text: The initial text to display.
            stat_name: The name of the stat this label represents (e.g., "STR", "MELEE_ATTACK").
            parent: The parent widget.
        """
        super().__init__(text, parent)
        # Store the enum name (e.g., "STR") for consistency with StatsManager keys
        self.stat_name_key = stat_name # Keep the original key passed in
        self.description = ""
        self.base_value = 0
        self.current_value = 0
        # Modifiers will be fetched dynamically for tooltip
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Handle mouse press events to show tooltips."""
        if event.button() == Qt.RightButton:
            self.show_tooltip(event.globalPos())
        super().mousePressEvent(event)
    
    def _fetch_modifiers(self) -> List[Dict[str, Any]]:
        """Fetch the list of modifiers for this stat."""
        try:
            # Get the StatsManager instance
            stats_manager = get_stats_manager()
            if not stats_manager:
                return []

            # Convert the stored stat_name_key back to the enum type if possible
            stat_type_enum = None
            try:
                stat_type_enum = StatType[self.stat_name_key]
            except KeyError:
                try:
                    stat_type_enum = DerivedStatType[self.stat_name_key]
                except KeyError:
                    logging.warning(f"Could not convert stat key '{self.stat_name_key}' to StatType or DerivedStatType for fetching modifiers.")
                    return []

            # Check if ModifierManager has a method to get the list
            # Assuming a method get_modifiers_for_stat exists or can be added
            if hasattr(stats_manager.modifier_manager, 'get_modifiers_for_stat'):
                # This method should return List[StatModifier] or List[Dict]
                mods = stats_manager.modifier_manager.get_modifiers_for_stat(stat_type_enum)
                # Convert StatModifier objects to dicts if necessary
                if mods and isinstance(mods[0], StatModifier):
                     return [mod.to_dict() for mod in mods] # Assuming StatModifier has to_dict()
                elif mods and isinstance(mods, list):
                     return mods # Assume it's already a list of dicts
                else:
                     return []
            else:
                # Fallback or log warning if the method doesn't exist
                logging.warning(f"ModifierManager lacks 'get_modifiers_for_stat' method.")
                return []

        except Exception as e:
            logging.error(f"Error fetching modifiers for {self.stat_name_key}: {e}")
            return []

    def show_tooltip(self, position: QPoint) -> None:
        """Show detailed tooltip for the stat."""
        # Fetch modifiers dynamically
        modifiers = self._fetch_modifiers()

        # Get the display name (e.g., "Strength") if available, otherwise use the key
        display_name = self.stat_name_key # Default to key
        if hasattr(self, 'display_name_override'): # Check if set by update_stat_data
            display_name = self.display_name_override

        tooltip_text = f"<b>{display_name}</b><hr>"

        if self.description:
            tooltip_text += f"{self.description}<br><br>"

        tooltip_text += f"Base Value: {self.base_value}<br>"
        tooltip_text += f"Current Value: {self.current_value}<br>"

        if modifiers:
            tooltip_text += "<br><b>Modifiers:</b><br>"
            for mod in modifiers:
                # Access modifier data assuming it's a dictionary now
                mod_source = mod.get('source', 'Unknown')
                mod_value = mod.get('value', 0)
                mod_is_percentage = mod.get('is_percentage', False)
                mod_duration = mod.get('duration', None)

                mod_text = f"{mod_source}: "
                if mod_value > 0:
                    mod_text += "+"
                mod_text += f"{mod_value}"
                if mod_is_percentage:
                    mod_text += "%"
                if mod_duration is not None:
                    mod_text += f" ({mod_duration} turns)"
                tooltip_text += f"{mod_text}<br>"
        else:
            tooltip_text += "<br>No active modifiers.<br>"

        QToolTip.showText(position, tooltip_text)

    def show_context_menu(self, position: QPoint) -> None:
        """Show context menu for the stat."""
        # Get the display name (e.g., "Strength") if available, otherwise use the key
        display_name = self.stat_name_key # Default to key
        if hasattr(self, 'display_name_override'): # Check if set by update_stat_data
            display_name = self.display_name_override

        menu = QMenu(self)
        menu.addAction(f"{display_name} Details", lambda: self.show_tooltip(QCursor.pos()))
        menu.exec_(self.mapToGlobal(position))

    def update_stat_data(self, stat_data: Dict[str, Any]) -> None:
        """
        Update the stat data stored in the label for tooltip display.

        Args:
            stat_data: Dictionary containing stat information from StatsManager.
        """
        # Store the display name ("Strength") if provided, distinct from the key ("STR")
        if 'name' in stat_data:
            self.display_name_override = str(stat_data['name'])

        if 'description' in stat_data:
            self.description = stat_data['description']
        if 'base_value' in stat_data:
            self.base_value = stat_data['base_value']
        if 'value' in stat_data:
            self.current_value = stat_data['value']
        # We no longer store modifiers here, they are fetched dynamically


class CharacterSheetWidget(QScrollArea):
    """Widget for displaying character information."""
    
    def __init__(self, parent: Optional[QWidget] = None):
            """Initialize the character sheet widget."""
            super().__init__(parent)

            self.setWidgetResizable(True)
            self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.setStyleSheet("""
                QScrollArea {
                    background-color: #2D2D30;
                    border: none;
                }
            """)

            self.character_widget = QWidget()
            self.setWidget(self.character_widget)
            self.state_manager = get_state_manager()
            self._signal_connected = False

            self._pending_player_bar_updates: Dict[str, Dict[str, Any]] = {} # For player resource bar animations

            self._setup_ui()
            self._clear_stat_displays()
        
    def _setup_ui(self):

        # Create the main layout
        self.main_layout = QVBoxLayout(self.character_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Initialize dictionaries for stat labels
        self.primary_stat_labels = {}
        self.derived_stat_labels = {}
        
        # Create character header
        self._create_header()
        
        # Create stats section
        self._create_stats_section()
        
        # Create skills section
        self._create_skills_section()
        
        # Create equipment section
        self._create_equipment_section()        
    
    def _create_header(self):
        """Create the character header section."""
        # Group box for character header
        header_group = QGroupBox("Character")
        header_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        header_layout = QHBoxLayout(header_group)
        
        # Character portrait frame
        portrait_frame = QFrame()
        portrait_frame.setFrameShape(QFrame.StyledPanel)
        portrait_frame.setFixedSize(100, 100)
        portrait_frame.setStyleSheet("""
            QFrame {
                border: 1px solid #555555;
                background-color: #222222;
            }
        """)
        
        # Character portrait label - this will be replaced with the actual image when available
        self.portrait_label = QLabel("Portrait")
        self.portrait_label.setAlignment(Qt.AlignCenter)
        self.portrait_label.setStyleSheet("color: #888888;")
        self.portrait_label.setScaledContents(True)  # Make the image scale to fit the label
        
        portrait_layout = QVBoxLayout(portrait_frame)
        portrait_layout.addWidget(self.portrait_label)
        
        # Character info
        info_layout = QVBoxLayout()
        
        # Create labels for character info
        self.name_label = QLabel("Name: Unknown")
        self.name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #E0E0E0;")
        
        self.race_class_label = QLabel("Race: Unknown | Class: Unknown")
        self.race_class_label.setStyleSheet("font-size: 12pt; color: #CCCCCC;")
        
        self.level_exp_label = QLabel("Level: 1 | Experience: 0/100")
        self.level_exp_label.setStyleSheet("font-size: 11pt; color: #BBBBBB;")
        
        # Experience bar
        self.exp_bar = QProgressBar()
        self.exp_bar.setRange(0, 100)
        self.exp_bar.setValue(0)
        self.exp_bar.setTextVisible(True)
        self.exp_bar.setStyleSheet("""
            QProgressBar {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                color: white;
            }
            QProgressBar::chunk {
                background-color: #006699;
                border-radius: 3px;
            }
        """)
        
        # Add widgets to layout
        info_layout.addWidget(self.name_label)
        info_layout.addWidget(self.race_class_label)
        info_layout.addWidget(self.level_exp_label)
        info_layout.addWidget(self.exp_bar)
        
        # Add layouts to header
        header_layout.addWidget(portrait_frame)
        header_layout.addLayout(info_layout, 1)  # 1 is the stretch factor
        
        # Add header to main layout
        self.main_layout.addWidget(header_group)
    
    def _create_stats_section(self):
        """Create the character stats section."""

        # --- Create Primary Stats Group Box ---
        primary_stats_group = QGroupBox("Primary Stats")
        primary_stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        primary_stats_layout = QGridLayout(primary_stats_group)
        primary_stats_layout.setColumnStretch(0, 1)
        primary_stats_layout.setColumnStretch(1, 1)

        # Add primary stats - Using Enum Name as stat_id
        self._add_stat(primary_stats_layout, 0, 0, StatType.STRENGTH.name, "Strength", "")
        self._add_stat(primary_stats_layout, 0, 1, StatType.DEXTERITY.name, "Dexterity", "")
        self._add_stat(primary_stats_layout, 1, 0, StatType.CONSTITUTION.name, "Constitution", "")
        self._add_stat(primary_stats_layout, 1, 1, StatType.INTELLIGENCE.name, "Intelligence", "")
        self._add_stat(primary_stats_layout, 2, 0, StatType.WISDOM.name, "Wisdom", "")
        self._add_stat(primary_stats_layout, 2, 1, StatType.CHARISMA.name, "Charisma", "")
        self._add_stat(primary_stats_layout, 3, 0, StatType.WILLPOWER.name, "Willpower", "")
        self._add_stat(primary_stats_layout, 3, 1, StatType.INSIGHT.name, "Insight", "")

        # --- Create Resources Group Box ---
        resources_group = QGroupBox("Resources")
        resources_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        resources_layout = QVBoxLayout(resources_group)

        # Create resource bars
        self.resource_bars = {}
        self._add_resource_bar(resources_layout, "Health", 100, 100, "#CC3333")
        self._add_resource_bar(resources_layout, "Mana", 50, 50, "#3366CC")
        self._add_resource_bar(resources_layout, "Stamina", 100, 100, "#66CC33")

        # --- Create Combat Status Group Box ---
        combat_status_group = QGroupBox("Combat Status")
        combat_status_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        combat_status_layout = QVBoxLayout(combat_status_group)

        # Status Effects section
        status_label = QLabel("Status Effects:")
        status_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        combat_status_layout.addWidget(status_label)

        self.status_effects_list = QTextEdit()
        self.status_effects_list.setReadOnly(True)
        self.status_effects_list.setMaximumHeight(60)
        self.status_effects_list.setStyleSheet("""
            QTextEdit {
                background-color: #222222;
                border: 1px solid #444444;
                color: #E0E0E0;
            }
        """)
        combat_status_layout.addWidget(self.status_effects_list)

        # Turn Order section
        turn_label = QLabel("Turn Order:")
        turn_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        combat_status_layout.addWidget(turn_label)

        self.turn_order_list = QTextEdit()
        self.turn_order_list.setReadOnly(True)
        self.turn_order_list.setMaximumHeight(60)
        self.turn_order_list.setStyleSheet("""
            QTextEdit {
                background-color: #222222;
                border: 1px solid #444444;
                color: #E0E0E0;
            }
        """)
        combat_status_layout.addWidget(self.turn_order_list)

        # Initiative label
        initiative_layout = QHBoxLayout()
        initiative_label = QLabel("Initiative:")
        initiative_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.initiative_value = QLabel("0")
        self.initiative_value.setStyleSheet("color: #E0E0E0;")
        self.initiative_value.setAlignment(Qt.AlignRight)
        initiative_layout.addWidget(initiative_label)
        initiative_layout.addWidget(self.initiative_value)
        combat_status_layout.addLayout(initiative_layout)

        # --- Create Derived Stats Group Box ---
        derived_stats_group = QGroupBox("Derived Stats")
        derived_stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        derived_stats_layout = QGridLayout(derived_stats_group)
        derived_stats_layout.setColumnStretch(0, 1)
        derived_stats_layout.setColumnStretch(1, 1)

        # Add derived stats - Using Enum Name as stat_id
        self._add_stat(derived_stats_layout, 0, 0, DerivedStatType.MELEE_ATTACK.name, "Melee Attack", "")
        self._add_stat(derived_stats_layout, 0, 1, DerivedStatType.RANGED_ATTACK.name, "Ranged Attack", "")
        self._add_stat(derived_stats_layout, 1, 0, DerivedStatType.MAGIC_ATTACK.name, "Magic Attack", "")
        self._add_stat(derived_stats_layout, 1, 1, DerivedStatType.DEFENSE.name, "Defense", "")
        self._add_stat(derived_stats_layout, 2, 0, DerivedStatType.MAGIC_DEFENSE.name, "Magic Defense", "")
        self._add_stat(derived_stats_layout, 2, 1, DerivedStatType.INITIATIVE.name, "Initiative", "")
        self._add_stat(derived_stats_layout, 3, 0, DerivedStatType.CARRY_CAPACITY.name, "Carry Capacity", "")
        self._add_stat(derived_stats_layout, 3, 1, DerivedStatType.MOVEMENT.name, "Movement", "")
        # Example if adding Resolve/Max Resolve display:
        # self._add_stat(derived_stats_layout, 4, 0, DerivedStatType.RESOLVE.name, "Resolve", "")
        # self._add_stat(derived_stats_layout, 4, 1, DerivedStatType.MAX_RESOLVE.name, "Max Resolve", "")

        # --- Add the group boxes to the main layout ---
        self.main_layout.addWidget(resources_group)
        self.main_layout.addWidget(combat_status_group)
        self.main_layout.addWidget(primary_stats_group)
        self.main_layout.addWidget(derived_stats_group)
    
    def _add_stat(self, layout, row, col, stat_id, stat_name, value):
            """Add a stat to the stats layout."""
            # Create label
            label = QLabel(f"{stat_name}:") # Use descriptive name for the row label
            label.setStyleSheet("color: #BBBBBB; font-weight: bold;")

            # Create value label - use the Enum Name (stat_id) as the key
            value_label = StatLabel(value, stat_id) # Pass Enum Name ("STR", "MELEE_ATTACK")
            # Set minimum width and restore original color
            value_label.setStyleSheet("color: #E0E0E0; min-width: 30px;")
            value_label.setAlignment(Qt.AlignRight)

            # Store the value label using the Enum Name as the key
            if stat_id in [s.name for s in StatType]:
                self.primary_stat_labels[stat_id] = value_label
            else:
                self.derived_stat_labels[stat_id] = value_label

            # Add to layout
            layout.addWidget(label, row, col * 2)
            layout.addWidget(value_label, row, col * 2 + 1)
    
    def _add_resource_bar(self, layout, name, value, max_value, color):
        """Add a resource bar to the layout."""
        # Create container
        container = QWidget()
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(2)
        
        # Create label
        label = QLabel(f"{name}: {value}/{max_value}")
        label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        
        # Create progress bar
        progress_bar = QProgressBar()
        progress_bar.setRange(0, max_value)
        progress_bar.setValue(value)
        progress_bar.setTextVisible(True)
        progress_bar.setFormat(f"%v/%m")
        progress_bar.setStyleSheet(f"""
            QProgressBar {{
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                color: white;
            }}
            QProgressBar::chunk {{
                background-color: {color};
                border-radius: 3px;
            }}
        """)
        
        # Add to container
        container_layout.addWidget(label)
        container_layout.addWidget(progress_bar)
        
        # Store the bar
        self.resource_bars[name.lower()] = (label, progress_bar)
        
        # Add to layout
        layout.addWidget(container)
    
    def _create_skills_section(self):
        """Create the character skills section."""
        # Group box for skills
        skills_group = QGroupBox("Skills")
        skills_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        skills_layout = QVBoxLayout(skills_group)
        
        # Create a label for when no skills are available
        self.no_skills_label = QLabel("No skills available yet.")
        self.no_skills_label.setStyleSheet("color: #888888; font-style: italic;")
        self.no_skills_label.setAlignment(Qt.AlignCenter)
        
        skills_layout.addWidget(self.no_skills_label)
        
        # Add skills to main layout
        self.main_layout.addWidget(skills_group)
    
    def _create_equipment_section(self):
        """Create the character equipment section."""
        # Group box for equipment
        equipment_group = QGroupBox("Equipment")
        equipment_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        equipment_layout = QGridLayout(equipment_group)
        
        # Equipment slots
        self.equip_labels = {}
        slots = [
            "Head", "Neck", "Shoulders", "Chest", "Back", "Wrists",
            "Hands", "Waist", "Legs", "Feet", "Main Hand", "Off Hand"
        ]
        
        # Create labels for each slot
        for i, slot in enumerate(slots):
            row = i // 2
            col = i % 2
            
            # Create slot label
            slot_label = QLabel(f"{slot}:")
            slot_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
            
            # Create value label
            value_label = QLabel("None")
            value_label.setStyleSheet("color: #888888; font-style: italic;")
            
            # Store the value label
            self.equip_labels[slot.lower().replace(" ", "_")] = value_label
            
            # Add to layout
            equipment_layout.addWidget(slot_label, row, col * 2)
            equipment_layout.addWidget(value_label, row, col * 2 + 1)
        
        # Add equipment to main layout
        self.main_layout.addWidget(equipment_group)
        
    def update_character(self, character=None):
            """
            Update the character sheet with character data.

            Args:
                character: The character data object (PlayerState). If None, uses current state.
            """
            # Attempt to connect signal if not already connected
            if not self._signal_connected:
                self._connect_stats_signal()

            try:
                # If no character is provided, use the current state
                if character is None:
                    if self.state_manager and self.state_manager.current_state:
                        character = self.state_manager.current_state.player
                        logging.info("Using character from current state")
                    else:
                        logging.warning("No character data available to update character sheet")
                        # Clear stats if no character data
                        self._clear_stat_displays() # Call helper to clear labels/bars
                        return

                # Update character info
                self.name_label.setText(f"Name: {character.name}")
                self.race_class_label.setText(f"Race: {character.race} | Class: {character.path}")

                # Update level and experience
                exp_current = character.experience
                exp_next = character.experience_to_next_level
                self.level_exp_label.setText(f"Level: {character.level} | Experience: {exp_current}/{exp_next}")

                # Update experience bar
                self.exp_bar.setRange(0, exp_next)
                self.exp_bar.setValue(exp_current)

                # Update stats if stats manager is available
                if self.state_manager and self.state_manager.stats_manager:
                    stats_manager = self.state_manager.stats_manager
                    logging.info(f"Found stats manager: {stats_manager}")

                    # Get all stats
                    all_stats = stats_manager.get_all_stats()
                    logging.info(f"All stats data structure: {list(all_stats.keys())}")
                    if 'primary' in all_stats:
                        logging.info(f"Primary stats keys: {list(all_stats['primary'].keys())}")
                    if 'combat' in all_stats:
                        logging.info(f"Combat stats keys: {list(all_stats['combat'].keys())}")
                    if 'resources' in all_stats:
                        logging.info(f"Resources stats keys: {list(all_stats['resources'].keys())}")


                    # Update primary stats
                    if 'primary' in all_stats:
                        primary_stats_log = ", ".join([f"{stat_name}={stat_data.get('value')}" for stat_name, stat_data in all_stats["primary"].items()])
                        logging.info(f"Primary stats values: {primary_stats_log}")
                        self._update_primary_stats(all_stats["primary"])
                    else:
                        logging.warning("Primary stats category not found in stats data.")
                        # Optionally clear primary stat labels here

                    # Update derived stats
                    for category in ["combat", "social", "other"]: # Iterate through relevant categories
                        if category in all_stats:
                            logging.info(f"Updating derived stats for category: {category}")
                            self._update_derived_stats(all_stats[category], category)
                        else:
                            logging.warning(f"Derived stats category '{category}' not found in stats data.")
                            # Optionally clear corresponding derived stat labels here

                    # Update resource bars
                    if "resources" in all_stats:
                        resources_log = ", ".join([f"{res_name}={res_data.get('value')}/{res_data.get('base_value')}" for res_name, res_data in all_stats.get("resources", {}).items()])
                        logging.info(f"Resources stats: {resources_log}")
                        # Pass all_stats to _update_resources
                        self._update_resources(all_stats["resources"], all_player_stats=all_stats)
                    else:
                        logging.warning("Resources category not found in stats data.")
                        # Optionally clear resource bars here

                    # Update combat status displays (status effects, turn order)
                    self._update_combat_status(character)

                else:
                    logging.warning("Stats manager not available during update_character, stats will not be displayed.")
                    # Clear stats if manager not available
                    self._clear_stat_displays() # Call helper

                # Update equipment (placeholder)
                if hasattr(character, 'equipped_items') and self.equip_labels:
                    # Existing equipment logic... (seems okay)
                    for slot_name, item_id in character.equipped_items.items():
                        slot_key = slot_name.lower().replace(' ', '_')
                        if slot_key in self.equip_labels:
                            if item_id:
                                # Placeholder: Get item name from an item manager if available
                                # For now, just show the ID
                                # item_name = get_item_manager().get_item_name(item_id) # Example
                                item_name = f"Item ID: {item_id}" # Current placeholder
                                self.equip_labels[slot_key].setText(item_name)
                                self.equip_labels[slot_key].setStyleSheet("color: #E0E0E0;")
                            else:
                                self.equip_labels[slot_key].setText("None")
                                self.equip_labels[slot_key].setStyleSheet("color: #888888; font-style: italic;")

                # Update portrait if available
                if hasattr(character, 'character_image') and character.character_image:
                    # Existing portrait logic... (seems okay)
                    try:
                        pixmap = QPixmap(character.character_image)
                        if not pixmap.isNull():
                            scaled_pixmap = pixmap.scaled(self.portrait_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            self.portrait_label.setPixmap(scaled_pixmap)
                            self.portrait_label.setStyleSheet("")
                        else:
                            self.portrait_label.setText("Portrait")
                            self.portrait_label.setStyleSheet("color: #888888;")
                    except Exception as image_err:
                        logging.error(f"Error loading character portrait: {image_err}")
                        self.portrait_label.setText("Portrait")
                        self.portrait_label.setStyleSheet("color: #888888;")
                else:
                    self.portrait_label.setText("Portrait")
                    self.portrait_label.setStyleSheet("color: #888888;")

            except Exception as e:
                # Log any errors but don't crash
                logging.error(f"Error updating character sheet: {e}", exc_info=True)

    def _update_combat_status(self, character):
        """Update combat status information.
        This method is now less critical for turn order if TURN_ORDER_UPDATE events are used,
        but kept for fallback and status effects.
        Args:
            character: The player character instance.
        """
        if not character:
            return
            
        from core.base.state import get_state_manager # Local import
        state_manager = get_state_manager()
        if not state_manager or not state_manager.current_state:
            self.status_effects_list.clear()
            self.turn_order_list.setText("Turn Order: N/A") # Default text
            self.initiative_value.setText("0")
            return
            
        game_state = state_manager.current_state
        combat_manager = getattr(game_state, 'combat_manager', None)
        
        # Update status effects (Logic for status effects seems okay, no changes here unless explicitly requested)
        self.status_effects_list.clear()
        status_text = ""
        player_entity_for_effects = None

        if combat_manager:
            player_id_for_lookup = getattr(character, 'id', None) or getattr(character, 'stats_manager_id', None)
            if player_id_for_lookup and player_id_for_lookup in combat_manager.entities:
                player_entity_for_effects = combat_manager.entities[player_id_for_lookup]
        
        source_for_effects = player_entity_for_effects if player_entity_for_effects else character

        if hasattr(source_for_effects, 'status_effects'):
            effects_data = source_for_effects.status_effects
            if isinstance(effects_data, dict):
                for effect_name, duration_data in effects_data.items():
                    duration = None
                    if isinstance(duration_data, int): 
                        duration = duration_data
                    
                    if duration is not None and duration > 0 : 
                        status_text += f"{effect_name} ({duration} turns)\n"
                    elif duration is None: 
                        status_text += f"{effect_name}\n"
            elif isinstance(effects_data, (list, set)):
                for effect_name in effects_data:
                    status_text += f"{effect_name}\n"
        
        self.status_effects_list.setText(status_text.strip())
        
        # Turn order display will be primarily handled by handle_turn_order_update event.
        # This section can act as a fallback or for initial display if no event received yet.
        if not combat_manager:
            self.turn_order_list.setText("Turn Order: N/A (Not in Combat)")
            self.initiative_value.setText("0")
        elif not hasattr(self, '_last_turn_order_event_data') or not self._last_turn_order_event_data:
            # Fallback logic if no TURN_ORDER_UPDATE event has populated the display yet
            logger.debug("CharacterSheet: _update_combat_status using fallback for turn order.")
            turn_text = ""
            if getattr(combat_manager, '_is_surprise_round', False) and hasattr(combat_manager, '_surprise_round_entities') and combat_manager._surprise_round_entities:
                turn_text += "[Surprise Round]\n"
                current_actor_id_for_highlight = getattr(combat_manager, '_active_entity_id', None)
                for entity_id_in_surprise_order in combat_manager._surprise_round_entities:
                    if entity_id_in_surprise_order in combat_manager.entities:
                        entity = combat_manager.entities[entity_id_in_surprise_order]
                        prefix = "→ " if entity_id_in_surprise_order == current_actor_id_for_highlight else "  "
                        turn_text += f"{prefix}{getattr(entity, 'combat_name', entity.name)}\n"
            elif hasattr(combat_manager, 'turn_order') and combat_manager.turn_order: # Regular round
                current_turn_idx = getattr(combat_manager, 'current_turn_index', 0)
                for i, entity_id_in_order in enumerate(combat_manager.turn_order):
                    if entity_id_in_order in combat_manager.entities:
                        entity = combat_manager.entities[entity_id_in_order]
                        is_current_actor_by_index = (i == current_turn_idx)
                        prefix = "→ " if is_current_actor_by_index else "  "
                        turn_text += f"{prefix}{getattr(entity, 'combat_name', entity.name)}\n"
            else:
                turn_text = "Turn Order: Initializing..."
            self.turn_order_list.setText(turn_text.strip())

            player_id_for_initiative = getattr(character, 'id', None) or getattr(character, 'stats_manager_id', None)
            entity_for_initiative_display = combat_manager.entities.get(player_id_for_initiative)
            if entity_for_initiative_display and hasattr(entity_for_initiative_display, 'initiative'):
                initiative_value = getattr(entity_for_initiative_display, 'initiative', 0)
                self.initiative_value.setText(str(int(initiative_value)))
            else:
                self.initiative_value.setText("N/A")

    def _connect_stats_signal(self):
        """Connect to the stats_changed signal of the StatsManager."""
        if self._signal_connected:
            logging.debug("Signal already connected, skipping.")
            return

        try:
            if self.state_manager and self.state_manager.stats_manager:
                stats_manager = self.state_manager.stats_manager
                signal_exists = hasattr(stats_manager, 'stats_changed')

                if signal_exists:
                    try:
                        # Disconnect first to avoid duplicates if connection attempt repeats
                        stats_manager.stats_changed.disconnect(self._update_from_stats)
                    except (TypeError, RuntimeError): # Catch specific Qt signal errors
                        pass # Ignore if not connected

                    stats_manager.stats_changed.connect(self._update_from_stats)
                    self._signal_connected = True
                    logging.info("Connected CharacterSheetWidget to stats_changed signal")
            else:
                 logging.debug("StatsManager not yet available for signal connection.")

        except Exception as e:
            logging.error(f"Failed to connect to stats_changed signal: {e}")
    
    def _update_from_stats(self, stats_data):
        """Update the character sheet directly from stats data provided by the signal."""
        logging.info("Updating character sheet from stats_changed signal")

        try:
            # Provide detailed logging about the stats data received
            if isinstance(stats_data, dict):
                category_counts = {k: len(v) for k, v in stats_data.items() if isinstance(v, dict)}
                logging.info(f"Stats data categories from signal: {category_counts}")
                # ...(rest of logging as before)...

                # Check for empty or invalid stats before proceeding
                has_valid_stats = any(
                    category in stats_data and isinstance(stats_data[category], dict) and stats_data[category]
                    for category in ['primary', 'resources', 'combat', 'social', 'other']
                )

                if not has_valid_stats:
                    logging.warning("Stats data from signal appears empty or invalid.")
                    # Optionally, could trigger a full update here, but might cause loops
                    # self.update_character()
                    return

                # Update primary stats
                if 'primary' in stats_data:
                    self._update_primary_stats(stats_data['primary'])
                    logging.info(f"Updated {len(stats_data['primary'])} primary stats from signal")

                # Update derived stats including combat, social, other
                for category in ['combat', 'social', 'other']:
                    if category in stats_data:
                        self._update_derived_stats(stats_data[category], category)
                        logging.info(f"Updated {len(stats_data[category])} {category} stats from signal")

                # Update resource bars (HP, Mana, Stamina)
                if 'resources' in stats_data:
                    # Pass the full stats_data (which is all_stats) to _update_resources
                    self._update_resources(stats_data['resources'], all_player_stats=stats_data)
                    logging.info(f"Updated {len(stats_data['resources'])} resources from signal")
                
                # Update combat status (turn order, status effects) if player data is available
                if self.state_manager and self.state_manager.current_state and self.state_manager.current_state.player:
                    self._update_combat_status(self.state_manager.current_state.player)
                    logging.info("Updated combat status from stats_changed signal context.")
                else:
                    logging.warning("Could not update combat status from signal: player state unavailable.")


                logging.info("Character sheet updated directly from stats data via signal")
            else:
                # Fallback to full update if data format isn't as expected (less likely now)
                logging.warning(f"Stats data from signal is not a dict: {type(stats_data)}, falling back to full update")
                self.update_character() # Trigger full refresh as fallback

        except Exception as e:
            logging.error(f"Error updating from stats signal: {e}", exc_info=True)
            # Fallback to full update on error
            try:
                self.update_character()
            except Exception as update_err:
                logging.error(f"Fallback update after signal error also failed: {update_err}")
                
    def _update_primary_stats(self, primary_stats):
        """Update just the primary stats from stats data."""
        for stat_name, stat_data in primary_stats.items():
             # stat_name here is expected to be "STR", "DEX", etc.
            if stat_name in self.primary_stat_labels:
                try:
                    stat_value = stat_data.get('value', 0)
                    old_text = self.primary_stat_labels[stat_name].text()
                    new_text = str(int(stat_value)) # Ensure comparison is string vs string

                    if old_text != new_text:
                        self.primary_stat_labels[stat_name].setText(new_text)
                        logging.info(f"Updated primary stat {stat_name} from '{old_text}' to '{new_text}'")

                    # Update tooltip data regardless
                    self.primary_stat_labels[stat_name].update_stat_data(stat_data)
                except Exception as e:
                    logging.error(f"Error updating primary stat {stat_name}: {e}", exc_info=True)
            else:
                 logging.warning(f"Stat key '{stat_name}' from primary stats data not found in UI labels.")
    
    def _update_derived_stats(self, derived_stats, category):
        """Update derived stats from stats data."""
        for stat_name, stat_data in derived_stats.items():
             # stat_name here is expected to be "MELEE_ATTACK", "DEFENSE", etc.
            if stat_name in self.derived_stat_labels:
                try:
                    stat_value = stat_data.get('value', 0)
                    old_text = self.derived_stat_labels[stat_name].text()
                    new_text = str(int(stat_value))

                    if old_text != new_text:
                        self.derived_stat_labels[stat_name].setText(new_text)
                        logging.info(f"Updated {category} stat {stat_name} from '{old_text}' to '{new_text}'")

                    # Update tooltip data regardless
                    self.derived_stat_labels[stat_name].update_stat_data(stat_data)

                    # Special case for initiative display
                    if stat_name == "INITIATIVE":
                        if self.initiative_value.text() != new_text:
                            self.initiative_value.setText(new_text)
                            logging.info(f"Updated initiative display to {new_text}")
                except Exception as e:
                    logging.error(f"Error updating derived stat {stat_name}: {e}", exc_info=True)
            else:
                 logging.warning(f"Stat key '{stat_name}' from {category} stats data not found in UI labels.")
    
    def _update_resources(self, resources: Dict[str, Any], all_player_stats: Optional[Dict[str, Any]] = None):
        """
        Update resource bars. During COMBAT, current values for HP, Mana, Stamina are primarily
        updated via orchestrated events (player_resource_bar_update_phaseX). This method will
        still update MAX values and, outside of combat, current values directly.
        """
        resource_key_map = {
            "HEALTH": "health", "MANA": "mana", "STAMINA": "stamina",
            "RESOLVE": "resolve" 
        }
        max_resource_map = {
            "HEALTH": "MAX_HEALTH", "MANA": "MAX_MANA", 
            "STAMINA": "MAX_STAMINA", "RESOLVE": "MAX_RESOLVE" 
        }

        for stat_name_key, resource_data in resources.items():
            ui_key = resource_key_map.get(stat_name_key.upper()) 

            if ui_key and ui_key in self.resource_bars:
                label, bar = self.resource_bars[ui_key]
                
                game_mode = InteractionMode.NARRATIVE # Default
                if self.state_manager and self.state_manager.current_state:
                    game_mode = self.state_manager.current_state.current_mode
                
                try:
                    current_value_from_model = int(resource_data.get('value', 0)) # Actual current value from stats model
                    max_stat_name_key = max_resource_map.get(stat_name_key.upper())
                    
                    # Determine Max Value (this should always reflect the true current max)
                    max_value_from_model = bar.maximum() if bar.maximum() > 0 else 100 
                    if all_player_stats and max_stat_name_key:
                        found_max_in_all_stats = False
                        for category_key in ['resources', 'other', 'primary', 'combat', 'social']: 
                            if category_key in all_player_stats and max_stat_name_key in all_player_stats[category_key]:
                                max_value_from_model = int(all_player_stats[category_key][max_stat_name_key].get('value', max_value_from_model))
                                found_max_in_all_stats = True
                                break
                        if not found_max_in_all_stats:
                           logger.warning(f"MAX stat {max_stat_name_key} not found in all_player_stats for {stat_name_key} in _update_resources. Using bar's current max.")
                    elif 'base_value' in resource_data and stat_name_key.upper().startswith("MAX_"): 
                         max_value_from_model = int(resource_data.get('base_value', max_value_from_model))
                    
                    max_value_from_model = max(1, max_value_from_model) 
                    display_name = resource_data.get("name", ui_key.capitalize()) 

                    # Always update the bar's range if the max value from model has changed
                    if bar.maximum() != max_value_from_model:
                        bar.setRange(0, max_value_from_model)
                        logger.info(f"CharacterSheet: {ui_key} bar max updated to {max_value_from_model} via _update_resources (model changed).")
                        # If max changed, the label will need updating too, unless an animation is active
                        if not (game_mode == InteractionMode.COMBAT and ui_key in self._pending_player_bar_updates):
                            current_display_val = bar.value() if game_mode == InteractionMode.COMBAT and ui_key in self._pending_player_bar_updates and self._pending_player_bar_updates[ui_key].get('phase1_preview_value') is not None else current_value_from_model
                            label.setText(f"{display_name}: {int(current_display_val)}/{max_value_from_model}")


                    # Handle current value updates
                    if game_mode == InteractionMode.COMBAT:
                        # In COMBAT, current value updates for HP, Mana, Stamina are driven by phase1/phase2 events.
                        # This method, when called by stats_changed, should not directly set the current value
                        # for these, to avoid conflicts with the animation.
                        # It only ensures MAX is correct. Resolve, if not animated, could be updated here.
                        if ui_key == "resolve": # Example: Resolve updates directly if not animated
                             if bar.value() != current_value_from_model: bar.setValue(current_value_from_model)
                             label.setText(f"{display_name}: {current_value_from_model}/{max_value_from_model}")
                        else:
                             logger.debug(f"CharacterSheet: In COMBAT, _update_resources deferring current value update for {ui_key} to orchestration.")
                             # If a phase1 animation is active, the label might show "X -> Y".
                             # If max_value changed, it's already updated above.
                             # If no animation is active, the label might be stale until phase1/2.
                             # Let's ensure label reflects at least the old value against new max if max changed.
                             if bar.maximum() == max_value_from_model and ui_key not in self._pending_player_bar_updates:
                                  current_on_bar = bar.value() # What the bar visually shows
                                  if label.text() != f"{display_name}: {int(current_on_bar)}/{max_value_from_model}":
                                       label.setText(f"{display_name}: {int(current_on_bar)}/{max_value_from_model}")


                    else: # Not in COMBAT mode, update directly
                        if bar.value() != current_value_from_model:
                            bar.setValue(current_value_from_model)
                        
                        new_text_direct = f"{display_name}: {current_value_from_model}/{max_value_from_model}"
                        if label.text() != new_text_direct:
                            label.setText(new_text_direct)
                        
                        # If there was any pending animation from a previous mode (unlikely but possible), clear it.
                        if ui_key in self._pending_player_bar_updates:
                            self._pending_player_bar_updates.pop(ui_key, None)
                        
                        logger.debug(f"CharacterSheet: Directly updated {ui_key} to {current_value_from_model}/{max_value_from_model} via _update_resources (not in combat).")
                    
                except Exception as e:
                    logging.error(f"CharacterSheet: Error updating resource bar for {stat_name_key} in _update_resources: {e}", exc_info=True)
            elif ui_key:
                logging.warning(f"UI key '{ui_key}' (from resource '{stat_name_key}') not found in self.resource_bars.")

    def _clear_stat_displays(self):
        """Helper method to reset all stat displays to default/empty."""
        logging.debug("Clearing character sheet stat displays.")
        # Clear primary stats
        for label in self.primary_stat_labels.values():
            label.setText("0") # Or "?" or ""
            label.update_stat_data({}) # Clear tooltip data

        # Clear derived stats
        for label in self.derived_stat_labels.values():
            label.setText("0") # Or "?" or ""
            label.update_stat_data({}) # Clear tooltip data

        # Clear resource bars
        for label, bar in self.resource_bars.values():
            label.setText(f"{label.text().split(':')[0]}: 0/0") # Keep name, reset values
            bar.setRange(0, 100) # Reset range
            bar.setValue(0) # Reset value

        # Clear initiative display
        self.initiative_value.setText("0")

        # Clear combat status
        self.status_effects_list.clear()
        self.turn_order_list.clear()
    
    def showEvent(self, event):
        """Handler called when widget is shown."""
        super().showEvent(event)

    @Slot(str, dict)
    def animate_resource_bar_ui_bar_update_phase1(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a bar update: show impending loss/gain.
        bar_type_key: "hp", "stamina", "mana", "resolve"
        update_data: { "old_value": X, "new_value_preview": Y, "max_value": M }
        """
        bar_type_key_internal = bar_type_key
        if bar_type_key == "hp": # Normalize "hp" to "health" for internal lookup
            bar_type_key_internal = "health"
        
        if bar_type_key_internal not in self.resource_bars:
            logging.warning(f"CharacterSheet: Bar type '{bar_type_key_internal}' (from original key '{bar_type_key}') not found for phase 1 animation.")
            return

        label, bar = self.resource_bars[bar_type_key_internal]
        new_value_preview = update_data.get("new_value_preview")
        max_value = update_data.get("max_value")
        
        if new_value_preview is None or max_value is None:
            logging.error(f"CharacterSheet: Missing new_value_preview or max_value for phase 1 of {bar_type_key_internal}")
            return
            
        is_loss = new_value_preview < bar.value()

        logging.debug(f"CharacterSheet: Phase 1 Anim for {bar_type_key_internal} - Preview: {new_value_preview}/{max_value}")

        display_name = label.text().split(':')[0] 
        label.setText(f"{display_name}: {bar.value()}/{max_value} -> {new_value_preview}/{max_value}")
        
        self._pending_bar_updates[bar_type_key_internal] = {
            "final_value": new_value_preview,
            "max_value": max_value,
            "is_loss": is_loss
        }

    @Slot(str, dict)
    def animate_resource_bar_ui_bar_update_phase2(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a bar update: finalize the bar to its new value.
        bar_type_key: "hp", "stamina", "mana", "resolve"
        update_data: { "final_new_value": Y, "max_value": M } (or use stored from pending)
        """
        bar_type_key_internal = bar_type_key
        if bar_type_key == "hp": # Normalize "hp" to "health" for internal lookup
            bar_type_key_internal = "health"

        if bar_type_key_internal not in self.resource_bars:
            logging.warning(f"CharacterSheet: Bar type '{bar_type_key_internal}' (from original key '{bar_type_key}') not found for phase 2 animation.")
            return
        
        pending_data = self._pending_bar_updates.pop(bar_type_key_internal, None)
        final_value = update_data.get("final_new_value", pending_data.get("final_value") if pending_data else None)
        max_value = update_data.get("max_value", pending_data.get("max_value") if pending_data else None)

        if final_value is None or max_value is None:
            # Attempt to get current value from bar if update_data is incomplete and no pending_data
            label_fallback, bar_fallback = self.resource_bars[bar_type_key_internal]
            final_value_fb = bar_fallback.value()
            max_value_fb = bar_fallback.maximum()

            if final_value is None: final_value = final_value_fb
            if max_value is None: max_value = max_value_fb
            
            logging.warning(f"CharacterSheet: Missing final_value or max_value for phase 2 of {bar_type_key_internal}. Using current/fallback: {final_value}/{max_value}")
            # Do not return; attempt to update with best available info.

        logging.debug(f"CharacterSheet: Phase 2 Anim for {bar_type_key_internal} - Final: {final_value}/{max_value}")

        label, bar = self.resource_bars[bar_type_key_internal]
        # Try to get original name part, handle cases where "->" might not be present
        original_name_part_match = re.match(r"([^:]+):", label.text())
        display_name = original_name_part_match.group(1).strip() if original_name_part_match else bar_type_key_internal.capitalize()


        label.setText(f"{display_name}: {int(final_value)}/{int(max_value)}")
        if bar.maximum() != int(max_value):
            bar.setRange(0, int(max_value))
        bar.setValue(int(final_value))

        logging.debug(f"CharacterSheet: {bar_type_key_internal} bar finalized to {int(final_value)}/{int(max_value)}")

    def _finalize_bar_animation(self, bar_type_key: str):
        """Helper to finalize a bar after a QTimer, if used internally (less common now)."""
        # This method is less likely to be used if Orchestrator handles delays.
        # Kept for potential future internal animation needs.
        if bar_type_key in self._pending_bar_updates:
            data = self._pending_bar_updates.pop(bar_type_key)
            self.animate_resource_bar_ui_bar_update_phase2(bar_type_key, {"final_new_value": data["final_value"], "max_value": data["max_value"]})

    @Slot(dict)
    def handle_turn_order_update(self, event_data: Dict[str, Any]):
        """
        Handles TURN_ORDER_UPDATE events from the orchestrator to update
        the turn order display and player initiative.
        """
        logger.info(f"CharacterSheet received TURN_ORDER_UPDATE: {event_data}")
        self._last_turn_order_event_data = event_data # Store for fallback if needed

        turn_text = ""
        is_surprise = event_data.get("is_surprise", False)
        round_num = event_data.get("round_number", "")
        turn_order_display_list = event_data.get("turn_order_display_list", []) # This should contain pre-formatted strings with "→"
        active_entity_name = event_data.get("active_entity_combat_name", "") # For initiative context

        if is_surprise:
            turn_text += f"[Surprise Round]\n"
        elif round_num:
            turn_text += f"Round {round_num}\n"
        
        if turn_order_display_list:
            turn_text += "\n".join(turn_order_display_list)
        else:
            turn_text += "Turn order not yet determined."

        self.turn_order_list.setText(turn_text.strip())

        # Update player's initiative display
        # If player is in the turn_order_display_list, try to extract their initiative
        # This assumes player's combat name is consistent
        player_id = getattr(self.state_manager.current_state.player, 'id', None) or getattr(self.state_manager.current_state.player, 'stats_manager_id', None)
        player_combat_name = getattr(self.state_manager.current_state.player, 'name', "Player") # Fallback
        
        # Get CombatManager to access player's CombatEntity for initiative
        combat_manager = getattr(self.state_manager.current_state, 'combat_manager', None)
        if combat_manager and player_id:
            player_combat_entity = combat_manager.entities.get(player_id)
            if player_combat_entity and hasattr(player_combat_entity, 'initiative'):
                self.initiative_value.setText(str(int(player_combat_entity.initiative)))
            else:
                self.initiative_value.setText("N/A")
        elif combat_manager: # Player ID not found, but CM exists
             self.initiative_value.setText("N/A (Player not in combat)")
        else: # Not in combat
            self.initiative_value.setText("0")

    @Slot(str, dict)
    def player_resource_bar_update_phase1(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a player's resource bar update: show impending loss/gain in label.
        bar_type_key: "hp", "stamina", "mana", "resolve" (from event metadata)
        update_data: { "old_value": X, "new_value_preview": Y, "max_value": M, "entity_id": player_id }
        """
        logger.debug(f"CharacterSheet: Player Phase 1 Anim for event bar_type '{bar_type_key}' - Data: {update_data}")
        
        event_to_internal_key_map = {"hp": "health", "mp": "mana", "stamina": "stamina", "resolve": "resolve"}
        internal_ui_key = event_to_internal_key_map.get(bar_type_key.lower(), bar_type_key.lower())

        if internal_ui_key not in self.resource_bars:
            logging.warning(f"CharacterSheet: Player bar type '{internal_ui_key}' (mapped from event '{bar_type_key}') not found for phase 1 animation.")
            return

        label, bar = self.resource_bars[internal_ui_key]
        
        new_value_preview = update_data.get("new_value_preview")
        max_value = update_data.get("max_value")
        
        if new_value_preview is None or max_value is None:
            logging.error(f"CharacterSheet: Missing new_value_preview or max_value for player phase 1 of {internal_ui_key}")
            return

        current_bar_visual_value = bar.value() 
        
        display_name_match = re.match(r"([^:]+):", label.text())
        display_name = display_name_match.group(1).strip() if display_name_match else internal_ui_key.capitalize()
        
        label.setText(f"{display_name}: {int(current_bar_visual_value)}/{int(max_value)} -> {int(new_value_preview)}/{int(max_value)}")
        
        if bar.maximum() != int(max_value):
            bar.setRange(0, int(max_value))
            logger.info(f"CharacterSheet (Phase1): {internal_ui_key} bar max updated to {max_value}")

        self._pending_player_bar_updates[internal_ui_key] = {
            "final_value": new_value_preview, 
            "max_value": max_value,
            "phase1_preview_value": current_bar_visual_value 
        }

    @Slot(str, dict)
    def player_resource_bar_update_phase2(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a player's resource bar update: finalize the bar to its new value.
        bar_type_key: "hp", "stamina", "mana", "resolve" (from event metadata)
        update_data: { "final_new_value": Y, "max_value": M, "entity_id": player_id }
        """
        event_to_internal_key_map = {"hp": "health", "mp": "mana", "stamina": "stamina", "resolve": "resolve"}
        internal_ui_key = event_to_internal_key_map.get(bar_type_key.lower(), bar_type_key.lower())

        logger.debug(f"CharacterSheet: Player Phase 2 Anim for internal_ui_key '{internal_ui_key}' (from event '{bar_type_key}') - Data: {update_data}")

        if internal_ui_key not in self.resource_bars:
            logging.warning(f"CharacterSheet: Player bar type '{internal_ui_key}' (mapped from event '{bar_type_key}') not found for phase 2 animation.")
            if internal_ui_key in self._pending_player_bar_updates:
                self._pending_player_bar_updates.pop(internal_ui_key, None)
            return
        
        pending_data = self._pending_player_bar_updates.pop(internal_ui_key, None)
        
        label, bar = self.resource_bars[internal_ui_key]

        final_value = update_data.get("final_new_value")
        max_val = update_data.get("max_value")

        if final_value is None:
            if pending_data and "final_value" in pending_data:
                final_value = pending_data["final_value"]
            else: 
                final_value = bar.value() 
                logger.warning(f"CharacterSheet (Phase2): for {internal_ui_key} missing final_new_value. Using current bar value {final_value}.")
        
        if max_val is None:
            if pending_data and "max_value" in pending_data:
                max_val = pending_data["max_value"]
            else: 
                max_val = bar.maximum()
                logger.warning(f"CharacterSheet (Phase2): for {internal_ui_key} missing max_value. Using current bar max {max_val}.")
        
        final_value = int(final_value)
        max_val = int(max_val)
        max_val = max(1, max_val)

        current_label_text = label.text()
        display_name_match = re.match(r"([^:]+):", current_label_text)
        display_name = display_name_match.group(1).strip() if display_name_match else internal_ui_key.capitalize()

        label.setText(f"{display_name}: {final_value}/{max_val}")
        if bar.maximum() != max_val: 
            bar.setRange(0, max_val)
        bar.setValue(final_value)

        logger.debug(f"CharacterSheet: Player {internal_ui_key} bar finalized to {final_value}/{max_val}")
```

### File: ..\gui\components\combat_display.py

```python
#!/usr/bin/env python3
"""
Combat display component for the RPG game.

This module provides a GUI component for displaying combat status and log,
with customizable appearance settings.
"""

import json
import logging
import os
import re # Added for stylesheet manipulation
from typing import Dict, Iterator, List, Any, Optional, Callable, Tuple
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit,
    QGroupBox, QProgressBar, QScrollArea, QFrame, QSizePolicy, QPushButton,
    QDialog # Added for placeholder dialog
)
from PySide6.QtCore import QSettings, Signal, Slot, QTimer
from PySide6.QtGui import QColor, QTextCharFormat, QFont, QTextCursor, QFontDatabase

from core.base.engine import get_game_engine
from core.interaction.enums import InteractionMode # Added QFontDatabase
from ..dialogs.combat_settings_dialog import CombatSettingsDialog

# Assuming core is in the parent directory of gui
# Adjust if your project structure is different
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))

# Configuration Constants - Adjusted paths based on project structure
CONFIG_DIR = os.path.join(project_root, "config")
SETTINGS_FILE = os.path.join(CONFIG_DIR, "combat_display_settings.json")
IMAGE_DIR = os.path.join(project_root, "images", "gui", "combat_display") # Path to background images

# Ensure directories exist
os.makedirs(CONFIG_DIR, exist_ok=True)
os.makedirs(IMAGE_DIR, exist_ok=True) # Create image dir if it doesn't exist

# Import after defining project_root if necessary for other modules
from core.utils.logging_config import get_logger
from core.combat.enums import CombatState
from core.combat.combat_entity import EntityType
from core.stats.stats_base import DerivedStatType
from core.base.state import GameState
from core.stats.stats_manager import get_stats_manager

# Get the module logger
logger = get_logger("GUI")

class CombatEntityWidget(QWidget):
    """Widget for displaying a combat entity status."""

    def __init__(self, entity_id: str, name: str, settings: dict, is_player: bool = False, parent=None):
        """Initialize the combat entity widget."""
        super().__init__(parent)

        self.entity_id = entity_id
        self.is_player = is_player
        self.settings = settings

        self._bar_animation_timer = QTimer(self)
        self._bar_animation_timer.setSingleShot(True)
        self._bar_animation_timer.timeout.connect(self._finalize_bar_update)
        self._pending_bar_update_data: Optional[Dict[str, Any]] = None


        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(2)

        self.name_label = QLabel(name)
        layout.addWidget(self.name_label)

        # HP Bar
        self.hp_widget_container = QWidget() # Container for HP bar and label
        hp_layout = QHBoxLayout(self.hp_widget_container)
        hp_layout.setContentsMargins(0, 0, 0, 0); hp_layout.setSpacing(5)
        self.hp_bar = QProgressBar()
        self.hp_bar.setRange(0, 100); self.hp_bar.setValue(100) 
        self.hp_bar.setTextVisible(True); self.hp_bar.setFormat("%v / %m")
        self.hp_label = QLabel("HP:")
        hp_layout.addWidget(self.hp_label); hp_layout.addWidget(self.hp_bar)
        layout.addWidget(self.hp_widget_container) # Add container to main layout

        # Stamina Bar
        self.stamina_widget_container = QWidget() # Container for stamina bar and label
        stamina_layout = QHBoxLayout(self.stamina_widget_container)
        stamina_layout.setContentsMargins(0, 0, 0, 0); stamina_layout.setSpacing(5)
        self.stamina_bar = QProgressBar() 
        self.stamina_bar.setRange(0, 100); self.stamina_bar.setValue(100) 
        self.stamina_bar.setTextVisible(True); self.stamina_bar.setFormat("%v / %m")
        self.stamina_label = QLabel("Stamina:") 
        stamina_layout.addWidget(self.stamina_label); stamina_layout.addWidget(self.stamina_bar)
        layout.addWidget(self.stamina_widget_container) # Add container to main layout

        # Mana Bar 
        self.mana_widget_container = QWidget() # Container for mana bar and label
        mana_layout = QHBoxLayout(self.mana_widget_container) 
        mana_layout.setContentsMargins(0, 0, 0, 0); mana_layout.setSpacing(5)
        self.mana_bar = QProgressBar()
        self.mana_bar.setRange(0, 1); self.mana_bar.setValue(0) # Default to 0/1
        self.mana_bar.setTextVisible(True); self.mana_bar.setFormat("%v / %m")
        self.mana_label = QLabel("Mana:")
        mana_layout.addWidget(self.mana_label); mana_layout.addWidget(self.mana_bar)
        layout.addWidget(self.mana_widget_container) # Add container to main layout

        # Status Effects
        self.status_widget_container = QWidget() # Container for status label and text
        status_layout = QHBoxLayout(self.status_widget_container)
        status_layout.setContentsMargins(0, 0, 0, 0); status_layout.setSpacing(5)
        self.status_label_title = QLabel("Status:")
        status_layout.addWidget(self.status_label_title)
        self.status_text = QLabel("") 
        status_layout.addWidget(self.status_text); status_layout.addStretch()
        layout.addWidget(self.status_widget_container) # Add container to main layout

        self.setMinimumHeight(110) 
        self.setMinimumWidth(250 if is_player else 200)
        self.update_style(self.settings)

    def update_stats(self, current_hp: int, max_hp: int,
                    current_stamina: int, max_stamina: int,
                    status_effects: Optional[List[str]] = None,
                    current_mana: Optional[int] = None, max_mana: Optional[int] = None):
        """Update the entity stats display. This is now the final update (Phase 2)."""
        
        old_hp = self.hp_bar.value()
        # Ensure HP bar is always visible if HP stat is relevant
        self.hp_widget_container.setVisible(True) # Make container visible
        self.hp_bar.setRange(0, max_hp if max_hp > 0 else 1) 
        self.hp_bar.setValue(current_hp)
        self.hp_bar.setFormat(f"{current_hp} / {max_hp}")
        self._update_hp_bar_color(current_hp, max_hp) 

        if old_hp != current_hp:
            logger.debug(f"EntityWidget {self.entity_id} HP directly updated to {current_hp}/{max_hp}")

        old_stamina = self.stamina_bar.value()
        if max_stamina > 0:
            self.stamina_widget_container.setVisible(True) # Make container visible
            self.stamina_bar.setRange(0, max_stamina)
            self.stamina_bar.setValue(current_stamina)
            self.stamina_bar.setFormat(f"{current_stamina} / {max_stamina}")
        else: 
            self.stamina_widget_container.setVisible(False) # Hide whole container
        
        if old_stamina != current_stamina:
            logger.debug(f"EntityWidget {self.entity_id} Stamina directly updated to {current_stamina}/{max_stamina}")

        if current_mana is not None and max_mana is not None:
            old_mana = self.mana_bar.value()
            if max_mana > 0:
                self.mana_widget_container.setVisible(True) # Make container visible
                self.mana_bar.setRange(0, max_mana)
                self.mana_bar.setValue(current_mana)
                self.mana_bar.setFormat(f"{current_mana} / {max_mana}")
            else: 
                self.mana_widget_container.setVisible(False) # Hide whole container
            
            if old_mana != current_mana:
                logger.debug(f"EntityWidget {self.entity_id} Mana directly updated to {current_mana}/{max_mana}")
        else: 
            self.mana_widget_container.setVisible(False) # Hide container if no mana data

        if status_effects:
            self.status_widget_container.setVisible(True) # Make container visible
            self.status_text.setText(", ".join(status_effects))
        else:
            self.status_widget_container.setVisible(True) # Still show "Status: None"
            self.status_text.setText("None")

    def _update_hp_bar_color(self, current_hp: int, max_hp: int):
        """Helper method to update HP bar color based on settings."""
        hp_percent = (current_hp / max_hp) * 100 if max_hp > 0 else 0
        style_sheet = self.hp_bar.styleSheet() # Get current base style
        chunk_style = ""

        # Use settings for colors
        critical_color = self.settings.get("color_hp_bar_chunk_critical", "#990000")
        low_color = self.settings.get("color_hp_bar_chunk_low", "#cc0000")
        normal_color = self.settings.get("color_hp_bar_chunk_normal", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)")

        if hp_percent < self.settings.get("hp_threshold_critical", 25): # Make threshold configurable? (Future idea)
            chunk_color = critical_color
        elif hp_percent < self.settings.get("hp_threshold_low", 50): # Make threshold configurable? (Future idea)
            chunk_color = low_color
        else:
            chunk_color = normal_color

        chunk_style = f"background-color: {chunk_color};"

        # Find and replace the chunk part of the stylesheet
        # This assumes the base style is set correctly in update_style
        new_style_sheet = re.sub(r"(QProgressBar::chunk\s*{)[^}]*(})",
                                 r"\1 " + chunk_style + r" \2",
                                 style_sheet, count=1, flags=re.IGNORECASE | re.DOTALL)

        if new_style_sheet != style_sheet: # Apply only if changed
            self.hp_bar.setStyleSheet(new_style_sheet)

    def setFrameStyle(self, active=False):
        """Set the frame style based on entity type, active state, and settings."""
        if self.is_player:
            if active:
                bg_color = self.settings.get("color_entity_player_bg_active", "rgba(200, 220, 255, 80)")
                border_color = self.settings.get("color_entity_player_border_active", "#00aaff")
                border_width = 3
            else:
                bg_color = self.settings.get("color_entity_player_bg", "rgba(200, 220, 255, 30)")
                border_color = self.settings.get("color_entity_player_border", "#0077cc")
                border_width = 2
        else: # Enemy
            if active:
                bg_color = self.settings.get("color_entity_enemy_bg_active", "rgba(255, 200, 200, 80)")
                border_color = self.settings.get("color_entity_enemy_border_active", "#ff5500")
                border_width = 3
            else:
                bg_color = self.settings.get("color_entity_enemy_bg", "rgba(255, 200, 200, 30)")
                border_color = self.settings.get("color_entity_enemy_border", "#cc0000")
                border_width = 2

        explicit_text_color = self.settings.get("color_groupbox_title_text", "#FFFFFF")

        self.setStyleSheet(f"""
            CombatEntityWidget {{
                border: {border_width}px solid {border_color};
                border-radius: 5px;
                background-color: {bg_color};
                /* color: {explicit_text_color}; */ /* Removing this default color for the widget itself */
            }}
            /* QLabel styling will be handled in update_style or by direct application */
        """)
        
        self.name_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.hp_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.stamina_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.status_label_title.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.status_text.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")

    def highlight_active(self, active: bool = True):
        """Highlight the entity if it's their turn, using settings."""
        self.setFrameStyle(active=active)

    def update_style(self, settings: dict):
        """Update the widget's style based on the provided settings."""
        self.settings = settings
        # is_active_currently = False # Not needed here, setFrameStyle handles active state

        base_font_family = self.settings.get("font_family", "Arial")
        base_font_size = self.settings.get("font_size", 10)

        label_text_color = self.settings.get("color_groupbox_title_text", "#FFFFFF")

        name_font = QFont(base_font_family, base_font_size)
        name_font.setBold(True)
        if self.is_player: name_font.setPointSize(base_font_size + self.settings.get("font_size_player_name_offset", 1))
        self.name_label.setFont(name_font)
        self.name_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")


        base_font = QFont(base_font_family, base_font_size)
        self.hp_label.setFont(base_font)
        self.hp_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.stamina_label.setFont(base_font) 
        self.stamina_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")
        
        self.mana_label.setFont(base_font) 
        self.mana_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.status_label_title.setFont(base_font)
        self.status_label_title.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.status_text.setFont(base_font)
        self.status_text.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        hp_chunk_normal = self.settings.get("color_hp_bar_chunk_normal", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)")
        stamina_chunk = self.settings.get("color_stamina_bar_chunk", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #66CC33, stop:1 #44AA22)")
        mana_chunk = self.settings.get("color_mana_bar_chunk", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #3366CC, stop:1 #2244AA)") 
        pb_text_color = self.settings.get("color_progressbar_text", "#FFFFFF") 
        pb_bg_color = self.settings.get("color_progressbar_bg", "#555555") 

        pb_base_style = f"""
            QProgressBar {{
                border: 1px solid #444; border-radius: 3px; text-align: center;
                height: 18px; color: {pb_text_color}; background-color: {pb_bg_color};
            }}
        """
        self.hp_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {hp_chunk_normal}; }}")
        self.stamina_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {stamina_chunk}; }}")
        self.mana_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {mana_chunk}; }}") 

        self.setFrameStyle(active=False) # Apply default inactive frame style

        current_hp = self.hp_bar.value(); max_hp = self.hp_bar.maximum()
        self._update_hp_bar_color(current_hp, max_hp)
        self.update()
        
    @Slot(dict)
    def animate_ui_bar_update_phase1(self, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a bar update: show impending loss.
        update_data: { "bar_type": "hp"|"stamina"|"mana", "old_value": X, "new_value_preview": Y, "max_value": M }
        """
        bar_type = update_data.get("bar_type")
        new_value_preview = update_data.get("new_value_preview") 
        max_value = update_data.get("max_value")

        logger.debug(f"EntityWidget {self.entity_id} PHASE 1 ANIM: {bar_type} to preview {new_value_preview}/{max_value}")

        target_bar = None
        original_stylesheet = ""
        bleak_color_key_suffix = "_bleak" # e.g. color_hp_bar_chunk_normal_bleak

        if bar_type == "hp": 
            target_bar = self.hp_bar
            hp_percent_preview = (new_value_preview / max_value) * 100 if max_value > 0 else 0
            if hp_percent_preview < self.settings.get("hp_threshold_critical", 25): bleak_color_key = "color_hp_bar_chunk_critical" + bleak_color_key_suffix
            elif hp_percent_preview < self.settings.get("hp_threshold_low", 50): bleak_color_key = "color_hp_bar_chunk_low" + bleak_color_key_suffix
            else: bleak_color_key = "color_hp_bar_chunk_normal" + bleak_color_key_suffix
        elif bar_type == "stamina": 
            target_bar = self.stamina_bar
            bleak_color_key = "color_stamina_bar_chunk" + bleak_color_key_suffix
        elif bar_type == "mana": # NEW for Mana
            target_bar = self.mana_bar
            bleak_color_key = "color_mana_bar_chunk" + bleak_color_key_suffix # Assuming similar setting key
        else:
            logger.warning(f"EntityWidget {self.entity_id}: Unknown bar_type '{bar_type}' for phase 1 animation.")
            if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'): # Ensure orchestrator can proceed
                QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
            return

        if target_bar and new_value_preview is not None and max_value is not None:
            original_stylesheet = target_bar.styleSheet() # Store current full stylesheet
            
            bleak_color = self.settings.get(bleak_color_key, "#777777A0") # Default semi-transparent gray

            new_chunk_style = f"background-color: {bleak_color};"
            # Replace only the background-color of the chunk part
            updated_stylesheet = re.sub(r"(QProgressBar::chunk\s*{\s*background-color:\s*)[^;]+(;[^}]*})",
                                        rf"\1{bleak_color}\2",
                                        original_stylesheet, count=1, flags=re.IGNORECASE | re.DOTALL)
            if not re.search(r"QProgressBar::chunk\s*{", updated_stylesheet, re.IGNORECASE): # If no chunk style existed
                base_pb_style = re.match(r"(QProgressBar\s*{[^}]*})", original_stylesheet, re.IGNORECASE | re.DOTALL)
                if base_pb_style:
                    updated_stylesheet = base_pb_style.group(1) + f" QProgressBar::chunk {{ {new_chunk_style} }}"
                else: # Fallback: just append
                    updated_stylesheet = original_stylesheet + f" QProgressBar::chunk {{ {new_chunk_style} }}"


            target_bar.setStyleSheet(updated_stylesheet)
            target_bar.setFormat(f"{new_value_preview} / {max_value} (...)") # Indicate change

            self._pending_bar_update_data = {
                "bar_type": bar_type,
                "final_value": new_value_preview, # This is preview, Phase2 will get actual final
                "max_value": max_value,
                "original_stylesheet": original_stylesheet 
            }
        else:
            logger.warning(f"Could not animate phase 1 for {self.entity_id}, bar_type: {bar_type}, data: {update_data}")

        # Visual update is considered complete for Phase 1 after style is set.
        if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
            QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
    @Slot(dict)
    def animate_ui_bar_update_phase2(self, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a bar update: finalize the bar to its new value.
        update_data: { "bar_type": "hp"|"stamina"|"mana", "final_new_value": Y, "max_value": M }
        """
        bar_type = update_data.get("bar_type")
        final_value = update_data.get("final_new_value")
        max_value = update_data.get("max_value")
        
        logger.debug(f"EntityWidget {self.entity_id} PHASE 2 ANIM: {bar_type} to final {final_value}/{max_value}")

        target_bar = None
        if bar_type == "hp": target_bar = self.hp_bar
        elif bar_type == "stamina": target_bar = self.stamina_bar
        elif bar_type == "mana": target_bar = self.mana_bar # NEW for Mana
        else:
            logger.warning(f"EntityWidget {self.entity_id}: Unknown bar_type '{bar_type}' for phase 2 animation.")
            if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
                QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
            return

        if target_bar and final_value is not None and max_value is not None:
            # Restore original base stylesheet if it was stored and modified for bleak color
            if self._pending_bar_update_data and self._pending_bar_update_data.get("bar_type") == bar_type:
                original_style = self._pending_bar_update_data.get("original_stylesheet")
                if original_style:
                    target_bar.setStyleSheet(original_style) # Restore base before applying final color logic
            
            # Call update_stats to set value and apply final color logic
            # Need to fetch other stats if update_stats requires all of them
            # For simplicity, assuming update_stats can handle partial updates or we reconstruct args
            if bar_type == "hp":
                self.update_stats(final_value, max_value, self.stamina_bar.value(), self.stamina_bar.maximum(), current_mana=self.mana_bar.value(), max_mana=self.mana_bar.maximum())
            elif bar_type == "stamina":
                self.update_stats(self.hp_bar.value(), self.hp_bar.maximum(), final_value, max_value, current_mana=self.mana_bar.value(), max_mana=self.mana_bar.maximum())
            elif bar_type == "mana": # NEW for Mana
                self.update_stats(self.hp_bar.value(), self.hp_bar.maximum(), self.stamina_bar.value(), self.stamina_bar.maximum(), current_mana=final_value, max_mana=max_value)

            
            target_bar.setFormat(f"{final_value} / {max_value}") # Ensure format is correct
            logger.debug(f"EntityWidget {self.entity_id} {bar_type} bar finalized to {final_value}/{max_value}")
        else:
            logger.warning(f"Could not animate phase 2 for {self.entity_id}, bar_type: {bar_type}, data: {update_data}")
            
        self._pending_bar_update_data = None 
        
        if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
            QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)

    @Slot()
    def _finalize_bar_update(self):
        """Actually updates the bar value and color after the delay (Old method, for reference if needed)."""
        # This method is less used now as Orchestrator controls delays and Phase 2 trigger.
        # Kept for potential direct use or if animation needs its own timer.
        if self._pending_bar_update_data:
            bar_type = self._pending_bar_update_data["bar_type"]
            final_value = self._pending_bar_update_data["final_value"]
            max_value = self._pending_bar_update_data["max_value"]
            # original_stylesheet = self._pending_bar_update_data["original_stylesheet"] # Not used if update_stats handles colors

            target_bar = None
            if bar_type == "hp": target_bar = self.hp_bar
            elif bar_type == "stamina": target_bar = self.stamina_bar

            if target_bar:
                # target_bar.setStyleSheet(original_stylesheet) # Restore base if needed
                target_bar.setValue(final_value)
                target_bar.setFormat(f"{final_value} / {max_value}")
                if bar_type == "hp": self._update_hp_bar_color(final_value, max_value)
                # Add similar for stamina if it has dynamic coloring

            self._pending_bar_update_data = None

class CombatDisplay(QWidget):
    """Widget for displaying combat status and log."""

    # --- ECFA Change: Add visualDisplayComplete signal ---
    visualDisplayComplete = Signal()
    # --- End ECFA Change ---

    def __init__(self, parent=None):
        """Initialize the combat display widget."""
        super().__init__(parent)

        self.setObjectName("combatDisplayWidget")

        self.entity_widgets: Dict[str, CombatEntityWidget] = {}
        self.combat_active = False 
        self.stats_manager = get_stats_manager() 
        self.current_settings: Dict[str, Any] = {} 

        self.load_settings()

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0) 
        main_layout.setSpacing(0)
        
        self.content_frame = QFrame()
        self.content_frame.setObjectName("combatContentFrame") 
        self.content_frame.setFrameShape(QFrame.Shape.StyledPanel) 
        self.content_frame.setFrameShadow(QFrame.Shadow.Raised) 
        main_layout.addWidget(self.content_frame) 

        layout = QVBoxLayout(self.content_frame) 
        layout.setContentsMargins(10, 10, 10, 10) 
        layout.setSpacing(10) 

        status_layout = QHBoxLayout()
        status_layout.setContentsMargins(0, 0, 0, 0)
        status_layout.setSpacing(10)

        self.status_label = QLabel("Status: Narrative") 
        self.status_label.setObjectName("statusLabel")
        status_layout.addWidget(self.status_label)

        self.round_label = QLabel("Round: 0")
        self.round_label.setVisible(False) 
        self.round_label.setObjectName("roundLabel")
        status_layout.addWidget(self.round_label)

        status_layout.addStretch()

        self.settings_button = QPushButton("⚙️")
        self.settings_button.setToolTip("Combat Display Settings")
        self.settings_button.setFixedSize(25, 25)
        self.settings_button.clicked.connect(self.open_settings_dialog)
        status_layout.addWidget(self.settings_button)

        layout.addLayout(status_layout)

        self.entities_frame = QFrame() 
        self.entities_frame.setFrameShape(QFrame.Shape.NoFrame) 
        self.entities_frame.setFrameShadow(QFrame.Shadow.Plain) 
        self.entities_frame.setObjectName("entitiesFrame")
        entities_layout = QVBoxLayout(self.entities_frame)
        entities_layout.setContentsMargins(0,0,0,0) 
        entities_layout.setSpacing(10) 

        self.player_group = QGroupBox("Player") 
        self.player_group.setObjectName("playerGroup")
        player_layout = QHBoxLayout(self.player_group)
        player_layout.setContentsMargins(5, 10, 5, 5) 
        player_layout.setSpacing(5)
        self.player_layout = player_layout
        entities_layout.addWidget(self.player_group)

        self.enemies_group = QGroupBox("Enemies") 
        self.enemies_group.setObjectName("enemiesGroup")
        enemies_layout = QHBoxLayout(self.enemies_group)
        enemies_layout.setContentsMargins(5, 10, 5, 5) 
        enemies_layout.setSpacing(5)
        self.enemies_layout = enemies_layout
        entities_layout.addWidget(self.enemies_group)

        layout.addWidget(self.entities_frame)

        self.log_group = QGroupBox("Combat Log") 
        self.log_group.setObjectName("logGroup")
        log_layout = QVBoxLayout(self.log_group)
        log_layout.setContentsMargins(5, 10, 5, 5) 
        log_layout.setSpacing(0)

        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setMinimumHeight(150)
        self.log_text.setObjectName("combatLogText")
        log_layout.addWidget(self.log_text)

        layout.addWidget(self.log_group)

        self.last_log_index = -1 

        self._gradual_log_iterator: Optional[Iterator[str]] = None
        self._gradual_log_format: Optional[QTextCharFormat] = None
        self._gradual_log_timer: Optional[QTimer] = None
        self._is_gradual_log_active: bool = False
        self._pending_log_messages: List[Tuple[str, QTextCharFormat, bool]] = [] 

        self.apply_settings()
        self.clear_display()

    def load_settings(self):
        """Load settings from JSON file or use defaults."""
        self.current_settings = self.get_default_settings() # Start with defaults
        logger.info(f"Loading combat display settings from: {SETTINGS_FILE}")
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r') as f:
                    loaded_settings = json.load(f)
                    logger.debug(f"Loaded settings: {loaded_settings}")
                    # Merge loaded settings carefully, only overwriting defaults
                    for key, value in loaded_settings.items():
                         # Check if key exists in defaults OR if it's a known pattern (future-proofing slightly)
                         if key in self.current_settings or key.startswith("color_") or key.startswith("font_"):
                             self.current_settings[key] = value
                         else:
                             logger.warning(f"Ignoring unknown setting '{key}' from file.")
            else:
                logger.info("Settings file not found. Using default settings.")
        except (IOError, json.JSONDecodeError) as e:
            logger.error(f"Error loading combat display settings: {e}. Using defaults.")
        logger.info(f"Final settings after load: {self.current_settings}")


    def get_default_settings(self):
        """Return a dictionary of default settings."""
        default_font = QFontDatabase.systemFont(QFontDatabase.GeneralFont)
        return {
            # Background
            "background_image": None,
            # Fonts
            "font_family": default_font.family(),
            "font_size": default_font.pointSize() if default_font.pointSize() > 0 else 10,
            "font_size_player_name_offset": 1,
            "font_size_status_offset": 2,
            # Log Colors
            "color_log_damage": "#C80000",
            "color_log_heal": "#009600",
            "color_log_crit": "#FF0000", # Brighter red for crits
            "color_log_miss": "#969696",
            "color_log_roll": "#C87800",
            "color_log_turn": "#0064C8",
            "color_log_round": "#0064FF",
            "color_log_dev": "#646464",
            "color_log_header": "#A0A0A0", 
            "color_log_default": "#E0E0E0", 
            "color_log_combat_event": "#FFFFFF", 
            "color_log_system_message": "#FFFF00", # Default Yellow for system messages
            "color_log_narrative": "#FFD700", # Default Golden for narrative/GM messages
            "color_log_group_bg": "rgba(40, 40, 40, 0.75)", 
            "color_log_text_bg": "rgba(25, 25, 25, 0.85)", # Slightly darker text edit bg
            # General UI Colors
            "color_status_text": "#FFFFFF", 
            "color_round_text": "#E0E0E0", 
            "color_groupbox_title_text": "#FFFFFF", 
            "color_groupbox_title_bg": "rgba(0, 0, 0, 0.6)", 
            # Section Background Colors 
            "color_player_group_bg": "rgba(60, 80, 120, 0.7)", 
            "color_enemies_group_bg": "rgba(120, 60, 60, 0.7)", 
            # Entity Colors
            "color_entity_player_bg": "rgba(200, 220, 255, 0.3)",
            "color_entity_player_border": "#0077cc",
            "color_entity_player_bg_active": "rgba(200, 220, 255, 0.8)",
            "color_entity_player_border_active": "#00aaff",
            "color_entity_enemy_bg": "rgba(255, 200, 200, 0.3)",
            "color_entity_enemy_border": "#cc0000",
            "color_entity_enemy_bg_active": "rgba(255, 200, 200, 0.8)",
            "color_entity_enemy_border_active": "#ff5500",
            # Progress Bar Colors
            "color_hp_bar_chunk_normal": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)",
            "color_hp_bar_chunk_low": "#cc0000",
            "color_hp_bar_chunk_critical": "#990000",
            "color_hp_bar_chunk_normal_bleak": "#AA0000A0", 
            "color_hp_bar_chunk_low_bleak": "#880000A0",   
            "color_hp_bar_chunk_critical_bleak": "#600000A0",
            "color_stamina_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #66CC33, stop:1 #44AA22)",
            "color_stamina_bar_chunk_bleak": "#44AA22A0",
            "color_mana_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #3366CC, stop:1 #2244AA)", # Added Mana Chunk
            "color_mana_bar_chunk_bleak": "#2244AAA0",  # Added Mana Bleak
            "color_resolve_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #9b59b6, stop:1 #8e44ad)",
            "color_progressbar_text": "#FFFFFF", 
            "color_progressbar_bg": "#555555",

            "gradual_text_combat_log": True, 
            "display_text_speed_delay": 30,
        }

    def save_settings(self):
        """Save current settings to JSON file."""
        logger.info(f"Saving combat display settings to: {SETTINGS_FILE}")
        try:
            # Ensure config directory exists before writing
            os.makedirs(CONFIG_DIR, exist_ok=True)
            with open(SETTINGS_FILE, 'w') as f:
                json.dump(self.current_settings, f, indent=4)
            logger.info("Settings saved successfully.")
        except IOError as e:
            logger.error(f"Error saving combat display settings: {e}")

    def apply_settings(self):
        """Apply loaded or default settings to the combat display UI."""
        if not self.current_settings:
            logger.warning("Attempted to apply settings before loading. Loading defaults.")
            self.load_settings() # This populates self.current_settings

        logger.debug(f"Applying settings to CombatDisplay: {self.current_settings}")

        # --- ECFA Change: Ensure text speed setting is loaded into self.current_settings ---
        # If load_settings doesn't get specific combat speed, use general one.
        q_settings = QSettings("RPGGame", "Settings")
        general_text_speed = q_settings.value("display/text_speed_delay", 30, type=int)
        self.current_settings.setdefault("display_text_speed_delay_combat", general_text_speed)
        # --- End ECFA Change ---

        bg_image_relative = self.current_settings.get("background_image")
        main_widget_style_parts = [] 
        image_path_for_log = "None" 
        if bg_image_relative:
            image_path = os.path.join(IMAGE_DIR, bg_image_relative).replace("\\", "/")
            image_path_for_log = image_path 
            if os.path.exists(image_path):
                main_widget_style_parts.append(f"border-image: url(\"{image_path}\") 0 0 0 0 stretch stretch;")
                logger.info(f"Applying background image using border-image: {image_path}")
            else:
                logger.warning(f"Background image not found: {image_path}")
                main_widget_style_parts.append("border-image: none;")
        else:
             main_widget_style_parts.append("border-image: none;")
             logger.info("No background image selected, applying 'border-image: none;'")

        try:
            fallback_bg_color_str = self.current_settings.get("color_fallback_bg", "rgba(30, 30, 30, 0.9)")
            QColor(fallback_bg_color_str) 
        except (ValueError, TypeError):
            logger.warning(f"Invalid fallback background color '{fallback_bg_color_str}'. Using default.")
            fallback_bg_color_str = "rgba(30, 30, 30, 0.9)"
        main_widget_style_parts.append(f"background-color: {fallback_bg_color_str};")

        main_widget_style = "\n    ".join(main_widget_style_parts)

        def get_safe_color(key, default):
            color_str = self.current_settings.get(key, default)
            try:
                QColor(color_str); return color_str
            except (ValueError, TypeError):
                logger.warning(f"Invalid color value '{color_str}' for key '{key}'. Using default '{default}'.")
                return default

        player_group_bg = get_safe_color("color_player_group_bg", "rgba(60, 80, 120, 0.7)")
        enemies_group_bg = get_safe_color("color_enemies_group_bg", "rgba(120, 60, 60, 0.7)")
        log_group_bg = get_safe_color("color_log_group_bg", "rgba(40, 40, 40, 0.75)")
        log_default_text_color = get_safe_color("color_log_default", "#E0E0E0")
        log_text_bg_color = get_safe_color("color_log_text_bg", "rgba(255, 255, 255, 0.05)") # Ensure this is a valid key or provide default
        groupbox_title_text = get_safe_color("color_groupbox_title_text", "#FFFFFF")
        groupbox_title_bg = get_safe_color("color_groupbox_title_bg", "rgba(0, 0, 0, 0.6)")
        status_text_color = get_safe_color("color_status_text", "#FFFFFF")
        round_text_color = get_safe_color("color_round_text", "#E0E0E0")


        full_stylesheet = f"""
            QWidget#{self.objectName()} {{ background-color: transparent; border: none; }}
            QFrame#combatContentFrame {{ {main_widget_style} background-clip: padding-box; background-origin: border-box; border-radius: 5px; }}
            QFrame#{self.entities_frame.objectName()} {{ background-color: transparent; border: none; }}
            QGroupBox#{self.player_group.objectName()} {{ background-color: {player_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox#{self.enemies_group.objectName()} {{ background-color: {enemies_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox#{self.log_group.objectName()} {{ background-color: {log_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox::title {{ color: {groupbox_title_text}; background-color: {groupbox_title_bg}; padding: 3px 8px; border-radius: 3px; subcontrol-origin: margin; subcontrol-position: top left; margin-left: 5px; }}
            QTextEdit#{self.log_text.objectName()} {{ background-color: {log_text_bg_color}; color: {log_default_text_color}; border: 1px solid rgba(0, 0, 0, 0.2); border-radius: 3px; padding: 2px; }}
            QLabel#{self.status_label.objectName()} {{ background-color: transparent; color: {status_text_color}; padding: 2px; }}
            QLabel#{self.round_label.objectName()} {{ background-color: transparent; color: {round_text_color}; padding: 2px; }}
        """
        self.setStyleSheet(full_stylesheet)

        font_family = self.current_settings.get("font_family", "Arial")
        font_size = self.current_settings.get("font_size", 10)
        
        status_font_size_offset = self.current_settings.get("font_size_status_offset", 2)
        status_font = QFont(font_family, font_size + status_font_size_offset)
        status_font.setBold(True)
        self.status_label.setFont(status_font)

        round_font = QFont(font_family, font_size)
        self.round_label.setFont(round_font)

        log_font = QFont(font_family, font_size)
        self.log_text.setFont(log_font) 

        title_font = QFont(font_family, font_size) 
        title_font.setBold(True) 
        self.player_group.setFont(title_font)
        self.enemies_group.setFont(title_font)
        self.log_group.setFont(title_font)

        for entity_widget in self.entity_widgets.values():
            entity_widget.update_style(self.current_settings)
        self.update()
        logger.info("Combat display settings applied.")

    def clear_display(self):
        """Clear the display and set to inactive/narrative state."""
        self.combat_active = False
        self.status_label.setText("Status: Narrative")
        self.round_label.setText("Round: 0")
        self.round_label.setVisible(False) # Hide round counter
        self.last_log_index = -1

        # Clear entity widgets
        self._clear_entity_widgets()

        # Hide the entities frame and log_group for clean UI
        if hasattr(self, 'entities_frame'):
            self.entities_frame.setVisible(False)
        if hasattr(self, 'log_group'):
            self.log_group.setVisible(False)

    @Slot(GameState)
    def update_display(self, game_state: GameState):
        """Update the display based on the current GameState."""
        if game_state is None:
            logger.warning("CombatDisplay.update_display received None GameState, clearing display.")
            self.clear_display()
            return

        current_mode_enum = getattr(game_state, 'current_mode', InteractionMode.NARRATIVE)
        mode = current_mode_enum.name if hasattr(current_mode_enum, 'name') else str(current_mode_enum)
        
        logger.info(f"CombatDisplay.update_display called. Game Mode: {mode}")

        if mode in ["COMBAT", "SOCIAL_CONFLICT"]:
            self.setVisible(True) # Ensure the CombatDisplay widget itself is visible
            initial_setup_done_this_call = False
            if not self.combat_active: 
                logger.info(f"CombatDisplay: First entry into {mode} view. Setting up UI visibility and styles.")
                if hasattr(self, 'entities_frame'): self.entities_frame.setVisible(True)
                if hasattr(self, 'log_group'): self.log_group.setVisible(True)
                if hasattr(self, 'player_group'): self.player_group.setVisible(True)
                if hasattr(self, 'enemies_group'): self.enemies_group.setVisible(True)
                self.combat_active = True
                self.apply_settings() # Apply styles
                initial_setup_done_this_call = True
            
            combat_manager = getattr(game_state, 'combat_manager', None)
            if not combat_manager:
                logger.warning(f"CombatDisplay: {mode} mode active but no CombatManager found. Clearing entity widgets.")
                self.status_label.setText(f"Status: {mode} (Error - No Manager)")
                self._clear_entity_widgets() 
                return
            
            logger.info(f"CombatDisplay: CombatManager found (ID: {getattr(combat_manager, 'id', 'N/A')}). Entities in CM: {len(getattr(combat_manager, 'entities', {}))}")

            round_num = getattr(combat_manager, 'round_number', 0)
            cm_state_attr = getattr(combat_manager, 'state', None)
            cm_state_name = cm_state_attr.name if hasattr(cm_state_attr, 'name') else "Unknown State"

            if mode == "COMBAT":
                self.round_label.setVisible(True)
                self.round_label.setText(f"Round: {round_num}")
                if cm_state_name == "IN_PROGRESS": self.status_label.setText("Status: Combat Active")
                elif cm_state_name == "PLAYER_VICTORY": self.status_label.setText("Status: Victory!")
                elif cm_state_name == "PLAYER_DEFEAT": self.status_label.setText("Status: Defeat!")
                elif cm_state_name == "FLED": self.status_label.setText("Status: Fled from Combat")
                else: self.status_label.setText(f"Status: Combat - {cm_state_name}")
            else: 
                self.status_label.setText("Status: Social Conflict")
                self.round_label.setVisible(False)

            current_turn_id = getattr(combat_manager, 'get_current_entity_id', lambda: None)()
            combatants_widget_data = {}
            cm_entities = getattr(combat_manager, 'entities', {})
            if cm_entities:
                logger.debug(f"CombatDisplay: Building combatants_widget_data from CM entities. Count: {len(cm_entities)}")
                for entity_id, combat_entity in cm_entities.items():
                    if not getattr(combat_entity, 'is_active_in_combat', True):
                        logger.debug(f"CombatDisplay: Skipping display of inactive entity: {getattr(combat_entity, 'combat_name', entity_id)}")
                        if entity_id in self.entity_widgets: 
                            widget_to_remove = self.entity_widgets.pop(entity_id)
                            if widget_to_remove.parentWidget() and widget_to_remove.parentWidget().layout():
                                widget_to_remove.parentWidget().layout().removeWidget(widget_to_remove)
                            widget_to_remove.deleteLater()
                        continue

                    raw_status_effects = getattr(combat_entity, 'status_effects', {})
                    display_status_effects = []
                    if isinstance(raw_status_effects, dict):
                        display_status_effects = [f"{name}({dur})" if dur not in [None, float('inf')] else name for name, dur in raw_status_effects.items()]
                    elif isinstance(raw_status_effects, (list, set)):
                        display_status_effects = [str(eff_name) for eff_name in raw_status_effects]
                    
                    entity_type_enum = getattr(combat_entity, 'entity_type', None)

                    combatants_widget_data[entity_id] = {
                        "id": entity_id, 
                        "name": getattr(combat_entity, 'name', 'N/A'), 
                        "combat_name": getattr(combat_entity, 'combat_name', 'N/A'), 
                        "current_hp": getattr(combat_entity, 'current_hp', 0), 
                        "max_hp": getattr(combat_entity, 'max_hp', 1) if getattr(combat_entity, 'max_hp', 0) > 0 else 1,
                        "current_stamina": getattr(combat_entity, 'current_stamina', 0), 
                        "max_stamina": getattr(combat_entity, 'max_stamina', 1) if getattr(combat_entity, 'max_stamina', 0) > 0 else 1,
                        "current_mana": getattr(combat_entity, 'current_mp', 0),
                        "max_mana": getattr(combat_entity, 'max_mp', 1) if getattr(combat_entity, 'max_mp', 0) > 0 else 1,
                        "status_effects": display_status_effects,
                        "is_player": entity_type_enum == EntityType.PLAYER if entity_type_enum else False,
                        "entity_type_str": entity_type_enum.name if hasattr(entity_type_enum, 'name') else str(entity_type_enum)
                    }
            else:
                logger.warning("CombatDisplay: combat_manager has no 'entities' or it's empty.")

            if not combatants_widget_data:
                logger.warning("CombatDisplay: combatants_widget_data is empty. No entity widgets will be updated/created for this call.")
                if initial_setup_done_this_call:
                    self._clear_entity_widgets() 
            else:
                logger.info(f"CombatDisplay: Queuing _update_entity_widgets with {len(combatants_widget_data)} entries. Current turn ID: {current_turn_id}")
                QTimer.singleShot(0, lambda data=combatants_widget_data.copy(), turn_id=current_turn_id: self._update_entity_widgets(data, turn_id))

        elif self.combat_active: 
            logger.info(f"CombatDisplay: Exiting {mode} view (was active). Clearing display.")
            self.clear_display() 
            self.setVisible(False) # Hide the CombatDisplay widget when not in combat
            
    def _clear_entity_widgets(self):
        """Clear all entity widgets."""
        layouts_to_clear = [self.player_layout, self.enemies_layout]
        for layout in layouts_to_clear:
            if not layout: continue
            # Remove stretch item first if it exists
            stretch_index = -1
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.spacerItem():
                    stretch_index = i
                    break
            if stretch_index != -1:
                layout.takeAt(stretch_index) # Remove stretch

            # Remove widgets
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()
                if widget:
                    widget.deleteLater()

        self.entity_widgets.clear()

    def _update_entity_widgets(self, combatants_data: Dict[str, Dict[str, Any]], current_turn_id: Optional[str]):
        """Update entity widgets based on combatant data."""
        logger.info(f"CombatDisplay._update_entity_widgets: Received {len(combatants_data)} combatants. Current turn: {current_turn_id}")
        if not combatants_data:
            logger.warning("CombatDisplay._update_entity_widgets: combatants_data is empty. Clearing existing widgets if any.")
            self._clear_entity_widgets() # Clear if no data
            return

        existing_ids_in_data = set(combatants_data.keys())
        current_widget_ids = set(self.entity_widgets.keys())

        # Remove widgets for entities no longer in combatants_data
        for entity_id_to_remove in current_widget_ids - existing_ids_in_data:
            if entity_id_to_remove in self.entity_widgets:
                widget = self.entity_widgets.pop(entity_id_to_remove)
                parent_layout = widget.parentWidget().layout() if widget.parentWidget() else None
                if parent_layout: parent_layout.removeWidget(widget)
                widget.deleteLater()
                logger.info(f"CombatDisplay: Removed entity widget for no longer present/active entity: {entity_id_to_remove}")

        player_widgets_present = False
        enemy_widgets_present = False

        for entity_id, entity_data in combatants_data.items():
            is_player = entity_data.get("is_player", False)
            entity_type_str = entity_data.get("entity_type_str", "UNKNOWN") # For logging
            logger.debug(f"CombatDisplay: Processing entity widget for ID {entity_id}, Name: {entity_data.get('combat_name', 'N/A')}, IsPlayer: {is_player}, Type: {entity_type_str}")
            
            is_active_turn = entity_id == current_turn_id
            display_name = entity_data.get("combat_name", entity_data.get("name", entity_id))
            
            current_hp = int(entity_data.get("current_hp", 0)) 
            max_hp = int(entity_data.get("max_hp", 1)) 
            current_stamina = int(entity_data.get("current_stamina", 0)) 
            max_stamina = int(entity_data.get("max_stamina", 1))
            current_mana = int(entity_data.get("current_mana", 0))
            max_mana = int(entity_data.get("max_mana", 1))
            status_effects = entity_data.get("status_effects", [])

            if entity_id in self.entity_widgets:
                widget = self.entity_widgets[entity_id]
                logger.debug(f"CombatDisplay: Updating existing widget for {display_name}")
                widget.name_label.setText(display_name) 
                widget.update_style(self.current_settings) 
                widget.update_stats(current_hp, max_hp, current_stamina, max_stamina, status_effects, current_mana, max_mana)
                widget.highlight_active(is_active_turn)
            else:
                logger.info(f"CombatDisplay: Creating NEW widget for {display_name} (ID: {entity_id}, IsPlayer: {is_player})")
                widget = CombatEntityWidget(entity_id=entity_id, name=display_name, settings=self.current_settings, is_player=is_player)
                widget.update_stats(current_hp, max_hp, current_stamina, max_stamina, status_effects, current_mana, max_mana)
                widget.highlight_active(is_active_turn)
                
                target_layout = self.player_layout if is_player else self.enemies_layout
                if target_layout:
                    # Remove existing stretch if present before adding widget
                    stretch_item = target_layout.takeAt(target_layout.count() -1) if target_layout.count() >0 and target_layout.itemAt(target_layout.count()-1).spacerItem() else None

                    target_layout.addWidget(widget) # Add the new widget

                    if stretch_item: # Add stretch back if it was removed
                        target_layout.addSpacerItem(stretch_item)
                    else: # Or ensure stretch is there if layout was empty
                        target_layout.addStretch()

                    logger.debug(f"CombatDisplay: Added widget for {display_name} to {'player' if is_player else 'enemies'} layout.")
                else:
                    logger.error(f"CombatDisplay: Target layout (player/enemy) not found for {display_name}!")
                self.entity_widgets[entity_id] = widget
            
            if is_player: player_widgets_present = True
            else: enemy_widgets_present = True

        # This ensures layouts with no widgets don't have a lingering stretch
        self._ensure_stretch(self.player_layout, player_widgets_present)
        self._ensure_stretch(self.enemies_layout, enemy_widgets_present)
        logger.info(f"CombatDisplay._update_entity_widgets: Finished. Player widgets: {player_widgets_present}, Enemy widgets: {enemy_widgets_present}. Total widgets in dict: {len(self.entity_widgets)}")

    def _ensure_stretch(self, layout: Optional[QHBoxLayout], widgets_present: bool):
        """Adds or removes stretch item from a layout as needed."""
        if not layout: return

        stretch_index = -1
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.spacerItem():
                stretch_index = i
                break

        if widgets_present and stretch_index == -1:
            layout.addStretch() # Add stretch if needed
        elif not widgets_present and stretch_index != -1:
            layout.takeAt(stretch_index) # Remove stretch if no widgets

    def _update_combat_log(self, log_entries: List[str]): # Added type hint
        """Update the combat log incrementally with new entries."""
        if not log_entries:
            return

        scrollbar = self.log_text.verticalScrollBar()
        at_bottom = scrollbar.value() >= scrollbar.maximum() - 10 # Is the user scrolled near the bottom?

        start_index = self.last_log_index + 1
        if start_index >= len(log_entries):
            return

        new_entries_to_process = log_entries[start_index:]
        logger.debug(f"Processing {len(new_entries_to_process)} new log entries (from index {start_index})")

        new_entries_added = False
        for entry_index, entry in enumerate(new_entries_to_process):
            # Determine color/format based on entry content and settings
            color_hex = self.current_settings.get("color_log_default", "#E0E0E0")
            is_bold = False
            is_italic = False
            is_narrative = True # Assume GM/Narrative by default

            entry_lower = entry.lower()

            # Simplified system message check (more robust checks might be needed)
            if entry.startswith("[SYSTEM]") or \
            "roll" in entry_lower and "vs" in entry_lower or \
            "takes" in entry_lower and "damage" in entry_lower or \
            "misses" in entry_lower or \
            "defeated" in entry_lower or \
            "fumble" in entry_lower or \
            "critical hit" in entry_lower or \
            "status expire" in entry_lower or \
            "turn." in entry_lower or \
            "round" in entry_lower and "begins" in entry_lower or \
            entry.startswith("Turn order:") or \
            "Stamina Cost:" in entry: # Check for stamina cost message
                is_narrative = False # Mark as system message

            # --- Color/Style Logic (using settings) ---
            # (Keep existing color logic)
            if entry.startswith("[DEV]"): color_hex = self.current_settings.get("color_log_dev", "#888888"); is_italic = True; is_narrative = False
            elif "critical hit" in entry_lower or "defeated!" in entry_lower or "was defeated" in entry_lower: color_hex = self.current_settings.get("color_log_crit", "#FF4444"); is_bold = True; is_narrative = False
            elif "healed" in entry_lower or "gains" in entry_lower and ("hp" in entry_lower or "stamina" in entry_lower): color_hex = self.current_settings.get("color_log_heal", "#44FF44"); is_narrative = False # Healing is often systemic
            elif "round" in entry_lower and "begins" in entry_lower: color_hex = self.current_settings.get("color_log_round", "#66AAFF"); is_bold = True; is_narrative = False
            elif "turn" in entry_lower or "'s turn" in entry_lower: color_hex = self.current_settings.get("color_log_turn", "#88CCFF"); is_narrative = False
            elif "combat started" in entry_lower or "combat ended" in entry_lower or "victory!" in entry_lower or "defeat!" in entry_lower or "fled!" in entry_lower or "surrender" in entry_lower: color_hex = self.current_settings.get("color_log_combat_event", "#FFFFFF"); is_bold = True; is_narrative = False
            elif "misses" in entry_lower or "fails" in entry_lower or "resisted" in entry_lower or "escape fails" in entry_lower: color_hex = self.current_settings.get("color_log_miss", "#AAAAAA"); is_italic = True; is_narrative = False
            elif "damage" in entry_lower or "loses" in entry_lower and ("hp" in entry_lower or "resolve" in entry_lower): color_hex = self.current_settings.get("color_log_damage", "#FF8888"); is_narrative = False
            elif "roll" in entry_lower or "vs" in entry_lower: color_hex = self.current_settings.get("color_log_roll", "#FFCC66"); is_narrative = False

            # Append with determined format and gradual flag
            text_format = QTextCharFormat()
            try:
                text_format.setForeground(QColor(color_hex))
            except ValueError:
                logger.warning(f"Invalid color hex '{color_hex}' for log entry. Using default.")
                text_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0")))

            if is_bold: text_format.setFontWeight(QFont.Weight.Bold)
            if is_italic: text_format.setFontItalic(True)

            # Use gradual display ONLY for narrative messages
            self._append_formatted_text(entry, text_format, gradual=is_narrative) # Pass gradual flag
            new_entries_added = True

            # Update last processed index
            self.last_log_index = start_index + entry_index

    def _append_formatted_text(self, text: str, text_format: QTextCharFormat, gradual: bool = False):
        """Appends text to the log, either immediately or gradually."""
        use_gradual = gradual and self.current_settings.get("gradual_text_combat_log", True) # Check setting

        if not text.strip(): # Don't append empty or whitespace-only lines
            logger.debug("Skipping append of empty/whitespace log message.")
            self.visualDisplayComplete.emit() # Emit completion even for skipped empty text
            return

        if not text.endswith('\n'):
            text += '\n'

        if self._is_gradual_log_active:
            logger.debug(f"Queueing log message (Gradual: {use_gradual}): '{text[:50]}...'")
            self._pending_log_messages.append((text, text_format, use_gradual))
            return

        if not use_gradual:
            logger.debug(f"Appending immediate log message: '{text[:50]}...'")
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            cursor.insertText(text, text_format)
            self.log_text.setTextCursor(cursor) 
            self.log_text.ensureCursorVisible()
            self.visualDisplayComplete.emit() # --- ECFA Change: Emit signal ---
            self._process_next_pending_log_message()
            return

        logger.debug(f"Starting gradual log display: '{text[:50]}...'")
        self._is_gradual_log_active = True
        self._gradual_log_iterator = iter(text)
        self._gradual_log_format = text_format

        cursor = self.log_text.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.log_text.setTextCursor(cursor)

        if not self._gradual_log_timer:
            self._gradual_log_timer = QTimer(self)
            self._gradual_log_timer.setSingleShot(True)
            self._gradual_log_timer.timeout.connect(self._display_next_log_char)

        QTimer.singleShot(1, self._display_next_log_char)

    @Slot()
    def _display_next_log_char(self):
        """Displays the next character for the combat log gradual display."""
        if not self._is_gradual_log_active or not self._gradual_log_iterator:
            if self._is_gradual_log_active: 
                self._is_gradual_log_active = False
                self.visualDisplayComplete.emit() 
                self._process_next_pending_log_message()
            return

        try:
            char = next(self._gradual_log_iterator)
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            if self._gradual_log_format:
                cursor.insertText(char, self._gradual_log_format)
            else:
                cursor.insertText(char) 
            self.log_text.setTextCursor(cursor) 
            self.log_text.ensureCursorVisible() 

            # --- ECFA Change: Use unified settings key from self.current_settings ---
            char_delay = self.current_settings.get("display_text_speed_delay", 30) 
            # --- End ECFA Change ---
            char_delay = max(5, int(char_delay)) 
            if self._gradual_log_timer: 
                self._gradual_log_timer.start(char_delay)

        except StopIteration:
            self._is_gradual_log_active = False
            self._gradual_log_iterator = None
            self._gradual_log_format = None
            logger.debug("Gradual log display finished for one segment.")
            self.visualDisplayComplete.emit() 
            self._process_next_pending_log_message()

        except Exception as e:
            logger.error(f"Error during gradual log display: {e}", exc_info=True)
            self._is_gradual_log_active = False
            self._gradual_log_iterator = None
            self._gradual_log_format = None
            if self._gradual_log_timer and self._gradual_log_timer.isActive():
                self._gradual_log_timer.stop()
            self.visualDisplayComplete.emit() 
            self._pending_log_messages.clear() 
            self._process_next_pending_log_message() # Process queue even on error

    def _process_next_pending_log_message(self):
        """Processes the next message in the pending queue."""
        if not self._is_gradual_log_active and self._pending_log_messages:
            text, text_format, is_gradual = self._pending_log_messages.pop(0)
            logger.debug(f"Processing pending log message (Gradual: {is_gradual}): '{text[:50]}...'")
            # Call _append_formatted_text again - it will handle starting gradual or immediate append
            self._append_formatted_text(text, text_format, gradual=is_gradual)

    def clear_log(self):
        """Clear the combat log."""
        self.log_text.clear()
        logger.info("Combat log cleared.")
        # Add header back immediately after clearing?
        # header_format = QTextCharFormat()
        # header_format.setFontWeight(QFont.Bold)
        # header_format.setForeground(QColor(self.current_settings.get("color_log_header", "#A0A0A0")))
        # self._append_formatted_text("===== COMBAT LOG =====", header_format)


    def open_settings_dialog(self):
        """Opens the settings dialog to customize the combat display."""
        logger.info("Opening Combat Display Settings dialog.")

        if not self.current_settings:
            logger.error("Cannot open settings dialog: current_settings not loaded.")
            self.load_settings() # Try loading defaults if missing

        # Pass a copy of current settings to avoid modifying originals unless saved
        dialog = CombatSettingsDialog(self.current_settings.copy(), IMAGE_DIR, self)

        # Execute the dialog modally
        if dialog.exec(): # Returns True if accepted (e.g., Save clicked)
            new_settings = dialog.get_settings()
            if new_settings != self.current_settings:
                logger.info("Settings changed. Saving and applying...")
                self.current_settings = new_settings
                self.save_settings()
                self.apply_settings() # Re-apply all settings
            else:
                logger.info("Settings dialog closed without changes.")
        else:
            logger.info("Settings dialog cancelled.")

    def append_buffered_messages(self, messages: List[str], gradual: bool):
        """
        Appends a list of messages, typically from the combat_narrative_buffer.
        The visualDisplayComplete signal will be emitted after the *last* message in the list
        has finished displaying.
        """
        if not messages:
            self.visualDisplayComplete.emit() # Emit if buffer is empty
            return

        logger.debug(f"Appending {len(messages)} buffered messages. Gradual: {gradual}")
        
        # Use default GM format for buffered messages (usually narrative)
        # This format should be configurable or passed with the event in a richer system
        from PySide6.QtGui import QFont, QColor # Local import for safety
        gm_format = QTextCharFormat()
        gm_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0"))) # Example color
        # font_family = self.current_settings.get("font_family", "Arial")
        # font_size = self.current_settings.get("font_size", 10)
        # gm_format.setFont(QFont(font_family, font_size))


        for i, message_content in enumerate(messages):
            is_last_message = (i == len(messages) - 1)
            
            # If it's the last message, its completion will trigger the main visualDisplayComplete.
            # For other messages, we don't want them to trigger the orchestrator's main logic.
            # This requires _append_formatted_text to know if it's part of a batch.
            # Simpler for now: _append_formatted_text always emits. Orchestrator ignores intermediate ones
            # if it knows it's processing a BUFFER_FLUSH event with multiple items.
            # This detail depends on how Orchestrator handles BUFFER_FLUSH DisplayEvents.

            # For now, let's assume _append_formatted_text handles queuing and will eventually
            # emit visualDisplayComplete after the *entire sequence* of buffered messages.
            # This means _append_formatted_text needs to be smarter or we need a different approach.

            # Refined approach: _append_formatted_text queues. The final visualDisplayComplete
            # will be emitted when the *last* character of the *last* message is displayed.
            self._append_formatted_text(message_content, gm_format, gradual)

    def stop_gradual_display(self):
        """Immediately stops any ongoing gradual text display and processes pending messages quickly."""
        logger.info("Stopping current gradual display and flushing pending messages.")
        if self._gradual_log_timer and self._gradual_log_timer.isActive():
            self._gradual_log_timer.stop()
        
        # If an iterator was active, display remaining text immediately
        if self._gradual_log_iterator:
            remaining_text = "".join(list(self._gradual_log_iterator))
            if remaining_text:
                cursor = self.log_text.textCursor()
                cursor.movePosition(QTextCursor.MoveOperation.End)
                if self._gradual_log_format:
                    cursor.insertText(remaining_text, self._gradual_log_format)
                else:
                    cursor.insertText(remaining_text)
                self.log_text.setTextCursor(cursor)
                self.log_text.ensureCursorVisible()
            self._gradual_log_iterator = None
            self._gradual_log_format = None

        self._is_gradual_log_active = False # Mark as not active
        
        # Process all pending messages immediately (non-gradual)
        while self._pending_log_messages:
            text, text_format, _ = self._pending_log_messages.pop(0) # Ignore original gradual flag
            logger.debug(f"Flushing pending message immediately: '{text[:50]}...'")
            if not text.endswith('\n'): text += '\n'
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            cursor.insertText(text, text_format)
            self.log_text.setTextCursor(cursor)
            self.log_text.ensureCursorVisible()
            
        self.visualDisplayComplete.emit()

    def append_orchestrated_event_content(self, event_content: str, event_role: str, is_gradual: bool):
        """
        Appends orchestrated event content to the combat log, using CombatDisplay's
        own settings for color formatting.
        """
        # Determine color/format based on event_role, event_content, and self.current_settings
        color_hex = self.current_settings.get("color_log_default", "#E0E0E0") # Default
        is_bold = False
        is_italic = False

        # Standardize role for key lookup
        role_lower = event_role.lower() if event_role else "system"
        content_lower = event_content.lower()

        # Precedence: Specific keywords first, then role-based, then default.
        if "critical hit" in content_lower or "defeated!" in content_lower or "was defeated" in content_lower:
            color_hex = self.current_settings.get("color_log_crit", "#FF0000") # Default red for crit
            is_bold = True
        elif "healed" in content_lower or ("gains" in content_lower and ("hp" in content_lower or "stamina" in content_lower)):
            color_hex = self.current_settings.get("color_log_heal", "#009600") # Default green for heal
        elif "round" in content_lower and "begins" in content_lower:
            color_hex = self.current_settings.get("color_log_round", "#0064FF") # Default blue for round
            is_bold = True
        elif "turn" in content_lower or "'s turn" in content_lower: # General turn info
            color_hex = self.current_settings.get("color_log_turn", "#0064C8") # Default light blue for turn
        elif "combat started" in content_lower or "combat ended" in content_lower or "victory!" in content_lower or "defeat!" in content_lower or "fled!" in content_lower or "surrender" in content_lower:
            color_hex = self.current_settings.get("color_log_combat_event", "#FFFFFF") # Default white for major combat events
            is_bold = True
        elif "misses" in content_lower or "fails" in content_lower or "resisted" in content_lower or "escape fails" in content_lower or "fumble" in content_lower:
            color_hex = self.current_settings.get("color_log_miss", "#969696") # Default gray for miss/fail
            is_italic = True
        elif "damage" in content_lower or ("loses" in content_lower and ("hp" in content_lower or "resolve" in content_lower)):
            color_hex = self.current_settings.get("color_log_damage", "#C80000") # Default dark red for damage
        elif "roll" in content_lower or "vs" in content_lower: # Dice rolls
            color_hex = self.current_settings.get("color_log_roll", "#C87800") # Default orange for rolls
        elif role_lower == "system":
            color_hex = self.current_settings.get("color_log_system_message", self.current_settings.get("color_log_default", "#E0E0E0"))
        elif role_lower == "gm": # Narrative content
            color_hex = self.current_settings.get("color_log_narrative", self.current_settings.get("color_log_default", "#E0E0E0"))
        elif event_content.startswith("[DEV]"): # Dev messages
            color_hex = self.current_settings.get("color_log_dev", "#646464"); is_italic = True;

        text_format = QTextCharFormat()
        try:
            text_format.setForeground(QColor(color_hex))
        except ValueError: # Fallback if color_hex is invalid
            logger.warning(f"Invalid color hex '{color_hex}' for combat log. Using default.")
            text_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0")))

        if is_bold: text_format.setFontWeight(QFont.Weight.Bold)
        if is_italic: text_format.setFontItalic(True)
        
        # Use the existing method to append with the determined format
        self._append_formatted_text(event_content, text_format, gradual=is_gradual)
```

### File: ..\gui\components\command_input.py

```python
#!/usr/bin/env python3
"""
Command input widget for the RPG game GUI.
This module provides a widget for entering commands.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QLineEdit, QPushButton, 
    QCompleter, QVBoxLayout, QListWidget, QFrame
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QIcon, QPalette, QBrush, QPixmap

from gui.utils.resource_manager import get_resource_manager

class CommandInputWidget(QFrame):
    """Widget for entering commands."""
    
    # Signal emitted when a command is submitted
    command_submitted = Signal(str)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the command input widget."""
        super().__init__(parent)
        
        # Set frame properties
        self.setFrameShape(QFrame.StyledPanel)
        self.setContentsMargins(0, 0, 0, 0)
        
        # Command history
        self.command_history: List[str] = []
        self.history_index = -1
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Set frame background to transparent
        self.setStyleSheet("""
            CommandInputWidget {
                background-color: transparent;
                border: none;
            }
        """)
        
        # Create the command line edit with semi-transparent white background
        self.command_edit = QLineEdit()
        self.command_edit.setPlaceholderText("Enter a command or type 'help'...")
        self.command_edit.setStyleSheet("""
            QLineEdit {
                background-color: rgba(255, 255, 255, 0.7);
                color: #2e2e2e;
                border: 1px solid #c4b59d;
                border-radius: 4px;
                padding: 8px;
                font-family: 'Garamond', serif;
                font-size: 14pt;
                margin-left: 5px;
                margin-right: 5px;
            }
        """)
        
        # Create the submit button with generic button styling
        self.submit_button = QPushButton("Enter")
        self.submit_button.setStyleSheet("""
            QPushButton {
                background-image: url('images/gui/button_normal.png');
                background-position: center;
                background-repeat: no-repeat;
                background-color: transparent;
                color: #2e2e2e;
                border: none;
                padding: 8px 15px;
                font-weight: bold;
                font-family: 'Times New Roman', serif;
                min-width: 80px;
                min-height: 30px;
                max-width: 100px;
                margin-right: 5px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-image: url('images/gui/button_hover.png');
            }
            QPushButton:pressed {
                background-image: url('images/gui/button_pressed.png');
                color: #FF0000;
                font-weight: bold;
            }
        """)
        # Add widgets to the layout
        layout.addWidget(self.command_edit, 1)
        layout.addWidget(self.submit_button)
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Connect the submit button click
        self.submit_button.clicked.connect(self._submit_command)
        
        # Connect the command edit return key
        self.command_edit.returnPressed.connect(self._submit_command)
        
        # Connect the command edit key press event
        self.command_edit.keyPressEvent = self._command_key_press
    
    def _submit_command(self):
        """Submit the current command."""
        # Get the command text
        command = self.command_edit.text().strip()
        
        # Skip if empty
        if not command:
            return
        
        # Add to history
        if not self.command_history or self.command_history[-1] != command:
            self.command_history.append(command)
            if len(self.command_history) > 50:
                self.command_history.pop(0)
        
        # Reset history index
        self.history_index = -1
        
        # Emit signal
        self.command_submitted.emit(command)
        
        # Clear the edit
        self.command_edit.clear()
    
    def _command_key_press(self, event):
        """Handle key press events for the command edit."""
        # Check for up/down arrow keys for command history
        if event.key() == Qt.Key_Up:
            self._navigate_history(1)
        elif event.key() == Qt.Key_Down:
            self._navigate_history(-1)
        else:
            # Default handling
            QLineEdit.keyPressEvent(self.command_edit, event)
    
    def _navigate_history(self, direction: int):
        """Navigate the command history.
        
        Args:
            direction: 1 for older commands, -1 for newer commands.
        """
        if not self.command_history:
            return
        
        # Update history index
        new_index = self.history_index + direction
        
        # Clamp index
        if new_index >= len(self.command_history):
            new_index = len(self.command_history) - 1
        elif new_index < -1:
            new_index = -1
        
        self.history_index = new_index
        
        # Set text from history or clear
        if self.history_index == -1:
            self.command_edit.clear()
        else:
            self.command_edit.setText(self.command_history[-(self.history_index+1)])
            self.command_edit.selectAll()
    
    def clear(self):
        """Clear the command input."""
        self.command_edit.clear()

```

### File: ..\gui\components\game_menu.py

```python
#!/usr/bin/env python3
"""
Game menu widget for the RPG game GUI.
This module provides a widget for game menu options.
"""

import logging
from typing import Optional

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QPushButton, QButtonGroup, 
    QMenu, QToolButton, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon

class GameMenuWidget(QWidget):
    """Widget for game menu options."""
    
    # Signals for menu actions
    new_game_requested = Signal()
    save_game_requested = Signal()
    load_game_requested = Signal()
    settings_requested = Signal()
    llm_settings_requested = Signal()
    exit_requested = Signal()
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the game menu widget."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 5, 0, 5)
        
        # Style for buttons
        button_style = """
            QPushButton, QToolButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                font-weight: bold;
            }
            QPushButton:hover, QToolButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed, QToolButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
        """
        
        # Create menu buttons
        self.new_game_button = QPushButton("New Game")
        self.new_game_button.setStyleSheet(button_style)
        self.new_game_button.clicked.connect(self.new_game_requested.emit)
        
        # Save game button
        self.save_button = QPushButton("Save")
        self.save_button.setStyleSheet(button_style)
        self.save_button.clicked.connect(self.save_game_requested.emit)
        
        # Load game button
        self.load_button = QPushButton("Load")
        self.load_button.setStyleSheet(button_style)
        self.load_button.clicked.connect(self.load_game_requested.emit)
        
        # Settings button with dropdown
        self.settings_button = QToolButton()
        self.settings_button.setText("Settings")
        self.settings_button.setStyleSheet(button_style)
        self.settings_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        
        self.settings_menu = QMenu(self.settings_button)
        self.settings_action = self.settings_menu.addAction("Game Settings")
        self.settings_action.triggered.connect(self.settings_requested.emit)
        
        self.llm_settings_action = self.settings_menu.addAction("LLM Settings")
        self.llm_settings_action.triggered.connect(self.llm_settings_requested.emit)
        
        self.graphics_action = self.settings_menu.addAction("Graphics Settings")
        self.sound_action = self.settings_menu.addAction("Sound Settings")
        
        self.settings_button.setMenu(self.settings_menu)
        self.settings_button.setPopupMode(QToolButton.InstantPopup)
        
        # Exit button
        self.exit_button = QPushButton("Exit")
        self.exit_button.setStyleSheet(button_style)
        self.exit_button.clicked.connect(self.exit_requested.emit)
        
        # Add spacer to push buttons to the left
        layout.addWidget(self.new_game_button)
        layout.addWidget(self.save_button)
        layout.addWidget(self.load_button)
        layout.addWidget(self.settings_button)
        layout.addStretch()
        layout.addWidget(self.exit_button)

```

### File: ..\gui\components\game_output.py

```python
# --- START OF FILE game_output.py ---

"""
Game output widget for the RPG game GUI.
This module provides a widget for displaying game output.
"""

import logging
from typing import List, Optional, Dict, Any, Iterator, Tuple

from PySide6.QtWidgets import QTextEdit, QWidget, QVBoxLayout, QStackedLayout, QHBoxLayout, QFrame, QColorDialog
from PySide6.QtGui import QTextCursor, QColor, QTextCharFormat, QFont, QPalette, QPixmap, QBrush
from PySide6.QtCore import Qt, QTimer, Signal, QSettings

from core.utils.logging_config import get_logger
from gui.components.skill_check_display import SkillCheckDisplay
from gui.utils.resource_manager import get_resource_manager
from core.stats.skill_check import SkillCheckResult

logger = get_logger("GUI")

class GameOutputWidget(QFrame):
    """Widget for displaying game output."""

    # --- ECFA Change: Add visualDisplayComplete signal ---
    visualDisplayComplete = Signal()
    # --- End ECFA Change ---

    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the game output widget."""
        super().__init__(parent)

        self.setFrameShape(QFrame.StyledPanel)
        self.setContentsMargins(0, 0, 0, 0)
        self.setStyleSheet("""
            GameOutputWidget {
                background-color: transparent;
                border: none;
            }
        """)

        self.resource_manager = get_resource_manager()
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setAcceptRichText(True)

        self.settings = QSettings("RPGGame", "Settings") 

        system_color = self.settings.value("style/system_msg_color", "#FF0000")
        font_color = self.settings.value("style/font_color", "#000000")
        font_family = self.settings.value("style/font_family", "Garamond")
        font_size = int(self.settings.value("style/font_size", 14))

        self.system_format = QTextCharFormat()
        self.system_format.setForeground(QColor(system_color))
        self.system_format.setFontWeight(QFont.Bold)

        self.gm_format = QTextCharFormat()
        self.gm_format.setForeground(QColor(font_color))
        gm_font = QFont(font_family, font_size)
        self.gm_format.setFont(gm_font)

        user_input_font_family = self.settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(self.settings.value("style/user_input_font_size", 14))
        user_input_font_color = self.settings.value("style/user_input_font_color", "#0d47a1")

        self.player_format = QTextCharFormat()
        self.player_format.setForeground(QColor(user_input_font_color))
        player_font = QFont(user_input_font_family, user_input_font_size)
        player_font.setItalic(True)  
        self.player_format.setFont(player_font)

        self.default_format = QTextCharFormat()
        self.default_format.setForeground(QColor(font_color))  
        default_font = QFont(font_family, font_size)
        self.default_format.setFont(default_font)

        self._setup_background()

        self.skill_check_display = SkillCheckDisplay()
        self.skill_check_display.setVisible(False)
        self.skill_check_display.display_finished.connect(self._on_skill_check_finished)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(0)

        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.addWidget(self.text_edit)

        self.skill_check_layout = QHBoxLayout()
        self.skill_check_layout.setContentsMargins(0, 0, 0, 0)
        self.skill_check_layout.setAlignment(Qt.AlignCenter)
        self.skill_check_layout.addWidget(self.skill_check_display)
        self.content_layout.addLayout(self.skill_check_layout)

        self.main_layout.addWidget(self.content_widget)

        self._gradual_text_iterator: Optional[Iterator[str]] = None
        self._gradual_text_format: Optional[QTextCharFormat] = None
        self._gradual_timer: Optional[QTimer] = None 
        self._is_gradual_display_active: bool = False
        self._pending_immediate_messages: List[Tuple[str, QTextCharFormat]] = [] # Changed to list for queueing

    def _update_formats(self):
        """Update text formats based on current settings."""
        settings = self.settings # Use self.settings

        # Update system message format
        system_color = settings.value("style/system_msg_color", "#FF0000")
        self.system_format.setForeground(QColor(system_color))

        # Update GM/narrator format
        font_color = settings.value("style/font_color", "#000000")
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))

        self.gm_format.setForeground(QColor(font_color))
        gm_font = QFont(font_family, font_size)
        self.gm_format.setFont(gm_font)

        # Update player format
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")

        self.player_format.setForeground(QColor(user_input_font_color))
        player_font = QFont(user_input_font_family, user_input_font_size)
        player_font.setItalic(True)
        self.player_format.setFont(player_font)

        # Update default format
        self.default_format.setForeground(QColor(font_color))
        default_font = QFont(font_family, font_size)
        self.default_format.setFont(default_font)

    def _setup_background(self):
        """Set up the styled background for the game output."""
        settings = self.settings # Use self.settings

        # Get background color, font family, font size, and font color from settings
        bg_color = settings.value("style/output_bg_color", "#D2B48C")
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        font_color = settings.value("style/font_color", "#000000")
        texture_name = settings.value("style/texture_name", "subtle_noise")
        output_opacity = int(settings.value("style/output_opacity", 100))

        # Calculate background opacity
        opacity_percent = output_opacity / 80.0

        # Create a frame around the text edit with decorative border
        self.setStyleSheet(f"""
            GameOutputWidget {{
                background-color: transparent;
                border: 2px solid #333333; /* Dark gray border to match panels */
                border-radius: 18px;
                padding: 3px;
            }}
        """)

        # Create a background-image URL based on texture name
        texture_path = ""
        if texture_name != "none":
            texture_path = f"background-image: url('images/gui/textures/{texture_name}.png');\n                background-repeat: repeat;\n"

        # Apply styled background with rounded edges
        self.text_edit.setStyleSheet(f"""
            QTextEdit {{
                background-color: rgba({int(QColor(bg_color).red())},
                                    {int(QColor(bg_color).green())},
                                    {int(QColor(bg_color).blue())},
                                    {opacity_percent});
                {texture_path}
                color: {font_color};
                border: none;
                border-radius: 15px;
                font-family: '{font_family}';
                font-size: {font_size}pt;
                padding: 20px;
                margin-left: 5px;
                margin-right: 5px;
            }}
            QScrollBar:vertical {{
                border: none;
                background-color: rgba(0, 0, 0, 20);
                width: 12px;
                border-radius: 6px;
                margin: 0px;
            }}
            QScrollBar::handle:vertical {{
                background-color: rgba(80, 80, 80, 150);
                min-height: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                height: 0px;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}
        """)

    def append_text(self, text: str, format: Optional[QTextCharFormat] = None, gradual: bool = True):
        """Append text to the output with the specified format.

        Args:
            text: The text to append
            format: The text format to apply
            gradual: Whether to display the text gradually (respects settings)
        """
        format_name = "None" # For logging
        if format == self.gm_format: format_name = "gm_format"
        elif format == self.system_format: format_name = "system_format"
        elif format == self.player_format: format_name = "player_format"
        elif format == self.default_format: format_name = "default_format"
        logging.debug(f"GameOutputWidget.append_text: Format: '{format_name}', Requested Gradual: {gradual}, Active Gradual: {self._is_gradual_display_active}, Text: '{text[:50]}...'")

        # Determine if gradual display should actually be used based on request AND global setting
        gradual_display_enabled_by_setting = self.settings.value("display/gradual_text_narrative", True, type=bool)
        effective_gradual = gradual and gradual_display_enabled_by_setting
        
        # Override for specific welcome/background texts to always be immediate
        if "CHARACTER BACKGROUND" in text.upper() or "WELCOME TO YOUR ADVENTURE" in text.upper():
            logging.info("Special text detected, forcing immediate display for GameOutputWidget.")
            effective_gradual = False

        if not text.strip():
            logging.warning("GameOutputWidget: Attempting to append empty text, ignoring.")
            self.visualDisplayComplete.emit() 
            return

        if not effective_gradual and self._is_gradual_display_active:
            logging.info(f"GameOutputWidget: Queueing immediate message '{text[:50]}...' as a gradual display is active.")
            self._pending_immediate_messages.append((text, format if format else self.default_format))
            return

        if not self._is_gradual_display_active: # Can only start new display if not already active
            if not effective_gradual:
                logging.debug("GameOutputWidget: Appending immediate message directly.")
                self._insert_text_immediately(text, format) 
                self.visualDisplayComplete.emit() 
                self._process_pending_immediate_messages() 
            else:
                logging.debug(f"GameOutputWidget: Starting gradual display: '{text[:50]}...'")
                self._is_gradual_display_active = True
                # Ensure pending immediate queue is cleared *before* starting new gradual display
                # if any were processed just before this.
                if self._pending_immediate_messages:
                    logger.warning("GameOutputWidget: Starting new gradual display while pending immediate messages existed. This might indicate a logic flaw if they weren't processed.")
                    # self._process_pending_immediate_messages() # Process them now before starting new gradual one.

                self._gradual_text_iterator = iter(text)
                self._gradual_text_format = format if format else self.default_format

                cursor = self.text_edit.textCursor()
                cursor.movePosition(QTextCursor.End)
                self.text_edit.setTextCursor(cursor)

                if not self._gradual_timer:
                     self._gradual_timer = QTimer(self)
                     self._gradual_timer.setSingleShot(True)
                     self._gradual_timer.timeout.connect(self._display_next_char)
                
                char_delay_initial = self.settings.value("display/text_speed_delay_narrative", 30, type=int)
                char_delay_initial = max(1, char_delay_initial) # Ensure at least 1ms for timer
                QTimer.singleShot(char_delay_initial, self._display_next_char) # Start with configured delay
        else: # Gradual display is already active
            if effective_gradual: 
                logger.warning(f"GameOutputWidget: Ignoring NEW gradual text '{text[:30]}' because a gradual display is ALREADY active. This text should have been queued by the Orchestrator.")
                # To prevent stalling, immediately emit completion for this ignored text.
                self.visualDisplayComplete.emit()
            # If it was an *immediate* message while gradual was active, it was already queued above.

    def _insert_text_immediately(self, text: str, format: Optional[QTextCharFormat]):
        """Helper to append text immediately and add newlines."""
        cursor = self.text_edit.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.text_edit.setTextCursor(cursor)
        
        current_format = format if format else self.default_format
        cursor.setCharFormat(current_format)
        
        cursor.insertText(text)
        if not text.endswith('\n'):
            cursor.insertText('\n')
        cursor.insertText('\n') # Extra blank line
        self.text_edit.ensureCursorVisible()

    def _process_pending_immediate_messages(self):
        """Processes any queued immediate messages if gradual display is not active."""
        if self._is_gradual_display_active:
            return # Don't process if gradual is still running
        
        while self._pending_immediate_messages:
            text, text_format = self._pending_immediate_messages.pop(0)
            logging.info(f"GameOutputWidget: Processing pending immediate message '{text[:50]}...'")
            self._insert_text_immediately(text, text_format)
            # Emitting visualDisplayComplete for each processed pending message
            # might be too chatty for the orchestrator.
            # The orchestrator should ideally wait for the original gradual display to finish,
            # then this queue is flushed, and *then* the "overall" completion is signaled.
            # However, for simplicity, let's emit for each. Orchestrator must handle this.
            self.visualDisplayComplete.emit()

    def _display_next_char(self):
        """Displays the next character from the iterator and schedules the next call."""
        if not self._is_gradual_display_active or not self._gradual_text_iterator:
            if self._is_gradual_display_active: 
                self._is_gradual_display_active = False
                self.visualDisplayComplete.emit()
                self._process_pending_immediate_messages() 
            return

        try:
            char = next(self._gradual_text_iterator)
            cursor = self.text_edit.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.text_edit.setTextCursor(cursor)

            if self._gradual_text_format:
                cursor.setCharFormat(self._gradual_text_format)
            cursor.insertText(char)
            self.text_edit.ensureCursorVisible()

            # --- ECFA Change: Use unified settings key ---
            char_delay = self.settings.value("display/text_speed_delay", 30, type=int) 
            # --- End ECFA Change ---
            char_delay = max(5, char_delay)
            
            if self._gradual_timer: 
                self._gradual_timer.start(char_delay)

        except StopIteration:
            logging.debug("GameOutputWidget: Gradual display finished for one segment.")
            cursor = self.text_edit.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.text_edit.setTextCursor(cursor)
            if not self.text_edit.toPlainText().endswith('\n\n'): 
                 if self.text_edit.toPlainText().endswith('\n'):
                     cursor.insertText('\n')
                 else:
                     cursor.insertText('\n\n')
            self.text_edit.ensureCursorVisible()

            self._is_gradual_display_active = False
            self._gradual_text_iterator = None
            self._gradual_text_format = None
            
            self.visualDisplayComplete.emit() 
            
            self._process_pending_immediate_messages()

        except Exception as e:
             logging.error(f"GameOutputWidget: Error during gradual display: {e}", exc_info=True)
             self._is_gradual_display_active = False
             self._gradual_text_iterator = None
             self._gradual_text_format = None
             if self._gradual_timer and self._gradual_timer.isActive():
                 self._gradual_timer.stop()
             self.visualDisplayComplete.emit() 
             self._pending_immediate_messages.clear()
             self._process_pending_immediate_messages() 
             
    def _insert_text(self, text: str, format: Optional[QTextCharFormat] = None):
        """Helper method to insert text directly with a format."""
        cursor = self.text_edit.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.text_edit.setTextCursor(cursor)
        if format:
            cursor.setCharFormat(format)
        else:
            cursor.setCharFormat(self.default_format) # Fallback to default
        cursor.insertText(text)
        self.text_edit.ensureCursorVisible()

    def append_system_message(self, message: str, gradual: bool = False):
        """Append a system message."""
        logging.debug(f"GAME_OUTPUT: append_system_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        self.append_text("[SYSTEM] " + message, self.system_format, gradual=gradual)

    def append_gm_message(self, message: str, gradual: bool = True):
        """Append a game master message."""
        logging.debug(f"GAME_OUTPUT: append_gm_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        processed_message = "\n".join(message.split("\n"))
        if "===== CHARACTER BACKGROUND =====" in message:
            logging.info("Character background detected, using immediate display for GM message")
            gradual = False
        self.append_text(processed_message, self.gm_format, gradual=gradual)

    def append_player_message(self, message: str, gradual: bool = False):
        """Append a player message."""
        logging.debug(f"GAME_OUTPUT: append_player_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        self.append_text("You: " + message, self.player_format, gradual=gradual)

    def clear(self):
        """Clear the output."""
        # Stop any gradual display and clear state before clearing
        if self._gradual_timer and self._gradual_timer.isActive():
            self._gradual_timer.stop()
        self._is_gradual_display_active = False
        self._gradual_text_iterator = None
        self._gradual_text_format = None
        self._pending_immediate_message = None
        # Clear the text edit
        self.text_edit.clear()

    def show_skill_check(self, result: SkillCheckResult, context: str = "", duration_ms: int = 3000) -> None:
        """
        Display a skill check result with animation.

        Args:
            result: The SkillCheckResult object containing the check details
            context: Optional context description for the check
            duration_ms: How long to display the result (in milliseconds)
        """
        # Stop any gradual display and clear state before showing skill check
        if self._gradual_timer and self._gradual_timer.isActive():
            logging.debug("Stopping gradual display for skill check.")
            self._gradual_timer.stop()
        self._is_gradual_display_active = False
        self._gradual_text_iterator = None
        self._gradual_text_format = None
        self._pending_immediate_message = None

        # Show the skill check
        self.skill_check_display.show_check_result(result, context, duration_ms)

    def _on_skill_check_finished(self) -> None:
        """
        Handler for when the skill check display is finished.
        Returns focus to the text edit.
        """
        # Ensure the text edit is visible and has focus
        self.text_edit.setFocus()

    def process_skill_check_command(self, command: str) -> bool:
        """
        Process a skill check command from the narrative.

        Args:
            command: The command string in format {STAT_CHECK:<stat>:<difficulty>:<context>}

        Returns:
            True if the command was processed successfully, False otherwise
        """
        from core.agents.rule_checker import get_rule_checker_agent

        try:
            # Parse the command format {STAT_CHECK:<stat>:<difficulty>:<context>}
            parts = command.strip().split(':')
            if len(parts) < 3:
                logging.warning(f"Invalid STAT_CHECK command format: {command}")
                return False

            stat_type = parts[1].strip().upper()
            difficulty = int(parts[2].strip())
            context = parts[3].strip() if len(parts) > 3 else ""

            # Get the rule checker agent to perform the skill check
            rule_checker = get_rule_checker_agent()
            check_result = rule_checker.perform_skill_check(stat_type, difficulty, context)

            if not check_result["success"]:
                logging.error(f"Skill check failed: {check_result.get('error', 'Unknown error')}")
                return False

            # Display the skill check result
            self.show_skill_check(check_result["result"], check_result["context"])

            return True

        except Exception as e:
            logging.error(f"Error processing skill check command: {e}")
            return False

    def stop_gradual_display(self):
        """Immediately stops any ongoing gradual text display and processes pending messages quickly."""
        logging.info("GameOutputWidget: Stopping current gradual display and flushing pending messages.")
        if self._gradual_timer and self._gradual_timer.isActive():
            self._gradual_timer.stop()
        
        # If an iterator was active, display remaining text immediately
        if self._gradual_text_iterator:
            remaining_text = "".join(list(self._gradual_text_iterator))
            if remaining_text:
                self._insert_text_immediately(remaining_text, self._gradual_text_format)
            self._gradual_text_iterator = None
            self._gradual_text_format = None

        self._is_gradual_display_active = False # Mark as not active
        
        # Process all pending immediate messages
        self._process_pending_immediate_messages()
            
        # Emit completion after flushing everything, if no pending messages started new gradual display
        if not self._is_gradual_display_active:
            self.visualDisplayComplete.emit()
```

### File: ..\gui\components\inventory_panel.py

```python
#!/usr/bin/env python3
"""
Inventory panel widget for the RPG game GUI.
This module provides a widget for displaying and interacting with the player's inventory.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QScrollArea, QFrame, QGroupBox, QListWidget, QListWidgetItem,
    QPushButton, QMenu, QToolButton, QSizePolicy, QComboBox
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont, QPixmap, QIcon, QCursor, QColor

from core.inventory.item_manager import get_inventory_manager
from core.utils.logging_config import get_logger

logger = get_logger("INVENTORY")

class InventoryPanelWidget(QScrollArea):
    """Widget for displaying and interacting with inventory."""
    
    # Signals for inventory actions
    item_use_requested = Signal(str)
    item_examine_requested = Signal(str)
    item_equip_requested = Signal(str)
    item_unequip_requested = Signal(str)
    item_drop_requested = Signal(str)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the inventory panel widget."""
        super().__init__(parent)
        
        # Set up the scroll area
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setStyleSheet("""
            QScrollArea {
                background-color: #2D2D30;
                border: none;
            }
        """)
        
        # Create the main widget
        self.inventory_widget = QWidget()
        self.setWidget(self.inventory_widget)
        
        # Initialize item list
        self.items = []
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self.inventory_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Create inventory header
        self._create_header()
        
        # Create item list section
        self._create_item_list()
        
        # Create item details section
        self._create_item_details()
    
    def _create_header(self):
        """Create the inventory header section."""
        # Create header layout
        header_layout = QHBoxLayout()
        
        # Create currency group
        currency_group = QGroupBox("Currency")
        currency_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        currency_layout = QHBoxLayout(currency_group)
        
        # Create labels for currency
        gold_label = QLabel("Gold:")
        gold_label.setStyleSheet("color: #FFD700; font-weight: bold;")
        self.gold_value = QLabel("0")
        self.gold_value.setStyleSheet("color: #FFD700;")
        
        silver_label = QLabel("Silver:")
        silver_label.setStyleSheet("color: #C0C0C0; font-weight: bold;")
        self.silver_value = QLabel("0")
        self.silver_value.setStyleSheet("color: #C0C0C0;")
        
        copper_label = QLabel("Copper:")
        copper_label.setStyleSheet("color: #B87333; font-weight: bold;")
        self.copper_value = QLabel("0")
        self.copper_value.setStyleSheet("color: #B87333;")
        
        # Add currency labels to layout
        currency_layout.addWidget(gold_label)
        currency_layout.addWidget(self.gold_value)
        currency_layout.addWidget(silver_label)
        currency_layout.addWidget(self.silver_value)
        currency_layout.addWidget(copper_label)
        currency_layout.addWidget(self.copper_value)
        
        # Create weight group
        weight_group = QGroupBox("Weight")
        weight_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        weight_layout = QHBoxLayout(weight_group)
        
        # Create labels for weight
        current_weight_label = QLabel("Current:")
        current_weight_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.current_weight_value = QLabel("0.0")
        self.current_weight_value.setStyleSheet("color: #E0E0E0;")
        
        max_weight_label = QLabel("Max:")
        max_weight_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.max_weight_value = QLabel("50.0")
        self.max_weight_value.setStyleSheet("color: #E0E0E0;")
        
        # Add weight labels to layout
        weight_layout.addWidget(current_weight_label)
        weight_layout.addWidget(self.current_weight_value)
        weight_layout.addWidget(max_weight_label)
        weight_layout.addWidget(self.max_weight_value)
        
        # Add groups to header layout
        header_layout.addWidget(currency_group)
        header_layout.addWidget(weight_group)
        
        # Add header layout to main layout
        self.main_layout.addLayout(header_layout)
    
    def _create_item_list(self):
        """Create the item list section."""
        # Create item list group
        item_list_group = QGroupBox("Items")
        item_list_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        item_list_layout = QVBoxLayout(item_list_group)
        
        # Create filter layout
        filter_layout = QHBoxLayout()
        
        # Create filter combobox
        filter_label = QLabel("Filter:")
        filter_label.setStyleSheet("color: #BBBBBB;")
        
        self.filter_combo = QComboBox()
        self.filter_combo.addItem("All")
        self.filter_combo.addItem("Weapons")
        self.filter_combo.addItem("Armor")
        self.filter_combo.addItem("Consumables")
        self.filter_combo.addItem("Quest Items")
        self.filter_combo.addItem("Other")
        self.filter_combo.setStyleSheet("""
            QComboBox {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QComboBox::drop-down {
                border: none;
                border-left: 1px solid #555555;
            }
            QComboBox QAbstractItemView {
                background-color: #2D2D30;
                color: #E0E0E0;
                selection-background-color: #0E639C;
            }
        """)
        
        # Add filter components to layout
        filter_layout.addWidget(filter_label)
        filter_layout.addWidget(self.filter_combo, 1)
        
        # Create item list
        self.item_list = QListWidget()
        self.item_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.item_list.setAlternatingRowColors(True)
        self.item_list.setSelectionMode(QListWidget.SingleSelection)
        
        # Add the filter layout and item list to the item list layout
        item_list_layout.addLayout(filter_layout)
        item_list_layout.addWidget(self.item_list)
        
        # Create action buttons
        button_layout = QHBoxLayout()
        
        # Style for buttons
        button_style = """
            QPushButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
            }
            QPushButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
            QPushButton:disabled {
                background-color: #2A2A2A;
                color: #666666;
                border-color: #444444;
            }
        """
        
        # Create action buttons
        self.use_button = QPushButton("Use")
        self.use_button.setStyleSheet(button_style)
        self.use_button.clicked.connect(self._on_use_clicked)
        
        self.examine_button = QPushButton("Examine")
        self.examine_button.setStyleSheet(button_style)
        self.examine_button.clicked.connect(self._on_examine_clicked)
        
        self.equip_button = QPushButton("Equip")
        self.equip_button.setStyleSheet(button_style)
        self.equip_button.clicked.connect(self._on_equip_clicked)
        
        self.drop_button = QPushButton("Drop")
        self.drop_button.setStyleSheet(button_style)
        self.drop_button.clicked.connect(self._on_drop_clicked)
        
        # Disable buttons initially
        self.use_button.setEnabled(False)
        self.examine_button.setEnabled(False)
        self.equip_button.setEnabled(False)
        self.drop_button.setEnabled(False)
        
        # Add buttons to button layout
        button_layout.addWidget(self.use_button)
        button_layout.addWidget(self.examine_button)
        button_layout.addWidget(self.equip_button)
        button_layout.addWidget(self.drop_button)
        
        # Add button layout to item list layout
        item_list_layout.addLayout(button_layout)
        
        # Add item list group to main layout
        self.main_layout.addWidget(item_list_group)
        
        # Connect item selection signal
        self.item_list.itemSelectionChanged.connect(self._on_item_selection_changed)
        
        # Connect right-click context menu
        self.item_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.item_list.customContextMenuRequested.connect(self._show_context_menu)
    
    def _create_item_details(self):
        """Create the item details section."""
        # Create item details group
        item_details_group = QGroupBox("Item Details")
        item_details_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        item_details_layout = QVBoxLayout(item_details_group)
        
        # Create labels for item details
        self.item_name_label = QLabel("No item selected")
        self.item_name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #E0E0E0;")
        
        self.item_type_label = QLabel("")
        self.item_type_label.setStyleSheet("font-size: 12pt; color: #CCCCCC;")
        
        self.item_description_label = QLabel("")
        self.item_description_label.setStyleSheet("color: #BBBBBB;")
        self.item_description_label.setWordWrap(True)
        
        # Add labels to item details layout
        item_details_layout.addWidget(self.item_name_label)
        item_details_layout.addWidget(self.item_type_label)
        item_details_layout.addWidget(self.item_description_label)
        
        # Create stats layout
        stats_layout = QGridLayout()
        
        # Add stats layout to item details layout
        item_details_layout.addLayout(stats_layout)
        
        # Add item details group to main layout
        self.main_layout.addWidget(item_details_group)
        
        # Add a stretch to push everything up
        self.main_layout.addStretch(1)
    
    def _on_item_selection_changed(self):
        """Handle item selection change."""
        selected_list_items = self.item_list.selectedItems()
        
        if not selected_list_items:
            self.use_button.setEnabled(False)
            self.examine_button.setEnabled(False)
            self.equip_button.setEnabled(False)
            self.drop_button.setEnabled(False)
            self.item_name_label.setText("No item selected")
            self.item_type_label.setText("")
            self.item_description_label.setText("")
            return
        
        list_item = selected_list_items[0]
        selected_item_id = list_item.data(Qt.UserRole) # Retrieve item_id

        # Find the corresponding item dict in self.items (list of dicts)
        selected_item_dict = None
        for item_d in self.items:
            if item_d['id'] == selected_item_id:
                selected_item_dict = item_d
                break
        
        if not selected_item_dict:
            logger.error(f"Selected item ID {selected_item_id} not found in internal self.items list.")
            # Clear details and disable buttons as a fallback
            self.use_button.setEnabled(False); self.examine_button.setEnabled(False)
            self.equip_button.setEnabled(False); self.drop_button.setEnabled(False)
            self.item_name_label.setText("Error: Item not found"); self.item_type_label.setText(""); self.item_description_label.setText("")
            return

        self.examine_button.setEnabled(True)
        self.drop_button.setEnabled(True)
        
        item_type_val = selected_item_dict.get('type', 'miscellaneous')
        is_equipped_val = selected_item_dict.get('equipped', False)

        self.use_button.setEnabled(item_type_val == 'consumable')
        
        can_be_equipped = item_type_val in ['weapon', 'armor', 'shield', 'accessory'] # Add shield and accessory
        if can_be_equipped:
            self.equip_button.setEnabled(True)
            self.equip_button.setText("Unequip" if is_equipped_val else "Equip")
        else:
            self.equip_button.setEnabled(False)
            self.equip_button.setText("Equip") # Default text if not equippable
            
        self.item_name_label.setText(selected_item_dict.get('name', 'Unknown Item'))
        self.item_type_label.setText(f"Type: {item_type_val.capitalize()}")
        
        # For description, we need the full Item object ideally, or it needs to be in the dict
        # Let's fetch the full item object for description and other details
        inv_manager = get_inventory_manager() # Assuming this gives the correct singleton
        full_item_obj = inv_manager.get_item(selected_item_id)
        if full_item_obj:
            self.item_description_label.setText(getattr(full_item_obj, 'description', 'No description available.'))
            # Here you could also populate stats display if you add a stats section to item details in inventory panel
        else:
            self.item_description_label.setText(selected_item_dict.get('description', 'No description available.'))
            
    def _show_context_menu(self, position):
        """Show the context menu for the item list."""
        # Get the selected item
        selected_items = self.item_list.selectedItems()
        
        if not selected_items:
            return
        
        # Get the item data
        item_index = self.item_list.row(selected_items[0])
        item = self.items[item_index]
        
        # Create the context menu
        context_menu = QMenu(self)
        context_menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #0E639C;
            }
        """)
        
        # Add menu actions
        examine_action = context_menu.addAction("Examine")
        
        # Add Use action if applicable
        use_action = None
        if item.get('type') == 'consumable':
            use_action = context_menu.addAction("Use")
        
        # Add Equip/Unequip action if applicable
        equip_action = None
        if item.get('type') in ['weapon', 'armor']:
            if item.get('equipped', False):
                equip_action = context_menu.addAction("Unequip")
            else:
                equip_action = context_menu.addAction("Equip")
        
        # Add Drop action
        drop_action = context_menu.addAction("Drop")
        
        # Show the menu and get the action
        action = context_menu.exec_(QCursor.pos())
        
        # Process the action
        if action == examine_action:
            self._on_examine_clicked()
        elif use_action and action == use_action:
            self._on_use_clicked()
        elif equip_action and action == equip_action:
            if item.get('equipped', False):
                self._on_unequip_clicked()
            else:
                self._on_equip_clicked()
        elif action == drop_action:
            self._on_drop_clicked()
    def _show_context_menu(self, position):
        """Show the context menu for the item list."""
        list_widget_item = self.item_list.itemAt(position)
        if not list_widget_item:
            return
        
        selected_item_id = list_widget_item.data(Qt.UserRole)
        if not selected_item_id:
            return

        # Find the item dict in self.items to get its properties like type and equipped status
        item_dict = next((it_d for it_d in self.items if it_d['id'] == selected_item_id), None)
        if not item_dict:
            logger.error(f"Context menu: Item ID {selected_item_id} not found in internal self.items list.")
            return
        
        item_type_val = item_dict.get('type', 'miscellaneous')
        is_equipped_val = item_dict.get('equipped', False)

        context_menu = QMenu(self)
        context_menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #0E639C;
            }
        """)
        
        examine_action = context_menu.addAction("Examine")
        use_action = None
        if item_type_val == 'consumable':
            use_action = context_menu.addAction("Use")
        
        equip_action = None
        can_be_equipped = item_type_val in ['weapon', 'armor', 'shield', 'accessory']
        if can_be_equipped:
            equip_action_text = "Unequip" if is_equipped_val else "Equip"
            equip_action = context_menu.addAction(equip_action_text)
        
        drop_action = context_menu.addAction("Drop")
        
        action = context_menu.exec_(QCursor.pos())
        
        if action == examine_action:
            self.item_examine_requested.emit(selected_item_id)
        elif use_action and action == use_action:
            self.item_use_requested.emit(selected_item_id)
        elif equip_action and action == equip_action:
            if is_equipped_val:
                self.item_unequip_requested.emit(selected_item_id) # Pass item_id
            else:
                self.item_equip_requested.emit(selected_item_id)
        elif action == drop_action:
            self.item_drop_requested.emit(selected_item_id)

    def _on_use_clicked(self):
        """Handle use button click."""
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            self.item_use_requested.emit(selected_item_id)
    
    def _on_examine_clicked(self):
        """Handle examine button click."""
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            self.item_examine_requested.emit(selected_item_id)
    
    def _on_equip_clicked(self):
        """Handle equip/unequip button click."""
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: return
        
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if not selected_item_id: return

        # Find the item in our local self.items list to check its 'equipped' status
        item_dict = next((it_d for it_d in self.items if it_d['id'] == selected_item_id), None)
        if not item_dict: return

        if item_dict.get('equipped', False):
            self.item_unequip_requested.emit(selected_item_id) # Pass item_id for unequip
        else:
            self.item_equip_requested.emit(selected_item_id)
    
    def _on_unequip_clicked(self):
        """Handle unequip button click."""
        self._get_selected_item_id(self.item_unequip_requested)
    
    def _on_drop_clicked(self):
        """Handle drop button click."""
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            self.item_drop_requested.emit(selected_item_id)
    
    def _get_selected_item_id(self, signal):
        """Get the selected item ID and emit the signal."""
        # Get the selected item
        selected_items = self.item_list.selectedItems()
        
        if not selected_items:
            return
        
        # Get the item data
        item_index = self.item_list.row(selected_items[0])
        item = self.items[item_index]
        
        # Emit the signal with the item ID
        signal.emit(item.get('id', ''))
    
    def update_inventory(self, inventory_manager_instance: Optional[Any]): # Renamed for clarity
        """Update the inventory panel with inventory data.
        
        Args:
            inventory_manager_instance: The InventoryManager instance.
        """
        if not inventory_manager_instance:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")
            self.current_weight_value.setText("0.0")
            self.max_weight_value.setText("0.0") 
            self.item_list.clear()
            self.items = [] 
            self._on_item_selection_changed() 
            logger.warning("InventoryPanelWidget.update_inventory called with no InventoryManager instance.")
            return

        inv_manager = inventory_manager_instance
        logger.info(f"InventoryPanelWidget: Updating with InventoryManager instance ID: {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")


        if hasattr(inv_manager, 'currency') and inv_manager.currency:
            currency_obj = inv_manager.currency
            self.gold_value.setText(str(getattr(currency_obj, 'gold', 0)))
            self.silver_value.setText(str(getattr(currency_obj, 'silver', 0)))
            total_copper_val = getattr(currency_obj, '_copper', 0) 
            copper_per_silver_val = getattr(currency_obj, '_copper_per_silver', 100)
            self.copper_value.setText(str(total_copper_val % copper_per_silver_val))
        else:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")

        current_weight = getattr(inv_manager, 'get_current_weight', lambda: 0.0)()
        weight_limit = getattr(inv_manager, 'weight_limit', 0.0)
        self.current_weight_value.setText(f"{current_weight:.1f}")
        self.max_weight_value.setText(f"{weight_limit:.1f}")
        
        self.items = [] 
        self.item_list.clear()

        actual_item_objects = getattr(inv_manager, 'items', []) 
        
        logger.debug(f"InventoryPanel: Found {len(actual_item_objects)} item objects from InventoryManager instance {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}.")

        for item_obj in actual_item_objects:
            if not hasattr(item_obj, 'id') or not hasattr(item_obj, 'name') or not hasattr(item_obj, 'item_type'):
                logger.warning(f"InventoryPanel: Skipping item object due to missing attributes: {item_obj}")
                continue

            is_equipped_flag = False
            if hasattr(inv_manager, 'is_item_equipped'):
                is_equipped_flag = inv_manager.is_item_equipped(item_obj.id)
            
            gui_item_dict = {
                'id': item_obj.id,
                'name': item_obj.name,
                'type': item_obj.item_type.value.lower() if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type).lower(),
                'description': getattr(item_obj, 'description', ''),
                'count': getattr(item_obj, 'quantity', 1),
                'equipped': is_equipped_flag,
            }
            self.items.append(gui_item_dict) 

            filter_text = self.filter_combo.currentText().lower()
            item_type_for_filter = gui_item_dict.get('type', '').lower()
            is_quest_item_flag = getattr(item_obj, 'is_quest_item', False) 

            if filter_text == 'all' or \
               filter_text == item_type_for_filter or \
               (filter_text == 'weapons' and item_type_for_filter == 'weapon') or \
               (filter_text == 'armor' and item_type_for_filter in ['armor', 'shield', 'helmet']) or \
               (filter_text == 'consumables' and item_type_for_filter in ['consumable', 'potion', 'food']) or \
               (filter_text == 'quest items' and is_quest_item_flag) or \
               (filter_text == 'other' and item_type_for_filter not in ['weapon', 'armor', 'shield', 'helmet', 'consumable', 'potion', 'food'] and not is_quest_item_flag):
                
                item_name_display = gui_item_dict.get('name', 'Unknown Item')
                item_count_display = gui_item_dict.get('count', 1)
                
                list_widget_item = QListWidgetItem()
                
                display_text = item_name_display
                if item_count_display > 1 and getattr(item_obj, 'is_stackable', False):
                    display_text += f" ({item_count_display})"
                
                if gui_item_dict.get('equipped', False):
                    display_text += " (Equipped)"
                    list_widget_item.setForeground(QColor('#4CAF50')) 
                
                list_widget_item.setText(display_text)
                list_widget_item.setData(Qt.UserRole, gui_item_dict['id']) 
                
                self.item_list.addItem(list_widget_item)
        
        self._on_item_selection_changed()
        logger.info(f"InventoryPanel updated with manager {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}. Displaying {self.item_list.count()} items after filter. Internal self.items count: {len(self.items)}.")
```

### File: ..\gui\components\journal_panel.py

```python
#!/usr/bin/env python3
"""
Journal panel widget for the RPG game GUI.
This module provides a widget for displaying and editing the player's journal.
"""

import logging
from typing import Optional, Dict, Any, List
from enum import Enum

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QScrollArea, QFrame, QGroupBox, QListWidget, QListWidgetItem,
    QPushButton, QTabWidget, QTextEdit, QSplitter, QTabBar
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QFont, QTextCharFormat, QColor

from core.base.state import get_state_manager
from gui.utils.resource_manager import get_resource_manager


class JournalSectionType(Enum):
    """Types of journal sections."""
    CHARACTER = 0
    QUESTS = 1
    NOTES = 2


class JournalPanelWidget(QScrollArea):
    """Widget for displaying and editing the journal."""
    
    # Signals for journal actions
    journal_updated = Signal(dict)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the journal panel widget."""
        super().__init__(parent)
        
        # Set up the scroll area
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setStyleSheet("""
            QScrollArea {
                background-color: #2D2D30;
                border: none;
            }
        """)
        
        # Create the main widget
        self.journal_widget = QWidget()
        self.setWidget(self.journal_widget)
        
        # Journal data structure
        self.journal_data = {
            "character": "",
            "quests": {},
            "notes": []
        }
        
        # Get state manager
        self.state_manager = get_state_manager()
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self.journal_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Create tab widget for sections
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
            }
            QTabWidget::pane {
                background-color: #333333;
                border: 1px solid #555555;
                border-top: none;
                border-radius: 0 0 5px 5px;
            }
            QTabBar::tab {
                background-color: #444444;
                color: #BBBBBB;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                padding: 8px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #333333;
                color: #E0E0E0;
                border-bottom: none;
            }
            QTabBar::tab:hover:!selected {
                background-color: #505050;
            }
        """)
        
        # Add tabs for each section
        self._setup_character_tab()
        self._setup_quests_tab()
        self._setup_notes_tab()
        
        # Add tab widget to main layout
        self.main_layout.addWidget(self.tab_widget)
    
    def _setup_character_tab(self):
        """Set up the character information tab."""
        # Create character tab
        character_tab = QWidget()
        character_layout = QVBoxLayout(character_tab)
        
        # Create character info editor
        self.character_info_editor = QTextEdit()
        self.character_info_editor.setPlaceholderText("Character bio and information will appear here...")
        self.character_info_editor.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
        """)
        self.character_info_editor.textChanged.connect(self._on_character_info_changed)
        
        # Add editor to layout
        character_layout.addWidget(self.character_info_editor)
        
        # Add tab to tab widget
        self.tab_widget.addTab(character_tab, "Character")
    
    def _setup_quests_tab(self):
        """Set up the quests tab."""
        # Create quests tab
        quests_tab = QWidget()
        quests_layout = QVBoxLayout(quests_tab)
        
        # Create quest status tabs
        self.quest_status_tabs = QTabWidget()
        self.quest_status_tabs.setStyleSheet("""
            QTabBar::tab {
                background-color: #333333;
                color: #BBBBBB;
                border: 1px solid #444444;
                border-bottom: none;
                border-top-left-radius: 3px;
                border-top-right-radius: 3px;
                padding: 5px 10px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2D2D30;
                color: #E0E0E0;
                border-bottom: none;
            }
            QTabBar::tab:hover:!selected {
                background-color: #3A3A3A;
            }
        """)
        
        # Create lists for active, completed, and failed quests
        self.active_quests_list = QListWidget()
        self.active_quests_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.active_quests_list.setAlternatingRowColors(True)
        self.active_quests_list.itemClicked.connect(self._on_quest_selected)
        
        self.completed_quests_list = QListWidget()
        self.completed_quests_list.setStyleSheet(self.active_quests_list.styleSheet())
        self.completed_quests_list.setAlternatingRowColors(True)
        self.completed_quests_list.itemClicked.connect(self._on_quest_selected)
        
        self.failed_quests_list = QListWidget()
        self.failed_quests_list.setStyleSheet(self.active_quests_list.styleSheet())
        self.failed_quests_list.setAlternatingRowColors(True)
        self.failed_quests_list.itemClicked.connect(self._on_quest_selected)
        
        # Add lists to quest status tabs
        self.quest_status_tabs.addTab(self.active_quests_list, "Active")
        self.quest_status_tabs.addTab(self.completed_quests_list, "Completed")
        self.quest_status_tabs.addTab(self.failed_quests_list, "Failed")
        
        # Create quest details view
        self.quest_details = QTextEdit()
        self.quest_details.setReadOnly(True)
        self.quest_details.setPlaceholderText("Select a quest to view details...")
        self.quest_details.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
        """)
        
        # Create splitter for quest list and details
        quests_splitter = QSplitter(Qt.Vertical)
        quests_splitter.addWidget(self.quest_status_tabs)
        quests_splitter.addWidget(self.quest_details)
        quests_splitter.setSizes([int(quests_tab.height() * 0.4), int(quests_tab.height() * 0.6)])
        
        # Add splitter to layout
        quests_layout.addWidget(quests_splitter)
        
        # Add tab to tab widget
        self.tab_widget.addTab(quests_tab, "Quests")
    
    def _setup_notes_tab(self):
        """Set up the personal notes tab."""
        # Create notes tab
        notes_tab = QWidget()
        notes_layout = QVBoxLayout(notes_tab)
        
        # Create notes list
        self.notes_list = QListWidget()
        self.notes_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.notes_list.setAlternatingRowColors(True)
        self.notes_list.itemClicked.connect(self._on_note_selected)
        
        # Create note editor
        self.note_editor = QTextEdit()
        self.note_editor.setPlaceholderText("Select a note to edit or create a new one...")
        self.note_editor.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
        """)
        self.note_editor.textChanged.connect(self._on_note_text_changed)
        
        # Create buttons for note management
        button_layout = QHBoxLayout()
        
        # Style for buttons
        button_style = """
            QPushButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
            }
            QPushButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
            QPushButton:disabled {
                background-color: #2A2A2A;
                color: #666666;
                border-color: #444444;
            }
        """
        
        # Create buttons
        self.new_note_button = QPushButton("New Note")
        self.new_note_button.setStyleSheet(button_style)
        self.new_note_button.clicked.connect(self._on_new_note_clicked)
        
        self.delete_note_button = QPushButton("Delete Note")
        self.delete_note_button.setStyleSheet(button_style)
        self.delete_note_button.clicked.connect(self._on_delete_note_clicked)
        self.delete_note_button.setEnabled(False)
        
        self.save_note_button = QPushButton("Save Note")
        self.save_note_button.setStyleSheet(button_style)
        self.save_note_button.clicked.connect(self._on_save_note_clicked)
        self.save_note_button.setEnabled(False)
        
        # Add buttons to layout
        button_layout.addWidget(self.new_note_button)
        button_layout.addWidget(self.delete_note_button)
        button_layout.addStretch()
        button_layout.addWidget(self.save_note_button)
        
        # Create splitter for notes list and editor
        notes_splitter = QSplitter(Qt.Vertical)
        notes_splitter.addWidget(self.notes_list)
        
        # Create editor container with buttons
        editor_container = QWidget()
        editor_layout = QVBoxLayout(editor_container)
        editor_layout.setContentsMargins(0, 0, 0, 0)
        editor_layout.addWidget(self.note_editor)
        editor_layout.addLayout(button_layout)
        
        notes_splitter.addWidget(editor_container)
        notes_splitter.setSizes([int(notes_tab.height() * 0.3), int(notes_tab.height() * 0.7)])
        
        # Add splitter to layout
        notes_layout.addWidget(notes_splitter)
        
        # Add tab to tab widget
        self.tab_widget.addTab(notes_tab, "Notes")
    
    def _on_character_info_changed(self):
        """Handle character info text changes."""
        # Update journal data
        self.journal_data["character"] = self.character_info_editor.toPlainText()
        
        # Emit journal updated signal
        self._emit_journal_updated()
    
    def _on_quest_selected(self, item: QListWidgetItem):
        """Handle quest selection."""
        # Get the quest ID from the item
        quest_id = item.data(Qt.UserRole)
        
        # Get the quest data
        quest_status = self._get_current_quest_status()
        if quest_status and quest_id in self.journal_data["quests"]:
            quest_data = self.journal_data["quests"][quest_id]
            
            # Update quest details
            self.quest_details.clear()
            
            # Format the quest details
            html = f"<h2>{quest_data['title']}</h2>"
            html += f"<p><b>Status:</b> {quest_status}</p>"
            
            if "description" in quest_data:
                html += f"<p>{quest_data['description']}</p>"
            
            if "objectives" in quest_data and quest_data["objectives"]:
                html += "<h3>Objectives:</h3>"
                html += "<ul>"
                for objective in quest_data["objectives"]:
                    if objective.get("completed", False):
                        html += f"<li><s>{objective['description']}</s></li>"
                    else:
                        html += f"<li>{objective['description']}</li>"
                html += "</ul>"
            
            if "rewards" in quest_data and quest_data["rewards"]:
                html += "<h3>Rewards:</h3>"
                html += "<ul>"
                for reward in quest_data["rewards"]:
                    html += f"<li>{reward}</li>"
                html += "</ul>"
            
            if "notes" in quest_data and quest_data["notes"]:
                html += "<h3>Notes:</h3>"
                html += f"<p>{quest_data['notes']}</p>"
            
            self.quest_details.setHtml(html)
    
    def _get_current_quest_status(self) -> Optional[str]:
        """Get the currently selected quest status tab."""
        current_tab_index = self.quest_status_tabs.currentIndex()
        if current_tab_index == 0:
            return "active"
        elif current_tab_index == 1:
            return "completed"
        elif current_tab_index == 2:
            return "failed"
        return None
    
    def _on_note_selected(self, item: QListWidgetItem):
        """Handle note selection."""
        # Get the note index from the item
        note_index = item.data(Qt.UserRole)
        
        # Enable delete and save buttons
        self.delete_note_button.setEnabled(True)
        self.save_note_button.setEnabled(True)
        
        # Get the note data
        if 0 <= note_index < len(self.journal_data["notes"]):
            note_data = self.journal_data["notes"][note_index]
            
            # Update note editor
            self.note_editor.setPlainText(note_data["content"])
            
            # Store the current note index
            self.note_editor.setProperty("note_index", note_index)
    
    def _on_note_text_changed(self):
        """Handle note text changes."""
        # Enable the save button if there is text
        self.save_note_button.setEnabled(bool(self.note_editor.toPlainText()))
    
    def _on_new_note_clicked(self):
        """Handle new note button click."""
        # Create a new note with a timestamp
        from datetime import datetime
        
        # Create new note with current time
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        new_note = {
            "title": f"Note {len(self.journal_data['notes']) + 1}",
            "timestamp": timestamp,
            "content": ""
        }
        
        # Add to journal data
        self.journal_data["notes"].append(new_note)
        
        # Add to list
        self._update_notes_list()
        
        # Select the new note
        self.notes_list.setCurrentRow(len(self.journal_data["notes"]) - 1)
        
        # Set focus to the editor
        self.note_editor.clear()
        self.note_editor.setFocus()
        
        # Store the current note index
        self.note_editor.setProperty("note_index", len(self.journal_data["notes"]) - 1)
        
        # Enable delete and save buttons
        self.delete_note_button.setEnabled(True)
        self.save_note_button.setEnabled(False)
    
    def _on_delete_note_clicked(self):
        """Handle delete note button click."""
        # Get the current note index
        note_index = self.note_editor.property("note_index")
        
        if note_index is not None and 0 <= note_index < len(self.journal_data["notes"]):
            # Remove from journal data
            self.journal_data["notes"].pop(note_index)
            
            # Update list
            self._update_notes_list()
            
            # Clear editor
            self.note_editor.clear()
            self.note_editor.setProperty("note_index", None)
            
            # Disable delete and save buttons
            self.delete_note_button.setEnabled(False)
            self.save_note_button.setEnabled(False)
            
            # Emit journal updated signal
            self._emit_journal_updated()
    
    def _on_save_note_clicked(self):
        """Handle save note button click."""
        # Get the current note index
        note_index = self.note_editor.property("note_index")
        
        if note_index is not None and 0 <= note_index < len(self.journal_data["notes"]):
            # Update note content
            self.journal_data["notes"][note_index]["content"] = self.note_editor.toPlainText()
            
            # Update the list item title (first line of content)
            content = self.note_editor.toPlainText()
            first_line = content.split("\n")[0][:30]
            if len(first_line) < len(content.split("\n")[0]):
                first_line += "..."
            
            self.journal_data["notes"][note_index]["title"] = first_line
            
            # Update list
            self._update_notes_list()
            
            # Reselect the note
            self.notes_list.setCurrentRow(note_index)
            
            # Emit journal updated signal
            self._emit_journal_updated()
    
    def _update_notes_list(self):
        """Update the notes list with current journal data."""
        # Save the currently selected row
        current_row = self.notes_list.currentRow()
        
        # Clear the list
        self.notes_list.clear()
        
        # Add notes to the list
        for i, note in enumerate(self.journal_data["notes"]):
            # Create list item
            item = QListWidgetItem(f"{note['title']} - {note['timestamp']}")
            item.setData(Qt.UserRole, i)
            
            # Add to list
            self.notes_list.addItem(item)
        
        # Restore selection if possible
        if current_row >= 0 and current_row < self.notes_list.count():
            self.notes_list.setCurrentRow(current_row)
    
    def _update_quests_lists(self):
        """Update the quest lists with current journal data."""
        # Save the currently selected items
        active_item = self.active_quests_list.currentItem()
        active_quest_id = active_item.data(Qt.UserRole) if active_item else None
        
        completed_item = self.completed_quests_list.currentItem()
        completed_quest_id = completed_item.data(Qt.UserRole) if completed_item else None
        
        failed_item = self.failed_quests_list.currentItem()
        failed_quest_id = failed_item.data(Qt.UserRole) if failed_item else None
        
        # Clear the lists
        self.active_quests_list.clear()
        self.completed_quests_list.clear()
        self.failed_quests_list.clear()
        
        # Add quests to the appropriate lists
        for quest_id, quest_data in self.journal_data["quests"].items():
            # Create list item
            item = QListWidgetItem(quest_data["title"])
            item.setData(Qt.UserRole, quest_id)
            
            # Add to the appropriate list based on status
            if quest_data["status"] == "active":
                self.active_quests_list.addItem(item)
            elif quest_data["status"] == "completed":
                self.completed_quests_list.addItem(item)
            elif quest_data["status"] == "failed":
                self.failed_quests_list.addItem(item)
        
        # Restore selections if possible
        if active_quest_id:
            for i in range(self.active_quests_list.count()):
                if self.active_quests_list.item(i).data(Qt.UserRole) == active_quest_id:
                    self.active_quests_list.setCurrentRow(i)
                    break
        
        if completed_quest_id:
            for i in range(self.completed_quests_list.count()):
                if self.completed_quests_list.item(i).data(Qt.UserRole) == completed_quest_id:
                    self.completed_quests_list.setCurrentRow(i)
                    break
        
        if failed_quest_id:
            for i in range(self.failed_quests_list.count()):
                if self.failed_quests_list.item(i).data(Qt.UserRole) == failed_quest_id:
                    self.failed_quests_list.setCurrentRow(i)
                    break
    
    def _emit_journal_updated(self):
        """Emit the journal updated signal."""
        self.journal_updated.emit(self.journal_data)
    
    def update_journal(self, journal_data: Dict[str, Any] = None):
        """
        Update the journal panel with journal data.
        
        Args:
            journal_data: The journal data to display.
        """
        # If no journal data is provided, use the current state
        if journal_data is None:
            if self.state_manager and self.state_manager.current_state:
                if hasattr(self.state_manager.current_state, "journal"):
                    journal_data = self.state_manager.current_state.journal
                else:
                    logging.warning("No journal data available to update journal panel")
                    return
            else:
                logging.warning("No state available to update journal panel")
                return
        
        # Update journal data
        self.journal_data = journal_data
        
        # Update character info
        if "character" in journal_data:
            self.character_info_editor.setPlainText(journal_data["character"])
        
        # Update quests lists
        if "quests" in journal_data:
            self._update_quests_lists()
        
        # Update notes list
        if "notes" in journal_data:
            self._update_notes_list()

```

### File: ..\gui\components\menu_panel.py

```python
#!/usr/bin/env python3
"""
Menu panel widget for the RPG game GUI.
This module provides a collapsible left menu panel.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QFrame, 
    QToolButton, QLabel, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QSize, QEasingCurve, Property
from PySide6.QtGui import QIcon, QPixmap

from gui.utils.resource_manager import get_resource_manager

class MenuPanelWidget(QFrame):
    """Collapsible left menu panel for the RPG game GUI."""
    
    # Signals for menu actions
    new_game_requested = Signal()
    save_game_requested = Signal()
    load_game_requested = Signal()
    settings_requested = Signal()
    llm_settings_requested = Signal()
    exit_requested = Signal()
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the menu panel widget."""
        super().__init__(parent)

        # Set the desired opacity (0 = fully transparent, 100 = fully opaque)
        menu_panel_opacity_percent = 50 # Example: 85% opaque (adjust as needed)

        # Convert percentage to alpha value (0.0 to 1.0)
        alpha_value = menu_panel_opacity_percent / 100.0

        # Define the base background color RGB values (from #333333)
        base_r, base_g, base_b = 51, 51, 51
        
        # Set frame properties using rgba for background
        self.setFrameShape(QFrame.StyledPanel)
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.setStyleSheet(f"""
            MenuPanelWidget {{
                /* Use rgba for background color with transparency */
                background-color: rgba({base_r}, {base_g}, {base_b}, {alpha_value}); 
                
                /* Keep other styles */
                border: 1px solid #555555; 
                border-radius: 5px;
            }}
            /* Ensure buttons inside the panel remain opaque (using their own styles) */
            /* No changes needed here as buttons have specific styles set later */
        """)
        

        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Create animation properties
        self._expanded = True
        self._animation = None
        self._expanded_width = 150  # Increase width from 100 to 120
        self._collapsed_width = 40  # Increase collapsed width from 30 to 40
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(5, 5, 10, 5)
        self.main_layout.setSpacing(10)
        
        # Create toggle button
        self.toggle_button = QToolButton()
        self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
        self.toggle_button.setIconSize(QSize(16, 16))
        self.toggle_button.setStyleSheet("""
            QToolButton {
                background-color: #444444;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QToolButton:hover {
                background-color: #555555;
            }
            QToolButton:pressed {
                background-color: #333333;
            }
        """)
        self.toggle_button.clicked.connect(self.toggle_expanded)
        
        # Create menu buttons
        self.new_game_button = self._create_menu_button("New Game", "new_game")
        self.new_game_button.clicked.connect(self.new_game_requested.emit)
        
        self.save_button = self._create_menu_button("Save", "save_game")
        self.save_button.clicked.connect(self.save_game_requested.emit)
        
        self.load_button = self._create_menu_button("Load", "load_game")
        self.load_button.clicked.connect(self.load_game_requested.emit)
        
        # Settings button
        self.settings_button = self._create_menu_button("Settings", "settings")
        self.settings_button.clicked.connect(self.settings_requested.emit)
        
        self.llm_settings_button = self._create_menu_button("LLM", "llm_settings")
        self.llm_settings_button.clicked.connect(self.llm_settings_requested.emit)
        
        self.exit_button = self._create_menu_button("Exit", "exit")
        self.exit_button.clicked.connect(self.exit_requested.emit)
        
        # Add buttons to layout
        self.main_layout.addWidget(self.toggle_button, 0, Qt.AlignRight)
        self.main_layout.addSpacing(50)
        self.main_layout.addWidget(self.new_game_button)
        self.main_layout.addWidget(self.save_button)
        self.main_layout.addWidget(self.load_button)
        self.main_layout.addWidget(self.settings_button)
        self.main_layout.addWidget(self.llm_settings_button)
        self.main_layout.addSpacing(100)
        self.main_layout.addWidget(self.exit_button)
        self.main_layout.addStretch(1)  
        
        # Set initial width
        self.setFixedWidth(self._expanded_width)
    
    def _create_menu_button(self, text: str, icon_name: str) -> QPushButton:
        """Create a styled menu button.
        
        Args:
            text: The button text
            icon_name: The icon name (without path or extension)
            
        Returns:
            The created button
        """
        button = QPushButton(text)
        button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        
        # Use generic button backgrounds instead of specific ones
        button.setStyleSheet("""
            QPushButton {
                background-image: url('images/gui/button_normal.png');
                background-position: center;
                background-repeat: no-repeat;
                background-color: transparent;

                color: #E0E0E0;
                border: none;
                padding: 8px;
                text-align: center;
                min-width: 100px;
                max-width: 110px;
                min-height: 35px;
                border-radius: 5px;
                margin-left: 5px;
                margin-right: 10px;
            }
            QPushButton:hover {
                background-image: url('images/gui/button_hover.png');
            }
            QPushButton:pressed {
                background-image: url('images/gui/button_pressed.png');
                color: #FF0000;
                font-weight: bold;
            }
        """)
        
        return button
    
    def toggle_expanded(self):
        """Toggle the expanded/collapsed state of the panel."""
        self.setExpanded(not self._expanded)
    
    def setExpanded(self, expanded: bool):
        """Set the expanded/collapsed state of the panel.
        
        Args:
            expanded: True to expand, False to collapse
        """
        if self._expanded == expanded:
            return
        
        # Update state
        self._expanded = expanded
        
        # Update toggle button icon
        if expanded:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
        else:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right"))
        
        # Hide/show buttons when collapsed/expanded
        for button in [
            self.new_game_button,
            self.save_button,
            self.load_button,
            self.settings_button,
            self.llm_settings_button,
            self.exit_button
        ]:
            # Store original text when collapsing
            if expanded:
                button.setText(button.property("original_text"))
                button.setVisible(True)
            else:
                if not button.property("original_text"):
                    button.setProperty("original_text", button.text())
                button.setText("")
                button.setVisible(False)
        
        # Only toggle button remains visible when collapsed
        if not expanded:
            self.toggle_button.setVisible(True)
        
        # Animate width change
        target_width = self._expanded_width if expanded else self._collapsed_width
        
        if self._animation:
            self._animation.stop()
        
        self._animation = QPropertyAnimation(self, b"minimumWidth")
        self._animation.setDuration(300)
        self._animation.setStartValue(self.width())
        self._animation.setEndValue(target_width)
        self._animation.setEasingCurve(QEasingCurve.InOutCubic)
        self._animation.start()
    
    def isExpanded(self) -> bool:
        """Get the expanded/collapsed state of the panel.
        
        Returns:
            True if expanded, False if collapsed
        """
        return self._expanded
    
    def sizeHint(self) -> QSize:
        """Get the recommended size for the widget.
        
        Returns:
            The recommended size
        """
        if self._expanded:
            return QSize(self._expanded_width, super().sizeHint().height())
        else:
            return QSize(self._collapsed_width, super().sizeHint().height())

```

### File: ..\gui\components\right_panel.py

```python
#!/usr/bin/env python3
"""
Right panel widget for the RPG game GUI.
This module provides a collapsible, tabbed right panel.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QTabWidget, QFrame, 
    QSplitter, QPushButton, QStackedWidget, QToolButton, QTabBar, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QSize, QEasingCurve, Property
from PySide6.QtGui import QIcon, QPixmap, QCursor

from gui.utils.resource_manager import get_resource_manager
from gui.components.character_sheet import CharacterSheetWidget
from gui.components.inventory_panel import InventoryPanelWidget
from gui.components.journal_panel import JournalPanelWidget

class CustomTabBar(QTabBar):
    """Custom tab bar that emits a signal when the selected tab is clicked again."""
    
    tab_clicked_twice = Signal(int)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._last_index = -1
    
    def mousePressEvent(self, event):
        """Handle mouse press events to detect double clicks on selected tabs."""
        index = self.tabAt(event.pos())
        
        if index != -1 and index == self.currentIndex():
            self.tab_clicked_twice.emit(index)
        
        # Let the normal event processing happen
        super().mousePressEvent(event)

class CollapsibleRightPanel(QFrame):
    """Collapsible, tabbed right panel for the RPG game GUI."""
    
    # Signals
    tab_changed = Signal(int)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the right panel widget."""
        super().__init__(parent)
        
        # Set the desired opacity (0 = fully transparent, 100 = fully opaque)
        right_panel_opacity_percent = 50
        
        # Convert percentage to alpha value (0.0 to 1.0)
        alpha_value = right_panel_opacity_percent / 100.0

        # Define the base background color RGB values (from #333333)
        base_r, base_g, base_b = 51, 51, 51
        
        # Set frame properties using rgba for background
        self.setFrameShape(QFrame.StyledPanel)
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.setStyleSheet(f"""
            CollapsibleRightPanel {{
                /* Use rgba for background color with transparency */
                background-color: rgba({base_r}, {base_g}, {base_b}, {alpha_value}); 
                
                /* Keep other styles */
                border: 1px solid #555555; 
                border-radius: 5px;
            }}
            /* Child widgets like QTabWidget will have their own styles set below */
        """)
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Create animation properties
        self._expanded = True
        self._animation = None
        self._expanded_width = 400
        self._collapsed_width = 30
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)
        
        # Create tab widget with custom tab bar
        self.tab_widget = QTabWidget()
        self.custom_tab_bar = CustomTabBar()
        self.tab_widget.setTabBar(self.custom_tab_bar)
        
        # Connect custom tab bar signal
        self.custom_tab_bar.tab_clicked_twice.connect(self.toggle_expanded)
        
        # Style the tab widget
        self.tab_widget.setStyleSheet("""
            QTabWidget,
            QTabWidget QWidget, /* Target widgets directly inside QTabWidget */
            QTabWidget QScrollArea,
            QTabWidget QScrollArea > QWidget > QFrame, /* Target frames within scroll areas */
            QTabWidget QScrollArea > QWidget { /* Target viewport widget */
                background-color: transparent; /* Make immediate children transparent */
                color: #E0E0E0;
                border: none;
            }
            QTabWidget::pane { /* The area behind the tabs' content */
                background-color: #2E2E2E; /* Opaque dark color - slightly different from panel bg */
                border: 1px solid #444444;
                border-top: none; /* Remove top border as it's covered by tabs */
                border-radius: 0px; /* Pane doesn't need radius if panel has it */
                padding: 5px; /* Add some padding for content */
                margin: 0px;
            }
            QTabBar::tab { /* Individual tabs */
                background-color: #444444; /* Opaque tab background */
                color: #BBBBBB;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                padding: 8px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected { /* Selected tab */
                background-color: #2E2E2E; /* Match the pane background */
                color: #E0E0E0;
                border-bottom: 1px solid #2E2E2E; /* Make it look connected */
            }
            QTabBar::tab:hover:!selected { /* Hovered non-selected tab */
                background-color: #505050;
            }
            /* Ensure specific content widgets (like CharacterSheetWidget) have transparent backgrounds */
            /* if you want the pane background (#2E2E2E) to show through */
            CharacterSheetWidget, InventoryPanelWidget, JournalPanelWidget {
                 background-color: transparent;
            }
        """)
        
        # Create tabs
        self.character_sheet = CharacterSheetWidget()
        self.inventory_panel = InventoryPanelWidget()
        self.journal_panel = JournalPanelWidget()
        
        # Add tabs
        self.tab_widget.addTab(self.character_sheet, "Character")
        self.tab_widget.addTab(self.inventory_panel, "Inventory")
        self.tab_widget.addTab(self.journal_panel, "Journal")
        
        # Create toggle button (only visible when collapsed)
        self.toggle_button = QToolButton()
        self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right"))
        self.toggle_button.setIconSize(QSize(16, 16))
        self.toggle_button.setStyleSheet("""
            QToolButton {
                background-color: #444444;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QToolButton:hover {
                background-color: #555555;
            }
            QToolButton:pressed {
                background-color: #333333;
            }
        """)
        self.toggle_button.clicked.connect(self.toggle_expanded)
        
        # Always show the toggle button
        self.toggle_button.setVisible(True)
        
        # Create stacked widget to switch between tab widget and collapsed view
        self.stacked_widget = QStackedWidget()
        self.stacked_widget.addWidget(self.tab_widget)  # Index 0: Expanded view with tabs
        
        # We don't use a separate collapsed view anymore
        # Instead, just modify the width of the panel while keeping tabs visible
        # This way, users can always see tab headers and expand the panel by clicking on them
        
        # Add toggle button directly to the main layout
        toggle_container = QWidget()
        toggle_layout = QVBoxLayout(toggle_container)
        toggle_layout.setContentsMargins(0, 5, 0, 0)
        toggle_layout.addWidget(self.toggle_button, 0, Qt.AlignRight)
        
        # Add toggle container to top of main layout
        self.main_layout.insertWidget(0, toggle_container)
        
        # Add stacked widget to main layout
        self.main_layout.addWidget(self.stacked_widget)
        
        # Set initial width
        self.setFixedWidth(self._expanded_width)
        
        # Connect tab changed signal
        self.tab_widget.currentChanged.connect(self._handle_tab_change)
    
    def _handle_tab_change(self, index):
        """Handle tab change event."""
        # Emit signal
        self.tab_changed.emit(index)
    
    def toggle_expanded(self, index=None):
        """Toggle the expanded/collapsed state of the panel."""
        self.setExpanded(not self._expanded)
    
    def setExpanded(self, expanded: bool):
        """Set the expanded/collapsed state of the panel.
        
        Args:
            expanded: True to expand, False to collapse
        """
        if self._expanded == expanded:
            return
        
        # Update state
        self._expanded = expanded
        
        # When collapsing, don't switch to the collapsed widget view
        # Instead, just resize the panel, keeping the tabs visible
        # This ensures users can still see and click on tabs
        
        # Animate width change
        target_width = self._expanded_width if expanded else self._collapsed_width
        
        if self._animation:
            self._animation.stop()
        
        self._animation = QPropertyAnimation(self, b"minimumWidth")
        self._animation.setDuration(300)
        self._animation.setStartValue(self.width())
        self._animation.setEndValue(target_width)
        self._animation.setEasingCurve(QEasingCurve.InOutCubic)
        self._animation.start()
    
    def isExpanded(self) -> bool:
        """Get the expanded/collapsed state of the panel.
        
        Returns:
            True if expanded, False if collapsed
        """
        return self._expanded
    
    def sizeHint(self) -> QSize:
        """Get the recommended size for the widget.
        
        Returns:
            The recommended size
        """
        if self._expanded:
            return QSize(self._expanded_width, super().sizeHint().height())
        else:
            return QSize(self._collapsed_width, super().sizeHint().height())
    
    def update_character(self, character=None):
        """Update the character sheet tab with character data."""
        # If character is provided directly, update with it
        if character:
            self.character_sheet.update_character(character)
            return
        
        # Otherwise get current character from game state
        from core.base.state import get_state_manager
        state_manager = get_state_manager()
        if state_manager and state_manager.current_state and state_manager.current_state.player:
            # First ensure stats manager is initialized
            if state_manager.stats_manager:
                # Trigger an update with current state's player
                self.character_sheet.update_character(state_manager.current_state.player)
    
    def update_inventory(self, inventory=None):
        """Update the inventory tab with inventory data."""
        self.inventory_panel.update_inventory(inventory)
    
    def update_journal(self, journal_data=None):
        """Update the journal tab with journal data."""
        self.journal_panel.update_journal(journal_data)

```

### File: ..\gui\components\skill_check_display.py

```python
#!/usr/bin/env python3
"""
Skill check display widget for the RPG game GUI.
This module provides a widget for displaying skill check results in a visual way.
"""

import logging
from typing import Optional, Dict, Any, List, Union
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, 
    QProgressBar, QGroupBox, QGraphicsOpacityEffect
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QTimer, QSize, Property
from PySide6.QtGui import QFont, QColor, QPainter, QPen, QBrush

from core.stats.skill_check import SkillCheckResult


class DiceWidget(QWidget):
    """Widget for displaying a dice roll result with animation."""
    
    def __init__(self, parent=None):
        """Initialize the dice widget."""
        super().__init__(parent)
        self.setMinimumSize(60, 60)
        self.setMaximumSize(60, 60)
        
        self._value = 1
        self._rolling = False
        self._roll_timer = QTimer(self)
        self._roll_timer.timeout.connect(self._update_rolling_value)
        
        # Set the background to be transparent
        self.setAttribute(Qt.WA_TranslucentBackground)
    
    def get_value(self) -> int:
        """Get the current dice value."""
        return self._value
    
    def set_value(self, value: int) -> None:
        """Set the dice value."""
        self._value = max(1, min(value, 20))  # Ensure value is between 1 and 20
        self.update()
    
    value = Property(int, get_value, set_value)
    
    def roll_animation(self, final_value: int, duration_ms: int = 1000) -> None:
        """
        Animate a dice roll to the final value.
        
        Args:
            final_value: The final dice value to show
            duration_ms: Duration of the animation in milliseconds
        """
        self._rolling = True
        self._final_value = max(1, min(final_value, 20))
        self._roll_timer.start(50)  # Update every 50ms
        
        # Set a timer to stop the rolling animation
        QTimer.singleShot(duration_ms, self._stop_rolling)
    
    def _update_rolling_value(self) -> None:
        """Update the dice value during rolling animation."""
        import random
        self.set_value(random.randint(1, 20))
    
    def _stop_rolling(self) -> None:
        """Stop the rolling animation and set the final value."""
        self._rolling = False
        self._roll_timer.stop()
        self.set_value(self._final_value)
    
    def paintEvent(self, event) -> None:
        """Paint the dice."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Define the dice colors based on the value
        if self._value == 20:
            # Critical success - gold
            bg_color = QColor(255, 215, 0)
            text_color = QColor(0, 0, 0)
        elif self._value == 1:
            # Critical failure - red
            bg_color = QColor(200, 0, 0)
            text_color = QColor(255, 255, 255)
        else:
            # Normal roll - white
            bg_color = QColor(240, 240, 240)
            text_color = QColor(0, 0, 0)
        
        # Draw the dice (d20 is icosahedron, but we'll draw a simplified pentagon)
        rect = self.rect().adjusted(2, 2, -2, -2)
        
        # Draw the background
        painter.setBrush(QBrush(bg_color))
        painter.setPen(QPen(QColor(20, 20, 20), 2))
        
        # Draw a circle as the dice
        painter.drawEllipse(rect)
        
        # Draw the value
        painter.setPen(QPen(text_color))
        font = QFont("Arial", 18, QFont.Bold)
        painter.setFont(font)
        painter.drawText(rect, Qt.AlignCenter, str(self._value))


class SkillCheckDisplay(QWidget):
    """Widget for displaying skill check results."""
    
    # Signal emitted when the display is finished
    display_finished = Signal()
    
    def __init__(self, parent=None):
        """Initialize the skill check display widget."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
        
        # Hide the widget by default
        self.setVisible(False)
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(5)
        
        # Create the title label
        self.title_label = QLabel("Skill Check")
        self.title_label.setStyleSheet("""
            font-size: 18px;
            font-weight: bold;
            color: #E0E0E0;
        """)
        self.title_label.setAlignment(Qt.AlignCenter)
        
        # Create the stat and difficulty display
        self.stat_layout = QHBoxLayout()
        
        self.stat_label = QLabel("Stat: STR")
        self.stat_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #BBBBBB;
        """)
        
        self.difficulty_label = QLabel("Difficulty: 15")
        self.difficulty_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #BBBBBB;
        """)
        
        self.stat_layout.addWidget(self.stat_label)
        self.stat_layout.addStretch(1)
        self.stat_layout.addWidget(self.difficulty_label)
        
        # Create the dice display
        self.dice_layout = QHBoxLayout()
        self.dice_layout.setAlignment(Qt.AlignCenter)
        
        self.dice_widget = DiceWidget()
        
        self.dice_layout.addWidget(self.dice_widget)
        
        # Create the result display
        self.result_layout = QHBoxLayout()
        
        self.mod_label = QLabel("Modifier: +0")
        self.mod_label.setStyleSheet("""
            font-size: 14px;
            color: #BBBBBB;
        """)
        
        self.total_label = QLabel("Total: 10")
        self.total_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #E0E0E0;
        """)
        
        self.success_label = QLabel("SUCCESS")
        self.success_label.setStyleSheet("""
            font-size: 16px;
            font-weight: bold;
            color: #66CC33;
        """)
        self.success_label.setAlignment(Qt.AlignCenter)
        
        self.result_layout.addWidget(self.mod_label)
        self.result_layout.addStretch(1)
        self.result_layout.addWidget(self.total_label)
        
        # Create the context display
        self.context_label = QLabel("Attempting to climb the steep cliff")
        self.context_label.setStyleSheet("""
            font-size: 14px;
            font-style: italic;
            color: #CCCCCC;
        """)
        self.context_label.setAlignment(Qt.AlignCenter)
        self.context_label.setWordWrap(True)
        
        # Add all elements to the main layout
        self.main_layout.addWidget(self.title_label)
        self.main_layout.addLayout(self.stat_layout)
        self.main_layout.addLayout(self.dice_layout)
        self.main_layout.addLayout(self.result_layout)
        self.main_layout.addWidget(self.success_label)
        self.main_layout.addWidget(self.context_label)
        
        # Set the widget styling
        self.setStyleSheet("""
            background-color: #333333;
            border: 2px solid #555555;
            border-radius: 8px;
        """)
        
        # Set a fixed size for the widget
        self.setFixedSize(300, 250)
    
    def show_check_result(self, result: SkillCheckResult, context: str = "", duration_ms: int = 3000) -> None:
        """
        Display a skill check result with animation.
        
        Args:
            result: The SkillCheckResult object containing the check details
            context: Optional context description for the check
            duration_ms: How long to display the result (in milliseconds)
        """
        # Update the labels with the check information
        self.title_label.setText(f"Skill Check: {result.stat_type}")
        self.stat_label.setText(f"Stat: {result.stat_type} ({int(result.stat_value)})")
        self.difficulty_label.setText(f"Difficulty: {result.difficulty}")
        self.mod_label.setText(f"Modifier: {'+' if result.modifier >= 0 else ''}{result.modifier}")
        self.total_label.setText(f"Total: {result.roll + result.modifier}")
        
        # Set success/failure display
        if result.success:
            if result.roll == 20:
                self.success_label.setText("CRITICAL SUCCESS!")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #FFD700;  /* Gold */
                """)
            else:
                self.success_label.setText("SUCCESS")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #66CC33;  /* Green */
                """)
        else:
            if result.roll == 1:
                self.success_label.setText("CRITICAL FAILURE!")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #CC3333;  /* Red */
                """)
            else:
                self.success_label.setText("FAILURE")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #CC3333;  /* Red */
                """)
        
        # Set the context text
        self.context_label.setText(context)
        
        # Make the widget visible
        self.setVisible(True)
        
        # Create fade-in animation
        self.fade_in_effect = QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.fade_in_effect)
        self.fade_in_effect.setOpacity(0)
        
        self.fade_in = QPropertyAnimation(self.fade_in_effect, b"opacity")
        self.fade_in.setDuration(300)
        self.fade_in.setStartValue(0)
        self.fade_in.setEndValue(1)
        self.fade_in.start()
        
        # Start the dice roll animation
        self.dice_widget.roll_animation(result.roll, 800)
        
        # Create a timer to hide the widget after duration_ms
        QTimer.singleShot(duration_ms, self._fade_out)
    
    def _fade_out(self) -> None:
        """Create and start a fade-out animation."""
        self.fade_out = QPropertyAnimation(self.fade_in_effect, b"opacity")
        self.fade_out.setDuration(500)
        self.fade_out.setStartValue(1)
        self.fade_out.setEndValue(0)
        self.fade_out.start()
        
        # Hide the widget after the animation finishes
        self.fade_out.finished.connect(self._hide_widget)
    
    def _hide_widget(self) -> None:
        """Hide the widget and emit the finished signal."""
        self.setVisible(False)
        self.display_finished.emit()


# For testing purposes
if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication
    from core.stats.stats_base import StatType
    
    # Create a test application
    app = QApplication(sys.argv)
    
    # Create a mock skill check result
    test_result = SkillCheckResult(
        stat_type=StatType.STRENGTH,
        stat_value=15,
        difficulty=12,
        roll=18,
        modifier=3,
        success=True,
        advantage=False,
        disadvantage=False
    )
    
    # Create and show the widget
    widget = SkillCheckDisplay()
    widget.show_check_result(test_result, "Attempting to lift the heavy boulder")
    widget.show()
    
    # Run the application
    sys.exit(app.exec())

```

### File: ..\gui\components\stat_allocation_widget.py

```python
#!/usr/bin/env python3
"""
Stat allocation widget for character creation and level-up.
"""

import os
import json
import logging
from typing import Dict, List, Optional, Any, Tuple, Callable

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QFrame, QGroupBox, QPushButton, QToolTip, QSizePolicy,
    QSpacerItem, QDialog, QFrame 
)
from PySide6.QtCore import Qt, Signal, Slot, QPoint, QSize, QEvent
from PySide6.QtGui import QFont, QColor, QPalette, QMouseEvent, QIcon, QPixmap, QCursor

from core.stats.stats_base import StatType
from core.stats.stat_allocation import StatPointAllocator
from core.stats.stats_manager import StatsManager
from core.stats.stat_modifier_info import StatModifierInfo
from core.utils.logging_config import get_logger, log_migration_fix

# Log the import fix
log_migration_fix(
    "gui.components.stat_allocation_widget", 
    "from core.utils.logging_config import get_logger, LogCategory\nlogger = get_logger(LogCategory.GUI)", 
    "from core.utils.logging_config import get_logger\nlogger = get_logger(\"GUI\")"
)

logger = get_logger("GUI")


class TooltipLabel(QLabel):
    """A custom label that shows a tooltip when hovered over."""
    
    def __init__(self, text="", tooltip="", parent=None):
        super().__init__(text, parent)
        self.tooltip_text = tooltip
        self.setMouseTracking(True)
    
    def enterEvent(self, event):
        """Show tooltip when mouse enters label area."""
        if self.tooltip_text:
            QToolTip.showText(QCursor.pos(), self.tooltip_text, self)
        super().enterEvent(event)
    
    def leaveEvent(self, event):
        """Hide tooltip when mouse leaves label area."""
        if self.tooltip_text:
            QToolTip.hideText()
        super().leaveEvent(event)
    
    def setTooltipText(self, text):
        """Set the tooltip text."""
        self.tooltip_text = text


class StatInfoDialog(QDialog):
    """Dialog for displaying detailed information about a stat."""
    
    def __init__(self, stat_name: str, stat_value: int, modifier_info: StatModifierInfo, parent=None):
        super().__init__(parent)

        # Configure dialog
        self.setWindowTitle(f"{stat_name} Stat Information")
        self.setFixedSize(400, 400)
        self.setModal(True)
        self.setStyleSheet("""
            QDialog {
                background-color: #333333;
                color: #E0E0E0;
            }
        """)

        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(10)

        # Stat title
        title_label = QLabel(f"<h2>{stat_name}</h2>")
        title_label.setStyleSheet("color: #E0E0E0;")
        layout.addWidget(title_label)

        # Stat description
        stat_descriptions = {
            "STR": "<b>Strength</b> represents physical power and affects melee damage, carrying capacity, and physical force.",
            "DEX": "<b>Dexterity</b> represents agility, reflexes, and balance. It affects initiative, ranged attacks, and ability to dodge.",
            "CON": "<b>Constitution</b> represents health, stamina, and vital force. It affects hit points, resistance to poison, and fatigue.",
            "INT": "<b>Intelligence</b> represents reasoning, memory, and learning ability. It affects spell power, knowledge skills, and ability to analyze.",
            "WIS": "<b>Wisdom</b> represents intuition, perception, and willpower. It affects magical resistance, perception checks, and survival skills.",
            "CHA": "<b>Charisma</b> represents force of personality, persuasiveness, and leadership. It affects social interactions, prices, and follower loyalty.",
            # --- MODIFICATION: Add descriptions for WIL and INS ---
            "WIL": "<b>Willpower</b> represents mental fortitude, focus, and resistance to stress or mental influence. It affects concentration, resisting fear, and pushing through mental challenges.",
            "INS": "<b>Insight</b> represents understanding, intuition, and awareness of subtle details in situations and people. It affects perception checks, reading motives, and making intuitive leaps."
            # --- END MODIFICATION ---
        }

        description = stat_descriptions.get(stat_name, "")
        desc_label = QLabel(description)
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("color: #E0E0E0; background-color: #2D2D2D; padding: 10px; border-radius: 5px;")
        layout.addWidget(desc_label)

        # Current values section
        values_group = QGroupBox("Current Values")
        values_group.setStyleSheet("""
            QGroupBox {
                background-color: #2D2D2D;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        values_layout = QVBoxLayout(values_group)

        # Base value
        base_value = stat_value
        race_mod = modifier_info.race_modifiers.get(stat_name, 0)
        class_mod = modifier_info.class_modifiers.get(stat_name, 0)
        total_value = base_value + race_mod + class_mod
        ability_mod = (total_value - 10) // 2
        min_req = modifier_info.minimum_requirements.get(stat_name, 0)

        values_text = f"""<p><b>Base Value:</b> {base_value}</p>
        <p><b>Race Modifier:</b> <span style='color: {'#4CAF50' if race_mod > 0 else ('#F44336' if race_mod < 0 else '#CCCCCC')}'>{'+'+ str(race_mod) if race_mod > 0 else race_mod if race_mod != 0 else '0'}</span> ({modifier_info.race_name})</p>
        <p><b>Class Modifier:</b> <span style='color: {'#2196F3' if class_mod > 0 else ('#F44336' if class_mod < 0 else '#CCCCCC')}'>{'+'+ str(class_mod) if class_mod > 0 else class_mod if class_mod != 0 else '0'}</span> ({modifier_info.class_name})</p>
        <p><b>Total Value:</b> {total_value}</p>
        <p><b>Ability Modifier:</b> <span style='color: {'#4CAF50' if ability_mod > 0 else ('#F44336' if ability_mod < 0 else '#CCCCCC')}'>{'+'+ str(ability_mod) if ability_mod > 0 else ability_mod if ability_mod != 0 else '0'}</span></p>"""

        # Add minimum requirement if it exists
        if min_req > 0:
            values_text += f"""<p><b>Minimum Requirement:</b> <span style='color: {'#4CAF50' if total_value >= min_req else '#F44336'}>{min_req}</span> ({modifier_info.class_name})</p>"""

        values_label = QLabel(values_text)
        values_label.setWordWrap(True)
        values_layout.addWidget(values_label)
        layout.addWidget(values_group)

        # Game effects section
        effects_group = QGroupBox("Game Effects")
        effects_group.setStyleSheet("""
            QGroupBox {
                background-color: #2D2D2D;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        effects_layout = QVBoxLayout(effects_group)

        # Effects based on the stat
        effects = {
            "STR": ["Melee attack damage", "Carrying capacity", "Breaking objects", "Grappling"],
            "DEX": ["Ranged attack accuracy", "Initiative in combat", "Dodge chance", "Stealth"],
            "CON": ["Hit points", "Resistance to poison", "Stamina and fatigue", "Survival in harsh conditions"],
            "INT": ["Spell power", "Knowledge and lore", "Language comprehension", "Puzzle solving"],
            "WIS": ["Magical resistance", "Perception", "Survival skills", "Willpower checks"],
            "CHA": ["NPC reactions", "Prices when buying/selling", "Leadership", "Persuasion attempts"],
            # --- MODIFICATION: Add effects for WIL and INS ---
            "WIL": ["Resisting mental attacks/control", "Maintaining concentration (spells)", "Enduring stress/fear", "Pushing through fatigue"],
            "INS": ["Detecting lies/motives", "Noticing hidden details", "Understanding complex situations", "Making intuitive connections"]
            # --- END MODIFICATION ---
        }

        effects_text = "<p>This stat affects:</p><ul>"
        for effect in effects.get(stat_name, []):
            modifier_text = "+" if ability_mod > 0 else "-" if ability_mod < 0 else "±"
            effects_text += f"<li>{effect} <span style='color: {'#4CAF50' if ability_mod > 0 else ('#F44336' if ability_mod < 0 else '#CCCCCC')}'>({modifier_text})</span></li>"
        effects_text += "</ul>"

        effects_label = QLabel(effects_text)
        effects_label.setWordWrap(True)
        effects_layout.addWidget(effects_label)
        layout.addWidget(effects_group)

        # Class importance
        importance = "Unknown"
        importance_color = "#CCCCCC"

        if stat_name in modifier_info.recommended_stats.get("primary", []):
            importance = "Primary"
            importance_color = "#4CAF50"  # Green
        elif stat_name in modifier_info.recommended_stats.get("secondary", []):
            importance = "Secondary"
            importance_color = "#FFC107"  # Amber
        elif stat_name in modifier_info.recommended_stats.get("tertiary", []):
            importance = "Tertiary"
            importance_color = "#F44336"  # Red

        importance_text = f"<p><b>Importance for {modifier_info.class_name}:</b> <span style='color: {importance_color}'>{importance}</span></p>"
        importance_label = QLabel(importance_text)
        importance_label.setWordWrap(True)
        layout.addWidget(importance_label)

        # Close button
        close_button = QPushButton("Close")
        close_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #0b7dda;
            }
            QPushButton:pressed {
                background-color: #0a5999;
            }
        """)
        close_button.clicked.connect(self.accept)
        layout.addWidget(close_button, 0, Qt.AlignCenter)


class StatRow:
    """A class to hold UI elements for a stat row."""
    
    def __init__(self):
        self.name_label = None
        self.info_button = None
        self.base_label = None
        self.increase_button = None
        self.decrease_button = None
        self.race_mod_label = None
        self.class_mod_label = None
        self.total_label = None
        self.mod_label = None


class StatAllocationWidget(QWidget):
    """Widget for allocating stat points during character creation or level-up."""
    
    # Signal emitted when stats change
    stats_changed = Signal(dict)
    allocation_complete = Signal()
    
    def __init__(
        self, 
        stats_manager: StatsManager,
        race_name: str = "Human",
        class_name: str = "Warrior",
        total_points: int = 27,
        min_value: int = 8,
        max_value: int = 15,
        parent: Optional[QWidget] = None
    ):
        """
        Initialize the stat allocation widget.
        
        Args:
            stats_manager: The stats manager to modify
            race_name: The character's race
            class_name: The character's class
            total_points: Total points available for allocation
            min_value: Minimum stat value
            max_value: Maximum stat value
            parent: The parent widget
        """
        super().__init__(parent)
        
        # Set up the stat allocator
        self.stats_manager = stats_manager
        self.allocator = StatPointAllocator(stats_manager, total_points, min_value, max_value)
        
        # Load race and class modifiers
        self.modifier_info = StatModifierInfo()
        self.modifier_info.load_modifiers(race_name, class_name)
        
        # Create UI elements dictionary
        self.stat_rows = {}
        
        # Create the UI elements
        self._setup_ui()
        
        # Update the display
        self._update_all_stat_displays()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # Create the stats info header
        header_layout = QHBoxLayout()

        # Points remaining label
        self.points_label = QLabel(f"Points Remaining: {self.allocator.get_remaining_points()}")
        self.points_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: #E0E0E0;
            }
        """)
        header_layout.addWidget(self.points_label)

        # Add spacer
        header_layout.addStretch()

        # Add reset button
        self.reset_button = QPushButton("Reset")
        self.reset_button.setToolTip("Reset all stats to minimum values")
        self.reset_button.setFixedWidth(80)
        self.reset_button.clicked.connect(self._reset_stats)
        header_layout.addWidget(self.reset_button)

        # Add header to main layout
        main_layout.addLayout(header_layout)

        # Create the stat grid
        stats_group = QGroupBox("Character Stats")
        stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)

        stats_layout = QGridLayout(stats_group)
        stats_layout.setContentsMargins(15, 20, 15, 15)
        stats_layout.setHorizontalSpacing(5) # Reduced horizontal spacing
        stats_layout.setVerticalSpacing(10) # Keep vertical spacing reasonable

        col1_start = 0
        col2_start = 8
        separator_col = 7
        num_cols_per_stat = 7
        num_stats_per_col = 4 

        headers = ["Stat", "Base", "Adjust", "Race", "Class", "Total", "Mod"]
        mod_tooltip = (
            "<b>Ability Score Modifier</b><br>"
            "This is calculated as: (Total Stat Value - 10) ÷ 2, rounded down.<br><br>"
            "It represents the bonus or penalty applied to actions using this stat.<br>"
            "For example, a Strength of 14 gives a +2 modifier to melee attacks.<br><br>"
            "<i>Note: This is not the same as Race/Class modifiers, which directly modify the stat value.</i>"
        )

        for col_offset in [col1_start, col2_start]:
            for i, header_text in enumerate(headers):
                if header_text == "Mod":
                    header_widget = TooltipLabel(header_text, mod_tooltip)
                    header_widget.setStyleSheet("font-weight: bold; color: #CCCCCC; text-decoration: underline dotted;")
                    header_widget.setCursor(Qt.WhatsThisCursor)
                else:
                    header_widget = QLabel(header_text)
                    header_widget.setStyleSheet("font-weight: bold; color: #CCCCCC;")
                stats_layout.addWidget(header_widget, 0, col_offset + i, alignment=Qt.AlignCenter)

        all_stat_types = list(StatType) # Get all stat types
        for index, stat_type in enumerate(all_stat_types):
            stat_name = str(stat_type)

            # Determine row and column offset
            row = (index % num_stats_per_col) + 1 # Row index (1-based)
            col_offset = col1_start if index < num_stats_per_col else col2_start

            # Create row object to hold UI elements
            stat_row = StatRow()

            # Create stat name layout with info icon and impact indicators
            stat_name_layout = QHBoxLayout()
            stat_name_layout.setSpacing(2)
            stat_name_layout.setContentsMargins(0, 0, 0, 0)

            # Create stat name label with importance coloring
            stat_row.name_label = QLabel(stat_name)
            name_color = "#E0E0E0"
            if stat_name in self.modifier_info.recommended_stats.get("primary", []): name_color = "#4CAF50"
            elif stat_name in self.modifier_info.recommended_stats.get("secondary", []): name_color = "#FFD700"
            elif stat_name in self.modifier_info.recommended_stats.get("tertiary", []): name_color = "#E65100"
            stat_row.name_label.setStyleSheet(f"color: {name_color}; font-weight: bold;")
            stat_row.name_label.setCursor(Qt.PointingHandCursor)
            stat_row.name_label.mousePressEvent = lambda event, s=stat_type: self._show_stat_info(s)

            # Define icons and their individual tooltips
            impact_icons = {
                "STR": [("⚔️", "Melee Combat Damage"), ("🏋️", "Carrying Capacity")],
                "DEX": [("🏹", "Ranged Attack Accuracy"), ("👟", "Initiative/Dodge")], 
                "CON": [("❤️", "Health Points"), ("🛡️", "Damage Resistance")],
                "INT": [("📚", "Knowledge & Learning"), ("✨", "Spell Power")],
                "WIS": [("👁️", "Perception"), ("🙏", "Magical Resistance")], 
                "CHA": [("💬", "Persuasion"), ("👑", "Leadership/Prices")],
                "WIL": [("🧠", "Mental Fortitude"), ("🛡️", "Resist Influence")],
                "INS": [("💡", "Intuition/Problem Solving"), ("🧐", "Reading People/Situations")] 

            }

            stat_icons = impact_icons.get(stat_name, [])
            icons_layout = QHBoxLayout()
            icons_layout.setSpacing(1)
            icons_layout.setContentsMargins(0, 0, 0, 0)
            for icon, tooltip in stat_icons:
                icon_label = TooltipLabel(icon, tooltip)
                icon_label.setStyleSheet("font-size: 12px;")
                icon_label.setFixedWidth(20)
                icon_label.setAlignment(Qt.AlignCenter)
                icons_layout.addWidget(icon_label)
            icons_widget = QWidget()
            icons_widget.setLayout(icons_layout)
            icons_widget.setFixedWidth(45)
            icons_widget.setMouseTracking(True)

            # Create info icon button
            stat_row.info_button = QPushButton()
            stat_row.info_button.setIcon(self._create_info_icon())
            stat_row.info_button.setIconSize(QSize(16, 16))
            stat_row.info_button.setFixedSize(20, 20)
            stat_row.info_button.setStyleSheet("""
                QPushButton { background-color: transparent; border: none; }
                QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); border-radius: 10px; }
            """)
            stat_row.info_button.setCursor(Qt.PointingHandCursor)
            stat_row.info_button.setToolTip("Click for detailed information")
            stat_row.info_button.clicked.connect(lambda checked=False, s=stat_type: self._show_stat_info(s))

            # Add to name layout
            stat_name_layout.addWidget(stat_row.name_label)
            stat_name_layout.addWidget(icons_widget)
            stat_name_layout.addWidget(stat_row.info_button)

            # Create base value label
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            stat_row.base_label = QLabel(str(base_value))
            stat_row.base_label.setStyleSheet("color: #E0E0E0;")
            stat_row.base_label.setAlignment(Qt.AlignCenter)

            # Create adjustment buttons layout
            adjust_layout = QHBoxLayout()
            adjust_layout.setSpacing(2)
            project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', '..'))
            left_arrow_path = os.path.join(project_root, "images", "icons", "left_arrow.svg")
            right_arrow_path = os.path.join(project_root, "images", "icons", "right_arrow.svg")
            stat_row.decrease_button = QPushButton()
            stat_row.decrease_button.setIcon(QIcon(left_arrow_path))
            stat_row.decrease_button.setIconSize(QSize(16, 16)); stat_row.decrease_button.setFixedSize(24, 24)
            stat_row.decrease_button.setStyleSheet("QPushButton { background-color: #AA4444; color: white; font-weight: bold; border-radius: 4px; border: none; } QPushButton:hover { background-color: #CC5555; } QPushButton:pressed { background-color: #993333; } QPushButton:disabled { background-color: #555555; color: #888888; }")
            stat_row.decrease_button.clicked.connect(lambda checked=False, s=stat_type: self._decrease_stat(s))
            stat_row.increase_button = QPushButton()
            stat_row.increase_button.setIcon(QIcon(right_arrow_path))
            stat_row.increase_button.setIconSize(QSize(16, 16)); stat_row.increase_button.setFixedSize(24, 24)
            stat_row.increase_button.setStyleSheet("QPushButton { background-color: #4CAF50; color: white; font-weight: bold; border-radius: 4px; border: none; } QPushButton:hover { background-color: #66BB69; } QPushButton:pressed { background-color: #3B8C3E; } QPushButton:disabled { background-color: #555555; color: #888888; }")
            stat_row.increase_button.clicked.connect(lambda checked=False, s=stat_type: self._increase_stat(s))
            adjust_layout.addWidget(stat_row.decrease_button)
            adjust_layout.addWidget(stat_row.increase_button)

            # Create race modifier label
            race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
            mod_text = f"{race_mod:+d}" if race_mod != 0 else "0"
            stat_row.race_mod_label = QLabel(mod_text)
            stat_row.race_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'race')};")
            stat_row.race_mod_label.setAlignment(Qt.AlignCenter)

            # Create class modifier label
            class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
            mod_text = f"{class_mod:+d}" if class_mod != 0 else "0"
            stat_row.class_mod_label = QLabel(mod_text)
            stat_row.class_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'class')};")
            stat_row.class_mod_label.setAlignment(Qt.AlignCenter)

            # Create total value label
            total_value = base_value + race_mod + class_mod
            stat_row.total_label = QLabel(str(total_value))
            stat_row.total_label.setStyleSheet("color: #E0E0E0; font-weight: bold;")
            stat_row.total_label.setAlignment(Qt.AlignCenter)

            # Create modifier label
            modifier = (total_value - 10) // 2
            mod_text = f"{modifier:+d}" if modifier != 0 else "0"
            stat_row.mod_label = QLabel(mod_text)
            stat_row.mod_label.setStyleSheet(f"color: {'#4CAF50' if modifier > 0 else ('#F44336' if modifier < 0 else '#CCCCCC')};")
            stat_row.mod_label.setAlignment(Qt.AlignCenter)

            # Add mouseover tooltip to the entire row
            tooltip_text = self.modifier_info.get_tooltip_text(stat_name, base_value)
            for widget in [stat_row.name_label, stat_row.base_label, stat_row.race_mod_label,
                          stat_row.class_mod_label, stat_row.total_label, stat_row.mod_label]:
                if widget: widget.setToolTip(tooltip_text)

            # Add widgets to the grid using the calculated row and column offset
            stats_layout.addLayout(stat_name_layout, row, col_offset + 0)
            stats_layout.addWidget(stat_row.base_label, row, col_offset + 1, alignment=Qt.AlignCenter)
            stats_layout.addLayout(adjust_layout, row, col_offset + 2)
            stats_layout.addWidget(stat_row.race_mod_label, row, col_offset + 3, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.class_mod_label, row, col_offset + 4, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.total_label, row, col_offset + 5, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.mod_label, row, col_offset + 6, alignment=Qt.AlignCenter)

            # Store the row for later reference
            self.stat_rows[stat_type] = stat_row

        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        separator.setStyleSheet("color: #555555;") # Make it visible
        stats_layout.addWidget(separator, 1, separator_col, num_stats_per_col, 1) # Span rows

        # Give more space to name columns, less to modifiers/buttons
        for col_offset in [col1_start, col2_start]:
            stats_layout.setColumnStretch(col_offset + 0, 3) # Name
            stats_layout.setColumnStretch(col_offset + 1, 1) # Base
            stats_layout.setColumnStretch(col_offset + 2, 2) # Adjust
            stats_layout.setColumnStretch(col_offset + 3, 1) # Race
            stats_layout.setColumnStretch(col_offset + 4, 1) # Class
            stats_layout.setColumnStretch(col_offset + 5, 1) # Total
            stats_layout.setColumnStretch(col_offset + 6, 1) # Mod
        stats_layout.setColumnStretch(separator_col, 0) # No stretch for separator
        # --- END MODIFICATION ---

        # Add stat color explanation (adjust row index)
        stat_colors_explanation = QLabel("* Stat colors: Green = Primary, Gold = Secondary, Dark Orange = Tertiary for your class")
        stat_colors_explanation.setStyleSheet("color: #AAAAAA; font-size: 10px; font-style: italic;")
        # Place below the grid, spanning all columns used
        stats_layout.addWidget(stat_colors_explanation, num_stats_per_col + 1, 0, 1, col2_start + num_cols_per_stat, Qt.AlignLeft)

        # Add the stats group to the main layout
        main_layout.addWidget(stats_group)

        # Create preset buttons (remains the same)
        presets_group = QGroupBox("Quick Presets")
        presets_group.setStyleSheet("""
            QGroupBox { background-color: #333333; border: 1px solid #555555; border-radius: 5px; margin-top: 15px; font-weight: bold; color: #E0E0E0; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top center; padding-left: 10px; padding-right: 10px; }
        """)
        presets_layout = QHBoxLayout(presets_group)
        presets_layout.setContentsMargins(15, 20, 15, 15); presets_layout.setSpacing(10)
        self.preset_buttons = {}
        for preset_name in self.modifier_info.archetype_presets:
            preset_button = QPushButton(preset_name)
            preset_button.setToolTip(self.modifier_info.archetype_presets[preset_name].get("description", ""))
            preset_button.clicked.connect(lambda checked=False, p=preset_name: self._apply_preset(p))
            presets_layout.addWidget(preset_button)
            self.preset_buttons[preset_name] = preset_button
        if not self.preset_buttons:
            balanced_button = QPushButton("Balanced"); balanced_button.setToolTip("Apply a balanced distribution of stats")
            balanced_button.clicked.connect(lambda: self._auto_allocate(balanced=True)); presets_layout.addWidget(balanced_button)
            focused_button = QPushButton("Focused"); focused_button.setToolTip("Focus on primary stats for your class")
            focused_button.clicked.connect(lambda: self._auto_allocate(balanced=False)); presets_layout.addWidget(focused_button)
        main_layout.addWidget(presets_group)

        # Add information about race/class effects (remains the same)
        info_text = f"""
        <p><b>{self.modifier_info.race_name}:</b> {self.modifier_info.race_description}</p>
        <p><b>{self.modifier_info.class_name}:</b> {self.modifier_info.class_description}</p>
        """
        info_label = QLabel(info_text); info_label.setWordWrap(True)
        info_label.setStyleSheet("QLabel { color: #CCCCCC; background-color: #2D2D2D; padding: 10px; border-radius: 5px; }")
        main_layout.addWidget(info_label)

        # Add stretcher to push everything up
        main_layout.addStretch(1)
    
    def _increase_stat(self, stat_type: StatType) -> None:
        """
        Increase a stat by one point.

        Args:
            stat_type: The stat to increase
        """
        if self.allocator.increase_stat(stat_type):
            # Update stat display
            self._update_stat_display(stat_type)

            # Update points remaining label
            remaining_points = self.allocator.get_remaining_points() # Get remaining points
            self.points_label.setText(f"Points Remaining: {remaining_points}")

            # Emit signal with current stats
            self._emit_stats_changed()

            # --- EMIT COMPLETION SIGNAL ---
            if remaining_points == 0:
                self.allocation_complete.emit()
    
    def _decrease_stat(self, stat_type: StatType) -> None:
        """
        Decrease a stat by one point.

        Args:
            stat_type: The stat to decrease
        """
        # --- GET PREVIOUS REMAINING ---
        prev_remaining_points = self.allocator.get_remaining_points()
        # --- END GET PREVIOUS REMAINING ---

        if self.allocator.decrease_stat(stat_type):
            # Update stat display
            self._update_stat_display(stat_type)

            # Update points remaining
            remaining_points = self.allocator.get_remaining_points() # Get remaining points
            self.points_label.setText(f"Points Remaining: {remaining_points}")

            # Emit signal with current stats
            self._emit_stats_changed()

            # --- EMIT COMPLETION SIGNAL (Check if went FROM 0) ---

            if remaining_points == 0 and prev_remaining_points != 0:
                 self.allocation_complete.emit()
            elif remaining_points != 0 and prev_remaining_points == 0:

                 pass 
            # --- END EMIT COMPLETION SIGNAL ---

    def are_points_fully_allocated(self) -> bool:
        """Checks if all available points have been allocated."""
        # Ensure allocator exists before calling its method
        return hasattr(self, 'allocator') and self.allocator.get_remaining_points() == 0

    def get_remaining_points(self) -> int:
        """Returns the number of points remaining to be allocated."""
         # Ensure allocator exists before calling its method
        return self.allocator.get_remaining_points() if hasattr(self, 'allocator') else 0
    
    def _update_stat_display(self, stat_type: StatType) -> None:
        """
        Update the display for a specific stat.
        
        Args:
            stat_type: The stat to update
        """
        if stat_type not in self.stat_rows:
            return
        
        stat_row = self.stat_rows[stat_type]
        stat_name = str(stat_type)
        
        # Get current values
        base_value = int(self.stats_manager.get_stat_value(stat_type))
        race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
        class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
        total_value = base_value + race_mod + class_mod
        modifier = (total_value - 10) // 2
        
        # Update labels
        stat_row.base_label.setText(str(base_value))
        stat_row.total_label.setText(str(total_value))
        
        mod_text = f"{modifier:+d}" if modifier != 0 else "0"
        stat_row.mod_label.setText(mod_text)
        stat_row.mod_label.setStyleSheet(f"color: {'#4CAF50' if modifier > 0 else ('#F44336' if modifier < 0 else '#CCCCCC')};")
        
        # Update tooltips with new values
        tooltip_text = self.modifier_info.get_tooltip_text(stat_name, base_value)
        for widget in [stat_row.name_label, stat_row.base_label, stat_row.race_mod_label, 
                      stat_row.class_mod_label, stat_row.total_label, stat_row.mod_label]:
            widget.setToolTip(tooltip_text)
        
        # Update button states
        stat_row.increase_button.setEnabled(self.allocator.can_increase_stat(stat_type))
        stat_row.decrease_button.setEnabled(self.allocator.can_decrease_stat(stat_type))
        
        # Check if total meets minimum requirement
        min_req = self.modifier_info.minimum_requirements.get(stat_name, 0)
        if min_req > 0 and total_value < min_req:
            stat_row.total_label.setStyleSheet(f"color: {self.modifier_info.below_minimum_color}; font-weight: bold;")
        else:
            stat_row.total_label.setStyleSheet("color: #E0E0E0; font-weight: bold;")
    
    def _update_all_stat_displays(self) -> None:
        """Update all stat displays."""
        for stat_type in StatType:
            self._update_stat_display(stat_type)
        
        # Update points remaining
        self.points_label.setText(f"Points Remaining: {self.allocator.get_remaining_points()}")
    
    def _reset_stats(self) -> None:
        """Reset all stats to minimum values."""
        self.allocator.reset_to_minimum()
        self._update_all_stat_displays()
        self._emit_stats_changed()
    
    def _apply_preset(self, preset_name: str) -> None:
        """
        Apply a preset stat distribution.
        
        Args:
            preset_name: The name of the preset to apply
        """
        preset_stats = self.modifier_info.apply_preset(preset_name)
        if not preset_stats:
            return
        
        # Reset stats first
        self.allocator.reset_to_minimum()
        
        # Apply preset values
        for stat_name, value in preset_stats.items():
            try:
                stat_type = StatType.from_string(stat_name)
                current_value = int(self.stats_manager.get_stat_value(stat_type))
                
                # Increase the stat until it reaches the preset value or we can't increase anymore
                while current_value < value and self.allocator.can_increase_stat(stat_type):
                    self.allocator.increase_stat(stat_type)
                    current_value = int(self.stats_manager.get_stat_value(stat_type))
            except ValueError:
                logger.warning(f"Unknown stat in preset: {stat_name}")
        
        # Update all displays
        self._update_all_stat_displays()
        self._emit_stats_changed()
    
    def _auto_allocate(self, balanced: bool = True) -> None:
        """
        Automatically allocate points.
        
        Args:
            balanced: If True, use balanced distribution; otherwise prioritize primary stats
        """
        # Get the recommended stats order
        priority_stats = []
        
        if self.modifier_info.recommended_stats:
            # Add primary stats first
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("primary", [])])
            
            # Then secondary stats
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("secondary", [])])
            
            # Then tertiary stats
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("tertiary", [])])
            
        # If no priorities defined, use a standard order
        if not priority_stats:
            priority_stats = list(StatType)
        
        # Reset to minimum first
        self.allocator.reset_to_minimum()
        
        # Apply automatic allocation
        self.allocator.allocate_points_automatically(priority_stats, balanced)
        
        # Update displays
        self._update_all_stat_displays()
        
        # Emit signal with current stats
        self._emit_stats_changed()
    
    def _emit_stats_changed(self) -> None:
        """Emit the stats_changed signal with current stats."""
        # Get current stats with modifiers applied
        stats = {}
        for stat_type in StatType:
            stat_name = str(stat_type)
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
            stats[stat_name] = {
                "base": base_value,
                "total": total_value,
                "modifier": (total_value - 10) // 2
            }
        
        # Emit the signal
        self.stats_changed.emit(stats)
    
    def update_race_class(self, race_name: str, class_name: str) -> None:
        """
        Update the race and class modifiers.
        
        Args:
            race_name: The new race name
            class_name: The new class name
        """
        logger.info(f"Updating race to {race_name} and class to {class_name}")
        
        # Check if we're already using this race/class combination
        if race_name == self.modifier_info.race_name and class_name == self.modifier_info.class_name:
            logger.debug(f"Race and class already set to {race_name} and {class_name}, skipping update")
            return
        
        # Re-create the modifier info with new race/class to ensure fresh loading
        self.modifier_info = StatModifierInfo()
        self.modifier_info.load_modifiers(race_name, class_name)
        
        # Update UI for each stat
        for stat_type in StatType:
            if stat_type in self.stat_rows:
                stat_name = str(stat_type)
                stat_row = self.stat_rows[stat_type]
                
                # Update race modifier label
                race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
                mod_text = f"{race_mod:+d}" if race_mod != 0 else "0"
                stat_row.race_mod_label.setText(mod_text)
                stat_row.race_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'race')}; text-align: center;")
                
                # Update class modifier label
                class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
                mod_text = f"{class_mod:+d}" if class_mod != 0 else "0"
                stat_row.class_mod_label.setText(mod_text)
                stat_row.class_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'class')}; text-align: center;")
                
                # Update stat name color based on importance for current class
                name_color = "#E0E0E0"  # Default color
                if stat_name in self.modifier_info.recommended_stats.get("primary", []):
                    name_color = "#4CAF50"  # Green for primary stats
                elif stat_name in self.modifier_info.recommended_stats.get("secondary", []):
                    name_color = "#FFD700"  # Brighter yellow for secondary stats
                elif stat_name in self.modifier_info.recommended_stats.get("tertiary", []):
                    name_color = "#E65100"  # Darker orange for tertiary stats
                
                # Properly update style
                stat_row.name_label.setStyleSheet(f"color: {name_color}; font-weight: bold;")
                # Make sure cursor is maintained
                stat_row.name_label.setCursor(Qt.PointingHandCursor)
        
        # Update all displays to reflect changes
        self._update_all_stat_displays()
        
        # Update preset buttons
        self._update_preset_buttons()
        
        # Update race/class info
        self._update_race_class_info()
    
    def _update_preset_buttons(self) -> None:
        """Update the preset buttons based on current class."""
        # Clear existing buttons
        for button in self.preset_buttons.values():
            button.setParent(None)
            button.deleteLater()
        
        # Reset buttons dictionary
        self.preset_buttons = {}
        
        # Get the presets group
        presets_group = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item.widget() and isinstance(item.widget(), QGroupBox) and item.widget().title() == "Quick Presets":
                presets_group = item.widget()
                break
        
        if not presets_group:
            return
        
        # Get the layout
        presets_layout = presets_group.layout()
        if not presets_layout:
            return
        
        # Clear the layout
        while presets_layout.count():
            item = presets_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Add new preset buttons
        for preset_name in self.modifier_info.archetype_presets:
            preset_button = QPushButton(preset_name)
            preset_button.setToolTip(self.modifier_info.archetype_presets[preset_name].get("description", ""))
            preset_button.clicked.connect(lambda checked=False, p=preset_name: self._apply_preset(p))
            presets_layout.addWidget(preset_button)
            self.preset_buttons[preset_name] = preset_button
        
        # Add balanced preset if no archetypes found
        if not self.preset_buttons:
            balanced_button = QPushButton("Balanced")
            balanced_button.setToolTip("Apply a balanced distribution of stats")
            balanced_button.clicked.connect(lambda: self._auto_allocate(balanced=True))
            presets_layout.addWidget(balanced_button)
            
            focused_button = QPushButton("Focused")
            focused_button.setToolTip("Focus on primary stats for your class")
            focused_button.clicked.connect(lambda: self._auto_allocate(balanced=False))
            presets_layout.addWidget(focused_button)
    
    def _update_race_class_info(self) -> None:
        """Update the race/class information label."""
        info_text = f"""
        <p><b>{self.modifier_info.race_name}:</b> {self.modifier_info.race_description}</p>
        <p><b>{self.modifier_info.class_name}:</b> {self.modifier_info.class_description}</p>
        """
        
        # Find the info label
        info_label = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item.widget() and isinstance(item.widget(), QLabel) and "background-color: #2D2D2D" in item.widget().styleSheet():
                info_label = item.widget()
                break
        
        if info_label:
            info_label.setText(info_text)
    
    def get_current_stats(self) -> Dict[str, Dict[str, int]]:
        """
        Get the current stat values.
        
        Returns:
            Dictionary of stat names and their values
        """
        stats = {}
        for stat_type in StatType:
            stat_name = str(stat_type)
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
            stats[stat_name] = {
                "base": base_value,
                "total": total_value,
                "modifier": (total_value - 10) // 2
            }
        return stats
    
    def meets_requirements(self) -> bool:
        """
        Check if the current stats meet all class minimum requirements.
        
        Returns:
            True if all requirements are met, False otherwise
        """
        for stat_type in StatType:
            stat_name = str(stat_type)
            min_req = self.modifier_info.minimum_requirements.get(stat_name, 0)
            if min_req > 0:
                base_value = int(self.stats_manager.get_stat_value(stat_type))
                total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
                if total_value < min_req:
                    return False
        return True
        
    def _create_info_icon(self) -> QIcon:
        """
        Create an information icon.

        Returns:
            QIcon: The information icon
        """
        # Create a pixmap
        pixmap = QPixmap(24, 24)
        pixmap.fill(Qt.transparent)

        # Draw an info icon using code
        import math
        from PySide6.QtGui import QPainter, QPen, QBrush
        from PySide6.QtCore import QRect

        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)

        # Draw circle
        pen = QPen(QColor("#2196F3"))
        pen.setWidth(2)
        painter.setPen(pen)
        painter.setBrush(QBrush(QColor("#2196F3").darker(150)))
        painter.drawEllipse(2, 2, 20, 20)

        # Draw "i" character
        pen = QPen(QColor("white"))
        painter.setPen(pen)
        painter.setFont(QFont("Arial", 14, QFont.Bold))
        painter.drawText(QRect(0, 0, 24, 24), Qt.AlignCenter, "i")

        painter.end()

        return QIcon(pixmap)
    
    def _show_stat_info(self, stat_type: StatType) -> None:
        """
        Show detailed information about a stat.

        Args:
            stat_type: The stat to show information for
        """
        stat_name = str(stat_type)
        base_value = int(self.stats_manager.get_stat_value(stat_type))

        # Create and show the dialog
        dialog = StatInfoDialog(stat_name, base_value, self.modifier_info, self)
        dialog.exec_()

    def get_allocated_stats(self) -> Dict[str, int]:
        """
        Retrieves the current base stat values as allocated by the user.

        Returns:
            A dictionary mapping stat names (e.g., "STR") to their current base integer values.
        """
        allocated_stats = {}
        for stat_type in StatType:
            # Get the current BASE value directly from the stats manager
            # as the allocator modifies the manager's state
            base_value = self.stats_manager.get_stat(stat_type).base_value
            allocated_stats[str(stat_type)] = int(base_value) # Ensure it's an integer
        return allocated_stats
```

### File: ..\gui\components\status_bar.py

```python
#!/usr/bin/env python3
"""
Status bar for the RPG game GUI.
This module provides a status bar widget for displaying game status information.
"""

import logging
from typing import Optional
from enum import Enum

from PySide6.QtWidgets import QStatusBar, QLabel, QWidget, QHBoxLayout, QFrame
from PySide6.QtCore import Qt
from PySide6.QtGui import QPixmap

from gui.utils.resource_manager import get_resource_manager

class GameMode(Enum):
    """Different game modes that affect time progression."""
    NORMAL = "Normal"
    COMBAT = "Combat"
    BARTER = "Barter"

class GameStatusBar(QStatusBar):
    """Status bar for displaying game status information."""
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the status bar."""
        super().__init__(parent)
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Apply styling
        self.setStyleSheet("""
            QStatusBar {
                background-color: #333333;
                color: #E0E0E0;
                border-top: 1px solid #555555;
            }
            QStatusBar::item {
                border: none;
            }
            QLabel {
                color: #E0E0E0;
                padding: 2px 10px;
                font-family: 'Times New Roman', serif;
            }
        """)
        
        # Current game mode
        self.current_mode = GameMode.NORMAL
        
        # Create status labels
        self.location_label = QLabel("Location: Not in game")
        self.time_label = QLabel("Time: Not in game")
        self.mode_label = QLabel("Mode: Normal")
        
        # Add permanent widgets
        self.addPermanentWidget(self.location_label)
        self.addPermanentWidget(self.time_label)
        self.addPermanentWidget(self.mode_label)
    
    def update_status(self, location: str = "", game_time: str = "", speed: str = "", mode: str = ""):
        """Update the status bar with the provided information.
        
        Args:
            location: The current location name.
            game_time: The current game time.
            speed: The current game speed.
            mode: The current game mode (Normal, Combat, Barter).
        """
        if location:
            self.location_label.setText(f"Location: {location}")
        
        if game_time:
            self.time_label.setText(f"Time: {game_time}")
        
        # Update mode if provided
        if mode:
            try:
                self.current_mode = GameMode(mode)
                self.mode_label.setText(f"Mode: {self.current_mode.value}")
            except ValueError:
                # If invalid mode name, default to Normal
                self.current_mode = GameMode.NORMAL
                self.mode_label.setText(f"Mode: {self.current_mode.value}")
        
        # If no mode specified but speed is, derive from speed
        elif speed:
            if speed.lower() == "combat":
                self.current_mode = GameMode.COMBAT
            elif speed.lower() == "pause":
                # Paused but maintain the current mode type
                pass
            else:
                self.current_mode = GameMode.NORMAL
                
            self.mode_label.setText(f"Mode: {self.current_mode.value}")

```

### File: ..\gui\dialogs\settings\__init__.py

```python
"""
Settings dialogs for the RPG game GUI.
This package provides dialogs for configuring game settings.
"""

from gui.dialogs.settings.llm_settings_dialog import LLMSettingsDialog
from gui.dialogs.settings.settings_dialog import SettingsDialog

__all__ = ['LLMSettingsDialog', 'SettingsDialog']

```

### File: ..\gui\dialogs\settings\agent_setup_tab.py

```python
#!/usr/bin/env python3
"""
Agent setup tab for the RPG game GUI.
This module provides a tab for configuring which LLM provider and model to use for each agent.
"""

import logging
from typing import Dict, Any, List, Optional, Tuple
import json
import os

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QComboBox, QTableWidget, QTableWidgetItem, QHeaderView, QSpinBox,
    QDoubleSpinBox, QGroupBox, QDialog, QDialogButtonBox
)
from PySide6.QtCore import Qt, Signal

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.settings_manager import get_settings_manager

# Get the module logger
logger = logging.getLogger("GUI")

class AgentSetupDialog(QDialog):
    """Dialog for configuring an agent's LLM settings."""
    
    def __init__(self, parent=None, agent_name: str = "", agent_settings: Dict[str, Any] = None):
        """Initialize the dialog.
        
        Args:
            parent: Parent widget.
            agent_name: Name of the agent being configured.
            agent_settings: Current agent settings.
        """
        super().__init__(parent)
        
        self.agent_name = agent_name
        self.agent_settings = agent_settings or {}
        self.provider_manager = get_provider_manager()
        self.settings_manager = get_settings_manager()
        
        self.setWindowTitle(f"Configure {agent_name.capitalize()} Agent")
        self.setMinimumWidth(450)
        
        self._setup_ui()
        self._populate_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Form layout
        form_layout = QFormLayout()
        
        # Provider dropdown
        self.provider_combo = QComboBox()
        self._populate_providers()
        form_layout.addRow("Provider:", self.provider_combo)
        
        # Model dropdown
        self.model_combo = QComboBox()
        form_layout.addRow("Model:", self.model_combo)
        
        # Temperature setting
        self.temperature_spin = QDoubleSpinBox()
        self.temperature_spin.setRange(0.0, 1.0)
        self.temperature_spin.setSingleStep(0.1)
        self.temperature_spin.setDecimals(2)
        form_layout.addRow("Temperature:", self.temperature_spin)
        
        # Max tokens
        self.max_tokens_spin = QSpinBox()
        self.max_tokens_spin.setRange(100, 8000)
        self.max_tokens_spin.setSingleStep(100)
        form_layout.addRow("Max Tokens:", self.max_tokens_spin)
        
        # Timeout
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(10, 120)
        self.timeout_spin.setSingleStep(5)
        form_layout.addRow("Timeout (seconds):", self.timeout_spin)
        
        # Connect signals
        self.provider_combo.currentIndexChanged.connect(self._on_provider_changed)
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Add layouts
        layout.addLayout(form_layout)
        layout.addWidget(button_box)
    
    def _populate_providers(self):
        """Populate the providers dropdown."""
        self.provider_combo.clear()
        
        # Get available providers
        available_providers = self.provider_manager.get_available_providers()
        
        # Add each provider to the dropdown
        for provider in available_providers:
            self.provider_combo.addItem(provider.name.capitalize(), provider.name)
        
        # Add a placeholder if no providers are available
        if not available_providers:
            self.provider_combo.addItem("No providers available", "")
    
    def _on_provider_changed(self, index):
        """Handle provider selection change."""
        self.model_combo.clear()
        
        # Get selected provider type
        if index < 0:
            self.model_combo.addItem("Select a provider first", "")
            return
        
        provider_name = self.provider_combo.itemData(index)
        
        # Handle None or empty provider name
        if not provider_name:
            self.model_combo.addItem("Invalid provider", "")
            return
            
        try:
            provider_type = ProviderType[provider_name]
            
            # Get available models for this provider
            models = self.settings_manager.get_available_models(provider_type)
            
            # Add models to the dropdown
            for model in models:
                self.model_combo.addItem(model, model)
            
            # Add a placeholder if no models are available
            if not models:
                self.model_combo.addItem("No models available", "")
                
        except (KeyError, ValueError):
            logger.error(f"Invalid provider type: {provider_name}")
            self.model_combo.addItem("Error loading models", "")
    
    def _populate_settings(self):
        """Populate the dialog with current settings."""
        # Set provider
        provider_type_str = self.agent_settings.get("provider_type", "OPENAI")
        
        # Check if provider_type_str is None and provide a default
        if provider_type_str is None:
            provider_type_str = "OPENAI"
        
        for i in range(self.provider_combo.count()):
            if self.provider_combo.itemData(i) == provider_type_str:
                self.provider_combo.setCurrentIndex(i)
                break
        
        # Model will be populated by _on_provider_changed
        
        # Make sure to call provider change handler to populate the model dropdown
        self._on_provider_changed(self.provider_combo.currentIndex())
        
        # If we have a specific model, select it
        model = self.agent_settings.get("model", "")
        if model:
            for i in range(self.model_combo.count()):
                if self.model_combo.itemData(i) == model:
                    self.model_combo.setCurrentIndex(i)
                    break
        
        # Set other settings
        self.temperature_spin.setValue(self.agent_settings.get("temperature", 0.7))
        self.max_tokens_spin.setValue(self.agent_settings.get("max_tokens", 1000))
        self.timeout_spin.setValue(self.agent_settings.get("timeout_seconds", 30))
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the settings from the dialog.
        
        Returns:
            Dictionary of agent settings.
        """
        # Get provider type
        provider_index = self.provider_combo.currentIndex()
        provider_type_str = self.provider_combo.itemData(provider_index)
        
        # Get model
        model_index = self.model_combo.currentIndex()
        model = self.model_combo.itemData(model_index)
        
        # Build settings dictionary
        settings = {
            "provider_type": provider_type_str,
            "model": model,
            "temperature": self.temperature_spin.value(),
            "max_tokens": self.max_tokens_spin.value(),
            "timeout_seconds": self.timeout_spin.value(),
        }
        
        return settings


class AgentSetupTab(QWidget):
    """Tab for configuring agent LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the agent setup tab."""
        super().__init__(parent)
        
        self.settings_manager = get_settings_manager()
        self.provider_manager = get_provider_manager()
        
        # Store agent settings
        self.agent_settings = {}
        
        self._setup_ui()
        self._load_agent_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Description
        description = QLabel(
            "Configure which LLM provider and model to use for each agent in the game. "
            "Each agent can use a different provider and model configuration."
        )
        description.setWordWrap(True)
        layout.addWidget(description)
        
        # Agents table
        self.agents_table = QTableWidget()
        self.agents_table.setColumnCount(5)
        self.agents_table.setHorizontalHeaderLabels([
            "Agent", "Provider", "Model", "Temperature", "Configure"
        ])
        
        # Set table properties
        header = self.agents_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.Stretch)
        header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)
        
        layout.addWidget(self.agents_table)
    
    def _load_agent_settings(self):
        """Load agent settings and populate the table."""
        # Clear the table
        self.agents_table.setRowCount(0)
        
        # Get available agents
        agents = self.settings_manager.list_available_agents()
        
        # Populate table
        for i, agent_name in enumerate(agents):
            # Get agent settings
            settings = self.settings_manager.get_agent_settings(agent_name)
            self.agent_settings[agent_name] = settings
            
            # Add row
            self.agents_table.insertRow(i)
            
            # Agent name
            name_item = QTableWidgetItem(agent_name.capitalize())
            name_item.setFlags(name_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 0, name_item)
            
            # Provider
            provider_type_str = settings.get("provider_type", "OPENAI")
            # Check if provider_type_str is None and provide a default
            if provider_type_str is None:
                provider_type_str = "OPENAI"
            provider_item = QTableWidgetItem(provider_type_str.capitalize())
            provider_item.setFlags(provider_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 1, provider_item)
            
            # Model
            model = settings.get("model", "default")
            model_item = QTableWidgetItem(model)
            model_item.setFlags(model_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 2, model_item)
            
            # Temperature
            temp = settings.get("temperature", 0.7)
            temp_item = QTableWidgetItem(f"{temp:.2f}")
            temp_item.setFlags(temp_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 3, temp_item)
            
            # Configure button
            self.agents_table.setCellWidget(i, 4, self._create_configure_button(agent_name))
    
    def _create_configure_button(self, agent_name: str) -> QPushButton:
        """Create a configure button for an agent.
        
        Args:
            agent_name: Name of the agent.
            
        Returns:
            Configure button widget.
        """
        button = QPushButton("Configure")
        button.clicked.connect(lambda: self._configure_agent(agent_name))
        return button
    
    def _configure_agent(self, agent_name: str) -> None:
        """Open the agent configuration dialog.
        
        Args:
            agent_name: Name of the agent to configure.
        """
        # Get agent settings
        settings = self.agent_settings.get(agent_name, {})
        
        # Create and show the dialog
        dialog = AgentSetupDialog(self, agent_name, settings)
        
        if dialog.exec():
            # Get updated settings
            updated_settings = dialog.get_settings()
            
            # Update in-memory settings
            self.agent_settings[agent_name] = updated_settings
            
            # Save settings to disk
            success = self.settings_manager.update_agent_settings(agent_name, updated_settings)
            
            if success:
                logger.info(f"Updated settings for agent {agent_name}")
            else:
                logger.error(f"Failed to update settings for agent {agent_name}")
            
            # Reload table
            self._load_agent_settings()
    
    def save_settings(self) -> bool:
        """Save all agent settings.
        
        Returns:
            True if successful, False otherwise.
        """
        success = True
        
        for agent_name, settings in self.agent_settings.items():
            # Save settings to disk
            result = self.settings_manager.update_agent_settings(agent_name, settings)
            
            if not result:
                success = False
                logger.error(f"Failed to save settings for agent {agent_name}")
        
        return success

```

### File: ..\gui\dialogs\settings\anthropic_tab.py

```python
#!/usr/bin/env python3
"""
Anthropic provider tab for the RPG game GUI.
This module provides a tab for configuring Anthropic LLM provider settings.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import QFormLayout
from PySide6.QtCore import Qt

from gui.dialogs.settings.llm_provider_tab import LLMProviderTab
from gui.dialogs.settings.model_management_widget import ModelManagementWidget
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = logging.getLogger("GUI")

class AnthropicTab(LLMProviderTab):
    """Tab for Anthropic settings."""
    
    def __init__(self, parent=None):
        """Initialize the Anthropic settings tab."""
        super().__init__(parent, provider_name="Anthropic")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.ANTHROPIC, "Anthropic")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("Anthropic's Claude models provide thoughtful, creative, and reliable AI assistant capabilities.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Set models in model manager
        self.model_manager.set_models(models)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings

```

### File: ..\gui\dialogs\settings\background_tab.py

```python
#!/usr/bin/env python3
"""
Background selection tab for the settings dialog.
"""

import logging
import os
from typing import List, Optional, Tuple # Added Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize
from PySide6.QtGui import QPixmap, QMovie # Added QMovie

from gui.utils.resource_manager import get_resource_manager

logger = logging.getLogger(__name__)

class BackgroundTab(QWidget):
    """Widget for selecting the main window background."""

    # Signal emitted when the user previews a different background
    # Argument is the full filename of the background (e.g., 'my_bg.gif')
    preview_background_changed = Signal(str)

    def __init__(self, parent=None):
        """Initialize the background tab."""
        super().__init__(parent)

        self.resource_manager = get_resource_manager()
        self.backgrounds: List[Tuple[str, str]] = [] # Stores (name, ext) tuples
        self.current_index: int = -1
        # Default should ideally include extension, but resource manager might find it
        self.default_background_filename = "main_background.png"

        self._setup_ui()
        self._load_available_backgrounds()

    def _setup_ui(self):
        """Set up the user interface for the tab."""
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Preview Area
        preview_layout = QVBoxLayout()
        preview_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.preview_label = QLabel("Background Preview")
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_label.setMinimumSize(400, 225) # Aspect ratio 16:9
        self.preview_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.preview_label.setStyleSheet("border: 1px solid gray; background-color: #333;")
        preview_layout.addWidget(self.preview_label)

        self.name_label = QLabel("Background: N/A")
        self.name_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        preview_layout.addWidget(self.name_label)

        layout.addLayout(preview_layout)

        # Navigation Controls
        nav_layout = QHBoxLayout()
        nav_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.prev_button = QPushButton("< Prev")
        self.prev_button.clicked.connect(self._show_previous_background)
        self.prev_button.setFixedWidth(100)

        self.next_button = QPushButton("Next >")
        self.next_button.clicked.connect(self._show_next_background)
        self.next_button.setFixedWidth(100)

        nav_layout.addWidget(self.prev_button)
        nav_layout.addStretch()
        nav_layout.addWidget(self.next_button)

        layout.addLayout(nav_layout)
        layout.addStretch() # Push controls to the top

    def _load_available_backgrounds(self):
        """Load the list of available background image/animation names and extensions."""
        self.backgrounds = self.resource_manager.list_background_names()
        logger.info(f"Found backgrounds: {self.backgrounds}")
        if not self.backgrounds:
            logger.warning("No background images or GIFs found in images/gui/background/")
            self.prev_button.setEnabled(False)
            self.next_button.setEnabled(False)
        else:
            # Try to set initial index based on saved setting later in load_settings
            self.prev_button.setEnabled(len(self.backgrounds) > 1)
            self.next_button.setEnabled(len(self.backgrounds) > 1)

    def _update_preview(self):
        """Update the preview label with the current background (PNG or GIF)."""
        # Stop any existing movie
        current_movie = self.preview_label.movie()
        if current_movie:
            current_movie.stop()
            self.preview_label.setMovie(None) # Clear movie reference

        # Clear existing pixmap
        self.preview_label.setPixmap(QPixmap())

        if 0 <= self.current_index < len(self.backgrounds):
            name, ext = self.backgrounds[self.current_index]
            filename = f"{name}{ext}"
            self.name_label.setText(f"Background: {filename}")

            if ext.lower() == ".png":
                pixmap = self.resource_manager.get_background_pixmap(name)
                if not pixmap.isNull():
                    scaled_pixmap = pixmap.scaled(self.preview_label.size(),
                                                  Qt.AspectRatioMode.KeepAspectRatio,
                                                  Qt.TransformationMode.SmoothTransformation)
                    self.preview_label.setPixmap(scaled_pixmap)
                else:
                    self.preview_label.setText(f"Failed to load:\n{filename}")

            elif ext.lower() == ".gif":
                movie = self.resource_manager.get_background_movie(name)
                if movie.isValid():
                    self.preview_label.setMovie(movie)
                    # Scale movie if possible (QMovie doesn't scale directly like QPixmap)
                    # We might need to adjust label size policy or container layout
                    # For now, just set it and start
                    movie.setScaledSize(self.preview_label.size()) # Attempt scaling
                    movie.start()
                else:
                    self.preview_label.setText(f"Failed to load:\n{filename}")

            # Emit signal for live preview in main window with full filename
            self.preview_background_changed.emit(filename)
        else:
            self.name_label.setText("Background: N/A")
            self.preview_label.setText("No Background Selected")
            # Ensure both pixmap and movie are cleared
            self.preview_label.setPixmap(QPixmap())
            self.preview_label.setMovie(None)

    def _show_previous_background(self):
        """Navigate to the previous background image/animation."""
        if not self.backgrounds:
            return
        self.current_index = (self.current_index - 1) % len(self.backgrounds)
        self._update_preview()

    def _show_next_background(self):
        """Navigate to the next background image/animation."""
        if not self.backgrounds:
            return
        self.current_index = (self.current_index + 1) % len(self.backgrounds)
        self._update_preview()

    def load_settings(self, settings: QSettings):
        """Load the saved background setting (full filename). Defaults to first available if saved is invalid."""
        # Save/Load the full filename now, e.g., "my_background.gif"
        saved_filename = settings.value("style/background_filename", None)
        logger.info(f"Attempting to load background setting: '{saved_filename}'")

        self.current_index = -1 # Reset index

        if saved_filename:
            # Find the index corresponding to the saved filename
            found = False
            for i, (name, ext) in enumerate(self.backgrounds):
                if f"{name}{ext}" == saved_filename:
                    self.current_index = i
                    logger.info(f"Found saved background '{saved_filename}' at index {self.current_index}")
                    found = True
                    break
            if not found:
                 logger.warning(f"Saved background '{saved_filename}' not found in available list: {self.backgrounds}")
                 if self.backgrounds:
                     self.current_index = 0 # Fallback to first available
                     logger.info(f"Falling back to first available: '{self.backgrounds[self.current_index][0]}{self.backgrounds[self.current_index][1]}'")

        elif self.backgrounds:
            # No setting saved, use the first available
            self.current_index = 0
            logger.info(f"No background setting saved. Using first available: '{self.backgrounds[self.current_index][0]}{self.backgrounds[self.current_index][1]}'")
        else:
            # No setting saved and no backgrounds available
             logger.warning("No saved background setting and no backgrounds available.")
             self.current_index = -1

        # Update preview even if index is -1 (will show N/A)
        self._update_preview()

    def save_settings(self, settings: QSettings):
        """Save the currently selected background filename."""
        if 0 <= self.current_index < len(self.backgrounds):
            selected_name, selected_ext = self.backgrounds[self.current_index]
            selected_filename = f"{selected_name}{selected_ext}"
            settings.setValue("style/background_filename", selected_filename)
            logger.info(f"Saving background setting: '{selected_filename}'")
        else:
            # If somehow no valid index, try saving the default filename
            settings.setValue("style/background_filename", self.default_background_filename)
            logger.warning(f"No valid background selected, saving default filename: {self.default_background_filename}")
```

### File: ..\gui\dialogs\settings\base_settings_dialog.py

```python
#!/usr/bin/env python3
"""
Base settings dialog for the RPG game GUI.
This module provides a base dialog class for settings dialogs.
"""

import os
import json
import logging
from typing import Dict, Any, Optional

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget, QWidget
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QIcon

# Get the module logger
logger = logging.getLogger("GUI")

class BaseSettingsDialog(QDialog):
    """Base dialog for settings dialogs."""
    
    # Signal emitted when settings are saved
    settings_saved = Signal()
    
    def __init__(self, parent=None, title="Settings"):
        """Initialize the base settings dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle(title)
        self.setMinimumWidth(700)
        self.setMinimumHeight(500)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QLineEdit, QComboBox, QSpinBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QComboBox:focus, QSpinBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QPushButton.danger {
                background-color: #D32F2F;
            }
            QPushButton.danger:hover {
                background-color: #F44336;
            }
            QPushButton.danger:pressed {
                background-color: #B71C1C;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #2D2D30;
            }
            QTabWidget::tab-bar {
                left: 5px;
            }
            QTabBar::tab {
                background-color: #333333;
                border: 1px solid #555555;
                border-bottom-color: #555555;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 10px;
                color: #CCCCCC;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #0E639C;
                color: white;
            }
            QTabBar::tab:!selected {
                margin-top: 2px;
            }
            QCheckBox {
                color: #E0E0E0;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 1px solid #555555;
                border-radius: 2px;
                background-color: #1E1E1E;
            }
            QCheckBox::indicator:checked {
                background-color: #0E639C;
                border-color: #0E639C;
            }
        """)
        
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(20, 20, 20, 20)
        self.main_layout.setSpacing(15)
        
        # Set up the bottom button layout
        self._setup_button_layout()
    
    def _setup_button_layout(self):
        """Set up the bottom button layout."""
        # Create bottom button layout
        self.button_layout = QHBoxLayout()
        self.button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create save button
        self.save_button = QPushButton("Save Settings")
        self.save_button.clicked.connect(self._on_save)
        
        # Add buttons to layout
        self.button_layout.addStretch()
        self.button_layout.addWidget(self.cancel_button)
        self.button_layout.addWidget(self.save_button)
    
    def add_button_layout(self):
        """Add the button layout to the main layout."""
        self.main_layout.addLayout(self.button_layout)
    
    def add_left_button(self, button):
        """Add a button to the left side of the button layout."""
        self.button_layout.insertWidget(0, button)
    
    def _on_save(self):
        """Handle save button click."""
        # Save settings
        if self.save_settings():
            # Emit signal
            self.settings_saved.emit()
            
            # Accept dialog
            self.accept()
    
    def save_settings(self) -> bool:
        """
        Save settings.
        
        This method should be implemented by subclasses.
        
        Returns:
            True if settings were saved successfully, False otherwise.
        """
        return True

```

### File: ..\gui\dialogs\settings\llm_general_tab.py

```python
#!/usr/bin/env python3
"""
LLM general settings tab for the RPG game GUI.
This module provides a tab for configuring general LLM settings.
"""

import logging
from typing import Dict, Any

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QGroupBox, 
    QComboBox, QCheckBox, QSpinBox
)
from PySide6.QtCore import Qt

# Get the module logger
logger = logging.getLogger("GUI")

class LLMGeneralTab(QWidget):
    """Tab for general LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the general settings tab."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        
        # Create general settings group
        general_group = QGroupBox("General LLM Settings")
        general_layout = QFormLayout(general_group)
        general_layout.setFieldGrowthPolicy(QFormLayout.AllNonFixedFieldsGrow)
        
        # Create default provider setting
        self.default_provider_combo = QComboBox()
        self.default_provider_combo.addItem("OpenAI", "OPENAI")
        self.default_provider_combo.addItem("Google", "GOOGLE")
        self.default_provider_combo.addItem("OpenRouter", "OPENROUTER")
        general_layout.addRow("Default Provider:", self.default_provider_combo)
        
        # Create LLM toggle checkbox
        self.llm_enabled_check = QCheckBox("Enable LLM Processing")
        self.llm_enabled_check.setToolTip("Toggle LLM processing for game input")
        general_layout.addRow("", self.llm_enabled_check)
        
        # Create diagnostics at startup checkbox
        self.diagnostics_check = QCheckBox("Run diagnostics at startup")
        self.diagnostics_check.setToolTip("Test LLM connections when the application starts")
        general_layout.addRow("", self.diagnostics_check)
        
        # Create advanced settings group
        advanced_group = QGroupBox("Advanced Settings")
        advanced_layout = QFormLayout(advanced_group)
        
        # Create timeout setting
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(5, 120)
        self.timeout_spin.setSuffix(" seconds")
        self.timeout_spin.setToolTip("Maximum time to wait for LLM response")
        advanced_layout.addRow("Request Timeout:", self.timeout_spin)
        
        # Create retry attempts setting
        self.retry_spin = QSpinBox()
        self.retry_spin.setRange(1, 10)
        self.retry_spin.setToolTip("Number of retry attempts for failed requests")
        advanced_layout.addRow("Retry Attempts:", self.retry_spin)
        
        # Create retry delay setting
        self.retry_delay_spin = QSpinBox()
        self.retry_delay_spin.setRange(1, 30)
        self.retry_delay_spin.setSuffix(" seconds")
        self.retry_delay_spin.setToolTip("Delay between retry attempts")
        advanced_layout.addRow("Retry Delay:", self.retry_delay_spin)
        
        # Create temperature setting
        self.temperature_combo = QComboBox()
        self.temperature_combo.addItem("Low (0.3) - More focused, less creative", 0.3)
        self.temperature_combo.addItem("Medium (0.7) - Balanced", 0.7)
        self.temperature_combo.addItem("High (1.0) - More creative, less focused", 1.0)
        self.temperature_combo.setToolTip("Controls randomness of LLM responses")
        advanced_layout.addRow("Default Temperature:", self.temperature_combo)
        
        # Add groups to layout
        layout.addWidget(general_group)
        layout.addWidget(advanced_group)
        layout.addStretch(1)
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings.
        
        Args:
            settings: Dictionary with settings values
        """
        # Set provider type
        provider_type = settings.get("default_provider_type", "OPENAI")
        index = self.default_provider_combo.findData(provider_type)
        if index >= 0:
            self.default_provider_combo.setCurrentIndex(index)
        
        # Set checkboxes
        self.llm_enabled_check.setChecked(settings.get("llm_enabled", False))
        self.diagnostics_check.setChecked(settings.get("run_diagnostics_on_start", False))
        
        # Set spin boxes
        self.timeout_spin.setValue(settings.get("timeout_seconds", 30))
        self.retry_spin.setValue(settings.get("retry_attempts", 3))
        self.retry_delay_spin.setValue(settings.get("retry_delay_seconds", 2))
        
        # Set temperature combo
        temp = settings.get("default_temperature", 0.7)
        if temp <= 0.3:
            self.temperature_combo.setCurrentIndex(0)
        elif temp >= 1.0:
            self.temperature_combo.setCurrentIndex(2)
        else:
            self.temperature_combo.setCurrentIndex(1)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab.
        
        Returns:
            Dictionary with current settings values
        """
        return {
            "default_provider_type": self.default_provider_combo.currentData(),
            "default_temperature": self.temperature_combo.currentData(),
            "timeout_seconds": self.timeout_spin.value(),
            "retry_attempts": self.retry_spin.value(),
            "retry_delay_seconds": self.retry_delay_spin.value(),
            "run_diagnostics_on_start": self.diagnostics_check.isChecked(),
            "llm_enabled": self.llm_enabled_check.isChecked()
        }

```

### File: ..\gui\dialogs\settings\llm_provider_tab.py

```python
#!/usr/bin/env python3
"""
LLM provider settings tab for the RPG game GUI.
This module provides a base tab for configuring LLM provider settings.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QGroupBox, 
    QLineEdit, QComboBox, QCheckBox, QLabel
)
from PySide6.QtCore import Qt

# Get the module logger
logger = logging.getLogger("GUI")

class LLMProviderTab(QWidget):
    """Base tab for provider LLM settings."""
    
    def __init__(self, parent=None, provider_name="Provider"):
        """Initialize the provider settings tab."""
        super().__init__(parent)
        
        # Provider properties
        self.provider_name = provider_name
        self.api_key_setting_name = "api_key"
        self.models = []  # Will be set by subclasses: List of (display_name, value) tuples
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(10)
        
        # Create API settings group
        api_group = QGroupBox(f"{self.provider_name} API Settings")
        api_layout = QFormLayout(api_group)
        
        # Create enabled checkbox
        self.enabled_check = QCheckBox(f"Enable {self.provider_name}")
        self.enabled_check.setToolTip(f"Enable/disable {self.provider_name} provider")
        self.enabled_check.toggled.connect(self._toggle_fields)
        api_layout.addRow("", self.enabled_check)
        
        # Create API key field
        self.api_key_edit = QLineEdit()
        self.api_key_edit.setPlaceholderText(f"Enter your {self.provider_name} API key")
        self.api_key_edit.setEchoMode(QLineEdit.Password)
        api_layout.addRow("API Key:", self.api_key_edit)
        
        # Add info section (to be overridden by subclasses)
        self.info_label = QLabel("")
        self.info_label.setWordWrap(True)
        self.info_label.setStyleSheet("color: #AAAAAA; font-style: italic;")
        
        # Add groups to layout
        self.main_layout.addWidget(api_group)
        self.main_layout.addWidget(self.info_label)
        self.main_layout.addStretch(1)
    
    def add_models(self, models: List[Tuple[str, str]]):
        """Store models data.
        
        Args:
            models: List of (display_name, value) tuples
        """
        self.models = models
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        self.api_key_edit.setEnabled(enabled)
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings.
        
        Args:
            settings: Dictionary with settings values
        """
        # Set enabled checkbox
        self.enabled_check.setChecked(settings.get("enabled", True))
        
        # Set API key
        self.api_key_edit.setText(settings.get(self.api_key_setting_name, ""))
        
        # Toggle fields based on enabled state
        self._toggle_fields(self.enabled_check.isChecked())
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab.
        
        Returns:
            Dictionary with current settings values
        """
        settings = {
            "enabled": self.enabled_check.isChecked(),
            self.api_key_setting_name: self.api_key_edit.text()
        }
        
        return settings

```

### File: ..\gui\dialogs\settings\llm_settings_dialog.py

```python
#!/usr/bin/env python3
"""
LLM settings dialog for the RPG game GUI.
This module provides a dialog for configuring LLM settings.
"""

import os
import json
import logging
from typing import Dict, Any
import shutil
from datetime import datetime

from PySide6.QtWidgets import (
    QTabWidget, QMessageBox, QPushButton
)
from PySide6.QtCore import QSettings

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.llm_manager import get_llm_manager

from gui.dialogs.settings.base_settings_dialog import BaseSettingsDialog
from gui.dialogs.settings.llm_general_tab import LLMGeneralTab
from gui.dialogs.settings.provider_tabs import OpenAITab, GoogleTab, OpenRouterTab
from gui.dialogs.settings.anthropic_tab import AnthropicTab
from gui.dialogs.settings.agent_setup_tab import AgentSetupTab

# Get the module logger
logger = logging.getLogger("GUI")

class LLMSettingsDialog(BaseSettingsDialog):
    """Dialog for configuring LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the LLM settings dialog."""
        super().__init__(parent, title="LLM Settings")
        
        # Get provider manager
        self.provider_manager = get_provider_manager()
        
        # Get LLM manager
        self.llm_manager = get_llm_manager()

        # Get settings manager
        from core.llm.settings_manager import get_settings_manager # Add import if not already present
        self.settings_manager = get_settings_manager()

        # Load settings using SettingsManager
        self.provider_settings = self.settings_manager.get_provider_settings()
        self.base_settings = self.settings_manager.get_llm_settings() # Load base settings directly

        # Remove QSettings dependency entirely
        # self.qsettings = QSettings("RPG_Game", "LLM_Settings_Base")

        # Set up the UI
        self._setup_ui()
        
        # Populate the UI with settings
        self._populate_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create tab widget
        self.tab_widget = QTabWidget()
        
        # Create tabs
        self.general_tab = LLMGeneralTab()
        self.openai_tab = OpenAITab()
        self.google_tab = GoogleTab()
        self.anthropic_tab = AnthropicTab()
        self.openrouter_tab = OpenRouterTab()
        self.agent_setup_tab = AgentSetupTab()
        
        # Add tabs to widget
        self.tab_widget.addTab(self.general_tab, "General")
        self.tab_widget.addTab(self.openai_tab, "OpenAI")
        self.tab_widget.addTab(self.google_tab, "Google")
        self.tab_widget.addTab(self.anthropic_tab, "Anthropic")
        self.tab_widget.addTab(self.openrouter_tab, "OpenRouter")
        self.tab_widget.addTab(self.agent_setup_tab, "Agent Setup")
        
        # Add tab widget to main layout
        self.main_layout.addWidget(self.tab_widget)
        
        # Create reset button
        self.reset_button = QPushButton("Reset to Default")
        self.reset_button.setStyleSheet("QPushButton { background-color: #D32F2F; }")
        self.reset_button.clicked.connect(self._reset_settings)
        
        # Create test button
        self.test_button = QPushButton("Test Connections")
        self.test_button.clicked.connect(self._test_connections)
        
        # Add buttons to left side
        self.add_left_button(self.test_button)
        self.add_left_button(self.reset_button)
        
        # Add button layout
        self.add_button_layout()

    # _load_provider_settings method removed - SettingsManager handles loading in __init__
    # _load_base_settings method definition removed below

    def _populate_settings(self):
        """Populate the UI with current settings."""
        # Populate general settings
        self.general_tab.set_settings(self.base_settings)
        
        # Populate provider settings
        self.openai_tab.set_settings(self.provider_settings.get("openai", {}))
        self.google_tab.set_settings(self.provider_settings.get("google", {}))
        self.anthropic_tab.set_settings(self.provider_settings.get("anthropic", {}))
        self.openrouter_tab.set_settings(self.provider_settings.get("openrouter", {}))
    
    def _reset_settings(self):
        """Reset settings to default."""
        # Ask for confirmation
        result = QMessageBox.question(
            self, 
            "Reset Settings", 
            "Are you sure you want to reset all LLM settings to default?\n\nThis will remove all API keys and custom configurations.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        try:
            # --- Removed QSettings clear ---
            # self.qsettings.clear()

            # Reset config files
            config_dir = os.path.join("config", "llm")
            
            # Create backup of current config
            backup_dir = os.path.join(config_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Backup providers.json if it exists
            providers_file = os.path.join(config_dir, "providers.json")
            if os.path.exists(providers_file):
                backup_file = os.path.join(backup_dir, f"providers_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
                shutil.copy2(providers_file, backup_file)
                logger.info(f"Backed up providers.json to {backup_file}")
            
            # Backup base_config.json if it exists
            base_file = os.path.join(config_dir, "base_config.json")
            if os.path.exists(base_file):
                backup_file = os.path.join(backup_dir, f"base_config_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
                shutil.copy2(base_file, backup_file)
                logger.info(f"Backed up base_config.json to {backup_file}")
            
            # Create default provider settings file
            default_providers = {
                "openai": {
                    "api_key": "",
                    "organization": "",
                    "api_base": "https://api.openai.com/v1",
                    "default_model": "gpt-4o-mini",
                    "available_models": ["gpt-4o", "gpt-4o-mini"],
                    "enabled": True
                },
                "google": {
                    "api_key": "",
                    "default_model": "gemini-2.0-flash",
                    "available_models": ["gemini-2.0-flash", "gemini-2.0-flash-lite"],
                    "enabled": True
                },
                "openrouter": {
                    "api_key": "",
                    "api_base": "https://openrouter.ai/api/v1",
                    "default_model": "nousresearch/deephermes-3-llama-3-8b-preview:free",
                    "available_models": [
                        "google/gemini-2.0-flash-lite-preview-02-05:free", 
                        "nousresearch/deephermes-3-llama-3-8b-preview:free",
                        "google/gemini-2.0-pro-exp-02-05:free", 
                        "mistralai/mistral-small-3.1-24b-instruct:free"
                    ],
                    "enabled": True
                }
            }

            with open(providers_file, 'w', encoding='utf-8') as f:
                json.dump(default_providers, f, indent=4)
            
            # Create default base settings file
            default_base = {
                "default_provider_type": "OPENAI",
                "default_temperature": 0.7,
                "timeout_seconds": 30,
                "retry_attempts": 3,
                "retry_delay_seconds": 2,
                "run_diagnostics_on_start": False,
                "log_prompts": True,
                "log_completions": True,
                "cost_tracking_enabled": True
            }
            
            with open(base_file, 'w', encoding='utf-8') as f:
                json.dump(default_base, f, indent=4)

            # Reload settings using SettingsManager
            self.provider_settings = self.settings_manager.get_provider_settings()
            self.base_settings = self.settings_manager.get_llm_settings()

            # Repopulate UI
            self._populate_settings()
            
            # Show success message
            QMessageBox.information(
                self,
                "Settings Reset",
                "LLM settings have been reset to default values.\nPrevious settings were backed up in the config/llm/backup directory."
            )
            
        except Exception as e:
            logger.error(f"Error resetting settings: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred while resetting settings: {str(e)}"
            )
    
    def _test_connections(self):
        """Test LLM connections."""
        try:
            # Save current settings temporarily
            self.save_settings(show_success=False)
            
            # Reinitialize provider manager
            self.provider_manager = get_provider_manager()
            
            # Run diagnostics
            diagnostics = self.llm_manager.run_llm_diagnostics()
            
            # Build results message
            message = f"LLM Diagnostics: {diagnostics['status']}\n\n"
            
            for provider_name, provider_result in diagnostics.get("providers", {}).items():
                status = provider_result.get("status", "unknown")
                status_text = "✓ Success" if status == "success" else "✗ Failed"
                
                message += f"{provider_name}: {status_text}\n"
                
                if status == "success":
                    model = provider_result.get("model", "unknown")
                    message += f"  Model: {model}\n"
                    message += f"  Response: {provider_result.get('response_content', '')[:50]}...\n"
                else:
                    message += f"  Error: {provider_result.get('error', 'Unknown error')}\n"
                
                message += "\n"
            
            # Show results
            QMessageBox.information(
                self,
                "Connection Test Results",
                message
            )
            
        except Exception as e:
            logger.error(f"Error testing connections: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred while testing connections: {str(e)}"
            )
    
    def save_settings(self, show_success=True) -> bool:
        """Save settings to configuration files and QSettings.
        
        Args:
            show_success: Whether to show a success message
            
        Returns:
            True if settings were saved successfully, False otherwise
        """
        try:
            # Get settings from UI
            
            # Get settings from UI
            base_settings = self.general_tab.get_settings()
            
            # Get provider settings
            provider_settings = {
                "openai": self.openai_tab.get_settings(),
                "anthropic": self.anthropic_tab.get_settings(),
                "google": self.google_tab.get_settings(),
                "openrouter": self.openrouter_tab.get_settings()
            }
            
            # Save agent settings (This saves agent JSON files via SettingsManager)
            self.agent_setup_tab.save_settings()

            # --- Removed saving provider settings to QSettings ---
            # Provider settings are now saved directly to providers.json
            # by the ModelManagementWidget and provider tabs via SettingsManager.
            # The loop below updates the ProviderManager instance, which relies
            # on SettingsManager having already saved the JSON.

            # Save base settings using SettingsManager
            if self.settings_manager.update_llm_settings(base_settings):
                logger.info("Successfully saved base LLM settings to JSON.")
            else:
                logger.error("Failed to save base LLM settings to JSON.")
                # Optionally raise an error or show a specific message

            # --- Removed saving base settings to QSettings ---
            # self.qsettings.beginGroup("base")
            # for key, value in base_settings.items():
            #     self.qsettings.setValue(key, value)
            # self.qsettings.endGroup()

            # Update provider manager (This updates the in-memory state of the manager)
            for provider_type_name, provider_name in [
                (ProviderType.OPENAI, "openai"),
                (ProviderType.GOOGLE, "google"),
                (ProviderType.OPENROUTER, "openrouter")
            ]:
                # Update provider settings
                if provider_name in provider_settings:
                    self.provider_manager.update_provider_settings(
                        provider_type_name, 
                        provider_settings[provider_name]
                    )
            
            # Set LLM enabled state
            if "llm_enabled" in base_settings:
                from core.base.engine import get_game_engine
                engine = get_game_engine()
                engine.set_llm_enabled(base_settings["llm_enabled"])
            
            # Show success message
            if show_success:
                QMessageBox.information(
                    self,
                    "Settings Saved",
                    "LLM settings have been saved successfully."
                )
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving settings: {e}")
            
            if show_success:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"An error occurred while saving settings: {str(e)}"
                )
            
            return False


# For testing
if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication
    from core.utils.logging_config import setup_logging
    
    # Set up logging
    setup_logging()
    
    # Create application
    app = QApplication(sys.argv)
    
    # Create dialog
    dialog = LLMSettingsDialog()
    
    # Show dialog
    dialog.exec()

```

### File: ..\gui\dialogs\settings\model_management_widget.py

```python
#!/usr/bin/env python3
"""
Model management widget for LLM settings.

This module provides a widget for adding, removing, and modifying
available LLM models for each provider.
"""

import logging
from typing import List, Dict, Any, Callable, Optional, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QDialog, QFormLayout,
    QDialogButtonBox, QGroupBox
)
from PySide6.QtCore import Qt, Signal

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.settings_manager import get_settings_manager

# Get the module logger
logger = logging.getLogger("GUI")

class AddEditModelDialog(QDialog):
    """Dialog for adding or editing a model."""
    
    def __init__(self, parent=None, edit_data: Optional[Tuple[str, str]] = None):
        """Initialize the dialog.
        
        Args:
            parent: Parent widget.
            edit_data: Tuple of (display_name, model_id) if editing, None if adding.
        """
        super().__init__(parent)
        
        self.edit_data = edit_data
        self.setWindowTitle("Add Model" if not edit_data else "Edit Model")
        self.setMinimumWidth(350)
        
        self._setup_ui()
        
        if edit_data:
            self._populate_edit_data(edit_data)
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Form layout for inputs
        form_layout = QFormLayout()
        
        # Model display name field
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Display name shown in UI")
        form_layout.addRow("Display Name:", self.name_edit)
        
        # Model ID/Value field
        self.value_edit = QLineEdit()
        self.value_edit.setPlaceholderText("Actual model ID/name used in API calls")
        form_layout.addRow("Model ID:", self.value_edit)
        
        # Add help text
        help_label = QLabel(
            "Note: Model ID should match the exact identifier expected by the API. "
            "For example: 'gpt-4o' for OpenAI or 'gemini-2.0-flash' for Google."
        )
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Add layouts to main layout
        layout.addLayout(form_layout)
        layout.addWidget(help_label)
        layout.addWidget(button_box)
    
    def _populate_edit_data(self, edit_data: Tuple[str, str]):
        """Populate the dialog with data for editing."""
        display_name, model_id = edit_data
        self.name_edit.setText(display_name)
        self.value_edit.setText(model_id)
    
    def get_model_data(self) -> Tuple[str, str]:
        """Get the model data entered by the user.
        
        Returns:
            Tuple of (display_name, model_id).
        """
        return (self.name_edit.text(), self.value_edit.text())


class ModelManagementWidget(QWidget):
    """Widget for managing LLM models for a provider."""
    
    # Signal emitted when models are updated
    models_updated = Signal(list)  # List of (display_name, model_id) tuples
    
    def __init__(self, parent=None, provider_type: ProviderType = None, provider_name: str = "Provider"):
        """Initialize the widget.
        
        Args:
            parent: Parent widget.
            provider_type: The type of provider.
            provider_name: Human-readable name of the provider.
        """
        super().__init__(parent)
        
        self.provider_type = provider_type
        self.provider_name = provider_name
        self.settings_manager = get_settings_manager()
        self.provider_manager = get_provider_manager()
        
        # Current models list [(display_name, model_id), ...]
        self.models = []
        
        self._setup_ui()
        self._load_models()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Main layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Group box
        group_box = QGroupBox(f"{self.provider_name} Models")
        group_layout = QVBoxLayout(group_box)
        
        # Description
        description = QLabel(f"Manage available models for {self.provider_name}:")
        description.setWordWrap(True)
        group_layout.addWidget(description)
        
        # List and buttons layout
        list_buttons_layout = QHBoxLayout()
        
        # Model list
        self.model_list = QListWidget()
        self.model_list.setMinimumHeight(150)
        self.model_list.itemSelectionChanged.connect(self._handle_selection_changed)
        list_buttons_layout.addWidget(self.model_list)
        
        # Buttons layout
        buttons_layout = QVBoxLayout()
        
        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self._handle_add)
        
        self.edit_button = QPushButton("Edit")
        self.edit_button.clicked.connect(self._handle_edit)
        self.edit_button.setEnabled(False)
        
        self.remove_button = QPushButton("Remove")
        self.remove_button.clicked.connect(self._handle_remove)
        self.remove_button.setEnabled(False)
        
        self.set_default_button = QPushButton("Set Default")
        self.set_default_button.clicked.connect(self._handle_set_default)
        self.set_default_button.setEnabled(False)
        
        buttons_layout.addWidget(self.add_button)
        buttons_layout.addWidget(self.edit_button)
        buttons_layout.addWidget(self.remove_button)
        buttons_layout.addWidget(self.set_default_button)
        buttons_layout.addStretch()
        
        list_buttons_layout.addLayout(buttons_layout)
        
        # Default model info
        self.default_model_label = QLabel("Default model: None")
        
        # Add widgets to layout
        group_layout.addLayout(list_buttons_layout)
        group_layout.addWidget(self.default_model_label)
        
        # Add group box to main layout
        layout.addWidget(group_box)
    
    def _load_models(self):
        """Load models from settings."""
        if not self.provider_type:
            return
        
        # Get provider settings
        settings = self.settings_manager.get_provider_settings(self.provider_type)
        available_models = settings.get("available_models", [])
        default_model = settings.get("default_model", "")
        
        # Clear current models
        self.models = []
        self.model_list.clear()
        
        # Simple case: just model IDs in the list
        if all(isinstance(model, str) for model in available_models):
            for model_id in available_models:
                # Use the model ID as display name too
                self.models.append((model_id, model_id))
                item = QListWidgetItem(model_id)
                item.setData(Qt.UserRole, model_id)
                self.model_list.addItem(item)
        
        # Update default model label
        if default_model:
            self.default_model_label.setText(f"Default model: {default_model}")
        else:
            self.default_model_label.setText("Default model: None")
    
    def _handle_selection_changed(self):
        """Handle selection change in the model list."""
        selected = self.model_list.selectedItems()
        has_selection = len(selected) > 0
        
        self.edit_button.setEnabled(has_selection)
        self.remove_button.setEnabled(has_selection)
        self.set_default_button.setEnabled(has_selection)
    
    def _handle_add(self):
        """Handle add button click."""
        dialog = AddEditModelDialog(self)
        if dialog.exec():
            display_name, model_id = dialog.get_model_data()
            
            # Validate input
            if not display_name or not model_id:
                QMessageBox.warning(self, "Invalid Input", "Both display name and model ID are required.")
                return
            
            # Check for duplicates
            for _, existing_id in self.models:
                if existing_id == model_id:
                    QMessageBox.warning(
                        self, 
                        "Duplicate Model", 
                        f"A model with ID '{model_id}' already exists."
                    )
                    return
            
            # Add to list
            self.models.append((display_name, model_id))
            item = QListWidgetItem(display_name)
            item.setData(Qt.UserRole, model_id)
            self.model_list.addItem(item)
            
            # Update settings
            self._save_models()
    
    def _handle_edit(self):
        """Handle edit button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        display_name = item.text()
        model_id = item.data(Qt.UserRole)
        
        dialog = AddEditModelDialog(self, (display_name, model_id))
        if dialog.exec():
            new_display_name, new_model_id = dialog.get_model_data()
            
            # Validate input
            if not new_display_name or not new_model_id:
                QMessageBox.warning(self, "Invalid Input", "Both display name and model ID are required.")
                return
            
            # Check for duplicates if model ID changed
            if new_model_id != model_id:
                for _, existing_id in self.models:
                    if existing_id == new_model_id:
                        QMessageBox.warning(
                            self, 
                            "Duplicate Model", 
                            f"A model with ID '{new_model_id}' already exists."
                        )
                        return
            
            # Update list
            index = self.model_list.row(item)
            self.models[index] = (new_display_name, new_model_id)
            
            item.setText(new_display_name)
            item.setData(Qt.UserRole, new_model_id)
            
            # Update settings
            self._save_models()
    
    def _handle_remove(self):
        """Handle remove button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        display_name = item.text()
        model_id = item.data(Qt.UserRole)
        
        # Confirm removal
        result = QMessageBox.question(
            self,
            "Remove Model",
            f"Are you sure you want to remove the model '{display_name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Check if it's the default model
        provider_settings = self.settings_manager.get_provider_settings(self.provider_type)
        default_model = provider_settings.get("default_model", "")
        
        if model_id == default_model:
            result = QMessageBox.question(
                self,
                "Remove Default Model",
                f"This model is currently set as the default model. "
                f"If you remove it, you'll need to select a new default model. "
                f"Do you want to continue?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if result != QMessageBox.Yes:
                return
        
        # Remove from list
        index = self.model_list.row(item)
        self.model_list.takeItem(index)
        self.models.pop(index)
        
        # Update settings
        self._save_models()
        
        # Reset default model if needed
        if model_id == default_model and self.models:
            self._set_default_model(self.models[0][1])  # Use first model as default
    
    def _handle_set_default(self):
        """Handle set default button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        model_id = item.data(Qt.UserRole)
        
        self._set_default_model(model_id)
    
    def _set_default_model(self, model_id: str):
        """Set the default model.
        
        Args:
            model_id: The model ID to set as default.
        """
        if not self.provider_type:
            return
        
        # Update settings
        self.settings_manager.update_provider_settings(
            self.provider_type,
            {"default_model": model_id}
        )
        
        # Update UI
        self.default_model_label.setText(f"Default model: {model_id}")
        
        logger.info(f"Set default model for {self.provider_name} to {model_id}")
    
    def _save_models(self):
        """Save the current models to settings."""
        if not self.provider_type:
            return
        
        # Extract model IDs
        model_ids = [model_id for _, model_id in self.models]
        
        # Update settings
        self.settings_manager.update_provider_settings(
            self.provider_type,
            {"available_models": model_ids}
        )
        
        # Emit signal
        self.models_updated.emit(self.models)
        
        logger.info(f"Updated models for {self.provider_name}: {model_ids}")
    
    def set_models(self, models: List[Tuple[str, str]]):
        """Set the models list.
        
        Args:
            models: List of (display_name, model_id) tuples.
        """
        self.models = models.copy()
        self.model_list.clear()
        
        for display_name, model_id in self.models:
            item = QListWidgetItem(display_name)
            item.setData(Qt.UserRole, model_id)
            self.model_list.addItem(item)

```

### File: ..\gui\dialogs\settings\provider_tabs.py

```python
#!/usr/bin/env python3
"""
LLM provider-specific tabs for the RPG game GUI.
This module provides tabs for different LLM providers.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import (
    QFormLayout, QLineEdit, QLabel, QVBoxLayout
)
from PySide6.QtCore import Qt

from gui.dialogs.settings.llm_provider_tab import LLMProviderTab
from gui.dialogs.settings.model_management_widget import ModelManagementWidget
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = logging.getLogger("GUI")

class OpenAITab(LLMProviderTab):
    """Tab for OpenAI settings."""
    
    def __init__(self, parent=None):
        """Initialize the OpenAI settings tab."""
        super().__init__(parent, provider_name="OpenAI")
        
        # Add OpenAI specific properties
        self.api_key_setting_name = "api_key"
        
        # Add OpenAI specific fields
        form_layout = self.findChild(QFormLayout)
        
        # Organization field
        self.org_edit = QLineEdit()
        self.org_edit.setPlaceholderText("Organization ID (optional)")
        form_layout.insertRow(2, "Organization:", self.org_edit)
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.OPENAI, "OpenAI")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("OpenAI's GPT models are powerful general-purpose models with varying capabilities.")
        
        # Connect signals
        self.enabled_check.toggled.connect(self._toggle_openai_fields)
    
    def _toggle_openai_fields(self, enabled: bool):
        """Toggle OpenAI-specific fields."""
        self.org_edit.setEnabled(enabled)
        self.model_manager.setEnabled(enabled)
        
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set OpenAI-specific settings
        self.org_edit.setText(settings.get("organization", ""))
        self.org_edit.setEnabled(self.enabled_check.isChecked())
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Set models in model manager
        self.model_manager.set_models(models)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add OpenAI-specific settings
        settings["organization"] = self.org_edit.text()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings


class GoogleTab(LLMProviderTab):
    """Tab for Google settings."""
    
    def __init__(self, parent=None):
        """Initialize the Google settings tab."""
        super().__init__(parent, provider_name="Google AI")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.GOOGLE, "Google AI")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("Google's Gemini models provide strong multilingual capabilities and state-of-the-art performance.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Set models in model manager
        self.model_manager.set_models(models)
        
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings


class OpenRouterTab(LLMProviderTab):
    """Tab for OpenRouter settings."""
    
    def __init__(self, parent=None):
        """Initialize the OpenRouter settings tab."""
        super().__init__(parent, provider_name="OpenRouter")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.OPENROUTER, "OpenRouter")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("OpenRouter allows access to multiple AI models from different providers through a single API. Create an account at openrouter.ai to get started.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Set models in model manager
        self.model_manager.set_models(models)
        
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings

```

### File: ..\gui\dialogs\settings\settings_dialog.py

```python
# --- START OF FILE settings_dialog.py ---

#!/usr/bin/env python3
"""
Settings dialog for the RPG game GUI.
This module provides a dialog for configuring game settings.
"""

import logging
import json
import os
from typing import Dict, Any

from gui.dialogs.base_dialog import BaseDialog
from gui.dialogs.settings.style_tab import StyleTab
from gui.dialogs.settings.background_tab import BackgroundTab 

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox,
    QPushButton, QTabWidget, QWidget, QFormLayout,
    QCheckBox, QSpinBox, QGroupBox, QRadioButton, QButtonGroup,
    QSlider 
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize, Slot
from PySide6.QtGui import QColor 

class SettingsDialog(BaseDialog):
    """Dialog for configuring game settings."""

    # Signal emitted when settings are saved
    settings_saved = Signal()

    # Signal emitted when a background preview is requested by the BackgroundTab
    background_preview_requested = Signal(str)

    def __init__(self, parent=None):
        """Initialize the settings dialog."""
        super().__init__(parent)


        # # --- ADDED: Ensure dialog has a default background --- 
        # self.setAutoFillBackground(True)
        # palette = self.palette()
        # # Use a light color that usually contrasts well with default black text
        # palette.setColor(self.backgroundRole(), QColor("#F0F0F0")) 
        # self.setPalette(palette)
        # # --- END ADDED --- 

        # Set dialog properties
        self.setWindowTitle("Game Settings")
        self.setMinimumWidth(500)

        # Load current settings
        self.settings = QSettings("RPGGame", "Settings")

        # Set up the UI
        self._setup_ui()

        # Load settings into the UI
        self._load_settings()

    def _setup_ui(self):
        """Set up the user interface."""
        # Create main layout
        layout = QVBoxLayout(self)

        # Create tab widget for settings categories
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget::pane { /* The area where tab pages are displayed */
                border: 1px solid #555555;
                background-color: #2D2D30; /* Dark background for the content pane */
                border-top: 1px solid #555555; /* Ensure top border is visible */
            }
            QTabBar::tab { /* Style for individual tabs */
                background-color: #333333; /* Dark background for non-selected tabs */
                color: #CCCCCC; /* Light text for non-selected tabs */
                border: 1px solid #555555;
                border-bottom: none; /* Remove bottom border for non-selected tabs */
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 12px; /* Adjusted padding */
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2D2D30; /* Match pane background for selected tab */
                color: #E0E0E0; /* Brighter text for selected tab */
                border-bottom: 1px solid #2D2D30; /* Blend selected tab with pane */
            }
            QTabBar::tab:!selected:hover {
                background-color: #454545; /* Slightly lighter for hover on non-selected tabs */
            }
            QTabWidget QWidget { /* Ensure widgets inside tabs also have transparent background if needed */
                 background-color: transparent; /* Or match #2D2D30 if transparency causes issues */
            }
        """)

        # Set up tabs
        self._setup_display_tab()
        self._setup_sound_tab()
        self._setup_gameplay_tab()
        self._setup_style_tab()
        self._setup_background_tab()

        # Add tab widget to layout
        layout.addWidget(self.tab_widget)

        # Create button box
        button_layout = QHBoxLayout()

        # Save button
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self._save_settings)

        # Cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)

        # Add buttons to layout
        button_layout.addStretch()
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.cancel_button)

        # Add button layout to main layout
        layout.addLayout(button_layout)

    def _setup_display_tab(self):
        """Set up the display settings tab."""
        # Create display tab
        display_tab = QWidget()
        display_layout = QVBoxLayout(display_tab)

        # Create form layout for settings
        form_layout = QFormLayout()

        # --- Window Mode Setting ---
        display_mode_group = QGroupBox("Display Mode")
        display_mode_layout = QVBoxLayout(display_mode_group)
        self.display_mode_group = QButtonGroup(self) # Group for radio buttons

        self.windowed_radio = QRadioButton("Windowed")
        self.windowed_fullscreen_radio = QRadioButton("Windowed Fullscreen (Maximized)")
        self.fullscreen_radio = QRadioButton("Fullscreen")

        self.display_mode_group.addButton(self.windowed_radio, 0)
        self.display_mode_group.addButton(self.windowed_fullscreen_radio, 1)
        self.display_mode_group.addButton(self.fullscreen_radio, 2)

        display_mode_layout.addWidget(self.windowed_radio)
        display_mode_layout.addWidget(self.windowed_fullscreen_radio)
        display_mode_layout.addWidget(self.fullscreen_radio)

        # --- Resolution Setting (Enabled only for Windowed) ---
        resolution_layout = QHBoxLayout()
        self.resolution_label = QLabel("Resolution (Windowed):") # Label clarifies when it applies
        self.resolution_combo = QComboBox()
        self.resolution_combo.addItem("800x600", QSize(800, 600))
        self.resolution_combo.addItem("1024x768", QSize(1024, 768))
        self.resolution_combo.addItem("1280x720", QSize(1280, 720))
        self.resolution_combo.addItem("1366x768", QSize(1366, 768))
        self.resolution_combo.addItem("1600x900", QSize(1600, 900))
        self.resolution_combo.addItem("1920x1080", QSize(1920, 1080))
        # Add more resolutions if needed
        resolution_layout.addWidget(self.resolution_label)
        resolution_layout.addWidget(self.resolution_combo)

        # Connect radio button toggle to enable/disable resolution combo
        self.windowed_radio.toggled.connect(self._update_resolution_state)

        # Add display mode and resolution to the form layout
        display_layout.addWidget(display_mode_group)
        display_layout.addLayout(resolution_layout) # Add the HBox layout

        # --- UI Scale Setting ---
        self.ui_scale_combo = QComboBox()
        self.ui_scale_combo.addItem("100%", 1.0)
        self.ui_scale_combo.addItem("125%", 1.25)
        self.ui_scale_combo.addItem("150%", 1.5)
        self.ui_scale_combo.addItem("175%", 1.75)
        self.ui_scale_combo.addItem("200%", 2.0)
        # Add UI Scale to its own layout or directly if preferred
        ui_scale_layout = QHBoxLayout()
        ui_scale_layout.addWidget(QLabel("UI Scale:"))
        ui_scale_layout.addWidget(self.ui_scale_combo)
        display_layout.addLayout(ui_scale_layout)

        # --- Text Speed Setting ---
        text_speed_layout = QHBoxLayout()
        text_speed_layout.addWidget(QLabel("Gradual Text Speed:"))
        self.text_speed_slider = QSlider(Qt.Horizontal)
        self.text_speed_slider.setRange(5, 100)
        self.text_speed_slider.setTickPosition(QSlider.TicksBelow)
        self.text_speed_slider.setTickInterval(10)
        self.text_speed_label = QLabel("30 ms")
        self.text_speed_slider.valueChanged.connect(
            lambda value: self.text_speed_label.setText(f"{value} ms")
        )
        text_speed_layout.addWidget(self.text_speed_slider)
        text_speed_layout.addWidget(self.text_speed_label)
        display_layout.addLayout(text_speed_layout)

        display_layout.addStretch()

        # Add display tab to tab widget
        self.tab_widget.addTab(display_tab, "Display")

    @Slot(bool)
    def _update_resolution_state(self, checked):
        """Enable/disable resolution combo based on Windowed mode selection."""
        is_windowed = self.windowed_radio.isChecked()
        self.resolution_label.setEnabled(is_windowed)
        self.resolution_combo.setEnabled(is_windowed)

    def _setup_sound_tab(self):
        """Set up the sound settings tab."""
        # Create sound tab
        sound_tab = QWidget()
        sound_layout = QVBoxLayout(sound_tab)

        # Create form layout for settings
        form_layout = QFormLayout()

        # Create master volume setting
        self.master_volume_spin = QSpinBox()
        self.master_volume_spin.setRange(0, 100)
        self.master_volume_spin.setSuffix("%")
        form_layout.addRow("Master Volume:", self.master_volume_spin)

        # Create music volume setting
        self.music_volume_spin = QSpinBox()
        self.music_volume_spin.setRange(0, 100)
        self.music_volume_spin.setSuffix("%")
        form_layout.addRow("Music Volume:", self.music_volume_spin)

        # Create sound effects volume setting
        self.effects_volume_spin = QSpinBox()
        self.effects_volume_spin.setRange(0, 100)
        self.effects_volume_spin.setSuffix("%")
        form_layout.addRow("Sound Effects Volume:", self.effects_volume_spin)

        # Create sound enabled checkbox
        self.sound_enabled_check = QCheckBox("Enable Sound")

        # Add form layout to sound layout
        sound_layout.addLayout(form_layout)
        sound_layout.addWidget(self.sound_enabled_check)
        sound_layout.addStretch()

        # Add sound tab to tab widget
        self.tab_widget.addTab(sound_tab, "Sound")

    def _setup_gameplay_tab(self):
        """Set up the gameplay settings tab."""
        # Create gameplay tab
        gameplay_tab = QWidget()
        gameplay_layout = QVBoxLayout(gameplay_tab)

        # Create form layout for settings
        form_layout = QFormLayout()

        # Create difficulty setting
        self.difficulty_combo = QComboBox()
        self.difficulty_combo.addItem("Easy")
        self.difficulty_combo.addItem("Normal")
        self.difficulty_combo.addItem("Hard")
        form_layout.addRow("Difficulty:", self.difficulty_combo)

        # Create auto-save interval setting
        self.autosave_spin = QSpinBox()
        self.autosave_spin.setRange(0, 60)
        self.autosave_spin.setSuffix(" minutes")
        self.autosave_spin.setSpecialValueText("Off")
        form_layout.addRow("Auto-save Interval:", self.autosave_spin)

        # Create tutorial checkbox
        self.tutorial_check = QCheckBox("Show Tutorial Tips")

        # Add form layout to gameplay layout
        gameplay_layout.addLayout(form_layout)
        gameplay_layout.addWidget(self.tutorial_check)
        gameplay_layout.addStretch()

        # Add gameplay tab to tab widget
        self.tab_widget.addTab(gameplay_tab, "Gameplay")

    def _load_settings(self):
        """Load settings from QSettings to the UI."""
        # Load display settings
        window_state = self.settings.value("display/window_state", "windowed")
        if window_state == "fullscreen":
            self.fullscreen_radio.setChecked(True)
        elif window_state == "maximized": # Changed key to 'maximized'
            self.windowed_fullscreen_radio.setChecked(True)
        else: # Default to windowed
            self.windowed_radio.setChecked(True)

        # Update resolution combo state initially
        self._update_resolution_state(self.windowed_radio.isChecked())

        # Load windowed resolution (even if not currently windowed)
        default_size = QSize(1280, 720)
        resolution = self.settings.value("display/windowed_size", default_size)
        # Ensure resolution is QSize
        if not isinstance(resolution, QSize):
            if isinstance(resolution, (tuple, list)) and len(resolution) == 2:
                resolution = QSize(resolution[0], resolution[1])
            elif isinstance(resolution, str):
                try:
                    parts = resolution.strip('()').split(',')
                    resolution = QSize(int(parts[0]), int(parts[1]))
                except Exception:
                    resolution = default_size # Fallback on parse error
            else:
                 resolution = default_size # Fallback if type is unexpected

        resolution_str = f"{resolution.width()}x{resolution.height()}"
        found = False
        for i in range(self.resolution_combo.count()):
            if self.resolution_combo.itemText(i) == resolution_str:
                self.resolution_combo.setCurrentIndex(i)
                found = True
                break
        if not found: # If saved resolution isn't in the list, add it? Or default?
            # Option 1: Add it (might make combo long)
            # self.resolution_combo.addItem(resolution_str, resolution)
            # self.resolution_combo.setCurrentIndex(self.resolution_combo.count() - 1)
            # Option 2: Default to first item if not found
             self.resolution_combo.setCurrentIndex(0)
             logging.warning(f"Saved windowed resolution {resolution_str} not found in options. Defaulting.")


        # Load UI scale (unchanged)
        ui_scale = self.settings.value("display/ui_scale", 1.0)
        for i in range(self.ui_scale_combo.count()):
            if self.ui_scale_combo.itemData(i) == ui_scale:
                self.ui_scale_combo.setCurrentIndex(i)
                break

        # Load text speed setting (unchanged)
        text_speed_delay = self.settings.value("display/text_speed_delay", 30, int)
        self.text_speed_slider.setValue(text_speed_delay)
        self.text_speed_label.setText(f"{text_speed_delay} ms")

        # Load sound settings (unchanged)
        self.master_volume_spin.setValue(int(self.settings.value("sound/master_volume", 100)))
        self.music_volume_spin.setValue(int(self.settings.value("sound/music_volume", 100)))
        self.effects_volume_spin.setValue(int(self.settings.value("sound/effects_volume", 100)))
        sound_enabled = self.settings.value("sound/enabled", True)
        if isinstance(sound_enabled, str): sound_enabled = sound_enabled.lower() == "true"
        self.sound_enabled_check.setChecked(sound_enabled)

        # Load gameplay settings (unchanged)
        difficulty = self.settings.value("gameplay/difficulty", "Normal")
        for i in range(self.difficulty_combo.count()):
            if self.difficulty_combo.itemText(i) == difficulty:
                self.difficulty_combo.setCurrentIndex(i)
                break
        self.autosave_spin.setValue(int(self.settings.value("gameplay/autosave_interval", 0)))
        tutorial_enabled = self.settings.value("gameplay/tutorial_enabled", True)
        if isinstance(tutorial_enabled, str): tutorial_enabled = tutorial_enabled.lower() == "true"
        self.tutorial_check.setChecked(tutorial_enabled)

        # Load style settings
        if hasattr(self, 'style_tab'):
            self.style_tab._load_settings() 

        if hasattr(self, 'background_tab'):
             self.background_tab.load_settings(self.settings)

    def _setup_style_tab(self):
        """Set up the style settings tab."""
        # Create style tab
        self.style_tab = StyleTab()

        # Add style tab to tab widget
        self.tab_widget.addTab(self.style_tab, "Style")


    def _setup_background_tab(self):
        """Set up the background selection tab."""
        # Create background tab
        self.background_tab = BackgroundTab()

        # Connect the preview signal from the tab to this dialog's signal
        self.background_tab.preview_background_changed.connect(self.background_preview_requested)

        # Add background tab to tab widget
        self.tab_widget.addTab(self.background_tab, "Background")

    def _save_settings(self):
        """Save settings from the UI to QSettings."""
        # Save window state
        window_state_str = "windowed" # Default
        if self.fullscreen_radio.isChecked():
            window_state_str = "fullscreen"
        elif self.windowed_fullscreen_radio.isChecked():
            window_state_str = "maximized" # Use 'maximized' internally
        self.settings.setValue("display/window_state", window_state_str)

        # Save windowed resolution *only* if windowed mode is selected
        if window_state_str == "windowed":
            selected_resolution = self.resolution_combo.currentData()
            if isinstance(selected_resolution, QSize): # Store QSize directly if possible
                self.settings.setValue("display/windowed_size", selected_resolution)
            else: # Fallback to storing tuple if currentData wasn't QSize
                resolution_text = self.resolution_combo.currentText()
                try:
                    w, h = map(int, resolution_text.split('x'))
                    self.settings.setValue("display/windowed_size", (w, h))
                except ValueError:
                    logging.error(f"Could not parse resolution text '{resolution_text}' during save.")
                    # Optionally save a default or skip saving resolution

        # Save UI scale (unchanged)
        self.settings.setValue("display/ui_scale", self.ui_scale_combo.currentData())

        # Save text speed setting (unchanged)
        self.settings.setValue("display/text_speed_delay", self.text_speed_slider.value())

        # Save sound settings (unchanged)
        self.settings.setValue("sound/master_volume", self.master_volume_spin.value())
        self.settings.setValue("sound/music_volume", self.music_volume_spin.value())
        self.settings.setValue("sound/effects_volume", self.effects_volume_spin.value())
        self.settings.setValue("sound/enabled", self.sound_enabled_check.isChecked())

        # Save gameplay settings (unchanged)
        self.settings.setValue("gameplay/difficulty", self.difficulty_combo.currentText())
        self.settings.setValue("gameplay/autosave_interval", self.autosave_spin.value())
        self.settings.setValue("gameplay/tutorial_enabled", self.tutorial_check.isChecked())

        # Save style settings (unchanged)
        if hasattr(self, 'style_tab'):
            self.style_tab.save_settings()

        # Save background settings (unchanged)
        if hasattr(self, 'background_tab'):
            self.background_tab.save_settings(self.settings)

        # Sync settings to disk
        self.settings.sync()

        # Emit signal
        self.settings_saved.emit()

        # Close dialog
        self.accept()

    @staticmethod
    def get_settings():
        """Get the current settings.

        Returns:
            Dict[str, Any]: The current settings.
        """
        settings = QSettings("RPGGame", "Settings")
        # ... (rest of the method implementation) ...

        # Helper to convert loaded QSize to tuple if needed
        def size_to_tuple(size_val):
            if isinstance(size_val, QSize):
                return (size_val.width(), size_val.height())
            # Handle tuple/list potentially saved previously
            elif isinstance(size_val, (tuple, list)) and len(size_val) == 2:
                return tuple(size_val)
            # Handle string format
            elif isinstance(size_val, str):
                try:
                    parts = size_val.strip('()').split(',')
                    return (int(parts[0]), int(parts[1]))
                except Exception:
                    return (1280, 720) # Fallback
            return (1280, 720) # Default fallback

        return {
            "display": {
                "window_state": settings.value("display/window_state", "windowed"),
                "windowed_size": size_to_tuple(settings.value("display/windowed_size", QSize(1280, 720))), # Get saved windowed size
                "ui_scale": settings.value("display/ui_scale", 1.0),
                "text_speed_delay": settings.value("display/text_speed_delay", 30, int)
            },
            "sound": {
                "master_volume": settings.value("sound/master_volume", 100),
                "music_volume": settings.value("sound/music_volume", 100),
                "effects_volume": settings.value("sound/effects_volume", 100),
                "enabled": settings.value("sound/enabled", True)
            },
            "gameplay": {
                "difficulty": settings.value("gameplay/difficulty", "Normal"),
                "autosave_interval": settings.value("gameplay/autosave_interval", 0),
                "tutorial_enabled": settings.value("gameplay/tutorial_enabled", True)
            },
            "style": {
                "output_bg_color": settings.value("style/output_bg_color", "#D2B48C"),
                "system_msg_color": settings.value("style/system_msg_color", "#FF0000"),
                "font_family": settings.value("style/font_family", "Garamond"),
                "font_size": settings.value("style/font_size", 14),
                "font_color": settings.value("style/font_color", "#000000"),
                "user_input_font_family": settings.value("style/user_input_font_family", "Garamond"),
                "user_input_font_size": settings.value("style/user_input_font_size", 14),
                "user_input_font_color": settings.value("style/user_input_font_color", "#0d47a1"),
                "background_filename": settings.value("style/background_filename", None), # Load filename string
                "texture_name": settings.value("style/texture_name", "subtle_noise"),
                "output_opacity": settings.value("style/output_opacity", 100, int),
                "input_opacity": settings.value("style/input_opacity", 100, int)
            }
        }
```

### File: ..\gui\dialogs\settings\style_tab.py

```python
#!/usr/bin/env python3
"""
Style settings tab for the RPG game GUI.
This module provides a tab for configuring UI style settings.
"""

import os
import logging
from typing import Dict, Any

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, 
    QPushButton, QFormLayout, QGroupBox, QRadioButton, 
    QButtonGroup, QColorDialog, QFontDialog, QGridLayout,
    QFrame, QSlider
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize
from PySide6.QtGui import QFont, QColor, QPixmap, QIcon

class StyleTab(QWidget):
    """Tab for configuring UI style settings."""
    
    def __init__(self, parent=None):
        """Initialize the style tab."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
        
        # Load settings
        self._load_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create main layout
        layout = QVBoxLayout(self)
        
        # Create form layout for settings
        form_layout = QFormLayout()
        
        # Output area background color
        self.output_bg_group = QGroupBox("Output Area Background")
        self.output_bg_layout = QVBoxLayout(self.output_bg_group)
        
        # Predefined colors
        self.predefined_colors_layout = QGridLayout()
        self.predefined_colors_layout.setSpacing(5)
        
        # Add predefined color options
        self.color_buttons = {}
        predefined_colors = [
            ("Light Brown", "#D2B48C"),
            ("Dark Brown", "#8B4513"),
            ("Beige", "#F5F5DC"),
            ("Cream", "#FFFDD0"),
            ("Tan", "#D2B48C"),
            ("Ivory", "#FFFFF0"),
            ("Light Gray", "#D3D3D3"),
            ("Light Blue", "#ADD8E6"),
            ("Light Green", "#90EE90"),
            ("Light Red", "#FFCCCB"),
        ]
        
        # Create a button group for color selection
        self.bg_color_group = QButtonGroup(self)
        self.bg_color_group.setExclusive(True)
        
        # Add color buttons to grid
        row, col = 0, 0
        for i, (color_name, color_hex) in enumerate(predefined_colors):
            button = QRadioButton(color_name)
            # Set a background color style for the button
            button.setStyleSheet(f"QRadioButton {{ background-color: {color_hex}; padding: 5px; border-radius: 3px; }}")
            button.setProperty("color_hex", color_hex)
            
            self.predefined_colors_layout.addWidget(button, row, col)
            self.color_buttons[color_name] = button
            self.bg_color_group.addButton(button)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Custom color picker
        self.custom_color_layout = QHBoxLayout()
        self.custom_color_radio = QRadioButton("Custom:")
        self.bg_color_group.addButton(self.custom_color_radio)
        
        self.custom_color_button = QPushButton("Choose...")
        self.custom_color_button.clicked.connect(self._choose_custom_bg_color)
        
        self.custom_color_preview = QFrame()
        self.custom_color_preview.setFixedSize(20, 20)
        self.custom_color_preview.setFrameShape(QFrame.StyledPanel)
        self.custom_color_preview.setStyleSheet("background-color: #D2B48C; border: 1px solid gray;")
        
        self.custom_color_layout.addWidget(self.custom_color_radio)
        self.custom_color_layout.addWidget(self.custom_color_button)
        self.custom_color_layout.addWidget(self.custom_color_preview)
        self.custom_color_layout.addStretch()
        
        # Add layouts to output bg group
        self.output_bg_layout.addLayout(self.predefined_colors_layout)
        self.output_bg_layout.addLayout(self.custom_color_layout)
        
        # System message color
        self.system_msg_group = QGroupBox("System Message Color")
        self.system_msg_layout = QVBoxLayout(self.system_msg_group)
        
        # Predefined system colors
        self.sys_colors_layout = QGridLayout()
        self.sys_colors_layout.setSpacing(5)
        
        # Add predefined system color options
        self.sys_color_buttons = {}
        predefined_sys_colors = [
            ("Red", "#FF0000"),
            ("Orange", "#FFA500"),
            ("Yellow", "#FFFF00"),
            ("Green", "#00FF00"),
            ("Blue", "#0000FF"),
            ("Purple", "#800080"),
            ("Pink", "#FFC0CB"),
            ("Black", "#000000"),
        ]
        
        # Create a button group for system color selection
        self.sys_color_group = QButtonGroup(self)
        self.sys_color_group.setExclusive(True)
        
        # Add system color buttons to grid
        row, col = 0, 0
        for i, (color_name, color_hex) in enumerate(predefined_sys_colors):
            button = QRadioButton(color_name)
            # Set a foreground color style for the button
            button.setStyleSheet(f"QRadioButton {{ color: {color_hex}; font-weight: bold; }}")
            button.setProperty("color_hex", color_hex)
            
            self.sys_colors_layout.addWidget(button, row, col)
            self.sys_color_buttons[color_name] = button
            self.sys_color_group.addButton(button)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Custom system color picker
        self.custom_sys_color_layout = QHBoxLayout()
        self.custom_sys_color_radio = QRadioButton("Custom:")
        self.sys_color_group.addButton(self.custom_sys_color_radio)
        
        self.custom_sys_color_button = QPushButton("Choose...")
        self.custom_sys_color_button.clicked.connect(self._choose_custom_sys_color)
        
        self.custom_sys_color_preview = QFrame()
        self.custom_sys_color_preview.setFixedSize(20, 20)
        self.custom_sys_color_preview.setFrameShape(QFrame.StyledPanel)
        self.custom_sys_color_preview.setStyleSheet("background-color: #FF0000; border: 1px solid gray;")
        
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_radio)
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_button)
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_preview)
        self.custom_sys_color_layout.addStretch()
        
        # Add layouts to system msg group
        self.system_msg_layout.addLayout(self.sys_colors_layout)
        self.system_msg_layout.addLayout(self.custom_sys_color_layout)
        
        # Output Text Font settings
        self.font_group = QGroupBox("Output Text Font")
        self.font_layout = QVBoxLayout(self.font_group)
        
        self.font_button = QPushButton("Choose Font...")
        self.font_button.clicked.connect(self._choose_font)
        
        self.font_preview = QLabel("AaBbCcDdEe 12345")
        self.font_preview.setAlignment(Qt.AlignCenter)
        self.font_preview.setFrameShape(QFrame.StyledPanel)
        self.font_preview.setMinimumHeight(40)
        
        self.font_layout.addWidget(self.font_button)
        self.font_layout.addWidget(self.font_preview)
        
        # Font color
        self.font_color_layout = QHBoxLayout()
        self.font_color_label = QLabel("Font Color:")
        self.font_color_button = QPushButton("Choose...")
        self.font_color_button.clicked.connect(self._choose_font_color)
        
        self.font_color_preview = QFrame()
        self.font_color_preview.setFixedSize(20, 20)
        self.font_color_preview.setFrameShape(QFrame.StyledPanel)
        self.font_color_preview.setStyleSheet("background-color: #000000; border: 1px solid gray;")
        
        self.font_color_layout.addWidget(self.font_color_label)
        self.font_color_layout.addWidget(self.font_color_button)
        self.font_color_layout.addWidget(self.font_color_preview)
        self.font_color_layout.addStretch()
        
        self.font_layout.addLayout(self.font_color_layout)
        
        # User Input Text Font settings
        self.user_input_font_group = QGroupBox("User Input Text Font")
        self.user_input_font_layout = QVBoxLayout(self.user_input_font_group)
        
        self.user_input_font_button = QPushButton("Choose Font...")
        self.user_input_font_button.clicked.connect(self._choose_user_input_font)
        
        self.user_input_font_preview = QLabel("AaBbCcDdEe 12345")
        self.user_input_font_preview.setAlignment(Qt.AlignCenter)
        self.user_input_font_preview.setFrameShape(QFrame.StyledPanel)
        self.user_input_font_preview.setMinimumHeight(40)
        
        self.user_input_font_layout.addWidget(self.user_input_font_button)
        self.user_input_font_layout.addWidget(self.user_input_font_preview)
        
        # User input font color
        self.user_input_font_color_layout = QHBoxLayout()
        self.user_input_font_color_label = QLabel("Font Color:")
        self.user_input_font_color_button = QPushButton("Choose...")
        self.user_input_font_color_button.clicked.connect(self._choose_user_input_font_color)
        
        self.user_input_font_color_preview = QFrame()
        self.user_input_font_color_preview.setFixedSize(20, 20)
        self.user_input_font_color_preview.setFrameShape(QFrame.StyledPanel)
        self.user_input_font_color_preview.setStyleSheet("background-color: #0d47a1; border: 1px solid gray;")
        
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_label)
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_button)
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_preview)
        self.user_input_font_color_layout.addStretch()
        
        self.user_input_font_layout.addLayout(self.user_input_font_color_layout)
        
        # Add all settings to the form layout
        layout.addWidget(self.output_bg_group)
        layout.addWidget(self.system_msg_group)
        layout.addWidget(self.font_group)
        layout.addWidget(self.user_input_font_group)
        
        # Add texture and transparency settings
        self._setup_texture_settings(layout)
        self._setup_transparency_settings(layout)
        
        layout.addStretch()
    
    def _setup_texture_settings(self, parent_layout):
        """Set up texture settings."""
        # Create a group box for texture settings
        self.texture_group = QGroupBox("Background Texture")
        texture_layout = QVBoxLayout(self.texture_group)
        
        # Create radio buttons for texture selection
        self.texture_radio_group = QButtonGroup(self)
        self.texture_radio_group.setExclusive(True)
        
        # Define available textures
        textures = [
            ("None", "none"),
            ("Subtle Noise", "subtle_noise"),
            ("Parchment", "parchment"),
            ("Leather", "leather"),
            ("Stone", "stone")
        ]
        
        # Create a grid layout for texture options
        texture_grid = QGridLayout()
        texture_grid.setSpacing(10)
        
        # Create radio buttons for each texture
        self.texture_buttons = {}
        row, col = 0, 0
        for i, (display_name, texture_name) in enumerate(textures):
            button = QRadioButton(display_name)
            button.setProperty("texture_name", texture_name)
            self.texture_buttons[texture_name] = button
            self.texture_radio_group.addButton(button)
            
            texture_grid.addWidget(button, row, col)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Add grid to layout
        texture_layout.addLayout(texture_grid)
        
        # Add group to parent layout
        parent_layout.addWidget(self.texture_group)
    
    def _setup_transparency_settings(self, parent_layout):
        """Set up transparency settings."""
        # Create group box
        self.transparency_group = QGroupBox("Transparency Settings")
        transparency_layout = QFormLayout(self.transparency_group)
        
        # Create output transparency slider
        self.output_transparency_slider = QSlider(Qt.Horizontal)
        self.output_transparency_slider.setRange(0, 100)
        self.output_transparency_slider.setValue(100)  # Default to fully opaque
        self.output_transparency_slider.setTickPosition(QSlider.TicksBelow)
        self.output_transparency_slider.setTickInterval(10)
        
        # Create input transparency slider
        self.input_transparency_slider = QSlider(Qt.Horizontal)
        self.input_transparency_slider.setRange(0, 100)
        self.input_transparency_slider.setValue(100)  # Default to fully opaque
        self.input_transparency_slider.setTickPosition(QSlider.TicksBelow)
        self.input_transparency_slider.setTickInterval(10)
        
        # Add sliders to layout
        transparency_layout.addRow("Output Area Opacity:", self.output_transparency_slider)
        transparency_layout.addRow("Command Input Opacity:", self.input_transparency_slider)
        
        # Add value labels
        self.output_transparency_value = QLabel("100%")
        self.input_transparency_value = QLabel("100%")
        
        transparency_layout.addRow("", self.output_transparency_value)
        transparency_layout.addRow("", self.input_transparency_value)
        
        # Connect sliders to update value labels
        self.output_transparency_slider.valueChanged.connect(
            lambda v: self.output_transparency_value.setText(f"{v}%")
        )
        self.input_transparency_slider.valueChanged.connect(
            lambda v: self.input_transparency_value.setText(f"{v}%")
        )
        
        # Add group to parent layout
        parent_layout.addWidget(self.transparency_group)
    
    def _choose_custom_bg_color(self):
        """Open color dialog for custom background color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/output_bg_color", "#D2B48C"))
        
        color = QColorDialog.getColor(current_color, self, "Select Background Color")
        if color.isValid():
            # Update preview
            self.custom_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Select custom radio button
            self.custom_color_radio.setChecked(True)
            # Store color hex
            self.custom_color_radio.setProperty("color_hex", color.name())
    
    def _choose_custom_sys_color(self):
        """Open color dialog for custom system message color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/system_msg_color", "#FF0000"))
        
        color = QColorDialog.getColor(current_color, self, "Select System Message Color")
        if color.isValid():
            # Update preview
            self.custom_sys_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Select custom radio button
            self.custom_sys_color_radio.setChecked(True)
            # Store color hex
            self.custom_sys_color_radio.setProperty("color_hex", color.name())
    
    def _choose_font(self):
        """Open font dialog."""
        settings = QSettings("RPGGame", "Settings")
        current_font = QFont()
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        current_font.setFamily(font_family)
        current_font.setPointSize(font_size)
        
        ok, font = QFontDialog.getFont(current_font, self, "Select Font")
        if ok:
            # Update preview
            self.font_preview.setFont(font)
            # Store font
            self.font_preview.setProperty("selected_font", font)
    
    def _choose_user_input_font(self):
        """Open font dialog for user input text."""
        settings = QSettings("RPGGame", "Settings")
        current_font = QFont()
        font_family = settings.value("style/user_input_font_family", "Garamond")
        font_size = int(settings.value("style/user_input_font_size", 14))
        current_font.setFamily(font_family)
        current_font.setPointSize(font_size)
        
        ok, font = QFontDialog.getFont(current_font, self, "Select User Input Font")
        if ok:
            # Update preview
            self.user_input_font_preview.setFont(font)
            # Store font
            self.user_input_font_preview.setProperty("selected_font", font)
    
    def _choose_user_input_font_color(self):
        """Open color dialog for user input font color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/user_input_font_color", "#0d47a1"))
        
        color = QColorDialog.getColor(current_color, self, "Select User Input Font Color")
        if color.isValid():
            # Update preview
            self.user_input_font_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Update font preview
            self.user_input_font_preview.setStyleSheet(f"color: {color.name()};")
            # Store color
            self.user_input_font_color_preview.setProperty("color_hex", color.name())
    
    def _choose_font_color(self):
        """Open color dialog for font color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/font_color", "#000000"))
        
        color = QColorDialog.getColor(current_color, self, "Select Font Color")
        if color.isValid():
            # Update preview
            self.font_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Update font preview
            self.font_preview.setStyleSheet(f"color: {color.name()};")
            # Store color
            self.font_color_preview.setProperty("color_hex", color.name())
    
    def _load_settings(self):
        """Load settings from QSettings to the UI."""
        settings = QSettings("RPGGame", "Settings")
        
        # Load output background color
        bg_color = settings.value("style/output_bg_color", "#D2B48C")
        
        # Check if it's one of the predefined colors
        found_predefined = False
        for button in self.color_buttons.values():
            if button.property("color_hex") == bg_color:
                button.setChecked(True)
                found_predefined = True
                break
        
        # If not found, use custom color
        if not found_predefined:
            self.custom_color_radio.setChecked(True)
            self.custom_color_preview.setStyleSheet(f"background-color: {bg_color}; border: 1px solid gray;")
            self.custom_color_radio.setProperty("color_hex", bg_color)
        
        # Load system message color
        sys_color = settings.value("style/system_msg_color", "#FF0000")
        
        # Check if it's one of the predefined colors
        found_predefined = False
        for button in self.sys_color_buttons.values():
            if button.property("color_hex") == sys_color:
                button.setChecked(True)
                found_predefined = True
                break
        
        # If not found, use custom color
        if not found_predefined:
            self.custom_sys_color_radio.setChecked(True)
            self.custom_sys_color_preview.setStyleSheet(f"background-color: {sys_color}; border: 1px solid gray;")
            self.custom_sys_color_radio.setProperty("color_hex", sys_color)
        
        # Load output font settings
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        font = QFont(font_family, font_size)
        self.font_preview.setFont(font)
        self.font_preview.setProperty("selected_font", font)
        
        # Load output font color
        font_color = settings.value("style/font_color", "#000000")
        self.font_color_preview.setStyleSheet(f"background-color: {font_color}; border: 1px solid gray;")
        self.font_preview.setStyleSheet(f"color: {font_color};")
        self.font_color_preview.setProperty("color_hex", font_color)
        
        # Load user input font settings
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font = QFont(user_input_font_family, user_input_font_size)
        self.user_input_font_preview.setFont(user_input_font)
        self.user_input_font_preview.setProperty("selected_font", user_input_font)
        
        # Load user input font color
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")
        self.user_input_font_color_preview.setStyleSheet(f"background-color: {user_input_font_color}; border: 1px solid gray;")
        self.user_input_font_preview.setStyleSheet(f"color: {user_input_font_color};")
        self.user_input_font_color_preview.setProperty("color_hex", user_input_font_color)
        
        # Load texture setting
        texture_name = settings.value("style/texture_name", "subtle_noise")
        if texture_name in self.texture_buttons:
            self.texture_buttons[texture_name].setChecked(True)
        else:
            # Default to subtle noise
            self.texture_buttons["subtle_noise"].setChecked(True)
        
        # Load transparency settings
        output_opacity = int(settings.value("style/output_opacity", 100))
        input_opacity = int(settings.value("style/input_opacity", 100))
        
        self.output_transparency_slider.setValue(output_opacity)
        self.input_transparency_slider.setValue(input_opacity)
        self.output_transparency_value.setText(f"{output_opacity}%")
        self.input_transparency_value.setText(f"{input_opacity}%")
    
    def save_settings(self):
        """Save settings from the UI to QSettings."""
        settings = QSettings("RPGGame", "Settings")
        
        # Save output background color
        if self.custom_color_radio.isChecked():
            bg_color = self.custom_color_radio.property("color_hex")
        else:
            # Get selected button
            for button in self.color_buttons.values():
                if button.isChecked():
                    bg_color = button.property("color_hex")
                    break
            else:
                # Default if none selected
                bg_color = "#D2B48C"
        
        settings.setValue("style/output_bg_color", bg_color)
        
        # Save system message color
        if self.custom_sys_color_radio.isChecked():
            sys_color = self.custom_sys_color_radio.property("color_hex")
        else:
            # Get selected button
            for button in self.sys_color_buttons.values():
                if button.isChecked():
                    sys_color = button.property("color_hex")
                    break
            else:
                # Default if none selected
                sys_color = "#FF0000"
        
        settings.setValue("style/system_msg_color", sys_color)
        
        # Save output font settings
        font = self.font_preview.property("selected_font")
        if font:
            settings.setValue("style/font_family", font.family())
            settings.setValue("style/font_size", font.pointSize())
        
        # Save output font color
        font_color = self.font_color_preview.property("color_hex")
        if font_color:
            settings.setValue("style/font_color", font_color)
            
        # Save user input font settings
        user_input_font = self.user_input_font_preview.property("selected_font")
        if user_input_font:
            settings.setValue("style/user_input_font_family", user_input_font.family())
            settings.setValue("style/user_input_font_size", user_input_font.pointSize())
        
        # Save user input font color
        user_input_font_color = self.user_input_font_color_preview.property("color_hex")
        if user_input_font_color:
            settings.setValue("style/user_input_font_color", user_input_font_color)
        
        # Save texture setting
        for button in self.texture_buttons.values():
            if button.isChecked():
                texture_name = button.property("texture_name")
                settings.setValue("style/texture_name", texture_name)
                break
        
        # Save transparency settings
        output_opacity = self.output_transparency_slider.value()
        input_opacity = self.input_transparency_slider.value()
        
        settings.setValue("style/output_opacity", output_opacity)
        settings.setValue("style/input_opacity", input_opacity)

```

### File: ..\gui\dialogs\__init__.py

```python
"""
Dialog modules for the RPG game GUI.
This package provides various dialog windows for the game.
"""

```

### File: ..\gui\dialogs\base_dialog.py

```python
#gui/dialogs/base_dialog.py
from PySide6.QtWidgets import QDialog
from PySide6.QtCore import QSize
from PySide6.QtGui import QScreen # Correct import for QScreen

class BaseDialog(QDialog):
    """Base class for dialogs to enforce maximum size constraints."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Common dialog settings can go here if needed

    def showEvent(self, event):
        """Override showEvent to adjust maximum size safely."""
        # Let the default showEvent run first to ensure widgets are likely created
        super().showEvent(event)

        # Check if the dialog has already been adjusted in this show cycle
        # Use a flag that persists across show calls within a single instance lifecycle if needed,
        # but for maximum size constraint, checking per show is fine.
        # Let's rename the flag for clarity.
        if hasattr(self, '_constrained_to_screen') and self._constrained_to_screen:
             return

        try:
            screen = self.screen() # Get the screen the dialog is *currently* on
            if screen:
                available_geo = screen.availableGeometry()

                # Calculate max size (e.g., 95% of available space)
                max_w = int(available_geo.width() * 0.95)
                max_h = int(available_geo.height() * 0.95)

                # Only set maximum size if it's reasonable (avoid tiny max sizes)
                if max_w > 100 and max_h > 100:
                    self.setMaximumSize(max_w, max_h)
                else:
                    logger.warning(f"Calculated maximum size ({max_w}x{max_h}) is too small. Skipping setMaximumSize.")

                # Check current size against the calculated maximum
                current_w = self.width()
                current_h = self.height()

                # Calculate the ideal size based on content, but capped by max size
                hint_w = self.sizeHint().width()
                hint_h = self.sizeHint().height()
                ideal_w = min(max(current_w, hint_w), max_w) # Use size hint but respect current size if larger
                ideal_h = min(max(current_h, hint_h), max_h)

                # Resize *only* if the current size exceeds the calculated max size
                resize_needed = False
                if current_w > max_w:
                    current_w = max_w
                    resize_needed = True
                if current_h > max_h:
                    current_h = max_h
                    resize_needed = True

                if resize_needed:
                     logger.info(f"Dialog '{self.windowTitle()}' exceeds screen bounds. Resizing to fit ({current_w}x{current_h}).")
                     self.resize(current_w, current_h) # Resize down to max limits

            else:
                 logger.warning(f"Could not get screen for dialog '{self.windowTitle()}' during showEvent.")

            # Mark as constrained for this show event
            self._constrained_to_screen = True

        except Exception as e:
            logger.error(f"Error adjusting dialog size in BaseDialog.showEvent for '{self.windowTitle()}': {e}", exc_info=True)
            # Ensure the flag is set even on error to prevent repeated attempts
            self._constrained_to_screen = True


    def exec(self):
         """Override exec to ensure size adjustment flag is reset before showing."""
         # Reset the flag before showing modally
         self._constrained_to_screen = False
         # Let the default exec handle showing the dialog, which will trigger our showEvent
         return super().exec()

    def open(self):
        """Override open to ensure size adjustment flag is reset before showing."""
         # Reset the flag before showing modelessly
        self._constrained_to_screen = False
         # Let the default open handle showing the dialog, which will trigger our showEvent
        return super().open()
```

### File: ..\gui\dialogs\character_creation_dialog.py

```python
#!/usr/bin/env python3
"""
Enhanced character creation dialog with Origin selection and stat allocation for the RPG game GUI.
"""

import os
import json
import logging
from typing import Dict, Optional, Any, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QComboBox,
    QPushButton, QGroupBox, QTextEdit, QTabWidget, QWidget, QMessageBox,
    QCheckBox, QFormLayout
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QPixmap, QIcon

from gui.dialogs.new_game_dialog import NewGameDialog
from gui.components.stat_allocation_widget import StatAllocationWidget
from core.stats.stats_manager import StatsManager
from core.utils.logging_config import get_logger
from core.agents.narrator import get_narrator_agent 
from core.agents.base_agent import AgentContext 
from core.base.config import get_config 

logger = get_logger("GUI")

class CharacterCreationDialog(NewGameDialog):
    """Extended dialog for creating a new game character with Origin selection and stat allocation."""

    def __init__(self, parent=None):
        """Initialize the character creation dialog."""
        # We call QDialog's init directly as we heavily override the UI from NewGameDialog
        QDialog.__init__(self, parent)

        # Set window properties from NewGameDialog if desired
        self.setWindowTitle("Create New Character")
        self.setMinimumWidth(800)
        # --- MODIFICATION: Reduced height ---
        self.setMinimumHeight(550) # Adjusted height (was 650)
        # --- END MODIFICATION ---
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
                padding-top: 3px;
            }
            QLineEdit, QTextEdit, QComboBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 10px 0 10px;
                color: #E0E0E0;
            }
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #333333;
                border-radius: 5px;
            }
            QTabBar::tab {
                background-color: #444444;
                color: #CCCCCC;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 10px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #333333;
                color: #E0E0E0;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            #OriginDetailsLabel {
                color: #CCCCCC;
                padding-left: 5px;
                padding-top: 0px;
            }
        """)

        # Load data dynamically
        self.available_races = self._load_races()
        self.available_classes = self._load_classes()
        self.available_origins = self._load_origins() # Load origins
        self.available_sexes = ["Male", "Female", "Other"]

        # Initialize other state variables BEFORE UI setup that might use them
        self.llm_enabled = True
        self.selected_icon_path = None
        self.selected_origin_data = None
        self._last_generated_params = None

        # Initialize character icons list BEFORE UI setup
        self.character_icons = []
        self.current_icon_index = 0

        # Create stats manager BEFORE UI setup (StatAllocationWidget needs it)
        self.stats_manager = StatsManager()

        # Set up the UI with tabs SECOND (this creates self.icon_label etc.)
        self._setup_ui_with_tabs()

        # Scan for icons and display the first one THIRD (now self.icon_label exists)
        # Initial scan based on default selections
        self.scan_character_icons(self.race_combo.currentText(), self.path_combo.currentText(), self.sex_combo.currentText())

        # Connect signals FOURTH
        self._connect_signals()

        # Update UI based on initial race/class FIFTH (important for stat allocation)
        self._update_race_class() # This also calls _show_stat_requirements_info

        self._on_origin_selected(self.origin_combo.currentIndex())

        # Initial validation LAST
        self._validate_form()

    def _setup_ui_with_tabs(self):
        """Set up the main UI using tabs."""
        # Main layout for the dialog
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(15, 15, 15, 15)
        dialog_layout.setSpacing(10)

        # Create tab widget
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget::pane { border: 1px solid #555555; background-color: #333333; border-radius: 5px; }
            QTabBar::tab { background-color: #444444; color: #CCCCCC; border: 1px solid #555555; border-bottom: none; border-top-left-radius: 4px; border-top-right-radius: 4px; padding: 6px 10px; margin-right: 2px; }
            QTabBar::tab:selected { background-color: #333333; color: #E0E0E0; }
        """)

        # --- Tab 1: Basic Info & Origin ---
        self.basic_info_tab = QWidget()
        basic_info_main_layout = QHBoxLayout(self.basic_info_tab)
        basic_info_main_layout.setSpacing(15)

        # Left Side: Character Info & Portrait
        left_basic_layout = QVBoxLayout()

        info_group = QGroupBox("Character Information")
        info_form_layout = QFormLayout(info_group)
        info_form_layout.setContentsMargins(15, 25, 15, 15)
        info_form_layout.setSpacing(8)

        # Create UI elements (Name, Race, Class, Origin Combo, Sex, LLM Checkbox)
        self.player_name_edit = QLineEdit()
        self.player_name_edit.setPlaceholderText("Enter your character's name...")
        info_form_layout.addRow("Name:", self.player_name_edit)

        self.race_combo = QComboBox()
        self._populate_combo(self.race_combo, self.available_races, "Races") # Populate basic combos early
        info_form_layout.addRow("Race:", self.race_combo)

        self.path_combo = QComboBox() # Represents Class
        self._populate_combo(self.path_combo, self.available_classes, "Classes") # Populate basic combos early
        info_form_layout.addRow("Class:", self.path_combo)

        self.origin_combo = QComboBox() # Create the combo, but DON'T populate yet
        info_form_layout.addRow("Origin:", self.origin_combo)

        self.sex_combo = QComboBox()
        self._populate_combo(self.sex_combo, self.available_sexes, "Sexes") # Populate basic combos early
        info_form_layout.addRow("Sex:", self.sex_combo)

        self.llm_checkbox = QCheckBox("Enable LLM (AI processing)")
        self.llm_checkbox.setChecked(self.llm_enabled)
        info_form_layout.addRow("", self.llm_checkbox)

        left_basic_layout.addWidget(info_group)

        # Portrait Section
        icon_group = QGroupBox("Character Portrait")
        icon_layout = QVBoxLayout(icon_group)
        icon_layout.setContentsMargins(15, 25, 15, 15)
        icon_layout.setSpacing(8)
        self.icon_label = QLabel() # Create icon label
        self.icon_label.setAlignment(Qt.AlignCenter)
        self.icon_label.setFixedSize(150, 150)
        self.icon_label.setStyleSheet("background-color: #1E1E1E; border: 1px solid #3F3F46;")
        self.icon_label.setText("No image")
        icon_layout.addWidget(self.icon_label, 0, Qt.AlignCenter)
        nav_layout = QHBoxLayout()
        self.prev_icon_button = QPushButton("←")
        self.icon_counter_label = QLabel("0 / 0") # Create counter label
        self.icon_counter_label.setAlignment(Qt.AlignCenter)
        self.next_icon_button = QPushButton("→")
        nav_layout.addWidget(self.prev_icon_button)
        nav_layout.addWidget(self.icon_counter_label)
        nav_layout.addWidget(self.next_icon_button)
        icon_layout.addLayout(nav_layout)
        portrait_hint = QLabel("Browse available portraits")
        portrait_hint.setStyleSheet("color: #888888; font-style: italic;")
        portrait_hint.setAlignment(Qt.AlignCenter)
        icon_layout.addWidget(portrait_hint)
        left_basic_layout.addWidget(icon_group)
        left_basic_layout.addStretch(1)

        # Right Side: Origin Details & Backstory Seed
        right_basic_layout = QVBoxLayout()

        origin_details_group = QGroupBox("Origin Details")
        origin_details_layout = QVBoxLayout(origin_details_group)
        origin_details_layout.setContentsMargins(15, 25, 15, 15)
        origin_details_layout.setSpacing(8)
        origin_details_layout.addWidget(QLabel("<b>Description:</b>"))
        self.origin_desc_label = QLabel("Select an Origin to see details.") # Create desc label
        self.origin_desc_label.setObjectName("OriginDetailsLabel")
        self.origin_desc_label.setWordWrap(True)
        self.origin_desc_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(self.origin_desc_label)
        origin_details_layout.addWidget(QLabel("<b>Skill Proficiencies:</b>"))
        self.origin_skills_label = QLabel("-") # Create skills label
        self.origin_skills_label.setObjectName("OriginDetailsLabel")
        self.origin_skills_label.setWordWrap(True)
        origin_details_layout.addWidget(self.origin_skills_label)
        origin_details_layout.addWidget(QLabel("<b>Origin Traits:</b>"))
        self.origin_traits_label = QLabel("-") # Create traits label
        self.origin_traits_label.setObjectName("OriginDetailsLabel")
        self.origin_traits_label.setWordWrap(True)
        self.origin_traits_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(self.origin_traits_label)
        origin_details_layout.addStretch()

        # Backstory Seed Group
        description_group = QGroupBox("Character Backstory (Seed)")
        description_layout = QVBoxLayout(description_group)
        description_layout.setContentsMargins(15, 25, 15, 15)
        description_layout.setSpacing(5)
        description_label = QLabel("Edit the text below (loaded from Origin) to guide LLM background generation:")
        description_label.setWordWrap(True)
        description_label.setStyleSheet("color: #AAAAAA; font-style: italic;")
        self.description_edit = QTextEdit() # Create text edit
        self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
        self.description_edit.setMinimumHeight(120)
        description_layout.addWidget(description_label)
        description_layout.addWidget(self.description_edit)

        # AI Buttons for Backstory
        ai_button_layout = QHBoxLayout()
        icon_path_improve = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "ai_improve.svg")
        self.improve_background_button = QPushButton()
        self.improve_background_button.setIcon(QIcon(icon_path_improve))
        self.improve_background_button.setIconSize(QSize(16, 16))
        self.improve_background_button.setToolTip("Improve Backstory Seed via AI")
        self.improve_background_button.setFixedSize(30, 30)

        icon_path_generate = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "ai_generate.svg")
        self.generate_background_button = QPushButton()
        self.generate_background_button.setIcon(QIcon(icon_path_generate))
        self.generate_background_button.setIconSize(QSize(16, 16))
        self.generate_background_button.setToolTip("Generate Backstory Seed via AI")
        self.generate_background_button.setFixedSize(30, 30)

        ai_button_layout.addStretch()
        ai_button_layout.addWidget(self.improve_background_button)
        ai_button_layout.addWidget(self.generate_background_button)
        description_layout.addLayout(ai_button_layout)

        right_basic_layout.addWidget(origin_details_group)
        right_basic_layout.addWidget(description_group)
        right_basic_layout.addStretch(1)

        basic_info_main_layout.addLayout(left_basic_layout, 1)
        basic_info_main_layout.addLayout(right_basic_layout, 2)

        # --- Tab 2: Stats --- (Will be added later by user)
        # self.stats_tab = QWidget()
        # ...

        # --- Tab 3: Stats (Renamed from Tab 2) ---
        self.stats_tab = QWidget() # Renamed variable for clarity, though index matters more
        stats_layout = QVBoxLayout(self.stats_tab)
        stats_layout.setSpacing(10)

        # Race/Class selectors
        race_class_selection_layout = QVBoxLayout()
        race_selector_layout = QHBoxLayout()
        race_selector_layout.setContentsMargins(0, 5, 0, 0); race_selector_layout.setSpacing(8)
        self.race_prev_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "left_arrow.svg")
        self.race_prev_button.setIcon(QIcon(icon_path))
        self.race_prev_button.setIconSize(QSize(16, 16)); self.race_prev_button.setFixedSize(24, 24)
        self.race_label = QLabel("Race") # Create race label
        self.race_label.setStyleSheet("color: #E0E0E0; font-weight: bold; font-size: 14px;"); self.race_label.setAlignment(Qt.AlignCenter)
        self.race_next_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "right_arrow.svg")
        self.race_next_button.setIcon(QIcon(icon_path))
        self.race_next_button.setIconSize(QSize(16, 16)); self.race_next_button.setFixedSize(24, 24)
        race_selector_layout.addWidget(self.race_prev_button); race_selector_layout.addWidget(self.race_label, 1); race_selector_layout.addWidget(self.race_next_button)
        race_class_selection_layout.addLayout(race_selector_layout)

        class_selector_layout = QHBoxLayout()
        class_selector_layout.setContentsMargins(0, 5, 0, 10); class_selector_layout.setSpacing(8)
        self.class_prev_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "left_arrow.svg")
        self.class_prev_button.setIcon(QIcon(icon_path))
        self.class_prev_button.setIconSize(QSize(16, 16)); self.class_prev_button.setFixedSize(24, 24)
        self.class_label = QLabel("Class") # Create class label
        self.class_label.setStyleSheet("color: #E0E0E0; font-weight: bold; font-size: 14px;"); self.class_label.setAlignment(Qt.AlignCenter)
        self.class_next_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "right_arrow.svg")
        self.class_next_button.setIcon(QIcon(icon_path))
        self.class_next_button.setIconSize(QSize(16, 16)); self.class_next_button.setFixedSize(24, 24)
        class_selector_layout.addWidget(self.class_prev_button); class_selector_layout.addWidget(self.class_label, 1); class_selector_layout.addWidget(self.class_next_button)
        race_class_selection_layout.addLayout(class_selector_layout)
        stats_layout.addLayout(race_class_selection_layout)

        # Stat Allocation Widget
        self.stat_allocation = StatAllocationWidget( # Create stat widget
            self.stats_manager,
            self.race_combo.currentText(),
            self.path_combo.currentText()
        )
        stats_layout.addWidget(self.stat_allocation)

        # Info Label for Stats Tab
        self.stat_info_label = QLabel() # Create stat info label
        self.stat_info_label.setWordWrap(True)
        self.stat_info_label.setStyleSheet("color: #E0E0E0; background-color: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px;")
        stats_layout.addWidget(self.stat_info_label)
        stats_layout.addStretch(1)

        # --- Tab 4: Background (Simplified) --- (Renamed from Tab 3)
        self.background_tab = QWidget()
        background_layout = QVBoxLayout(self.background_tab)
        # Maybe repurpose this tab later if needed
        background_layout.addWidget(QLabel("Review Character Summary (Optional Tab)"))
        background_layout.addStretch()

        # Add tabs to the tab widget
        self.tab_widget.addTab(self.basic_info_tab, "1. Basic Info & Origin")
        # --- MODIFICATION: Add placeholder for future Tab 2 ---
        # self.tab_widget.addTab(QWidget(), "2. Skills & Feats (TBD)") # Placeholder
        # --- END MODIFICATION ---
        # --- MODIFICATION: Renamed Stats Tab ---
        self.tab_widget.addTab(self.stats_tab, "3. Stats") # Renamed from "2. Stats"
        # --- END MODIFICATION ---
        # Connect tab changed signal
        self.tab_widget.currentChanged.connect(self._tab_changed)
        # self.tab_widget.addTab(self.background_tab, "4. Review (Optional)") # Renumbered

        dialog_layout.addWidget(self.tab_widget)

        # --- Navigation & Create Buttons ---
        bottom_button_layout = QHBoxLayout()
        self.prev_tab_button = QPushButton("< Previous")
        self.next_tab_button = QPushButton("Next >")
        self.cancel_button = QPushButton("Cancel")
        self.create_button = QPushButton("Create Character")
        self.start_game_button = QPushButton("Start Game")
        self.start_game_button.setStyleSheet("""
            QPushButton {
                background-color: #22863a;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2a9949;
            }
            QPushButton:pressed {
                background-color: #1e7e34;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
        """)
        self.start_game_button.hide()  # Initially hidden

        bottom_button_layout.addWidget(self.cancel_button)
        bottom_button_layout.addStretch()
        bottom_button_layout.addWidget(self.prev_tab_button)
        bottom_button_layout.addWidget(self.next_tab_button)
        bottom_button_layout.addWidget(self.create_button)
        # Initially hide the create button until needed
        self.create_button.hide()

        dialog_layout.addLayout(bottom_button_layout)

        # Initialize tab state
        self._tab_changed(0)

        # NOW populate the origin combo, as all widgets exist
        self._populate_origin_combo()

    def _populate_combo(self, combo: QComboBox, items: List[str], item_type: str):
        """Helper to populate QComboBox and handle empty lists."""
        combo.clear()
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItems(items)
            combo.setEnabled(True)

    def _populate_origin_combo(self):
        """
        Populate the Origin combo box, filtering based on selected Race and Class.
        """
        combo = self.origin_combo
        all_origins = self.available_origins # List of origin dicts
        item_type = "Origins"

        # Get current selections (ensure combo boxes exist first)
        selected_race = self.race_combo.currentText() if hasattr(self, 'race_combo') else None
        selected_class = self.path_combo.currentText() if hasattr(self, 'path_combo') else None

        previous_origin_id = combo.currentData()

        combo.blockSignals(True) 
        combo.clear()
        combo.addItem("--- Select an Origin ---", None) 

        if not all_origins:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
            combo.blockSignals(False)
            self._on_origin_selected(0) 
            return

        if not selected_race or not selected_class:
            combo.addItem("Select Race/Class first")
            combo.setEnabled(False)
            combo.blockSignals(False)
            self._on_origin_selected(0) 
            return

        # --- Filtering Logic ---
        suitable_origins = []
        for origin_data in all_origins:
            races_ok = True 
            if origin_data.get("suitable_races"): 
                races_ok = selected_race in origin_data["suitable_races"]

            classes_ok = True 
            if origin_data.get("suitable_classes"): 
                classes_ok = selected_class in origin_data["suitable_classes"]

            if races_ok and classes_ok:
                suitable_origins.append(origin_data)
        # --- End Filtering Logic ---

        if not suitable_origins:
            combo.addItem(f"No suitable {item_type} found")
            combo.setEnabled(False)
        else:
            reselect_index = 0 # Default to placeholder
            for index, origin_data in enumerate(suitable_origins):
                origin_id = origin_data.get('id')
                origin_name = origin_data.get('name', 'Unknown Origin')
                # Add item with name as text and id as data
                combo.addItem(origin_name, origin_id)
                # Check if this was the previously selected origin
                if origin_id == previous_origin_id:
                    reselect_index = index + 1

            combo.setEnabled(True)
            combo.setCurrentIndex(reselect_index)

        combo.blockSignals(False) # Re-enable signals
        self._on_origin_selected(combo.currentIndex())

    def _toggle_llm(self, state):
        """Toggle LLM enabled state."""
        self.llm_enabled = bool(state)
        # Enable/disable AI buttons based on LLM state
        self.improve_background_button.setEnabled(self.llm_enabled)
        self.generate_background_button.setEnabled(self.llm_enabled)

    # --- Data Loading --- (Keep as is)
    def _load_races(self) -> List[str]:
        races = []
        try:
            config = get_config()
            loaded_races_data = config.get_all("races")
            if loaded_races_data:
                race_names = sorted([data.get('name', race_id) for race_id, data in loaded_races_data.items()])
                if race_names: races = race_names
            if not races: logger.warning("Race config not found or empty.")
        except Exception as e: logger.error(f"Error loading races: {e}.")
        return races if races else ["Human"]

    def _load_classes(self) -> List[str]:
        classes = []
        try:
            config = get_config()
            loaded_classes_data = config.get_all("classes")
            if loaded_classes_data:
                class_names = sorted([data.get('name', class_id) for class_id, data in loaded_classes_data.items()])
                if class_names: classes = class_names
            if not classes: logger.warning("Class config not found or empty.")
        except Exception as e: logger.error(f"Error loading classes: {e}.")
        return classes if classes else ["Wanderer"]

    def _load_origins(self) -> List[Dict[str, Any]]:
        origins_data = []
        try:
            config = get_config()
            loaded_origins_dict = config.get_all("origins") # Load "origins" key
            if loaded_origins_dict and isinstance(loaded_origins_dict, dict):
                origins_data = list(loaded_origins_dict.values())
                origins_data.sort(key=lambda x: x.get('name', 'Unknown Origin'))
                logger.info(f"Loaded {len(origins_data)} origins from config.")
            else:
                logger.warning("Origin configuration domain ('origins') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading origins from config: {e}.")
        return origins_data

    # --- Icon Scanning & Filtering ---
    def scan_character_icons(self, race: str, class_name: str, sex: str):
        """
        Scan for character icons in the specific race/class directory
        and filter based on sex, looking for '_male' or '_female' in filenames.
        """
        self.character_icons = [] # Clear previous icons
        self.current_icon_index = 0

        if not race or not class_name or not sex or "No " in race or "No " in class_name:
            logger.warning(f"Cannot scan icons: Race ('{race}'), Class ('{class_name}'), or Sex ('{sex}') not validly selected.")
            self._display_current_icon()
            return

        try:
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            safe_race = race.replace(" ", "_")
            safe_class_name = class_name.replace(" ", "_")
            specific_icons_dir = os.path.join(project_root, "images", "character_icons", f"{safe_race}_{safe_class_name}")
            logger.debug(f"Scanning for icons in specific directory: {specific_icons_dir}")

            if not os.path.exists(specific_icons_dir):
                logger.warning(f"Icon directory not found: {specific_icons_dir}")
                self._display_current_icon()
                return

            supported_extensions = [".png", ".jpg", ".jpeg", ".gif", ".svg"]

            for filename in os.listdir(specific_icons_dir):
                if any(filename.lower().endswith(ext) for ext in supported_extensions):
                    name_part_lower = os.path.splitext(filename)[0].lower() # Filename without extension, lowercase
                    sex_lower = sex.lower()
                    include_file = False

                    # Check for specific substrings "_male" or "_female"
                    contains_male_tag = "_male" in name_part_lower
                    contains_female_tag = "_female" in name_part_lower

                    if sex_lower == "male":
                        if contains_male_tag: # Only include if it explicitly has "_male"
                            include_file = True
                    elif sex_lower == "female":
                        if contains_female_tag: # Only include if it explicitly has "_female"
                            include_file = True
                    elif sex_lower == "other":
                        # For "Other", include if either tag is present
                        if contains_male_tag or contains_female_tag:
                            include_file = True
                    
                    if include_file:
                        file_path = os.path.join(specific_icons_dir, filename)
                        self.character_icons.append({
                            "filename": filename,
                            "path": file_path
                        })

            self.character_icons.sort(key=lambda x: x["filename"])
            logger.info(f"Found {len(self.character_icons)} suitable icons in {specific_icons_dir} for sex '{sex}' (using _male/_female tags).")

        except OSError as e:
            logger.error(f"Error reading icons directory {specific_icons_dir}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error scanning icons: {e}", exc_info=True)

        self._display_current_icon()
        
    # --- Signal Connections ---
    def _connect_signals(self):
        """Connect signals to slots."""
        # Basic Info Tab
        self.player_name_edit.textChanged.connect(self._validate_form)
        self.race_combo.currentIndexChanged.connect(self._validate_form)
        self.race_combo.currentTextChanged.connect(self._update_race_class)
        self.race_combo.currentTextChanged.connect(self._populate_origin_combo) 
        self.path_combo.currentIndexChanged.connect(self._validate_form)
        self.path_combo.currentTextChanged.connect(self._update_race_class)
        self.path_combo.currentTextChanged.connect(self._populate_origin_combo) 

        # Only connect origin index change to validation and details update
        self.origin_combo.currentIndexChanged.connect(self._validate_form)
        self.origin_combo.currentIndexChanged.connect(self._on_origin_selected)

        self.sex_combo.currentIndexChanged.connect(self._validate_form)
        self.llm_checkbox.stateChanged.connect(self._toggle_llm)

        # Update icons when race, class, or sex changes
        self.race_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)
        self.path_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)
        self.sex_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)

        # Portrait
        self.prev_icon_button.clicked.connect(self._show_previous_icon)
        self.next_icon_button.clicked.connect(self._show_next_icon)

        # Stats Tab
        self.race_prev_button.clicked.connect(self._previous_race)
        self.race_next_button.clicked.connect(self._next_race)
        self.class_prev_button.clicked.connect(self._previous_class)
        self.class_next_button.clicked.connect(self._next_class)
        self.stat_allocation.stats_changed.connect(self._stats_changed)

        # Backstory Seed / AI Buttons
        self.improve_background_button.clicked.connect(self._improve_background)
        self.generate_background_button.clicked.connect(self._generate_background)

        # Dialog Buttons
        self.cancel_button.clicked.connect(self.reject)
        self.create_button.clicked.connect(self._finish_character_creation) # Connect create to finish method
        self.start_game_button.clicked.connect(self._start_new_game) # Start game button triggers special method
        self.prev_tab_button.clicked.connect(self._previous_tab)
        self.next_tab_button.clicked.connect(self._next_tab)
        
        # Set tooltips for the buttons
        self.create_button.setToolTip("Create your character and prepare to start the game")
        self.start_game_button.setToolTip("Begin your adventure with this character")
        self.cancel_button.setToolTip("Cancel character creation")

        # Connect race/class/origin/sex change to clear background generation context
        self.race_combo.currentTextChanged.connect(self._check_generated_context)
        self.path_combo.currentTextChanged.connect(self._check_generated_context)
        self.origin_combo.currentTextChanged.connect(self._check_generated_context) # Keep this check
        self.sex_combo.currentTextChanged.connect(self._check_generated_context)

        # Initial UI state update
        self._toggle_llm(self.llm_checkbox.isChecked()) # Set initial AI button state

        # Connect signals that affect AI button state
        self.player_name_edit.textChanged.connect(self._update_ai_button_state)
        self.stat_allocation.stats_changed.connect(self._update_ai_button_state)
        self.stat_allocation.allocation_complete.connect(self._update_ai_button_state)

        # Initial AI button state update
        self._update_ai_button_state()

    # --- Validation ---
    def _validate_form(self):
        """Validate the form and enable/disable the create button."""
        # This validation now applies mainly to the Create button state
        has_name = bool(self.player_name_edit.text().strip())
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0 # Check for valid origin index

        can_create = (
            has_name and
            race_selected and
            class_selected and
            origin_selected
        )

        # Get current tab
        current_tab_index = self.tab_widget.currentIndex()
        
        # Set Create button state if visible
        if self.create_button.isVisible():
            logger.debug(f"Setting create button enabled state to: {can_create}")
            self.create_button.setEnabled(can_create)
            if can_create:
                self.create_button.setToolTip("Create your character")
            else:
                self.create_button.setToolTip("Please complete all required fields")

        # Enable/disable next button based on basic info validity if on first tab
        if current_tab_index == 0:
            self.next_tab_button.setEnabled(can_create)
            if can_create:
                self.next_tab_button.setToolTip("Proceed to character stats")
            else:
                self.next_tab_button.setToolTip("Please complete all required fields before proceeding")
        else:
            self.next_tab_button.setEnabled(True) # Always enabled on other tabs (except last)


    # --- Icon Display --- (Keep as is)
    def _show_previous_icon(self):
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index - 1 + len(self.character_icons)) % len(self.character_icons)
        self._display_current_icon()

    def _show_next_icon(self):
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index + 1) % len(self.character_icons)
        self._display_current_icon()

    def _display_current_icon(self):
        if not self.character_icons:
            self.selected_icon_path = None
            self.icon_label.setText("No Icons Found")
            self.icon_counter_label.setText("0 / 0")
            return

        icon_info = self.character_icons[self.current_icon_index]
        icon_path = icon_info['path']
        self.icon_counter_label.setText(f"{self.current_icon_index + 1} / {len(self.character_icons)}")

        try:
            pixmap = QPixmap(icon_path)
            if not pixmap.isNull():
                pixmap = pixmap.scaled(self.icon_label.width(), self.icon_label.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.icon_label.setPixmap(pixmap)
                self.selected_icon_path = icon_path
            else:
                self.icon_label.setText("Load Error")
                self.selected_icon_path = None
        except Exception as e:
            logger.error(f"Error loading icon '{icon_path}': {e}")
            self.icon_label.setText("Load Error")
            self.selected_icon_path = None

    # --- Get Character Data ---
    def get_character_data(self) -> Optional[Dict[str, Any]]:
        """Get the final character data from all tabs."""
        # Validate basic info first
        if not self._validate_basic_info():
             QMessageBox.warning(self, "Incomplete Information", "Please complete the basic character information.")
             self.tab_widget.setCurrentIndex(0) # Go back to first tab
             return None

        # Retrieve basic info
        name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText()
        path = self.path_combo.currentText()
        origin_id = self.origin_combo.currentData() # Get the ID stored in data
        sex = self.sex_combo.currentText()

        # Basic validation again (should pass if Create button was enabled)
        if not name or not race or not path or origin_id is None:
             logger.error("Validation failed in get_character_data despite enabled button.")
             return None

        # Retrieve backstory seed text
        # Prioritize user edited text, fallback to origin intro text
        backstory_seed = self.description_edit.toPlainText().strip()
        if not backstory_seed and self.selected_origin_data:
            backstory_seed = self.selected_origin_data.get('introduction_text', '')

        # Retrieve final stats from allocation widget
        allocated_stats = self.stat_allocation.get_allocated_stats()
        if not allocated_stats:
            logger.error("Could not retrieve allocated stats.")
            QMessageBox.critical(self, "Stat Error", "Could not retrieve final stats. Please check the Stats tab.")
            self.tab_widget.setCurrentIndex(1) # Go to stats tab
            return None

        # Build the final data dictionary
        data = {
            'name': name,
            'race': race,
            'path': path,
            'origin_id': origin_id, # Use origin ID
            'sex': sex,
            'description': backstory_seed, # The seed text for LLM
            'use_llm': self.llm_enabled,
            'character_image': self.selected_icon_path,
            'stats': allocated_stats, # Include allocated base stats
            # Add starting items/location based on selected origin
            'starting_location_id': self.selected_origin_data.get('starting_location_id', '') if self.selected_origin_data else '',
            'starting_items': self.selected_origin_data.get('starting_items', []) if self.selected_origin_data else [],
            'initial_quests': self.selected_origin_data.get('initial_quests', []) if self.selected_origin_data else []
        }

        # --- Optional: Add compatibility fields if core engine expects them ---
        # This depends on how core/base/engine.py -> start_new_game is implemented
        # If it still expects individual base stats:
        # for stat_name, value in allocated_stats.items():
        #     data[f'base_{stat_name.lower()}'] = value
        # If it expects background name (use origin name as fallback):
        # data['background'] = self.origin_combo.currentText()
        # ---------------------------------------------------------------------

        logger.info(f"Character data collected: { {k:v for k,v in data.items() if k != 'stats'} }") # Log non-stat data
        logger.debug(f"Character stats: {data.get('stats')}")
        return data


    # --- Methods inherited or potentially modified from NewGameDialog ---
    # These might need adjustments based on the tabbed layout

    def _update_race_class(self, *args):
        """Update stat allocation and labels when race or class changes."""
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()

        if hasattr(self, 'race_label'): self.race_label.setText(race)
        if hasattr(self, 'class_label'): self.class_label.setText(class_name)

        if hasattr(self, 'stat_allocation'):
            self.stat_allocation.update_race_class(race, class_name)

        self._show_stat_requirements_info(race, class_name)
        self._validate_form() # Re-validate when race/class changes

    def _previous_race(self):
        current_index = self.race_combo.currentIndex()
        if current_index > 0:
            self.race_combo.setCurrentIndex(current_index - 1)

    def _next_race(self):
        current_index = self.race_combo.currentIndex()
        if current_index < self.race_combo.count() - 1:
            self.race_combo.setCurrentIndex(current_index + 1)

    def _previous_class(self):
        current_index = self.path_combo.currentIndex()
        if current_index > 0:
            self.path_combo.setCurrentIndex(current_index - 1)

    def _next_class(self):
        current_index = self.path_combo.currentIndex()
        if current_index < self.path_combo.count() - 1:
            self.path_combo.setCurrentIndex(current_index + 1)

    def _stats_changed(self, stats: Dict[str, Dict[str, int]]):
        """Handle stat changes from allocation widget."""
        self._validate_form() # Re-validate overall form
        self._update_ai_button_state()

    def _validate_for_ai_generation(self) -> bool:
        """Checks if conditions are met for enabling AI generation buttons."""
        has_name = bool(self.player_name_edit.text().strip())
        stats_allocated = hasattr(self, 'stat_allocation') and self.stat_allocation.are_points_fully_allocated()
        return has_name and stats_allocated

    def _update_ai_button_state(self):
        """Updates the enabled state and tooltip of AI buttons."""
        can_generate = self._validate_for_ai_generation()
        tooltip_text = ""

        if not can_generate:
            missing = []
            if not bool(self.player_name_edit.text().strip()):
                missing.append("Enter a character name")
            if not (hasattr(self, 'stat_allocation') and self.stat_allocation.are_points_fully_allocated()):
                remaining = self.stat_allocation.get_remaining_points() if hasattr(self, 'stat_allocation') else 'N/A'
                missing.append(f"Allocate all stat points ({remaining} remaining)")
            tooltip_text = "Cannot generate backstory:\n- " + "\n- ".join(missing)

        # Update Improve Button
        if hasattr(self, 'improve_background_button'):
            self.improve_background_button.setEnabled(can_generate)
            self.improve_background_button.setToolTip(tooltip_text if not can_generate else "Improve Backstory Seed via AI")

        # Update Generate Button
        if hasattr(self, 'generate_background_button'):
            self.generate_background_button.setEnabled(can_generate)
            self.generate_background_button.setToolTip(tooltip_text if not can_generate else "Generate Backstory Seed via AI")
    
    def _show_stat_requirements_info(self, race: str, class_name: str):
        """Display info about race/class modifiers and requirements."""
        if not hasattr(self, 'stat_allocation') or not hasattr(self, 'stat_info_label'):
            return

        modifier_info = self.stat_allocation.modifier_info
        if not modifier_info:
            self.stat_info_label.setText("Loading stat info...")
            return

        race_mods = modifier_info.race_modifiers
        class_mods = modifier_info.class_modifiers
        reqs = modifier_info.minimum_requirements
        recomm = modifier_info.recommended_stats

        info_text = f"<div style='font-weight: bold; font-size: 13px;'>{race} {class_name} Stat Info</div><hr>"

        def format_mods(mods_dict, color_pos, color_neg):
            if not mods_dict: return "None"
            parts = []
            for stat, mod in sorted(mods_dict.items()):
                if mod != 0:
                    color = color_pos if mod > 0 else color_neg
                    parts.append(f"<span style='color: {color}'>{stat} {mod:+d}</span>")
            return ", ".join(parts) if parts else "None"

        info_text += f"<div style='margin-bottom: 8px;'><b>Race Modifiers:</b> {format_mods(race_mods, '#4CAF50', '#F44336')}</div>"
        info_text += f"<div style='margin-bottom: 8px;'><b>Class Modifiers:</b> {format_mods(class_mods, '#2196F3', '#F44336')}</div>"

        req_text = ", ".join([f"{stat} {val}" for stat, val in sorted(reqs.items())]) if reqs else "None"
        info_text += f"<div style='margin-bottom: 8px;'><b>Minimum Requirements:</b> {req_text}</div>"

        recomm_prim = ", ".join(recomm.get('primary', [])) if recomm.get('primary') else "Balanced"
        info_text += f"<div><b>Recommended Primary:</b> {recomm_prim}</div>"

        self.stat_info_label.setText(info_text)

    @Slot()
    def _improve_background(self):
        if not self._validate_for_ai_generation(): return # Check validation first

        text = self.description_edit.toPlainText().strip()
        if not text:
            QMessageBox.warning(self, "No Text", "Please enter some background seed text first.")
            return

        detailed_context = self._get_detailed_context_for_llm()
        formatted_context = self._format_context_for_llm_prompt(detailed_context)

        prompt = (
            f"Improve the following background seed text for the character described below. "
            f"Make it an engaging character description focusing on personality, motivation, and appearance, "
            f"fitting the provided context. Do not narrate actions, just describe the character.\n\n"
            f"BACKGROUND SEED:\n{text}\n\n"
            f"{formatted_context}"
        )

        logger.debug(f"Sending improve background prompt:\n{prompt}") # Log the prompt

        # Call LLM
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={}, # Minimal state needed
            player_input=prompt, # Use the constructed prompt
            conversation_history=[], relevant_memories=[], additional_context={}
        )
        # Add error handling for LLM calls
        try:
            # Disable buttons during generation
            self.improve_background_button.setEnabled(False)
            self.generate_background_button.setEnabled(False)
            self.repaint() # Force UI update

            response = get_narrator_agent().process(ctx) # Assumes this function exists

            # Re-enable buttons
            self._update_ai_button_state()

            narrative_content = response.get("narrative") if response else None
            if narrative_content:
                self.description_edit.setPlainText(narrative_content.strip())
                # Update context tracking only AFTER successful generation
                self._last_generated_params = (
                    detailed_context.get('race',{}).get('name'),
                    detailed_context.get('class',{}).get('name'),
                    detailed_context.get('origin',{}).get('name'),
                    detailed_context.get('character',{}).get('sex')
                 )
            else:
                 QMessageBox.warning(self, "AI Error", "Could not improve background. No valid response from AI.")
        except Exception as e:
            logger.error(f"Error improving background: {e}", exc_info=True)
            QMessageBox.critical(self, "AI Error", f"An error occurred while improving the background:\n{e}")
            self._update_ai_button_state() # Ensure buttons are re-enabled on error

    @Slot()
    def _generate_background(self):
        if not self._validate_for_ai_generation(): return # Check validation first

        detailed_context = self._get_detailed_context_for_llm()
        formatted_context = self._format_context_for_llm_prompt(detailed_context)

        prompt = (
            f"Generate a short, engaging character description backstory seed (personality, motivation, appearance) "
            f"for the character described below. Do not narrate actions, just describe the character based on the context.\n\n"
            f"{formatted_context}"
        )

        logger.debug(f"Sending generate background prompt:\n{prompt}") # Log the prompt

        # Call LLM
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={}, # Minimal state needed
            player_input=prompt, # Use the constructed prompt
            conversation_history=[], relevant_memories=[], additional_context={}
        )
        # Add error handling for LLM calls
        try:
            # Disable buttons during generation
            self.improve_background_button.setEnabled(False)
            self.generate_background_button.setEnabled(False)
            self.repaint() # Force UI update

            response = get_narrator_agent().process(ctx) # Assumes this function exists

            # Re-enable buttons
            self._update_ai_button_state()

            narrative_content = response.get("narrative") if response else None
            if narrative_content:
                self.description_edit.setPlainText(narrative_content.strip())
                 # Update context tracking only AFTER successful generation
                self._last_generated_params = (
                    detailed_context.get('race',{}).get('name'),
                    detailed_context.get('class',{}).get('name'),
                    detailed_context.get('origin',{}).get('name'),
                    detailed_context.get('character',{}).get('sex')
                 )
            else:
                 QMessageBox.warning(self, "AI Error", "Could not generate background. No valid response from AI.")
        except Exception as e:
            logger.error(f"Error generating background: {e}", exc_info=True)
            QMessageBox.critical(self, "AI Error", f"An error occurred while generating the background:\n{e}")
            self._update_ai_button_state() # Ensure buttons are re-enabled on error

    def _check_generated_context(self):
        """Warn if selections change after background generation."""
        if self._last_generated_params:
            current = (
                self.race_combo.currentText(),
                self.path_combo.currentText(),
                self.origin_combo.currentText(), # Use origin name
                self.sex_combo.currentText()
            )
            if current != self._last_generated_params:
                QMessageBox.warning(
                    self,
                    "Background Mismatch",
                    "The backstory seed was generated for a previous selection. Please regenerate or edit to match."
                )
                # Clear the tracking so it doesn't warn repeatedly
                self._last_generated_params = None

    # --- Tab Navigation Logic ---
    def _previous_tab(self):
        current = self.tab_widget.currentIndex()
        if current > 0:
            self.tab_widget.setCurrentIndex(current - 1)

    def _next_tab(self):
        current = self.tab_widget.currentIndex()
        total = self.tab_widget.count()
        if current < total - 1:
            # Validate basic info before leaving first tab
            if current == 0 and not self._validate_basic_info():
                return # Stay on first tab if invalid
            self.tab_widget.setCurrentIndex(current + 1)
        # Note: Finishing logic is now in _finish_character_creation connected to create_button
        
    def _validate_basic_info(self) -> bool:
        """Validate the basic character information on the first tab."""
        logger.debug("Validating basic character information")
        
        # Check if name is entered
        name = self.player_name_edit.text().strip()
        if not name:
            logger.warning("Character creation validation failed: Missing name")
            QMessageBox.warning(self, "Missing Name", "Please enter a character name.")
            return False
            
        # Check if race is selected
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0
        if not race_selected:
            logger.warning("Character creation validation failed: Missing race")
            QMessageBox.warning(self, "Missing Race", "Please select a race for your character.")
            return False
            
        # Check if class is selected
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        if not class_selected:
            logger.warning("Character creation validation failed: Missing class")
            QMessageBox.warning(self, "Missing Class", "Please select a class for your character.")
            return False
            
        # Check if origin is selected (choosing the first placeholder item doesn't count)
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0
        if not origin_selected:
            logger.warning("Character creation validation failed: Missing origin")
            QMessageBox.warning(self, "Missing Origin", "Please select an origin for your character.")
            return False
            
        # All basic info is valid
        logger.debug("Basic character information validation passed")
        return True

    def _tab_changed(self, index: int):
        """Handle tab change events for button visibility."""
        logger.debug(f"Tab changed to index {index}")
        total = self.tab_widget.count()
        self.prev_tab_button.setEnabled(index > 0)

        # Find the correct QHBoxLayout holding the buttons
        bottom_layout = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if isinstance(item, QHBoxLayout):
                widget_texts = []
                for j in range(item.count()):
                    widget = item.itemAt(j).widget()
                    if isinstance(widget, QPushButton):
                        widget_texts.append(widget.text())
                if "< Previous" in widget_texts:
                    bottom_layout = item
                    break

        if not bottom_layout:
            logger.error("Could not find bottom button layout in _tab_changed")
            return


        stats_tab_index = 1 

        if index == stats_tab_index:  
            logger.debug("Showing 'Create Character' button on Stats tab")
            # Hide the next button if it's visible
            if self.next_tab_button.isVisible():
                bottom_layout.removeWidget(self.next_tab_button)
                self.next_tab_button.hide()

            # Show the create button
            if bottom_layout.indexOf(self.create_button) == -1:
                bottom_layout.addWidget(self.create_button)
            self.create_button.show()
            self._validate_form() 

        elif index < stats_tab_index:
            logger.debug(f"Showing 'Next' button on tab {index}")

            if self.create_button.isVisible():
                bottom_layout.removeWidget(self.create_button)
                self.create_button.hide()

            # Show the next button
            if bottom_layout.indexOf(self.next_tab_button) == -1:

                 stretch_index = -1
                 for i in range(bottom_layout.count()):
                     if bottom_layout.itemAt(i).spacerItem():
                         stretch_index = i
                         break
                 if stretch_index != -1:
                     insert_index = bottom_layout.indexOf(self.create_button)
                     if insert_index == -1: insert_index = stretch_index + 1 
                     bottom_layout.insertWidget(insert_index, self.next_tab_button)
                 else:  
                    bottom_layout.addWidget(self.next_tab_button)
            self.next_tab_button.show()
            self._validate_form()  

    def _finish_character_creation(self):
        """Final validation and show the start game button."""
        logger.info("Finalizing character creation")
        
        # Validate basic info again just in case
        if not self._validate_basic_info():
             logger.warning("Character creation finalization failed: Incomplete basic information")
             QMessageBox.warning(self, "Incomplete Information", "Please complete the basic character information on the first tab.")
             self.tab_widget.setCurrentIndex(0)
             return

        # Validate stats meet class requirements
        if not self.stat_allocation.meets_requirements():
            logger.warning("Character doesn't meet minimum stat requirements for selected class")
            result = QMessageBox.question(
                self,
                "Stat Requirements Not Met",
                "Your character doesn't meet the minimum stat requirements for the selected class. Continue anyway?",
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No
            )
            if result == QMessageBox.No:
                logger.debug("User chose to return to stats tab to adjust requirements")
                self.tab_widget.setCurrentIndex(1) # Go to stats tab
                return
            else:
                logger.info("User chose to continue with character despite unmet stat requirements")

        # If all checks pass, display character confirmation and show start game button
        character_name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()
        origin = self.origin_combo.currentText()
        
        logger.info(f"Character creation complete: {character_name} ({race} {class_name} from {origin})")
        
        message = f"Character Creation Complete!\n\n"
        message += f"Name: {character_name}\n"
        message += f"Race: {race}\n"
        message += f"Class: {class_name}\n"
        message += f"Origin: {origin}\n\n"
        message += f"Click 'Start Game' to begin your adventure or 'Cancel' to discard this character."
        
        QMessageBox.information(self, "Character Created", message)
        
        # Replace create button with start game button
        logger.debug("Replacing 'Create Character' button with 'Start Game' button")
        bottom_layout = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if isinstance(item, QHBoxLayout):
                widget_texts = []
                for j in range(item.count()):
                    widget = item.itemAt(j).widget()
                    if isinstance(widget, QPushButton):
                        widget_texts.append(widget.text())
                if "< Previous" in widget_texts:
                    bottom_layout = item
                    break
                    
        if bottom_layout:
            if bottom_layout.indexOf(self.create_button) != -1:
                bottom_layout.removeWidget(self.create_button)
                self.create_button.hide()
                
            if bottom_layout.indexOf(self.start_game_button) == -1:
                bottom_layout.addWidget(self.start_game_button)
            self.start_game_button.show()
            self.start_game_button.setFocus()
            logger.debug("'Start Game' button displayed and focused")
        else:
            logger.error("Could not find bottom button layout to replace buttons")

    def _start_new_game(self):
        """Accept the dialog to start a new game with the created character."""
        logger.info("Starting new game with created character")
        self.accept()
        
    def _get_detailed_context_for_llm(self) -> Dict[str, Any]:
        """Gathers detailed context about race, class, and origin for LLM prompts."""
        context = {}
        config = get_config()

        # --- Race Details ---
        race_name = self.race_combo.currentText()
        race_data = config.get(f"races.{race_name}", {}) # Assumes race name is key
        if not race_data: # Fallback if name isn't key
             all_races = config.get_all("races")
             race_data = next((r for r in all_races.values() if r.get("name") == race_name), {})

        context['race'] = {
            "name": race_name,
            "description": race_data.get('description', 'No description available.'),
            "traits": [f"{t.get('name', 'Unknown')}: {t.get('description', '-')}" for t in race_data.get('traits', [])]
        }

        # --- Class Details ---
        class_name = self.path_combo.currentText()
        class_data = config.get(f"classes.{class_name}", {}) # Assumes class name is key
        if not class_data: # Fallback if name isn't key
            all_classes = config.get_all("classes")
            class_data = next((c for c in all_classes.values() if c.get("name") == class_name), {})

        context['class'] = {
            "name": class_name,
            "description": class_data.get('description', 'No description available.'),
            "recommended_stats": class_data.get('recommended_stats', {}).get('primary', []),
            # Add proficiencies if needed:
            # "weapon_proficiencies": class_data.get('weapon_proficiencies', []),
            # "armor_proficiencies": class_data.get('armor_proficiencies', []),
        }

        # --- Origin Details ---
        origin_id = self.origin_combo.currentData()
        origin_data = self.selected_origin_data # Use stored data from selection
        if origin_data and origin_data.get('id') == origin_id:
            context['origin'] = {
                "name": origin_data.get('name', 'Unknown Origin'),
                "description": origin_data.get('description', 'No description available.'),
                "location": origin_data.get('starting_location_id', 'Unknown Location'), # Location ID
                # Add traits and skills if useful for context
                "traits": [f"{t.get('name', 'Unknown')}: {t.get('description', '-')}" for t in origin_data.get('origin_traits', [])],
                "skills": origin_data.get('skill_proficiencies', [])
            }
        else:
            context['origin'] = {"name": self.origin_combo.currentText(), "description": "Details unavailable."}


        # --- Character Info ---
        context['character'] = {
             "name": self.player_name_edit.text().strip(),
             "sex": self.sex_combo.currentText()
        }

        # --- Allocated Stats ---
        # Get base stats AFTER allocation for context (important!)
        if hasattr(self, 'stat_allocation'):
             context['stats'] = self.stat_allocation.get_allocated_stats() # Get base allocated stats

        return context

    def _format_context_for_llm_prompt(self, detailed_context: Dict[str, Any]) -> str:
        """Formats the detailed context into a string for the LLM prompt."""
        prompt_parts = ["Character Context:\n"]

        # Character Basics
        char_info = detailed_context.get('character', {})
        prompt_parts.append(f"- Name: {char_info.get('name', '(Not Set)')}")
        prompt_parts.append(f"- Sex: {char_info.get('sex', 'Unknown')}")

        # Race
        race_info = detailed_context.get('race', {})
        prompt_parts.append(f"\nRace: {race_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {race_info.get('description', 'N/A')}")
        if race_info.get('traits'):
            prompt_parts.append("  - Traits:")
            for trait in race_info['traits']:
                prompt_parts.append(f"    - {trait}")

        # Class
        class_info = detailed_context.get('class', {})
        prompt_parts.append(f"\nClass: {class_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {class_info.get('description', 'N/A')}")
        if class_info.get('recommended_stats'):
            prompt_parts.append(f"  - Recommended Primary Stats: {', '.join(class_info['recommended_stats'])}")

        # Origin
        origin_info = detailed_context.get('origin', {})
        prompt_parts.append(f"\nOrigin: {origin_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {origin_info.get('description', 'N/A')}")
        prompt_parts.append(f"  - Starting Location ID: {origin_info.get('location', 'N/A')}")
        if origin_info.get('skills'):
             prompt_parts.append(f"  - Origin Skills: {', '.join(origin_info['skills'])}")
        if origin_info.get('traits'):
            prompt_parts.append("  - Origin Traits:")
            for trait in origin_info['traits']:
                 prompt_parts.append(f"    - {trait}")

        # Allocated Stats
        stats_info = detailed_context.get('stats', {})
        if stats_info:
            prompt_parts.append("\nAllocated Base Stats:")
            stat_strs = [f"{name}: {val}" for name, val in sorted(stats_info.items())]
            prompt_parts.append(f"  - {', '.join(stat_strs)}")

        return "\n".join(prompt_parts)

    # --- New Slot for Icon Updates ---
    @Slot()
    def _update_icons_on_selection_change(self):
        """Calls scan_character_icons with current selections."""
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()
        sex = self.sex_combo.currentText()
        self.scan_character_icons(race, class_name, sex)
```

### File: ..\gui\dialogs\combat_settings_dialog.py

```python
# gui/dialogs/combat_settings_dialog.py

import os
import logging
from typing import Dict, Any, List, Optional

from PySide6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel,
    QPushButton, QGroupBox, QDialogButtonBox, QFontDialog, QColorDialog,
    QSizePolicy, QFrame, QScrollArea
)
from PySide6.QtGui import QPixmap, QIcon, QFont, QColor, QPalette
from PySide6.QtCore import Qt, Slot, QSize

from gui.dialogs.base_dialog import BaseDialog

# Get logger for the dialog
logger = logging.getLogger("GUI") # Use the same logger name as combat_display

class CombatSettingsDialog(BaseDialog):
    """Dialog for configuring Combat Display settings."""

    def __init__(self, current_settings: Dict[str, Any], image_dir: str, parent: Optional[QWidget] = None):
        """
        Initialize the settings dialog.

        Args:
            current_settings: A dictionary containing the current settings.
            image_dir: The absolute path to the directory containing background images.
            parent: The parent widget.
        """
        super().__init__(parent)
        self.setWindowTitle("Combat Display Settings")
        self.setMinimumHeight(550) # Increased height slightly
        self.setMinimumWidth(850) # Increased width slightly

        # Store settings and image directory
        self.settings = current_settings.copy()
        self.image_dir = image_dir
        self.available_images: List[str] = []
        self.current_image_index: int = -1
        self.color_buttons: Dict[str, QPushButton] = {}

        # Main layout
        main_layout = QVBoxLayout(self)

        # --- Sections ---
        main_layout.addWidget(self._setup_background_section())
        main_layout.addWidget(self._setup_font_section())
        color_group = self._setup_color_section()
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setWidget(color_group)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        main_layout.addWidget(scroll_area, 1) # Allow color section to expand

        # --- Dialog Buttons ---
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        main_layout.addWidget(button_box)

        # Load initial values into UI elements
        self._load_settings_to_ui()

    # --- Section Setup Methods ---

    def _setup_background_section(self) -> QGroupBox:
        """Create the GroupBox for background image settings."""
        group = QGroupBox("Main Background Image") # Renamed for clarity
        layout = QVBoxLayout(group)
        h_layout = QHBoxLayout() # Layout for controls

        # Image Preview
        self.bg_preview_label = QLabel("No Image Selected")
        self.bg_preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.bg_preview_label.setFixedSize(200, 112) # 16:9 aspect ratio approx
        self.bg_preview_label.setFrameShape(QFrame.Shape.StyledPanel)
        self.bg_preview_label.setStyleSheet("background-color: #333;") # Dark background for preview

        # Controls Layout
        controls_layout = QVBoxLayout()
        controls_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Image Filename Label
        self.bg_filename_label = QLabel("Current: None")
        self.bg_filename_label.setWordWrap(True)
        controls_layout.addWidget(self.bg_filename_label)

        # Navigation Buttons
        nav_layout = QHBoxLayout()
        prev_button = QPushButton("< Prev") # Use standard characters
        prev_button.setToolTip("Select previous background image")
        prev_button.clicked.connect(self._browse_image_left)
        next_button = QPushButton("Next >") # Use standard characters
        next_button.setToolTip("Select next background image")
        next_button.clicked.connect(self._browse_image_right)
        nav_layout.addWidget(prev_button)
        nav_layout.addWidget(next_button)
        controls_layout.addLayout(nav_layout)

        # Clear Button
        clear_button = QPushButton("Clear Background")
        clear_button.setToolTip("Remove background image selection")
        clear_button.clicked.connect(self._clear_background)
        controls_layout.addWidget(clear_button)

        # Add preview and controls to horizontal layout
        h_layout.addWidget(self.bg_preview_label)
        h_layout.addLayout(controls_layout)
        layout.addLayout(h_layout)

        # Scan for available images
        self._scan_images()

        return group

    def _setup_font_section(self) -> QGroupBox:
        """Create the GroupBox for font settings."""
        group = QGroupBox("Font Settings")
        layout = QHBoxLayout(group) # Use QHBoxLayout for side-by-side

        # Font Selection Button
        font_button = QPushButton("Choose Base Font...")
        font_button.setToolTip("Select font family and base size for most elements")
        font_button.clicked.connect(self._choose_font)
        layout.addWidget(font_button)

        # Font Preview Label
        self.font_preview_label = QLabel("Font Preview Text")
        self.font_preview_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        layout.addWidget(self.font_preview_label)

        return group

    def _setup_color_section(self) -> QGroupBox:
        """Create the GroupBox for color settings, organized into columns."""
        group = QGroupBox("Color Settings")
        main_h_layout = QHBoxLayout(group)

        categories = {
            "Log General": [
                "color_log_default", "color_log_header", "color_log_dev",
                "color_log_system_message", "color_log_narrative", "color_log_combat_event",
                "color_log_group_bg", "color_log_text_bg"
            ],
            "Log Specific Events": [
                "color_log_damage", "color_log_heal", "color_log_crit", "color_log_miss",
                "color_log_roll", "color_log_turn", "color_log_round"
            ],
            "Entity Display": [
                "color_entity_player_bg", "color_entity_player_border",
                "color_entity_player_bg_active", "color_entity_player_border_active",
                "color_entity_enemy_bg", "color_entity_enemy_border",
                "color_entity_enemy_bg_active", "color_entity_enemy_border_active"
            ],
            "Progress Bars": [
                "color_hp_bar_chunk_normal", "color_hp_bar_chunk_low", "color_hp_bar_chunk_critical",
                "color_hp_bar_chunk_normal_bleak", "color_hp_bar_chunk_low_bleak", "color_hp_bar_chunk_critical_bleak",
                "color_stamina_bar_chunk", "color_stamina_bar_chunk_bleak",
                "color_mana_bar_chunk", "color_mana_bar_chunk_bleak", # Added Mana Bleak
                "color_resolve_bar_chunk", "color_progressbar_text", "color_progressbar_bg"
            ],
            "Section & UI Text": [
                "color_player_group_bg", "color_enemies_group_bg",
                "color_groupbox_title_text", "color_groupbox_title_bg",
                "color_status_text", "color_round_text"
            ]
        }

        for category_name, keys in categories.items():
            valid_keys_in_category = [k for k in keys if k in self.settings]
            if not valid_keys_in_category:
                continue

            category_v_layout = QVBoxLayout()
            category_v_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

            category_label = QLabel(f"<b>{category_name}</b>")
            category_v_layout.addWidget(category_label)

            form_layout = QFormLayout()
            form_layout.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
            form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
            form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapLongRows)


            valid_keys_in_category.sort() 

            for key in valid_keys_in_category:
                label_text_parts = key.replace("color_", "").replace("_", " ").split(" ")
                # Capitalize each part and join
                label_text = " ".join([part.capitalize() for part in label_text_parts]) + ":"
                
                # Specific label overrides for better readability
                if key == "color_log_default": label_text = "Log Default Text:"
                elif key == "color_log_header": label_text = "Log Header Text:"
                elif key == "color_log_dev": label_text = "Log Dev Message:"
                elif key == "color_log_system_message": label_text = "Log System Message:"
                elif key == "color_log_narrative": label_text = "Log Narrative/GM Text:"
                elif key == "color_log_combat_event": label_text = "Log Major Combat Event:"
                elif key == "color_log_group_bg": label_text = "Log Section BG:"
                elif key == "color_log_text_bg": label_text = "Log Text Area BG:"
                elif key == "color_log_damage": label_text = "Log Damage Text:"
                elif key == "color_log_heal": label_text = "Log Heal Text:"
                elif key == "color_log_crit": label_text = "Log Critical Hit:"
                elif key == "color_log_miss": label_text = "Log Miss/Fail:"
                elif key == "color_log_roll": label_text = "Log Dice Roll:"
                elif key == "color_log_turn": label_text = "Log Turn Change:"
                elif key == "color_log_round": label_text = "Log Round Change:"
                elif key == "color_entity_player_bg": label_text = "Player Entity BG:"
                elif key == "color_entity_player_border": label_text = "Player Entity Border:"
                elif key == "color_entity_player_bg_active": label_text = "Player Active BG:"
                elif key == "color_entity_player_border_active": label_text = "Player Active Border:"
                elif key == "color_entity_enemy_bg": label_text = "Enemy Entity BG:"
                elif key == "color_hp_bar_chunk_normal": label_text = "HP Bar Normal:"
                elif key == "color_hp_bar_chunk_low": label_text = "HP Bar Low:"
                elif key == "color_hp_bar_chunk_critical": label_text = "HP Bar Critical:"
                elif key == "color_hp_bar_chunk_normal_bleak": label_text = "HP Bar Normal (Bleak):"
                elif key == "color_hp_bar_chunk_low_bleak": label_text = "HP Bar Low (Bleak):"
                elif key == "color_hp_bar_chunk_critical_bleak": label_text = "HP Bar Critical (Bleak):"
                elif key == "color_stamina_bar_chunk": label_text = "Stamina Bar:"
                elif key == "color_stamina_bar_chunk_bleak": label_text = "Stamina Bar (Bleak):"
                elif key == "color_mana_bar_chunk": label_text = "Mana Bar:" # Added Mana Bar
                elif key == "color_mana_bar_chunk_bleak": label_text = "Mana Bar (Bleak):" # Added Mana Bar Bleak
                elif key == "color_resolve_bar_chunk": label_text = "Resolve Bar:"
                elif key == "color_progressbar_text": label_text = "Progress Bar Text:"
                elif key == "color_progressbar_bg": label_text = "Progress Bar BG:"
                elif key == "color_player_group_bg": label_text = "Player Section BG:"
                elif key == "color_enemies_group_bg": label_text = "Enemies Section BG:"
                elif key == "color_groupbox_title_text": label_text = "Section Title Text:"
                elif key == "color_groupbox_title_bg": label_text = "Section Title BG:"
                elif key == "color_status_text": label_text = "Status Label Text:"
                elif key == "color_round_text": label_text = "Round Label Text:"


                color_button = self._create_color_button(key)
                form_layout.addRow(label_text, color_button)
                self.color_buttons[key] = color_button

            category_v_layout.addLayout(form_layout)
            main_h_layout.addLayout(category_v_layout)

        main_h_layout.addStretch()
        return group
    # --- Helper Methods ---

    def _scan_images(self):
        """Scan the image directory for valid image files."""
        self.available_images = []
        try:
            if os.path.isdir(self.image_dir):
                for filename in sorted(os.listdir(self.image_dir)):
                    if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
                        self.available_images.append(filename)
                logger.info(f"Found {len(self.available_images)} images in {self.image_dir}")
            else:
                logger.warning(f"Image directory not found: {self.image_dir}")
        except OSError as e:
            logger.error(f"Error scanning image directory {self.image_dir}: {e}")

    def _update_background_preview(self):
        """Update the background image preview label and filename."""
        if 0 <= self.current_image_index < len(self.available_images):
            relative_path = self.available_images[self.current_image_index]
            full_path = os.path.join(self.image_dir, relative_path)
            pixmap = QPixmap(full_path)
            if not pixmap.isNull():
                scaled_pixmap = pixmap.scaled(self.bg_preview_label.size(),
                                              Qt.AspectRatioMode.KeepAspectRatioByExpanding, # Fill the space better
                                              Qt.TransformationMode.SmoothTransformation)
                # Crop the pixmap to the label size after scaling
                rect = scaled_pixmap.rect()
                rect.setSize(self.bg_preview_label.size())
                cropped_pixmap = scaled_pixmap.copy(rect)

                self.bg_preview_label.setPixmap(cropped_pixmap)
                self.bg_filename_label.setText(f"Current: {relative_path}")
                self.settings["background_image"] = relative_path # Store relative path
            else:
                logger.warning(f"Failed to load image: {full_path}")
                self._clear_background_ui() # Show error state
                self.bg_filename_label.setText(f"Error loading: {relative_path}")
        else:
            self._clear_background_ui()

    def _clear_background_ui(self):
        """Clear the background preview and filename label."""
        self.bg_preview_label.clear()
        self.bg_preview_label.setText("No Image Selected")
        self.bg_preview_label.setStyleSheet("background-color: #333;") # Reset background
        self.bg_filename_label.setText("Current: None")
        self.settings["background_image"] = None # Clear setting

    def _update_font_preview(self):
        """Update the font preview label based on current settings."""
        font_family = self.settings.get("font_family", "Arial")
        font_size = self.settings.get("font_size", 10)
        font = QFont(font_family, font_size)
        self.font_preview_label.setFont(font)
        self.font_preview_label.setText(f"{font_family}, {font_size}pt - AaBbCc") # Add sample text

    def _create_color_button(self, setting_key: str) -> QPushButton:
        """Create a button for selecting a color."""
        button = QPushButton()
        button.setProperty("setting_key", setting_key) # Store key on button
        button.setToolTip(f"Click to change color for '{setting_key}'")
        button.setMinimumHeight(25)
        button.clicked.connect(self._choose_color)
        return button

    def _update_color_button_preview(self, button: QPushButton, color_value: str):
        """Update the appearance of a color selection button."""
        try:
            qcolor = QColor(color_value)
            if qcolor.isValid():
                # Set background color
                # Determine text color based on background brightness for readability
                brightness = (qcolor.red() * 299 + qcolor.green() * 587 + qcolor.blue() * 114) / 1000
                text_color = "#000000" if brightness > 128 else "#FFFFFF"
                # Combine styles
                button.setStyleSheet(f"background-color: {color_value}; color: {text_color}; border: 1px solid #888;") # Add border for definition
                button.setText(color_value) # Display the color value
            else:
                button.setText("Invalid Color")
                button.setStyleSheet("") # Reset style
        except Exception as e:
            logger.error(f"Error updating color button preview for '{color_value}': {e}")
            button.setText("Error")
            button.setStyleSheet("")

    def _load_settings_to_ui(self):
        """Load the initial settings values into the UI controls."""
        # Background
        current_bg = self.settings.get("background_image")
        if current_bg and self.available_images: # Check if list is not empty
            try:
                self.current_image_index = self.available_images.index(current_bg)
            except ValueError:
                logger.warning(f"Saved background image '{current_bg}' not found in available images. Clearing.")
                self.current_image_index = -1 # Not found
                if "background_image" in self.settings: self.settings["background_image"] = None # Clear invalid setting
        else:
            self.current_image_index = -1
            if "background_image" in self.settings: self.settings["background_image"] = None # Ensure it's cleared if no images available
        self._update_background_preview()

        # Font
        self._update_font_preview()

        # Colors
        for key, button in self.color_buttons.items():
            # Provide a default fallback color if key is missing in settings (e.g., new setting added)
            default_color = "#FFFFFF" if "bg" in key else "#000000" # Simple default logic
            color_value = self.settings.get(key, default_color)
            self._update_color_button_preview(button, color_value)

    # --- Slots ---

    @Slot()
    def _browse_image_left(self):
        """Select the previous image."""
        if not self.available_images: return
        self.current_image_index -= 1
        if self.current_image_index < 0:
            self.current_image_index = len(self.available_images) - 1 # Wrap around
        self._update_background_preview()

    @Slot()
    def _browse_image_right(self):
        """Select the next image."""
        if not self.available_images: return
        self.current_image_index += 1
        if self.current_image_index >= len(self.available_images):
            self.current_image_index = 0 # Wrap around
        self._update_background_preview()

    @Slot()
    def _clear_background(self):
        """Clear the background image selection."""
        self.current_image_index = -1
        self._update_background_preview()

    @Slot()
    def _choose_font(self):
        """Open the QFontDialog to select a font."""
        current_family = self.settings.get("font_family", "Arial")
        current_size = self.settings.get("font_size", 10)
        current_font = QFont(current_family, current_size)

        ok, font = QFontDialog.getFont(current_font, self, "Select Base Font")
        if ok:
            self.settings["font_family"] = font.family()
            self.settings["font_size"] = font.pointSize()
            self._update_font_preview() # Update the preview label

    @Slot()
    def _choose_color(self):
        """Open the QColorDialog to select a color for the clicked button."""
        sender_button = self.sender()
        if not isinstance(sender_button, QPushButton):
            return

        setting_key = sender_button.property("setting_key")
        if not setting_key:
            logger.warning("Color button clicked without a 'setting_key' property.")
            return

        current_color_value = self.settings.get(setting_key, "#000000")
        try:
            current_qcolor = QColor(current_color_value)
            if not current_qcolor.isValid():
                logger.warning(f"Invalid current color '{current_color_value}' for key '{setting_key}'. Defaulting to black.")
                current_qcolor = QColor("#000000")
        except Exception:
             logger.warning(f"Error parsing current color '{current_color_value}' for key '{setting_key}'. Defaulting to black.")
             current_qcolor = QColor("#000000")


        # Open color dialog, always allow alpha for background colors or if current value suggests it
        options = QColorDialog.ColorDialogOption(0)
        # Enable alpha if it's a background setting OR if the current color has alpha OR if it's an rgba string
        if "bg" in setting_key.lower() or current_qcolor.alpha() < 255 or 'rgba' in current_color_value.lower():
             options = QColorDialog.ColorDialogOption.ShowAlphaChannel

        new_color = QColorDialog.getColor(current_qcolor, self, f"Select Color for {setting_key}", options=options)

        if new_color.isValid():
            # Store color. Use RGBA string if alpha is not 255, otherwise use hex.
            if new_color.alpha() < 255:
                # Store rgba string directly as it's often more CSS friendly.
                # Use integer values for RGB, float for alpha
                rgba_string = f"rgba({new_color.red()}, {new_color.green()}, {new_color.blue()}, {new_color.alphaF():.3f})"
                self.settings[setting_key] = rgba_string
                self._update_color_button_preview(sender_button, rgba_string)
            else:
                hex_name = new_color.name(QColor.NameFormat.HexRgb) # Format like #RRGGBB
                self.settings[setting_key] = hex_name
                self._update_color_button_preview(sender_button, hex_name)


    # --- Public Method ---

    def get_settings(self) -> Dict[str, Any]:
        """
        Return the modified settings dictionary.

        This should be called after the dialog has been accepted.
        """
        # The self.settings dictionary has been updated throughout interaction
        logger.info("Returning updated settings from dialog.")
        # Ensure background image is None if index is invalid or no images available
        if not self.available_images or self.current_image_index < 0 or self.current_image_index >= len(self.available_images):
            self.settings["background_image"] = None
        elif self.available_images: # Check again just in case
             self.settings["background_image"] = self.available_images[self.current_image_index]

        return self.settings


```

### File: ..\gui\dialogs\game_over_dialog.py

```python
# gui/dialogs/game_over_dialog.py
import os
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QFrame, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QSize
from PySide6.QtGui import QFont, QColor, QPalette

class GameOverDialog(QDialog):
    """Dialog displayed when the player is defeated."""

    # Signals for button clicks
    new_game_requested = Signal()
    load_game_requested = Signal()
    load_last_save_requested = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self.setWindowTitle("Game Over")
        self.setModal(True) # Block interaction with main window
        self.setMinimumSize(400, 250)
        # Remove close button, force choice via buttons
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowCloseButtonHint | Qt.FramelessWindowHint)

        # --- Styling ---
        self.setStyleSheet("""
            QDialog {
                background-color: rgba(30, 30, 30, 0.95); /* Dark semi-transparent background */
                border: 2px solid #8B0000; /* Dark red border */
                border-radius: 15px;
            }
            QLabel#GameOverTitle {
                color: #DC143C; /* Crimson red */
                font-size: 48px;
                font-weight: bold;
                qproperty-alignment: 'AlignCenter';
                padding: 20px;
            }
            QLabel#GameOverReason {
                color: #E0E0E0; /* Light gray */
                font-size: 16px;
                qproperty-alignment: 'AlignCenter';
                padding-bottom: 20px;
            }
            QPushButton {
                background-color: #555555;
                color: #FFFFFF;
                border: 1px solid #777777;
                border-radius: 5px;
                padding: 10px 20px;
                font-size: 14px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #666666;
                border: 1px solid #999999;
            }
            QPushButton:pressed {
                background-color: #444444;
            }
            QPushButton#LoadLastSaveButton {
                background-color: #4CAF50; /* Green for emphasis */
            }
            QPushButton#LoadLastSaveButton:hover {
                background-color: #66BB69;
            }
             QPushButton#LoadLastSaveButton:pressed {
                background-color: #3B8C3E;
            }
        """)

        # --- Layout ---
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        main_layout.setAlignment(Qt.AlignCenter)

        # Title Label
        title_label = QLabel("GAME OVER")
        title_label.setObjectName("GameOverTitle")
        main_layout.addWidget(title_label, 0, Qt.AlignCenter)

        # Reason Label (optional, can be set externally)
        self.reason_label = QLabel("You have been defeated!")
        self.reason_label.setObjectName("GameOverReason")
        main_layout.addWidget(self.reason_label, 0, Qt.AlignCenter)

        # Button Layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        button_layout.setAlignment(Qt.AlignCenter) # Center buttons horizontally

        self.new_game_button = QPushButton("New Game")
        self.load_game_button = QPushButton("Load Game")
        self.load_last_save_button = QPushButton("Load Last Save")
        self.load_last_save_button.setObjectName("LoadLastSaveButton")

        button_layout.addWidget(self.new_game_button)
        button_layout.addWidget(self.load_game_button)
        button_layout.addWidget(self.load_last_save_button)

        main_layout.addLayout(button_layout)

        # --- Connections ---
        self.new_game_button.clicked.connect(self._on_new_game)
        self.load_game_button.clicked.connect(self._on_load_game)
        self.load_last_save_button.clicked.connect(self._on_load_last_save)

    def set_reason(self, reason: str):
        """Set the reason text displayed below GAME OVER."""
        self.reason_label.setText(reason)

    def _on_new_game(self):
        self.new_game_requested.emit()
        self.accept() # Close the dialog

    def _on_load_game(self):
        self.load_game_requested.emit()
        self.accept() # Close the dialog

    def _on_load_last_save(self):
        self.load_last_save_requested.emit()
        self.accept() # Close the dialog

    # --- Optional: Centering on Show ---
    def showEvent(self, event):
        """Center the dialog when shown."""
        super().showEvent(event)
        if self.parent():
            parent_rect = self.parent().geometry()
            self.move(parent_rect.center() - self.rect().center())
```

### File: ..\gui\dialogs\load_game_dialog.py

```python
#!/usr/bin/env python3
"""
Load game dialog for the RPG game GUI.
This module provides a dialog for loading a saved game.
"""

import logging
import os
import json
from typing import Optional, List, Dict
from datetime import datetime

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
    QPushButton, QGroupBox, QListWidget, QListWidgetItem,
    QSplitter, QWidget, QTextEdit, QHeaderView, QTableWidget,
    QTableWidgetItem, QAbstractItemView
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon, QFont

from gui.dialogs.base_dialog import BaseDialog

class LoadGameDialog(BaseDialog):
    """Dialog for loading a saved game."""
    
    def __init__(self, parent=None):
        """Initialize the load game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Load Game")
        self.setMinimumWidth(600)
        self.setMinimumHeight(400)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget, QTableWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item, QTableWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected, QTableWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover, QTableWidget::item:hover {
                background-color: #383838;
            }
            QTextEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QHeaderView::section {
                background-color: #333333;
                color: #E0E0E0;
                padding: 5px;
                border: 1px solid #444444;
            }
            QSplitter::handle {
                background-color: #444444;
            }
        """)
        
        # Selected save
        self.selected_save = None
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create a splitter for the save list and details
        splitter = QSplitter(Qt.Horizontal)
        
        # Create the saves list widget
        saves_widget = QWidget()
        saves_layout = QVBoxLayout(saves_widget)
        saves_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the saves table
        self.saves_table = QTableWidget()
        self.saves_table.setColumnCount(3)
        self.saves_table.setHorizontalHeaderLabels(["Save Name", "Date", "Character"])
        self.saves_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.saves_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.saves_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.saves_table.verticalHeader().setVisible(False)
        self.saves_table.setAlternatingRowColors(True)
        self.saves_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.saves_table.setSelectionMode(QAbstractItemView.SingleSelection)
        self.saves_table.setEditTriggers(QTableWidget.NoEditTriggers)
        
        # Add saves table to layout
        saves_layout.addWidget(self.saves_table)
        
        # Create the details widget
        details_widget = QWidget()
        details_layout = QVBoxLayout(details_widget)
        details_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the details group
        details_group = QGroupBox("Save Details")
        details_group_layout = QVBoxLayout(details_group)
        
        # Create the details text
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        
        # Add details text to group layout
        details_group_layout.addWidget(self.details_text)
        
        # Add details group to layout
        details_layout.addWidget(details_group)
        
        # Add widgets to splitter
        splitter.addWidget(saves_widget)
        splitter.addWidget(details_widget)
        
        # Set initial sizes
        splitter.setSizes([int(self.width() * 0.6), int(self.width() * 0.4)])
        
        # Add splitter to main layout
        main_layout.addWidget(splitter)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create delete button
        self.delete_button = QPushButton("Delete Save")
        self.delete_button.setEnabled(False)
        # self.delete_button.clicked.connect(self._on_delete_clicked)
        
        # Create load button
        self.load_button = QPushButton("Load Game")
        self.load_button.setEnabled(False)
        self.load_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.delete_button)
        button_layout.addWidget(self.load_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load saves
        self._load_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Connect save selection
        self.saves_table.itemSelectionChanged.connect(self._on_save_selected)
        self.saves_table.doubleClicked.connect(self._on_save_double_clicked)
    
    def _load_saves(self):
        """Load saves into the table."""
        # Clear the table
        self.saves_table.setRowCount(0)
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to table
        for i, save_file in enumerate(save_files):
            # Get the full path
            save_path = os.path.join(saves_dir, save_file)
            
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Get the modification time
            mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
            mod_time_str = mod_time.strftime("%Y-%m-%d %H:%M")
            
            # Get the character name (if possible)
            character_name = self._get_character_name(save_path)
            
            # Add row to table
            self.saves_table.insertRow(i)
            self.saves_table.setItem(i, 0, QTableWidgetItem(save_name))
            self.saves_table.setItem(i, 1, QTableWidgetItem(mod_time_str))
            self.saves_table.setItem(i, 2, QTableWidgetItem(character_name))
    
    def _get_character_name(self, save_path: str) -> str:
        """Get the character name from a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The character name, or "Unknown" if not found.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Try to get the character name
                if "player" in save_data and "name" in save_data["player"]:
                    return save_data["player"]["name"]
        except Exception as e:
            pass
        
        return "Unknown"
    
    def _get_save_details(self, save_path: str) -> str:
        """Get the details for a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The save details as a formatted string.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Extract details
                player_data = save_data.get("player", {})
                world_data = save_data.get("world", {})
                
                # Format details
                details = []
                
                # Player details
                if player_data:
                    details.append("Character Information:")
                    details.append(f"Name: {player_data.get('name', 'Unknown')}")
                    details.append(f"Race: {player_data.get('race', 'Unknown')}")
                    details.append(f"Class: {player_data.get('path', 'Unknown')}")
                    details.append(f"Background: {player_data.get('background', 'Unknown')}")
                    details.append(f"Level: {player_data.get('level', 1)}")
                    details.append("")
                
                # World details
                if world_data:
                    details.append("World Information:")
                    details.append(f"Location: {world_data.get('current_location', 'Unknown')}")
                    details.append(f"Time: {world_data.get('game_time', 'Unknown')}")
                    details.append("")
                
                # Game details
                mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
                details.append("Save Information:")
                details.append(f"Created: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}")
                details.append(f"File: {os.path.basename(save_path)}")
                
                return "\n".join(details)
        except Exception as e:
            return f"Error loading save details: {str(e)}"
    
    def _on_save_selected(self):
        """Handle save selection."""
        # Get the selected row
        selected_rows = self.saves_table.selectedItems()
        
        if not selected_rows:
            # No selection
            self.selected_save = None
            self.details_text.clear()
            self.load_button.setEnabled(False)
            self.delete_button.setEnabled(False)
            return
        
        # Get the save name
        save_name = self.saves_table.item(selected_rows[0].row(), 0).text()
        
        # Set the selected save
        self.selected_save = save_name + ".json"
        
        # Get the save path
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        save_path = os.path.join(saves_dir, self.selected_save)
        
        # Update the details
        self.details_text.setText(self._get_save_details(save_path))
        
        # Enable buttons
        self.load_button.setEnabled(True)
        self.delete_button.setEnabled(True)
    
    def _on_save_double_clicked(self, item):
        """Handle save double click."""
        # Accept the dialog to load the selected save
        self.accept()

```

### File: ..\gui\dialogs\new_game_dialog.py

```python
# gui/dialogs/new_game_dialog.py

import os
import json
import logging
from typing import Any, Optional, List, Dict

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QComboBox,
    QPushButton, QGroupBox, QTextEdit, QMessageBox, QFormLayout,
    QCheckBox, QScrollArea, QWidget
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QPixmap
from core.base.config import get_config

# Get logger for this module
logger = logging.getLogger(__name__)

class NewGameDialog(QDialog):
    """Dialog for creating a new game character using the Origin system."""

    def __init__(self, parent=None):
        """Initialize the new game dialog."""
        super().__init__(parent)

        # Set window properties
        self.setWindowTitle("Create New Character")
        self.setMinimumWidth(700) # Increased width for more details
        self.setMinimumHeight(600) # Increased height
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
                padding-top: 3px; /* Add some vertical space */
            }
            QLineEdit, QTextEdit, QComboBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px; /* Reduced margin */
                padding-top: 10px; /* Add padding inside */
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 10px 0 10px;
                color: #E0E0E0;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            #OriginDetailsLabel { /* Style for the details labels */
                color: #CCCCCC;
                padding-left: 5px;
            }
        """)

        # Load data dynamically
        self.available_races = self._load_races()
        self.available_classes = self._load_classes()
        self.available_origins = self._load_origins() # Load origins instead of backgrounds
        self.available_sexes = ["Male", "Female", "Other"] # Added 'Other'

        # Set up character icon browsing
        self.character_icons = []
        self.current_icon_index = 0
        self.scan_character_icons()

        # Default to LLM enabled
        self.llm_enabled = True
        self.selected_icon_path = None
        self.selected_origin_data = None # Store full data of selected origin

        # Set up the UI
        self._setup_ui()

        # Connect signals
        self._connect_signals()

        # Initial validation
        self._validate_form()

    def _setup_ui(self):
        """Set up the user interface."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(10) # Reduced spacing

        # Layout for character details (info, description) and portrait
        details_layout = QHBoxLayout()
        details_layout.setSpacing(15)

        # --- Left Column: Info, Origin Details, Description ---
        left_column_widget = QWidget() # Create a widget for the scroll area
        left_column_layout = QVBoxLayout(left_column_widget)
        left_column_layout.setContentsMargins(0,0,0,0)
        left_column_layout.setSpacing(10)

        # --- Character Info Group ---
        info_group = QGroupBox("Character Information")
        info_layout = QFormLayout(info_group)
        info_layout.setContentsMargins(15, 25, 15, 15) # Adjusted margins
        info_layout.setSpacing(8) # Reduced spacing

        self.player_name_edit = QLineEdit()
        self.player_name_edit.setPlaceholderText("Enter your character's name...")
        info_layout.addRow("Name:", self.player_name_edit)

        self.race_combo = QComboBox()
        self._populate_combo(self.race_combo, self.available_races, "Races")
        info_layout.addRow("Race:", self.race_combo)

        self.path_combo = QComboBox() # Represents Class
        self._populate_combo(self.path_combo, self.available_classes, "Classes")
        info_layout.addRow("Class:", self.path_combo)

        # --- Origin Selection (Replaces Background) ---
        self.origin_combo = QComboBox()
        self._populate_origin_combo() # Custom population method
        info_layout.addRow("Origin:", self.origin_combo)
        # --- End Origin Selection ---

        self.sex_combo = QComboBox()
        self._populate_combo(self.sex_combo, self.available_sexes, "Sexes")
        info_layout.addRow("Sex:", self.sex_combo)

        self.llm_checkbox = QCheckBox("Enable LLM (AI processing)")
        self.llm_checkbox.setChecked(self.llm_enabled)
        info_layout.addRow("", self.llm_checkbox)
        left_column_layout.addWidget(info_group)

        # --- Origin Details Group (NEW) ---
        origin_details_group = QGroupBox("Origin Details")
        origin_details_layout = QVBoxLayout(origin_details_group)
        origin_details_layout.setContentsMargins(15, 25, 15, 15)
        origin_details_layout.setSpacing(8)

        self.origin_desc_label = QLabel("Select an Origin to see details.")
        self.origin_desc_label.setObjectName("OriginDetailsLabel")
        self.origin_desc_label.setWordWrap(True)
        self.origin_desc_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(QLabel("<b>Description:</b>"))
        origin_details_layout.addWidget(self.origin_desc_label)

        self.origin_skills_label = QLabel("-")
        self.origin_skills_label.setObjectName("OriginDetailsLabel")
        self.origin_skills_label.setWordWrap(True)
        origin_details_layout.addWidget(QLabel("<b>Skill Proficiencies:</b>"))
        origin_details_layout.addWidget(self.origin_skills_label)

        self.origin_traits_label = QLabel("-")
        self.origin_traits_label.setObjectName("OriginDetailsLabel")
        self.origin_traits_label.setWordWrap(True)
        self.origin_traits_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(QLabel("<b>Origin Traits:</b>"))
        origin_details_layout.addWidget(self.origin_traits_label)
        origin_details_layout.addStretch() # Push details up
        left_column_layout.addWidget(origin_details_group)


        # --- Description Group (Backstory) ---
        description_group = QGroupBox("Character Backstory (Optional Seed)")
        description_layout = QVBoxLayout(description_group)
        description_layout.setContentsMargins(15, 25, 15, 15)
        description_layout.setSpacing(5)

        description_label = QLabel("Optionally edit the text below (based on selected Origin) to guide the LLM background generation:")
        description_label.setWordWrap(True)
        description_label.setStyleSheet("color: #AAAAAA; font-style: italic;")

        self.description_edit = QTextEdit() # Player editable backstory seed
        self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
        self.description_edit.setMinimumHeight(100) # Ensure decent height

        description_layout.addWidget(description_label)
        description_layout.addWidget(self.description_edit)
        left_column_layout.addWidget(description_group)
        left_column_layout.addStretch(1) # Add stretch to push content up

        # --- Add Left Column Scroll Area ---
        left_scroll_area = QScrollArea()
        left_scroll_area.setWidgetResizable(True)
        left_scroll_area.setWidget(left_column_widget)


        # --- Right Column: Portrait ---
        right_column_widget = QWidget()
        right_column_layout = QVBoxLayout(right_column_widget)
        right_column_layout.setContentsMargins(0,0,0,0)
        right_column_layout.setSpacing(10)

        icon_group = QGroupBox("Character Portrait")
        icon_layout = QVBoxLayout(icon_group)
        icon_layout.setContentsMargins(15, 25, 15, 15)
        icon_layout.setSpacing(8)

        self.icon_label = QLabel()
        self.icon_label.setAlignment(Qt.AlignCenter)
        self.icon_label.setFixedSize(150, 150) # Fixed size for portrait
        self.icon_label.setStyleSheet("background-color: #1E1E1E; border: 1px solid #3F3F46;")
        self.icon_label.setText("No image")
        icon_layout.addWidget(self.icon_label, 0, Qt.AlignCenter) # Center the label

        nav_layout = QHBoxLayout()
        self.prev_icon_button = QPushButton("←")
        self.icon_counter_label = QLabel("0 / 0")
        self.icon_counter_label.setAlignment(Qt.AlignCenter)
        self.next_icon_button = QPushButton("→")
        nav_layout.addWidget(self.prev_icon_button)
        nav_layout.addWidget(self.icon_counter_label)
        nav_layout.addWidget(self.next_icon_button)
        icon_layout.addLayout(nav_layout)

        portrait_hint = QLabel("Browse available character portraits")
        portrait_hint.setStyleSheet("color: #888888; font-style: italic;")
        portrait_hint.setAlignment(Qt.AlignCenter)
        icon_layout.addWidget(portrait_hint)
        right_column_layout.addWidget(icon_group)
        right_column_layout.addStretch(1) # Push portrait group up


        # Add columns to main details layout
        details_layout.addWidget(left_scroll_area, 3)  # Left column takes more space
        details_layout.addWidget(right_column_widget, 1) # Right column for portrait

        main_layout.addLayout(details_layout, 1) # Make details layout stretch

        # --- Dialog Buttons ---
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        self.cancel_button = QPushButton("Cancel")
        self.create_button = QPushButton("Create Character")
        self.create_button.setEnabled(False)
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.create_button)
        main_layout.addLayout(button_layout)

    def _populate_combo(self, combo: QComboBox, items: List[str], item_type: str):
        """Helper to populate QComboBox and handle empty lists."""
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItems(items)
            combo.setEnabled(True)

    def _populate_origin_combo(self):
        """Populate the Origin combo box."""
        combo = self.origin_combo
        items = self.available_origins
        item_type = "Origins"

        combo.clear() # Clear previous items
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItem("--- Select an Origin ---", None) # Placeholder item
            for origin_data in items:
                # Add item with name as text and id as data
                combo.addItem(origin_data.get('name', 'Unknown Origin'), origin_data.get('id'))
            combo.setEnabled(True)

    @Slot(int)
    def _on_origin_selected(self, index: int):
        """Update details display when an origin is selected."""
        self.selected_origin_data = None # Reset selected data
        origin_id = self.origin_combo.itemData(index)

        if origin_id is None: # Handle placeholder selection
            self.origin_desc_label.setText("Select an Origin to see details.")
            self.origin_skills_label.setText("-")
            self.origin_traits_label.setText("-")
            self.description_edit.setPlainText("") # Clear backstory seed
            self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
            self._validate_form() # Re-validate as origin is deselected
            return

        # Find the full origin data using the ID
        origin = next((o for o in self.available_origins if o.get('id') == origin_id), None)

        if origin:
            self.selected_origin_data = origin # Store the full data
            self.origin_desc_label.setText(origin.get('description', 'No description available.'))

            # Format skills
            skills = origin.get('skill_proficiencies', [])
            self.origin_skills_label.setText(", ".join(skills) if skills else "None")

            # Format traits
            traits = origin.get('origin_traits', [])
            traits_text = ""
            if traits:
                trait_lines = [f"<b>{t.get('name', 'Unnamed Trait')}:</b> {t.get('description', 'No description.')}" for t in traits]
                traits_text = "<br>".join(trait_lines) # Use HTML for formatting
            else:
                traits_text = "None"
            self.origin_traits_label.setText(traits_text)

            # Pre-populate backstory seed if empty
            if not self.description_edit.toPlainText().strip():
                 self.description_edit.setPlainText(origin.get('introduction_text', ''))

        else:
            # Handle case where origin ID is found but data isn't (shouldn't happen)
            self.origin_desc_label.setText("Error: Could not load details.")
            self.origin_skills_label.setText("-")
            self.origin_traits_label.setText("-")
            self.description_edit.setPlainText("")
            logger.error(f"Could not find origin data for ID: {origin_id}")

        self._validate_form() # Re-validate after selection change


    def _toggle_llm(self, state):
        """Toggle LLM enabled state."""
        self.llm_enabled = bool(state)

    def _load_races(self) -> List[str]:
        """Load race names from the configuration."""
        races = [] # Start empty, rely on config
        try:
            config = get_config()
            loaded_races_data = config.get_all("races")
            if loaded_races_data:
                race_names = sorted([data.get('name', race_id) for race_id, data in loaded_races_data.items()])
                if race_names:
                    races = race_names
                    logger.info(f"Loaded {len(races)} races from config.")
                else:
                    logger.warning("No race names found in loaded race data.")
            else:
                logger.warning("Race configuration domain ('races') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading races from config: {e}.")
        return races if races else ["Human"] # Fallback if loading fails

    def _load_classes(self) -> List[str]:
        """Load class names from the configuration."""
        classes = [] # Start empty
        try:
            config = get_config()
            loaded_classes_data = config.get_all("classes")
            if loaded_classes_data:
                class_names = sorted([data.get('name', class_id) for class_id, data in loaded_classes_data.items()])
                if class_names:
                    classes = class_names
                    logger.info(f"Loaded {len(classes)} classes from config.")
                else:
                    logger.warning("No class names found in loaded class data.")
            else:
                logger.warning("Class configuration domain ('classes') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading classes from config: {e}.")
        return classes if classes else ["Wanderer"] # Fallback

    def _load_origins(self) -> List[Dict[str, Any]]:
        """Load origin data (id and name initially) from configuration."""
        origins_data = []
        try:
            config = get_config()
            # Assuming origins.json is loaded under the 'origins' key
            loaded_origins_dict = config.get_all("origins")
            if loaded_origins_dict and isinstance(loaded_origins_dict, dict):
                 # Store the full data for later lookup
                origins_data = list(loaded_origins_dict.values())
                # Sort by name for display
                origins_data.sort(key=lambda x: x.get('name', 'Unknown Origin'))
                logger.info(f"Loaded {len(origins_data)} origins from config.")
            else:
                logger.warning("Origin configuration domain ('origins') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading origins from config: {e}.")
        return origins_data

    def scan_character_icons(self, race: str, class_name: str, sex: str):
        """
        Scan for character icons in the specific race/class directory
        and filter based on sex.
        """
        self.character_icons = [] # Clear previous icons
        self.current_icon_index = 0

        if not race or not class_name or not sex or "No " in race or "No " in class_name: # Added check for placeholder text
            logger.warning(f"Cannot scan icons: Race ('{race}'), Class ('{class_name}'), or Sex ('{sex}') not validly selected.")
            self._display_current_icon() # Display "No Icons Found" or similar
            return

        try:
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            # Construct specific directory path (e.g., images/character_icons/Human_Warrior)
            safe_race = race.replace(" ", "_")
            safe_class_name = class_name.replace(" ", "_")
            specific_icons_dir = os.path.join(project_root, "images", "character_icons", f"{safe_race}_{safe_class_name}")
            logger.debug(f"Scanning for icons in specific directory: {specific_icons_dir}")

            if not os.path.exists(specific_icons_dir):
                logger.warning(f"Icon directory not found: {specific_icons_dir}")
                self._display_current_icon() # Display "No Icons Found"
                return

            supported_extensions = [".png", ".jpg", ".jpeg", ".gif", ".svg"]

            # Scan and filter files
            for filename in os.listdir(specific_icons_dir):
                if any(filename.lower().endswith(ext) for ext in supported_extensions):
                    name_part_lower = os.path.splitext(filename)[0].lower()
                    sex_lower = sex.lower()
                    include_file = False

                    contains_male_keyword = "male" in name_part_lower
                    contains_female_keyword = "female" in name_part_lower

                    if sex_lower == "male":
                        # Include if "male" is present AND "female" is NOT present
                        if contains_male_keyword and not contains_female_keyword:
                            include_file = True
                    elif sex_lower == "female":
                        # Include if "female" is present
                        if contains_female_keyword:
                            include_file = True
                    elif sex_lower == "other":
                        # Include if either "male" or "female" is present
                        if contains_male_keyword or contains_female_keyword:
                            include_file = True
                    
                    if include_file:
                        file_path = os.path.join(specific_icons_dir, filename)
                        self.character_icons.append({
                            "filename": filename,
                            "path": file_path
                        })

            # Sort the icons by filename
            self.character_icons.sort(key=lambda x: x["filename"])

            logger.info(f"Found {len(self.character_icons)} suitable icons in {specific_icons_dir} for sex '{sex}'.")

        except OSError as e:
            logger.error(f"Error reading icons directory {specific_icons_dir}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error scanning icons: {e}", exc_info=True)

        # Display the first found icon (or "No Icons Found")
        self._display_current_icon()
    def _connect_signals(self):
        """Connect signals to slots."""
        self.player_name_edit.textChanged.connect(self._validate_form)
        self.race_combo.currentIndexChanged.connect(self._validate_form)
        self.path_combo.currentIndexChanged.connect(self._validate_form)
        self.origin_combo.currentIndexChanged.connect(self._validate_form) # Validate on origin change too
        self.origin_combo.currentIndexChanged.connect(self._on_origin_selected) # Update details on change

        self.llm_checkbox.stateChanged.connect(self._toggle_llm)
        self.prev_icon_button.clicked.connect(self._show_previous_icon)
        self.next_icon_button.clicked.connect(self._show_next_icon)

        self.cancel_button.clicked.connect(self.reject)
        self.create_button.clicked.connect(self.accept)

    def _validate_form(self):
        """Validate the form and enable/disable the create button."""
        has_name = bool(self.player_name_edit.text().strip())
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0 # Check index too
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        # Check if a valid origin (not the placeholder) is selected
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0

        self.create_button.setEnabled(
            has_name and
            race_selected and
            class_selected and
            origin_selected
        )

    def _show_previous_icon(self):
        """Show the previous character icon."""
        # (Keep existing implementation)
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index - 1 + len(self.character_icons)) % len(self.character_icons)
        self._display_current_icon()


    def _show_next_icon(self):
        """Show the next character icon."""
        # (Keep existing implementation)
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index + 1) % len(self.character_icons)
        self._display_current_icon()

    def _display_current_icon(self):
        """Display the current character icon."""
        # (Keep existing implementation, ensure counter updates)
        if not self.character_icons:
            self.selected_icon_path = None
            self.icon_label.setText("No Icons Found")
            self.icon_counter_label.setText("0 / 0")
            return

        icon_info = self.character_icons[self.current_icon_index]
        icon_path = icon_info['path']
        self.icon_counter_label.setText(f"{self.current_icon_index + 1} / {len(self.character_icons)}")

        try:
            pixmap = QPixmap(icon_path)
            if not pixmap.isNull():
                pixmap = pixmap.scaled(self.icon_label.width(), self.icon_label.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.icon_label.setPixmap(pixmap)
                self.selected_icon_path = icon_path
            else:
                self.icon_label.setText("Load Error")
                self.selected_icon_path = None
        except Exception as e:
            logger.error(f"Error loading icon '{icon_path}': {e}")
            self.icon_label.setText("Load Error")
            self.selected_icon_path = None

    def get_character_data(self) -> Optional[Dict[str, Any]]:
        """Get the character data from the form, including origin_id."""
        name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText() if self.race_combo.isEnabled() else None
        path = self.path_combo.currentText() if self.path_combo.isEnabled() else None
        origin_id = self.origin_combo.currentData() if self.origin_combo.isEnabled() else None # Get origin ID from data

        # Basic validation
        if not name or not race or not path or origin_id is None: # Check origin_id too
             logger.error("Cannot get character data: Name, Race, Class, or Origin is missing or invalid.")
             QMessageBox.warning(self, "Missing Information", "Please select a valid Race, Class, and Origin.")
             return None

        data = {
            'name': name,
            'race': race,
            'path': path,
            'origin_id': origin_id, # Add origin ID
            'sex': self.sex_combo.currentText(),
            # Use edited description if provided, otherwise use the original intro text from selected origin
            'description': self.description_edit.toPlainText().strip() if self.description_edit.toPlainText().strip() else (self.selected_origin_data.get('introduction_text', '') if self.selected_origin_data else ''),
            'use_llm': self.llm_enabled,
            'character_image': self.selected_icon_path
        }

        return data
```

### File: ..\gui\dialogs\save_game_dialog.py

```python
#!/usr/bin/env python3
"""
Save game dialog for the RPG game GUI.
This module provides a dialog for saving the game.
"""

import logging
import os
from typing import Optional, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QGroupBox, QListWidget, QListWidgetItem
)
from PySide6.QtCore import Qt, Signal, Slot

class SaveGameDialog(QDialog):
    """Dialog for saving the game."""
    
    def __init__(self, parent=None):
        """Initialize the save game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Save Game")
        self.setMinimumWidth(400)
        self.setMinimumHeight(300)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QLineEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create save name input section
        name_layout = QVBoxLayout()
        
        # Create save name label
        name_label = QLabel("Save Name:")
        
        # Create save name edit
        self.save_name_edit = QLineEdit()
        self.save_name_edit.setPlaceholderText("Enter a name for this save...")
        
        # Add widgets to name layout
        name_layout.addWidget(name_label)
        name_layout.addWidget(self.save_name_edit)
        
        # Add name layout to main layout
        main_layout.addLayout(name_layout)
        
        # Create existing saves group
        existing_group = QGroupBox("Existing Saves")
        existing_layout = QVBoxLayout(existing_group)
        existing_layout.setContentsMargins(10, 20, 10, 10)
        
        # Create existing saves list
        self.saves_list = QListWidget()
        self.saves_list.setAlternatingRowColors(True)
        
        # Add saves list to existing layout
        existing_layout.addWidget(self.saves_list)
        
        # Add existing group to main layout
        main_layout.addWidget(existing_group)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create save button
        self.save_button = QPushButton("Save Game")
        self.save_button.setEnabled(False)  # Disable until name is entered
        self.save_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.save_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load existing saves
        self._load_existing_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Enable/disable save button based on name field
        self.save_name_edit.textChanged.connect(self._validate_form)
        
        # Update name field when an existing save is selected
        self.saves_list.itemClicked.connect(self._on_save_selected)
    
    def _validate_form(self):
        """Validate the form and enable/disable the save button."""
        # Check if name is not empty
        has_name = bool(self.save_name_edit.text().strip())
        
        # Enable/disable save button
        self.save_button.setEnabled(has_name)
    
    def _load_existing_saves(self):
        """Load existing saves into the list."""
        # Clear the list
        self.saves_list.clear()
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to list
        for save_file in save_files:
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Create and add the item
            item = QListWidgetItem(save_name)
            self.saves_list.addItem(item)
    
    def _on_save_selected(self, item):
        """Handle save selection."""
        # Set the save name edit to the selected save
        self.save_name_edit.setText(item.text())

```

### File: ..\gui\utils\init_settings.py

```python
#!/usr/bin/env python3
"""
Initialize application settings with default values if they don't exist.
"""

import logging
from PySide6.QtCore import QSettings

def init_default_settings():
    """Initialize default settings if they don't exist."""

    settings = QSettings("RPGGame", "Settings")

    # Check if style settings exist and create defaults if not
    if not settings.contains("style/output_bg_color"):
        settings.setValue("style/output_bg_color", "#D2B48C")  # Light brown

    if not settings.contains("style/system_msg_color"):
        settings.setValue("style/system_msg_color", "#FF0000")  # Red

    if not settings.contains("style/font_family"):
        settings.setValue("style/font_family", "Garamond")

    if not settings.contains("style/font_size"):
        settings.setValue("style/font_size", 14)

    if not settings.contains("style/font_color"):
        settings.setValue("style/font_color", "#000000")  # Black

    # Initialize texture and transparency settings
    if not settings.contains("style/texture_name"):
        settings.setValue("style/texture_name", "subtle_noise")

    if not settings.contains("style/output_opacity"):
        settings.setValue("style/output_opacity", 100)

    if not settings.contains("style/input_opacity"):
        settings.setValue("style/input_opacity", 100)

    # Initialize display settings if they don't exist
    if not settings.contains("display/resolution"):
        settings.setValue("display/resolution", (1280, 720))

    if not settings.contains("display/mode"):
        settings.setValue("display/mode", "windowed")

    if not settings.contains("display/ui_scale"):
        settings.setValue("display/ui_scale", 1.0)
    # Initialize text speed setting
    if not settings.contains("display/text_speed_delay"):
        settings.setValue("display/text_speed_delay", 30) # Default delay in ms per character

    # Initialize sound settings if they don't exist
    if not settings.contains("sound/master_volume"):
        settings.setValue("sound/master_volume", 100)

    if not settings.contains("sound/music_volume"):
        settings.setValue("sound/music_volume", 100)

    if not settings.contains("sound/effects_volume"):
        settings.setValue("sound/effects_volume", 100)

    if not settings.contains("sound/enabled"):
        settings.setValue("sound/enabled", True)

    # Initialize gameplay settings if they don't exist
    if not settings.contains("gameplay/difficulty"):
        settings.setValue("gameplay/difficulty", "Normal")

    if not settings.contains("gameplay/autosave_interval"):
        settings.setValue("gameplay/autosave_interval", 0)

    if not settings.contains("gameplay/tutorial_enabled"):
        settings.setValue("gameplay/tutorial_enabled", True)

    # Sync settings to disk
    settings.sync()

    logging.info("Default settings initialized")

```

### File: ..\gui\utils\resource_manager.py

```python
#!/usr/bin/env python3
"""
Resource manager for the RPG game GUI.
This module provides a centralized system for loading and managing GUI resources.
"""

import os
import logging
from typing import Dict, Optional, List, Tuple

from PySide6.QtGui import QPixmap, QIcon, QMovie # Added QMovie
from PySide6.QtCore import QSize, QByteArray # Added QByteArray for QMovie

class ResourceManager:
    """Manages the loading and caching of GUI resources."""
    
    _instance = None
    
    def __new__(cls):
        """Singleton pattern implementation."""
        if cls._instance is None:
            cls._instance = super(ResourceManager, cls).__new__(cls)
            cls._instance._initialize()
        return cls._instance
    
    def _initialize(self):
        """Initialize the resource manager."""
        # Cache for loaded resources
        self._pixmap_cache: Dict[str, QPixmap] = {}
        self._icon_cache: Dict[str, QIcon] = {}
        self._movie_cache: Dict[str, QMovie] = {} # Added movie cache

        # Base paths
        self.gui_path = os.path.join("images", "gui")
        self.background_path = os.path.join(self.gui_path, "background") # --- ADDED ---
        
    def get_pixmap(self, name: str, default_size: Optional[QSize] = None) -> QPixmap:
        """
        Get a pixmap resource.
        
        Args:
            name: The resource name (without path or extension)
            default_size: Optional default size for the pixmap
            
        Returns:
            The loaded pixmap
        """
        # Check cache first
        if name in self._pixmap_cache:
            pixmap = self._pixmap_cache[name]
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
            return pixmap
        
        # Try to load the resource
        full_path = os.path.join(self.gui_path, f"{name}.png")
        
        try:
            pixmap = QPixmap(full_path)
            
            if pixmap.isNull():
                logging.warning(f"Failed to load pixmap: {full_path}")
                # Return an empty pixmap
                pixmap = QPixmap()
            else:
                # Cache the resource
                self._pixmap_cache[name] = pixmap
                
            # Scale if needed
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
                
            return pixmap
            
        except Exception as e:
            logging.error(f"Error loading pixmap {full_path}: {e}")
            return QPixmap()
    
    def get_icon(self, name: str) -> QIcon:
        """
        Get an icon resource.
        
        Args:
            name: The resource name (without path or extension)
            
        Returns:
            The loaded icon
        """
        # Check cache first
        if name in self._icon_cache:
            return self._icon_cache[name]
        
        # Try to load the resource
        try:
            # For button states, check for specific state images
            states = {
                "normal": f"{name}.png",
                "hover": f"{name}_hover.png",
                "pressed": f"{name}_pressed.png",
                "disabled": f"{name}_disabled.png"
            }
            
            # Create icon
            icon = QIcon()
            
            # Add states if they exist
            for state_name, filename in states.items():
                full_path = os.path.join(self.gui_path, filename)
                if os.path.exists(full_path):
                    pixmap = QPixmap(full_path)
                    if not pixmap.isNull():
                        if state_name == "normal":
                            icon.addPixmap(pixmap, QIcon.Normal, QIcon.Off)
                        elif state_name == "hover":
                            icon.addPixmap(pixmap, QIcon.Active, QIcon.Off)
                        elif state_name == "pressed":
                            icon.addPixmap(pixmap, QIcon.Selected, QIcon.Off)
                        elif state_name == "disabled":
                            icon.addPixmap(pixmap, QIcon.Disabled, QIcon.Off)
            
            # If no states were added, try to add the base name
            if icon.isNull():
                pixmap = self.get_pixmap(name)
                if not pixmap.isNull():
                    icon.addPixmap(pixmap)
            
            # Cache the icon
            self._icon_cache[name] = icon
            
            return icon
            
        except Exception as e:
            logging.error(f"Error loading icon {name}: {e}")
            return QIcon()
    

    def list_background_names(self) -> List[Tuple[str, str]]:
        """List available background image/animation names and their extensions."""
        backgrounds = []
        if not os.path.isdir(self.background_path):
            logging.warning(f"Background directory not found: {self.background_path}")
            return backgrounds
        try:
            for filename in os.listdir(self.background_path):
                name, ext = os.path.splitext(filename)
                ext_lower = ext.lower()
                if ext_lower in [".png", ".gif"]:
                    backgrounds.append((name, ext)) # Store name and extension
        except Exception as e:
            logging.error(f"Error listing backgrounds in {self.background_path}: {e}")
        return sorted(backgrounds, key=lambda x: x[0]) # Sort by name

    def get_background_pixmap(self, name: str) -> QPixmap:
        """
        Get a pixmap resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded pixmap
        """
        cache_key = f"background_{name}"
        # Check cache first
        if cache_key in self._pixmap_cache:
            return self._pixmap_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.png")

        try:
            pixmap = QPixmap(full_path)

            if pixmap.isNull():
                logging.warning(f"Failed to load background pixmap: {full_path}")
                pixmap = QPixmap() # Return an empty pixmap
            else:
                # Cache the resource
                self._pixmap_cache[cache_key] = pixmap

            return pixmap

        except Exception as e:
            logging.error(f"Error loading background pixmap {full_path}: {e}")
            return QPixmap()

    def get_background_movie(self, name: str) -> QMovie:
        """
        Get a QMovie resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded QMovie
        """
        cache_key = f"background_movie_{name}"
        # Check cache first
        if cache_key in self._movie_cache:
            # Return a new QMovie instance pointing to the same data if needed,
            # but for simplicity, let's assume sharing the instance is okay for now.
            # If issues arise, create new QMovie(self._movie_cache[cache_key].fileName())
            return self._movie_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.gif")

        try:
            # QMovie needs the path, not raw data like QPixmap sometimes uses
            movie = QMovie(full_path)

            if not movie.isValid():
                logging.warning(f"Failed to load or invalid background movie: {full_path}")
                # Return an empty/invalid movie
                return QMovie()
            else:
                # Cache the resource
                self._movie_cache[cache_key] = movie
                return movie

        except Exception as e:
            logging.error(f"Error loading background movie {full_path}: {e}")
            return QMovie()

    def clear_cache(self):
        """Clear the resource cache."""
        self._pixmap_cache.clear()
        self._icon_cache.clear()
        self._movie_cache.clear() # Clear movie cache

# Global instance for easy access
def get_resource_manager() -> ResourceManager:
    """Get the singleton resource manager instance."""
    return ResourceManager()

```

### File: models\__init__.py

```python
"""
Models for the World Configurator Tool.
"""

```

### File: models\base_models.py

```python
"""
Base data models for the World Configurator Tool.
"""

from dataclasses import dataclass, field, asdict, fields # Added 'fields' import
from typing import Dict, List, Any, Optional, Union, Literal
import json
import uuid
import logging

logger = logging.getLogger("world_configurator.models")

@dataclass
class BaseModel:
    """Base class for all data models."""

    def to_dict(self) -> Dict[str, Any]:
        """Convert the model to a dictionary."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'BaseModel':
        """Create a model instance from a dictionary."""
        # Basic implementation, might need overrides in subclasses for complex types
        # Filter data to only include fields defined in the dataclass
        known_fields = {f.name for f in fields(cls)} # Use imported 'fields'
        filtered_data = {k: v for k, v in data.items() if k in known_fields}
        try:
            return cls(**filtered_data)
        except TypeError as e:
            logger.error(f"Error creating {cls.__name__} from dict. Data: {filtered_data}, Error: {e}")
            # Attempt to create with minimal required fields if possible, or raise
            # This part depends on how you want to handle partial data.
            # For now, re-raising might be safer.
            raise e

    def to_json(self, indent: int = 2) -> str:
        """Convert the model to a JSON string."""
        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)

    @classmethod
    def from_json(cls, json_str: str) -> 'BaseModel':
        """Create a model instance from a JSON string."""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @staticmethod
    def generate_id() -> str:
        """Generate a unique ID."""
        return str(uuid.uuid4())


@dataclass
class WorldModelState:
    """
    Tracks the state of a model (modified status, etc.)
    """
    modified: bool = False
    path: Optional[str] = None

    def mark_modified(self) -> None:
        """Mark the model as modified."""
        self.modified = True

    def mark_saved(self, path: str) -> None:
        """Mark the model as saved."""
        self.modified = False
        self.path = path

# --- Culture Related ---
@dataclass
class CultureValue:
    """
    Represents a cultural value.
    """
    name: str
    description: str
    importance: int = 5  # 1-10 scale

@dataclass
class Tradition:
    """
    Represents a cultural tradition.
    """
    name: str
    description: str
    occasion: str
    significance: str

@dataclass
class Culture(BaseModel):
    """
    Represents a culture in the game world.
    """
    id: str
    name: str
    description: str
    values: List[CultureValue] = field(default_factory=list)
    traditions: List[Tradition] = field(default_factory=list)
    language_style: str = ""
    naming_conventions: Dict[str, str] = field(default_factory=dict)
    common_traits: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'Culture':
        """Create a new culture with a unique ID."""
        culture_id = cls.generate_id()
        return cls(
            id=culture_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Culture':
        """Create a culture instance from a dictionary."""
        data_copy = data.copy()
        if 'values' in data_copy and isinstance(data_copy['values'], list):
            values = []
            for value_data in data_copy['values']:
                if isinstance(value_data, dict):
                    values.append(CultureValue(**value_data))
                elif isinstance(value_data, CultureValue): # Handle already converted objects
                    values.append(value_data)
            data_copy['values'] = values

        if 'traditions' in data_copy and isinstance(data_copy['traditions'], list):
            traditions = []
            for tradition_data in data_copy['traditions']:
                if isinstance(tradition_data, dict):
                    traditions.append(Tradition(**tradition_data))
                elif isinstance(tradition_data, Tradition): # Handle already converted objects
                    traditions.append(tradition_data)
            data_copy['traditions'] = traditions

        # Use superclass from_dict for basic field assignment after handling nested lists
        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)


# --- Location Related ---
@dataclass
class LocationConnection:
    """
    Represents a connection between locations.
    """
    target: str  # ID of the target location
    description: str
    travel_time: int  # In minutes
    requirements: List[str] = field(default_factory=list)

@dataclass
class LocationFeature:
    """
    Represents a special feature of a location.
    """
    name: str
    description: str
    interaction_type: str = "none"  # none, examine, use, etc.

@dataclass
class Location(BaseModel):
    """
    Represents a location in the game world.
    """
    id: str
    name: str
    description: str
    type: str  # village, city, dungeon, etc.
    region: str = ""
    culture_id: str = ""
    population: int = 0
    features: List[LocationFeature] = field(default_factory=list)
    connections: List[LocationConnection] = field(default_factory=list)
    npcs: List[str] = field(default_factory=list)  # IDs of important NPCs

    @classmethod
    def create_new(cls, name: str, description: str, location_type: str) -> 'Location':
        """Create a new location with a unique ID."""
        location_id = cls.generate_id()
        return cls(
            id=location_id,
            name=name,
            description=description,
            type=location_type
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Location':
        """Create a location instance from a dictionary."""
        data_copy = data.copy()
        if 'features' in data_copy and isinstance(data_copy['features'], list):
            features = []
            for feature_data in data_copy['features']:
                if isinstance(feature_data, dict):
                    features.append(LocationFeature(**feature_data))
                elif isinstance(feature_data, LocationFeature):
                    features.append(feature_data)
            data_copy['features'] = features

        if 'connections' in data_copy and isinstance(data_copy['connections'], list):
            connections = []
            for connection_data in data_copy['connections']:
                if isinstance(connection_data, dict):
                    connections.append(LocationConnection(**connection_data))
                elif isinstance(connection_data, LocationConnection):
                    connections.append(connection_data)
            data_copy['connections'] = connections

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

# --- History Related ---
@dataclass
class HistoricalEvent:
    """
    Represents a significant historical event.
    """
    year: int
    title: str
    description: str
    significance: str = ""
    affected_locations: List[str] = field(default_factory=list)
    affected_cultures: List[str] = field(default_factory=list)

@dataclass
class Era:
    """
    Represents a historical era.
    """
    name: str
    start_year: int
    end_year: int
    description: str
    events: List[HistoricalEvent] = field(default_factory=list)

@dataclass
class WorldHistory(BaseModel):
    """
    Represents the history of the game world.
    """
    name: str
    description: str
    current_year: int
    eras: List[Era] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str, current_year: int) -> 'WorldHistory':
        """Create a new world history."""
        return cls(
            name=name,
            description=description,
            current_year=current_year
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldHistory':
        """Create a world history instance from a dictionary."""
        data_copy = data.copy()
        if 'eras' in data_copy and isinstance(data_copy['eras'], list):
            eras = []
            for era_data in data_copy['eras']:
                if isinstance(era_data, dict):
                    events = []
                    if 'events' in era_data and isinstance(era_data['events'], list):
                        for event_data in era_data['events']:
                            if isinstance(event_data, dict):
                                events.append(HistoricalEvent(**event_data))
                            elif isinstance(event_data, HistoricalEvent):
                                events.append(event_data)
                    era_data['events'] = events # Update the dict before creating Era
                    eras.append(Era(**era_data))
                elif isinstance(era_data, Era):
                    eras.append(era_data)
            data_copy['eras'] = eras

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

# --- Quest Related ---
@dataclass
class QuestObjective:
    """
    Represents an objective in a quest.
    """
    id: str
    description: str
    type: str  # fetch, kill, escort, etc.
    target_id: str = ""
    location_id: str = ""
    completion_criteria: str = ""
    rewards: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Quest(BaseModel):
    """
    Represents a quest in the game.
    """
    id: str
    title: str
    description: str
    giver_id: str = ""
    level: int = 1
    objectives: List[QuestObjective] = field(default_factory=list)
    rewards: Dict[str, Any] = field(default_factory=dict)
    prerequisites: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, title: str, description: str) -> 'Quest':
        """Create a new quest with a unique ID."""
        quest_id = cls.generate_id()
        return cls(
            id=quest_id,
            title=title,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Quest':
        """Create a quest instance from a dictionary."""
        data_copy = data.copy()
        if 'objectives' in data_copy and isinstance(data_copy['objectives'], list):
            objectives = []
            for obj_data in data_copy['objectives']:
                if isinstance(obj_data, dict):
                    if 'id' not in obj_data: obj_data['id'] = cls.generate_id() # Ensure ID
                    objectives.append(QuestObjective(**obj_data))
                elif isinstance(obj_data, QuestObjective):
                    objectives.append(obj_data)
            data_copy['objectives'] = objectives

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

# --- Rules Related ---
@dataclass
class FundamentalRule:
    """
    Represents a fundamental rule of the game world.
    """
    name: str
    description: str
    category: str  # magic, physics, society, etc.
    effects: List[str] = field(default_factory=list)

@dataclass
class WorldRules(BaseModel):
    """
    Represents the fundamental rules of the game world.
    """
    name: str
    description: str
    rules: List[FundamentalRule] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'WorldRules':
        """Create a new world rules definition."""
        return cls(
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldRules':
        """Create a WorldRules instance from a dictionary."""
        data_copy = data.copy()
        if 'rules' in data_copy and isinstance(data_copy['rules'], list):
            rules = []
            for rule_data in data_copy['rules']:
                if isinstance(rule_data, dict):
                    rules.append(FundamentalRule(**rule_data))
                elif isinstance(rule_data, FundamentalRule):
                    rules.append(rule_data)
            data_copy['rules'] = rules

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)


# --- Magic System Related ---
@dataclass
class SpellEffect:
    """
    Represents a single effect of a spell.
    """
    target_type: Literal["caster", "target"] = "target"
    effect_type: Literal["damage", "healing", "stat_modification", "status_effect"] = "damage"
    value: float = 0.0
    stat_affected: str = ""
    status_effect: str = ""
    duration: int = 0
    dice_notation: str = ""
    description: str = ""

@dataclass
class Spell(BaseModel):
    """
    Represents a spell in the magic system.
    """
    id: str
    name: str
    description: str
    mana_cost: int = 0
    casting_time: str = "1 action"
    range: str = "10m"
    target: str = "single"
    effects: List[SpellEffect] = field(default_factory=list)
    level: int = 1
    components: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'Spell':
        """Create a new spell with a unique ID."""
        spell_id = cls.generate_id()
        return cls(
            id=spell_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Spell':
        """Create a spell instance from a dictionary."""
        data_copy = data.copy()
        if 'effects' in data_copy and isinstance(data_copy['effects'], list):
            effects = []
            for effect_data in data_copy['effects']:
                if isinstance(effect_data, dict):
                    effects.append(SpellEffect(**effect_data))
                elif isinstance(effect_data, SpellEffect):
                    effects.append(effect_data)
            data_copy['effects'] = effects

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

@dataclass
class RacialAffinity:
    """
    Represents a race's affinity to a magical system.
    """
    affinity_level: str = "Medium"
    learning_difficulty: str = "Moderate"
    natural_talent: bool = False
    bonus_effects: Optional[str] = None

@dataclass
class ClassAffinity:
    """
    Represents a class's affinity to a magical system.
    """
    affinity_level: str = "Medium"
    learning_difficulty: str = "Moderate"
    required_stats: Dict[str, int] = field(default_factory=dict)

@dataclass
class MagicalSystem(BaseModel):
    """
    Represents a magical system in the game world.
    """
    id: str
    name: str
    description: str
    origin: str = ""
    limitations: str = ""
    practitioners: str = ""
    cultural_significance: str = ""
    racial_affinities: Dict[str, RacialAffinity] = field(default_factory=dict)
    class_affinities: Dict[str, ClassAffinity] = field(default_factory=dict)
    spells: Dict[str, Spell] = field(default_factory=dict)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'MagicalSystem':
        """Create a new magical system with a unique ID."""
        system_id = cls.generate_id()
        return cls(
            id=system_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MagicalSystem':
        """Create a magical system instance from a dictionary."""
        data_copy = data.copy()
        if 'spells' in data_copy and isinstance(data_copy['spells'], dict):
            spells = {}
            for spell_id, spell_data in data_copy['spells'].items():
                if isinstance(spell_data, dict):
                    if 'id' not in spell_data: spell_data['id'] = spell_id
                    spells[spell_id] = Spell.from_dict(spell_data)
                elif isinstance(spell_data, Spell):
                    spells[spell_id] = spell_data
            data_copy['spells'] = spells

        if 'racial_affinities' in data_copy and isinstance(data_copy['racial_affinities'], dict):
            racial_affinities = {}
            for race_name, affinity_data in data_copy['racial_affinities'].items():
                if isinstance(affinity_data, dict):
                    racial_affinities[race_name] = RacialAffinity(**affinity_data)
                elif isinstance(affinity_data, RacialAffinity):
                    racial_affinities[race_name] = affinity_data
            data_copy['racial_affinities'] = racial_affinities

        if 'class_affinities' in data_copy and isinstance(data_copy['class_affinities'], dict):
            class_affinities = {}
            for class_name, affinity_data in data_copy['class_affinities'].items():
                if isinstance(affinity_data, dict):
                    class_affinities[class_name] = ClassAffinity(**affinity_data)
                elif isinstance(affinity_data, ClassAffinity):
                    class_affinities[class_name] = affinity_data
            data_copy['class_affinities'] = class_affinities

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)


# --- Race and Class Related (MOVED HERE) ---
@dataclass
class RaceTrait:
    """Represents a specific trait of a race."""
    name: str
    description: str

@dataclass
class Race(BaseModel):
    """Represents a playable race in the game world."""
    id: str
    name: str
    description: str
    stat_modifiers: Dict[str, int] = field(default_factory=dict)
    traits: List[RaceTrait] = field(default_factory=list)
    recommended_classes: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'Race':
        """Create a new race with a unique ID."""
        race_id = cls.generate_id()
        return cls(
            id=race_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Race':
        """Create a race instance from a dictionary."""
        data_copy = data.copy()
        if 'traits' in data_copy and isinstance(data_copy['traits'], list):
            traits = []
            for trait_data in data_copy['traits']:
                if isinstance(trait_data, dict):
                    traits.append(RaceTrait(**trait_data))
                elif isinstance(trait_data, RaceTrait):
                     traits.append(trait_data)
            data_copy['traits'] = traits

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

@dataclass
class ClassArchetype:
    """Represents a specific archetype or specialization within a class."""
    name: str
    description: str
    stat_distribution: Dict[str, int] = field(default_factory=dict)

@dataclass
class CharacterClass(BaseModel):
    """Represents a character class in the game."""
    id: str
    name: str
    description: str
    stat_modifiers: Dict[str, int] = field(default_factory=dict)
    minimum_stats: Dict[str, int] = field(default_factory=dict)
    recommended_stats: Dict[str, List[str]] = field(default_factory=dict) # e.g., {"primary": ["STR"], "secondary": ["CON"]}
    archetypes: Dict[str, ClassArchetype] = field(default_factory=dict)
    weapon_proficiencies: List[str] = field(default_factory=list)
    armor_proficiencies: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'CharacterClass':
        """Create a new class with a unique ID."""
        class_id = cls.generate_id()
        return cls(
            id=class_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CharacterClass':
        """Create a class instance from a dictionary."""
        data_copy = data.copy()
        if 'archetypes' in data_copy and isinstance(data_copy['archetypes'], dict):
            archetypes = {}
            for arch_name, arch_data in data_copy['archetypes'].items():
                if isinstance(arch_data, dict):
                     # Ensure name is included if missing in nested dict
                    if 'name' not in arch_data:
                        arch_data['name'] = arch_name
                    archetypes[arch_name] = ClassArchetype(**arch_data)
                # If it's already an object, keep it
                elif isinstance(arch_data, ClassArchetype):
                    archetypes[arch_name] = arch_data
            data_copy['archetypes'] = archetypes

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

@dataclass
class OriginTrait:
    """Represents a minor trait granted by an Origin."""
    name: str = ""
    description: str = ""

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'OriginTrait':
        return cls(
            name=data.get("name", ""),
            description=data.get("description", "")
        )

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "description": self.description
        }

@dataclass
class Origin:
    """Represents a starting origin/scenario for a character."""
    id: str = field(default_factory=lambda: f"origin_{uuid.uuid4().hex[:8]}")
    name: str = "New Origin"
    description: str = ""
    starting_location_id: str = ""
    starting_culture_id: Optional[str] = None # Optional culture override
    starting_items: List[str] = field(default_factory=list)
    initial_quests: List[str] = field(default_factory=list)
    suitable_races: List[str] = field(default_factory=list)
    suitable_classes: List[str] = field(default_factory=list)
    introduction_text: str = ""
    skill_proficiencies: List[str] = field(default_factory=list) # NEW
    origin_traits: List[OriginTrait] = field(default_factory=list) # NEW

    @classmethod
    def create_new(cls, name: str, description: str, location_id: str) -> 'Origin':
        """Helper to create a new Origin with a default ID."""
        return cls(
            name=name,
            description=description,
            starting_location_id=location_id
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Origin':
        # Handle optional fields gracefully
        traits_data = data.get("origin_traits", [])
        traits = [OriginTrait.from_dict(t) for t in traits_data if isinstance(t, dict)]

        return cls(
            id=data.get("id", f"origin_{uuid.uuid4().hex[:8]}"),
            name=data.get("name", "Unknown Origin"),
            description=data.get("description", ""),
            starting_location_id=data.get("starting_location_id", data.get("starting_location", "")), # Check old key too
            starting_culture_id=data.get("starting_culture_id"), # Okay if None
            starting_items=data.get("starting_items", []),
            initial_quests=data.get("initial_quests", []),
            suitable_races=data.get("suitable_races", []),
            suitable_classes=data.get("suitable_classes", []),
            introduction_text=data.get("introduction_text", ""),
            skill_proficiencies=data.get("skill_proficiencies", []), # NEW
            origin_traits=traits # NEW
        )

    def to_dict(self) -> Dict[str, Any]:
        # Filter out None values for cleaner JSON, especially for optional culture
        data = {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "starting_location_id": self.starting_location_id,
            "starting_items": self.starting_items,
            "initial_quests": self.initial_quests,
            "suitable_races": self.suitable_races,
            "suitable_classes": self.suitable_classes,
            "introduction_text": self.introduction_text,
            "skill_proficiencies": self.skill_proficiencies, # NEW
            "origin_traits": [t.to_dict() for t in self.origin_traits] # NEW
        }
        if self.starting_culture_id is not None:
            data["starting_culture_id"] = self.starting_culture_id
        return data

# --- World Config Container
@dataclass
class WorldConfig:
    """
    Container for all world configuration data.
    Uses the unified Origin concept.
    """
    cultures: Dict[str, Culture] = field(default_factory=dict)
    locations: Dict[str, Location] = field(default_factory=dict)
    history: Optional[WorldHistory] = None
    rules: Optional[WorldRules] = None
    origins: Dict[str, Origin] = field(default_factory=dict)
    quests: Dict[str, Quest] = field(default_factory=dict)
    magic_systems: Dict[str, MagicalSystem] = field(default_factory=dict)
    races: Dict[str, Race] = field(default_factory=dict)
    classes: Dict[str, CharacterClass] = field(default_factory=dict)
    state: WorldModelState = field(default_factory=WorldModelState)

    def add_race(self, race: Race) -> None:
        """Add a race to the configuration."""
        self.races[race.id] = race
        self.state.mark_modified()

    def add_class(self, char_class: CharacterClass) -> None:
        """Add a character class to the configuration."""
        self.classes[char_class.id] = char_class
        self.state.mark_modified()

    # RENAMED add_scenario to add_origin
    def add_origin(self, origin: Origin) -> None:
        """Add a starting origin to the configuration."""
        self.origins[origin.id] = origin
        self.state.mark_modified()

    def add_culture(self, culture: Culture) -> None:
        """Add a culture to the configuration."""
        self.cultures[culture.id] = culture
        self.state.mark_modified()

    def add_location(self, location: Location) -> None:
        """Add a location to the configuration."""
        self.locations[location.id] = location
        self.state.mark_modified()

    def add_magic_system(self, magic_system: MagicalSystem) -> None:
        """Add a magical system to the configuration."""
        self.magic_systems[magic_system.id] = magic_system
        self.state.mark_modified()

    def set_history(self, history: WorldHistory) -> None:
        """Set the world history."""
        self.history = history
        self.state.mark_modified()

    def set_rules(self, rules: WorldRules) -> None:
        """Set the fundamental rules."""
        self.rules = rules
        self.state.mark_modified()

    def to_dict(self) -> Dict[str, Any]:
        """Convert the configuration to a dictionary."""
        result = {
            "cultures": {k: v.to_dict() for k, v in self.cultures.items()},
            "locations": {k: v.to_dict() for k, v in self.locations.items()},
            "origins": {k: v.to_dict() for k, v in self.origins.items()}, # RENAMED from scenarios
            "quests": {k: v.to_dict() for k, v in self.quests.items()},
            "magic_systems": {k: v.to_dict() for k, v in self.magic_systems.items()},
            "races": {k: v.to_dict() for k, v in self.races.items()},
            "classes": {k: v.to_dict() for k, v in self.classes.items()},
        }
        if self.history: result["history"] = self.history.to_dict()
        if self.rules: result["rules"] = self.rules.to_dict()
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldConfig':
        """Create a configuration from a dictionary."""
        config = cls()
        if "cultures" in data:
            for item_id, item_data in data["cultures"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.cultures[item_id] = Culture.from_dict(item_data)
        if "locations" in data:
            for item_id, item_data in data["locations"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.locations[item_id] = Location.from_dict(item_data)
        if "origins" in data:
            for item_id, item_data in data["origins"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.origins[item_id] = Origin.from_dict(item_data)
        if "quests" in data:
            for item_id, item_data in data["quests"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.quests[item_id] = Quest.from_dict(item_data)
        if "magic_systems" in data:
            for item_id, item_data in data["magic_systems"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.magic_systems[item_id] = MagicalSystem.from_dict(item_data)
        if "history" in data:
            config.history = WorldHistory.from_dict(data["history"])
        if "rules" in data:
            config.rules = WorldRules.from_dict(data["rules"])
        if "races" in data:
            for race_id, race_data in data["races"].items():
                if "id" not in race_data: race_data["id"] = race_id
                config.races[race_id] = Race.from_dict(race_data)
        if "classes" in data:
            for class_id, class_data in data["classes"].items():
                if "id" not in class_data: class_data["id"] = class_id
                config.classes[class_id] = CharacterClass.from_dict(class_data)

        return config

```

### File: models\location_data.py

```python
"""
Location data models for the world configurator.
"""

import logging
import os
import shutil
import datetime
from typing import Dict, List, Any, Optional, Union

from world_configurator.models.base_models import Location, LocationConnection, LocationFeature, WorldModelState
from world_configurator.utils.file_manager import load_json, save_json, get_world_config_dir

logger = logging.getLogger("world_configurator.models.location_data")

class LocationManager:
    """
    Manager for location data.
    """
    def __init__(self):
        self.locations: Dict[str, Location] = {}
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load locations from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "locations" not in data:
                logger.error(f"Invalid locations file format: {file_path}")
                return False
            
            # Clear existing locations
            self.locations.clear()
            
            # Load each location
            for location_id, location_data in data["locations"].items():
                # Ensure the location has an ID
                if "id" not in location_data:
                    location_data["id"] = location_id
                
                location = Location.from_dict(location_data)
                self.locations[location_id] = location
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded {len(self.locations)} locations from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading locations from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save locations to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving locations")
                return False
            
            # Prepare data
            data = {
                "locations": {k: v.to_dict() for k, v in self.locations.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Location definitions for the RPG game world"
                }
            }
            
            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.locations)} locations to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving locations: {e}")
            return False
    
    def add_location(self, location: Location) -> None:
        """
        Add a location to the manager.
        
        Args:
            location: The location to add.
        """
        self.locations[location.id] = location
        self.state.modified = True
        logger.info(f"Added location: {location.name} ({location.id})")
    
    def remove_location(self, location_id: str) -> bool:
        """
        Remove a location from the manager.
        
        Args:
            location_id: The ID of the location to remove.
        
        Returns:
            True if the location was removed, False if it wasn't found.
        """
        if location_id in self.locations:
            del self.locations[location_id]
            self.state.modified = True
            logger.info(f"Removed location: {location_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent location: {location_id}")
            return False
    
    def get_location(self, location_id: str) -> Optional[Location]:
        """
        Get a location by ID.
        
        Args:
            location_id: The ID of the location to get.
        
        Returns:
            The location if found, None otherwise.
        """
        return self.locations.get(location_id)
    
    def add_connection(self, source_id: str, target_id: str, description: str, travel_time: int) -> bool:
        """
        Add a connection between two locations.
        
        Args:
            source_id: The ID of the source location.
            target_id: The ID of the target location.
            description: Description of the connection.
            travel_time: Travel time in minutes.
        
        Returns:
            True if the connection was added, False if a location wasn't found.
        """
        source = self.get_location(source_id)
        target = self.get_location(target_id)
        
        if not source:
            logger.warning(f"Cannot add connection from non-existent location: {source_id}")
            return False
        
        if not target:
            logger.warning(f"Cannot add connection to non-existent location: {target_id}")
            return False
        
        # Create connection
        connection = LocationConnection(
            target=target_id,
            description=description,
            travel_time=travel_time
        )
        
        # Add to source location
        source.connections.append(connection)
        self.state.modified = True
        
        logger.info(f"Added connection from {source_id} to {target_id}")
        return True
    
    def remove_connection(self, source_id: str, target_id: str) -> bool:
        """
        Remove a connection between two locations.
        
        Args:
            source_id: The ID of the source location.
            target_id: The ID of the target location.
        
        Returns:
            True if the connection was removed, False if a location or connection wasn't found.
        """
        source = self.get_location(source_id)
        
        if not source:
            logger.warning(f"Cannot remove connection from non-existent location: {source_id}")
            return False
        
        for i, connection in enumerate(source.connections):
            if connection.target == target_id:
                source.connections.pop(i)
                self.state.modified = True
                logger.info(f"Removed connection from {source_id} to {target_id}")
                return True
        
        logger.warning(f"No connection found from {source_id} to {target_id}")
        return False
    
    def add_feature_to_location(self, location_id: str, feature: LocationFeature) -> bool:
        """
        Add a feature to a location.
        
        Args:
            location_id: The ID of the location to modify.
            feature: The feature to add.
        
        Returns:
            True if the feature was added, False if the location wasn't found.
        """
        location = self.get_location(location_id)
        if not location:
            logger.warning(f"Cannot add feature to non-existent location: {location_id}")
            return False
        
        location.features.append(feature)
        self.state.modified = True
        logger.info(f"Added feature to location {location_id}: {feature.name}")
        return True
    
    def remove_feature_from_location(self, location_id: str, feature_name: str) -> bool:
        """
        Remove a feature from a location.
        
        Args:
            location_id: The ID of the location to modify.
            feature_name: The name of the feature to remove.
        
        Returns:
            True if the feature was removed, False if the location or feature wasn't found.
        """
        location = self.get_location(location_id)
        if not location:
            logger.warning(f"Cannot remove feature from non-existent location: {location_id}")
            return False
        
        for i, feature in enumerate(location.features):
            if feature.name == feature_name:
                location.features.pop(i)
                self.state.modified = True
                logger.info(f"Removed feature {feature_name} from location {location_id}")
                return True
        
        logger.warning(f"No feature named {feature_name} found in location {location_id}")
        return False
    
    def verify_connections(self) -> List[str]:
        """
        Verify that all connections reference valid location IDs.
        
        Returns:
            A list of error messages, or an empty list if all connections are valid.
        """
        errors = []
        
        for location_id, location in self.locations.items():
            for i, connection in enumerate(location.connections):
                if connection.target not in self.locations:
                    error = f"Location {location_id} has invalid connection to non-existent location: {connection.target}"
                    errors.append(error)
                    logger.warning(error)
        
        return errors
    
    def export_to_game(self) -> bool:
        """
        Export locations to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "locations")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "locations.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting locations to game: {e}")
            return False

```

### File: models\origin_data.py

```python
# world_configurator/models/origin_data.py
"""
Origin data models for starting origins.
(Formerly Scenario Data)
"""

import logging
import os
import shutil
import datetime
from typing import Dict, List, Any, Optional, Union

# Assuming Origin model exists in base_models with the new fields
from world_configurator.models.base_models import Origin, Quest, QuestObjective, WorldModelState
from world_configurator.utils.file_manager import load_json, save_json, get_world_config_dir

logger = logging.getLogger("world_configurator.models.origin_data") # Updated logger name

class OriginManager: # Renamed class
    """
    Manager for starting origin data.
    """
    def __init__(self):
        self.origins: Dict[str, Origin] = {} # Renamed variable and type hint
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """
        Load origins from a JSON file.

        Args:
            file_path: Path to the JSON file.

        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            # Check for 'origins' key instead of 'scenarios'
            if not data or "origins" not in data:
                logger.error(f"Invalid origins file format: {file_path}")
                return False

            # Clear existing origins
            self.origins.clear() # Renamed variable

            # Load each origin
            for origin_id, origin_data in data["origins"].items(): # Use 'origins' key
                # Ensure the origin has an ID
                if "id" not in origin_data:
                    origin_data["id"] = origin_id

                origin = Origin.from_dict(origin_data) # Use Origin model
                self.origins[origin_id] = origin # Renamed variable

            # Update state
            self.state.path = file_path
            self.state.modified = False

            logger.info(f"Loaded {len(self.origins)} origins from {file_path}") # Renamed log message
            return True
        except Exception as e:
            logger.error(f"Error loading origins from {file_path}: {e}", exc_info=True) # Added exc_info
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save origins to a JSON file.

        Args:
            file_path: Path to the JSON file. If None, uses the path from state.

        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving origins")
                return False

            # Prepare data
            data = {
                # Use 'origins' key
                "origins": {k: v.to_dict() for k, v in self.origins.items()}, # Renamed variable
                "metadata": {
                    "version": "1.0.1", # Updated version
                    "description": "Starting origin definitions for the RPG game world" # Updated description
                }
            }

            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.origins)} origins to {path}") # Renamed log message

            return result
        except Exception as e:
            logger.error(f"Error saving origins: {e}", exc_info=True) # Added exc_info
            return False

    def add_origin(self, origin: Origin) -> None: # Renamed method and type hint
        """
        Add an origin to the manager.

        Args:
            origin: The origin to add.
        """
        self.origins[origin.id] = origin # Renamed variable
        self.state.modified = True
        logger.info(f"Added origin: {origin.name} ({origin.id})")

    def remove_origin(self, origin_id: str) -> bool: # Renamed method
        """
        Remove an origin from the manager.

        Args:
            origin_id: The ID of the origin to remove.

        Returns:
            True if the origin was removed, False if it wasn't found.
        """
        if origin_id in self.origins: # Renamed variable
            del self.origins[origin_id] # Renamed variable
            self.state.modified = True
            logger.info(f"Removed origin: {origin_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent origin: {origin_id}")
            return False

    def get_origin(self, origin_id: str) -> Optional[Origin]: # Renamed method and return type
        """
        Get an origin by ID.

        Args:
            origin_id: The ID of the origin to get.

        Returns:
            The origin if found, None otherwise.
        """
        return self.origins.get(origin_id) # Renamed variable

    def export_to_game(self) -> bool:
        """
        Export origins to the game's configuration directory.

        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path - Changed filename
            target_dir = os.path.join(get_world_config_dir(), "scenarios") # Keep subfolder for now
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "origins.json") # Changed filename

            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)

                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails

            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting origins to game: {e}", exc_info=True) # Added exc_info
            return False

# --- QuestManager remains the same ---
# (Assuming Quest data structure hasn't changed)
# ... (Keep existing QuestManager class here) ...
class QuestManager:
    """
    Manager for quest data.
    """
    def __init__(self):
        self.quests: Dict[str, Quest] = {}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """
        Load quests from a JSON file.

        Args:
            file_path: Path to the JSON file.

        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "quests" not in data:
                logger.error(f"Invalid quests file format: {file_path}")
                return False

            # Clear existing quests
            self.quests.clear()

            # Load each quest
            for quest_id, quest_data in data["quests"].items():
                # Ensure the quest has an ID
                if "id" not in quest_data:
                    quest_data["id"] = quest_id

                quest = Quest.from_dict(quest_data)
                self.quests[quest_id] = quest

            # Update state
            self.state.path = file_path
            self.state.modified = False

            logger.info(f"Loaded {len(self.quests)} quests from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading quests from {file_path}: {e}")
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save quests to a JSON file.

        Args:
            file_path: Path to the JSON file. If None, uses the path from state.

        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving quests")
                return False

            # Prepare data
            data = {
                "quests": {k: v.to_dict() for k, v in self.quests.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Quest definitions for the RPG game world"
                }
            }

            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.quests)} quests to {path}")

            return result
        except Exception as e:
            logger.error(f"Error saving quests: {e}")
            return False

    def add_quest(self, quest: Quest) -> None:
        """
        Add a quest to the manager.

        Args:
            quest: The quest to add.
        """
        self.quests[quest.id] = quest
        self.state.modified = True
        logger.info(f"Added quest: {quest.title} ({quest.id})")

    def remove_quest(self, quest_id: str) -> bool:
        """
        Remove a quest from the manager.

        Args:
            quest_id: The ID of the quest to remove.

        Returns:
            True if the quest was removed, False if it wasn't found.
        """
        if quest_id in self.quests:
            del self.quests[quest_id]
            self.state.modified = True
            logger.info(f"Removed quest: {quest_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent quest: {quest_id}")
            return False

    def get_quest(self, quest_id: str) -> Optional[Quest]:
        """
        Get a quest by ID.

        Args:
            quest_id: The ID of the quest to get.

        Returns:
            The quest if found, None otherwise.
        """
        quest = self.quests.get(quest_id)

        # Ensure we're returning a Quest object, not a dict
        if quest and isinstance(quest, dict):
            try:
                quest = Quest.from_dict(quest)
                self.quests[quest_id] = quest  # Update the dictionary with the object
                logger.info(f"Converted dict to Quest object for {quest_id}")
            except Exception as e:
                logger.error(f"Error converting quest dict to object for {quest_id}: {str(e)}")

        return quest

    def add_objective_to_quest(self, quest_id: str, objective: QuestObjective) -> bool:
        """
        Add an objective to a quest.

        Args:
            quest_id: The ID of the quest to modify.
            objective: The objective to add.

        Returns:
            True if the objective was added, False if the quest wasn't found.
        """
        quest = self.get_quest(quest_id)
        if not quest:
            logger.warning(f"Cannot add objective to non-existent quest: {quest_id}")
            return False

        quest.objectives.append(objective)
        self.state.modified = True
        logger.info(f"Added objective to quest {quest_id}: {objective.description}")
        return True

    def remove_objective_from_quest(self, quest_id: str, objective_id: str) -> bool:
        """
        Remove an objective from a quest.

        Args:
            quest_id: The ID of the quest to modify.
            objective_id: The ID of the objective to remove.

        Returns:
            True if the objective was removed, False if the quest or objective wasn't found.
        """
        quest = self.get_quest(quest_id)
        if not quest:
            logger.warning(f"Cannot remove objective from non-existent quest: {quest_id}")
            return False

        initial_len = len(quest.objectives)
        quest.objectives = [obj for obj in quest.objectives if obj.id != objective_id]

        if len(quest.objectives) < initial_len:
             self.state.modified = True
             logger.info(f"Removed objective {objective_id} from quest {quest_id}")
             return True
        else:
             logger.warning(f"Cannot remove non-existent objective {objective_id} from quest {quest_id}")
             return False


    def export_to_game(self) -> bool:
        """
        Export quests to the game's configuration directory.

        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "scenarios") # Keep quests in scenarios subfolder for now
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "quests.json")

            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)

                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails

            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting quests to game: {e}")
            return False
```

### File: models\world_config.py

```python
"""
World configuration manager for the World Configurator Tool.
"""

import os
import logging
from typing import Dict, List, Any, Optional, Tuple

from world_configurator.models.base_models import WorldModelState
from world_configurator.models.world_data import CultureManager, WorldHistoryManager, WorldRulesManager, RaceManager, ClassManager, MagicSystemManager
from world_configurator.models.location_data import LocationManager
from world_configurator.models.origin_data import OriginManager, QuestManager
from world_configurator.utils.file_manager import get_config_dir, get_world_config_dir, load_json, save_json

logger = logging.getLogger("world_configurator.models.world_config")

# Define expected filenames for each component relative to the main 'config' directory
COMPONENT_FILES = {
    "cultures": ("world/base", "cultures.json"),
    "races": ("character", "races.json"),
    "classes": ("character", "classes.json"),
    "locations": ("world/locations", "locations.json"), # Corrected path
    "history": ("world/base", "world_history.json"),
    "rules": ("world/base", "fundamental_rules.json"),
    "origins": ("world/scenarios", "origins.json"),
    "quests": ("world/scenarios", "quests.json"),
    "magic_systems": ("world/base", "magic_systems.json")
}

class WorldConfigManager:
    """Manages loading, saving, and accessing all world configuration components."""
    def __init__(self):
        self.state = WorldModelState()
        self.project_name: str = "Untitled Project"

        # Initialize managers
        self.culture_manager = CultureManager()
        self.race_manager = RaceManager()
        self.class_manager = ClassManager()
        self.location_manager = LocationManager()
        self.history_manager = WorldHistoryManager()
        self.rules_manager = WorldRulesManager()
        self.origin_manager = OriginManager()
        self.quest_manager = QuestManager()
        self.magic_system_manager = MagicSystemManager()

        # Map component names to managers for easier iteration
        self.managers = {
            "cultures": self.culture_manager,
            "races": self.race_manager,
            "classes": self.class_manager,
            "locations": self.location_manager,
            "history": self.history_manager,
            "rules": self.rules_manager,
            "origins": self.origin_manager,
            "quests": self.quest_manager,
            "magic_systems": self.magic_system_manager
        }
    
    def new_project(self, name: str):
        """Start a new, empty project."""
        self.project_name = name
        self.state = WorldModelState() # Reset state
        for manager in self.managers.values():
            manager.__init__() # Reinitialize each manager
        logger.info(f"Started new project: {name}")
    
    def load_project(self, project_dir: str) -> bool:
        """
        Load a project from a specified directory.
        Assumes each component is saved as a separate JSON file within the directory.
        """
        if not os.path.isdir(project_dir):
            logger.error(f"Project directory not found: {project_dir}")
            return False

        self.project_name = os.path.basename(project_dir)
        all_loaded = True
        loaded_components = []

        for component, (_, filename) in COMPONENT_FILES.items():
            file_path = os.path.join(project_dir, filename)
            manager = self.managers.get(component)
            if manager:
                if os.path.exists(file_path):
                    if manager.load_from_file(file_path):
                        loaded_components.append(component)
                    else:
                        logger.warning(f"Failed to load component '{component}' from {file_path}")
                        # Continue loading other components even if one fails
                        # Optionally, set all_loaded = False here if partial loads are unacceptable
                else:
                    logger.debug(f"Component file not found, skipping: {file_path}")
                    manager.__init__() # Reset manager if file not found
            else:
                 logger.warning(f"No manager found for component '{component}'")


        self.state.path = project_dir
        self.state.modified = False # Mark as unmodified after load
        logger.info(f"Project '{self.project_name}' loaded from {project_dir}. Components loaded: {', '.join(loaded_components)}")
        return True # Return True even if some components failed, UI should reflect missing data
    
    def save_project(self, project_dir: Optional[str] = None) -> bool:
        """
        Save the current project to a directory.
        If project_dir is None, saves to the current project path.
        """
        target_dir = project_dir or self.state.path
        if not target_dir:
            logger.error("Cannot save project: No directory specified or loaded.")
            return False

        os.makedirs(target_dir, exist_ok=True)
        all_saved = True

        for component, (_, filename) in COMPONENT_FILES.items():
            manager = self.managers.get(component)
            if manager:
                file_path = os.path.join(target_dir, filename)
                if not manager.save_to_file(file_path):
                    logger.error(f"Failed to save component '{component}' to {file_path}")
                    all_saved = False # Mark failure but continue saving others
            else:
                logger.warning(f"No manager found for component '{component}', cannot save.")


        if all_saved:
            self.state.path = target_dir # Update path if saved successfully
            self.state.modified = False # Mark as unmodified after save
            logger.info(f"Project '{self.project_name}' saved to {target_dir}")
        else:
            logger.error(f"Project '{self.project_name}' saved to {target_dir} with errors.")

        return all_saved
    
    def export_to_game(self, export_options: Dict[str, bool]) -> Tuple[bool, List[str]]:
        """
        Export selected components to the game's config directory.

        Args:
            export_options: A dictionary where keys are component names
                            and values are booleans indicating if they should be exported.

        Returns:
            A tuple (bool, List[str]) indicating overall success and a list of errors.
        """
        all_success = True
        errors = []
        exported_count = 0

        for component, should_export in export_options.items():
            if should_export:
                manager = self.managers.get(component)
                if manager:
                    logger.debug(f"Attempting to export component: {component}")
                    if hasattr(manager, 'export_to_game'):
                        if manager.export_to_game():
                            logger.info(f"Successfully exported {component}")
                            exported_count += 1
                        else:
                            all_success = False
                            error_msg = f"Failed to export {component}."
                            errors.append(error_msg)
                            logger.error(error_msg)
                    else:
                         logger.warning(f"Manager for '{component}' does not have an export_to_game method.")
                else:
                    error_msg = f"No manager found for component '{component}', cannot export."
                    errors.append(error_msg)
                    logger.warning(error_msg)


        if exported_count > 0 and all_success:
            logger.info(f"Successfully exported {exported_count} components.")
        elif exported_count > 0:
            logger.warning(f"Export completed with errors. Successfully exported {exported_count} components.")
        else:
             logger.error("Export failed. No components were exported successfully.")


        return all_success, errors
    
    def validate_configuration(self) -> List[str]:
        """
        Validate the entire world configuration for consistency and completeness.
        
        Returns:
            A list of validation error messages, or an empty list if validation passed.
        """
        errors = []
        
        # Check for basic required elements
        if not self.culture_manager.cultures:
            errors.append("No cultures defined")
        
        if not self.location_manager.locations:
            errors.append("No locations defined")
        
        if not self.history_manager.history:
            errors.append("No world history defined")
        
        if not self.rules_manager.rules:
            errors.append("No fundamental rules defined")
        
        if not self.scenario_manager.scenarios:
            errors.append("No starting scenarios defined")

        if not self.race_manager.races:
            errors.append("No races defined")
        if not self.class_manager.classes:
            errors.append("No classes defined")
        
        # Validate location connections
        connection_errors = self.location_manager.verify_connections()
        errors.extend(connection_errors)
        
        # Validate scenario starting locations
        for scenario_id, scenario in self.scenario_manager.scenarios.items():
            if scenario.starting_location not in self.location_manager.locations:
                errors.append(f"Scenario {scenario_id} references non-existent starting location: {scenario.starting_location}")
        
        # Validate scenario initial quests
        for scenario_id, scenario in self.scenario_manager.scenarios.items():
            for quest_id in scenario.initial_quests:
                if quest_id not in self.quest_manager.quests:
                    errors.append(f"Scenario {scenario_id} references non-existent quest: {quest_id}")
        
        # Validate culture references in locations
        for location_id, location in self.location_manager.locations.items():
            if location.culture_id and location.culture_id not in self.culture_manager.cultures:
                errors.append(f"Location {location_id} references non-existent culture: {location.culture_id}")
        
        logger.info(f"Validated world configuration: {len(errors)} errors found")
        return errors
    
    def synchronize_with_game(self) -> bool:
        """Load all components directly from the game's config directory."""
        base_config_dir = get_config_dir() 
        self.project_name = "Game Configuration"
        all_loaded = True
        loaded_components = []

        for component, (subdir, filename) in COMPONENT_FILES.items():
            file_path = os.path.join(base_config_dir, subdir, filename)
            manager = self.managers.get(component)
            if manager:
                if os.path.exists(file_path):
                    if manager.load_from_file(file_path):
                        loaded_components.append(component)
                    else:
                        logger.warning(f"Failed to sync component '{component}' from {file_path}")
                        all_loaded = False # Mark failure but continue
                else:
                    logger.warning(f"Game config file not found for component '{component}', resetting: {file_path}")
                    manager.__init__() # Reset manager if file not found
            else:
                 logger.warning(f"No manager found for component '{component}' during sync.")

        self.state.path = None # No project path when synced from game
        self.state.modified = False # Mark as unmodified
        logger.info(f"Synchronized with game config. Components loaded: {', '.join(loaded_components)}")
        return all_loaded
    
    def is_modified(self) -> bool:
        """
        Check if any part of the world configuration has been modified.
        
        Returns:
            True if any manager has modified data, False otherwise.
        """
        return (
            self.state.modified or
            self.culture_manager.state.modified or
            self.location_manager.state.modified or
            self.history_manager.state.modified or
            self.rules_manager.state.modified or
            self.scenario_manager.state.modified or
            self.quest_manager.state.modified or
            self.magic_system_manager.state.modified or
            self.race_manager.state.modified or
            self.class_manager.state.modified or
            self.background_manager.state.modified 
        )

```

### File: models\world_data.py

```python
"""
World data models for cultures, history, and rules.
"""

import logging
import os
import shutil
import datetime
from typing import Dict, Optional

from world_configurator.models.base_models import CharacterClass, Culture, Race, WorldHistory, WorldRules, MagicalSystem, Spell, WorldModelState
from world_configurator.utils.file_manager import load_json, save_json, get_world_config_dir


logger = logging.getLogger("world_configurator.models.world_data")

class CultureManager:
    """
    Manager for culture data.
    """
    def __init__(self):
        self.cultures: Dict[str, Culture] = {}
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load cultures from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "cultures" not in data:
                logger.error(f"Invalid cultures file format: {file_path}")
                return False
            
            # Clear existing cultures
            self.cultures.clear()
            
            # Load each culture
            for culture_id, culture_data in data["cultures"].items():
                # Ensure the culture has an ID
                if "id" not in culture_data:
                    culture_data["id"] = culture_id
                
                culture = Culture.from_dict(culture_data)
                self.cultures[culture_id] = culture
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded {len(self.cultures)} cultures from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading cultures from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save cultures to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving cultures")
                return False
            
            # Prepare data
            data = {
                "cultures": {k: v.to_dict() for k, v in self.cultures.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Culture definitions for the RPG game world"
                }
            }
            
            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.cultures)} cultures to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving cultures: {e}")
            return False
    
    def add_culture(self, culture: Culture) -> None:
        """
        Add a culture to the manager.
        
        Args:
            culture: The culture to add.
        """
        self.cultures[culture.id] = culture
        self.state.modified = True
        logger.info(f"Added culture: {culture.name} ({culture.id})")
    
    def remove_culture(self, culture_id: str) -> bool:
        """
        Remove a culture from the manager.
        
        Args:
            culture_id: The ID of the culture to remove.
        
        Returns:
            True if the culture was removed, False if it wasn't found.
        """
        if culture_id in self.cultures:
            del self.cultures[culture_id]
            self.state.modified = True
            logger.info(f"Removed culture: {culture_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent culture: {culture_id}")
            return False
    
    def get_culture(self, culture_id: str) -> Optional[Culture]:
        """
        Get a culture by ID.
        
        Args:
            culture_id: The ID of the culture to get.
        
        Returns:
            The culture if found, None otherwise.
        """
        return self.cultures.get(culture_id)
    
    def export_to_game(self) -> bool:
        """
        Export cultures to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "cultures.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting cultures to game: {e}")
            return False

class WorldHistoryManager:
    """
    Manager for world history data.
    """
    def __init__(self):
        self.history: Optional[WorldHistory] = None
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load world history from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data:
                logger.error(f"Invalid world history file format: {file_path}")
                return False
            
            # Create history from data
            self.history = WorldHistory.from_dict(data)
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded world history from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading world history from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save world history to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Check if we have history data
            if not self.history:
                logger.error("No world history data to save")
                return False
            
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving world history")
                return False
            
            # Save to file
            result = save_json(self.history.to_dict(), path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved world history to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving world history: {e}")
            return False
    
    def create_new_history(self, name: str, description: str, current_year: int) -> None:
        """
        Create a new world history.
        
        Args:
            name: The name of the world.
            description: A description of the world.
            current_year: The current year in the world timeline.
        """
        self.history = WorldHistory.create_new(name, description, current_year)
        self.state.modified = True
        logger.info(f"Created new world history: {name}")
    
    def export_to_game(self) -> bool:
        """
        Export world history to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "world_history.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting world history to game: {e}")
            return False

class WorldRulesManager:
    """
    Manager for world rules data.
    """
    def __init__(self):
        self.rules: Optional[WorldRules] = None
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load world rules from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data:
                logger.error(f"Invalid world rules file format: {file_path}")
                return False
            
            # Create rules from data
            self.rules = WorldRules.from_dict(data)
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded world rules from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading world rules from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save world rules to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Check if we have rules data
            if not self.rules:
                logger.error("No world rules data to save")
                return False
            
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving world rules")
                return False
            
            # Save to file
            result = save_json(self.rules.to_dict(), path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved world rules to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving world rules: {e}")
            return False
    
    def create_new_rules(self, name: str, description: str) -> None:
        """
        Create new world rules.
        
        Args:
            name: The name of the rules set.
            description: A description of the rules.
        """
        self.rules = WorldRules.create_new(name, description)
        self.state.modified = True
        logger.info(f"Created new world rules: {name}")
    
    def export_to_game(self) -> bool:
        """
        Export world rules to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "fundamental_rules.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting world rules to game: {e}")
            return False

class MagicSystemManager:
    """
    Manager for magic system data.
    """
    def __init__(self):
        self.magic_systems: Dict[str, MagicalSystem] = {}
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load magic systems from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "magic_systems" not in data:
                logger.error(f"Invalid magic systems file format: {file_path}")
                return False
            
            # Clear existing magic systems
            self.magic_systems.clear()
            
            # Load each magic system
            for system_id, system_data in data["magic_systems"].items():
                # Ensure the magic system has an ID
                if "id" not in system_data:
                    system_data["id"] = system_id
                
                magic_system = MagicalSystem.from_dict(system_data)
                self.magic_systems[system_id] = magic_system
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded {len(self.magic_systems)} magic systems from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading magic systems from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save magic systems to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving magic systems")
                return False
            
            # Prepare data
            data = {
                "magic_systems": {k: v.to_dict() for k, v in self.magic_systems.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Magic system definitions for the RPG game world"
                }
            }
            
            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.magic_systems)} magic systems to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving magic systems: {e}")
            return False
    
    def add_magic_system(self, magic_system: MagicalSystem) -> None:
        """
        Add a magic system to the manager.
        
        Args:
            magic_system: The magic system to add.
        """
        self.magic_systems[magic_system.id] = magic_system
        self.state.modified = True
        logger.info(f"Added magic system: {magic_system.name} ({magic_system.id})")
    
    def remove_magic_system(self, system_id: str) -> bool:
        """
        Remove a magic system from the manager.
        
        Args:
            system_id: The ID of the magic system to remove.
        
        Returns:
            True if the magic system was removed, False if it wasn't found.
        """
        if system_id in self.magic_systems:
            del self.magic_systems[system_id]
            self.state.modified = True
            logger.info(f"Removed magic system: {system_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent magic system: {system_id}")
            return False
    
    def get_magic_system(self, system_id: str) -> Optional[MagicalSystem]:
        """
        Get a magic system by ID.
        
        Args:
            system_id: The ID of the magic system to get.
        
        Returns:
            The magic system if found, None otherwise.
        """
        return self.magic_systems.get(system_id)
    
    def add_spell_to_system(self, system_id: str, spell: Spell) -> bool:
        """
        Add a spell to a magic system.
        
        Args:
            system_id: The ID of the magic system to add the spell to.
            spell: The spell to add.
        
        Returns:
            True if the spell was added, False if the magic system wasn't found.
        """
        magic_system = self.get_magic_system(system_id)
        if not magic_system:
            logger.warning(f"Cannot add spell to non-existent magic system: {system_id}")
            return False
        
        magic_system.spells[spell.id] = spell
        self.state.modified = True
        logger.info(f"Added spell '{spell.name}' to magic system '{magic_system.name}'")
        return True
    
    def remove_spell_from_system(self, system_id: str, spell_id: str) -> bool:
        """
        Remove a spell from a magic system.
        
        Args:
            system_id: The ID of the magic system to remove the spell from.
            spell_id: The ID of the spell to remove.
        
        Returns:
            True if the spell was removed, False if the magic system or spell wasn't found.
        """
        magic_system = self.get_magic_system(system_id)
        if not magic_system:
            logger.warning(f"Cannot remove spell from non-existent magic system: {system_id}")
            return False
        
        if spell_id in magic_system.spells:
            del magic_system.spells[spell_id]
            self.state.modified = True
            logger.info(f"Removed spell '{spell_id}' from magic system '{magic_system.name}'")
            return True
        else:
            logger.warning(f"Cannot remove non-existent spell '{spell_id}' from magic system '{magic_system.name}'")
            return False
    
    def get_spell(self, system_id: str, spell_id: str) -> Optional[Spell]:
        """
        Get a spell from a magic system.
        
        Args:
            system_id: The ID of the magic system to get the spell from.
            spell_id: The ID of the spell to get.
        
        Returns:
            The spell if found, None otherwise.
        """
        magic_system = self.get_magic_system(system_id)
        if not magic_system:
            return None
        
        return magic_system.spells.get(spell_id)
    
    def export_to_game(self) -> bool:
        """
        Export magic systems to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "magic_systems.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting magic systems to game: {e}")
            return False

class RaceManager:
    """Manager for race data."""
    def __init__(self):
        self.races: Dict[str, Race] = {}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """Load races from a JSON file."""
        try:
            data = load_json(file_path)
            if not data or "races" not in data:
                logger.error(f"Invalid races file format: {file_path}")
                self.races.clear() # Clear even if load fails partially
                return False

            self.races.clear()
            for race_key, race_data in data["races"].items():
                if "id" not in race_data: race_data["id"] = race_key
                if "name" not in race_data:
                    race_data["name"] = race_key
                race = Race.from_dict(race_data)
                self.races[race_key] = race

            self.state.path = file_path
            self.state.modified = False
            logger.info(f"Loaded {len(self.races)} races from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading races from {file_path}: {e}")
            self.races.clear()
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """Save races to a JSON file using name as the key."""
        try:
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving races")
                return False

            # This dictionary comprehension now correctly uses the name as the key
            data_to_save = {k: v.to_dict() for k, v in self.races.items()}

            final_data = {"races": data_to_save}


            result = save_json(final_data, path) # Save the structure {"races": {...}}
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.races)} races to {path}")
            return result
        except Exception as e:
            logger.error(f"Error saving races: {e}")
            return False
        
    def add_race(self, race: Race) -> None:
        """Add a race to the manager."""
        self.races[race.name] = race
        self.state.modified = True
        logger.info(f"Added race: {race.name} ({race.id})")

    def remove_race(self, race_name: str) -> bool:
        """Remove a race from the manager."""
        if race_name in self.races:
            del self.races[race_name]
            self.state.modified = True
            logger.info(f"Removed race: {race_name}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent race: {race_name}")
            return False

    def get_race(self, race_name: str) -> Optional[Race]:
        """Get a race by ID."""
        return self.races.get(race_name)

    def export_to_game(self) -> bool:
        """Export races to the game's configuration directory."""
        try:
            target_dir = os.path.join(get_world_config_dir(), "..", "character")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "races.json")

            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")

            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting races to game: {e}")
            return False

class ClassManager:
    """Manager for character class data."""
    def __init__(self):
        self.classes: Dict[str, CharacterClass] = {}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """Load classes from a JSON file."""
        try:
            data = load_json(file_path)
            if not data or "classes" not in data:
                logger.error(f"Invalid classes file format: {file_path}")
                self.classes.clear()
                return False

            self.classes.clear()
            for class_id, class_data in data["classes"].items():
                if "id" not in class_data: class_data["id"] = class_id
                if "name" not in class_data:
                    class_data["name"] = class_id
                char_class = CharacterClass.from_dict(class_data)
                self.classes[char_class.id] = char_class # Use class.id as key

            self.state.path = file_path
            self.state.modified = False
            logger.info(f"Loaded {len(self.classes)} classes from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading classes from {file_path}: {e}")
            self.classes.clear()
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """Save classes to a JSON file."""
        try:
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving classes")
                return False

            data = {
                "classes": {k: v.to_dict() for k, v in self.classes.items()},
                 # Optionally add metadata from JSON if needed
                # "display_colors": {...},
                # "details": {...}
            }

            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.classes)} classes to {path}")
            return result
        except Exception as e:
            logger.error(f"Error saving classes: {e}")
            return False

    def add_class(self, char_class: CharacterClass) -> None:
        """Add a class to the manager."""
        self.classes[char_class.id] = char_class
        self.state.modified = True
        logger.info(f"Added class: {char_class.name} ({char_class.id})")

    def remove_class(self, class_id: str) -> bool:
        """Remove a class from the manager."""
        if class_id in self.classes:
            del self.classes[class_id]
            self.state.modified = True
            logger.info(f"Removed class: {class_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent class: {class_id}")
            return False

    def get_class(self, class_id: str) -> Optional[CharacterClass]:
        """Get a class by ID."""
        return self.classes.get(class_id)

    def export_to_game(self) -> bool:
        """Export classes to the game's configuration directory."""
        try:
            target_dir = os.path.join(get_world_config_dir(), "..", "character")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "classes.json")

            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")

            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting classes to game: {e}")
            return False

```

### File: ui\main_window.py

```python
"""
Main window for the World Configurator Tool.
"""

import os
import sys
import logging
from typing import Optional, Dict, Any

import json
from PySide6.QtCore import Qt, QSize, Signal, Slot
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QPushButton, QMenuBar, QMenu,
    QToolBar, QFileDialog, QMessageBox, QDialog,
    QStatusBar, QLabel, QSplitter, QTextEdit, QComboBox
)
from PySide6.QtGui import QIcon, QCloseEvent, QAction, QFont

# Corrected import path assumption (models likely in a subfolder)
from world_configurator.models.world_config import WorldConfigManager
from world_configurator.utils.file_manager import get_project_root, get_world_config_dir

from .editors.culture_editor import CultureEditor
from .editors.location_editor import LocationEditor
from .editors.history_editor import HistoryEditor
# Renamed import
from .editors.origin_editor import OriginEditor
from .editors.quest_editor import QuestEditor
from .editors.magic_systems_editor import MagicSystemsEditor
from .editors.class_editor import ClassEditor
from .editors.race_editor import RaceEditor
# Removed BackgroundEditor import
# from .editors.background_editor import BackgroundEditor

from .dialogs.new_project_dialog import NewProjectDialog
from .dialogs.export_dialog import ExportDialog
from .dialogs.settings_dialog import SettingsDialog

logger = logging.getLogger("world_configurator.ui.main_window")

class MainWindow(QMainWindow):
    """Main window for the World Configurator Tool."""

    # Signals
    project_loaded = Signal(str)  # Project path
    project_saved = Signal(str)  # Project path

    def __init__(self):
        """Initialize the main window."""
        super().__init__()

        # Initialize world config manager
        self.world_config = WorldConfigManager()

        # Set up UI
        self.setup_ui()

        # Set up actions
        self.setup_actions()

        # Set up menus
        self.setup_menus()

        # Set up toolbar
        self.setup_toolbar()

        # Set up status bar
        self.setup_status_bar()

        # Load settings
        self.load_settings()

        # Set window title
        self.update_window_title()

        logger.info("Main window initialized")

        # Show welcome information
        self.show_welcome_info()

    def show_welcome_info(self):
        """Show welcome information to help users get started."""
        QMessageBox.information(
            self,
            "Welcome to World Configurator",
            "Welcome to the World Configurator Tool!\n\n"
            "Currently, the following editors are fully implemented:\n"
            "- Cultures: Create and edit cultures\n"
            "- Races: Create and edit races\n" # Added
            "- Classes: Create and edit classes\n" # Added
            "- Locations: Create and edit locations\n"
            "- World History: Create and edit historical eras and events\n"
            "- Origins: Create and edit starting origins (scenarios)\n" # Updated
            "- Quests: Create and edit quests and objectives\n"
            "- Magic Systems: Create and edit magic systems\n\n" # Added
            "To edit your existing game data, use the 'File > Load from Game' option.\n"
            "This will load your existing JSON files from your game's configuration directory.\n\n"
            "When you export your changes, backup copies of your original files\n"
            "will be automatically created with timestamped filenames in a 'backup' folder."
        )

    def setup_ui(self):
        """Set up the UI components."""
        # Set window properties
        self.setWindowTitle("World Configurator")
        self.setMinimumSize(1000, 700)

        # Create main layout and central widget
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout(self.central_widget)
        self.main_layout.setContentsMargins(5, 5, 5, 5)

        # Create splitter for resizable panels
        self.main_splitter = QSplitter(Qt.Horizontal)
        self.main_layout.addWidget(self.main_splitter)

        # Create tab widget for editors
        self.tab_widget = QTabWidget()
        self.main_splitter.addWidget(self.tab_widget)

        # Create editor widgets
        self.create_editor_tabs()

        logger.debug("UI components set up")

    def create_editor_tabs(self):
        """Create tabs for the different editors."""
        # Culture editor
        self.culture_editor = CultureEditor()
        self.culture_editor.set_culture_manager(self.world_config.culture_manager)
        self.tab_widget.addTab(self.culture_editor, "Cultures")

        # Race editor
        self.race_editor = RaceEditor()
        self.race_editor.set_race_manager(self.world_config.race_manager)
        self.tab_widget.addTab(self.race_editor, "Races")

        # Class editor
        self.class_editor = ClassEditor()
        self.class_editor.set_class_manager(self.world_config.class_manager)
        self.tab_widget.addTab(self.class_editor, "Classes")

        # Location editor
        self.location_editor = LocationEditor()
        self.location_editor.set_managers(self.world_config.location_manager, self.world_config.culture_manager)
        self.tab_widget.addTab(self.location_editor, "Locations")

        # History editor
        self.history_editor = HistoryEditor()
        self.history_editor.set_managers(
            self.world_config.history_manager,
            self.world_config.culture_manager,
            self.world_config.location_manager
        )
        self.tab_widget.addTab(self.history_editor, "World History")

        # Renamed Scenario editor to Origin editor
        self.origin_editor = OriginEditor() # Renamed variable
        self.origin_editor.set_managers(
            self.world_config.origin_manager, # Renamed manager reference
            self.world_config.location_manager
        )
        self.tab_widget.addTab(self.origin_editor, "Origins") # Renamed tab title

        # Quest editor
        self.quest_editor = QuestEditor()
        self.quest_editor.set_managers(
            self.world_config.quest_manager,
            self.world_config.location_manager
        )
        self.tab_widget.addTab(self.quest_editor, "Quests")

        # Magic Systems editor
        self.magic_systems_editor = MagicSystemsEditor()
        self.magic_systems_editor.set_magic_system_manager(self.world_config.magic_system_manager)
        self.tab_widget.addTab(self.magic_systems_editor, "Magic Systems")

        # Connect modified signals (optional but recommended)
        self.culture_editor.culture_modified.connect(self.on_data_modified)
        self.race_editor.race_modified.connect(self.on_data_modified)
        self.class_editor.class_modified.connect(self.on_data_modified)
        self.location_editor.location_modified.connect(self.on_data_modified)
        self.history_editor.history_modified.connect(self.on_data_modified)
        self.origin_editor.origin_modified.connect(self.on_data_modified) # Renamed signal
        self.quest_editor.quest_modified.connect(self.on_data_modified)
        self.magic_systems_editor.magic_system_modified.connect(self.on_data_modified)
        # Removed background editor signal connection
        # self.background_editor.background_modified.connect(self.on_data_modified)


        logger.debug("Editor tabs created")

    def setup_actions(self):
        """Set up actions for the main window."""
        # File actions
        self.action_new = QAction("New Project", self)
        self.action_new.setShortcut("Ctrl+N")
        self.action_new.triggered.connect(self.on_new_project)

        self.action_open = QAction("Open Project", self)
        self.action_open.setShortcut("Ctrl+O")
        self.action_open.triggered.connect(self.on_open_project)

        self.action_load_from_game = QAction("Load from Game", self)
        self.action_load_from_game.setShortcut("Ctrl+L")
        self.action_load_from_game.triggered.connect(self.on_load_from_game)

        self.action_save = QAction("Save", self)
        self.action_save.setShortcut("Ctrl+S")
        self.action_save.triggered.connect(self.on_save_project)

        self.action_save_as = QAction("Save As...", self)
        self.action_save_as.setShortcut("Ctrl+Shift+S")
        self.action_save_as.triggered.connect(self.on_save_project_as)

        self.action_export = QAction("Export to Game", self)
        self.action_export.setShortcut("Ctrl+E")
        self.action_export.triggered.connect(self.on_export_to_game)

        self.action_exit = QAction("Exit", self)
        self.action_exit.setShortcut("Alt+F4")
        self.action_exit.triggered.connect(self.close)

        # Edit actions
        self.action_settings = QAction("Settings", self)
        self.action_settings.triggered.connect(self.on_settings)

        self.action_view_json = QAction("View JSON Data", self)
        self.action_view_json.setShortcut("Ctrl+J")
        self.action_view_json.triggered.connect(self.on_view_json)

        # Help actions
        self.action_about = QAction("About", self)
        self.action_about.triggered.connect(self.on_about)

        logger.debug("Actions set up")

    def setup_menus(self):
        """Set up the application menus."""
        self.menu_bar = QMenuBar()
        self.setMenuBar(self.menu_bar)

        # File menu
        self.menu_file = QMenu("File")
        self.menu_bar.addMenu(self.menu_file)
        self.menu_file.addAction(self.action_new)
        self.menu_file.addAction(self.action_open)
        self.menu_file.addAction(self.action_load_from_game)
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.action_save)
        self.menu_file.addAction(self.action_save_as)
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.action_export)
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.action_exit)

        # Edit menu
        self.menu_edit = QMenu("Edit")
        self.menu_bar.addMenu(self.menu_edit)
        self.menu_edit.addAction(self.action_settings)
        self.menu_edit.addSeparator()
        self.menu_edit.addAction(self.action_view_json)

        # Help menu
        self.menu_help = QMenu("Help")
        self.menu_bar.addMenu(self.menu_help)
        self.menu_help.addAction(self.action_about)

        logger.debug("Menus set up")

    def setup_toolbar(self):
        """Set up the application toolbar."""
        self.toolbar = QToolBar()
        self.toolbar.setMovable(False)
        self.toolbar.setIconSize(QSize(32, 32))
        self.addToolBar(self.toolbar)

        # Add actions to toolbar
        self.toolbar.addAction(self.action_new)
        self.toolbar.addAction(self.action_open)
        self.toolbar.addAction(self.action_save)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.action_export)

        logger.debug("Toolbar set up")

    def setup_status_bar(self):
        """Set up the status bar."""
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        # Add status labels
        self.status_label = QLabel("Ready")
        self.status_bar.addWidget(self.status_label, 1)

        self.project_label = QLabel("No project loaded")
        self.status_bar.addPermanentWidget(self.project_label)

        logger.debug("Status bar set up")

    def load_settings(self):
        """Load application settings."""
        # TODO: Implement settings loading
        logger.debug("Settings loaded")

    def save_settings(self):
        """Save application settings."""
        # TODO: Implement settings saving
        logger.debug("Settings saved")

    def update_window_title(self):
        """Update the window title with the current project name."""
        if self.world_config.state.path:
            modified_indicator = "*" if self.world_config.state.modified else ""
            self.setWindowTitle(f"World Configurator - {self.world_config.project_name}{modified_indicator}")
        else:
            self.setWindowTitle("World Configurator")

        # Update project label in status bar
        if self.world_config.state.path:
            self.project_label.setText(self.world_config.project_name)
        else:
            self.project_label.setText("No project loaded")

    def update_ui_from_model(self):
        """Update UI components with data from the model."""
        # Update editors
        self.culture_editor._refresh_culture_list()
        self.race_editor._refresh_race_list() # Add Race
        self.class_editor._refresh_class_list() # Add Class
        self.location_editor._refresh_location_list()
        self.location_editor._populate_culture_combo()
        self.history_editor.refresh()
        self.origin_editor.refresh() # Renamed
        self.quest_editor.refresh()
        self.magic_systems_editor._refresh_system_list()
        # Removed background editor refresh
        # self.background_editor._refresh_background_list()

        # Update window title
        self.update_window_title()

        # Show data overview
        self._show_data_overview()

        logger.debug("UI updated from model")

    def _show_data_overview(self):
        """Show an overview of the data that has been loaded."""
        loaded_items = []

        if self.world_config.culture_manager.cultures:
            loaded_items.append(f"{len(self.world_config.culture_manager.cultures)} cultures")
        if self.world_config.race_manager.races: # Add Race
            loaded_items.append(f"{len(self.world_config.race_manager.races)} races")
        if self.world_config.class_manager.classes: # Add Class
            loaded_items.append(f"{len(self.world_config.class_manager.classes)} classes")
        if self.world_config.location_manager.locations:
            loaded_items.append(f"{len(self.world_config.location_manager.locations)} locations")
        if hasattr(self.world_config, 'history_manager') and self.world_config.history_manager.history:
            loaded_items.append("World history")
        if hasattr(self.world_config, 'rules_manager') and self.world_config.rules_manager.rules:
            rule_count = len(self.world_config.rules_manager.rules.rules) if hasattr(self.world_config.rules_manager.rules, 'rules') else 0
            loaded_items.append(f"{rule_count} world rules")
        # Updated manager reference
        if hasattr(self.world_config, 'origin_manager') and self.world_config.origin_manager.origins:
            loaded_items.append(f"{len(self.world_config.origin_manager.origins)} origins") # Renamed
        if hasattr(self.world_config, 'quest_manager') and self.world_config.quest_manager.quests:
            loaded_items.append(f"{len(self.world_config.quest_manager.quests)} quests")
        if hasattr(self.world_config, 'magic_system_manager') and self.world_config.magic_system_manager.magic_systems:
             loaded_items.append(f"{len(self.world_config.magic_system_manager.magic_systems)} magic systems")
        # Removed backgrounds from overview
        # if hasattr(self.world_config, 'background_manager') and self.world_config.background_manager.backgrounds:
        #    loaded_items.append(f"{len(self.world_config.background_manager.backgrounds)} backgrounds")


        if loaded_items:
            overview = "Loaded: " + ", ".join(loaded_items)
            self.status_label.setText(overview)
        else:
            self.status_label.setText("No data loaded")

            # Show a message about using "Load from Game" if no editors are available
            if self.tab_widget.count() <= 5:  # Update count based on actual tabs
                QMessageBox.information(
                    self,
                    "Editor Information",
                    "Some editors might be missing or still under development.\n\n"
                    "Use the 'Load from Game' option to import existing game configuration files."
                )

    def closeEvent(self, event: QCloseEvent):
        """Handle window close event."""
        if self.check_unsaved_changes():
            # Save settings
            self.save_settings()
            event.accept()
        else:
            event.ignore()

    def check_unsaved_changes(self) -> bool:
        """
        Check if there are unsaved changes and prompt user to save if needed.

        Returns:
            True if it's safe to continue (changes saved or discarded), False to cancel.
        """
        if self.world_config.state.modified:
            response = QMessageBox.question(
                self,
                "Unsaved Changes",
                "There are unsaved changes. Would you like to save before continuing?",
                QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel,
                QMessageBox.Save
            )

            if response == QMessageBox.Save:
                return self.on_save_project()
            elif response == QMessageBox.Cancel:
                return False

        return True

    @Slot()
    def on_data_modified(self):
        """Slot to mark the project as modified when an editor signals changes."""
        if not self.world_config.state.modified:
            self.world_config.state.mark_modified()
            self.update_window_title()
            logger.debug("Project marked as modified due to editor changes.")

    @Slot()
    def on_new_project(self) -> bool:
        """
        Handle creating a new project.

        Returns:
            True if a new project was created, False otherwise.
        """
        # Check for unsaved changes
        if not self.check_unsaved_changes():
            return False

        # Show new project dialog
        dialog = NewProjectDialog(self)
        if dialog.exec() == QDialog.Accepted:
            # Create new project
            project_name = dialog.get_project_name()
            self.world_config.new_project(project_name)

            # Update UI
            self.update_ui_from_model()

            # Set status
            self.status_label.setText(f"Created new project: {project_name}")
            logger.info(f"Created new project: {project_name}")

            return True

        return False

    @Slot()
    def on_open_project(self) -> bool:
        """
        Handle opening an existing project.

        Returns:
            True if a project was opened, False otherwise.
        """
        # Check for unsaved changes
        if not self.check_unsaved_changes():
            return False

        # Show file dialog
        directory = QFileDialog.getExistingDirectory(
            self,
            "Open Project",
            os.path.join(get_project_root(), "projects")
        )

        if directory:
            # Load project
            if self.world_config.load_project(directory):
                # Update UI
                self.update_ui_from_model()

                # Set status
                self.status_label.setText(f"Opened project: {self.world_config.project_name}")
                logger.info(f"Opened project from {directory}")

                # Emit signal
                self.project_loaded.emit(directory)

                return True
            else:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to open project from {directory}. See log for details."
                )

        return False

    @Slot()
    def on_save_project(self) -> bool:
        """
        Handle saving the current project.

        Returns:
            True if the project was saved, False otherwise.
        """
        # If no path set, prompt for save location
        if not self.world_config.state.path:
            return self.on_save_project_as()

        # Save project
        if self.world_config.save_project():
            # Update UI
            self.update_window_title()

            # Set status
            self.status_label.setText(f"Saved project to {self.world_config.state.path}")
            logger.info(f"Saved project to {self.world_config.state.path}")

            # Emit signal
            self.project_saved.emit(self.world_config.state.path)

            return True
        else:
            QMessageBox.critical(
                self,
                "Error",
                f"Failed to save project. See log for details."
            )
            return False

    @Slot()
    def on_save_project_as(self) -> bool:
        """
        Handle saving the current project to a new location.

        Returns:
            True if the project was saved, False otherwise.
        """
        # Show file dialog
        directory = QFileDialog.getExistingDirectory(
            self,
            "Save Project As",
            os.path.join(get_project_root(), "projects")
        )

        if directory:
            # Save project
            if self.world_config.save_project(directory):
                # Update UI
                self.update_window_title()

                # Set status
                self.status_label.setText(f"Saved project to {directory}")
                logger.info(f"Saved project to {directory}")

                # Emit signal
                self.project_saved.emit(directory)

                return True
            else:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to save project to {directory}. See log for details."
                )

        return False

    @Slot()
    def on_export_to_game(self) -> bool:
        """
        Handle exporting the current project to the game.

        Returns:
            True if the project was exported, False otherwise.
        """
        # Confirm with user about potential overwrite
        confirm_response = QMessageBox.question(
            self,
            "Confirm Export",
            "This will export your current project to the game files.\n\n"
            "Existing game files will be automatically backed up with timestamps before being replaced.\n\n"
            "Do you want to continue?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if confirm_response != QMessageBox.Yes:
            return False

        # Show export dialog
        dialog = ExportDialog(self)


        if dialog.exec() == QDialog.Accepted:
            export_options = dialog.get_export_options()
            selected_components = [comp for comp, selected in export_options.items() if selected]
            logger.info(f"Exporting components: {', '.join(selected_components)}")

            # Export to game with selected options
            # Assumes WorldConfigManager.export_to_game handles calling manager exports
            success, errors = self.world_config.export_to_game(export_options)

            if success:
                QMessageBox.information(
                    self, "Export Successful",
                    f"Successfully exported: {', '.join(selected_components)}\n\n"
                    "Backups created in respective 'backup' folders."
                )
                self.status_label.setText(f"Exported {len(selected_components)} component(s)")
                logger.info(f"Exported {len(selected_components)} component(s) to game")
                return True
            else:
                error_text = "\n".join(errors)
                QMessageBox.critical(self, "Export Failed", f"Failed to export:\n\n{error_text}")
        return False

    @Slot()
    def on_settings(self):
        """Handle showing the settings dialog."""
        dialog = SettingsDialog(self)
        dialog.exec()

    @Slot()
    def on_load_from_game(self) -> bool:
        """
        Handle loading data directly from the game's config files.

        Returns:
            True if game data was loaded successfully, False otherwise.
        """
        # Check for unsaved changes
        if not self.check_unsaved_changes():
            return False

        # Confirm with user
        response = QMessageBox.question(
            self,
            "Load from Game",
            "This will load world configuration data directly from the game files. \n\n"
            "Any unsaved changes in the current project will be lost. Continue?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if response != QMessageBox.Yes:
            return False

        # Load data from game files
        if self.world_config.synchronize_with_game():
            # Update UI with loaded data
            self.update_ui_from_model()

            # Set status message
            self.status_label.setText("Loaded world configuration from game files")
            self.project_label.setText("Game Files (Unsaved Project)")

            # Update project name
            self.world_config.project_name = "Game Configuration"
            self.update_window_title()

            logger.info("Loaded world configuration from game files")
            return True
        else:
            # Show error message
            QMessageBox.critical(
                self,
                "Error",
                "Failed to load world configuration from game files. \n\n"
                "See log for details."
            )
            return False

    @Slot()
    def on_view_json(self):
        """Handle showing the JSON data view dialog."""
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("View JSON Data")
        dialog.resize(800, 600)

        # Create layout
        layout = QVBoxLayout(dialog)

        # Create selection controls
        select_layout = QHBoxLayout()
        select_layout.addWidget(QLabel("Select data type:"))

        data_type_combo = QComboBox()
        # Updated list of data types
        data_type_combo.addItems([
            "Cultures", "Races", "Classes", "Locations", "World History",
            "Fundamental Rules", "Origins", "Quests", "Magic Systems"
        ])
        select_layout.addWidget(data_type_combo)

        refresh_btn = QPushButton("Refresh")
        select_layout.addWidget(refresh_btn)

        layout.addLayout(select_layout)

        # Create text display
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFont(QFont("Courier New", 10))
        layout.addWidget(text_edit)

        # Function to refresh the JSON data
        def refresh_json():
            data_type = data_type_combo.currentText()
            json_data = "{}"

            try: # Wrap in try-except for safety
                if data_type == "Cultures":
                    data_dict = {k: v.to_dict() for k, v in self.world_config.culture_manager.cultures.items()}
                    json_data = json.dumps({"cultures": data_dict}, indent=2) if data_dict else "No culture data loaded."
                elif data_type == "Races": # Add Race
                    data_dict = {k: v.to_dict() for k, v in self.world_config.race_manager.races.items()}
                    json_data = json.dumps({"races": data_dict}, indent=2) if data_dict else "No race data loaded."
                elif data_type == "Classes": # Add Class
                    data_dict = {k: v.to_dict() for k, v in self.world_config.class_manager.classes.items()}
                    json_data = json.dumps({"classes": data_dict}, indent=2) if data_dict else "No class data loaded."
                elif data_type == "Locations":
                    data_dict = {k: v.to_dict() for k, v in self.world_config.location_manager.locations.items()}
                    json_data = json.dumps({"locations": data_dict}, indent=2) if data_dict else "No location data loaded."
                elif data_type == "World History":
                    if hasattr(self.world_config, 'history_manager') and self.world_config.history_manager.history:
                        json_data = json.dumps(self.world_config.history_manager.history.to_dict(), indent=2)
                    else: json_data = "No world history data loaded."
                elif data_type == "Fundamental Rules":
                     if hasattr(self.world_config, 'rules_manager') and self.world_config.rules_manager.rules:
                        json_data = json.dumps(self.world_config.rules_manager.rules.to_dict(), indent=2)
                     else: json_data = "No fundamental rules data loaded."
                # Updated case for Origins
                elif data_type == "Origins":
                    if hasattr(self.world_config, 'origin_manager') and self.world_config.origin_manager.origins:
                        data_dict = {k: v.to_dict() for k, v in self.world_config.origin_manager.origins.items()}
                        json_data = json.dumps({"origins": data_dict}, indent=2) if data_dict else "No origin data loaded."
                    else: json_data = "No origin data loaded."
                elif data_type == "Quests":
                     if hasattr(self.world_config, 'quest_manager') and self.world_config.quest_manager.quests:
                        data_dict = {k: v.to_dict() for k, v in self.world_config.quest_manager.quests.items()}
                        json_data = json.dumps({"quests": data_dict}, indent=2) if data_dict else "No quest data loaded."
                     else: json_data = "No quest data loaded."
                elif data_type == "Magic Systems":
                    if hasattr(self.world_config, 'magic_system_manager') and self.world_config.magic_system_manager.magic_systems:
                        data_dict = {k: v.to_dict() for k, v in self.world_config.magic_system_manager.magic_systems.items()}
                        json_data = json.dumps({"magic_systems": data_dict}, indent=2) if data_dict else "No magic system data loaded."
                    else: json_data = "No magic system data loaded."
                # Removed Backgrounds case

            except Exception as e:
                json_data = f"Error generating JSON view: {e}"
                logger.error(f"Error in JSON view for {data_type}: {e}")

            text_edit.setText(json_data)

        # Connect signals
        data_type_combo.currentIndexChanged.connect(refresh_json)
        refresh_btn.clicked.connect(refresh_json)

        # Initial refresh
        refresh_json()

        # Show dialog
        dialog.exec()

    @Slot()
    def on_about(self):
        """Handle showing the about dialog."""
        QMessageBox.about(
            self,
            "About World Configurator",
            "World Configurator Tool for the RPG Project\n\n"
            "Version 1.0.1 (Origin Refactor)\n\n" # Updated version
            "A tool for creating and editing world configuration data for the RPG game."
        )
```

### File: ..\gui\main_window.py

```python
#!/usr/bin/env python3
"""
Main window for the RPG game GUI.
This module provides the MainWindow class that serves as the primary GUI container.
"""

import logging
import os
from typing import Optional, List, Dict, Any, Tuple
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QStackedWidget, QDialog, QLabel, QPushButton, 
    QTextEdit, QScrollArea, QGraphicsOpacityEffect, QMessageBox, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QTimer, QSize, QSettings, QObject, QThread, Signal, QParallelAnimationGroup, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QIcon, QPixmap, QPalette, QBrush, QColor, QMovie # Added QMovie
from core.inventory import get_inventory_manager
from gui.dialogs.game_over_dialog import GameOverDialog
from core.base.engine import GameEngine, get_game_engine
from core.combat.enums import CombatState, CombatStep
from core.interaction.enums import InteractionMode # Added import
from core.base.state import GameState, get_state_manager # Added imports
from core.utils.logging_config import get_logger
from gui.components.game_output import GameOutputWidget
from gui.components.command_input import CommandInputWidget
from gui.components.menu_panel import MenuPanelWidget
from gui.components.right_panel import CollapsibleRightPanel
from gui.components.status_bar import GameStatusBar
from gui.components.combat_display import CombatDisplay # Added import
from gui.utils.resource_manager import get_resource_manager
from gui.dialogs.settings.llm_settings_dialog import LLMSettingsDialog

logger = get_logger("GUI")

class MainWindow(QMainWindow):
    """Main window for the RPG game GUI."""
    
    def __init__(self):
            super().__init__()
            
            self._previous_mode = None # Track previous mode for transitions
            
            # Get resource manager
            self.resource_manager = get_resource_manager()
            
            # Get game engine
            self.game_engine = get_game_engine()

            # Set minimum size based on reasonable content size hint
            self.setMinimumSize(1024, 700) # Set a sensible minimum size

            # Store character data temporarily during animation
            self._character_data_for_new_game: Optional[Dict[str, Any]] = None

            # Set up the UI
            self._setup_ui()
            
            # Connect signals and slots
            self._connect_signals()
            
            # Apply initial styling
            self._update_styling()

            self._last_submitted_command = None

    def _apply_initial_window_state(self):
        """Apply saved window state and geometry when the window is first shown."""
        settings = QSettings("RPGGame", "Settings")
        window_state = settings.value("display/window_state", "windowed") # Default to windowed
        
        logger.info(f"Applying initial window state: {window_state}")

        if window_state == "fullscreen":
            self.showFullScreen()
        elif window_state == "maximized":
            self.showMaximized()
        else: # windowed
            # Load saved windowed size or default
            default_size = QSize(1280, 720)
            windowed_size = settings.value("display/windowed_size", default_size)
            # Ensure windowed_size is a QSize object
            if not isinstance(windowed_size, QSize):
                # Attempt conversion if it's a tuple/list or handle potential string format
                if isinstance(windowed_size, (tuple, list)) and len(windowed_size) == 2:
                    windowed_size = QSize(windowed_size[0], windowed_size[1])
                elif isinstance(windowed_size, str):
                     try:
                         parts = windowed_size.strip('()').split(',')
                         windowed_size = QSize(int(parts[0]), int(parts[1]))
                     except Exception:
                         windowed_size = default_size # Fallback on parse error
                else:
                    windowed_size = default_size # Fallback if type is unexpected

            self.showNormal() # Ensure not maximized/fullscreen first
            self.resize(windowed_size) # Apply the loaded/default size
            # Optional: Center the window
            screen_geometry = self.screen().availableGeometry()
            self.move(screen_geometry.center() - self.rect().center())        

    def showEvent(self, event):
        """Override showEvent to apply initial window state after the window is shown."""
        super().showEvent(event)
        # Apply the state only once when the window is first shown
        if not hasattr(self, '_initial_state_applied') or not self._initial_state_applied:
             self._apply_initial_window_state()
             self._initial_state_applied = True

    def closeEvent(self, event):
        """Handle window close event, saving window state."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # --- Save Window State ---
            settings = QSettings("RPGGame", "Settings")
            current_state_str = "windowed" # Default
            if self.isFullScreen():
                current_state_str = "fullscreen"
            elif self.isMaximized():
                current_state_str = "maximized"
            
            settings.setValue("display/window_state", current_state_str)
            
            # Save the *current* size only if the state is 'windowed'
            if current_state_str == "windowed":
                 settings.setValue("display/windowed_size", self.size())
            logger.info(f"Saved window state ({current_state_str}) and size ({self.size() if current_state_str == 'windowed' else 'N/A'}) on exit.")
            # --- End Save Window State ---

            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def _apply_saved_resolution(self):
        """Apply saved resolution from settings."""
        settings = QSettings("RPGGame", "Settings")
        resolution = settings.value("display/resolution", (1280, 720))
        
        # Convert to tuple if it's a string (can happen with some QSettings implementations)
        if isinstance(resolution, str):
            try:
                # Handle string format like "(1280, 720)"
                if resolution.startswith("(") and resolution.endswith(")"):
                    parts = resolution.strip("()").split(",")
                    resolution = (int(parts[0].strip()), int(parts[1].strip()))
            except:
                # Fallback to default if parsing fails
                resolution = (1280, 720)
                logging.warning("Failed to parse resolution setting, using default")
        
        # Set window size
        self.setFixedSize(*resolution)
        logging.info(f"Applied saved resolution: {resolution}")
    
    def _setup_ui(self):
        """Set up the user interface."""
        self.setWindowTitle("RPG Game")
        
        self.background_container = QWidget()
        self.setCentralWidget(self.background_container)
        self.background_container.setStyleSheet("background-color: transparent;")

        self.background_label = QLabel(self.background_container)
        self.background_label.setGeometry(0, 0, self.width(), self.height()) 
        self.background_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.background_label.setScaledContents(True) 

        self.main_content_widget = QWidget(self.background_container)
        self.main_content_widget.setGeometry(0, 0, self.width(), self.height()) 
        self.main_content_widget.setStyleSheet("background-color: transparent;") 

        self.main_layout = QVBoxLayout(self.main_content_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10) 
        self.main_layout.setSpacing(5)
        
        self.mode_stacked_widget = QStackedWidget()
        
        self.narrative_view = QWidget()
        self.narrative_layout = QVBoxLayout(self.narrative_view)
        self.narrative_layout.setContentsMargins(0, 0, 0, 0)
        self.narrative_layout.setSpacing(0)
        
        self.combat_view = QWidget()
        self.combat_layout = QVBoxLayout(self.combat_view)
        self.combat_layout.setContentsMargins(0, 0, 0, 0)
        self.combat_layout.setSpacing(0)
        
        title_pixmap = self.resource_manager.get_pixmap("title_banner")
        if not title_pixmap.isNull():
            self.title_label = QLabel()
            target_height = 100
            scaled_pixmap = title_pixmap.scaled(
                QSize(1000, target_height), 
                Qt.KeepAspectRatio,         
                Qt.SmoothTransformation     
            )
            self.title_label.setPixmap(scaled_pixmap)
            self.title_label.setAlignment(Qt.AlignCenter)
            self.title_label.setContentsMargins(0, 0, 0, 5)
            self.main_layout.addWidget(self.title_label)
        
        self.content_layout = QHBoxLayout()
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.setSpacing(10)
        
        self.menu_panel = MenuPanelWidget()
        
        self.game_output = GameOutputWidget()
        if hasattr(self.game_output, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.game_output.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected GameOutputWidget.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect GameOutputWidget.visualDisplayComplete: Attribute or slot missing.")
        self.narrative_layout.addWidget(self.game_output, 1)
        
        self.narrative_command_input = CommandInputWidget()
        self.narrative_layout.addWidget(self.narrative_command_input, 0)
        
        self.combat_display = CombatDisplay()
        if hasattr(self.combat_display, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.combat_display.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected CombatDisplay.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect CombatDisplay.visualDisplayComplete: Attribute or slot missing.")
        self.combat_layout.addWidget(self.combat_display, 1)
        
        self.combat_command_input = CommandInputWidget()
        self.combat_layout.addWidget(self.combat_command_input, 0)
        
        self.mode_stacked_widget.addWidget(self.narrative_view)
        self.mode_stacked_widget.addWidget(self.combat_view)
        
        self.center_widget = QWidget()
        center_layout = QVBoxLayout(self.center_widget)
        center_layout.setContentsMargins(0, 0, 0, 0)
        center_layout.addWidget(self.mode_stacked_widget)
        
        self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
        
        self.right_panel = CollapsibleRightPanel()
        
        self.content_layout.addWidget(self.menu_panel, 0) # Stretch factor 0 for menu_panel
        self.content_layout.addWidget(self.center_widget, 1) # Stretch factor 1 for center_widget
        self.content_layout.addWidget(self.right_panel, 0) # Stretch factor 0 for right_panel
        
        self.main_layout.addLayout(self.content_layout, 1)
        
        self.music_controls = self._create_music_controls()
        
        self.status_bar = GameStatusBar()
        self.setStatusBar(self.status_bar)

        self._load_and_apply_initial_background()

        self._initialize_panel_effects() 
        
        # Initial state: center, right, and status bar are part of the layout but fully transparent and disabled.
        # setVisible(True) is important for them to be considered by the layout manager from the start.
        self.center_widget.setVisible(True) 
        self.center_widget.setEnabled(False)
        if hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False)
        if hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect.setOpacity(0.0)
            
        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False)
        if hasattr(self, 'status_bar_opacity_effect'):
             self.status_bar_opacity_effect.setOpacity(0.0)

    def _create_music_controls(self):
        """Create music control widgets."""
        # Create a widget for the music controls
        music_widget = QWidget()
        music_layout = QHBoxLayout(music_widget)
        music_layout.setContentsMargins(0, 0, 0, 0)
        music_layout.setSpacing(5)
        
        # Create music control buttons
        play_pause_button = QPushButton()
        play_pause_button.setIcon(self.resource_manager.get_icon("music_play"))
        play_pause_button.setIconSize(QSize(24, 24))
        play_pause_button.setFixedSize(32, 32)
        play_pause_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 16px;
            }
            QPushButton:pressed {
                background-color: rgba(255, 255, 255, 0.2);
            }
        """)
        
        next_button = QPushButton()
        next_button.setIcon(self.resource_manager.get_icon("music_next"))
        next_button.setIconSize(QSize(24, 24))
        next_button.setFixedSize(32, 32)
        next_button.setStyleSheet(play_pause_button.styleSheet())
        
        volume_button = QPushButton()
        volume_button.setIcon(self.resource_manager.get_icon("music_volume"))
        volume_button.setIconSize(QSize(24, 24))
        volume_button.setFixedSize(32, 32)
        volume_button.setStyleSheet(play_pause_button.styleSheet())
        
        # Add buttons to layout
        music_layout.addWidget(play_pause_button)
        music_layout.addWidget(next_button)
        music_layout.addWidget(volume_button)
        
        # Add music controls to the top-right corner
        self.main_layout.insertWidget(0, music_widget, 0, Qt.AlignRight)
        
        # Return the widget for reference
        return music_widget
    
    def _connect_signals(self):
        """Connect signals and slots."""
        self.narrative_command_input.command_submitted.connect(self._process_command)
        self.combat_command_input.command_submitted.connect(self._process_command)

        # --- ECFA Change: Connect to new orchestrated_event_to_ui signal ---
        logger.info("Connecting GameEngine.orchestrated_event_to_ui signal to MainWindow.process_orchestrated_display_event")
        try:
            self.game_engine.orchestrated_event_to_ui.connect(self.process_orchestrated_display_event)
            logger.info("Successfully connected orchestrated_event_to_ui signal")
        except Exception as e:
            logger.error(f"Failed to connect orchestrated_event_to_ui signal: {e}")
        
        # Remove direct connection from engine.output_generated to _handle_game_output
        # if _handle_game_output is only for non-orchestrated messages now.
        # Or, _handle_game_output can differentiate if it still receives all engine outputs.
        # For clarity, let's assume _handle_game_output is for NON-ORCHESTRATED things.
        # If _output is still used by engine for general things, keep this:
        logger.info("Connecting game engine output_generated signal to _handle_game_output (for non-orchestrated events)")
        try:
            self.game_engine.output_generated.connect(self._handle_game_output)
            logger.info("Successfully connected engine.output_generated signal")
        except Exception as e:
            logger.error(f"Failed to connect output_generated signal: {e}")
        # --- End ECFA Change ---

        self.menu_panel.new_game_requested.connect(self._show_new_game_dialog)
        self.menu_panel.save_game_requested.connect(self._show_save_game_dialog)
        self.menu_panel.load_game_requested.connect(self._show_load_game_dialog)
        self.menu_panel.settings_requested.connect(self._show_settings_dialog)
        self.menu_panel.llm_settings_requested.connect(self._show_llm_settings_dialog)
        self.menu_panel.exit_requested.connect(self.close)

        self.right_panel.tab_changed.connect(self._handle_tab_change)

        if self.game_engine.state_manager.stats_manager:
            try:
                self.game_engine.state_manager.stats_manager.stats_changed.disconnect(self._handle_stats_update)
            except (TypeError, RuntimeError): pass 
            self.game_engine.state_manager.stats_manager.stats_changed.connect(self._handle_stats_update)
            logger.info("Connected StatsManager stats_changed signal to MainWindow handler.")
        else:
            logger.warning("StatsManager not available at signal connection time in MainWindow.")

        # --- ECFA Change: Connect orchestrator's resume signal to engine ---
        if hasattr(self.game_engine._combat_orchestrator, 'resume_combat_manager') and hasattr(self.game_engine, 'on_orchestrator_idle_and_combat_manager_resumed'):
             # This signal might be better named or a different one used.
             # For now, connecting to a general resume signal.
             # If CombatManager pauses itself, it needs a way to be unpaused.
             # The orchestrator's _on_inter_step_delay_timeout calls _signal_combat_manager_resume,
             # which then calls CM.process_combat_step.
             # This connection here is for the specific case of the *closing narrative* completing.
             self.game_engine._combat_orchestrator.resume_combat_manager.connect(self.game_engine.on_orchestrator_idle_and_combat_manager_resumed)
             logger.info("Connected orchestrator's resume_combat_manager to engine's handler for post-closing-narrative.")
        else:
             logger.error("Could not connect orchestrator's resume signal to engine.")
        # --- End ECFA Change ---
        
    @Slot(dict)
    def _handle_stats_update(self, stats_data: dict):
        """Handle updates received directly from StatsManager."""
        logger.debug("Received stats update signal in MainWindow")
        state = self.game_engine.state_manager.current_state
        if state:
            # Update Character Sheet (Right Panel)
            # This ensures character sheet gets all data including combat status
            if self.right_panel and hasattr(self.right_panel, 'update_character'):
                self.right_panel.update_character(state.player) # Pass player state for full context
                logger.debug("Updated CharacterSheet (RightPanel) from stats signal.")

            # Update Combat Display if in Combat Mode
            if state.current_mode == InteractionMode.COMBAT:
                logger.debug("Updating CombatDisplay from stats signal")
                self.combat_display.update_display(state) 
            
            # Any other UI elements that need to react to general stats changes can be updated here.

    def _setup_stats_refresh(self):
        """Set up player command tracking and direct signal connections instead of timer-based refresh."""
        # Store the last command submitted by the player to prevent echo
        self._last_submitted_command: Optional[str] = None
        
        # We don't need timer-based stats refresh anymore since we'll use direct signal connections
    
    # The _refresh_stats method is removed since we're using direct signal connections now
    
    def _handle_tab_change(self, index):
        """Handle tab change event."""
        # Update the active tab content
        if index == 0:  # Character tab
            self.right_panel.update_character()
        elif index == 1:  # Inventory tab
            if self.game_engine.state_manager.current_state:
                # Get inventory manager instance
                from core.inventory import get_inventory_manager
                inventory_manager = get_inventory_manager()
                
                if inventory_manager:
                    self.right_panel.update_inventory(inventory_manager)
                else:
                    logger.warning("No inventory manager available")
        elif index == 2:  # Journal tab
            if self.game_engine.state_manager.current_state:
                # Check if journal data exists, create it if not
                if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                    self.game_engine.state_manager.current_state.journal = {
                        "character": "",
                        "quests": {},
                        "notes": []
                    }
                
                self.right_panel.update_journal(
                    self.game_engine.state_manager.current_state.journal
                )
    
    # Define a worker for running commands in a separate thread
    class CommandWorker(QObject):
        finished = Signal()
        error = Signal(str)
        processing = Signal(bool)  # Signal to show/hide processing indicator
        
        def __init__(self, game_engine, command):
            super().__init__()
            self.game_engine = game_engine
            self.command = command
        
        def run(self):
            try:
                self.processing.emit(True)
                # Process input in the worker thread using the new InputRouter-based approach
                command_result = self.game_engine.process_input(self.command) # Original call
                
                # NEW: Process commands returned by LLM
                if command_result.data and "commands" in command_result.data:
                    llm_commands: List[Tuple[str, str]] = command_result.data["commands"]
                    if llm_commands:
                        logger.info(f"CommandWorker: Processing {len(llm_commands)} commands from LLM response: {llm_commands}")
                        # Ensure current_state is available
                        current_game_state = self.game_engine._state_manager.current_state
                        if not current_game_state:
                            logger.error("CommandWorker: Cannot process LLM commands, current_game_state is None.")
                        else:
                            for cmd, args_str in llm_commands:
                                try:
                                    # We need to call the central LLM command processor
                                    # command_handlers.process_llm_command takes (engine, command, args_list, game_state)
                                    # The args_str from the tuple is a single string, so wrap it in a list.
                                    logger.debug(f"CommandWorker: Executing LLM command '{cmd}' with args '{args_str}'")
                                    # Import locally if not already available or pass engine components if needed
                                    from core.game_flow.command_handlers import process_llm_command
                                    
                                    # process_llm_command itself might call engine._output, which triggers _update_ui.
                                    # This is fine, as _update_ui will reflect the state *after* each command.
                                    cmd_exec_result = process_llm_command(self.game_engine, cmd, [args_str], current_game_state)
                                    logger.info(f"CommandWorker: LLM command '{cmd}' execution result: {cmd_exec_result.message if cmd_exec_result else 'No result'}")
                                    if cmd_exec_result and not cmd_exec_result.is_success and cmd_exec_result.message:
                                        # If an LLM command itself fails, output its error message
                                        self.game_engine._output("system", f"Error processing internal command '{cmd}': {cmd_exec_result.message}")

                                except Exception as e_cmd:
                                    logger.error(f"CommandWorker: Error processing extracted LLM command '{cmd}': {e_cmd}", exc_info=True)
                                    self.game_engine._output("system", f"System error processing internal command '{cmd}'.")
                
                self.finished.emit()
            except Exception as e:
                logging.error(f"Error processing input: {e}", exc_info=True)
                self.error.emit(str(e))
            finally:
                self.processing.emit(False)
                
    def _process_command(self, command: str):
        """Process a command using the game engine in a separate thread."""
        if not command.strip():
            return
        
        # --- ECFA Change: Check if waiting for closing narrative ---
        if self.game_engine._waiting_for_closing_narrative_display:
            self.game_output.append_system_message("Please wait, concluding previous actions...", gradual=False)
            # Re-enable input field as this input is being ignored.
            if self.mode_stacked_widget.currentWidget() == self.narrative_view:
                self.narrative_command_input.setEnabled(True)
                self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            else:
                self.combat_command_input.setEnabled(True)
                self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            return
        # --- End ECFA Change ---

        self.game_output.append_player_message(command)
        self._last_submitted_command = command
        
        active_command_input = self.narrative_command_input if self.mode_stacked_widget.currentWidget() == self.narrative_view else self.combat_command_input
        active_command_input.clear()
        active_command_input.setEnabled(False)
        active_command_input.command_edit.setPlaceholderText("Processing...")
        
        self.status_bar.showMessage("Processing command...", 0)
        
        self.worker_thread = QThread()
        self.worker = self.CommandWorker(self.game_engine, command)
        self.worker.moveToThread(self.worker_thread)
        
        self.worker_thread.started.connect(self.worker.run)
        self.worker.finished.connect(self._on_command_processed)
        self.worker.error.connect(self._on_command_error)
        self.worker.processing.connect(self._set_processing_state) 
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker_thread.finished.connect(self.worker_thread.deleteLater)
        
        self.worker_thread.start()
    
    def _on_command_processed(self):
        """Handle completion of command processing."""
        # Update UI components
        self._update_ui()
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
    
    def _on_command_error(self, error_msg):
        """Handle error in command processing."""
        self.game_output.append_system_message(f"Error: {error_msg}")
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
    
    def _set_processing_state(self, is_processing):
        """Update UI to show processing state."""
        if is_processing:
            self.status_bar.showMessage("Processing command...")
            self.narrative_command_input.command_edit.setPlaceholderText("Processing...")
            self.combat_command_input.command_edit.setPlaceholderText("Processing...")
        else:
            self.status_bar.clearMessage()
            self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.narrative_command_input.setEnabled(True)
            self.combat_command_input.setEnabled(True)
    
    def _handle_game_output(self, role: str, content: str):
        """
        Handle non-orchestrated output from the game engine.
        Orchestrated events are handled by `process_orchestrated_display_event`.
        This method is now for general system messages or direct player echoes
        that are NOT part of the CombatOutputOrchestrator's flow.
        """
        logger.info(f"[LEGACY_OUTPUT] Received: role='{role}', content='{content[:200]}...'")
        
        # Prevent echoing the player's command if it somehow comes through this path
        if (role == "gm" or role == "player") and \
           self._last_submitted_command is not None and \
           content == self._last_submitted_command:
            logger.warning(f"Skipping potential echo of last command via _handle_game_output: role='{role}'")
            self._last_submitted_command = None 
            return
            
        if self._last_submitted_command is not None and content != self._last_submitted_command:
             self._last_submitted_command = None

        # Route to GameOutputWidget. The append_text method now takes 'gradual'
        # For non-orchestrated output, usually display immediately (gradual=False)
        if role == "system":
            self.game_output.append_system_message(content, gradual=False)
        elif role == "gm":
            # General GM messages not part of orchestrated combat flow
            self.game_output.append_gm_message(content, gradual=True) # Allow GM narrative to be gradual
        elif role == "player":
            # This path should be rare now, as player input is directly echoed then processed.
            self.game_output.append_player_message(content, gradual=False)
        else:
            self.game_output.append_text(f"[{role}] {content}", gradual=False)
                      
        self._update_ui() # Still update UI for general status, etc.
    
    def _update_ui(self):
            """Update UI components based on the current game state."""
            state = self.game_engine.state_manager.current_state
            if not state:
                logger.debug("MainWindow._update_ui: No game state to update UI from.")
                self.status_bar.update_status(location="Not in game", game_time="", speed="", mode="N/A")
                if hasattr(self.right_panel, 'character_sheet') and self.right_panel.character_sheet: 
                    self.right_panel.character_sheet._clear_stat_displays() 
                
                inventory_manager_for_clear = get_inventory_manager() 
                logger.info(f"MainWindow._update_ui (no game state): Using InventoryManager instance ID: {getattr(inventory_manager_for_clear, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
                if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager_for_clear) 
                return

            game_over = False
            if state.current_mode == InteractionMode.COMBAT and state.combat_manager:
                if state.combat_manager.state == CombatState.PLAYER_DEFEAT:
                    game_over = True
            elif state.current_mode != InteractionMode.COMBAT: 
                try:
                    stats_manager = self.game_engine._stats_manager
                    if stats_manager:
                        from core.stats.stats_base import DerivedStatType
                        player_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                        if player_hp <= 0: game_over = True
                except Exception as e: logger.error(f"MainWindow._update_ui: Error checking player HP for game over: {e}", exc_info=True)

            if game_over and not hasattr(self, '_game_over_dialog_shown'):
                logger.info("MainWindow._update_ui: Player defeat detected. Showing Game Over dialog.")
                self._game_over_dialog_shown = True 
                self.narrative_command_input.setEnabled(False)
                self.combat_command_input.setEnabled(False)
                dialog = GameOverDialog(self)
                dialog.set_reason("You have been defeated!") 
                dialog.new_game_requested.connect(self._show_new_game_dialog)
                dialog.load_game_requested.connect(self._show_load_game_dialog)
                dialog.load_last_save_requested.connect(self._load_last_save)
                dialog.exec()
                self.narrative_command_input.setEnabled(True)
                self.combat_command_input.setEnabled(True)
                if hasattr(self, '_game_over_dialog_shown'): 
                    delattr(self, '_game_over_dialog_shown') 
                return 
            
            current_mode_enum = state.current_mode
            current_mode_name = current_mode_enum.name if hasattr(current_mode_enum, 'name') else str(current_mode_enum)
            logger.info(f"MainWindow._update_ui: Updating UI. Target mode: {current_mode_name}. Current QStackedWidget widget: {self.mode_stacked_widget.currentWidget().objectName() if self.mode_stacked_widget.currentWidget() else 'None'}")

            is_transitioning_to_combat = getattr(state, 'is_transitioning_to_combat', False)
            combat_narrative_buffer = getattr(state, 'combat_narrative_buffer', [])

            if current_mode_name == "COMBAT":
                view_switched_this_call = False
                if self.mode_stacked_widget.currentWidget() != self.combat_view:
                    logger.info(f"MainWindow._update_ui: Switching to combat_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.combat_view)
                    view_switched_this_call = True
                else:
                    logger.info("MainWindow._update_ui: combat_view is already the current widget.")

                # Ensure combat_view is visible and updated, regardless of whether it was just switched.
                self.combat_view.setVisible(True) # Explicitly ensure visibility
                self.combat_view.update() # Request a repaint of the combat_view
                self.mode_stacked_widget.update() # Request a repaint of the QStackedWidget
                
                if view_switched_this_call:
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.combat_view:
                        logger.info(f"MainWindow._update_ui: Successfully set combat_view as current widget in QStackedWidget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set combat_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                    
                    if hasattr(self.right_panel, 'tab_widget'): 
                        self.right_panel.tab_widget.setCurrentIndex(0)

                if is_transitioning_to_combat and combat_narrative_buffer:
                    logger.info(f"MainWindow._update_ui: Combat transition: Queuing {len(combat_narrative_buffer)} buffered messages with Orchestrator.")
                    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
                    
                    buffer_event = DisplayEvent(
                        type=DisplayEventType.BUFFER_FLUSH,
                        content=list(combat_narrative_buffer), 
                        role="gm", 
                        target_display=DisplayTarget.COMBAT_LOG,
                        gradual_visual_display=True,
                        tts_eligible=True
                    )
                    self.game_engine._combat_orchestrator.add_event_to_queue(buffer_event)
                    
                    state.combat_narrative_buffer.clear() 
                    state.is_transitioning_to_combat = False 
                    logger.debug("MainWindow._update_ui: Cleared combat_narrative_buffer and reset is_transitioning_to_combat flag.")
                
                # Call combat_display.update_display to refresh its content
                logger.info("MainWindow._update_ui (COMBAT mode): Calling combat_display.update_display.")
                self.combat_display.update_display(state) 
                
                if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player) 

                combat_manager = state.combat_manager 
                if view_switched_this_call and combat_manager and combat_manager.current_step == CombatStep.STARTING_COMBAT:
                    if not self.game_engine._combat_orchestrator.is_processing_event and not self.game_engine._combat_orchestrator.event_queue:
                        logger.info(f"MainWindow._update_ui (view switched to COMBAT this call) triggering initial CombatManager.process_combat_step() as Orchestrator is idle.")
                        QTimer.singleShot(10, lambda cm=combat_manager, eng=self.game_engine: cm.process_combat_step(eng))
                elif combat_manager and combat_manager.current_step == CombatStep.AWAITING_PLAYER_INPUT:
                     logger.debug("MainWindow._update_ui: CombatManager is AWAITING_PLAYER_INPUT. No nudge needed.")


            else: # Not in Combat mode
                if self.mode_stacked_widget.currentWidget() != self.narrative_view:
                    logger.info(f"MainWindow._update_ui: Switching to narrative_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.narrative_view:
                        logger.info(f"MainWindow._update_ui: Successfully set narrative_view as current widget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set narrative_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                
                self.narrative_view.setVisible(True) # Ensure narrative view is visible
                self.narrative_view.update()
                self.mode_stacked_widget.update()


                if is_transitioning_to_combat: 
                    logger.warning("MainWindow._update_ui: Was transitioning to combat, but now in narrative. Resetting transition flag.")
                    state.is_transitioning_to_combat = False 
                    state.combat_narrative_buffer.clear()


            if current_mode_enum == InteractionMode.TRADE and \
               (self._previous_mode is None or self._previous_mode != InteractionMode.TRADE):
                partner_id = getattr(state, 'current_trade_partner_id', None)
                partner_name = "Unknown NPC"
                if partner_id and state.world: 
                    partner_obj = getattr(state.world, 'get_character', lambda pid: None)(partner_id)
                    if partner_obj: partner_name = getattr(partner_obj, 'name', "Unknown NPC")
                self.game_output.append_system_message(f"Trade started with {partner_name}.", gradual=False)

            self._previous_mode = current_mode_enum
            if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player)

            inventory_manager = get_inventory_manager() 
            logger.info(f"MainWindow._update_ui: Using InventoryManager instance ID: {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
            if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager)
            
            journal_data = getattr(state, "journal", None)
            if journal_data is not None and hasattr(self.right_panel, 'update_journal'): self.right_panel.update_journal(journal_data)

            self.status_bar.update_status(
                location=getattr(state.player, 'current_location', 'Unknown') if state.player else 'N/A',
                game_time=self.game_engine.game_loop.game_time.get_formatted_time(),
                speed=self.game_engine.game_loop.speed.name,
                mode=current_mode_name 
            )

    def _show_new_game_dialog(self):
        """Show dialog for creating a new game."""
        from gui.dialogs.character_creation_dialog import CharacterCreationDialog
        dialog = CharacterCreationDialog(self)
        if dialog.exec():
            character_data = dialog.get_character_data()
            if not character_data: 
                logger.warning("New game character creation cancelled or failed validation in dialog.")
                return

            logger.info(f"Character data received from dialog. Preparing to start panel animations.")
            
            # Start panel animations, passing character_data to be used after animation
            # This will eventually call _start_game_flow_after_animation
            self._start_panel_animations(character_data)
            
            # DO NOT start game engine here. It will be started by _start_game_flow_after_animation.
        else:
            logger.info("New game dialog cancelled by user.")

    def _show_save_game_dialog(self):
        """Show dialog for saving the game."""
        from gui.dialogs.save_game_dialog import SaveGameDialog
        dialog = SaveGameDialog(self)
        if dialog.exec():
            # Save the game with the provided name
            save_name = dialog.save_name_edit.text()
            saved_path = self.game_engine.save_game(save_name)
            
            if saved_path:
                QMessageBox.information(
                    self, 
                    "Game Saved", 
                    f"Game saved successfully to {saved_path}"
                )
    
    def _show_load_game_dialog(self):
        """Show dialog for loading a saved game."""
        from gui.dialogs.load_game_dialog import LoadGameDialog
        dialog = LoadGameDialog(self)
        if dialog.exec():
            # Load the selected save
            save_filename = dialog.selected_save
            if save_filename:
                loaded_state = self.game_engine.load_game(save_filename)
                
                if loaded_state:
                    # Ensure journal exists
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": self.game_engine.state_manager.current_state.player.background,
                            "quests": {},
                            "notes": []
                        }
                    
                    # Ensure the stats manager is fully initialized
                    self.game_engine.state_manager.ensure_stats_manager_initialized()
                    
                    # Update UI
                    self._update_ui()
                    
                    # Force character sheet update with current player
                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                else:
                    QMessageBox.warning(
                        self, 
                        "Load Failed", 
                        f"Failed to load game from {save_filename}"
                    )
    
    def _show_settings_dialog(self):
        """Show dialog for game settings."""
        logger.info("Attempting to show SettingsDialog...") # Log entry
        from gui.dialogs.settings.settings_dialog import SettingsDialog
        logger.info("Imported SettingsDialog.") # Log import success

        try:
            dialog = SettingsDialog(self)
            logger.info("SettingsDialog instance created.") # Log instance creation
        except Exception as e:
            logger.error(f"Error INSTANTIATING SettingsDialog: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"Failed to create settings dialog:\n{e}")
            return

        # Connect the background preview signal from the BackgroundTab within the SettingsDialog
        connected = False
        if hasattr(dialog, 'background_tab') and hasattr(dialog.background_tab, 'preview_background_changed'):
            try:
                # Connect the signal that now emits the full filename
                dialog.background_tab.preview_background_changed.connect(self.update_background)
                connected = True
                logger.info("Connected background_preview_changed signal for live preview.")
            except Exception as e:
                 logger.error(f"Error connecting background_preview_changed signal: {e}")
        else:
            logger.warning("Could not find background_tab or preview_background_changed signal in SettingsDialog.")

        saved = False
        try:
            logger.info("Attempting to execute SettingsDialog...") # Log before exec
            # Execute the dialog
            result = dialog.exec()
            logger.info(f"SettingsDialog execution finished with result: {result}") # Log after exec
            if result == QDialog.Accepted: # Check result code
                saved = True
        except Exception as e:
             logger.error(f"Error EXECUTING SettingsDialog: {e}", exc_info=True)
             QMessageBox.critical(self, "Error", f"Failed to execute settings dialog:\n{e}")
        finally:
            # Disconnect signal after dialog is closed
            if connected:
                try:
                    dialog.background_tab.preview_background_changed.disconnect(self.update_background)
                    logger.info("Disconnected background_preview_changed signal.")
                except Exception as e:
                     logger.warning(f"Failed to disconnect background_preview_changed signal: {e}")

        if saved: # Process saved settings only if dialog was accepted
            logger.info("Settings dialog accepted. Applying settings...") # Log applying settings
            # Apply new settings
            settings = SettingsDialog.get_settings() # Re-fetch to be sure

            # Update resolution if needed
            resolution = settings["display"]["windowed_size"] # Use windowed_size now
            current_state = settings["display"]["window_state"]

            logger.info(f"Applying settings - State: {current_state}, Windowed Size: {resolution}")

            # Apply window state changes
            if current_state == "fullscreen":
                if not self.isFullScreen(): self.showFullScreen()
            elif current_state == "maximized":
                 if not self.isMaximized(): self.showMaximized()
            else: # windowed
                 if self.isFullScreen() or self.isMaximized(): self.showNormal()
                 # Check if size actually needs changing
                 if QSize(resolution[0], resolution[1]) != self.size():
                     self.resize(resolution[0], resolution[1]) # Use tuple values

            # Update styling (includes non-background styles)
            self._update_styling()

            # Explicitly apply the *saved* background setting after dialog closes
            q_settings = QSettings("RPGGame", "Settings")
            saved_filename = q_settings.value("style/background_filename", None)
            if saved_filename:
                 logger.info(f"Applying saved background from QSettings: {saved_filename}")
                 self.update_background(saved_filename)
            else:
                 logger.warning("Could not read saved background filename after settings dialog closed.")

            # Update UI based on new settings (e.g., status bar, panels)
            # self._update_ui() # Update UI can be complex, might re-trigger things, maybe call specific updates?
            # Let's rely on the window state change and styling update for now.

            # Show confirmation
            self.game_output.append_system_message("Settings saved successfully.")
            logger.info("Settings applied successfully.")
        else:
             logger.info("Settings dialog cancelled or closed without saving.")
    
    def update_background(self, filename: Optional[str]):
        """Load and apply a new background image or GIF to the main window."""
        logger.info(f"Attempting to update background to: {filename}")

        # Stop and clear any existing movie/pixmap
        current_movie = self.background_label.movie()
        if current_movie:
            current_movie.stop()
            self.background_label.setMovie(None)
        self.background_label.setPixmap(QPixmap())
        # Reset palette to default in case previous was PNG
        self.background_container.setAutoFillBackground(False) # Important! Don't let palette fill container
        self.background_label.setProperty("current_background", None) # Store current bg filename

        if not filename:
            logger.warning("No background filename provided, clearing background.")
            # Optionally set a default color on the label if needed
            self.background_label.setStyleSheet("background-color: #1E1E1E;")
            return

        name, ext = os.path.splitext(filename)
        ext_lower = ext.lower()

        if ext_lower == ".png":
            pixmap = self.resource_manager.get_background_pixmap(name)
            if not pixmap.isNull():
                self.background_label.setPixmap(pixmap) # Label scales content
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied PNG background: {filename}")
            else:
                logger.warning(f"Failed to load PNG background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")

        elif ext_lower == ".gif":
            movie = self.resource_manager.get_background_movie(name)
            if movie.isValid():
                self.background_label.setMovie(movie)
                movie.start()
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied GIF background: {filename}")
            else:
                logger.warning(f"Failed to load GIF background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")
        else:
            logger.error(f"Unsupported background file type: {filename}")
            self.background_label.setStyleSheet("background-color: #1E1E1E;") # Fallback color

    def _load_and_apply_initial_background(self):
        """Load the saved background filename from settings and apply it.
        If no valid setting is found, use the first available background alphabetically.
        """
        settings = QSettings("RPGGame", "Settings")
        # Read the full filename setting
        saved_filename = settings.value("style/background_filename", None)

        available_backgrounds = self.resource_manager.list_background_names() # Gets list of (name, ext)
        final_filename = None

        # Check if saved filename exists in the available list
        if saved_filename:
            found = False
            for name, ext in available_backgrounds:
                if f"{name}{ext}" == saved_filename:
                    final_filename = saved_filename
                    found = True
                    break
            if found:
                logger.info(f"Using saved background: {final_filename}")
            else:
                logger.warning(f"Saved background '{saved_filename}' not found in available list.")
                saved_filename = None # Treat as not found

        # If no valid saved name, use the first available background
        if not final_filename and available_backgrounds:
            first_name, first_ext = available_backgrounds[0] # Use first alphabetically
            final_filename = f"{first_name}{first_ext}"
            logger.info(f"No valid saved background found. Using first available: {final_filename}")
        elif not final_filename:
             logger.warning("No saved background setting found and no backgrounds available in images/gui/background/. Applying fallback color.")
             # update_background will handle the fallback color if name is None

        self.update_background(final_filename) # Pass None if no background is available

    def _update_styling(self):
        """Update UI styling based on saved settings."""
        # Update game output styling and formats
        self.game_output._update_formats()
        self.game_output._setup_background()
        
        # Get settings for command input styling
        settings = QSettings("RPGGame", "Settings")
        
        # Update command input styling
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")
        
        # Create a dark frame around command input and enter button
        # Get transparency setting
        input_opacity = int(settings.value("style/input_opacity", 100))
        opacity_percent = input_opacity / 100.0
        
        # Calculate RGB values for the background
        bg_color_obj = QColor("#333333")
        r, g, b = bg_color_obj.red(), bg_color_obj.green(), bg_color_obj.blue()
        
        # Common style for command inputs
        command_input_style = f"""
            CommandInputWidget {{
                background-color: rgba({r}, {g}, {b}, {opacity_percent});
                border-radius: 10px;
                padding: 5px;
                border: 2px solid #333333; /* Same as left/right panels */
            }}
            QLineEdit {{
                background-color: rgba(255, 255, 255, 0.7);
                color: {user_input_font_color};
                border: 1px solid #c4b59d;
                border-radius: 4px;
                padding: 8px;
                font-family: '{user_input_font_family}';
                font-size: {user_input_font_size}pt;
                margin-left: 5px;
                margin-right: 5px;
            }}
        """
        
        # Apply style to both command inputs
        self.narrative_command_input.setStyleSheet(command_input_style)
        self.combat_command_input.setStyleSheet(command_input_style)
    
    def _show_llm_settings_dialog(self):
        """Show dialog for LLM settings."""
        dialog = LLMSettingsDialog(self)
        dialog.settings_saved.connect(self._on_llm_settings_saved)
        dialog.exec()
    
    def _on_llm_settings_saved(self):
        """Handle LLM settings saved event."""
        # Update UI elements that depend on LLM settings
        is_llm_enabled = self.game_engine._use_llm
        
        # Add UI feedback to show LLM status when explicitly changed through settings
        if is_llm_enabled:
            self.game_output.append_system_message("LLM processing is now enabled.")
        else:
            self.game_output.append_system_message("LLM processing is now disabled.")

    # Removed _delayed_character_update method - we now use direct update instead of timers
    
    def closeEvent(self, event):
        """Handle window close event."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.Yes | QMessageBox.No, 
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def resizeEvent(self, event):
        """Handle window resize event to keep background and content sized correctly."""
        super().resizeEvent(event)
        # Keep background label and content widget filling the container
        if hasattr(self, 'background_label'): # Check if widgets exist yet
             self.background_label.setGeometry(0, 0, event.size().width(), event.size().height())
        if hasattr(self, 'main_content_widget'):
             self.main_content_widget.setGeometry(0, 0, event.size().width(), event.size().height())

    def _load_last_save(self):
        """Loads the most recent non-auto save file."""
        logger.info("Attempting to load last save.")
        from core.utils.save_manager import SaveManager # Local import
        save_manager = SaveManager()
        try:
            # Get recent saves, excluding backups and auto-saves initially
            saves = save_manager.get_recent_saves(count=10, include_backups=False) # Get a few recent ones
            last_manual_save = None
            for save in saves:
                 if not save.auto_save:
                      last_manual_save = save
                      break # Found the most recent manual save

            if last_manual_save:
                save_filename = f"{last_manual_save.save_id}/{SaveManager.STATE_FILENAME}" # Need correct path format if StateManager expects full path or just ID
                save_id = last_manual_save.save_id # Use the ID for loading
                logger.info(f"Found last manual save: {last_manual_save.save_name} (ID: {save_id})")

                # Call engine's load_game method
                loaded_state = self.game_engine.load_game(save_id) # Pass save_id

                if loaded_state:
                    # Ensure journal exists (similar to _show_load_game_dialog)
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": getattr(self.game_engine.state_manager.current_state.player, 'background', ''),
                            "quests": {},
                            "notes": []
                        }
                    self.game_engine.state_manager.ensure_stats_manager_initialized()
                    self._update_ui() # Update UI after load
                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                    self.game_output.append_system_message(f"Loaded last save: {last_manual_save.save_name}")
                else:
                    QMessageBox.warning(self, "Load Failed", f"Failed to load last save: {last_manual_save.save_name}")
                    # If last save fails, open the regular load dialog
                    self._show_load_game_dialog()
            else:
                logger.warning("No manual saves found to load.")
                QMessageBox.information(self, "No Last Save", "No manual save file found. Please load manually or start a new game.")
                # Open the regular load dialog as fallback
                self._show_load_game_dialog()
        except Exception as e:
            logger.error(f"Error loading last save: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An error occurred while trying to load the last save:\n{e}")
            self._show_load_game_dialog() # Fallback to regular load dialog

    @Slot(object) 
    def process_orchestrated_display_event(self, event):
        """
        Handles DisplayEvents routed from the CombatOutputOrchestrator via the GameEngine.
        This method sends the content to the appropriate UI display widget.
        """
        from core.orchestration.events import DisplayEvent, DisplayTarget, DisplayEventType 
        if not isinstance(event, DisplayEvent):
            logger.error(f"MainWindow received non-DisplayEvent object: {type(event)}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()
            return

        logger.info(f"MainWindow processing orchestrated event: {event}")
        state = self.game_engine.state_manager.current_state

        target_widget = None
        # Determine primary target widget
        if event.target_display == DisplayTarget.COMBAT_LOG:
            target_widget = self.combat_display
        elif event.target_display == DisplayTarget.MAIN_GAME_OUTPUT:
            target_widget = self.game_output
        else: # Default based on mode if target not explicit
            if state and state.current_mode == InteractionMode.COMBAT:
                target_widget = self.combat_display
            else:
                target_widget = self.game_output
        
        if not target_widget and event.type not in [DisplayEventType.TURN_ORDER_UPDATE, DisplayEventType.UI_BAR_UPDATE_PHASE1, DisplayEventType.UI_BAR_UPDATE_PHASE2]: # These might not have a primary text widget
            logger.error(f"No target widget found for orchestrated event: {event} and not a special UI event.")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete() 
            return

        # Handle event types
        if event.type == DisplayEventType.BUFFER_FLUSH:
            if isinstance(event.content, list) and target_widget == self.combat_display:
                if hasattr(self.combat_display, 'append_buffered_messages'):
                    self.combat_display.append_buffered_messages(event.content, event.gradual_visual_display)
                else: 
                    for line_content in event.content:
                        self.combat_display.append_orchestrated_event_content(str(line_content), event.role or "gm", event.gradual_visual_display)
            else:
                logger.error(f"Invalid content type or target for BUFFER_FLUSH event: {type(event.content)}, target: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()

        elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1 or event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
            logger.debug(f"Handling UI_BAR_UPDATE event: {event.metadata}")
            entity_id = event.metadata.get("entity_id")
            bar_type = event.metadata.get("bar_type") 
            
            # Update CombatEntityWidget in CombatDisplay
            entity_widget_combat_display = self.combat_display.entity_widgets.get(entity_id)
            if entity_widget_combat_display:
                if hasattr(entity_widget_combat_display, f"animate_{event.type.name.lower()}"):
                    getattr(entity_widget_combat_display, f"animate_{event.type.name.lower()}")(event.metadata)

            # Update CharacterSheet if it's the player
            player_id = None
            if state and state.player:
                 player_id = getattr(state.player, 'id', getattr(state.player, 'stats_manager_id', None))

            if entity_id == player_id and self.right_panel and self.right_panel.character_sheet:
                if event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1:
                    self.right_panel.character_sheet.player_resource_bar_update_phase1(bar_type, event.metadata)
                elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
                    self.right_panel.character_sheet.player_resource_bar_update_phase2(bar_type, event.metadata)
            
            # UI_BAR_UPDATE events often complete their "visual" part quickly by calling orchestrator.
            # If _handle_visual_display_complete wasn't called by the widget, call it here.
            # However, CombatEntityWidget.animate_... methods *do* call it.
            # CharacterSheet player_resource_bar_update methods DO NOT currently call it.
            # For CharacterSheet updates, the "visual" part is effectively done after its method runs.
            if entity_id == player_id: # If it was for player, CS handled it.
                 if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)


        elif event.type == DisplayEventType.TURN_ORDER_UPDATE:
            if self.right_panel and self.right_panel.character_sheet and hasattr(self.right_panel.character_sheet, 'handle_turn_order_update'):
                self.right_panel.character_sheet.handle_turn_order_update(event.content) # event.content is the data dict
            # This event is primarily for CharacterSheet, CombatDisplay updates turn order itself.
            # Signal completion immediately as CharacterSheet update is synchronous.
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                 QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)


        elif isinstance(event.content, str): # For NARRATIVE_*, SYSTEM_MESSAGE
            if target_widget == self.combat_display:
                self.combat_display.append_orchestrated_event_content(
                    event_content=event.content,
                    event_role=event.role or "system",
                    is_gradual=event.gradual_visual_display
                )
            elif target_widget == self.game_output:
                text_format = None 
                if event.role == "system": text_format = self.game_output.system_format
                elif event.role == "gm": text_format = self.game_output.gm_format
                elif event.role == "player": text_format = self.game_output.player_format
                self.game_output.append_text(event.content, text_format, event.gradual_visual_display)
            elif target_widget is None and event.type == DisplayEventType.TURN_ORDER_UPDATE:
                 # This was already handled above, but log if it falls through
                 logger.debug("TURN_ORDER_UPDATE already handled for CharacterSheet, no primary text widget needed.")
            else:
                logger.error(f"Unhandled target widget for orchestrated string event: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()
        else:
            logger.error(f"Orchestrated event has non-string content and is not a known special type: {event}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()

    def _initialize_panel_effects(self):
        """Initialize QGraphicsOpacityEffect for panels that will be animated."""
        if not hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect = QGraphicsOpacityEffect(self.center_widget)
            self.center_widget.setGraphicsEffect(self.center_opacity_effect)
            self.center_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect = QGraphicsOpacityEffect(self.right_panel)
            self.right_panel.setGraphicsEffect(self.right_panel_opacity_effect)
            self.right_panel_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'status_bar_opacity_effect'):
            self.status_bar_opacity_effect = QGraphicsOpacityEffect(self.status_bar)
            self.status_bar.setGraphicsEffect(self.status_bar_opacity_effect)
            self.status_bar_opacity_effect.setOpacity(0.0)

    def _start_panel_animations(self, character_data: Dict[str, Any]):
        """Starts the animation sequence for showing the main game panels."""
        self._character_data_for_new_game = character_data 

        self._initialize_panel_effects()

        # 1. Make panels visible (for layout) but keep them disabled and transparent
        self.center_widget.setVisible(True)
        self.center_widget.setEnabled(False) # Keep disabled during animation
        self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False) # Keep disabled during animation
        # Ensure right_panel is set to its desired initial expanded state before animation
        if not self.right_panel.isExpanded(): 
             self.right_panel.setExpanded(True) # Set its state, width animation will be part of its logic
        self.right_panel_opacity_effect.setOpacity(0.0)

        animation_duration = 300 

        center_anim = QPropertyAnimation(self.center_opacity_effect, b"opacity", self)
        center_anim.setDuration(animation_duration)
        center_anim.setStartValue(0.0)
        center_anim.setEndValue(1.0)
        center_anim.setEasingCurve(QEasingCurve.InOutQuad)

        right_panel_anim = QPropertyAnimation(self.right_panel_opacity_effect, b"opacity", self)
        right_panel_anim.setDuration(animation_duration)
        right_panel_anim.setStartValue(0.0)
        right_panel_anim.setEndValue(1.0)
        right_panel_anim.setEasingCurve(QEasingCurve.InOutQuad)

        self.parallel_anim_group = QParallelAnimationGroup(self)
        self.parallel_anim_group.addAnimation(center_anim)
        self.parallel_anim_group.addAnimation(right_panel_anim)

        self.parallel_anim_group.finished.connect(self._animate_status_bar_in)
        self.parallel_anim_group.start(QPropertyAnimation.DeleteWhenStopped)

    @Slot()
    def _animate_status_bar_in(self):
        """Makes the status bar visible and animates its fade-in."""
        # Enable the center and right panels now that their fade-in is complete
        self.center_widget.setEnabled(True)
        self.right_panel.setEnabled(True)
        logger.info("Center widget and Right panel enabled after fade-in.")

        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False) # Keep disabled during its own animation
        self.status_bar_opacity_effect.setOpacity(0.0)

        status_bar_anim = QPropertyAnimation(self.status_bar_opacity_effect, b"opacity", self)
        status_bar_anim.setDuration(200) 
        status_bar_anim.setStartValue(0.0)
        status_bar_anim.setEndValue(1.0)
        status_bar_anim.setEasingCurve(QEasingCurve.InOutQuad)

        status_bar_anim.finished.connect(self._start_game_flow_after_animation)
        status_bar_anim.start(QPropertyAnimation.DeleteWhenStopped) 

    @Slot()
    def _start_game_flow_after_animation(self):
        """Final step after all panel animations are complete. Starts the game engine flow."""
        self.status_bar.setEnabled(True)
        logger.info("Status bar enabled after fade-in.")
        logger.info("All panel animations complete. Starting game engine flow.")

        character_data = getattr(self, '_character_data_for_new_game', None)
        if not character_data:
            logger.error("Character data not found after animation. Cannot start new game.")
            QMessageBox.critical(self, "Error", "Failed to retrieve character data to start the game.")
            # Reset UI to pre-new-game state
            self.center_widget.setVisible(False)
            self.center_widget.setEnabled(False)
            if hasattr(self, 'center_opacity_effect'): self.center_opacity_effect.setOpacity(0.0)
            
            self.right_panel.setVisible(False)
            self.right_panel.setEnabled(False)
            if hasattr(self, 'right_panel_opacity_effect'): self.right_panel_opacity_effect.setOpacity(0.0)

            self.status_bar.setVisible(False)
            self.status_bar.setEnabled(False)
            if hasattr(self, 'status_bar_opacity_effect'): self.status_bar_opacity_effect.setOpacity(0.0)
            return

        player_name = character_data['name']
        race = character_data['race']
        path = character_data['path']
        origin_id = character_data.get('origin_id', '') # Get origin_id
        sex = character_data.get('sex', 'Male')
        # 'description' from character_data is the origin's intro_text/background
        origin_description_as_background = character_data.get('description', '') 
        character_image = character_data.get('character_image')
        use_llm = character_data.get('use_llm', True)
        custom_stats = None
        if 'stats' in character_data:
            if all(isinstance(val, int) for val in character_data['stats'].values()):
                custom_stats = character_data['stats']
            else: 
                logger.warning("Unexpected stats format from character_data, attempting to parse.")
                temp_stats = {}
                for stat_name, stat_info in character_data['stats'].items():
                    if isinstance(stat_info, dict) and 'base' in stat_info:
                        temp_stats[stat_name] = stat_info['base']
                    elif isinstance(stat_info, int):
                         temp_stats[stat_name] = stat_info
                if temp_stats: custom_stats = temp_stats
        
        logger.info(f"Starting new game with resolved data: Name={player_name}, Race={race}, Path={path}, OriginID={origin_id}, Sex={sex}, LLM={use_llm}, Stats={custom_stats is not None}")

        self.game_engine.start_new_game(
            player_name=player_name, 
            race=race, 
            path=path, 
            background=origin_description_as_background, # Pass origin description as background
            sex=sex,
            character_image=character_image,
            stats=custom_stats,
            origin_id=origin_id # Pass origin_id here
        )
        
        self.game_engine.set_llm_enabled(use_llm)
        
        # Ensure journal quests is a dictionary
        initial_quests_data = character_data.get('initial_quests', [])
        journal_quests = {}
        if isinstance(initial_quests_data, dict):
            journal_quests = initial_quests_data
        elif isinstance(initial_quests_data, list):
            logger.warning(f"Initial quests from origin is a list: {initial_quests_data}. Initializing journal quests as an empty dictionary. Full quest population from origin list is not yet implemented here.")
        
        current_game_state = self.game_engine.state_manager.current_state
        if current_game_state:
            if not hasattr(current_game_state, "journal") or current_game_state.journal is None:
                current_game_state.journal = {
                    "character": origin_description_as_background, # Use the same background/origin text
                    "quests": journal_quests,
                    "notes": []
                }
            # Ensure player state's origin_id is set, if GameEngine.start_new_game didn't already
            if not current_game_state.player.origin_id:
                 current_game_state.player.origin_id = origin_id
        
        self._update_ui() 
        self.game_engine.state_manager.ensure_stats_manager_initialized()
        
        if current_game_state and current_game_state.player:
            self.right_panel.update_character(current_game_state.player)

        # Clean up the temporary data
        if hasattr(self, '_character_data_for_new_game'):
            delattr(self, '_character_data_for_new_game')
```

### File: ui\dialogs\export_dialog.py

```python
"""
Export dialog for the World Configurator Tool.
"""

import logging
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QCheckBox, QLabel,
    QPushButton, QHBoxLayout, QGroupBox
)

from gui.dialogs.base_dialog import BaseDialog

logger = logging.getLogger("world_configurator.ui.dialogs.export")

class ExportDialog(BaseDialog):
    """
    Dialog for exporting project to the game.
    """

    def __init__(self, parent=None):
        """
        Initialize the dialog.

        Args:
            parent: The parent widget.
        """
        super().__init__(parent)

        self.setWindowTitle("Export to Game")
        self.setMinimumWidth(400)

        self._setup_ui()

    def _setup_ui(self):
        """Set up the UI components."""
        # Main layout
        layout = QVBoxLayout(self)

        # Add description
        description = QLabel(
            "This will export the world configuration to the game's configuration directory. "
            "Select the components you want to export:"
        )
        description.setWordWrap(True)
        layout.addWidget(description)

        # Components group box
        components_group = QGroupBox("Components")
        self.components_layout = QVBoxLayout(components_group)

        # Component checkboxes
        self.chk_cultures = QCheckBox("Cultures")
        self.chk_cultures.setChecked(True)
        self.components_layout.addWidget(self.chk_cultures)

        self.chk_races = QCheckBox("Races")
        self.chk_races.setChecked(True)
        self.components_layout.addWidget(self.chk_races)

        self.chk_classes = QCheckBox("Classes")
        self.chk_classes.setChecked(True)
        self.components_layout.addWidget(self.chk_classes)

        self.chk_locations = QCheckBox("Locations")
        self.chk_locations.setChecked(True)
        self.components_layout.addWidget(self.chk_locations)

        self.chk_history = QCheckBox("World History")
        self.chk_history.setChecked(True)
        self.components_layout.addWidget(self.chk_history)

        self.chk_rules = QCheckBox("Fundamental Rules")
        self.chk_rules.setChecked(True)
        self.components_layout.addWidget(self.chk_rules)

        # Updated: Renamed Scenarios to Origins
        self.chk_origins = QCheckBox("Origins")
        self.chk_origins.setChecked(True)
        self.components_layout.addWidget(self.chk_origins)

        self.chk_quests = QCheckBox("Quests")
        self.chk_quests.setChecked(True)
        self.components_layout.addWidget(self.chk_quests)

        self.chk_magic_systems = QCheckBox("Magic Systems")
        self.chk_magic_systems.setChecked(True)
        self.components_layout.addWidget(self.chk_magic_systems)

        layout.addWidget(components_group)

        # Select all/none buttons
        select_buttons = QHBoxLayout()

        self.select_all_btn = QPushButton("Select All")
        self.select_all_btn.clicked.connect(self._select_all)
        select_buttons.addWidget(self.select_all_btn)

        self.select_none_btn = QPushButton("Select None")
        self.select_none_btn.clicked.connect(self._select_none)
        select_buttons.addWidget(self.select_none_btn)

        layout.addLayout(select_buttons)

        # Buttons
        buttons = QHBoxLayout()

        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)

        self.export_btn = QPushButton("Export")
        self.export_btn.clicked.connect(self.accept)
        self.export_btn.setDefault(True)

        buttons.addWidget(self.cancel_btn)
        buttons.addStretch()
        buttons.addWidget(self.export_btn)

        layout.addLayout(buttons)

    def _select_all(self):
        """Select all components."""
        self.chk_cultures.setChecked(True)
        self.chk_races.setChecked(True)
        self.chk_classes.setChecked(True)
        self.chk_locations.setChecked(True)
        self.chk_history.setChecked(True)
        self.chk_rules.setChecked(True)
        self.chk_origins.setChecked(True)
        self.chk_quests.setChecked(True)
        self.chk_magic_systems.setChecked(True)

    def _select_none(self):
        """Deselect all components."""
        self.chk_cultures.setChecked(False)
        self.chk_races.setChecked(False)
        self.chk_classes.setChecked(False)
        self.chk_locations.setChecked(False)
        self.chk_history.setChecked(False)
        self.chk_rules.setChecked(False)
        self.chk_origins.setChecked(False)
        self.chk_quests.setChecked(False)
        self.chk_magic_systems.setChecked(False)


    def get_export_options(self) -> dict:
        """
        Get the export options selected by the user.

        Returns:
            A dictionary of export options.
        """
        return {
            "cultures": self.chk_cultures.isChecked(),
            "races": self.chk_races.isChecked(),
            "classes": self.chk_classes.isChecked(),
            "locations": self.chk_locations.isChecked(),
            "history": self.chk_history.isChecked(),
            "rules": self.chk_rules.isChecked(),
            "origins": self.chk_origins.isChecked(),
            "quests": self.chk_quests.isChecked(),
            "magic_systems": self.chk_magic_systems.isChecked(),

        }
```

### File: ui\dialogs\new_project_dialog.py

```python
"""
New project dialog for the World Configurator Tool.
"""

import logging
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLabel, QLineEdit,
    QPushButton, QHBoxLayout, QMessageBox
)

from gui.dialogs.base_dialog import BaseDialog

logger = logging.getLogger("world_configurator.ui.dialogs.new_project")

class NewProjectDialog(BaseDialog):
    """
    Dialog for creating a new project.
    """
    
    def __init__(self, parent=None):
        """
        Initialize the dialog.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        self.setWindowTitle("New Project")
        self.setMinimumWidth(400)
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the UI components."""
        # Main layout
        layout = QVBoxLayout(self)
        
        # Form layout
        form = QFormLayout()
        
        # Project name field
        self.name_edit = QLineEdit("New World")
        self.name_edit.selectAll()
        form.addRow("Project Name:", self.name_edit)
        
        layout.addLayout(form)
        
        # Buttons
        buttons = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.create_btn = QPushButton("Create")
        self.create_btn.clicked.connect(self._on_create)
        self.create_btn.setDefault(True)
        
        buttons.addWidget(self.cancel_btn)
        buttons.addStretch()
        buttons.addWidget(self.create_btn)
        
        layout.addLayout(buttons)
    
    def _on_create(self):
        """Handle the Create button click."""
        project_name = self.name_edit.text().strip()
        
        if not project_name:
            QMessageBox.warning(
                self,
                "Invalid Name",
                "Please enter a project name."
            )
            return
        
        # Accept the dialog
        self.accept()
    
    def get_project_name(self) -> str:
        """
        Get the project name entered by the user.
        
        Returns:
            The project name.
        """
        return self.name_edit.text().strip()

```

### File: ui\dialogs\settings_dialog.py

```python
"""
Settings dialog for the World Configurator Tool.
"""

import logging
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLabel, QLineEdit,
    QPushButton, QHBoxLayout, QTabWidget, QWidget,
    QCheckBox, QComboBox, QSpinBox, QFileDialog
)

from gui.dialogs.base_dialog import BaseDialog

logger = logging.getLogger("world_configurator.ui.dialogs.settings")

class SettingsDialog(BaseDialog):
    """
    Dialog for editing application settings.
    """
    
    def __init__(self, parent=None):
        """
        Initialize the dialog.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        self.setWindowTitle("Settings")
        self.setMinimumWidth(500)
        self.setMinimumHeight(400)
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the UI components."""
        # Main layout
        layout = QVBoxLayout(self)
        
        # Tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        
        # General tab
        self.general_tab = QWidget()
        self.tab_widget.addTab(self.general_tab, "General")
        
        general_layout = QVBoxLayout(self.general_tab)
        
        # Game path setting
        game_path_layout = QHBoxLayout()
        game_path_layout.addWidget(QLabel("Game Path:"))
        
        self.game_path_edit = QLineEdit()
        game_path_layout.addWidget(self.game_path_edit)
        
        self.browse_btn = QPushButton("Browse...")
        self.browse_btn.clicked.connect(self._browse_game_path)
        game_path_layout.addWidget(self.browse_btn)
        
        general_layout.addLayout(game_path_layout)
        
        # Projects folder setting
        projects_path_layout = QHBoxLayout()
        projects_path_layout.addWidget(QLabel("Projects Folder:"))
        
        self.projects_path_edit = QLineEdit()
        projects_path_layout.addWidget(self.projects_path_edit)
        
        self.browse_projects_btn = QPushButton("Browse...")
        self.browse_projects_btn.clicked.connect(self._browse_projects_path)
        projects_path_layout.addWidget(self.browse_projects_btn)
        
        general_layout.addLayout(projects_path_layout)
        
        # Auto-save settings
        self.autosave_check = QCheckBox("Enable Auto-Save")
        general_layout.addWidget(self.autosave_check)
        
        autosave_interval_layout = QHBoxLayout()
        autosave_interval_layout.addWidget(QLabel("Auto-Save Interval (minutes):"))
        
        self.autosave_interval_spin = QSpinBox()
        self.autosave_interval_spin.setRange(1, 60)
        self.autosave_interval_spin.setValue(5)
        autosave_interval_layout.addWidget(self.autosave_interval_spin)
        
        general_layout.addLayout(autosave_interval_layout)
        
        # Add spacer to fill remaining space
        general_layout.addStretch()
        
        # Advanced tab
        self.advanced_tab = QWidget()
        self.tab_widget.addTab(self.advanced_tab, "Advanced")
        
        advanced_layout = QVBoxLayout(self.advanced_tab)
        
        # Logging level setting
        log_level_layout = QHBoxLayout()
        log_level_layout.addWidget(QLabel("Logging Level:"))
        
        self.log_level_combo = QComboBox()
        self.log_level_combo.addItems(["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"])
        self.log_level_combo.setCurrentText("INFO")
        log_level_layout.addWidget(self.log_level_combo)
        
        advanced_layout.addLayout(log_level_layout)
        
        # Add spacer to fill remaining space
        advanced_layout.addStretch()
        
        # Buttons
        buttons = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        buttons.addWidget(self.cancel_btn)
        buttons.addStretch()
        buttons.addWidget(self.save_btn)
        
        layout.addLayout(buttons)
    
    def _browse_game_path(self):
        """Open file dialog to select the game path."""
        directory = QFileDialog.getExistingDirectory(
            self, "Select Game Directory", self.game_path_edit.text()
        )
        if directory:
            self.game_path_edit.setText(directory)
    
    def _browse_projects_path(self):
        """Open file dialog to select the projects folder."""
        directory = QFileDialog.getExistingDirectory(
            self, "Select Projects Directory", self.projects_path_edit.text()
        )
        if directory:
            self.projects_path_edit.setText(directory)
    
    def get_settings(self) -> dict:
        """
        Get the settings selected by the user.
        
        Returns:
            A dictionary of settings.
        """
        return {
            "game_path": self.game_path_edit.text(),
            "projects_path": self.projects_path_edit.text(),
            "autosave": self.autosave_check.isChecked(),
            "autosave_interval": self.autosave_interval_spin.value(),
            "log_level": self.log_level_combo.currentText()
        }

```

### File: ui\dialogs\__init__.py

```python
"""
Dialog components for the World Configurator Tool.
"""

```

### File: utils\__init__.py

```python
"""
Utility functions for the World Configurator Tool.
"""

```

### File: utils\data_validator.py

```python
"""
Data validation utilities for the World Configurator Tool.
"""

import re
import json
import logging
from typing import Dict, Any, List, Optional, Union, Tuple

logger = logging.getLogger("world_configurator.data_validator")

class ValidationError:
    """
    Represents a validation error in configuration data.
    """
    def __init__(self, field: str, message: str, severity: str = "error"):
        """
        Initialize a ValidationError.
        
        Args:
            field: The field path that has the error.
            message: The error message.
            severity: The severity level ("error", "warning", or "info").
        """
        self.field = field
        self.message = message
        self.severity = severity
    
    def __str__(self) -> str:
        """String representation of the error."""
        return f"{self.severity.upper()} in {self.field}: {self.message}"

class DataValidator:
    """
    Validator for configuration data structures.
    """
    def __init__(self, schema_path: Optional[str] = None):
        """
        Initialize the DataValidator.
        
        Args:
            schema_path: Optional path to a JSON schema file.
        """
        self.schema = None
        if schema_path:
            self.load_schema(schema_path)
    
    def load_schema(self, schema_path: str) -> bool:
        """
        Load a JSON schema from a file.
        
        Args:
            schema_path: Path to the JSON schema file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            with open(schema_path, 'r', encoding='utf-8') as f:
                self.schema = json.load(f)
            logger.debug(f"Loaded schema from {schema_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading schema from {schema_path}: {e}")
            self.schema = None
            return False
    
    def validate_cultures(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate cultures data.
        
        Args:
            data: The cultures data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        if "cultures" not in data:
            errors.append(ValidationError("root", "Missing 'cultures' key"))
            return errors
        
        if not isinstance(data["cultures"], dict):
            errors.append(ValidationError("cultures", "Must be a dictionary"))
            return errors
        
        # Check each culture
        for culture_id, culture in data["cultures"].items():
            # Basic field checks
            if not isinstance(culture, dict):
                errors.append(ValidationError(f"cultures.{culture_id}", "Must be a dictionary"))
                continue
            
            # Check for required fields
            required_fields = ["name", "description", "values", "traditions"]
            for field in required_fields:
                if field not in culture:
                    errors.append(ValidationError(
                        f"cultures.{culture_id}", f"Missing required field: {field}"
                    ))
            
            # Check values
            if "values" in culture and isinstance(culture["values"], list):
                if len(culture["values"]) == 0:
                    errors.append(ValidationError(
                        f"cultures.{culture_id}.values", "Should have at least one value"
                    ))
            
            # Check traditions
            if "traditions" in culture and isinstance(culture["traditions"], list):
                if len(culture["traditions"]) == 0:
                    errors.append(ValidationError(
                        f"cultures.{culture_id}.traditions", "Should have at least one tradition"
                    ))
        
        return errors
    
    def validate_locations(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate locations data.
        
        Args:
            data: The locations data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        if "locations" not in data:
            errors.append(ValidationError("root", "Missing 'locations' key"))
            return errors
        
        if not isinstance(data["locations"], dict):
            errors.append(ValidationError("locations", "Must be a dictionary"))
            return errors
        
        # Check each location
        for location_id, location in data["locations"].items():
            # Basic field checks
            if not isinstance(location, dict):
                errors.append(ValidationError(f"locations.{location_id}", "Must be a dictionary"))
                continue
            
            # Check for required fields
            required_fields = ["name", "description", "type"]
            for field in required_fields:
                if field not in location:
                    errors.append(ValidationError(
                        f"locations.{location_id}", f"Missing required field: {field}"
                    ))
            
            # Check connections
            if "connections" in location:
                if not isinstance(location["connections"], list):
                    errors.append(ValidationError(
                        f"locations.{location_id}.connections", "Must be a list"
                    ))
                else:
                    for i, conn in enumerate(location["connections"]):
                        if not isinstance(conn, dict):
                            errors.append(ValidationError(
                                f"locations.{location_id}.connections[{i}]", "Must be a dictionary"
                            ))
                            continue
                        
                        # Check for required connection fields
                        if "target" not in conn:
                            errors.append(ValidationError(
                                f"locations.{location_id}.connections[{i}]", 
                                "Missing required field: target"
                            ))
        
        return errors
    
    def validate_world_history(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate world history data.
        
        Args:
            data: The world history data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        required_fields = ["name", "description", "eras"]
        for field in required_fields:
            if field not in data:
                errors.append(ValidationError("root", f"Missing required field: {field}"))
        
        # Check eras
        if "eras" in data:
            if not isinstance(data["eras"], list):
                errors.append(ValidationError("eras", "Must be a list"))
            else:
                if len(data["eras"]) == 0:
                    errors.append(ValidationError(
                        "eras", "Should have at least one era", "warning"
                    ))
                
                for i, era in enumerate(data["eras"]):
                    if not isinstance(era, dict):
                        errors.append(ValidationError(f"eras[{i}]", "Must be a dictionary"))
                        continue
                    
                    # Check for required era fields
                    era_required = ["name", "start_year", "end_year", "description", "events"]
                    for field in era_required:
                        if field not in era:
                            errors.append(ValidationError(
                                f"eras[{i}]", f"Missing required field: {field}"
                            ))
                    
                    # Check events
                    if "events" in era:
                        if not isinstance(era["events"], list):
                            errors.append(ValidationError(f"eras[{i}].events", "Must be a list"))
                        else:
                            for j, event in enumerate(era["events"]):
                                if not isinstance(event, dict):
                                    errors.append(ValidationError(
                                        f"eras[{i}].events[{j}]", "Must be a dictionary"
                                    ))
                                    continue
                                
                                # Check for required event fields
                                event_required = ["year", "title", "description"]
                                for field in event_required:
                                    if field not in event:
                                        errors.append(ValidationError(
                                            f"eras[{i}].events[{j}]", 
                                            f"Missing required field: {field}"
                                        ))
        
        return errors
    
    def validate_scenario(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate a scenario definition.
        
        Args:
            data: The scenario data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        required_fields = ["id", "name", "description", "starting_location", "quests"]
        for field in required_fields:
            if field not in data:
                errors.append(ValidationError("root", f"Missing required field: {field}"))
        
        # Check quests
        if "quests" in data:
            if not isinstance(data["quests"], list):
                errors.append(ValidationError("quests", "Must be a list"))
            else:
                for i, quest in enumerate(data["quests"]):
                    if not isinstance(quest, dict):
                        errors.append(ValidationError(f"quests[{i}]", "Must be a dictionary"))
                        continue
                    
                    # Check for required quest fields
                    quest_required = ["id", "title", "description", "objectives"]
                    for field in quest_required:
                        if field not in quest:
                            errors.append(ValidationError(
                                f"quests[{i}]", f"Missing required field: {field}"
                            ))
                    
                    # Check objectives
                    if "objectives" in quest:
                        if not isinstance(quest["objectives"], list):
                            errors.append(ValidationError(
                                f"quests[{i}].objectives", "Must be a list"
                            ))
                        else:
                            for j, objective in enumerate(quest["objectives"]):
                                if not isinstance(objective, dict):
                                    errors.append(ValidationError(
                                        f"quests[{i}].objectives[{j}]", "Must be a dictionary"
                                    ))
                                    continue
                                
                                # Check for required objective fields
                                obj_required = ["id", "description", "type"]
                                for field in obj_required:
                                    if field not in objective:
                                        errors.append(ValidationError(
                                            f"quests[{i}].objectives[{j}]", 
                                            f"Missing required field: {field}"
                                        ))
        
        return errors
    
    def get_validator_for_type(self, data_type: str):
        """
        Get the appropriate validator function for a data type.
        
        Args:
            data_type: The type of data to validate.
        
        Returns:
            A validation function for the specified data type.
        """
        validators = {
            "cultures": self.validate_cultures,
            "locations": self.validate_locations,
            "world_history": self.validate_world_history,
            "scenario": self.validate_scenario,
        }
        
        return validators.get(data_type, lambda x: [])

```

### File: utils\file_manager.py

```python
"""
File management utilities for the World Configurator Tool.
"""

import os
import json
import logging
import shutil
import datetime
from typing import Dict, Any, Optional, Union

logger = logging.getLogger("world_configurator.file_manager")

def get_project_root() -> str:
    """
    Get the root directory of the project.
    
    Returns:
        The absolute path to the project root directory.
    """
    # Go up from the utils directory to find project root
    current_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    return os.path.normpath(os.path.join(current_dir, ".."))

def get_config_dir() -> str:
    """
    Get the configuration directory of the project.
    
    Returns:
        The absolute path to the config directory.
    """
    return os.path.join(get_project_root(), "config")

def get_world_config_dir() -> str:
    """
    Get the world configuration directory.
    
    Returns:
        The absolute path to the world config directory.
    """
    return os.path.join(get_config_dir(), "world")

def ensure_dir_exists(directory: str) -> None:
    """
    Ensure that a directory exists, creating it if necessary.
    
    Args:
        directory: The directory path to check/create.
    """
    if not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)
        logger.info(f"Created directory: {directory}")

def load_json(file_path: str) -> Optional[Dict[str, Any]]:
    """
    Load JSON data from a file.
    
    Args:
        file_path: The path to the JSON file.
    
    Returns:
        The loaded JSON data as a dictionary, or None if loading failed.
    """
    try:
        if not os.path.exists(file_path):
            logger.warning(f"File does not exist: {file_path}")
            return None
        
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        logger.debug(f"Loaded JSON from {file_path}")
        return data
    except Exception as e:
        logger.error(f"Error loading JSON from {file_path}: {e}")
        return None

def save_json(data: Dict[str, Any], file_path: str, pretty: bool = True) -> bool:
    """
    Save JSON data to a file.
    
    Args:
        data: The data to save.
        file_path: The path to the JSON file.
        pretty: Whether to format the JSON for readability.
    
    Returns:
        True if the save was successful, False otherwise.
    """
    try:
        # Ensure the directory exists
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Save with appropriate formatting
        indent = 2 if pretty else None
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=indent, ensure_ascii=False)
        
        logger.debug(f"Saved JSON to {file_path}")
        return True
    except Exception as e:
        logger.error(f"Error saving JSON to {file_path}: {e}")
        return False

def create_backup(file_path: str) -> Optional[str]:
    """
    Create a backup of a file.
    
    Args:
        file_path: The path to the file to back up.
    
    Returns:
        The path to the backup file, or None if backup failed.
    """
    try:
        if not os.path.exists(file_path):
            logger.warning(f"Cannot back up non-existent file: {file_path}")
            return None
        
        # Create backup filename
        backup_path = f"{file_path}.bak"
        
        # Copy file
        shutil.copy2(file_path, backup_path)
        
        logger.debug(f"Created backup: {backup_path}")
        return backup_path
    except Exception as e:
        logger.error(f"Error creating backup of {file_path}: {e}")
        return None

def export_to_game(source_path: str, target_subpath: str) -> bool:
    """
    Export a configuration file to the game's config directory.
    
    Args:
        source_path: The path to the source file.
        target_subpath: The subpath within the game's config directory.
    
    Returns:
        True if the export was successful, False otherwise.
    """
    try:
        if not os.path.exists(source_path):
            logger.warning(f"Source file does not exist: {source_path}")
            return False
        
        # Construct target path
        config_dir = get_config_dir()
        target_path = os.path.join(config_dir, target_subpath)
        
        # Ensure target directory exists
        os.makedirs(os.path.dirname(target_path), exist_ok=True)
        
        # Create backup folder if it doesn't exist
        backup_dir = os.path.join(os.path.dirname(target_path), "backup")
        os.makedirs(backup_dir, exist_ok=True)
        
        # Create timestamped backup if target exists
        if os.path.exists(target_path):
            filename = os.path.basename(target_path)
            name, ext = os.path.splitext(filename)
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"{name}_{timestamp}{ext}"
            backup_path = os.path.join(backup_dir, backup_filename)
            
            try:
                shutil.copy2(target_path, backup_path)
                logger.info(f"Created backup of {target_path} at {backup_path}")
            except Exception as backup_err:
                logger.error(f"Failed to create backup: {backup_err}")
                # Continue with export even if backup fails
        
        # Copy file
        shutil.copy2(source_path, target_path)
        
        logger.info(f"Exported {source_path} to {target_path}")
        return True
    except Exception as e:
        logger.error(f"Error exporting {source_path} to {target_subpath}: {e}")
        return False

def list_files_in_dir(directory: str, extension: Optional[str] = None) -> list:
    """
    List all files in a directory, optionally filtered by extension.
    
    Args:
        directory: The directory to list files from.
        extension: The file extension to filter by, or None for all files.
    
    Returns:
        A list of filenames in the directory.
    """
    try:
        if not os.path.exists(directory) or not os.path.isdir(directory):
            logger.warning(f"Directory does not exist: {directory}")
            return []
        
        if extension:
            # Filter by extension
            return [f for f in os.listdir(directory) 
                  if os.path.isfile(os.path.join(directory, f)) and f.endswith(extension)]
        else:
            # All files
            return [f for f in os.listdir(directory) 
                  if os.path.isfile(os.path.join(directory, f))]
    except Exception as e:
        logger.error(f"Error listing files in {directory}: {e}")
        return []

```

### File: utils\logging_setup.py

```python
"""
Logging setup for the World Configurator Tool.
"""

import os
import logging
import datetime
from logging.handlers import RotatingFileHandler

def setup_logging(level=logging.INFO):
    """
    Set up logging for the World Configurator Tool.
    
    Args:
        level: The logging level to use.
    """
    # Create logs directory if it doesn't exist
    logs_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "logs")
    os.makedirs(logs_dir, exist_ok=True)
    
    # Create log filename with date
    date_str = datetime.datetime.now().strftime("%Y%m%d")
    log_file = os.path.join(logs_dir, f"world_configurator_{date_str}.log")
    
    # Configure root logger
    logger = logging.getLogger()
    logger.setLevel(level)
    
    # Create console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_format = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%H:%M:%S"
    )
    console_handler.setFormatter(console_format)
    
    # Create file handler
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=5 * 1024 * 1024,  # 5 MB
        backupCount=5
    )
    file_handler.setLevel(level)
    file_format = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    file_handler.setFormatter(file_format)
    
    # Add handlers to root logger
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    # Create world_configurator logger
    wc_logger = logging.getLogger("world_configurator")
    wc_logger.setLevel(level)
    
    return wc_logger

```

### File: main.py

```python
#!/usr/bin/env python
"""
World Configurator Tool for the RPG Project.

This tool allows creating and editing world configuration for the RPG game.
"""

import os
import sys
import logging

# Add the project root to the Python path so we can use absolute imports
project_root = os.path.dirname(os.path.abspath(__file__))
if project_root not in sys.path:
    sys.path.insert(0, os.path.dirname(project_root))

from PySide6.QtWidgets import QApplication

from world_configurator.ui.main_window import MainWindow
from world_configurator.utils.logging_setup import setup_logging

def main():
    """
    Main entry point for the World Configurator Tool.
    """
    # Setup logging
    setup_logging()
    logger = logging.getLogger("world_configurator")
    logger.info("Starting World Configurator Tool")
    
    # Create application
    app = QApplication(sys.argv)
    app.setApplicationName("World Configurator")
    app.setApplicationVersion("1.0.0")
    
    # Create main window
    window = MainWindow()
    window.show()
    
    # Run application
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

```

### File: __init__.py

```python
"""
World Configurator Tool Package.
"""

```

