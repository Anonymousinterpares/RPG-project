"""
Centralized input router for the RPG game.

This module provides a unified approach to routing player input based on
game mode, input type, and content analysis.
"""

from typing import Any, Dict, Optional, Tuple, TYPE_CHECKING

from core.base.commands import CommandResult
from core.combat.combat_entity import EntityType
from core.combat.enums import CombatState, CombatStep
from core.interaction.enums import InteractionMode
from core.utils.logging_config import get_logger

# Import the modules for processing the input after routing
from core.game_flow import command_handlers
# Import functions from the refactored interaction processor modules
from core.game_flow.interaction_core import run_unified_loop, process_interactive_text, should_narrative_use_unified_loop
from core.game_flow.npc_interaction import get_npc_intent


if TYPE_CHECKING:
    from core.base.state import GameState
    from core.agents.base_agent import BaseAgent, AgentContext

# Get the module logger
logger = get_logger("INPUT_ROUTER")

# Define essential commands allowed in any mode (without the leading '/')
# These bypass the mode-specific intent handling.
ESSENTIAL_COMMANDS = {"quit", "exit", "save", "load", "help", "status", "llm", "speed", "pause"}
UI_PROXY_COMMANDS = {"examine", "equip", "unequip", "drop", "use"} # Commands that might originate from UI buttons


class InputRouter:
    """
    Centralized router for player input based on game mode and input type.
    
    This class handles the routing of all player input to the appropriate
    processors based on the current game mode, input format, and content analysis.
    It also handles mode transitions and logging of routing decisions.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(InputRouter, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the input router."""
        if self._initialized:
            return
        
        self._initialized = True
        # The command processor instance is not currently used in this class.
        # self._command_processor = get_command_processor()

        logger.info("InputRouter initialized")
    
    def route_input(self, engine: 'GameEngine', input_text: str) -> CommandResult:
        """
        Route player input to the appropriate processor based on mode and type.

        Args:
            engine: The GameEngine instance.
            input_text: The raw input text from the player.

        Returns:
            The result of processing the input.
        """
        logger.debug(f"Routing input: '{input_text}'")

        game_state = engine._state_manager.current_state
        if game_state is None:
            logger.warning("Cannot process input: No current game state")
            return CommandResult.error("No game in progress. Start a new game or load a saved game.")

        input_text = input_text.strip()
        if not input_text:
            return CommandResult.invalid("Please enter a command or action.")

        current_mode = game_state.current_mode
        logger.debug(f"Current mode: {current_mode.name}")
        
        # Check if this input might be a UI-proxied command that should be handled directly
        # by the command_handlers.py and not echoed as player input to GameOutputWidget.
        # This is specifically for commands like "examine {uuid}" which are generated by UI clicks.
        is_ui_generated_command = False
        try:
            parts = input_text.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in UI_PROXY_COMMANDS:
                # Further check if the second part looks like a UUID (simple check)
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10: # Basic UUID-like check
                    is_ui_generated_command = True
                    logger.info(f"Identified as UI-generated command, will not echo: '{input_text}'")
        except Exception:
            pass # Ignore parsing errors here, will be handled by normal routing

        if self._is_essential_command(input_text):
            logger.info(f"Processing essential command: '{input_text}'")
            return self._process_direct_command(engine, game_state, input_text)

        if self._is_direct_command(input_text) and not is_ui_generated_command:
            # Direct commands typed by user (e.g. /look) should still be echoed.
            # UI-generated commands like "examine {uuid}" are "direct" but should not be echoed.
            logger.info(f"Processing direct command: '{input_text}'")
            if not input_text.startswith('//'): # Don't echo dev commands starting with //
                engine._output("player", input_text) # Echo direct commands typed by player
            return self._process_direct_command(engine, game_state, input_text)
        elif is_ui_generated_command: # Handle UI-generated commands that look like direct commands but shouldn't be echoed
            logger.info(f"Processing UI-generated command directly (no echo): '{input_text}'")
            return self._process_direct_command(engine, game_state, input_text)


        # --- Mode-specific routing ---
        if current_mode == InteractionMode.COMBAT:
            logger.info(f"COMBAT input received: '{input_text}'")
            if game_state.combat_manager is None:
                logger.error("COMBAT mode active but CombatManager is None.")
                return CommandResult.error("Internal Error: Combat state invalid.")

            combat_manager = game_state.combat_manager

            # Check if it's awaiting player input specifically
            if combat_manager.current_step == CombatStep.AWAITING_PLAYER_INPUT:
                # Echo player input immediately
                engine._output("player", input_text)
                # Delegate action receiving to CombatManager, passing engine and intent
                combat_manager.receive_player_action(engine, input_text) 
                # Signal that the action was received, combat manager will process
                return CommandResult.success("Action received...")
            else:
                # Not awaiting player input (e.g., NPC turn, resolving action)
                display_name = "Someone else"
                active_id = getattr(combat_manager, '_active_entity_id', None)
                if active_id:
                    entity = combat_manager.entities.get(active_id)
                    if entity: display_name = entity.combat_name
                logger.info(f"Input received during non-player-input step ({combat_manager.current_step.name}). Ignoring.")
                return CommandResult.invalid(f"Please wait, currently processing {display_name}'s turn or resolving actions.")

        elif current_mode == InteractionMode.NARRATIVE:
            # --- PHASE 1: Intent Sentinel classification ---
            if engine._use_llm:
                try:
                    from core.agents.base_agent import AgentContext
                    # Lightweight context for sentinel
                    sentinel_context = AgentContext(
                        game_state={"mode": current_mode.name},
                        player_state={}, world_state={},
                        player_input=input_text, conversation_history=[]
                    )
                    intent_data = engine._agent_manager._intent_sentinel.classify(sentinel_context)
                    intent = intent_data.get("intent")
                    confidence = intent_data.get("confidence", 0.0)
                    
                    logger.info(f"SENTINEL: Detected intent '{intent}' (Confidence: {confidence})")
                    
                    # Direct bypass for STATUS intent (e.g. "show items", "inventory")
                    if intent == "STATUS" and confidence > 0.7:
                        logger.info("SENTINEL: Bypassing to STATUS retrieval.")
                        # Determine which status to show based on input keywords
                        status_cmd = "status"
                        if any(k in input_text.lower() for k in ["inv", "item", "backpack", "pack", "bag"]):
                            status_cmd = "inventory"
                        elif any(k in input_text.lower() for k in ["quest", "log", "objective", "journal"]):
                            status_cmd = "quests"
                        
                        return self._process_direct_command(engine, game_state, status_cmd)

                except Exception as e:
                    logger.error(f"Intent Sentinel routing failed: {e}")

            # ... continue to unified loop ...
            if should_narrative_use_unified_loop(input_text):
                logger.info(f"NARRATIVE input routed to unified loop: '{input_text}'")
                if not is_ui_generated_command: engine._output("player", input_text)
                return run_unified_loop(engine, game_state, input_text)
            else:
                logger.info(f"NARRATIVE input routed to interactive text: '{input_text}'")
                # Echo player input if processed by LLM and not UI-generated
                if engine._use_llm and not is_ui_generated_command:
                    engine._output("player", input_text)
                result = process_interactive_text(engine, input_text)
                # Output LLM response if applicable
                is_welcome_narration = "I've just started a new game" in input_text and "introduce me to the game world" in input_text
                if result.is_success and result.data and "commands" in result.data and not is_welcome_narration:
                    logger.debug(f"Sending output from LLM result. Role 'gm'. Snippet: '{result.message[:100]}...'")
                    if result.message: # Only output if there's a message
                         engine._output("gm", result.message)
                elif result.is_success and result.message: # LLM response without commands, still output it
                    engine._output("gm", result.message)
                return result

        elif current_mode in [InteractionMode.SOCIAL_CONFLICT, InteractionMode.TRADE]:
            # ... (logic for these modes remains the same) ...
            logger.info(f"{current_mode.name} input routed to unified loop: '{input_text}'")
            if not is_ui_generated_command: engine._output("player", input_text)
            # TODO: Implement proper turn handling/state checks for these modes if needed
            return run_unified_loop(engine, game_state, input_text)

        else:
            logger.warning(f"Unknown mode: {current_mode.name}. Falling back to narrative.")
            if not is_ui_generated_command: engine._output("player", input_text)
            return process_interactive_text(engine, input_text)
    
    def _is_essential_command(self, input_text: str) -> bool:
        """Check if the input is an essential command."""
        if input_text.startswith('/'):
            try:
                command_verb = input_text[1:].split(maxsplit=1)[0].lower()
                return command_verb in ESSENTIAL_COMMANDS
            except IndexError:
                pass  # Input was just '/'
        return False
    
    def _is_direct_command(self, input_text: str) -> bool:
        """Check if the input is a direct command (bypassing mode-specific processing)."""
        return (input_text.startswith('command:') or 
                input_text.startswith('//') or 
                input_text.startswith('/'))
    
    def _process_direct_command(self, engine: 'GameEngine', game_state: 'GameState', input_text: str) -> CommandResult:
        """Process a direct command."""
        # Strip 'command:' prefix if present
        command_to_process = input_text
        if input_text.startswith('command:'):
            command_to_process = input_text[8:].strip()
        elif input_text.startswith('/'): # Also strip '/' for consistency if it's not a dev command
            if not input_text.startswith('//'):
                command_to_process = input_text[1:].strip()
            
        # Pass to the command handlers
        return command_handlers.process_direct_command(engine, command_to_process)
    
    def _get_entity_display_name(self, game_state: 'GameState', entity_id: str) -> str:
        """Get the display name for an entity."""
        # Try combat manager first
        if game_state.current_mode == InteractionMode.COMBAT and game_state.combat_manager:
            try:
                entity = game_state.combat_manager.get_entity_by_id(entity_id)
                if entity and hasattr(entity, 'name'):
                    return entity.name
            except Exception as e:
                logger.warning(f"Error getting entity name from combat manager: {e}")

        # Try NPC system
        if hasattr(game_state, 'npc_system') and game_state.npc_system:
            npc = getattr(game_state.npc_system, 'get_npc', lambda id: None)(entity_id)
            if npc and hasattr(npc, 'name'):
                return npc.name

        # Fallback to ID
        return entity_id

# Convenience function
def get_input_router() -> InputRouter:
    """Get the input router instance."""
    return InputRouter()