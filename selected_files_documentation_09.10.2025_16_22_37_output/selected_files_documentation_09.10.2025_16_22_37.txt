# Project Documentation: latest version
Generated on: 2025-10-09 16:22:37

## Project Structure

```
latest version/
├── archiv/
│   ├── gui/
│   │   ├── advanced_config_editor/
│   │   │   ├── form_views/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── items_form.py
│   │   │   │   ├── paths_form.py
│   │   │   │   ├── races_form.py
│   │   │   │   ├── scenarios_form.py
│   │   │   │   └── world_settings_form.py
│   │   │   ├── __init__.py
│   │   │   ├── advanced_config_editor.py
│   │   │   ├── custom_widgets.py
│   │   │   ├── entry_editor.py
│   │   │   ├── schemas.py
│   │   │   └── versioning.py
│   │   ├── inventory/
│   │   │   ├── __init__.py
│   │   │   ├── detail_panels.py
│   │   │   ├── equipment_slot_widget.py
│   │   │   ├── inventory_widget.py
│   │   │   ├── item_widget.py
│   │   │   └── utils.py
│   │   ├── widgets/
│   │   │   ├── __init__.py
│   │   │   ├── music_controls.py
│   │   │   └── widgets-LEGACY-MOVED TO INIT.py
│   │   ├── __init__.py
│   │   ├── conversation_widget.py
│   │   ├── dialogs.py
│   │   ├── game_engine_runner.py
│   │   ├── llm_settings_dialog.py
│   │   ├── log_explorer.py
│   │   ├── logging_handlers.py
│   │   ├── main_window.py
│   │   ├── message_widget.py
│   │   ├── quest_widgets.py
│   │   ├── safe_zone_widget.py
│   │   └── tab_widgets.py
│   └── settings_manager_new.py
├── archiv_dev/
├── config/
│   ├── aliases/
│   │   └── entities.json
│   ├── backup/
│   │   ├── skills_skills_20250912_235959.json
│   │   ├── skills_skills_20250913_002318.json
│   │   ├── skills_skills_20250913_002554.json
│   │   ├── skills_skills_20250913_141551.json
│   │   ├── skills_skills_20250913_141748.json
│   │   ├── skills_skills_20250913_180742.json
│   │   ├── skills_skills_20250913_235905.json
│   │   ├── skills_skills_20250914_130547.json
│   │   ├── skills_skills_20250914_131055.json
│   │   ├── skills_skills_20250914_132944.json
│   │   ├── skills_skills_20250919_095109.json
│   │   ├── skills_skills_20250919_131027.json
│   │   ├── skills_skills_20250919_142500.json
│   │   ├── skills_skills_20251006_220742.json
│   │   ├── skills_skills_20251006_225101.json
│   │   └── skills_skills_20251007_222935.json
│   ├── character/
│   │   ├── backup/
│   │   │   ├── classes_20250418_133031.json
│   │   │   ├── classes_20250418_135120.json
│   │   │   ├── classes_20250912_235959.json
│   │   │   ├── classes_20250913_002318.json
│   │   │   ├── classes_20250913_002554.json
│   │   │   ├── classes_20250913_141551.json
│   │   │   ├── classes_20250913_141748.json
│   │   │   ├── classes_20250913_180742.json
│   │   │   ├── classes_20250913_235905.json
│   │   │   ├── classes_20250914_130547.json
│   │   │   ├── classes_20250914_131055.json
│   │   │   ├── classes_20250914_132944.json
│   │   │   ├── classes_20250919_095109.json
│   │   │   ├── classes_20250919_131027.json
│   │   │   ├── classes_20250919_142500.json
│   │   │   ├── classes_20251006_220742.json
│   │   │   ├── classes_20251006_225101.json
│   │   │   ├── classes_20251007_222935.json
│   │   │   ├── races_20250418_131835.json
│   │   │   ├── races_20250418_132122.json
│   │   │   ├── races_20250418_132911.json
│   │   │   ├── races_20250418_135120.json
│   │   │   ├── races_20250912_235959.json
│   │   │   ├── races_20250913_002318.json
│   │   │   ├── races_20250913_002554.json
│   │   │   ├── races_20250913_141551.json
│   │   │   ├── races_20250913_141748.json
│   │   │   ├── races_20250913_180742.json
│   │   │   ├── races_20250913_235905.json
│   │   │   ├── races_20250914_130547.json
│   │   │   ├── races_20250914_131055.json
│   │   │   ├── races_20250914_132944.json
│   │   │   ├── races_20250919_095109.json
│   │   │   ├── races_20250919_131027.json
│   │   │   ├── races_20250919_142500.json
│   │   │   ├── races_20251006_220742.json
│   │   │   ├── races_20251006_225101.json
│   │   │   └── races_20251007_222935.json
│   │   ├── backgrounds.json
│   │   ├── classes.json
│   │   ├── npc_templates.json
│   │   ├── races.json
│   │   ├── stat_registry.json
│   │   └── stats_config.json
│   ├── combat/
│   │   └── combat_config.json
│   ├── game/
│   │   └── base_config.json
│   ├── gameplay/
│   │   ├── calendar.json
│   │   ├── calendar_master.json
│   │   └── canonical_lists.json
│   ├── items/
│   │   ├── backup/
│   │   │   ├── base_armor_items_armor_20250912_235959.json
│   │   │   ├── base_armor_items_armor_20250913_002318.json
│   │   │   ├── base_armor_items_armor_20250913_002554.json
│   │   │   ├── base_armor_items_armor_20250913_141551.json
│   │   │   ├── base_armor_items_armor_20250913_141748.json
│   │   │   ├── base_armor_items_armor_20250913_180742.json
│   │   │   ├── base_armor_items_armor_20250913_235905.json
│   │   │   ├── base_armor_items_armor_20250914_130547.json
│   │   │   ├── base_armor_items_armor_20250914_131055.json
│   │   │   ├── base_armor_items_armor_20250914_132944.json
│   │   │   ├── base_armor_items_armor_20250919_095109.json
│   │   │   ├── base_armor_items_armor_20250919_131027.json
│   │   │   ├── base_armor_items_armor_20250919_142500.json
│   │   │   ├── base_armor_items_armor_20251006_220742.json
│   │   │   ├── base_armor_items_armor_20251006_225101.json
│   │   │   ├── base_armor_items_armor_20251007_222935.json
│   │   │   ├── base_armor_items_armor_20251007_230717.json
│   │   │   ├── base_weapons_items_weapons_20250912_235959.json
│   │   │   ├── base_weapons_items_weapons_20250913_002318.json
│   │   │   ├── base_weapons_items_weapons_20250913_002554.json
│   │   │   ├── base_weapons_items_weapons_20250913_141551.json
│   │   │   ├── base_weapons_items_weapons_20250913_141748.json
│   │   │   ├── base_weapons_items_weapons_20250913_180742.json
│   │   │   ├── base_weapons_items_weapons_20250913_235905.json
│   │   │   ├── base_weapons_items_weapons_20250914_130547.json
│   │   │   ├── base_weapons_items_weapons_20250914_131055.json
│   │   │   ├── base_weapons_items_weapons_20250914_132944.json
│   │   │   ├── base_weapons_items_weapons_20250919_095109.json
│   │   │   ├── base_weapons_items_weapons_20250919_131027.json
│   │   │   ├── base_weapons_items_weapons_20250919_142500.json
│   │   │   ├── base_weapons_items_weapons_20251006_220302.json
│   │   │   ├── base_weapons_items_weapons_20251006_220742.json
│   │   │   ├── base_weapons_items_weapons_20251006_225101.json
│   │   │   ├── base_weapons_items_weapons_20251007_222935.json
│   │   │   ├── base_weapons_items_weapons_20251007_224914.json
│   │   │   ├── base_weapons_items_weapons_20251007_225231.json
│   │   │   ├── base_weapons_items_weapons_20251007_225824.json
│   │   │   ├── base_weapons_items_weapons_20251007_230517.json
│   │   │   ├── consumables_items_consumables_20250912_235959.json
│   │   │   ├── consumables_items_consumables_20250913_002318.json
│   │   │   ├── consumables_items_consumables_20250913_002554.json
│   │   │   ├── consumables_items_consumables_20250913_141551.json
│   │   │   ├── consumables_items_consumables_20250913_141748.json
│   │   │   ├── consumables_items_consumables_20250913_180742.json
│   │   │   ├── consumables_items_consumables_20250913_235905.json
│   │   │   ├── consumables_items_consumables_20250914_130547.json
│   │   │   ├── consumables_items_consumables_20250914_131055.json
│   │   │   ├── consumables_items_consumables_20250914_132944.json
│   │   │   ├── consumables_items_consumables_20250919_095109.json
│   │   │   ├── consumables_items_consumables_20250919_131027.json
│   │   │   ├── consumables_items_consumables_20250919_142500.json
│   │   │   ├── consumables_items_consumables_20251006_220742.json
│   │   │   ├── consumables_items_consumables_20251006_225101.json
│   │   │   ├── consumables_items_consumables_20251007_222935.json
│   │   │   ├── miscellaneous_items_misc_20250912_235959.json
│   │   │   ├── miscellaneous_items_misc_20250913_002318.json
│   │   │   ├── miscellaneous_items_misc_20250913_002554.json
│   │   │   ├── miscellaneous_items_misc_20250913_141551.json
│   │   │   ├── miscellaneous_items_misc_20250913_141748.json
│   │   │   ├── miscellaneous_items_misc_20250913_180742.json
│   │   │   ├── miscellaneous_items_misc_20250913_235905.json
│   │   │   ├── miscellaneous_items_misc_20250914_130547.json
│   │   │   ├── miscellaneous_items_misc_20250914_131055.json
│   │   │   ├── miscellaneous_items_misc_20250914_132944.json
│   │   │   ├── miscellaneous_items_misc_20250919_095109.json
│   │   │   ├── miscellaneous_items_misc_20250919_131027.json
│   │   │   ├── miscellaneous_items_misc_20250919_142500.json
│   │   │   ├── miscellaneous_items_misc_20251006_220742.json
│   │   │   ├── miscellaneous_items_misc_20251006_225101.json
│   │   │   ├── miscellaneous_items_misc_20251007_222935.json
│   │   │   ├── origin_items_items_origin_20250912_235959.json
│   │   │   ├── origin_items_items_origin_20250913_002318.json
│   │   │   ├── origin_items_items_origin_20250913_002554.json
│   │   │   ├── origin_items_items_origin_20250913_141551.json
│   │   │   ├── origin_items_items_origin_20250913_141748.json
│   │   │   ├── origin_items_items_origin_20250913_180742.json
│   │   │   ├── origin_items_items_origin_20250913_235905.json
│   │   │   ├── origin_items_items_origin_20250914_130547.json
│   │   │   ├── origin_items_items_origin_20250914_131055.json
│   │   │   ├── origin_items_items_origin_20250914_132944.json
│   │   │   ├── origin_items_items_origin_20250919_095109.json
│   │   │   ├── origin_items_items_origin_20250919_131027.json
│   │   │   ├── origin_items_items_origin_20250919_142500.json
│   │   │   ├── origin_items_items_origin_20251006_220742.json
│   │   │   ├── origin_items_items_origin_20251006_225101.json
│   │   │   └── origin_items_items_origin_20251007_222935.json
│   │   ├── base_armor.json
│   │   ├── base_weapons.json
│   │   ├── consumables.json
│   │   ├── miscellaneous.json
│   │   └── origin_items.json
│   ├── llm/
│   │   ├── agents/
│   │   │   ├── combatnarrator.json
│   │   │   ├── context_evaluator.json
│   │   │   ├── narrator.json
│   │   │   └── rule_checker.json
│   │   ├── base_config.json
│   │   ├── models.json
│   │   └── providers.json
│   ├── npc/
│   │   ├── backup/
│   │   │   ├── names_20250919_095109.json
│   │   │   ├── names_20250919_131027.json
│   │   │   ├── names_20250919_142500.json
│   │   │   ├── names_20251006_220742.json
│   │   │   ├── names_20251006_225101.json
│   │   │   ├── names_20251007_222935.json
│   │   │   ├── variants_20251006_220742.json
│   │   │   ├── variants_20251006_225101.json
│   │   │   └── variants_20251007_222935.json
│   │   ├── abilities.json
│   │   ├── abilities.schema.json
│   │   ├── boss_overlays.json
│   │   ├── boss_overlays.schema.json
│   │   ├── families.json
│   │   ├── families.schema.json
│   │   ├── families_factions.json
│   │   ├── generation_rules.json
│   │   ├── generation_rules.schema.json
│   │   ├── names.json
│   │   ├── roles.json
│   │   ├── roles.schema.json
│   │   ├── tags.json
│   │   ├── tags.schema.json
│   │   └── variants.json
│   ├── schemas/
│   │   ├── aliases.schema.json
│   │   ├── npc_family.schema.json
│   │   ├── npc_tags.schema.json
│   │   └── npc_variant.schema.json
│   ├── world/
│   │   ├── base/
│   │   │   ├── backup/
│   │   │   │   ├── cultures_20250912_235959.json
│   │   │   │   ├── cultures_20250913_002318.json
│   │   │   │   ├── cultures_20250913_002554.json
│   │   │   │   ├── cultures_20250913_141551.json
│   │   │   │   ├── cultures_20250913_141748.json
│   │   │   │   ├── cultures_20250913_180742.json
│   │   │   │   ├── cultures_20250913_235905.json
│   │   │   │   ├── cultures_20250914_130547.json
│   │   │   │   ├── cultures_20250914_131055.json
│   │   │   │   ├── cultures_20250914_132944.json
│   │   │   │   ├── cultures_20250919_095109.json
│   │   │   │   ├── cultures_20250919_131027.json
│   │   │   │   ├── cultures_20250919_142500.json
│   │   │   │   ├── cultures_20251006_220742.json
│   │   │   │   ├── cultures_20251006_225101.json
│   │   │   │   ├── cultures_20251007_222935.json
│   │   │   │   ├── fundamental_rules_20250912_235959.json
│   │   │   │   ├── fundamental_rules_20250913_002318.json
│   │   │   │   ├── fundamental_rules_20250913_002554.json
│   │   │   │   ├── fundamental_rules_20250913_141551.json
│   │   │   │   ├── fundamental_rules_20250913_141748.json
│   │   │   │   ├── fundamental_rules_20250913_180742.json
│   │   │   │   ├── fundamental_rules_20250913_235905.json
│   │   │   │   ├── fundamental_rules_20250914_130547.json
│   │   │   │   ├── fundamental_rules_20250914_131055.json
│   │   │   │   ├── fundamental_rules_20250914_132944.json
│   │   │   │   ├── fundamental_rules_20250919_095109.json
│   │   │   │   ├── fundamental_rules_20250919_131027.json
│   │   │   │   ├── fundamental_rules_20250919_142500.json
│   │   │   │   ├── fundamental_rules_20251006_220742.json
│   │   │   │   ├── fundamental_rules_20251006_225101.json
│   │   │   │   ├── fundamental_rules_20251007_222935.json
│   │   │   │   ├── magic_systems_20250912_235959.json
│   │   │   │   ├── magic_systems_20250913_002318.json
│   │   │   │   ├── magic_systems_20250913_002554.json
│   │   │   │   ├── magic_systems_20250913_141551.json
│   │   │   │   ├── magic_systems_20250913_141748.json
│   │   │   │   ├── magic_systems_20250913_180742.json
│   │   │   │   ├── magic_systems_20250913_235905.json
│   │   │   │   ├── magic_systems_20250914_130547.json
│   │   │   │   ├── magic_systems_20250914_131055.json
│   │   │   │   ├── magic_systems_20250914_132944.json
│   │   │   │   ├── magic_systems_20250919_095109.json
│   │   │   │   ├── magic_systems_20250919_131027.json
│   │   │   │   ├── magic_systems_20250919_142500.json
│   │   │   │   ├── magic_systems_20251006_220742.json
│   │   │   │   ├── magic_systems_20251006_225101.json
│   │   │   │   ├── magic_systems_20251007_222935.json
│   │   │   │   ├── world_history_20250912_235959.json
│   │   │   │   ├── world_history_20250913_002318.json
│   │   │   │   ├── world_history_20250913_002554.json
│   │   │   │   ├── world_history_20250913_141551.json
│   │   │   │   ├── world_history_20250913_141748.json
│   │   │   │   ├── world_history_20250913_180742.json
│   │   │   │   ├── world_history_20250913_235905.json
│   │   │   │   ├── world_history_20250914_130547.json
│   │   │   │   ├── world_history_20250914_131055.json
│   │   │   │   ├── world_history_20250914_132944.json
│   │   │   │   ├── world_history_20250919_095109.json
│   │   │   │   ├── world_history_20250919_131027.json
│   │   │   │   ├── world_history_20250919_142500.json
│   │   │   │   ├── world_history_20251006_220742.json
│   │   │   │   ├── world_history_20251006_225101.json
│   │   │   │   └── world_history_20251007_222935.json
│   │   │   ├── cultures.json
│   │   │   ├── fundamental_rules.json
│   │   │   ├── magic_systems.json
│   │   │   └── world_history.json
│   │   ├── locations/
│   │   │   ├── backup/
│   │   │   │   ├── defaults_20251006_220742.json
│   │   │   │   ├── defaults_20251006_225101.json
│   │   │   │   ├── defaults_20251007_222935.json
│   │   │   │   ├── locations_20250912_235959.json
│   │   │   │   ├── locations_20250913_002318.json
│   │   │   │   ├── locations_20250913_002554.json
│   │   │   │   ├── locations_20250913_141551.json
│   │   │   │   ├── locations_20250913_141748.json
│   │   │   │   ├── locations_20250913_180742.json
│   │   │   │   ├── locations_20250913_235905.json
│   │   │   │   ├── locations_20250914_130547.json
│   │   │   │   ├── locations_20250914_131055.json
│   │   │   │   ├── locations_20250914_132944.json
│   │   │   │   ├── locations_20250919_095109.json
│   │   │   │   ├── locations_20250919_131027.json
│   │   │   │   ├── locations_20250919_142500.json
│   │   │   │   ├── locations_20251006_220742.json
│   │   │   │   ├── locations_20251006_225101.json
│   │   │   │   └── locations_20251007_222935.json
│   │   │   ├── defaults.json
│   │   │   └── locations.json
│   │   └── scenarios/
│   │       ├── backup/
│   │       │   ├── origins_20250912_235330.json
│   │       │   ├── origins_20250912_235959.json
│   │       │   ├── origins_20250913_002318.json
│   │       │   ├── origins_20250913_002554.json
│   │       │   ├── origins_20250913_141551.json
│   │       │   ├── origins_20250913_141748.json
│   │       │   ├── origins_20250913_180742.json
│   │       │   ├── origins_20250913_235905.json
│   │       │   ├── origins_20250914_130547.json
│   │       │   ├── origins_20250914_131055.json
│   │       │   ├── origins_20250914_132944.json
│   │       │   ├── origins_20250919_095109.json
│   │       │   ├── origins_20250919_131027.json
│   │       │   ├── origins_20250919_142500.json
│   │       │   ├── origins_20251006_220742.json
│   │       │   ├── origins_20251006_225101.json
│   │       │   ├── origins_20251007_222935.json
│   │       │   ├── quests_20250912_235330.json
│   │       │   ├── quests_20250912_235959.json
│   │       │   ├── quests_20250913_002318.json
│   │       │   ├── quests_20250913_002554.json
│   │       │   ├── quests_20250913_141551.json
│   │       │   ├── quests_20250913_141748.json
│   │       │   ├── quests_20250913_180742.json
│   │       │   ├── quests_20250913_235905.json
│   │       │   ├── quests_20250914_130547.json
│   │       │   ├── quests_20250914_131055.json
│   │       │   ├── quests_20250914_132944.json
│   │       │   ├── quests_20250919_095109.json
│   │       │   ├── quests_20250919_131027.json
│   │       │   ├── quests_20250919_142500.json
│   │       │   ├── quests_20251006_220742.json
│   │       │   ├── quests_20251006_225101.json
│   │       │   └── quests_20251007_222935.json
│   │       ├── origins.json
│   │       └── quests.json
│   ├── combat_display_settings.json
│   ├── game_config.json
│   ├── gui_config.json
│   ├── llm_config.json
│   ├── skills.json
│   └── system_config.json
├── core/
│   ├── agents/
│   │   ├── __init__.py
│   │   ├── agent_manager.py
│   │   ├── base_agent.py
│   │   ├── combat_narrator.py
│   │   ├── context_evaluator.py
│   │   ├── data_retrieval_commands.py
│   │   ├── narrator.py
│   │   ├── rule_checker.py
│   │   ├── social_conflict_agent.py
│   │   └── trade_agent.py
│   ├── audio/
│   │   ├── __init__.py
│   │   └── tts_manager.py
│   ├── base/
│   │   ├── state/
│   │   │   ├── __init__.py
│   │   │   ├── calendar_state.py
│   │   │   ├── game_state.py
│   │   │   ├── player_state.py
│   │   │   ├── state_manager.py
│   │   │   ├── stats_integration.py
│   │   │   └── world_state.py
│   │   ├── __init__.py
│   │   ├── commands.py
│   │   ├── config.py
│   │   ├── engine.py
│   │   ├── game_loop.py
│   │   ├── init_modules.py
│   │   └── state.py
│   ├── character/
│   │   ├── selected_files_documentation_25.05.2025_22_45_07_output/
│   │   ├── __init__.py
│   │   ├── background_generator.py
│   │   ├── npc_base.py
│   │   ├── npc_creator.py
│   │   ├── npc_family_generator.py
│   │   ├── npc_flavor.py
│   │   ├── npc_generator.py
│   │   ├── npc_manager.py
│   │   ├── npc_memory.py
│   │   ├── npc_persistence.py
│   │   └── npc_system.py
│   ├── combat/
│   │   ├── __init__.py
│   │   ├── action_handlers.py
│   │   ├── combat_action.py
│   │   ├── combat_entity.py
│   │   ├── combat_manager.py
│   │   ├── dev_commands.py
│   │   └── enums.py
│   ├── game_flow/
│   │   ├── __init__.py
│   │   ├── command_handlers.py
│   │   ├── command_router.py
│   │   ├── event_log.py
│   │   ├── game_flow_utils.py
│   │   ├── input_router.py
│   │   ├── interaction_core.py
│   │   ├── interaction_processor.py
│   │   ├── lifecycle.py
│   │   ├── mode_transitions.py
│   │   ├── npc_interaction.py
│   │   ├── quest_updates.py
│   │   ├── reference_resolver.py
│   │   └── request_handlers.py
│   ├── interaction/
│   │   ├── context_builder.py
│   │   ├── enums.py
│   │   ├── social_effects.py
│   │   └── structured_requests.py
│   ├── inventory/
│   │   ├── __init__.py
│   │   ├── currency_manager.py
│   │   ├── equipment_manager.py
│   │   ├── inventory_base.py
│   │   ├── inventory_commands.py
│   │   ├── inventory_commands_2.py
│   │   ├── inventory_commands_3.py
│   │   ├── inventory_item_operations.py
│   │   ├── inventory_limits.py
│   │   ├── inventory_manager.py
│   │   ├── item.py
│   │   ├── item_effect.py
│   │   ├── item_enums.py
│   │   ├── item_factory.py
│   │   ├── item_manager.py
│   │   ├── item_modifier.py
│   │   ├── item_serialization.py
│   │   ├── item_stat.py
│   │   ├── item_stat_modifier.py
│   │   ├── item_template_loader.py
│   │   ├── item_variation_generator.py
│   │   ├── narrative_item_creation.py
│   │   ├── narrative_item_discovery.py
│   │   ├── narrative_item_manager.py
│   │   └── narrative_item_mappings.py
│   ├── llm/
│   │   ├── __init__.py
│   │   ├── llm_manager.py
│   │   ├── provider_manager.py
│   │   ├── settings_cli.py
│   │   └── settings_manager.py
│   ├── orchestration/
│   │   ├── __init__.py
│   │   ├── combat_orchestrator.py
│   │   └── events.py
│   ├── stats/
│   │   ├── enums/
│   │   │   └── __init__.py
│   │   ├── tests/
│   │   │   ├── __init__.py
│   │   │   └── test_stats_manager.py
│   │   ├── __init__.py
│   │   ├── combat_effects.py
│   │   ├── derived_stats.py
│   │   ├── enums.py
│   │   ├── modifier.py
│   │   ├── modifier_manager.py
│   │   ├── registry.py
│   │   ├── skill_check.py
│   │   ├── skill_manager.py
│   │   ├── stat_allocation.py
│   │   ├── stat_modifier_info.py
│   │   ├── stats_base.py
│   │   └── stats_manager.py
│   ├── testing/
│   │   ├── __init__.py
│   │   ├── headless_env.py
│   │   ├── headless_ui_listener.py
│   │   ├── quest_commands.py
│   │   └── scenario_runner.py
│   ├── time/
│   │   └── time_controller.py
│   ├── utils/
│   │   ├── dice.py
│   │   ├── dotdict.py
│   │   ├── enhanced_time_manager.py
│   │   ├── json_utils.py
│   │   ├── logging_config.py
│   │   ├── save_manager.py
│   │   └── time_utils.py
│   └── __init__.py
├── gui/
│   ├── components/
│   │   ├── character_sheet.py
│   │   ├── combat_display.py
│   │   ├── command_input.py
│   │   ├── game_menu.py
│   │   ├── game_output.py
│   │   ├── inventory_panel.py
│   │   ├── journal_panel.py
│   │   ├── menu_panel.py
│   │   ├── right_panel.py
│   │   ├── skill_check_display.py
│   │   ├── stat_allocation_widget.py
│   │   └── status_bar.py
│   ├── dialogs/
│   │   ├── settings/
│   │   │   ├── __init__.py
│   │   │   ├── agent_setup_tab.py
│   │   │   ├── anthropic_tab.py
│   │   │   ├── background_tab.py
│   │   │   ├── base_settings_dialog.py
│   │   │   ├── llm_general_tab.py
│   │   │   ├── llm_provider_tab.py
│   │   │   ├── llm_settings_dialog.py
│   │   │   ├── model_management_widget.py
│   │   │   ├── provider_tabs.py
│   │   │   ├── settings_dialog.py
│   │   │   └── style_tab.py
│   │   ├── __init__.py
│   │   ├── base_dialog.py
│   │   ├── character_creation_dialog.py
│   │   ├── combat_settings_dialog.py
│   │   ├── game_over_dialog.py
│   │   ├── item_info_dialog.py
│   │   ├── load_game_dialog.py
│   │   ├── new_game_dialog.py
│   │   └── save_game_dialog.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── init_settings.py
│   │   └── resource_manager.py
│   └── main_window.py
├── images/
│   ├── character/
│   │   └── paperdoll/
│   │       └── dump/
│   ├── character_icons/
│   │   ├── Cinderspawn_Cleric/
│   │   ├── Cinderspawn_Mage/
│   │   ├── Cinderspawn_Ranger/
│   │   ├── Cinderspawn_Rogue/
│   │   ├── Cinderspawn_Wanderer/
│   │   ├── Cinderspawn_Warrior/
│   │   ├── Dwarf_Cleric/
│   │   ├── Dwarf_Mage/
│   │   ├── Dwarf_Ranger/
│   │   ├── Dwarf_Rogue/
│   │   ├── Dwarf_Warrior/
│   │   ├── Elf_Cleric/
│   │   ├── Elf_Mage/
│   │   ├── Elf_Ranger/
│   │   ├── Elf_Rogue/
│   │   ├── Elf_Wanderer/
│   │   ├── Elf_Warrior/
│   │   ├── Halfling_Cleric/
│   │   ├── Halfling_Mage/
│   │   ├── Halfling_Ranger/
│   │   ├── Halfling_Rogue/
│   │   ├── Halfling_Wanderer/
│   │   ├── Halfling_Warrior/
│   │   ├── Human_Cleric/
│   │   ├── Human_Mage/
│   │   ├── Human_Ranger/
│   │   ├── Human_Rogue/
│   │   ├── Human_Wanderer/
│   │   ├── Human_Warrior/
│   │   ├── Maelstri_Cleric/
│   │   ├── Maelstri_Mage/
│   │   ├── Maelstri_Ranger/
│   │   ├── Maelstri_Rogue/
│   │   ├── Maelstri_Wanderer/
│   │   ├── Maelstri_Warrior/
│   │   ├── Mycora_Cleric/
│   │   ├── Mycora_Mage/
│   │   ├── Mycora_Ranger/
│   │   ├── Mycora_Rogue/
│   │   ├── Mycora_Wanderer/
│   │   ├── Mycora_Warrior/
│   │   ├── Orc_Cleric/
│   │   ├── Orc_Mage/
│   │   ├── Orc_Ranger/
│   │   ├── Orc_Rogue/
│   │   ├── Orc_Wanderer/
│   │   ├── Orc_Warrior/
│   │   ├── Prismal_Cleric/
│   │   ├── Prismal_Mage/
│   │   ├── Prismal_Ranger/
│   │   ├── Prismal_Rogue/
│   │   ├── Prismal_Wanderer/
│   │   ├── Prismal_Warrior/
│   │   ├── gui/
│   │   │   ├── background/
│   │   │   ├── colors/
│   │   │   │   └── placeholder_creator.py
│   │   │   ├── combat_display/
│   │   │   ├── textures/
│   │   │   └── placeholder_creator.py
│   │   ├── icons/
│   │   ├── character_combinations.txt.bulk_settings.json
│   │   └── convert_images_recursive.py
│   ├── gui/
│   │   ├── background/
│   │   └── combat_display/
│   ├── icons/
│   │   ├── accessory/
│   │   ├── armor/
│   │   ├── consumable/
│   │   ├── container/
│   │   ├── document/
│   │   ├── key/
│   │   ├── material/
│   │   ├── miscellaneous/
│   │   ├── quest/
│   │   ├── shield/
│   │   ├── tool/
│   │   ├── treasure/
│   │   └── weapon/
│   └── convert_images_recursive.py
├── log_viewer_tool/
│   ├── logs/
│   ├── __init__.py
│   ├── color_delegate.py
│   ├── color_settings_dialog.py
│   ├── export_dialog.py
│   ├── filter_model.py
│   ├── log_entry.py
│   ├── log_parser.py
│   ├── main_window.py
│   └── settings_manager.py
├── logs/
├── reports/
│   └── npc_headless_report.json
├── saves/
│   ├── backups/
│   ├── npcs/
│   │   └── _report_tmp/
│   ├── newgame1.json
│   ├── newgame2.json
│   ├── newgame3.json
│   ├── test1.json
│   ├── test2.json
│   ├── test3.json
│   ├── test4.json
│   ├── test5.json
│   ├── test6.json
│   ├── test7.json
│   ├── test8.json
│   ├── test8wolf.json
│   ├── test9.json
│   ├── test_fight_new.json
│   ├── test_time_1.json
│   ├── testing.json
│   ├── testing_apple1.json
│   └── wolf_alpha.json
├── scripts/
│   └── migrations/
│       └── normalize_items_aliases.py
├── selected_files_documentation_08.10.2025_22_29_43_output/
├── selected_files_documentation_09.10.2025_10_35_57_output/
├── selected_files_documentation_09.10.2025_14_16_18_output/
├── selected_files_documentation_09.10.2025_16_22_03_output/
├── selected_files_documentation_09.10.2025_16_22_37_output/
├── sound/
├── tests/
│   ├── __init__.py
│   └── test_stats_system.py
├── tools/
│   ├── headless_cli/
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── repro_new_game_wolf.py
│   │   ├── run_families_quick.py
│   │   ├── run_loaded.py
│   │   └── verify_q02_autocomplete.py
│   ├── __init__.py
│   ├── npc_headless_report.py
│   ├── sanity_check_npc.py
│   ├── test_npc_boss_overlays_headless.py
│   ├── test_npc_families_headless.py
│   ├── test_npc_generation_rules_headless.py
│   ├── test_npc_variants_headless.py
│   ├── test_social_determinism_headless.py
│   ├── test_social_npcs_headless.py
│   ├── test_spawn_intent_resolution_headless.py
│   └── validate_json.py
├── web/
│   ├── client/
│   │   ├── css/
│   │   └── js/
│   └── server/
│       └── server.py
├── world_configurator/
│   ├── assistant/
│   │   ├── __init__.py
│   │   ├── context.py
│   │   ├── panel.py
│   │   ├── patching.py
│   │   └── prompt_builder.py
│   ├── config/
│   │   └── skills.json
│   ├── data/
│   ├── llm/
│   │   ├── __init__.py
│   │   ├── client_base.py
│   │   ├── gemini.py
│   │   ├── providers_registry.py
│   │   └── settings.py
│   ├── logs/
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base_models.py
│   │   ├── item_data_manager.py
│   │   ├── location_data.py
│   │   ├── location_defaults_manager.py
│   │   ├── names_manager.py
│   │   ├── origin_data.py
│   │   ├── skill_manager.py
│   │   ├── variants_manager.py
│   │   ├── world_config.py
│   │   └── world_data.py
│   ├── selected_files_documentation_31.05.2025_22_40_59_output/
│   ├── ui/
│   │   ├── dialogs/
│   │   │   ├── __init__.py
│   │   │   ├── base_dialog.py
│   │   │   ├── export_dialog.py
│   │   │   ├── item_selection_dialog.py
│   │   │   ├── new_project_dialog.py
│   │   │   ├── quest_selection_dialog.py
│   │   │   ├── settings_dialog.py
│   │   │   └── skill_selection_dialog.py
│   │   ├── editors/
│   │   │   ├── SpecificItemEditor.py
│   │   │   ├── __init__.py
│   │   │   ├── class_editor.py
│   │   │   ├── culture_editor.py
│   │   │   ├── history_editor.py
│   │   │   ├── item_editor_panel.py
│   │   │   ├── location_editor.py
│   │   │   ├── magic_systems_editor.py
│   │   │   ├── names_editor.py
│   │   │   ├── origin_editor.py
│   │   │   ├── quest_editor.py
│   │   │   ├── race_editor.py
│   │   │   ├── skills_editor.py
│   │   │   └── variants_editor.py
│   │   ├── widgets/
│   │   │   ├── __init__.py
│   │   │   ├── multiselect_combo.py
│   │   │   └── typed_resistances_editor.py
│   │   ├── __init__.py
│   │   └── main_window.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── data_validator.py
│   │   ├── file_manager.py
│   │   └── logging_setup.py
│   ├── validators/
│   │   └── origins_quests_validator.py
│   ├── __init__.py
│   └── main.py
├── world_configurator.egg-info/
├── create_color_swatches.py
├── create_texture.py
├── create_textures.py
├── generate_project_structure.py
├── main.py
├── manage_llm_settings.py
├── run_gui.py
├── run_headless.py
├── run_headless_load.py
├── run_log_viewer.py
├── run_verify_q02.py
├── setup.py
├── start_server.py
├── test_difficulty_encounter_scaling.py
├── test_inventory.py
└── world_configurator.py
```

## Files Content

### File: core\agents\__init__.py

```python
#!/usr/bin/env python3
"""
Agent module for LLM-powered game agents.

This module provides LLM-powered agents for narrative generation, rule checking,
and context evaluation in the RPG game.
"""

from core.agents.base_agent import BaseAgent, AgentContext, AgentResponse
from core.agents.narrator import NarratorAgent, get_narrator_agent
from core.agents.rule_checker import RuleCheckerAgent, get_rule_checker_agent
from core.agents.context_evaluator import ContextEvaluatorAgent, get_context_evaluator_agent
from core.agents.agent_manager import AgentManager, get_agent_manager

__all__ = [
    'BaseAgent',
    'AgentContext',
    'AgentResponse',
    'NarratorAgent',
    'get_narrator_agent',
    'RuleCheckerAgent',
    'get_rule_checker_agent',
    'ContextEvaluatorAgent',
    'get_context_evaluator_agent',
    'AgentManager',
    'get_agent_manager'
]
```

### File: core\agents\agent_manager.py

```python
"""
Agent manager for coordinating between different agent types.

This module provides an AgentManager class that initializes, coordinates,
and manages interactions between different agent types, including
context evaluation, rule checking, and narrative generation.
"""

import os
import json
import time
from typing import Dict, List, Optional, Any, Tuple, Union
import logging

from core.interaction.enums import InteractionMode
from core.stats.stats_base import DerivedStatType
from core.stats.stats_manager import get_stats_manager
from core.utils.logging_config import get_logger
from core.base.state import GameState
from core.base.commands import get_command_processor
from core.inventory import get_narrative_item_manager, get_inventory_manager
from core.agents.base_agent import AgentContext, AgentResponse
from core.agents.narrator import get_narrator_agent
from core.agents.rule_checker import get_rule_checker_agent
from core.agents.context_evaluator import get_context_evaluator_agent
from core.agents.data_retrieval_commands import process_data_retrieval_command

# Get the module logger
logger = get_logger("AGENT")

class AgentManager:
    """
    Manager for coordinating between different agent types.
    
    This class handles initialization, coordination, and management of
    different agent types, including context evaluation, rule checking,
    and narrative generation.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(AgentManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the agent manager."""
        if self._initialized:
            return
        
        logger.info("Initializing AgentManager")
        
        # Initialize agents
        self._narrator_agent = get_narrator_agent()
        self._rule_checker_agent = get_rule_checker_agent()
        self._context_evaluator_agent = get_context_evaluator_agent()
        
        # Initialize command processor
        self._command_processor = get_command_processor()
        
        # Initialize narrative item manager
        self._narrative_item_manager = get_narrative_item_manager()
        
        # Settings
        self._perform_rule_check = True
        self._perform_context_evaluation = True
        
        self._initialized = True
        logger.info("AgentManager initialized")
    
    def reset_state(self):
        """
        Reset the state of all agents.
        
        This should be called when starting a new game to ensure no state
        from previous games affects the new game's narrative.
        """
        logger.info("Resetting agent state")
        
        try:
            # Reset narrator agent if it has a reset method
            if hasattr(self._narrator_agent, 'reset'):
                self._narrator_agent.reset()
                logger.info("Reset narrator agent state")
            
            # Reset rule checker agent if it has a reset method
            if hasattr(self._rule_checker_agent, 'reset'):
                self._rule_checker_agent.reset()
                logger.info("Reset rule checker agent state")
            
            # Reset context evaluator agent if it has a reset method
            if hasattr(self._context_evaluator_agent, 'reset'):
                self._context_evaluator_agent.reset()
                logger.info("Reset context evaluator agent state")
            
            # Reset narrative item manager if needed
            if hasattr(self._narrative_item_manager, 'reset'):
                self._narrative_item_manager.reset()
                logger.info("Reset narrative item manager state")
        except Exception as e:
            logger.error(f"Error resetting agent state: {e}", exc_info=True)
    
    def reload_settings(self):
        """
        Reload settings for all agents.
        
        This should be called when LLM settings are updated.
        """
        logger.info("Reloading agent settings")
        
        try:
            # Reload settings for each agent
            if hasattr(self._narrator_agent, 'reload_settings'):
                self._narrator_agent.reload_settings()
            
            if hasattr(self._rule_checker_agent, 'reload_settings'):
                self._rule_checker_agent.reload_settings()
            
            if hasattr(self._context_evaluator_agent, 'reload_settings'):
                self._context_evaluator_agent.reload_settings()
            
            logger.info("Agent settings reloaded")
        except Exception as e:
            logger.error(f"Error reloading agent settings: {e}", exc_info=True)
    
    def process_input(self, 
                      game_state: GameState, 
                      player_input: str,
                      perform_rule_check: bool = True,
                      perform_context_evaluation: bool = True) -> Tuple[str, List[Tuple[str, str]]]:
        """
        Process player input through the appropriate agents.
        
        Args:
            game_state: The current game state.
            player_input: The player's input text.
            perform_rule_check: Whether to perform rule checking.
            perform_context_evaluation: Whether to perform context evaluation.
        
        Returns:
            A tuple of (response_text, commands), where commands is a list of
            (command, args) tuples extracted from the response.
        """
        logger.info(f"Processing player input with LLM: {player_input}")
        
        # Update settings
        self._perform_rule_check = perform_rule_check
        self._perform_context_evaluation = perform_context_evaluation
        
        # Create base context
        context = self._create_agent_context(game_state, player_input)

        # Opportunistically prefetch inventory when input is item/inventory-related so validation sees real items
        try:
            lower_in = (player_input or "").lower()
            inventory_triggers = [
                "inventory", "pack", "backpack", "bag", "use ", "consume", "eat", "drink",
                "equip", "unequip", "drop", "take", "pick", "obtain", "get ", "have ", "has ", "hold"
            ]
            should_prefetch_inv = any(t in lower_in for t in inventory_triggers)
            if should_prefetch_inv:
                from core.agents.data_retrieval_commands import get_inventory_data
                pre_inv = get_inventory_data(game_state)
                if pre_inv and isinstance(pre_inv, dict):
                    context.additional_context = {**(context.additional_context or {}), "inventory": pre_inv}
                    logger.info("Prefetched inventory into LLM context based on user input.")
        except Exception as e:
            logger.warning(f"Prefetch inventory failed: {e}")

        # Prefetch quests when the user explicitly asks about them (single-output UX)
        try:
            if isinstance(player_input, str) and "quest" in player_input.lower():
                from core.agents.data_retrieval_commands import get_quest_data
                pre_q = get_quest_data(game_state)
                if pre_q and isinstance(pre_q, dict):
                    context.additional_context = {**(context.additional_context or {}), "quests": pre_q}
                    logger.info("Prefetched quests into LLM context based on user input.")
        except Exception as e:
            logger.warning(f"Prefetch quests failed: {e}")
        
        try:
            # Step 1: Evaluate context
            if self._perform_context_evaluation:
                context = self._evaluate_context(context)
            
            # Step 2: Check rules
            if self._perform_rule_check:
                is_valid, reason = self._check_rules(context)
                
                if not is_valid:
                    # Ensure we have a meaningful error message
                    if not reason:
                        reason = "Unknown rule violation"
                    # Return rule violation message
                    return f"Invalid action: {reason}", []
            
            # Step 3: First phase - Generate initial narrative to check for data retrieval needs
            logger.info("Phase 1: Generating initial narrative to identify data needs...")
            initial_response = self._generate_narrative(context)
            
            # Check if there are any data retrieval commands in the response
            data_commands = [
                (cmd, args) for cmd, args in initial_response.commands 
                if cmd in ["GET_INVENTORY", "GET_STATS", "GET_QUESTS", "GET_LOCATION_INFO"]
            ]
            
            # If data retrieval commands exist, process them and regenerate the narrative
            if data_commands:
                logger.info(f"Found {len(data_commands)} data retrieval commands")
                
                # Process data retrieval commands
                additional_context = {}
                for cmd, args in data_commands:
                    logger.info(f"Processing data retrieval command: {cmd}")
                    
                    # Get data based on command
                    data = process_data_retrieval_command(cmd, args, game_state)
                    
                    # Add to additional context
                    if cmd == "GET_INVENTORY":
                        additional_context["inventory"] = data
                    elif cmd == "GET_STATS":
                        additional_context["character_stats"] = data
                    elif cmd == "GET_QUESTS":
                        additional_context["quests"] = data
                    elif cmd == "GET_LOCATION_INFO":
                        additional_context["location_info"] = data
                
                # Update context with retrieved data
                context.additional_context = {
                    **(context.additional_context or {}),
                    **additional_context
                }
                
                # Step 3.5: Regenerate narrative with enhanced context
                logger.info("Phase 2: Regenerating narrative with retrieved data...")
                response = self._generate_narrative(context)
                # If the regenerated narrative is empty but we have retrieved data, generate a default response
                if (not response.content or len(response.content.strip()) == 0) and additional_context:
                    default_message = "Here is the information you requested:\n\n"
                    
                    if "character_stats" in additional_context:
                        stats = additional_context["character_stats"]
                        default_message += "=== CHARACTER STATS ===\n"
                        if "character" in stats:
                            char_info = stats["character"]
                            default_message += f"Name: {char_info.get('name', 'Unknown')}\n"
                            default_message += f"Race: {char_info.get('race', 'Unknown')}\n"
                            default_message += f"Class: {char_info.get('path', 'Unknown')}\n"
                            default_message += f"Level: {char_info.get('level', 1)}\n"
                        
                        default_message += "\nPrimary Stats:\n"
                        if "primary_stats" in stats:
                            for stat_name, stat_data in stats["primary_stats"].items():
                                default_message += f"- {stat_name}: {stat_data.get('value', 0)}\n"
                        
                        default_message += "\nDerived Stats:\n"
                        if "derived_stats" in stats:
                            for stat_name, stat_data in stats["derived_stats"].items():
                                default_message += f"- {stat_name}: {stat_data.get('value', 0)}\n"
                        
                        default_message += "\nSkills:\n"
                        if "skills" in stats:
                            for skill_name, skill_data in stats["skills"].items():
                                default_message += f"- {skill_name}: {skill_data.get('value', 0)}\n"
                    
                    if "inventory" in additional_context:
                        inventory = additional_context["inventory"]
                        default_message += "\n=== INVENTORY ===\n"
                        if "equipped" in inventory and inventory["equipped"]: # Check if equipped dict is not empty
                            default_message += "Equipped Items:\n"
                            for slot, item_data in inventory["equipped"].items(): # Iterate over items in dict
                                if isinstance(item_data, dict): # Ensure item_data is a dict
                                    default_message += f"- {slot}: {item_data.get('name', 'Unknown Item')}\n"
                                elif item_data: # Fallback if it's just a string/ID (less likely with new structure)
                                    default_message += f"- {slot}: {item_data}\n"
                        else:
                            default_message += "Equipped Items: None\n"

                        if "backpack" in inventory and inventory["backpack"]:
                            default_message += "\nBackpack Items:\n"
                            for item_data in inventory["backpack"]: # Iterate over items in list
                                if isinstance(item_data, dict): # Ensure item_data is a dict
                                    quantity = item_data.get("quantity", 1)
                                    quantity_str = f" (x{quantity})" if quantity > 1 else ""
                                    default_message += f"- {item_data.get('name', 'Unknown Item')}{quantity_str}\n"
                                else: # Fallback if it's just a string/ID
                                    default_message += f"- {item_data}\n"
                        else:
                            default_message += "\nBackpack Items: Empty\n"

                        if "currency" in inventory:
                            currency = inventory["currency"]
                            gold = currency.get("gold", 0)
                            silver = currency.get("silver", 0)
                            copper = currency.get("copper", 0)
                            default_message += f"\nCurrency: {gold}g {silver}s {copper}c\n"
                    
                    if "quests" in additional_context:
                        quests = additional_context["quests"]
                        default_message += "\n=== QUESTS ===\n"
                        if "active_quests" in quests:
                            default_message += "Active Quests:\n"
                            for quest in quests["active_quests"]:
                                if isinstance(quest, dict):
                                    default_message += f"- {quest.get('name', 'Unknown Quest')}\n"
                                    if 'description' in quest:
                                        default_message += f"  {quest['description']}\n"
                                else:
                                    default_message += f"- {quest}\n"
                    
                    if "location_info" in additional_context:
                        location = additional_context["location_info"]
                        default_message += "\n=== LOCATION ===\n"
                        default_message += f"Current Location: {location.get('current_location', 'Unknown')}\n"
                        default_message += f"District/Area: {location.get('current_district', 'Unknown')}\n"
                        if "weather" in location:
                            default_message += f"Weather: {location['weather']}\n"
                    
                    # Update the response with our default message
                    response.content = default_message
                    logger.info("Generated default data retrieval response")
                
                logger.info(f"Received final response from LLM: {len(response.content)} chars")
            else:
                # No data retrieval needed, use the initial response
                logger.info("No data retrieval commands found, using initial response")
                response = initial_response
            
            # Step 4: Process narrative item commands
            processed_text, item_results = self._process_narrative_items(game_state, response.content)
            
            # Update response with processed text
            response.content = processed_text
            
            # Step 5: Process remaining commands in the response
            # Filter out data retrieval commands as they've already been processed
            # Also filter out CONSUME_ITEM commands, as they will be handled by game logic post-narration.
            commands_to_return = []
            for cmd, args in response.commands:
                if cmd in ["GET_INVENTORY", "GET_STATS", "GET_QUESTS", "GET_LOCATION_INFO"]:
                    logger.debug(f"Filtering out already processed data retrieval command: {cmd}")
                    continue
                elif cmd == "CONSUME_ITEM": # This is an example, actual command might differ
                    logger.debug(f"Noting CONSUME_ITEM command for game logic: {cmd} {args}")
                    # This command is now passed through for GameEngine to handle
                    commands_to_return.append((cmd, args))
                else:
                    commands_to_return.append((cmd, args))

            logger.info(f"Extracted {len(commands_to_return)} action commands to return from response")

            # Route special LLM commands (including quest updates) immediately through LLM handlers
            routed_commands: list[tuple[str, str]] = []
            for cmd, args in commands_to_return:
                if cmd in ["MODE_TRANSITION", "QUEST_UPDATE", "QUEST_STATUS"]:
                    try:
                        from core.game_flow.command_handlers import process_llm_command
                        from core.base.engine import get_game_engine
                        engine = get_game_engine()
                        logger.info(f"Routing special LLM command now: {cmd}")
                        # Ensure args are provided as a list of one string per our handler signature
                        _ = process_llm_command(engine, cmd, [args] if not isinstance(args, list) else args, game_state)
                        # We do not append these to the returned list; they are handled immediately
                    except Exception as e:
                        logger.error(f"Error routing LLM command {cmd}: {e}")
                else:
                    routed_commands.append((cmd, args))

            # Return the response text and only the remaining commands (non-LLM-special)
            return response.content, routed_commands
            
        except Exception as e:
            logger.error(f"Error in agent processing: {e}", exc_info=True)
            return f"I'm sorry, but I encountered an error while processing your input: {str(e)}", []
    
    def _create_agent_context(self, game_state: GameState, player_input: str) -> AgentContext:
        """
        Create an agent context from the game state and player input.
        
        Args:
            game_state: The current game state.
            player_input: The player's input text.
        
        Returns:
            An AgentContext object.
        """
        # Extract game state information
        game_state_dict = {}
        player_state_dict = {}
        world_state_dict = {}
        additional_context_for_agent = {} # For specific notes like low stamina

        if game_state:
            # Convert game state to dictionary
            game_state_dict = {
                "session_id": game_state.session_id,
                "created_at": game_state.created_at,
                "last_saved_at": game_state.last_saved_at,
                "game_version": game_state.game_version,
                "last_command": game_state.last_command,
                "mode": game_state.current_mode.name if hasattr(game_state, 'current_mode') else "NARRATIVE"
            }
            
            # Extract player state
            if game_state.player:
                player_state_dict = game_state.player.to_dict()

                # Add note for out-of-combat stamina regeneration consideration
                # Access StatsManager via get_stats_manager() singleton
                player_stats_manager = get_stats_manager()
                if game_state.current_mode == InteractionMode.NARRATIVE and player_stats_manager:
                    try:
                        current_stamina = player_stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                        max_stamina = player_stats_manager.get_stat_value(DerivedStatType.MAX_STAMINA)
                        if current_stamina < max_stamina:
                            additional_context_for_agent["player_stamina_status"] = (
                                f"Player stamina is {current_stamina:.0f}/{max_stamina:.0f}. "
                                f"Consider if regeneration is appropriate based on recent actions and time passed."
                            )
                            logger.debug(f"Stamina note added to agent context: {additional_context_for_agent['player_stamina_status']}")
                    except Exception as e:
                        logger.warning(f"Could not get player stamina for agent context note: {e}")
            
            # Extract world state
            if game_state.world:
                world_state_dict = game_state.world.to_dict()
        
        # Create agent context
        context = AgentContext(
            game_state=game_state_dict,
            player_state=player_state_dict,
            world_state=world_state_dict,
            player_input=player_input,
            conversation_history=game_state.conversation_history if game_state else [],
            relevant_memories=[],  # Will be populated by context evaluator
            additional_context=additional_context_for_agent if additional_context_for_agent else None
        )
        
        return context
    
    def _evaluate_context(self, context: AgentContext) -> AgentContext:
        """
        Evaluate the context using the context evaluator agent.
        
        Args:
            context: The agent context.
        
        Returns:
            An updated agent context with relevant memories and a context summary.
        """
        logger.info("Evaluating context")
        
        try:
            # Check for cached summary first
            cached_summary = self._context_evaluator_agent.get_cached_summary(context)
            
            if cached_summary:
                # Use cached summary
                context.context_summary = cached_summary
                logger.info("Using cached context summary")
            else:
                # Process context evaluation
                eval_result = self._context_evaluator_agent.evaluate_context(context)
                
                # Update context with evaluation results
                if eval_result:
                    context.context_summary = eval_result.get("context_summary")
                    
                    # In a full implementation, we would retrieve relevant memories
                    # based on the evaluation results and add them to context.relevant_memories
                    
                    logger.info("Context evaluation completed")
                else:
                    logger.warning("Context evaluation failed")
        
        except Exception as e:
            logger.error(f"Error evaluating context: {e}")
            # Proceed without context evaluation
        
        return context
    
    def _check_rules(self, context: AgentContext) -> Tuple[bool, Optional[str]]:
        """
        Check rules using the rule checker agent.
        
        Args:
            context: The agent context.
        
        Returns:
            A tuple of (is_valid, reason), where reason is None if valid.
        """
        logger.info("Checking rules")
        
        try:
            # Special case for welcome narration - always allow it
            if "starting a new game as" in context.player_input and "introduce me to the game world" in context.player_input:
                logger.info("Allowing welcome narration to bypass rule check")
                return True, None
                
            # Use the rule checker's validate_action method
            is_valid, reason = self._rule_checker_agent.validate_action(context)
            
            if is_valid:
                logger.info("Rule check passed")
            else:
                # Make sure reason is not None when action is invalid
                if not reason:
                    reason = "Unknown rule violation"
                logger.info(f"Rule check failed: {reason}")
            
            return is_valid, reason
            
        except Exception as e:
            logger.error(f"Error checking rules: {e}")
            # Proceed with rule check passed by default
            return True, None
    
    def _generate_narrative(self, context: AgentContext) -> AgentResponse:
        """
        Generate narrative using the narrator agent.
        
        Args:
            context: The agent context.
        
        Returns:
            An AgentResponse object with narrative content and commands.
        """
        logger.info("Generating narrative")
        
        # Filter error messages from conversation history to prevent cascading errors
        self._filter_error_messages_from_history(context)
        
        try:
            # Check if narrator agent is available
            if self._narrator_agent is None:
                raise ValueError("Narrator agent is not initialized")
                
            # Log that we're about to call the narrator agent
            logger.info("Calling narrator agent process() method")
            
            # Process the context with the narrator agent
            agent_output = self._narrator_agent.process(context)
            
            # Check if we got a valid response
            if agent_output is None:
                raise ValueError("Narrator agent returned None response")
                
            if "narrative" not in agent_output:
                raise ValueError("Narrator agent returned response without narrative")
            
            # Convert AgentOutput to AgentResponse
            narrative = agent_output.get("narrative", "")
            requests = agent_output.get("requests", [])
            
            # Command conversion - map structured requests to simple commands
            commands = []
            for req in requests:
                if isinstance(req, dict) and "action" in req:
                    action = req["action"]
                    # Format depends on action type
                    if action == "request_skill_check":
                        skill_name = req.get("skill_name", "unknown")
                        difficulty = req.get("difficulty_class", 10)
                        commands.append(("STAT_CHECK", f"{skill_name}:{difficulty}"))
                    elif action == "request_state_change":
                        # Preserve all fields by passing JSON; normalize target_id if only target_entity/target provided
                        import json
                        payload = dict(req)
                        if "target_id" not in payload:
                            payload["target_id"] = (
                                req.get("target_entity") or req.get("target") or req.get("actor_id")
                            )
                        commands.append(("STATE_CHANGE", json.dumps(payload)))
                    elif action == "request_data_retrieval":
                        data_type = req.get("data_type", "unknown")
                        if data_type.upper() in ["INVENTORY", "STATS", "QUESTS", "LOCATION_INFO"]:
                            commands.append((f"GET_{data_type.upper()}", ""))
                    elif action == "request_quest_update":
                        # Pass whole request as JSON payload
                        import json
                        commands.append(("QUEST_UPDATE", json.dumps(req)))
                    elif action == "request_quest_status":
                        import json
                        commands.append(("QUEST_STATUS", json.dumps(req)))
                    elif action == "request_mode_transition":
                        # Add support for mode transitions
                        target_mode = req.get("target_mode", "UNKNOWN")
                        origin_mode = req.get("origin_mode", "UNKNOWN")
                        reason = req.get("reason", "")
                        target_entity_id = req.get("target_entity_id", "")
                        surprise = "true" if req.get("surprise", False) else "false"
                        # Format as a MODE_TRANSITION command
                        commands.append(("MODE_TRANSITION", 
                                       f"{target_mode}:{origin_mode}:{surprise}:{target_entity_id}:{reason}"))
            
            # Create AgentResponse object
            response = AgentResponse(
                content=narrative,
                commands=commands,
                metadata={"structured_requests": requests} 
            )
            
            logger.info("Narrative generation completed successfully")
            logger.debug(f"Generated content: {response.content[:100]}...")
            return response
        
        except Exception as e:
            logger.error(f"Narrator agent failed to get LLM response: {e}", exc_info=True)
            
            # Generate a more specific error message based on the exception type
            error_message = "Error: Narrator agent failed to generate a response."
            
            # Check for specific error types
            if "NoneType object is not subscriptable" in str(e):
                error_message = "Error: Communication with the LLM service failed. The server may be experiencing issues or the API format may have changed."
            elif "api_key" in str(e).lower():
                error_message = "Error: API key issues detected. Please check your LLM provider settings."
            elif "timeout" in str(e).lower():
                error_message = "Error: The LLM service timed out. Please try again later."
            elif "rate limit" in str(e).lower() or "rate_limit" in str(e).lower():
                error_message = "Error: Rate limit exceeded with the LLM service. Please try again in a few moments."
            
            # Return a fallback response with the specific error message
            return AgentResponse(
                content=error_message,
                commands=[],
                metadata={"error": f"narrative_generation_failure: {str(e)}"}
            )

    def _filter_error_messages_from_history(self, context: AgentContext) -> None:
        """
        Filter out error messages from conversation history to prevent cascading errors.
        
        Args:
            context: The agent context containing conversation history.
        """
        if not context.conversation_history:
            return
        
        # Look for error patterns in assistant/gm responses
        error_patterns = [
            "[Narrator Error:",
            "[System Error:",
            "Error:",
            "cannot process",
            "failed to generate",
            "```json", # Don't want raw JSON in history either
            "I'm sorry, but I encountered an error"
        ]
        
        # Create a new filtered history
        filtered_history = []
        removed_count = 0
        
        for entry in context.conversation_history:
            role = entry.get("role", "")
            content = entry.get("content", "")
            
            # Only filter assistant/gm messages, keep all player messages
            if role in ["assistant", "gm"]:
                # Check if the message contains error patterns
                if any(pattern in content for pattern in error_patterns):
                    removed_count += 1
                    # Skip this message - don't add to filtered history
                    continue
            
            # This message passed all filters, keep it
            filtered_history.append(entry)
        
        if removed_count > 0:
            logger.info(f"Filtered {removed_count} error messages from conversation history")
            context.conversation_history = filtered_history    

    def _process_narrative_items(self, game_state: GameState, response_text: str) -> Tuple[str, List[Any]]:
        """
        Process narrative item commands in the response text.
        
        Args:
            game_state: The current game state.
            response_text: The response text from the narrator agent.
        
        Returns:
            A tuple of (processed_text, results).
        """
        logger.info("Processing narrative item commands")
        
        try:
            # Process narrative item commands
            processed_text, results = self._narrative_item_manager.process_narrative_commands(
                response_text, game_state
            )
            
            logger.info(f"Processed {len(results)} narrative item commands")
            return processed_text, results
            
        except Exception as e:
            logger.error(f"Error processing narrative items: {e}", exc_info=True)
            # Return original text if there's an error
            return response_text, []
    
    def process_commands(self, game_state: GameState, commands: List[Tuple[str, str]]) -> List[Any]:
        """
        Process commands extracted from agent responses.
        
        Args:
            game_state: The current game state.
            commands: A list of (command, args) tuples.
        
        Returns:
            A list of command results.
        """
        logger.info(f"Processing {len(commands)} commands")
        
        results = []
        
        for cmd, args in commands:
            try:
                # Import the LLM command handler
                from core.game_flow.command_handlers import process_llm_command
                
                # Get game engine
                from core.base.engine import get_game_engine
                engine = get_game_engine()
                
                # Process special commands directly first
                if cmd == "MODE_TRANSITION":
                    logger.info(f"Handling MODE_TRANSITION command: {args}")
                    result = process_llm_command(engine, cmd, [args], game_state)
                    results.append(result)
                    logger.info(f"MODE_TRANSITION command processed: {result.message}")
                # Process skill checks and other special commands
                elif cmd == "STAT_CHECK" or cmd == "RULE_CHECK":
                    # Process skill check with the rule checker agent
                    result = self._process_skill_check_command(cmd, args, game_state)
                    results.append(result)
                    logger.info(f"Processed skill check command {cmd}")
                else:
                    # Process other commands with the command processor
                    result = self._command_processor.process_llm_commands(
                        game_state, f"{{{cmd} {args}}}"
                    )
                    
                    # Add the result to the list
                    results.append(result)
                    
                    logger.info(f"Processed command {cmd}")
            
            except Exception as e:
                logger.error(f"Error processing command {cmd}: {e}", exc_info=True)
                # Add error result
                results.append((f"Error processing command {cmd}: {e}", []))
        
        return results
        
    def _process_skill_check_command(self, cmd: str, args: str, game_state: GameState) -> Any:
        """
        Process a skill check command.
        
        Args:
            cmd: The command (STAT_CHECK or RULE_CHECK).
            args: The command arguments.
            game_state: The current game state.
            
        Returns:
            The result of the skill check.
        """
        logger.info(f"Processing skill check command: {cmd} {args}")
        
        try:
            # Parse the command arguments
            parts = args.split(':') if ':' in args else args.split()
            
            if len(parts) < 2:
                return {"error": f"Invalid {cmd} command format: {args}"}
                
            # Extract the stat type and difficulty
            stat_type = parts[0].strip().upper()
            difficulty = int(parts[1].strip())
            
            # Extract context if available
            context = parts[2].strip() if len(parts) > 2 else ""
            
            # Use the rule checker's perform_skill_check method
            check_result = self._rule_checker_agent.perform_skill_check(
                stat_type=stat_type,
                difficulty=difficulty,
                context=context
            )
            
            return check_result
        except Exception as e:
            logger.error(f"Error processing skill check command: {e}")
            return {"error": f"Error processing skill check: {str(e)}"}
        


# Convenience function
def get_agent_manager() -> AgentManager:
    """Get the agent manager instance."""
    return AgentManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create an agent manager
    manager = get_agent_manager()
    
    # Create a dummy game state for testing
    from core.base.state import GameState, PlayerState, WorldState
    
    game_state = GameState(
        player=PlayerState(
            name="Test Player",
            race="Human",
            path="Wanderer",
            background="Commoner",
            current_location="Test Town",
            current_district="Town Square"
        ),
        world=WorldState()
    )
    
    # Add some conversation history
    game_state.add_conversation_entry("player", "Hello, world!")
    game_state.add_conversation_entry("gm", "Welcome to the game!")
    
    # Process player input
    response_text, commands = manager.process_input(
        game_state=game_state,
        player_input="I look around to see what's in the town square."
    )
    
    # Print the response
    print(f"Response: {response_text}")
    
    if commands:
        print("\nCommands:")
        for cmd, args in commands:
            print(f"  {cmd}: {args}")

```

### File: core\agents\base_agent.py

```python
#!/usr/bin/env python3
"""
Base agent for LLM-powered game agents.

This module provides a BaseAgent class that defines the common interface
and functionality for all agent types (Narrator, RuleChecker, ContextEvaluator).
"""

import os
import json
import datetime
from typing import Dict, List, Optional, Any, Tuple, Union
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass

from core.utils.logging_config import get_logger
from core.base.config import get_config
from core.llm.llm_manager import LLMManager, LLMResponse, LLMRole, get_llm_manager
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = get_logger("AGENT")

@dataclass
class AgentContext:
    """
    Context for an agent.
    
    This dataclass contains the context information provided to an agent
    for processing a request, including game state, player input, and
    relevant memories.
    """
    # Game state information
    game_state: Dict[str, Any]
    player_state: Dict[str, Any]
    world_state: Dict[str, Any]
    
    # Input and history
    player_input: str
    conversation_history: List[Dict[str, Any]]
    
    # Memory context (if applicable)
    relevant_memories: List[Dict[str, Any]] = None
    
    # Additional context
    context_summary: Optional[str] = None
    additional_context: Optional[Dict[str, Any]] = None


@dataclass
class AgentResponse:
    """
    Response from an agent.
    
    This dataclass contains the response generated by an agent,
    including the output text, any extracted commands, and metadata.
    """
    # Output text
    content: str
    
    # Extracted LLM commands (if any)
    commands: List[Tuple[str, str]] = None
    
    # Metadata
    metadata: Dict[str, Any] = None
    
    # LLM response details
    llm_response: Optional[LLMResponse] = None
    
    # Timestamp
    timestamp: str = None
    
    def __post_init__(self):
        """Initialize default values."""
        if self.commands is None:
            self.commands = []
        
        if self.metadata is None:
            self.metadata = {}
        
        if self.timestamp is None:
            self.timestamp = datetime.datetime.now().isoformat()


class BaseAgent(ABC):
    """
    Base class for all agents.
    
    This abstract class defines the common interface and functionality
    for all agent types (Narrator, RuleChecker, ContextEvaluator).
    """
    
    def __init__(self, agent_name: str, agent_id: Optional[str] = None):
        """
        Initialize the base agent.
        
        Args:
            agent_name: The name of the agent.
            agent_id: Optional unique identifier for the agent.
        """
        self.agent_name = agent_name
        self.agent_id = agent_id or f"{agent_name.lower()}_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        # Get configuration
        self._config = get_config()
        
        # Get LLM manager
        self._llm_manager = get_llm_manager()
        
        # Load agent settings
        self._settings = self._load_agent_settings()
        
        # Set provider settings
        self._provider_type = self._get_provider_type()
        self._model = self._settings.get("model", None)
        self._temperature = self._settings.get("temperature", 0.7)
        
        logger.info(f"Initialized {self.agent_name} agent (ID: {self.agent_id})")
    
    def _load_agent_settings(self) -> Dict[str, Any]:
        """
        Load agent settings from configuration.
        
        Returns:
            Dictionary of agent settings.
        """
        # Default settings
        default_settings = {
            "provider_type": None,  # Use system default
            "model": None,  # Use provider default
            "temperature": 0.7,
            "max_tokens": 1000,
            "timeout_seconds": 30,
            "system_prompt_template": "You are {agent_name}, a helpful assistant for an RPG game.",
            "include_conversation_history": True,
            "include_memories": True,
            "max_conversation_entries": 10,
            "max_memory_entries": 5
        }
        
        # Try to load agent-specific settings
        agent_settings_path = os.path.join("config", "llm", "agents", f"{self.agent_name.lower()}.json")
        
        if os.path.exists(agent_settings_path):
            try:
                with open(agent_settings_path, 'r', encoding='utf-8') as f:
                    agent_settings = json.load(f)
                
                # Merge with default settings
                merged_settings = {**default_settings, **agent_settings}
                logger.info(f"Loaded settings for {self.agent_name} agent from {agent_settings_path}")
                return merged_settings
            
            except Exception as e:
                logger.error(f"Error loading agent settings: {e}")
                logger.info(f"Using default settings for {self.agent_name} agent")
                return default_settings
        
        # If no agent-specific settings file exists, create one with default settings
        try:
            os.makedirs(os.path.dirname(agent_settings_path), exist_ok=True)
            with open(agent_settings_path, 'w', encoding='utf-8') as f:
                json.dump(default_settings, f, indent=4)
            logger.info(f"Created default settings file for {self.agent_name} agent at {agent_settings_path}")
        except Exception as e:
            logger.error(f"Error creating default agent settings file: {e}")
        
        return default_settings
    
    def _get_provider_type(self) -> ProviderType:
        """
        Get the provider type for this agent.
        
        Returns:
            The provider type enum value.
        """
        provider_type_str = self._settings.get("provider_type")
        
        if provider_type_str and provider_type_str != "None":
            try:
                return ProviderType[provider_type_str]
            except (KeyError, ValueError):
                logger.warning(f"Invalid provider type: {provider_type_str}. Using system default.")
        
        # Use system default
        default_provider = self._llm_manager._provider_manager.get_default_provider()
        if not default_provider:
            logger.error(f"No default provider available for {self.agent_name} agent")
            # Fall back to OPENAI if we have no default
            return ProviderType.OPENAI
            
        return default_provider
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the agent.
        
        This method should be overridden by subclasses to provide
        agent-specific system prompts.
        
        Args:
            context: The agent context.
        
        Returns:
            The system prompt string.
        """
        # Get the template
        template = self._settings.get("system_prompt_template", 
                                     "You are {agent_name}, a helpful assistant for an RPG game.")
        
        # Format with agent name
        system_prompt = template.format(agent_name=self.agent_name)
        
        return system_prompt
    
    def _format_conversation_history(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Format conversation history for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        if not self._settings.get("include_conversation_history", True):
            return messages
        
        # Get the max number of entries to include
        max_entries = self._settings.get("max_conversation_entries", 10)
        
        # Get the most recent entries
        recent_history = context.conversation_history[-max_entries:] if context.conversation_history else []
        
        # Format each entry as a message
        for entry in recent_history:
            role = entry.get("role", "user")
            content = entry.get("content", "")
            
            # Map game roles to LLM roles
            if role == "player":
                messages.append({"role": "user", "content": content})
            elif role == "gm":
                messages.append({"role": "assistant", "content": content})
            elif role == "system":
                # Skip system messages in conversation history
                continue
            else:
                # For unknown roles, use user role
                messages.append({"role": "user", "content": f"[{role}] {content}"})
        
        return messages
    
    def _format_memories(self, context: AgentContext) -> str:
        """
        Format memory context for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted memory context string.
        """
        if not context.relevant_memories or not self._settings.get("include_memories", True):
            return ""
        
        memory_lines = ["### Relevant Memories:"]
        
        # Get the max number of entries to include
        max_entries = self._settings.get("max_memory_entries", 5)
        
        # Format each memory entry
        for i, memory in enumerate(context.relevant_memories[:max_entries]):
            # Extract memory details
            content = memory.get("content", "")
            importance = memory.get("importance", 0)
            timestamp = memory.get("timestamp", "")
            
            memory_lines.append(f"{i+1}. [{importance}] {content} ({timestamp})")
        
        return "\n".join(memory_lines)
    
    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        # Add system prompt
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        
        # Add conversation history
        history_messages = self._format_conversation_history(context)
        messages.extend(history_messages)
        
        # Prepare the user message with the current input
        user_message = context.player_input
        
        # Add memory context if available
        memory_context = self._format_memories(context)
        if memory_context:
            user_message = f"{memory_context}\n\n{user_message}"
        
        # Add context summary if available
        if context.context_summary:
            user_message = f"{context.context_summary}\n\n{user_message}"
        
        # Add the user message
        messages.append({"role": "user", "content": user_message})
        
        return messages
    
    def process(self, context: AgentContext) -> AgentResponse:
        """
        Process a request with the agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The agent response.
        """
        logger.info(f"Processing request with {self.agent_name} agent")
        
        # Prepare messages for the LLM
        messages = self._prepare_messages(context)
        
        # Get completion from LLM
        try:
            # Ensure we have valid provider and model
            if not self._provider_type:
                logger.warning(f"No provider type set for {self.agent_name} agent. Using default.")
                self._provider_type = self._llm_manager._provider_manager.get_default_provider()
                if not self._provider_type:
                    self._provider_type = ProviderType.OPENAI
            
            # If model is None or empty, use provider default
            effective_model = self._model
            if not effective_model:
                logger.warning(f"No model set for {self.agent_name} agent. Using provider default.")
                effective_model = None  # This will make LLMManager use the provider default
            
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=effective_model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1000),
                timeout=self._settings.get("timeout_seconds", 30)
            )
        except Exception as e:
            logger.error(f"Error getting LLM completion: {e}")
            return AgentResponse(
                content=f"Error: {self.agent_name} agent failed to generate a response.\nError details: {str(e)}",
                metadata={"error": "llm_failure", "error_details": str(e)}
            )
        
        if not llm_response:
            logger.error(f"{self.agent_name} agent failed to get LLM response")
            return AgentResponse(
                content=f"Error: {self.agent_name} agent failed to generate a response.",
                metadata={"error": "llm_failure"}
            )
        
        # Process the LLM response
        content = llm_response.content
        
        # Extract any commands from the content
        commands = self._extract_commands(content)
        
        # Create response
        response = AgentResponse(
            content=content,
            commands=commands,
            metadata={
                "agent_name": self.agent_name,
                "agent_id": self.agent_id,
                "provider": llm_response.provider_type.name,
                "model": llm_response.model,
                "tokens": llm_response.total_tokens,
                "cost": llm_response.cost
            },
            llm_response=llm_response
        )
        
        logger.info(f"{self.agent_name} agent generated response ({llm_response.total_tokens} tokens)")
        return response
    
    def _extract_commands(self, text: str) -> List[Tuple[str, str]]:
        """
        Extract LLM commands from text.
        
        Args:
            text: The text to extract commands from.
        
        Returns:
            A list of (command, args) tuples.
        """
        # Use the CommandProcessor's extract method
        from core.base.commands import get_command_processor
        
        command_processor = get_command_processor()
        return command_processor.extract_llm_commands(text)
    
    def reload_settings(self):
        """
        Reload agent settings from configuration file.
        
        This should be called when LLM settings are updated in the UI.
        """
        self._settings = self._load_agent_settings()
        self._provider_type = self._get_provider_type()
        self._model = self._settings.get("model", None)
        self._temperature = self._settings.get("temperature", 0.7)
        
        logger.info(f"Reloaded settings for {self.agent_name} agent")
    
    @abstractmethod
    def supports_command(self, command: str) -> bool:
        """
        Check if this agent supports a specific command.
        
        Args:
            command: The command name.
        
        Returns:
            True if the agent supports the command, False otherwise.
        """
        pass


# Example implementation (for demonstration purposes)
class TestAgent(BaseAgent):
    """
    Test implementation of BaseAgent.
    
    This is a simple implementation for testing and demonstrating the BaseAgent functionality.
    """
    
    def __init__(self):
        """Initialize the test agent."""
        super().__init__("TestAgent")
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """Generate system prompt for test agent."""
        return (
            "You are TestAgent, a simple agent for testing the BaseAgent functionality.\n"
            "You should respond briefly and directly to user inputs."
        )
    
    def supports_command(self, command: str) -> bool:
        """Check if the test agent supports a command."""
        # Test agent supports TEST_COMMAND
        return command == "TEST_COMMAND"


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create a test agent
    test_agent = TestAgent()
    
    # Create a test context
    context = AgentContext(
        game_state={},
        player_state={"name": "Test Player"},
        world_state={"location": "Test Location"},
        player_input="Hello, agent!",
        conversation_history=[
            {"role": "player", "content": "Hello, world!", "timestamp": "2023-01-01T12:00:00"},
            {"role": "gm", "content": "Welcome to the game!", "timestamp": "2023-01-01T12:00:01"}
        ]
    )
    
    # Process the request
    response = test_agent.process(context)
    
    # Print the response
    print(f"Response: {response.content}")
    print(f"Metadata: {response.metadata}")
    
    if response.commands:
        print("Commands:")
        for cmd, args in response.commands:
            print(f"  {cmd}: {args}")

```

### File: core\agents\combat_narrator.py

```python
#!/usr/bin/env python3
"""
Combat Narrator agent for handling combat interactions.
"""

import re
import json
import logging
from typing import List, Dict, Any, Optional

from core.combat.combat_manager import CombatManager
from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode
from core.stats.stats_base import Skill

logger = get_logger("AGENT")

class CombatNarratorAgent(BaseAgent):
    """
    Agent responsible for narrating combat and interpreting player/NPC actions within combat.

    It receives combat-specific context and player/NPC input, generates narrative
    describing the action's attempt, and identifies necessary skill checks
    or state changes requested by the intent.
    """

    def __init__(self):
        """Initialize the combat narrator agent."""
        super().__init__("CombatNarrator")

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the combat narrator agent.
        """
        # --- Context Extraction (Use combat_name where appropriate) ---
        player_id_internal = context.player_state.get("id", "player")
        combat_context = context.additional_context.get("combat_context", {})
        participants_data = context.additional_context.get("participants", []) # Get full participant data
        turn_order_ids = combat_context.get("turn_order", [])
        current_turn_internal_id = combat_context.get("current_turn", "Unknown")

        # Create mapping from internal ID to combat name for easier lookup
        id_to_combat_name = {p.get('id', 'N/A'): p.get('combat_name', p.get('name', 'Unknown')) for p in participants_data}

        turn_order_str = ", ".join([id_to_combat_name.get(p_id, '?') for p_id in turn_order_ids]) # Use combat names
        current_turn_combat_name = id_to_combat_name.get(current_turn_internal_id, "Unknown")

        participant_list_parts = []
        player_combat_name = "Player" # Default

        for p in participants_data:
            p_internal_id = p.get('id', 'N/A')
            p_combat_name = id_to_combat_name.get(p_internal_id, p.get('name', 'Unknown')) # Get combat name via mapping

            if p_internal_id == player_id_internal:
                player_combat_name = p_combat_name # Store player's combat name

            # Format status effects (assuming dict {name: duration/data})
            effects = p.get('status_effects', {})
            effects_str_parts = []
            if isinstance(effects, dict):
                for name, duration_data in effects.items():
                    duration = None
                    if isinstance(duration_data, int):
                        duration = duration_data
                    elif isinstance(duration_data, dict): # Handle StatusEffectData dicts
                        duration = duration_data.get('duration')

                    if duration is None:
                        effects_str_parts.append(str(name))
                    else:
                        effects_str_parts.append(f"{name}({duration}t)") # Use 't' for turns
            elif isinstance(effects, (list, set)): # Fallback for list/set format
                effects_str_parts = [str(eff) for eff in effects]

            effects_str = f" Effects: [{', '.join(effects_str_parts)}]" if effects_str_parts else ""

            # Get HP/Stamina safely
            hp = p.get('hp', '?')
            max_hp = p.get('max_hp', '?')
            stamina = p.get('stamina', '?') # Assuming stamina might be in context now
            max_stamina = p.get('max_stamina', '?')

            participant_list_parts.append(
                f"- Combat Name: '{p_combat_name}' (Original: {p.get('name', 'Unknown')}, "
                f"HP: {hp}/{max_hp}, "
                f"Stamina: {stamina}/{max_stamina})"
                f"{effects_str}"
            )
        participant_list = "\n".join(participant_list_parts)

        round_num = combat_context.get("round", 1)

        # --- Load Skills (existing logic) ---
        try:
            from core.stats.skill_manager import get_skill_manager
            skill_manager = get_skill_manager()
            available_skills = skill_manager.get_skill_list_for_llm()
        except Exception as e:
            logger.warning(f"Could not load skills from SkillManager: {e}. Using defaults.")
            available_skills = """Available skills for checks (use exact names):
    - MELEE_ATTACK: Physical close-range combat attacks
    - RANGED_ATTACK: Physical ranged combat attacks
    - UNARMED_ATTACK: Attacking without weapons
    - SPELL_ATTACK: Magical attacks
    - DEFENSE: Blocking or parrying attacks
    - DODGE: Avoiding attacks and obstacles"""

        # --- SYSTEM PROMPT (Emphasize Combat Names) ---
        system_prompt = f"""You are the Combat Narrator AI for a text-based RPG. Your role is to process combat action INTENT, describe the attempted action, and output the corresponding game mechanics as structured requests.

        ## CRITICAL INSTRUCTION: JSON OUTPUT ONLY & COMBAT NAMES
        Your *ENTIRE* response MUST be a single, valid JSON object. NO introductory text, explanations, markdown, or other characters outside the JSON structure.
        **VERY IMPORTANT**: When referring to entities in the `"requests"` list (`actor_id`, `target_actor_id`, `target_entity`), YOU MUST use their **Combat Name** exactly as listed in the 'Participants' section below (e.g., 'Qa', 'elder', 'Goblin 1'). Do **NOT** use original names or generic terms like 'player'.

        ## Required Output Format (JSON Object Only)
        ```json
        {{
        "narrative": "Your descriptive text about the ATTEMPTED combat action. Describe the wind-up, movement, target, etc. Focus on the *attempt*, NOT the outcome (success/failure). Do NOT repeat the input intent verbatim.",
        "requests": [
            // REQUIRED: Include one or more structured requests based on the action intent.
            // Use the examples below ONLY as structural guides. DO NOT use the specific values from the examples.
            // --- Example 1: Physical Attack (Melee/Ranged/Unarmed) ---
            {{
            "action": "request_skill_check",
            "actor_id": "[ACTOR_COMBAT_NAME]", // **USE COMBAT NAME** of the entity performing the action (from Current Turn context)
            "skill_name": "[ATTACK_SKILL_NAME]", // MELEE_ATTACK, RANGED_ATTACK, or UNARMED_ATTACK
            "stat_name": "[PHYSICAL_STAT]", // Typically STRENGTH or DEXTERITY
            "target_actor_id": "[TARGET_COMBAT_NAME]", // **USE COMBAT NAME** of the target entity (from Action Intent or Participants list)
            "difficulty_class": "[ESTIMATED_DEFENSE]", // Target's Defense score - Estimate 10-15 if unknown
            "modifiers": {{}}, // Optional: {{"circumstance_bonus": 2}}
            "context": "[Brief context, e.g., 'Actor attacking Target with weapon_name']"
            }},
            // --- Example 2: Spell Attack ---
            {{
            "action": "request_skill_check",
            "actor_id": "[ACTOR_COMBAT_NAME]", // **USE COMBAT NAME**
            "skill_name": "SPELL_ATTACK",
            "stat_name": "[SPELLCASTING_STAT]", // Typically INTELLIGENCE, WISDOM, or CHARISMA
            "target_actor_id": "[TARGET_COMBAT_NAME]", // **USE COMBAT NAME**
            "difficulty_class": "[ESTIMATED_MAGIC_DEFENSE]", // Target's Magic Defense or Save DC estimate (10-15)
            "modifiers": {{}},
            "context": "[Brief context, e.g., 'Actor casting spell_name at Target']"
            }},
            // --- Example 3: Applying Status Effect ---
            {{
            "action": "request_state_change",
            "target_entity": "[TARGET_COMBAT_NAME]", // **USE COMBAT NAME**
            "attribute": "add_status_effect", // Or "remove_status_effect"
            "change_type": "set", // Usually 'set' for effects
            "value": "[EFFECT_NAME]", // String name (e.g., BURNING, STUNNED, DEFENDING)
            "duration": "[DURATION_TURNS]", // Optional: Integer number of turns
            "context": "[Brief context, e.g., 'Result of spell hitting target']"
            }}
            // Add other request types (like Defend via state change) as needed.
        ]
        }}
        ```

        ## Current Combat State (Round {round_num})
        - Participants (Use **'Combat Name'** for IDs in JSON requests):
    {participant_list}
        - Turn Order (Combat Names): {turn_order_str}
        - Current Turn: '{current_turn_combat_name}'
        - Player Combat Name: '{player_combat_name}'

        ## Available Skills for Checks (Use ONLY these skill names in `skill_name`)
    {available_skills}

        ## Task: Process Action Intent into JSON Output
        Given the current combat state and the 'Action Intent to Process' below:
        1.  **Narrate Attempt:** Describe the action attempt. DO NOT determine success/failure.
        2.  **Determine Mechanics & Target:**
            *   Analyze the 'Action Intent'. Identify the intended action type (physical attack, spell, defend, etc.) and the intended target (by name or description).
            *   Find the Target **Combat Name**: Match the intended target name/description from the intent to a participant in the 'Participants' list. Use the corresponding **Combat Name** for `target_actor_id` or `target_entity`. **CRITICAL: Use ONLY Combat Names listed in the 'Participants' section.**
            *   Find the Actor **Combat Name**: Use the name provided in 'Current Turn'.
        3.  **Select Skill & Stat:** Choose the most appropriate `skill_name` from the 'Available Skills' list. Determine the likely primary `stat_name`.
        4.  **Construct Request(s):** Create the JSON request object(s).
            *   Use the correct Actor **Combat Name** and Target **Combat Name** found in step 2.
            *   Fill in other fields (`skill_name`, `stat_name`, `difficulty_class`, etc.) based on the action. For attacks, estimate target defenses (10-15) if unknown.
        5.  **Output JSON:** Ensure the final output is ONLY the valid JSON object. NO EXTRA TEXT.

        ## Action Intent to Process:
        ```
        {context.player_input}
        ```

        ## REMEMBER: YOUR ENTIRE RESPONSE MUST BE A SINGLE VALID JSON OBJECT. USE ONLY **COMBAT NAMES** FOR IDs.
        """
        return system_prompt

    # TODO: Add method CombatNarratorAgent.narrate_outcome(action_result, combat_manager)
    # This method would take the result dictionary from perform_action and generate narrative.
    # It would need its own system prompt focused on describing outcomes.

    def _format_combat_context(self, context: AgentContext) -> str:
        """ Formats the combat specific context """
        combat_context = context.additional_context.get("combat_context", {})
        if not combat_context:
            return ""

        lines = ["## Combat Situation"]
        participants = combat_context.get("participants", [])
        turn_order = combat_context.get("turn_order", [])
        current_turn = combat_context.get("current_turn", "Unknown")
        round_num = combat_context.get("round", 1)

        lines.append(f"- Round: {round_num}")
        lines.append(f"- Current Turn: {current_turn}")
        lines.append(f"- Turn Order: {', '.join(turn_order)}")
        lines.append("### Participants:")
        for p in participants:
            # Assuming status_effects is now a dict {name: duration}
            status_str = ", ".join(p.get('status_effects', {}).keys())
            lines.append(f"- {p.get('name', 'Unknown')} (ID: {p.get('id', 'N/A')}, HP: {p.get('hp', '?')}/{p.get('max_hp', '?')}, Stamina: {p.get('stamina', '?')}/{p.get('max_stamina', '?')}, Status: {status_str or 'Normal'})") # Added Stamina

        environment_tags = context.additional_context.get("environment", [])
        if environment_tags:
            lines.append("### Environmental Features:")
            lines.append(f"- Tags: {', '.join(environment_tags)}")

        return "\n".join(lines)

    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list specifically for the Combat Narrator.
        """
        messages = []
        # Generate the system prompt with the actual input substituted
        final_system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": final_system_prompt})
        # Note: We do NOT add conversation history or a separate user message here,
        # as the entire context and the specific action intent are baked into the system prompt.
        logger.debug(f"Prepared messages for CombatNarrator (System Prompt Only):\n{messages[0]['content'][:500]}...") # Log start of prompt
        return messages

    def process(self, context: AgentContext) -> Optional[AgentOutput]:
        """
        Process a combat request, expecting a structured JSON output.

        Args:
            context: The context for the request.

        Returns:
            An AgentOutput dictionary containing the narrative and structured requests, or None on failure.
        """
        # Log the mode being processed and the player input
        mode = context.additional_context.get('mode', 'N/A')
        player_input = context.player_input if hasattr(context, 'player_input') else 'No input'
        logger.info(f"Processing request with CombatNarrator agent. Mode: {mode}, Intent: '{player_input[:50]}...'")

        messages = self._prepare_messages(context)
        agent_output: Optional[AgentOutput] = None # Initialize

        try:
            # --- LLM Call ---
            effective_model = self._model or None
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=effective_model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1000),
                timeout=self._settings.get("timeout_seconds", 30)
            )

            if not llm_response or not llm_response.content:
                raise ValueError("LLM returned empty response or content.")

            llm_response_content = llm_response.content.strip()
            logger.debug(f"Raw LLM Response (Combat):\n```\n{llm_response_content}\n```")

            # --- Enhanced JSON Parsing ---
            parsed_output = None
            cleaned_response = llm_response_content
            try:
                 # 1. Remove potential markdown fences first
                cleaned_response = re.sub(r'^```(?:json)?\s*|\s*```$', '', cleaned_response, flags=re.MULTILINE).strip()

                # 2. Try direct parsing
                parsed_output = json.loads(cleaned_response)
                logger.debug("Successfully parsed JSON directly.")

            except json.JSONDecodeError as e:
                logger.warning(f"Initial JSON parsing failed: {e}. Trying to extract JSON object...")
                # 3. If direct parsing fails, try to find the first '{' and last '}'
                start_index = cleaned_response.find('{')
                end_index = cleaned_response.rfind('}')
                if start_index != -1 and end_index != -1 and start_index < end_index:
                    json_substring = cleaned_response[start_index : end_index + 1]
                    try:
                        parsed_output = json.loads(json_substring)
                        logger.info("Successfully parsed extracted JSON substring.")
                    except json.JSONDecodeError as e_inner:
                        logger.error(f"Failed to parse extracted JSON substring: {e_inner}")
                        logger.error(f"Substring attempted: ```\n{json_substring}\n```")
                        parsed_output = None # Ensure it's None if second parse fails
                else:
                    logger.error("Could not find valid JSON object markers '{' and '}' in the response.")
                    parsed_output = None

            # --- Validate Structure and Build Output ---
            if (isinstance(parsed_output, dict) and
                "narrative" in parsed_output and
                "requests" in parsed_output and
                isinstance(parsed_output["requests"], list)):

                # Validate requests format (basic check)
                validated_requests = []
                for req in parsed_output["requests"]:
                    if isinstance(req, dict) and "action" in req:
                        validated_requests.append(req)
                    else:
                        logger.warning(f"Skipping invalid request structure: {req}")

                agent_output = {
                    "narrative": parsed_output["narrative"],
                    "requests": validated_requests
                }
                narrative_snippet = parsed_output["narrative"][:100]
                logger.info(f"Successfully parsed valid JSON response. Narrative: '{narrative_snippet}...', Requests: {len(validated_requests)}")

            else: # Parsing failed or structure invalid
                logger.error("Failed to parse LLM response as valid JSON AgentOutput.")
                # **Fallback:** Create a default basic attack request if parsing fails during combat
                # This prevents combat from stalling completely if the LLM messes up JSON.
                if context.game_state.get("mode") == InteractionMode.COMBAT:
                    logger.warning("Applying fallback: Generating basic attack request due to JSON failure.")
                    # Find a likely target (first enemy)
                    target_id = None
                    combat_context = context.additional_context.get("combat_context", {})
                    participants = combat_context.get("participants", [])
                    player_id = context.player_state.get("id", "player")
                    for p in participants:
                        p_id = p.get('id')
                        p_type = p.get('entity_type') # Assuming type is available
                        if p_id != player_id and p_type == 'ENEMY': # Find first enemy
                             target_id = p_id
                             break

                    if target_id:
                        fallback_request = {
                            "action": "request_skill_check",
                            "actor_id": player_id,
                            "skill_name": "MELEE_ATTACK", # Assume basic melee
                            "stat_name": "STRENGTH",
                            "target_actor_id": target_id,
                            "difficulty_class": 12, # Default guess
                            "modifiers": {},
                            "context": f"Fallback: Actor basic attack on {target_id}."
                        }
                        agent_output = {
                            "narrative": f"{context.player_state.get('name', 'Actor')} attempts a basic attack on {target_id}. (LLM response parsing failed)",
                            "requests": [fallback_request]
                        }
                        logger.info("Generated fallback basic attack request.")
                    else:
                         # If no target found, return error narrative
                         agent_output = {
                             "narrative": "You attempt an action, but something goes wrong. (LLM Response Error)",
                             "requests": []
                         }
                else:
                     # If not in combat, just return error narrative
                     agent_output = {
                        "narrative": "There was an issue processing the response. (LLM Response Error)",
                        "requests": []
                     }

        except Exception as e:
            logger.exception(f"Error during CombatNarrator processing: {e}")
            agent_output = None # Indicate failure

        if agent_output:
             logger.info(f"CombatNarrator generated output with {len(agent_output['requests'])} requests.")
        else:
             logger.error("CombatNarrator failed to generate valid output.")

        return agent_output

    def supports_command(self, command: str) -> bool:
        # Combat Narrator doesn't handle direct commands, only interprets intent
        return False

    def _generate_outcome_narration_prompt(self, action_result: Dict, combat_manager: CombatManager) -> str:
        """Generates the prompt for narrating an action's outcome, focusing on the result dict."""

        prompt = f"""You are the Combat Narrator AI. Describe the outcome of the combat action based *only* on the following JSON results. Be concise and vivid. Focus on what happened, not the mechanics.

        Action Result Data:
        ```json
        {json.dumps(action_result, indent=2, default=str)}
        ```

        Describe the outcome:"""
        return prompt

    def narrate_outcome(self, action_result: Dict, combat_manager: CombatManager) -> Optional[str]:
        """Generates narrative describing the outcome of a resolved action."""
        if not action_result:
            logger.warning("narrate_outcome called with no action_result.")
            return None

        logger.info(f"Attempting to narrate outcome for action result: {action_result}")
        prompt = self._generate_outcome_narration_prompt(action_result, combat_manager)
        # Send result as JSON for the LLM to parse
        messages = [{"role": "system", "content": "You are the Combat Narrator AI. Describe the outcome of the action concisely and vividly based *only* on the provided JSON result details."},
                    {"role": "user", "content": f"Action Result Data:\n```json\n{json.dumps(action_result, indent=2, default=str)}\n```\n\nDescribe the outcome:"}]

        raw_llm_response_content = "[No LLM Response]" # Default for logging if call fails
        try:
            logger.debug(f"Calling LLM for outcome narration. Prompt implies action: {action_result.get('action_name', 'unknown')}")
            llm_response = self._llm_manager.get_completion(
                messages=messages, provider_type=self._provider_type, model=self._model,
                temperature=0.6, max_tokens=150
            )

            if llm_response and llm_response.content:
                raw_llm_response_content = llm_response.content # Store raw response for logging
                narrative = raw_llm_response_content.strip()
                # Basic cleaning
                narrative = re.sub(r'^(Outcome Description|Narrative|Result)[:\s]*', '', narrative, flags=re.IGNORECASE).strip()
                narrative = re.sub(r'^```(?:json)?\s*|\s*```$', '', narrative, flags=re.MULTILINE).strip()
                # Ensure it's not empty after cleaning
                if not narrative:
                    logger.warning("LLM returned empty content after cleaning for outcome narration.")
                    logger.debug(f"Raw response for empty outcome narration: {raw_llm_response_content}") # Log raw response if clean fails
                    return None

                logger.info(f"Generated outcome narrative: '{narrative[:100]}...'")
                return narrative
            else:
                logger.warning("LLM returned no content for outcome narration.")
                return None
        except Exception as e:
            logger.exception(f"Error generating outcome narration via LLM: {e}")
            logger.debug(f"Raw response (if any) leading to outcome narration error: {raw_llm_response_content}") # Log raw response on error
            return f"[System Error: Could not generate outcome description for {action_result.get('action_name', 'action')}.]"
        
# Convenience function
def get_combat_narrator_agent() -> CombatNarratorAgent:
    return CombatNarratorAgent()
```

### File: core\agents\context_evaluator.py

```python
#!/usr/bin/env python3
"""
Context evaluator agent for analyzing game context.

This module provides a ContextEvaluatorAgent class that analyzes the current
game context, identifies relevant memories, calculates importance scores,
and suggests potential actions to the player.
"""

import os
import re
import json
import math
from typing import Dict, List, Optional, Any, Tuple, Set
import logging

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext, AgentResponse

# Get the module logger
logger = get_logger("AGENT")

class ContextEvaluatorAgent(BaseAgent):
    """
    Context evaluator agent for analyzing game context.
    
    This agent analyzes the current game context, identifies relevant memories,
    calculates importance scores for different context elements, and generates
    summaries for use by other agents.
    """
    
    # Command types supported by the context evaluator
    SUPPORTED_COMMANDS = [
        "CONTEXT_SUMMARIZE", "MEMORY_EVALUATE", "SUGGEST_FOCUS", 
        "IMPORTANCE_SCORE", "RELEVANCE_CHECK"
    ]
    
    def __init__(self):
        """Initialize the context evaluator agent."""
        super().__init__("context_evaluator")
        
        # Cache for context summaries
        self._context_summaries: Dict[str, Tuple[str, float]] = {}

    def reset(self) -> None:
        """Clear cached context summaries to avoid cross-session leakage."""
        try:
            self._context_summaries.clear()
        except Exception:
            self._context_summaries = {}
        logger.info("ContextEvaluator agent cache cleared")
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the context evaluator agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The system prompt string.
        """
        system_prompt = """You are the ContextEvaluator, an AI responsible for analyzing game context, evaluating memories, and determining what information is most relevant to the current situation. Your goal is to provide context awareness to both the player and other game systems.

## Your Responsibilities
1. Analyze the current game context and determine what is most relevant
2. Evaluate memory entries for their importance to the current situation
3. Generate concise, useful context summaries
4. Suggest topics, elements, or actions that might be relevant
5. Calculate importance scores for different context elements
6. Identify connections between seemingly unrelated pieces of information

## Analysis Approach
- **Situational Relevance**: Consider the player's current location, ongoing quests, recent actions, and immediate goals
- **Character Relationships**: Identify NPCs, factions, and entities relevant to the current context
- **Knowledge Continuity**: Ensure important information from past interactions is surfaced when relevant
- **Narrative Coherence**: Maintain storytelling consistency and logical progression
- **Quest Progression**: Highlight information relevant to active and nearby quests
- **Environmental Context**: Note location-specific details, hazards, or opportunities
- **Player Intent**: Consider what the player is likely trying to accomplish

## Output Format
Provide your analysis in this format:
1. Context Summary (2-3 sentences highlighting the most critical elements)
2. Key Elements (bullet points of the most important context items)
3. Suggested Focus (what the player should consider or attend to)
4. Importance Scores (numeric ratings for different context elements)

## Special Instructions
- Be concise and precise - focus on the most relevant information
- Consider both immediate and long-term relevance
- Prioritize information that might otherwise be forgotten or overlooked
- Avoid unnecessary repetition of obvious information
- When evaluating memories, consider recency, uniqueness, and narrative impact
- Use numeric scores (0-10) when evaluating importance

Analyze the provided context and respond with your evaluation.
"""
        
        return system_prompt
    
    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        # Add system prompt
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        
        # Add current game state information
        state_info = self._format_game_state(context)
        if state_info:
            messages.append({"role": "user", "content": state_info})
        
        # Add memory entries if available
        memory_info = self._format_memories(context)
        if memory_info:
            messages.append({"role": "user", "content": memory_info})
        
        # Add conversation history
        history_info = self._format_conversation_summary(context)
        if history_info:
            messages.append({"role": "user", "content": history_info})
        
        # Add the evaluation request
        eval_request = self._format_evaluation_request(context)
        messages.append({"role": "user", "content": eval_request})
        
        return messages
    
    def _format_game_state(self, context: AgentContext) -> str:
        """
        Format game state information for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted game state string.
        """
        # Extract player information
        player_state = context.player_state
        if not player_state:
            return ""
        
        player_name = player_state.get("name", "Unknown")
        player_race = player_state.get("race", "Human")
        player_path = player_state.get("path", "Wanderer")
        player_location = player_state.get("current_location", "Unknown")
        player_district = player_state.get("current_district", "Unknown")
        
        # Extract world information
        world_state = context.world_state
        if not world_state:
            return ""
        
        time_of_day = world_state.get("time_of_day", "Unknown")
        weather = world_state.get("weather", "Clear")
        is_day = world_state.get("is_day", True)
        day_night = "day" if is_day else "night"
        
        # Get active quests if available
        active_quests = player_state.get("active_quests", [])
        
        # Format the information
        state_lines = [
            "## Current Game State",
            f"- Player: {player_name} the {player_race} {player_path}",
            f"- Location: {player_location}, {player_district}",
            f"- Time: {time_of_day} ({day_night})",
            f"- Weather: {weather}"
        ]
        
        # Add active quests
        if active_quests:
            state_lines.append("\n### Active Quests")
            for quest in active_quests:
                quest_name = quest.get("name", "Unknown Quest")
                quest_stage = quest.get("stage", "Unknown")
                state_lines.append(f"- {quest_name} (Stage: {quest_stage})")
        
        return "\n".join(state_lines)
    
    def _format_memories(self, context: AgentContext) -> str:
        """
        Format memory entries for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted memory entries string.
        """
        if not context.relevant_memories:
            return ""
        
        memory_lines = ["## Memory Entries to Evaluate"]
        
        # Organize memories by type
        memories_by_type = {}
        
        for memory in context.relevant_memories:
            memory_type = memory.get("type", "general")
            
            if memory_type not in memories_by_type:
                memories_by_type[memory_type] = []
            
            memories_by_type[memory_type].append(memory)
        
        # Add memories by type
        for memory_type, memories in memories_by_type.items():
            memory_lines.append(f"\n### {memory_type.title()} Memories")
            
            for i, memory in enumerate(memories):
                content = memory.get("content", "")
                timestamp = memory.get("timestamp", "")
                memory_lines.append(f"{i+1}. {content} ({timestamp})")
        
        return "\n".join(memory_lines)
    
    def _format_conversation_summary(self, context: AgentContext) -> str:
        """
        Format a summary of recent conversation for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted conversation summary string.
        """
        if not context.conversation_history:
            return ""
        
        # Get the most recent conversation entries (last 5)
        recent_conversation = context.conversation_history[-5:]
        
        summary_lines = ["## Recent Conversation"]
        
        for entry in recent_conversation:
            role = entry.get("role", "unknown")
            content = entry.get("content", "")
            
            # Format based on role
            if role == "player":
                summary_lines.append(f"Player: {content}")
            elif role == "gm":
                summary_lines.append(f"Narrator: {content}")
            else:
                summary_lines.append(f"{role.title()}: {content}")
        
        return "\n".join(summary_lines)
    
    def _format_evaluation_request(self, context: AgentContext) -> str:
        """
        Format the evaluation request for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted evaluation request string.
        """
        request_lines = [
            "## Context Evaluation Request",
            "Please evaluate the current game context based on the information provided above.",
            "Consider what is most relevant to the player's current situation and goals.",
            "",
            "### Current Focus",
            f"Player's last input: \"{context.player_input}\"",
            "",
            "Provide a context summary, identify key elements, suggest a focus, and assign importance scores."
        ]
        
        return "\n".join(request_lines)
    
    def process(self, context: AgentContext) -> AgentResponse:
        """
        Process a context evaluation request.
        
        Args:
            context: The agent context.
        
        Returns:
            The agent response.
        """
        logger.info("Processing request with ContextEvaluator agent")
        
        # Use the base process method
        response = super().process(context)
        
        # Parse the evaluation result
        evaluation_result = self._parse_evaluation_result(response.content)
        
        # Add the evaluation result to the response metadata
        if evaluation_result:
            response.metadata["evaluation_result"] = evaluation_result
        
        # Cache the context summary if successful
        if evaluation_result and "context_summary" in evaluation_result:
            key = self._generate_context_key(context)
            summary = evaluation_result["context_summary"]
            timestamp = context.world_state.get("game_time", 0) if context.world_state else 0
            
            self._context_summaries[key] = (summary, timestamp)
        
        return response
    
    def _parse_evaluation_result(self, content: str) -> Dict[str, Any]:
        """
        Parse the evaluation result from the LLM response.
        
        Args:
            content: The LLM response content.
        
        Returns:
            Dictionary with evaluation result information.
        """
        result = {
            "context_summary": None,
            "key_elements": [],
            "suggested_focus": None,
            "importance_scores": {}
        }
        
        # Extract context summary
        summary_match = re.search(r"(?:Context Summary:?|Summary:?)\s*(.+?)(?:\n\n|\n#|\n\*|$)", content, re.IGNORECASE | re.DOTALL)
        if summary_match:
            result["context_summary"] = summary_match.group(1).strip()
        
        # Extract key elements
        elements_section = re.search(r"(?:Key Elements:?|Important Elements:?)(.+?)(?:\n\n|\n#|$)", content, re.IGNORECASE | re.DOTALL)
        if elements_section:
            elements_text = elements_section.group(1).strip()
            # Extract bullet points
            elements = re.findall(r"(?:^|\n)-\s*(.+?)(?:$|\n)", elements_text)
            result["key_elements"] = [e.strip() for e in elements if e.strip()]
        
        # Extract suggested focus
        focus_match = re.search(r"(?:Suggested Focus:?|Focus:?)\s*(.+?)(?:\n\n|\n#|$)", content, re.IGNORECASE | re.DOTALL)
        if focus_match:
            result["suggested_focus"] = focus_match.group(1).strip()
        
        # Extract importance scores
        scores_section = re.search(r"(?:Importance Scores:?|Scores:?)(.+?)(?:\n\n|\n#|$)", content, re.IGNORECASE | re.DOTALL)
        if scores_section:
            scores_text = scores_section.group(1).strip()
            # Extract element-score pairs
            score_patterns = [
                r"(?:^|\n)-\s*(.+?):\s*(\d+(?:\.\d+)?)",  # Bullet point format
                r"(?:^|\n)(.+?):\s*(\d+(?:\.\d+)?)"       # Regular format
            ]
            
            for pattern in score_patterns:
                scores = re.findall(pattern, scores_text)
                if scores:
                    for element, score in scores:
                        try:
                            result["importance_scores"][element.strip()] = float(score)
                        except ValueError:
                            pass
        
        return result
    
    def _generate_context_key(self, context: AgentContext) -> str:
        """
        Generate a key for caching context summaries.
        
        Args:
            context: The agent context.
        
        Returns:
            A string key representing the context.
        """
        # Create a key based on location and player input
        location = context.player_state.get("current_location", "") if context.player_state else ""
        district = context.player_state.get("current_district", "") if context.player_state else ""
        input_hash = hash(context.player_input) % 10000  # Simple hash of input
        
        return f"{location}_{district}_{input_hash}"
    
    def get_cached_summary(self, context: AgentContext) -> Optional[str]:
        """
        Get a cached context summary if available and recent.
        
        Args:
            context: The agent context.
        
        Returns:
            A cached summary string, or None if not available.
        """
        key = self._generate_context_key(context)
        
        if key in self._context_summaries:
            summary, timestamp = self._context_summaries[key]
            
            # Check if the summary is still recent enough
            current_time = context.world_state.get("game_time", 0) if context.world_state else 0
            
            # If the summary is less than 10 minutes old in game time, use it
            if current_time - timestamp < 600:
                return summary
        
        return None
    
    def evaluate_context(self, context: AgentContext) -> Dict[str, Any]:
        """
        Evaluate the current game context.
        
        Args:
            context: The agent context.
        
        Returns:
            Dictionary with evaluation results.
        """
        # Check for cached summary first
        cached_summary = self.get_cached_summary(context)
        if cached_summary:
            logger.info("Using cached context summary")
            return {
                "context_summary": cached_summary,
                "source": "cache"
            }
        
        # Otherwise, process the context evaluation
        response = self.process(context)
        
        # Return the evaluation result
        return response.metadata.get("evaluation_result", {})
    
    def supports_command(self, command: str) -> bool:
        """
        Check if the context evaluator agent supports a specific command.
        
        Args:
            command: The command name.
        
        Returns:
            True if the agent supports the command, False otherwise.
        """
        return command in self.SUPPORTED_COMMANDS


# Convenience function
def get_context_evaluator_agent() -> ContextEvaluatorAgent:
    """Get the context evaluator agent instance."""
    return ContextEvaluatorAgent()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the context evaluator agent
    context_evaluator = get_context_evaluator_agent()
    
    # Create a test context
    context = AgentContext(
        game_state={},
        player_state={
            "name": "Thorn",
            "race": "Elf",
            "path": "Ranger",
            "background": "Outcast",
            "current_location": "Whispering Woods",
            "current_district": "Ancient Grove",
            "active_quests": [
                {"name": "The Lost Artifact", "stage": "Find the entrance to the ancient temple"}
            ]
        },
        world_state={
            "time_of_day": "evening",
            "weather": "Light Rain",
            "is_day": False,
            "game_time": 1000
        },
        player_input="I look around for any signs of the temple entrance.",
        conversation_history=[
            {"role": "player", "content": "I enter the Ancient Grove cautiously.", "timestamp": "2023-01-01T12:00:00"},
            {"role": "gm", "content": "The trees here are older and more gnarled, their branches forming a dense canopy above. Strange symbols are carved into some of the trunks.", "timestamp": "2023-01-01T12:00:01"},
            {"role": "player", "content": "I examine the symbols on the trees.", "timestamp": "2023-01-01T12:00:02"},
            {"role": "gm", "content": "The symbols appear to be an ancient elven script. They seem to be pointing in a specific direction deeper into the grove.", "timestamp": "2023-01-01T12:00:03"}
        ],
        relevant_memories=[
            {
                "content": "The Ancient Grove is said to contain a hidden temple dedicated to the old gods.",
                "type": "location",
                "importance": 0.9,
                "timestamp": "2023-01-01T11:30:00"
            },
            {
                "content": "The temple entrance is marked by trees with elven runes.",
                "type": "quest",
                "importance": 0.95,
                "timestamp": "2023-01-01T11:35:00"
            },
            {
                "content": "You obtained a map fragment showing part of the Ancient Grove.",
                "type": "item",
                "importance": 0.8,
                "timestamp": "2023-01-01T11:40:00"
            }
        ]
    )
    
    # Process the request
    response = context_evaluator.process(context)
    
    # Print the response
    print(f"Response: {response.content}")
    
    # Print the evaluation result
    evaluation_result = response.metadata.get("evaluation_result", {})
    if evaluation_result:
        print("\nEvaluation Result:")
        print(f"Context Summary: {evaluation_result.get('context_summary')}")
        print(f"Key Elements: {evaluation_result.get('key_elements')}")
        print(f"Suggested Focus: {evaluation_result.get('suggested_focus')}")
        print(f"Importance Scores: {evaluation_result.get('importance_scores')}")
```

### File: core\agents\data_retrieval_commands.py

```python
"""
Data retrieval commands for LLM agents.

This module provides commands that allow LLM agents to request specific game data
only when needed instead of including all data in every context.
"""

from typing import Dict, List, Optional, Any, Tuple
import logging

from core.utils.logging_config import get_logger
from core.base.state import GameState
from core.inventory import get_inventory_manager, Item # Added Item import

# Get module logger
logger = get_logger("DATA_RETRIEVAL")

def get_inventory_data(game_state: GameState) -> Dict[str, Any]:
    """
    Get detailed inventory data for an LLM agent in the simplified format.
    
    Args:
        game_state: The current game state.
    
    Returns:
        A dictionary containing inventory data with 'equipped' and 'backpack' keys.
    """
    logger.info("Retrieving inventory data for LLM agent (simplified format)")
    
    try:
        inventory_manager = get_inventory_manager()
        
        if not inventory_manager:
            logger.warning("Inventory manager not available for data retrieval.")
            return {"error": "Inventory manager not available"}
        
        equipped_items_dict: Dict[str, Dict[str, str]] = {}
        backpack_items_list: List[Dict[str, Any]] = []

        # Populate equipped items
        if hasattr(inventory_manager, 'equipment') and isinstance(inventory_manager.equipment, dict):
            for slot, item_id in inventory_manager.equipment.items():
                if item_id:
                    item_obj: Optional[Item] = inventory_manager.get_item(item_id)
                    if item_obj:
                        equipped_items_dict[slot.value] = { # Use slot.value for the key
                            "name": item_obj.name,
                            "id": item_obj.id,
                            "type": item_obj.item_type.value if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type)
                        }
                    else:
                        logger.warning(f"Equipped item ID {item_id} in slot {slot.value} not found in inventory manager items.")
        else:
            logger.warning("Inventory manager 'equipment' attribute missing or not a dict.")

        # Populate backpack items
        if hasattr(inventory_manager, 'items') and isinstance(inventory_manager.items, dict): # Assuming _items is the dict
            all_items_in_inventory = inventory_manager.items.values()
        elif hasattr(inventory_manager, 'items') and isinstance(inventory_manager.items, list): # Fallback if it's a list
            all_items_in_inventory = inventory_manager.items
        else:
            all_items_in_inventory = []
            logger.warning("Inventory manager 'items' attribute missing or not a list/dict.")

        for item_obj in all_items_in_inventory:
            if not inventory_manager.is_item_equipped(item_obj.id):
                backpack_items_list.append({
                    "name": item_obj.name,
                    "id": item_obj.id,
                    "type": item_obj.item_type.value if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type),
                    "quantity": item_obj.quantity if item_obj.is_stackable else 1
                })
        
        # Get currency data
        currency_data = {}
        if hasattr(inventory_manager, 'currency'):
            currency_data = inventory_manager.currency.get_currency_dict()
        else:
            logger.warning("Inventory manager 'currency' attribute missing.")

        inventory_data = {
            "equipped": equipped_items_dict,
            "backpack": backpack_items_list,
            "currency": currency_data, # Keep currency as is
            "weight": { # Keep weight/slots as is
                "current": inventory_manager.get_current_weight(),
                "limit": inventory_manager.weight_limit
            },
            "slots": {
                "used": inventory_manager.get_used_slots(),
                "limit": inventory_manager.slot_limit
            }
        }
        
        return inventory_data
        
    except Exception as e:
        logger.error(f"Error retrieving inventory data: {e}", exc_info=True)
        return {"error": f"Error retrieving inventory data: {str(e)}"}

def get_character_stats(game_state: GameState) -> Dict[str, Any]:
    """
    Get character stats data for an LLM agent.
    
    Args:
        game_state: The current game state.
    
    Returns:
        A dictionary containing character stats data.
    """
    logger.info("Retrieving character stats data for LLM agent")
    
    try:
        # Check if stats manager is available (it should be in state_manager)
        from core.base.state import get_state_manager
        
        state_manager = get_state_manager()
        stats_manager = state_manager.stats_manager
        
        if not stats_manager:
            logger.warning("Stats manager not available")
            return {"error": "Stats manager not available"}
        
        # Get basic character info
        character_info = {
            "name": game_state.player.name,
            "race": game_state.player.race,
            "path": game_state.player.path,
            "background": game_state.player.background,
            "level": game_state.player.level,
            "experience": game_state.player.experience,
            "experience_to_next_level": game_state.player.experience_to_next_level,
        }
        
        # Get primary stats
        primary_stats = {}
        
        from core.stats.stats_base import StatType
        for stat_type in StatType:
            stat_value = stats_manager.get_stat_value(stat_type)
            stat_obj = stats_manager.get_stat(stat_type)
            stat_base = stat_obj.base_value if stat_obj else 0
            # Get modifiers from the modifier manager
            mod_values = stats_manager.modifier_manager.get_stat_modifier_value(stat_type)
            stat_mod = mod_values['flat']  # Use flat modifier
            
            primary_stats[stat_type.name] = {
                "value": stat_value,
                "base": stat_base,
                "modifier": stat_mod
            }
        
        # Get derived stats
        derived_stats = {}
        
        from core.stats.stats_base import DerivedStatType
        for stat_type in DerivedStatType:
            # Get the derived stat value (fall back to get_stat_value for consistency)
            stat_value = stats_manager.get_stat_value(stat_type)
            
            derived_stats[stat_type.name] = {
                "value": stat_value
            }
        
        # Get active modifiers
        active_modifiers = []
        
        # Get all modifiers from the modifier manager
        all_modifiers = stats_manager.modifier_manager.modifiers
        for modifier in all_modifiers:
            # The modifier structure might be different than expected, handle safely
            try:
                mod_data = {
                    "stat": str(modifier.stat) if hasattr(modifier, 'stat') else "Unknown",
                    "value": modifier.value if hasattr(modifier, 'value') else 0,
                    "source": str(modifier.source_type) if hasattr(modifier, 'source_type') else str(modifier.source) if hasattr(modifier, 'source') else "Unknown",
                    "duration": modifier.duration if hasattr(modifier, 'duration') else None,
                    "is_permanent": modifier.modifier_type.name == "PERMANENT" if hasattr(modifier, 'modifier_type') else (modifier.duration is None) if hasattr(modifier, 'duration') else True,
                }
            except Exception as e:
                logger.warning(f"Error processing modifier: {e}")
                mod_data = {
                    "stat": "Unknown",
                    "value": 0,
                    "source": "Unknown",
                    "duration": None,
                    "is_permanent": True,
                }
            active_modifiers.append(mod_data)
        
        # Combine all stats data
        stats_data = {
            "character": character_info,
            "primary_stats": primary_stats,
            "derived_stats": derived_stats,
            "active_modifiers": active_modifiers
        }
        
        return stats_data
    
    except Exception as e:
        logger.error(f"Error retrieving character stats data: {e}", exc_info=True)
        return {"error": f"Error retrieving character stats data: {str(e)}"}

def get_quest_data(game_state: GameState) -> Dict[str, Any]:
    """
    Get quest data for an LLM agent from the authoritative journal.

    Returns a dict with active_quests, completed_quests, failed_quests arrays.
    Each quest entry contains id, title, description, status, and objectives
    with minimal fields needed for LLM summaries.
    """
    logger.info("Retrieving quest data for LLM agent (from journal)")

    try:
        journal = getattr(game_state, 'journal', {}) or {}
        quests_map = journal.get('quests', {}) if isinstance(journal, dict) else {}
        
        def classify_status(q: Dict[str, Any]) -> str:
            # Derive status similar to GUI logic
            try:
                status = q.get('status', 'active')
                objectives = q.get('objectives', []) or []
                mandatory_total = sum(1 for o in objectives if o.get('mandatory', True)) or 0
                mandatory_completed = sum(1 for o in objectives if o.get('mandatory', True) and o.get('completed', False))
                any_failed = any(o.get('failed', False) for o in objectives)
                fully_completed = (mandatory_total == mandatory_completed) and not any_failed
                if q.get('abandoned'):
                    return 'failed'
                if fully_completed:
                    return 'completed'
                if status in ('failed','completed','active'):
                    return status
                return 'active'
            except Exception:
                return q.get('status', 'active')
        
        def simplify_quest(qid: str, q: Dict[str, Any]) -> Dict[str, Any]:
            return {
                'id': qid,
                'title': q.get('title', qid),
                'description': q.get('description', ''),
                'status': classify_status(q),
                'objectives': [
                    {
                        'id': o.get('id'),
                        'description': o.get('description', ''),
                        'completed': bool(o.get('completed', False)),
                        'failed': bool(o.get('failed', False)),
                        'mandatory': bool(o.get('mandatory', True)),
                    } for o in (q.get('objectives', []) or [])
                ]
            }
        
        active: list[Dict[str, Any]] = []
        completed: list[Dict[str, Any]] = []
        failed: list[Dict[str, Any]] = []
        
        for qid, q in quests_map.items():
            entry = simplify_quest(qid, q if isinstance(q, dict) else {})
            st = entry['status']
            if st == 'completed':
                completed.append(entry)
            elif st == 'failed':
                failed.append(entry)
            else:
                active.append(entry)
        
        return {
            'active_quests': active,
            'completed_quests': completed,
            'failed_quests': failed,
        }
    except Exception as e:
        logger.error(f"Error retrieving quest data: {e}", exc_info=True)
        return {"error": f"Error retrieving quest data: {str(e)}"}

def get_location_info(game_state: GameState) -> Dict[str, Any]:
    """
    Get location information for an LLM agent.
    
    Args:
        game_state: The current game state.
    
    Returns:
        A dictionary containing location information.
    """
    logger.info("Retrieving location information for LLM agent")
    
    try:
        # Basic location information from player and world state
        location_data = {
            "current_location": game_state.player.current_location,
            "current_district": game_state.player.current_district,
            "time_of_day": game_state.world.time_of_day,
            "weather": game_state.world.weather,
            "is_day": game_state.world.is_day,
        }
        
        # Get game time
        from core.base.game_loop import GameTime
        game_time = GameTime(game_time=game_state.world.game_time)
        
        location_data["game_time"] = {
            "total_seconds": game_state.world.game_time,
            "formatted_time": game_time.get_formatted_time(),
            "day_name": game_time.get_day_name(),
            "hour": game_time.hour,
            "minute": game_time.minute,
            "second": game_time.second
        }
        
        return location_data
    
    except Exception as e:
        logger.error(f"Error retrieving location information: {e}", exc_info=True)
        return {"error": f"Error retrieving location information: {str(e)}"}

def get_calendar_info(game_state: GameState) -> Dict[str, Any]:
    """
    Get canonical calendar information for an LLM agent.

    Returns a dict with canonical fields (era, cycle, phase, tide, span, day),
    compact string, human-readable string, narrative period, and game time seconds.
    """
    logger.info("Retrieving calendar information for LLM agent")
    try:
        w = getattr(game_state, 'world', None)
        if not w:
            return {"error": "World state not available"}
        cal = getattr(w, 'calendar', None)
        cal_dict = cal.to_dict() if hasattr(cal, 'to_dict') else {}
        data = {
            **cal_dict,
            "compact": getattr(w, 'calendar_compact', None),
            "string": getattr(w, 'calendar_string', None),
            "narrative_period": getattr(w, 'time_of_day', None),
            "game_time_seconds": float(getattr(w, 'game_time', 0.0) or 0.0),
        }
        return data
    except Exception as e:
        logger.error(f"Error retrieving calendar info: {e}", exc_info=True)
        return {"error": f"Error retrieving calendar info: {str(e)}"}


def process_data_retrieval_command(command: str, args: str, game_state: GameState) -> Dict[str, Any]:
    """
    Process a data retrieval command.
    
    Args:
        command: The command name (e.g., GET_INVENTORY).
        args: Command arguments (if any).
        game_state: The current game state.
    
    Returns:
        Retrieved data as a dictionary.
    """
    logger.info(f"Processing data retrieval command: {command}")
    
    # Map commands to handler functions
    command_handlers = {
        "GET_INVENTORY": get_inventory_data,
        "GET_STATS": get_character_stats,
        "GET_QUESTS": get_quest_data,
        "GET_LOCATION_INFO": get_location_info,
        "GET_CALENDAR_INFO": get_calendar_info,
        "GET_WORLD_CALENDAR": get_calendar_info,
    }
    
    # Get handler function
    handler = command_handlers.get(command)
    
    if not handler:
        logger.warning(f"Unknown data retrieval command: {command}")
        return {"error": f"Unknown data retrieval command: {command}"}
    
    # Call the handler function
    result = handler(game_state)
    
    return result

```

### File: core\agents\narrator.py

```python
#!/usr/bin/env python3
"""
Narrator agent for generating game narrative and identifying actions.

This module provides a NarratorAgent class that generates narrative
text based on player input, game state, and context information.
It also identifies potential skill checks or state changes requested
by the player's natural language input and outputs them in a
structured format.
"""

import os
import re
import json
from typing import Dict, List, Optional, Any, Tuple, Union
import logging

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext # Keep AgentContext, remove AgentResponse if not used
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode

# Get the module logger
logger = get_logger("AGENT")

class NarratorAgent(BaseAgent):
    """
    Narrator agent for generating game narrative and identifying actions.

    This agent generates narrative text based on player input, game state,
    and context information. When the game mode is NARRATIVE, it analyzes
    player input to identify implicit requests for skill checks or state
    changes, outputting these alongside the narrative in a structured format.
    """
    
    # Define the commands that this agent supports
    SUPPORTED_COMMANDS = [
        "DESCRIBE_LOCATION",
        "NARRATE_ACTION",
        "DESCRIBE_NPC",
        "NARRATE_DIALOGUE",
        "DESCRIBE_ITEM",
        "NARRATE_DISCOVERY"
    ]

    def __init__(self):
        """Initialize the narrator agent."""
        super().__init__("Narrator")
        logger.info(f"NarratorAgent initialized with {len(self.SUPPORTED_COMMANDS)} supported commands: {', '.join(self.SUPPORTED_COMMANDS)}")
        
    def reset(self) -> None:
        """No persistent state to reset, provided for interface consistency."""
        logger.info("Narrator agent reset (no state)")

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the narrator agent.
        """
        # --- Context Extraction (same as before) ---
        player_name = context.player_state.get("name", "Unknown")
        player_race = context.player_state.get("race", "Human")
        player_path = context.player_state.get("path", "Wanderer")
        player_background = context.player_state.get("background", "Commoner")
        player_location = context.player_state.get("current_location", "Unknown")
        player_district = context.player_state.get("current_district", "Unknown")
        player_id = context.player_state.get("id", "player")

        world_time = context.world_state.get("time_of_day", "Unknown")
        world_weather = context.world_state.get("weather", "Clear")
        is_day = context.world_state.get("is_day", True)
        day_night = "day" if is_day else "night"
        # Internal exact time (do not reveal to player)
        exact_game_time = context.world_state.get("exact_game_time", "Unknown")

        current_mode = context.game_state.get("mode", "NARRATIVE")
        mode_display = current_mode if isinstance(current_mode, str) else \
                    current_mode.name if hasattr(current_mode, 'name') else "NARRATIVE"

        # --- Stamina Regeneration Note ---
        stamina_note_for_prompt = ""
        if context.additional_context and "player_stamina_status" in context.additional_context:
            stamina_note_for_prompt = f"\n        - System Note: {context.additional_context['player_stamina_status']}"

        # --- Refined Prompt with JSON Emphasis ---
        system_prompt = f"""You are the Narrator, an AI game master for a text-based RPG. Your role is to create immersive narrative based on player input and game state.

        ## Current Game State
        - Player ID: {player_id}
        - Player: {player_name} the {player_race} {player_path} ({player_background})
        - Location: {player_location}, {player_district}
        - Time: {world_time} ({day_night})
        - Weather: {world_weather}
        - Current Interaction Mode: {mode_display}{stamina_note_for_prompt}
        - Exact Game Time (internal): {exact_game_time}
        - Calendar (internal): {context.world_state.get('calendar', '')}

        ## Your Responsibilities
        1. Generate vivid narrative responses to player actions.
        2. Maintain world lore and character consistency.
        3. **CRITICAL (Especially in NARRATIVE Mode):** Analyze the player's natural language input. Identify actions implying skill checks (e.g., "I try to pick the lock"), state changes (e.g., "I drink the potion"), or **MODE TRANSITIONS** (e.g., "I attack the guard", "I want to trade").
        4. **Output JSON:** Your *ENTIRE* response MUST be a single, valid JSON object adhering *exactly* to the `AgentOutput` structure below. NO extra text, explanations, or markdown formatting outside the JSON.

        ## Required Output Format (JSON Object Only)
        ```json
        {{
        "narrative": "Your descriptive text about the situation and the player's attempted action goes here. Describe the lead-up to any requested checks or state changes.",
        "time_passage": "1m",
        "requests": [
            {{
            "action": "request_skill_check",
            "actor_id": "{player_id}",
            "skill_name": "LOCKPICKING",
            "stat_name": "DEXTERITY",
            "target_actor_id": null,
            "difficulty_class": 14,
            "modifiers": {{}},
            "context": "Player attempting to pick the chest lock."
            }},
            {{
            "action": "request_state_change",
            "target_entity": "{player_id}",
            "attribute": "stamina",
            "change_type": "add",
            "value": 5,
            "context": "Player recovered some stamina after a brief rest."
            }},
            {{
            "action": "request_mode_transition",
            "target_mode": "COMBAT",
            "origin_mode": "NARRATIVE",
            "reason": "Player initiated attack on guard.",
            "target_entity_id": "guard_1",
            "surprise": false,
            "enemy_template": "beast_easy_base",
            "enemy_count": 1,
            "enemy_level": 1,
            "spawn_hints": {{
              "actor_type": "beast",
              "threat_tier": "easy",
              "species_tags": ["wolf"],
              "role_hint": "skirmisher",
              "is_boss": false,
              "overlay": null
            }},
            "additional_context": {{
              "original_intent": "I lunge at the wolf and start a fight."
            }}
            }},
            {{
            "action": "request_state_change",
            "target_entity": "{player_id}",
            "attribute": "inventory",
            "change_type": "add",
            "item_template": "test_apple",
            "quantity": 1,
            "context": "Player picks up an apple and puts it in the backpack."
            }},
            {{
            "action": "request_data_retrieval",
            "data_type": "inventory"
            }},
            {{
            "action": "request_quest_update",
            "quest_id": "the-first-exchange",
            "objective_id": "step-2",
            "new_status": "completed",
            "confidence": 0.85,
            "evidence": [
              {{ "type": "flag", "key": "elder.message_deciphered" }},
              {{ "type": "dialogue", "id": "elder_03_line_17" }}
            ]
            }},
            {{
            "action": "request_quest_status",
            "quest_id": "the-first-exchange",
            "new_status": "abandoned",
            "confidence": 0.9,
            "evidence": [ {{ "type": "flag", "key": "player.abandon_confirmed" }} ]
            }}
        ]
        }}
        ```
        
        Evidence items should reference concrete signals (flags, dialogue ids, interaction ids). Do not propose quest status changes that contradict objective-level logic; prefer proposing objective updates. Never invent quest or objective IDs.

        ## Guidelines
        - **Time Passage (MANDATORY):** Always include a compact `time_passage` value (e.g., "30s", "1m", "2h", "1d") representing the approximate time elapsed since the last user input. If uncertain, default to "1m". Do not omit this field.
        - **Time Disclosure Policy:** Do not reveal numeric clock times to the player. Use only named periods (dawn, morning, noon, afternoon, evening, sunset, night, deep night). The "Exact Game Time (internal)" is for reasoning only.
        - **NARRATIVE Mode Focus:** When mode is NARRATIVE, actively look for intents requiring skill checks, state changes, or mode transitions.
        - **Inventory Changes (CRITICAL):** When the player gives, offers, drops, leaves behind, discards, sacrifices, or consumes an item, include a `request_state_change` with `attribute: "inventory"`.
          • Prefer `template_id` if known; otherwise use `item_id` (when present) or `item_name`.
          • Use `change_type: "remove"` for removals; include `quantity`.
          • Example: {{"action":"request_state_change","target_entity":"{player_id}","attribute":"inventory","change_type":"remove","template_id":"ritual_dagger","quantity":1,"context":"Player offers the dagger to the Elder as part of the ritual."}}
        - **Stamina Regeneration (NARRATIVE Mode):** If the 'System Note' indicates player stamina is not full, evaluate if context (time passed, player actions) warrants regeneration. If yes, include a `request_state_change` for 'stamina' with a positive 'value' and narrate briefly (e.g., "You feel somewhat refreshed."). If not appropriate, omit this request.
        - **Mode Transitions:** If player input clearly initiates combat ("attack", "fight"), trade ("trade", "buy", "sell"), or social conflict ("confront", "intimidate"), YOU MUST include a `request_mode_transition` in the `requests` list.
        - **Spawn Hints for COMBAT (Optional):** When requesting COMBAT, include a compact spawn specification only if needed:
          * Prefer setting `enemy_template` to a known family/variant id (e.g., `beast_easy_base`, `verdant_alpha`).
          * If you do not know a valid id, include `spawn_hints` with `actor_type`, `threat_tier`, and optional `species_tags`, `role_hint`, `is_boss`, `overlay`.
          * Also include `additional_context.original_intent` containing the exact natural language phrase that triggered combat.
          * Keep this section minimal and structured; do not dump lists or catalogs.
        - **Skill Checks:** Identify verbs implying effort/uncertainty ("try", "attempt", "search", "sneak", "persuade"). Infer the skill (e.g., `LOCKPICKING`, `PERCEPTION`, `STEALTH`, `PERSUASION`). Use `skill_name` from the available skill list.
        - **State Changes:** Identify direct actions ("drink potion", "give item", "pull lever"). Infer target, attribute, change type, value.
        - **Data Retrieval:** Only use `request_data_retrieval` if the player *explicitly asks* for their stats, inventory, quests, etc. Do not guess. If used, the `narrative` should usually be empty or very brief (e.g., "Checking your inventory...").
        - **Narrative First:** Always provide narrative, describing the attempt or situation leading to requests. Do not determine success/failure in narrative.
        - **Environment:** Incorporate environmental tags (from context, if provided) into descriptions and consider them for checks (e.g., taking cover).
        - **Consistency & Fairness:** Maintain world/character consistency. Be descriptive but reasonably concise. Avoid explicit/harmful content.

        ### Final Checklist (before you output JSON)
        1) Did the input imply a skill check? If yes, add `request_skill_check`.
        2) Did the input imply an inventory change? If yes, add `request_state_change` with `attribute: "inventory"`.
        3) Did the input imply a mode transition (combat/trade/social)? If yes, add `request_mode_transition`.
        4) Did the player explicitly ask to list stats/inventory/quests? If yes, add `request_data_retrieval`.
        5) Keep the narrative concise (2–5 sentences) and complete the immediate outcome.

        Respond to the player's input by generating the required JSON `AgentOutput` object ONLY.
        """
        return system_prompt


    def _format_memories(self, context: AgentContext) -> str:
        """
        Format memory context specifically for the narrator.

        Args:
            context: The agent context.

        Returns:
            Formatted memory context string.
        """
        if not context.relevant_memories or not self._settings.get("include_memories", True):
            return ""

        memory_lines = ["## Relevant Background Information"]

        # Categorize memories
        location_memories = []
        character_memories = []
        quest_memories = []
        other_memories = []

        # Get the max number of entries to include
        max_entries = self._settings.get("max_memory_entries", 10)

        # Sort memories by importance
        sorted_memories = sorted(
            context.relevant_memories[:max_entries],
            key=lambda m: m.get("importance", 0),
            reverse=True
        )

        # Categorize and format each memory entry
        for memory in sorted_memories:
            content = memory.get("content", "")
            memory_type = memory.get("type", "general")

            formatted_memory = f"- {content}"

            if memory_type == "location":
                location_memories.append(formatted_memory)
            elif memory_type == "character":
                character_memories.append(formatted_memory)
            elif memory_type == "quest":
                quest_memories.append(formatted_memory)
            else:
                other_memories.append(formatted_memory)

        # Add categorized memories to the output
        if location_memories:
            memory_lines.append("### Locations")
            memory_lines.extend(location_memories)

        if character_memories:
            memory_lines.append("### Characters")
            memory_lines.extend(character_memories)

        if quest_memories:
            memory_lines.append("### Quests")
            memory_lines.extend(quest_memories)

        if other_memories:
            memory_lines.append("### Other Information")
            memory_lines.extend(other_memories)

        return "\n".join(memory_lines)

    def _format_character_stats(self, context: AgentContext) -> str:
        """
        Format character stats information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted character stats string.
        """
        stats = context.additional_context.get("character_stats", {}) if context.additional_context else {}
        if not stats:
            return ""

        lines = ["## Character Stats"]

        # Check for error message
        if "error" in stats:
            lines.append(f"Error retrieving character stats: {stats['error']}")
            return "\n".join(lines)

        # Format character info
        character = stats.get("character", {})
        if character:
            lines.append("### Character Information")
            lines.append(f"- Name: {character.get('name', 'Unknown')}")
            lines.append(f"- Race: {character.get('race', 'Unknown')}")
            lines.append(f"- Class/Path: {character.get('path', 'Unknown')}")
            lines.append(f"- Background: {character.get('background', 'Unknown')}")
            lines.append(f"- Level: {character.get('level', 1)}")
            lines.append(f"- Experience: {character.get('experience', 0)}/{character.get('experience_to_next_level', 100)}")

        # Format primary stats
        primary_stats = stats.get("primary_stats", {})
        if primary_stats:
            lines.append("### Primary Stats")
            for stat_name, stat_info in primary_stats.items():
                value = stat_info.get("value", 0)
                base = stat_info.get("base", 0)
                modifier = stat_info.get("modifier", 0)

                mod_str = f"+{modifier}" if modifier > 0 else str(modifier) if modifier < 0 else ""
                base_str = f" (Base: {base}{f', Mod: {mod_str}' if mod_str else ''})" if base != value else ""

                lines.append(f"- {stat_name}: {value}{base_str}")

        # Format derived stats
        derived_stats = stats.get("derived_stats", {})
        if derived_stats:
            lines.append("### Derived Stats")
            for stat_name, stat_info in derived_stats.items():
                value = stat_info.get("value", 0)
                lines.append(f"- {stat_name}: {value}")

        # Format skills (if available)
        skills = stats.get("skills", {})
        if skills:
            lines.append("### Skills")
            for skill_name, skill_info in skills.items():
                 value = skill_info.get("value", 0)
                 lines.append(f"- {skill_name.title()}: {value}")


        # Format active modifiers
        active_modifiers = stats.get("active_modifiers", [])
        if active_modifiers:
            lines.append("### Active Modifiers")
            for mod in active_modifiers:
                stat = mod.get("stat", "Unknown")
                value = mod.get("value", 0)
                source = mod.get("source", "Unknown")
                duration = mod.get("duration", "")
                is_permanent = mod.get("is_permanent", False)

                duration_str = "Permanent" if is_permanent else f"Duration: {duration}s" if duration else ""
                lines.append(f"- {stat} {value:+g} from {source} ({duration_str})")

        return "\n".join(lines)

    def _format_quests(self, context: AgentContext) -> str:
        """
        Format quest information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted quest information string.
        """
        quests = context.additional_context.get("quests", {}) if context.additional_context else {}
        if not quests:
            return ""

        lines = ["## Quests"]

        # Check for error message
        if "error" in quests:
            lines.append(f"Error retrieving quest data: {quests['error']}")
            return "\n".join(lines)

        # Format active quests
        active_quests = quests.get("active_quests", [])
        lines.append("### Active Quests")
        if not active_quests:
            lines.append("- No active quests")
        else:
            for quest in active_quests:
                if isinstance(quest, dict):
                    quest_name = quest.get("title") or quest.get("name", "Unknown Quest")
                    quest_desc = quest.get("description", "")
                    quest_status = quest.get("status", "In Progress")
                    lines.append(f"- {quest_name} ({quest_status})")
                    if quest_desc:
                        lines.append(f"  {quest_desc}")
                else:
                    lines.append(f"- {quest}")

        # Format completed quests
        completed_quests = quests.get("completed_quests", [])
        lines.append("\n### Completed Quests")
        if not completed_quests:
            lines.append("- No completed quests")
        else:
            for quest in completed_quests:
                if isinstance(quest, dict):
                    quest_name = quest.get("title") or quest.get("name", "Unknown Quest")
                    lines.append(f"- {quest_name}")
                else:
                    lines.append(f"- {quest}")

        # Format failed quests
        failed_quests = quests.get("failed_quests", [])
        lines.append("\n### Failed Quests")
        if not failed_quests:
            lines.append("- No failed quests")
        else:
            for quest in failed_quests:
                if isinstance(quest, dict):
                    quest_name = quest.get("title") or quest.get("name", "Unknown Quest")
                    lines.append(f"- {quest_name}")
                else:
                    lines.append(f"- {quest}")

        return "\n".join(lines)

    def _format_location_info(self, context: AgentContext) -> str:
        """
        Format location information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted location information string.
        """
        location_info = context.additional_context.get("location_info", {}) if context.additional_context else {}
        if not location_info:
            return ""

        lines = ["## Current Location & Environment"]

        # Check for error message
        if "error" in location_info:
            lines.append(f"Error retrieving location information: {location_info['error']}")
            return "\n".join(lines)

        # Basic location information
        lines.append(f"- Location: {location_info.get('current_location', 'Unknown')}")
        lines.append(f"- District/Area: {location_info.get('current_district', 'Unknown')}")

        # Time and weather information
        # Format game time
        game_time = location_info.get("game_time", {})
        if game_time:
            formatted_time = game_time.get("formatted_time", "Unknown time")
            day_name = game_time.get("day_name", "")
            time_str = formatted_time
            if day_name:
                time_str = f"{day_name}, {time_str}"
            lines.append(f"- Time: {time_str}")

        # Weather and time of day
        lines.append(f"- Time of Day: {location_info.get('time_of_day', 'Unknown')}")
        lines.append(f"- Weather: {location_info.get('weather', 'Unknown')}")
        lines.append(f"- Daylight: {'Day' if location_info.get('is_day', True) else 'Night'}")

        # Add nearby interactables/entities if available
        nearby = location_info.get("nearby_entities", [])
        if nearby:
            lines.append("### Nearby")
            for entity in nearby:
                 lines.append(f"- {entity.get('name', 'Unknown Entity')} ({entity.get('type', 'object')})")


        return "\n".join(lines)

    def _format_inventory(self, context: AgentContext) -> str:
        """
        Format inventory information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted inventory string.
        """
        inventory = context.additional_context.get("inventory", {}) if context.additional_context else {}
        if not inventory:
            return ""

        lines = ["## Current Inventory"]

        # Check for error message
        if "error" in inventory:
            lines.append(f"Error retrieving inventory data: {inventory['error']}")
            return "\n".join(lines)

        # Format equipped items
        equipped = inventory.get("equipped", {})
        if equipped:
            lines.append("### Equipped Items")
            if not equipped:
                lines.append("- Nothing equipped.")
            else:
                for slot, item in equipped.items():
                    if isinstance(item, dict):
                        item_name = item.get("name", "Unknown Item")
                        item_stats = item.get("stats", [])
                        stats_str = ", ".join(f"{stat['name']}: {stat['value']}" for stat in item_stats) if item_stats else ""
                        lines.append(f"- {slot.title()}: {item_name} {f'({stats_str})' if stats_str else ''}")
                    elif item: # Handle cases where it might be just the item name/ID
                         lines.append(f"- {slot.title()}: {item}")
                    # else: # Don't list empty slots explicitly unless needed
                    #    lines.append(f"- {slot.title()}: None")

        # Format backpack items
        backpack = inventory.get("backpack", [])
        lines.append("### Backpack")
        if not backpack:
            lines.append("- Backpack is empty.")
        else:
            # Group items by type
            items_by_type = {}
            for item in backpack:
                if isinstance(item, dict):
                    item_type = item.get("type", "Miscellaneous").title()
                    if item_type not in items_by_type:
                        items_by_type[item_type] = []
                    items_by_type[item_type].append(item)

            # Display items by type
            for item_type, items in items_by_type.items():
                lines.append(f"#### {item_type}")
                for item in items:
                    item_name = item.get("name", "Unknown Item")
                    item_rarity = item.get("rarity", "")
                    item_quantity = item.get("quantity", 1)
                    quantity_str = f" (x{item_quantity})" if item_quantity > 1 else ""
                    rarity_str = f" ({item_rarity})" if item_rarity else ""
                    lines.append(f"- {item_name}{quantity_str}{rarity_str}")

        # Format currency
        currency = inventory.get("currency", {})
        if currency:
            gold = currency.get("gold", 0)
            silver = currency.get("silver", 0)
            copper = currency.get("copper", 0)
            lines.append(f"### Currency: {gold}g {silver}s {copper}c")

        # Format inventory limits
        weight = inventory.get("weight", {})
        slots = inventory.get("slots", {})
        if weight or slots:
            lines.append("### Inventory Limits")
            if weight:
                current_weight = weight.get("current", 0)
                weight_limit = weight.get("limit", 0)
                lines.append(f"- Weight: {current_weight:.1f}/{weight_limit:.1f}")
            if slots:
                used_slots = slots.get("used", 0)
                slot_limit = slots.get("limit", 0)
                lines.append(f"- Slots: {used_slots}/{slot_limit}")

        return "\n".join(lines)


    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        """
        messages = []
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        # Verify time_passage directive presence in prompt
        try:
            directive_present = ("Time Passage (MANDATORY)" in system_prompt) or ("time_passage" in system_prompt)
            logger.info(f"[LLM_PROMPT_POLICY] time_passage_directive_present={directive_present}")
        except Exception:
            pass

        # Add conversation history
        history_messages = self._format_conversation_history(context)
        messages.extend(history_messages)

        # Prepare user message parts
        user_message_parts = []
        if context.context_summary: user_message_parts.append(f"## Summary\n{context.context_summary}")
        memory_context = self._format_memories(context)
        if memory_context: user_message_parts.append(memory_context)

        # Add formatted context data ONLY if specifically requested or highly relevant
        # Avoid overloading the prompt by default in Narrative mode unless needed
        # Inventory
        if "inventory" in context.player_input.lower():
             inventory_info = self._format_inventory(context)
             if inventory_info: user_message_parts.append(inventory_info)
        # Stats
        if any(kw in context.player_input.lower() for kw in ["stat", "skill", "ability", "can i"]):
             stats_info = self._format_character_stats(context)
             if stats_info: user_message_parts.append(stats_info)
        # Quests: include when user mentions quests, or when additional_context already includes quests
        if ("quest" in context.player_input.lower()) or (context.additional_context and context.additional_context.get("quests")):
             quests_info = self._format_quests(context)
             if quests_info: user_message_parts.append(quests_info)

        # Always add basic location info
        location_info = self._format_location_info(context)
        if location_info: user_message_parts.append(location_info)
        # Explicitly add environment tags
        environment_tags = context.additional_context.get("environment", []) if context.additional_context else []
        if environment_tags: user_message_parts.append(f"### Environment Tags: {', '.join(environment_tags)}")


        # Add the actual player input
        user_message_parts.append("## Player Input")
        user_message_parts.append(context.player_input)

        final_user_message = "\n\n".join(user_message_parts)
        messages.append({"role": "user", "content": final_user_message})

        logger.debug(f"Prepared messages for NarratorAgent:\nSystem Prompt Length: {len(system_prompt)}\nUser Message Length: {len(final_user_message)}")
        # logger.debug(f"Full User Message:\n{final_user_message}") # Uncomment for detailed debugging

        return messages

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a request with the narrator agent, expecting JSON output.
        """
        mode = context.game_state.get("mode", "N/A")
        logger.info(f"Processing request with Narrator agent. Mode: {mode}, Intent: '{context.player_input[:50]}...'")

        messages = self._prepare_messages(context)
        agent_output: Optional[AgentOutput] = None

        try:
            # --- LLM Call ---
            effective_model = self._model or None
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=effective_model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1500), # Use setting
                timeout=self._settings.get("timeout_seconds", 45) # Use setting
            )
            if not llm_response or not llm_response.content:
                raise ValueError("LLM returned empty content.")

            llm_response_content = llm_response.content.strip()
            logger.debug(f"Raw LLM Response (Narrator):\n```\n{llm_response_content}\n```")

            # --- Enhanced JSON Parsing ---
            parsed_output = None
            cleaned_response = llm_response_content
            try:
                 # 1. Remove potential markdown fences first
                cleaned_response = re.sub(r'^```(?:json)?\s*|\s*```$', '', cleaned_response, flags=re.MULTILINE).strip()

                # 2. Try direct parsing
                parsed_output = json.loads(cleaned_response)
                logger.debug("Successfully parsed JSON directly.")

            except json.JSONDecodeError as e:
                logger.warning(f"Narrator initial JSON parsing failed: {e}. Trying to extract JSON object...")
                # 3. If direct parsing fails, try to find the first '{' and last '}'
                start_index = cleaned_response.find('{')
                end_index = cleaned_response.rfind('}')
                if start_index != -1 and end_index != -1 and start_index < end_index:
                    json_substring = cleaned_response[start_index : end_index + 1]
                    try:
                        parsed_output = json.loads(json_substring)
                        logger.info("Successfully parsed extracted JSON substring from Narrator response.")
                    except json.JSONDecodeError as e_inner:
                        logger.error(f"Narrator failed to parse extracted JSON substring: {e_inner}")
                        logger.error(f"Substring attempted: ```\n{json_substring}\n```")
                        parsed_output = None
                else:
                    logger.error("Narrator could not find valid JSON object markers '{' and '}' in the response.")
                    parsed_output = None

            # --- Validate Structure and Build Output ---
            if (isinstance(parsed_output, dict) and
                "narrative" in parsed_output and
                "requests" in parsed_output and
                isinstance(parsed_output["requests"], list)):

                # Validate requests format (basic check)
                validated_requests = []
                for req in parsed_output["requests"]:
                    if isinstance(req, dict) and "action" in req:
                        validated_requests.append(req)
                    else:
                        logger.warning(f"Narrator skipping invalid request structure: {req}")

                agent_output = {
                    "narrative": parsed_output["narrative"],
                    "requests": validated_requests
                }
                narrative_snippet = parsed_output["narrative"][:100]
                logger.info(f"Narrator successfully parsed valid JSON. Narrative: '{narrative_snippet}...', Requests: {len(validated_requests)}")

            else: # Parsing failed or structure invalid
                logger.error("Narrator failed to parse LLM response as valid JSON AgentOutput.")
                # Fallback: Treat the whole response as narrative if parsing fails
                agent_output = {
                    "narrative": llm_response_content, # Use the raw content as narrative
                    "requests": [] # No requests could be parsed
                }
                logger.warning("Narrator using raw response as narrative due to JSON parsing failure.")


        except Exception as e:
            logger.exception(f"Error during NarratorAgent processing or LLM call: {e}")
            # Fallback: Provide an error narrative
            agent_output = {
                "narrative": f"[Narrator Error: An unexpected error occurred: {e}]",
                "requests": []
            }

        # Log final decision
        if agent_output:
             logger.info(f"Narrator final output generated with {len(agent_output['requests'])} requests.")
        else:
             # This case should ideally not be reached due to fallbacks, but log just in case
             logger.error("Narrator failed to generate any output structure.")
             agent_output = { "narrative": "[System Error: Narrator failed completely.]", "requests": [] }

        return agent_output

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a request with the narrator agent.

        Calls the LLM, parses the expected JSON output, and returns it.

        Args:
            context: The agent context.

        Returns:
            An AgentOutput dictionary containing narrative and structured requests.
        """
        logger.info(f"Processing request with Narrator agent in mode: {context.game_state.get('mode', 'N/A')}")

        messages = self._prepare_messages(context)

        # --- LLM Call ---
        try:
            # Use the LLM manager from BaseAgent with proper parameters
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=self._model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1000),
                timeout=self._settings.get("timeout_seconds", 30)
            )
            if not llm_response or not llm_response.content:
                raise ValueError("LLM returned empty content.")
            llm_response_content = llm_response.content
            logger.debug(f"Raw LLM Response:\n{llm_response_content}")

            # --- Response Parsing ---
            # The LLM might return a mix of text and JSON, or just the JSON
            # We need to try multiple parsing strategies
            try:
                # First try: Look for JSON code block
                json_match = re.search(r'```(?:json)?\s*({.*?})\s*```', llm_response_content, re.DOTALL)
                if json_match:
                    # Extract JSON from code block
                    cleaned_response = json_match.group(1).strip()
                    logger.debug(f"Found JSON in code block: {cleaned_response[:100]}...")
                else:
                    # Second try: See if the entire response is JSON
                    if llm_response_content.strip().startswith('{'):
                        cleaned_response = llm_response_content.strip()
                        logger.debug("Response appears to be raw JSON")
                    else:
                        # Third try: Look for JSON anywhere in the text
                        # More robust pattern that handles nested structures better
                        json_pattern = r'({\s*"narrative"\s*:.+?"requests"\s*:\s*\[.*?\]\s*})'
                        json_match = re.search(json_pattern, llm_response_content, re.DOTALL)
                        if json_match:
                            cleaned_response = json_match.group(1).strip()
                            logger.debug(f"Found JSON pattern in response: {cleaned_response[:100]}...")
                        else:
                            # Final fallback: Treat the whole text as narrative with no requests
                            logger.warning("No JSON found in response. Treating entire text as narrative.")
                            return {
                                "narrative": llm_response_content.strip(),
                                "requests": []
                            }
                
                # Parse the extracted JSON
                try:
                    # Log the cleaned response for debugging
                    logger.debug(f"Attempting to parse JSON: {cleaned_response[:100]}... (length: {len(cleaned_response)})")
                    parsed_output = json.loads(cleaned_response)
                    logger.debug("Successfully parsed JSON")
                except json.JSONDecodeError as json_err:
                    # One more attempt: Try to sanitize quotes and escape characters
                    sanitized_json = re.sub(r'(?<!\\)\\\'', '\'', cleaned_response)  # Fix escaped single quotes
                    sanitized_json = re.sub(r'(?<!\\)\\"', '"', sanitized_json)  # Fix escaped double quotes
                    parsed_output = json.loads(sanitized_json)

                # Validate basic structure
                if not isinstance(parsed_output, dict) or \
                "narrative" not in parsed_output or \
                "requests" not in parsed_output or \
                not isinstance(parsed_output["requests"], list):
                    raise ValueError("LLM response is not a valid AgentOutput JSON structure.")

                # Basic validation of request structures (can be expanded)
                validated_requests = []
                for req in parsed_output["requests"]:
                    if not isinstance(req, dict) or "action" not in req:
                        logger.warning(f"Skipping invalid request structure: {req}")
                        continue
                    # Add more specific validation per action type if needed
                    validated_requests.append(req)

                agent_output: AgentOutput = {
                    "narrative": parsed_output.get("narrative", "Error: Narrative missing from LLM response."),
                    "requests": validated_requests
                }

            except json.JSONDecodeError as e:
                logger.warning(f"Narrator: JSON decode failed; using raw text as narrative. Error: {e}")
                # Fallback: Treat the whole response as narrative, no requests
                agent_output: AgentOutput = {
                    "narrative": llm_response_content.strip(),
                    "requests": []
                }
            except ValueError as e:
                logger.warning(f"Narrator: Invalid AgentOutput structure; using raw text as narrative. Error: {e}")
                agent_output: AgentOutput = {
                    "narrative": (parsed_output.get('narrative', llm_response_content).strip() if isinstance(parsed_output, dict) else str(llm_response_content).strip()),
                    "requests": []
                }


        except Exception as e:
            logger.exception(f"Error during NarratorAgent processing or LLM call: {e}")
            agent_output: AgentOutput = {
                "narrative": f"[Narrator Error: An unexpected error occurred during processing: {e}]",
                "requests": []
            }

        # --- RuleChecker Integration Point (Placeholder) ---
        # In Phase B3, the core loop would take agent_output["requests"]
        # and pass them to the RuleCheckerAgent for validation before
        # executing skill checks or state changes.
        # Example:
        # validated_requests = self.rule_checker.validate(agent_output["requests"], context)
        # agent_output["requests"] = validated_requests
        logger.info(f"Narrator generated {len(agent_output['requests'])} requests.")
        # Log request types for debugging
        request_types = [req.get('action', 'unknown') for req in agent_output.get('requests', []) if isinstance(req, dict)]
        logger.info(f"Request types generated: {request_types}")
        if 'request_mode_transition' in request_types:
            mode_transitions = [req for req in agent_output.get('requests', []) if isinstance(req, dict) and req.get('action') == 'request_mode_transition']
            logger.info(f"Mode transition requests detected: {json.dumps(mode_transitions, indent=2)}")
        # logger.debug(f"Narrator Output: {agent_output}") # Be careful logging potentially large outputs

        return agent_output

    def supports_command(self, command: str) -> bool:
        """
        Check if this agent supports a specific command.
        Args: Command: The command name.
        Returns: True if the agent supports the command, False otherwise.
        """
        is_supported = command.upper() in self.SUPPORTED_COMMANDS
        logger.debug(f"NarratorAgent.supports_command check for '{command}': {is_supported}")
        return is_supported


# Convenience function
def get_narrator_agent() -> NarratorAgent:
    """Get the narrator agent instance."""
    # In a real app, LLM service would be injected here
    # For now, assume BaseAgent handles it or it's set elsewhere
    return NarratorAgent()

```

### File: core\agents\rule_checker.py

```python
#!/usr/bin/env python3
"""
Rule checker agent for validating player actions.

This module provides a RuleCheckerAgent class that validates player
actions against game rules, prevents cheating, and ensures game fairness.
"""

import os
import re
import json
import hashlib
from typing import Dict, List, Optional, Any, Tuple, Set
import logging

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext, AgentResponse

# Get the module logger
logger = get_logger("AGENT")

class RuleCheckerAgent(BaseAgent):
    """
    Rule checker agent for validating player actions.
    
    This agent validates player actions against game rules, provides feedback
    on invalid actions, and implements anti-cheat measures to ensure a fair
    and balanced game experience.
    """
    
    # Command types that can be validated
    SUPPORTED_COMMANDS = [
        "ACTION_VALIDATE", "COMBAT_VALIDATE", "LOOT_VALIDATE",
        "QUEST_VALIDATE", "RULE_QUERY", "ANTICHEAT_CHECK",
        "STAT_CHECK", "RULE_CHECK"
    ]
    
    def __init__(self, entity_manager=None, item_manager=None, stats_manager=None, world_manager=None):
        """Initialize the rule checker agent."""
        super().__init__("rule_checker")
        
        # Store the managers passed from the engine
        self._entity_manager = entity_manager
        self._item_manager = item_manager
        self._stats_manager = stats_manager
        self._world_manager = world_manager
        
        # Track entities that have already been looted
        self._looted_entities: Set[str] = set()
        
        # Track time-limited events that have been completed
        self._completed_events: Dict[str, float] = {}
        
        # Track action history for anti-cheat detection
        self._action_history: List[Dict[str, Any]] = []

    def reset(self) -> None:
        """Reset in-memory caches and histories so no state leaks between sessions."""
        try:
            if hasattr(self, "_looted_entities") and isinstance(self._looted_entities, set):
                self._looted_entities.clear()
            else:
                self._looted_entities = set()
            if hasattr(self, "_completed_events") and isinstance(self._completed_events, dict):
                self._completed_events.clear()
            else:
                self._completed_events = {}
            if hasattr(self, "_action_history") and isinstance(self._action_history, list):
                self._action_history.clear()
            else:
                self._action_history = []
            logger.info("RuleChecker agent state reset")
        except Exception:
            # Fall back to reinitializing the containers
            self._looted_entities = set()
            self._completed_events = {}
            self._action_history = []
            logger.info("RuleChecker agent state reset (containers reinitialized)")
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the rule checker agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The system prompt string.
        """
        system_prompt = """You are the RuleChecker, an AI responsible for validating player actions against game rules and preventing cheating. Your role is to ensure fair play while maintaining immersion.

## Your Responsibilities
1. Validate player actions against game rules and mechanics
2. Identify and prevent exploits and cheating
3. Provide clear feedback when actions are invalid
4. Ensure consistent application of rules
5. Track entities that have been looted to prevent double-looting
6. Monitor time-limited events to prevent replaying
7. Analyze patterns of behavior for potential cheating

## Key Rules to Enforce
- **Physics and Realism**: Actions must be physically possible within the game world
- **Character Capabilities**: Actions must be within the character's abilities
- **Resource Limits**: Players cannot exceed inventory weight, size limits, or currency caps
- **Consequence Consistency**: Similar actions should have similar consequences
- **Anti-Exploitation**: Prevent looting the same entity multiple times
- **Time Integrity**: Prevent replaying time-limited events
- **Action Atomicity**: Ensure actions are completed properly with all side effects

## Response Format
Your response MUST follow this exact format with these exact section markers to be properly processed:

<REASONING>
Provide your detailed reasoning process here (for development purposes).
</REASONING>

<DECISION>
YES or NO (write only one of these words)
</DECISION>

<EXPLANATION>
If NO, explain why the action is invalid in a clear, helpful manner.
If YES, briefly explain why the action is valid.
</EXPLANATION>

<SUGGESTIONS>
If NO, suggest alternatives when appropriate.
If YES, this section can be brief or empty.
</SUGGESTIONS>

## Special Instructions
- Balance strictness with fun - apply rules consistently but don't be pedantic
- Focus on significant rule violations, not minor inconsistencies
- Consider character attributes and skills when evaluating actions
- Flag suspicious behavior patterns for further review
- Always prioritize game balance and fair play
- Always include all four sections in your response, even if some are empty

## Mode Transition Validation
- **Contextual Sense:** Does the requested transition make sense given the current situation, location, and participants? (e.g., initiating trade during a fight is invalid).
- **Target Validity:** For the requested mode transition, check if the target entity (if any) exists. If target entity is mentioned by name but not found in context, do not immediately reject the transition - assume the entity *could* be created dynamically for combat.
- **Combat Fleeing:** Attempting to flee combat (`request_mode_transition` to NARRATIVE from COMBAT) is generally a valid *attempt*, but the success is determined by a later skill check. Validate the *attempt* itself (e.g., is the player prevented from moving?).  
- **Initiating Combat:** Ensure combat is initiated against valid targets. If target is not found in current context but has a name that could be an enemy (like "goblin", "bandit", "guard", "elder", etc.), assume it's a potentially valid target that will be created dynamically. 
- **Initiating Trade/Social:** Ensure the target is present and capable of participating.

Respond with your validation assessment of the player's proposed action.
"""
        
        return system_prompt
    
    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        # Add system prompt
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        
        # Add player stats and capabilities
        player_info = self._format_player_info(context)
        if player_info:
            messages.append({"role": "user", "content": player_info})
        
        # Add recent action history for context
        action_history = self._format_action_history()
        if action_history:
            messages.append({"role": "user", "content": action_history})
        
        # Add the validation request with player input
        validation_request = self._format_validation_request(context)
        messages.append({"role": "user", "content": validation_request})
        
        return messages
    
    def _format_player_info(self, context: AgentContext) -> str:
        """
        Format player information for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted player information string.
        """
        player_state = context.player_state
        if not player_state:
            return ""
        
        # Extract player information
        player_name = player_state.get("name", "Unknown")
        player_race = player_state.get("race", "Human")
        player_path = player_state.get("path", "Wanderer")
        player_level = player_state.get("level", 1)
        
        # Extract player stats
        strength = player_state.get("strength", 10)
        agility = player_state.get("agility", 10)
        constitution = player_state.get("constitution", 10)
        intelligence = player_state.get("intelligence", 10)
        wisdom = player_state.get("wisdom", 10)
        charisma = player_state.get("charisma", 10)
        
        # Extract player status
        health = player_state.get("health", 100)
        max_health = player_state.get("max_health", 100)
        stamina = player_state.get("stamina", 100)
        max_stamina = player_state.get("max_stamina", 100)
        mana = player_state.get("mana", 100)
        max_mana = player_state.get("max_mana", 100)
        
        # Format the information
        info_lines = [
            "## Player Information",
            f"- Name: {player_name}",
            f"- Race: {player_race}",
            f"- Path: {player_path}",
            f"- Level: {player_level}",
            "",
            "### Stats",
            f"- Strength: {strength}",
            f"- Agility: {agility}",
            f"- Constitution: {constitution}",
            f"- Intelligence: {intelligence}",
            f"- Wisdom: {wisdom}",
            f"- Charisma: {charisma}",
            "",
            "### Status",
            f"- Health: {health}/{max_health}",
            f"- Stamina: {stamina}/{max_stamina}",
            f"- Mana: {mana}/{max_mana}"
        ]
        
        # Add inventory details if available for more accurate validation
        inventory_info = context.additional_context.get("inventory", {}) if context.additional_context else {}
        if inventory_info:
            # Weight/slots summary (robust to nested structure in data_retrieval)
            try:
                weight_current = inventory_info.get("weight", {}).get("current", inventory_info.get("current_weight", 0))
                weight_limit = inventory_info.get("weight", {}).get("limit", inventory_info.get("weight_limit", 0))
                info_lines.append(f"- Inventory Weight: {weight_current}/{weight_limit} units")
                slots_used = inventory_info.get("slots", {}).get("used")
                slots_limit = inventory_info.get("slots", {}).get("limit")
                if slots_used is not None and slots_limit is not None:
                    info_lines.append(f"- Inventory Slots: {slots_used}/{slots_limit}")
            except Exception:
                pass

            # Equipped items
            try:
                equipped = inventory_info.get("equipped", {}) or {}
                if equipped:
                    info_lines.append("")
                    info_lines.append("### Equipped Items")
                    for slot, item in equipped.items():
                        if isinstance(item, dict):
                            name = item.get("name", "Unknown Item")
                            iid = item.get("id", "?")
                            info_lines.append(f"- {slot}: {name} (id: {iid})")
                        else:
                            info_lines.append(f"- {slot}: {str(item)}")
            except Exception:
                pass

            # Backpack items
            try:
                backpack = inventory_info.get("backpack", []) or []
                if backpack:
                    info_lines.append("")
                    info_lines.append("### Backpack Items")
                    # List at most the first 25 to keep prompts concise
                    for idx, item in enumerate(backpack[:25]):
                        if isinstance(item, dict):
                            name = item.get("name", "Unknown Item")
                            iid = item.get("id", "?")
                            qty = item.get("quantity", 1)
                            qstr = f" x{qty}" if isinstance(qty, int) and qty > 1 else ""
                            info_lines.append(f"- {name}{qstr} (id: {iid})")
                        else:
                            info_lines.append(f"- {str(item)}")
                    if len(backpack) > 25:
                        info_lines.append(f"...and {len(backpack)-25} more items")
            except Exception:
                pass
        
        return "\n".join(info_lines)
    
    def _format_action_history(self) -> str:
        """
        Format recent action history for context.
        
        Returns:
            Formatted action history string.
        """
        if not self._action_history:
            return ""
        
        # Get the last 5 actions for context
        recent_actions = self._action_history[-5:]
        
        lines = ["## Recent Action History"]
        
        for action in recent_actions:
            action_type = action.get("type", "Unknown")
            action_desc = action.get("description", "")
            timestamp = action.get("timestamp", "")
            lines.append(f"- {timestamp}: {action_type} - {action_desc}")
        
        return "\n".join(lines)
    
    def _format_validation_request(self, context: AgentContext) -> str:
        """
        Format the validation request for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted validation request string.
        """
        # Extract world information
        world_state = context.world_state
        location = context.player_state.get("current_location", "Unknown")
        district = context.player_state.get("current_district", "Unknown")
        time_of_day = world_state.get("time_of_day", "Unknown") if world_state else "Unknown"
        weather = world_state.get("weather", "Clear") if world_state else "Clear"
        
        request_lines = [
            "## Action Validation Request",
            f"- Location: {location}, {district}",
            f"- Time: {time_of_day}",
            f"- Weather: {weather}",
            "",
            "### Player's Proposed Action",
            f"{context.player_input}",
            "",
            "Please validate this action against game rules and provide your assessment."
        ]
        
        return "\n".join(request_lines)
    
    def process(self, context: AgentContext) -> AgentResponse:
        """
        Process a validation request with the rule checker agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The agent response.
        """
        logger.info("Processing request with RuleChecker agent")
        
        # Use the base process method
        response = super().process(context)
        
        # Extract validation result
        validation_result = self._parse_validation_result(response.content)
        
        # Add the validation result to the response metadata
        if validation_result:
            response.metadata["validation_result"] = validation_result
        
        # If this is a loot validation, track the entity if approved
        if "loot" in context.player_input.lower() and validation_result.get("is_valid", False):
            self._track_looted_entity(context)
        
        # Add the action to history
        self._add_to_action_history(context, validation_result)
        
        return response
    
    def _parse_validation_result(self, content: str) -> Dict[str, Any]:
        """Parse the validation result from the LLM response."""
        result = {
            "is_valid": False,
            "reason": "Unspecified rule violation",  # Default reason if not extracted
            "suggestions": []
        }
        
        # Log the content length for debugging
        logger.debug(f"Parsing validation result from content of length {len(content)}")
        
        # Extract sections using the exact markers
        decision_match = re.search(r'<DECISION>\s*(.+?)\s*</DECISION>', content, re.DOTALL)
        explanation_match = re.search(r'<EXPLANATION>\s*(.+?)\s*</EXPLANATION>', content, re.DOTALL)
        suggestions_match = re.search(r'<SUGGESTIONS>\s*(.+?)\s*</SUGGESTIONS>', content, re.DOTALL)
        
        # Process decision
        if decision_match:
            decision_text = decision_match.group(1).strip().upper()
            logger.debug(f"Found decision: {decision_text}")
            
            if 'YES' in decision_text:
                result["is_valid"] = True
                result["reason"] = None  # No reason needed for valid actions
            elif 'NO' in decision_text:
                result["is_valid"] = False
                # Reason will be extracted from explanation
            else:
                # This is a common issue with the LLM where it says the action is valid but marks it as NO
                # Check if the explanation actually contains a positive validation
                if explanation_match:
                    explanation_text = explanation_match.group(1).strip()
                    if explanation_text and any(positive_term in explanation_text.lower() for positive_term in 
                                              ['valid', 'allowed', 'acceptable', 'is valid', 'can be performed']):
                        logger.warning(f"Decision says NO but explanation indicates validity. Setting to valid.")
                        result["is_valid"] = True
                        result["reason"] = None
                    else:
                        logger.warning(f"Unclear decision text: '{decision_text}'")
                else:
                    logger.warning(f"Unclear decision text: '{decision_text}'")
        else:
            logger.warning("No <DECISION> section found in response")
        
        # Process explanation (reason for decision)
        if explanation_match:
            explanation_text = explanation_match.group(1).strip()
            logger.debug(f"Found explanation: {explanation_text[:100]}...")
            
            # Special case: explanation contradicts decision
            is_positive_explanation = any(positive_term in explanation_text.lower() for positive_term in 
                                         ['valid', 'allowed', 'acceptable', 'is valid', 'can be performed'])
            
            # If explanation says it's valid but decision says it's not, override
            if is_positive_explanation and not result["is_valid"]:
                logger.warning("Explanation contradicts decision: Explanation says action is valid, overriding decision")
                result["is_valid"] = True
                result["reason"] = None
            # If explanation says it's invalid but decision says it's valid, don't override
            # (This is a safety feature - we prefer to allow actions on ambiguity)
            
            # For invalid actions, set the reason
            if not result["is_valid"] and explanation_text:  
                result["reason"] = explanation_text
        else:
            logger.warning("No <EXPLANATION> section found in response")
        
        # Process suggestions
        if suggestions_match:
            suggestions_text = suggestions_match.group(1).strip()
            logger.debug(f"Found suggestions: {suggestions_text[:100]}...")
            
            if suggestions_text:
                # Split by lines or sentences to get individual suggestions
                suggestions_lines = re.split(r'[\n\r]+|(?<=\.)\s+', suggestions_text)
                result["suggestions"] = [s.strip() for s in suggestions_lines if s.strip()]
        else:
            logger.warning("No <SUGGESTIONS> section found in response")
        
        # Ensure we have a reason for invalid actions
        if not result["is_valid"] and (not result["reason"] or result["reason"] == "Unspecified rule violation"):
            # If explanation was missing but we have suggestions, use first suggestion as reason
            if result["suggestions"]:
                result["reason"] = f"Action invalid. {result['suggestions'][0]}"
                logger.debug(f"Using first suggestion as reason: {result['reason']}")
        
        return result
    
    def _track_looted_entity(self, context: AgentContext) -> None:
        """
        Track an entity that has been looted to prevent double-looting.
        
        Args:
            context: The agent context with the entity being looted.
        """
        # Extract entity information from input
        player_input = context.player_input.lower()
        
        # Create a simple hash of the input and location to identify the entity
        location = context.player_state.get("current_location", "") if context.player_state else ""
        district = context.player_state.get("current_district", "") if context.player_state else ""
        
        entity_hash = hashlib.md5(f"{player_input}|{location}|{district}".encode()).hexdigest()
        
        # Add to the looted entities set
        self._looted_entities.add(entity_hash)
        logger.debug(f"Tracked looted entity: {entity_hash}")
    
    def _add_to_action_history(self, context: AgentContext, validation_result: Dict[str, Any]) -> None:
        """
        Add an action to the history for anti-cheat tracking.
        
        Args:
            context: The agent context.
            validation_result: The validation result.
        """
        import datetime
        
        action_entry = {
            "type": self._determine_action_type(context.player_input),
            "description": context.player_input,
            "location": context.player_state.get("current_location", "") if context.player_state else "",
            "district": context.player_state.get("current_district", "") if context.player_state else "",
            "is_valid": validation_result.get("is_valid", False),
            "reason": validation_result.get("reason"),
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        # Add to action history
        self._action_history.append(action_entry)
        
        # Limit history size
        if len(self._action_history) > 100:
            self._action_history = self._action_history[-100:]
    
    def _determine_action_type(self, input_text: str) -> str:
        """
        Determine the type of action from the input text.
        
        Args:
            input_text: The player input text.
        
        Returns:
            The action type.
        """
        input_lower = input_text.lower()
        
        if any(word in input_lower for word in ["attack", "fight", "hit", "strike", "combat"]):
            return "COMBAT"
        elif any(word in input_lower for word in ["loot", "take", "grab", "steal", "pick up"]):
            return "LOOT"
        elif any(word in input_lower for word in ["cast", "spell", "magic"]):
            return "MAGIC"
        elif any(word in input_lower for word in ["talk", "speak", "ask", "tell"]):
            return "DIALOGUE"
        elif any(word in input_lower for word in ["move", "go", "walk", "run", "travel"]):
            return "MOVEMENT"
        elif any(word in input_lower for word in ["use", "activate", "trigger"]):
            return "USE"
        elif any(word in input_lower for word in ["search", "look", "examine", "inspect"]):
            return "OBSERVATION"
        else:
            return "OTHER"
    
    def supports_command(self, command: str) -> bool:
        """
        Check if the rule checker agent supports a specific command.
        
        Args:
            command: The command name.
        
        Returns:
            True if the agent supports the command, False otherwise.
        """
        return command in self.SUPPORTED_COMMANDS
    
    def validate_action(self, context: AgentContext) -> Tuple[bool, Optional[str]]:
        """
        Validate a player action against game rules.
        
        Args:
            context: The agent context.
        
        Returns:
            A tuple of (is_valid, reason) where reason is None if valid.
        """
        # Log the action being validated
        logger.info(f"Validating action: {context.player_input[:100]}...")
        
        # Process the validation request
        response = self.process(context)
        
        # Get the validation result
        validation_result = response.metadata.get("validation_result", {})
        is_valid = validation_result.get("is_valid", False)
        reason = validation_result.get("reason")
        
        # Log more details about the validation result
        logger.info(f"Validation result: valid={is_valid}, reason={reason}")
        
        # If it's invalid but reason is None, provide a default
        if not is_valid and reason is None:
            reason = "Unspecified rule violation - rule checker could not determine specific reason"
            logger.warning(f"Rule checker returned invalid action with no reason. Using default: {reason}")
        
        # Debug log the full validation response if the result seems problematic
        if not is_valid or reason is None:
            # Log first 500 chars of the response content for debugging
            logger.debug(f"Rule checker response content (excerpt): {response.content[:500]}...")
        
        return is_valid, reason
    
    def is_already_looted(self, entity_description: str, location: str, district: str) -> bool:
        """
        Check if an entity has already been looted.
        
        Args:
            entity_description: Description of the entity.
            location: The location of the entity.
            district: The district within the location.
        
        Returns:
            True if the entity has already been looted, False otherwise.
        """
        # Create a hash of the entity
        entity_hash = hashlib.md5(f"{entity_description.lower()}|{location}|{district}".encode()).hexdigest()
        
        # Check if the entity is in the looted entities set
        return entity_hash in self._looted_entities
        
    def perform_skill_check(self, stat_type: str, difficulty: int, context: str = "") -> Dict[str, Any]:
        """
        Perform a skill check against a character stat.
        
        Args:
            stat_type: The type of stat to check (e.g., STR, DEX, INT)
            difficulty: The difficulty class (DC) of the check
            context: Optional description of the check context
            
        Returns:
            Dictionary with skill check results
        """
        from core.base.state import get_state_manager
        from core.stats.stats_base import StatType, DerivedStatType
        
        # Get the stats manager from the state manager
        state_manager = get_state_manager()
        if not state_manager or not state_manager.stats_manager:
            logger.warning("Stats manager not available for skill check")
            return {
                "success": False,
                "error": "Stats system not available"
            }
            
        stats_manager = state_manager.stats_manager
        
        try:
            # Convert string stat type to enum if needed
            if isinstance(stat_type, str):
                # Try to match with primary stat first
                try:
                    stat_enum = StatType.from_string(stat_type)
                except ValueError:
                    # Then try derived stat
                    try:
                        stat_enum = DerivedStatType.from_string(stat_type)
                    except ValueError:
                        logger.warning(f"Unknown stat type: {stat_type}")
                        return {
                            "success": False,
                            "error": f"Unknown stat type: {stat_type}"
                        }
            else:
                stat_enum = stat_type
                
            # Perform the skill check
            result = stats_manager.perform_skill_check(
                stat_type=stat_enum,
                difficulty=difficulty
            )
            
            # Return the result as a dictionary
            return {
                "success": True,
                "result": result,
                "context": context
            }
            
        except Exception as e:
            logger.error(f"Error performing skill check: {e}")
            return {
                "success": False,
                "error": str(e)
            }


# Convenience function
def get_rule_checker_agent() -> RuleCheckerAgent:
    """Get the rule checker agent instance."""
    return RuleCheckerAgent()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the rule checker agent
    rule_checker = get_rule_checker_agent()
    
    # Create a test context
    context = AgentContext(
        game_state={},
        player_state={
            "name": "Thorn",
            "race": "Elf",
            "path": "Ranger",
            "background": "Outcast",
            "current_location": "Whispering Woods",
            "current_district": "Ancient Grove",
            "strength": 12,
            "agility": 15,
            "constitution": 10,
            "intelligence": 13,
            "wisdom": 14,
            "charisma": 9,
            "health": 80,
            "max_health": 100,
            "stamina": 60,
            "max_stamina": 100,
            "mana": 90,
            "max_mana": 100
        },
        world_state={
            "time_of_day": "evening",
            "weather": "Light Rain",
            "is_day": False
        },
        player_input="I want to lift the boulder that's blocking the entrance to the cave.",
        conversation_history=[],
        relevant_memories=[],
        additional_context={
            "inventory": {
                "current_weight": 25,
                "weight_limit": 50
            }
        }
    )
    
    # Process the request
    response = rule_checker.process(context)
    
    # Print the response
    print(f"Response: {response.content}")
    print(f"Validation result: {response.metadata.get('validation_result')}")
```

### File: core\agents\social_conflict_agent.py

```python
#!/usr/bin/env python3
"""
Social Conflict agent for handling non-combat confrontations.
"""

import re
import json
import logging
from typing import List, Dict, Any

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode, SocialStatusEffect # Make sure SocialStatusEffect is imported
from core.stats.stats_base import Skill # Corrected: Import Skill from stats_base

logger = get_logger("AGENT")

class SocialConflictAgent(BaseAgent):
    """
    Agent responsible for managing social conflicts (debates, negotiations, interrogations).

    It receives social context (participants, relationships, goals, resolve) and player input,
    generates narrative describing the social exchange, and identifies necessary skill checks
    (e.g., Persuasion, Deception, Intimidation, Insight) or state changes (e.g., changing
    relationship stance, reducing Resolve/Composure).
    """

    def __init__(self):
        """Initialize the social conflict agent."""
        super().__init__("SocialConflict")

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the social conflict agent.
        """
        player_id = context.player_state.get("id", "player")
        # Extract social-specific context
        social_context = context.additional_context.get("social_context", {})
        participants_data = social_context.get("participants", []) # Assuming this contains dicts with participant info
        conflict_goal = social_context.get("goal", "Resolve the situation")
        current_topic = social_context.get("topic", "General discussion")

        # D3: Enhance participant list to show effects
        participant_list_parts = []
        for p in participants_data:
            effects = p.get('active_social_effects', [])
            # Ensure effects are strings before joining, handle potential non-string items gracefully
            effects_str = f" Effects: [{', '.join(map(str, effects))}]" if effects else ""
            participant_list_parts.append(
                f"- {p.get('name', 'Unknown')} (ID: {p.get('id', 'N/A')}, "
                f"Stance: {p.get('stance', 'Neutral')}, "
                f"Resolve: {p.get('resolve', '?')}/{p.get('max_resolve', '?')})"
                f"{effects_str}" # Add effects string
            )
        participant_list = "\n".join(participant_list_parts)


        # D3: Refined Prompt
        system_prompt = f"""You are the Social Conflict AI moderator for a text-based RPG. Your role is to narrate social interactions like debates, negotiations, interrogations, or persuasion attempts, and interpret player actions within this context.
You will receive the current social situation and the player's input describing their intended social action.
Your output MUST be a single JSON object adhering *exactly* to the `AgentOutput` structure defined below.

## Current Social Conflict State
- Participants:
{participant_list}
- Conflict Goal: {conflict_goal}
- Current Topic: {current_topic}
- Player ID: {player_id}

## Your Responsibilities
1.  **Narrate the Attempt:** Generate engaging narrative describing the player's *attempted* social maneuver based on their input (e.g., "You lean in, trying to appear sincere...", "You raise your voice, attempting to intimidate the guard...", "You calmly present your counter-argument..."). **Do not state success or failure in the narrative.** The game engine resolves checks and applies changes based on your requests.
2.  **Analyze Intent:** Analyze the player's natural language input (e.g., "I try to convince him to let us pass", "I lie about where we found the artifact", "I demand answers", "I offer a compromise") and the social context.
3.  **Request Actions (Skill Checks & State Changes):** Based on the player's intent and the context, determine the necessary game mechanic requests. Output these as a list in the `requests` field of the JSON.
    *   **Skill Checks (`request_skill_check`):**
        *   **When:** Request a skill check when the player attempts an action whose success is uncertain and depends on their social capabilities against a target's resistance.
        *   **Which Skill:**
            *   Use `{Skill.PERSUASION.name}` when the player tries to convince, reason, negotiate, charm, or appeal to emotion/logic.
            *   Use `{Skill.INTIMIDATION.name}` when the player tries to threaten, coerce, or frighten.
            *   Use `{Skill.DECEPTION.name}` when the player tries to lie, mislead, or feint.
            *   Use `{Skill.INSIGHT.name}` when the player tries to discern motives, detect lies, or understand someone's emotional state.
            *   Use other relevant skills (e.g., `{Skill.PERFORMANCE.name}`) if applicable.
        *   **Target:** Specify the `target_actor_id`. The `difficulty_class` (DC) should reflect the target's resistance (e.g., based on their Resolve, opposing skill, current stance, or situational factors). Provide context for the check.
    *   **State Changes (`request_state_change`):**
        *   **When:** Request a state change to reflect the direct consequences of a social action (often following a successful skill check, but sometimes as the primary action like offering a gift).
        *   **Resolve:** To reduce a target's `current_resolve` (social HP), use `attribute: "current_resolve"`, `change_type: "add"`, and a negative integer `value` (e.g., `value: -5`).
        *   **Social Status Effects:**
            *   To *add* an effect, use `attribute: "add_social_effect"` and set `value` to the string name of the effect from the `SocialStatusEffect` enum (e.g., `value: "{SocialStatusEffect.CHARMED.name}"`, `value: "{SocialStatusEffect.INTIMIDATED.name}"`).
            *   To *remove* an effect, use `attribute: "remove_social_effect"` and set `value` to the string name of the effect (e.g., `value: "{SocialStatusEffect.CHARMED.name}"`).
        *   **Other Changes:** You can also request changes to other attributes like `relationship_stance` if appropriate.
4.  **Output JSON:** Ensure your entire response is a single, valid JSON object matching the `AgentOutput` structure.

## Required Output Format (JSON)
```json
{{
  "narrative": "Your descriptive text about the attempted social action goes here. Describe the player's words, tone, body language, and the immediate reaction or atmosphere. Focus on the attempt, not the outcome.",
  "requests": [
    // Optional: Include structured requests based on player intent. Add one or more requests as needed.
    // Example 1: Persuasion Check
    {{
      "action": "request_skill_check",
      "actor_id": "{player_id}", // The one performing the check
      "skill_name": "{Skill.PERSUASION.name}", // Use the correct Skill enum name string
      "target_actor_id": "guard_captain", // ID of the target NPC being persuaded
      "difficulty_class": 15, // DC based on target's resistance/situation
      "context": "Player attempting to persuade the captain to grant access."
    }},
    // Example 2: Reducing Resolve via Intimidation (State Change - often follows successful Intimidation check)
     {{
      "action": "request_state_change",
      "target_entity": "stubborn_noble", // ID of the target NPC
      "attribute": "current_resolve", // Target the resolve attribute
      "change_type": "add", // Use 'add' for delta changes
      "value": -5, // Negative value to decrease resolve
      "context": "Result of successful intimidation attempt."
    }},
    // Example 3: Applying 'Charmed' Status (State Change - often follows successful Persuasion/Charm check)
    {{
      "action": "request_state_change",
      "target_entity": "merchant_guildmaster",
      "attribute": "add_social_effect", // Use 'add_social_effect'
      "change_type": "set", // Type is less relevant here, but 'set' or 'add' is fine
      "value": "{SocialStatusEffect.CHARMED.name}", // String name of the SocialStatusEffect enum member
      "context": "Result of successful charm attempt."
    }},
    // Example 4: Removing 'Intimidated' Status (State Change)
    {{
      "action": "request_state_change",
      "target_entity": "frightened_peasant",
      "attribute": "remove_social_effect", // Use 'remove_social_effect'
      "change_type": "set", // Type is less relevant here
      "value": "{SocialStatusEffect.INTIMIDATED.name}", // String name of the effect to remove
      "context": "Player successfully calmed the peasant."
    }}
    // Add more requests here if the player's action involves multiple steps/effects
  ]
}}
```

## Guidelines
- **Interpret Intent:** Focus on the player's goal and the *implied* social tactic (persuade, intimidate, deceive, etc.) even if they don't use specific keywords.
- **Context is Key:** Base your requested checks and changes on the provided participant details (Resolve, Stance, Effects) and the overall situation. A high-Resolve character might require a higher DC to intimidate. An already 'Friendly' character might be easier to persuade.
- **Clarity & Precision:** Ensure `requests` use the correct IDs, attribute names (`current_resolve`, `add_social_effect`, `remove_social_effect`), skill names (`{Skill.PERSUASION.name}`, etc.), and effect names (`{SocialStatusEffect.CHARMED.name}`, etc.).
- **Multi-Step Actions:** If the player describes a complex action (e.g., "I flatter him then ask for the key"), break it down into multiple requests if necessary (e.g., a Persuasion check for flattery potentially followed by another Persuasion check for the key, maybe with a modifier).
- **Safety:** Adhere to standard content safety guidelines.

Respond to the player's social input by generating the JSON `AgentOutput` object.
"""
        return system_prompt

    # D3: Update _format_social_context to potentially include effects if available in context data
    def _format_social_context(self, context: AgentContext) -> str:
        """ Formats the social conflict specific context """
        social_context = context.additional_context.get("social_context", {})
        if not social_context:
            return ""

        lines = ["## Social Conflict Situation"]
        participants_data = social_context.get("participants", [])
        conflict_goal = social_context.get("goal", "Resolve the situation")
        current_topic = social_context.get("topic", "General discussion")
        recent_exchange = social_context.get("recent_exchange", "N/A") # Last significant statement/action

        lines.append(f"- Goal: {conflict_goal}")
        lines.append(f"- Topic: {current_topic}")
        lines.append(f"- Recent Exchange: {recent_exchange}")
        lines.append("### Participants:")
        for p in participants_data:
            # D3: Include active effects in the formatted context string
            effects = p.get('active_social_effects', []) # Get effects list/set
            # Ensure effects are strings before joining
            effects_str = f" Effects: [{', '.join(map(str, effects))}]" if effects else ""
            lines.append(
                f"- {p.get('name', 'Unknown')} (ID: {p.get('id', 'N/A')}, "
                f"Stance: {p.get('stance', 'Neutral')}, "
                f"Resolve: {p.get('resolve', '?')}/{p.get('max_resolve', '?')}, "
                f"Goal: {p.get('goal', 'Unknown')})"
                f"{effects_str}" # Append formatted effects
            )
        return "\n".join(lines)

    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """ Prepare messages, adding social context. """
        messages = super()._prepare_messages(context) # Get base messages

        # Find the user message and prepend social context
        for msg in reversed(messages):
            if msg["role"] == "user":
                social_context_str = self._format_social_context(context)
                if social_context_str:
                     original_user_content = msg["content"]
                     input_marker = "## Player Input"
                     if input_marker in original_user_content:
                         parts = original_user_content.split(input_marker, 1)
                         msg["content"] = f"{parts[0]}{social_context_str}\n\n{input_marker}{parts[1]}"
                     else:
                         msg["content"] = f"{social_context_str}\n\n{original_user_content}"
                break
        return messages

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a social conflict request.
        """
        logger.info(f"Processing request with SocialConflict agent in mode: {context.game_state.get('mode', 'N/A')}")

        messages = self._prepare_messages(context)

        try:
            llm_response_content = self._llm_service.generate_response(messages)
            if not llm_response_content:
                 raise ValueError("LLM returned empty content.")
            logger.debug(f"Raw LLM Response (Social):\n{llm_response_content}")

            try:
                cleaned_response = re.sub(r'^```json\s*|\s*```$', '', llm_response_content, flags=re.MULTILINE | re.DOTALL).strip()
                parsed_output = json.loads(cleaned_response)

                if not isinstance(parsed_output, dict) or \
                   "narrative" not in parsed_output or \
                   "requests" not in parsed_output or \
                   not isinstance(parsed_output["requests"], list):
                    raise ValueError("LLM response is not a valid AgentOutput JSON structure.")

                validated_requests = []
                for req in parsed_output["requests"]:
                    if not isinstance(req, dict) or "action" not in req:
                        logger.warning(f"Skipping invalid request structure: {req}")
                        continue
                    validated_requests.append(req)

                agent_output: AgentOutput = {
                    "narrative": parsed_output.get("narrative", "Error: Narrative missing."),
                    "requests": validated_requests
                }

            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Social LLM response as JSON: {e}\nRaw response: {llm_response_content}")
                agent_output: AgentOutput = {
                    "narrative": f"[SocialConflict Error: Parse failed] {llm_response_content}",
                    "requests": []
                }
            except ValueError as e:
                 logger.error(f"Invalid AgentOutput structure from Social LLM: {e}\nParsed: {parsed_output}")
                 agent_output: AgentOutput = {
                    "narrative": f"[SocialConflict Error: Invalid structure] {parsed_output.get('narrative', llm_response_content)}",
                    "requests": []
                 }

        except Exception as e:
            logger.exception(f"Error during SocialConflict processing: {e}")
            agent_output: AgentOutput = {
                "narrative": f"[SocialConflict Error: Processing failed: {e}]",
                "requests": []
            }

        logger.info(f"SocialConflict generated {len(agent_output['requests'])} requests.")
        return agent_output

    def supports_command(self, command: str) -> bool:
        return False # Handles interactions via natural language and structured requests

# Convenience function
def get_social_conflict_agent() -> SocialConflictAgent:
    return SocialConflictAgent()
```

### File: core\agents\trade_agent.py

```python
#!/usr/bin/env python3
"""
Trade agent for handling buying, selling, and bartering interactions.
"""

import re
import json
import logging
from typing import List, Dict, Any

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode

logger = get_logger("AGENT")

class TradeAgent(BaseAgent):
    """
    Agent responsible for managing trade interactions (buying, selling, bartering).

    It receives trade context (participants, inventories, current offers) and player input,
    generates narrative describing the trade negotiation, and identifies necessary skill checks
    (e.g., Appraise, Haggle/Barter) or state changes (transferring items/currency).
    """

    def __init__(self):
        """Initialize the trade agent."""
        super().__init__("Trade") # Use "Trade" as name for settings file trade.json

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the trade agent.
        """
        player_info = context.additional_context.get("player_trade_info", {})
        partner_info = context.additional_context.get("trade_partner", {})

        player_id = context.player_state.get("id", "player") # Fallback if not in player_info
        player_currency = player_info.get("currency", "N/A")
        player_inv_str = ", ".join([f"{item.get('name', '?')} (Value: {item.get('value', 0)})" for item in player_info.get("inventory", [])]) or "Empty"

        trade_partner_id = partner_info.get("id", "unknown_merchant")
        trade_partner_name = partner_info.get("name", "Unknown Merchant")
        partner_currency = partner_info.get("currency", "N/A")
        partner_inv_str = ", ".join([f"{item.get('name', '?')} (Value: {item.get('value', 0)})" for item in partner_info.get("inventory", [])]) or "Empty"

        system_prompt = f"""You are the Trade AI facilitator for a text-based RPG. Your role is to narrate trading interactions (buying, selling, bartering) and interpret player actions within this context.

## Current Trade State
- Player: ID '{player_id}', Currency: {player_currency}
  - Inventory: {player_inv_str}
- Trade Partner: {trade_partner_name} (ID: {trade_partner_id}), Currency: {partner_currency}
  - Inventory: {partner_inv_str}

## Your Responsibilities
1.  **Narrate:** Describe the player's trade action, proposal, or inquiry based on their input (e.g., "You examine the sword closely...", "You offer 5 gold pieces for the potion.", "You try to haggle for a better price...").
2.  **Analyze Intent:** Understand the player's natural language input (e.g., "I want to buy the health potion", "I offer my old dagger for that shield", "How much for the map?", "Can you do 10 gold instead?", "I accept the deal", "What do you have for sale?", "I want to sell these pelts").
3.  **Identify Mechanics:** Determine if the player's action requires:
    *   **Skill Checks:** Primarily `BARTER` (associated with Charisma) for haggling/influencing prices. Use `APPRAISE` (associated with Intelligence) if the player explicitly tries to determine an item's value.
    *   **State Changes:** Although the final transaction (item/currency transfer) is usually handled by the game engine after an agreement, you should understand the *intent* behind buy/sell/offer actions.
4.  **Output JSON:** Format your entire response as a single JSON object adhering *exactly* to the `AgentOutput` structure defined below.

## Required Output Format (JSON)
```json
{{
  "narrative": "Your descriptive text about the trade interaction. Describe the item examination, the offer being made, the haggling attempt, or the agreement.",
  "requests": [
    // Optional: Include structured requests based on player intent.
    // --- Example 1: Barter Check ---
    // Triggered by inputs like "Can you do better?", "I offer 10 gold [when value is 15]", "I try to haggle".
    {{
      "request_type": "SkillCheckRequest", // Matches class name
      "entity_id": "{player_id}", // Who is performing the check
      "skill_name": "BARTER", // Use the BARTER skill for haggling
      "target_dc": 12, // Target DC determined by game logic (e.g., based on NPC disposition, offer difference) - provide a reasonable estimate if unsure
      "advantage": false,
      "disadvantage": false,
      "modifier": 0, // Any situational modifiers?
      "context": "Player attempting to haggle for a better price on [Item Name/Offer]."
    }},
    // --- Example 2: Appraise Check ---
    // Triggered by inputs like "What's this worth?", "Is this price fair?".
    // {{
    //   "request_type": "SkillCheckRequest",
    //   "entity_id": "{player_id}",
    //   "skill_name": "APPRAISE", // Use APPRAISE skill
    //   "target_dc": 10, // DC based on item rarity/complexity
    //   "advantage": false,
    //   "disadvantage": false,
    //   "modifier": 0,
    //   "context": "Player attempting to appraise the [Item Name]."
    // }},
    // --- Example 3: Transfer Item (State Change) ---
    // NOTE: The core loop usually handles this *after* an offer is accepted based on intent ("accept", "deal").
    // Only include this if the LLM *confidently* determines a final, agreed-upon transfer.
    // {{
    //   "request_type": "StateChangeRequest", // Matches class name
    //   "target_entity": "UNUSED_FOR_TRANSFER", // Not used directly for transfer_item attribute
    //   "attribute": "transfer_item",
    //   "value": {{ // Dictionary containing transfer details
    //     "item_id": "item_id_to_transfer", // Specific ID of the item
    //     "from_owner_id": "{trade_partner_id}", // ID of the entity giving the item
    //     "to_owner_id": "{player_id}" // ID of the entity receiving the item
    //   }},
    //   "context": "Item transferred as part of accepted trade."
    // }},
    // --- Example 4: Adjust Currency (State Change) ---
    // NOTE: Similar to item transfer, usually handled by core loop post-acceptance.
    // {{
    //   "request_type": "StateChangeRequest",
    //   "target_entity": "{player_id}", // ID of the entity whose currency is changing
    //   "attribute": "adjust_currency",
    //   "value": -50, // Amount to change (positive to add, negative to remove)
    //   "context": "Currency transferred as part of accepted trade."
    // }}
    // --- Focus ---
    // Your primary job is narrative + identifying necessary skill checks (BARTER/APPRAISE).
    // Let the game engine handle the mechanics of offer proposal, acceptance, and the resulting state changes based on player intent like 'accept' or specific offers like 'I offer X for Y'.
  ]
}}
```

## Guidelines
- **Narrate Clearly:** Describe the negotiation, item inspection, offers, counter-offers, inquiries ("What do you have?", "How much is...?").
- **Identify Intent:** Determine if the player is inquiring, offering ("I offer X for Y"), buying ("I want to buy Z"), selling ("I want to sell A"), accepting ("Deal", "I accept"), rejecting ("No thanks"), or haggling ("Can you do better?").
- **Infer Checks:** Request `BARTER` checks for haggling attempts. Request `APPRAISE` only if explicitly asked about value/fairness.
- **Use Context:** Refer to the player and partner inventories and currency provided in the state.
- **State Changes:** Generate `StateChangeRequest` for item/currency transfers *only if* you are certain the interaction represents a finalized, agreed transaction (less common, usually handled by the engine).
- **Safety:** Adhere to standard content safety guidelines.

Respond to the player's trade input by generating the JSON `AgentOutput` object.
"""
        return system_prompt

    def _format_trade_context(self, context: AgentContext) -> str:
        """ Formats the trade specific context """
        trade_context = context.additional_context.get("trade_context", {})
        if not trade_context:
            return ""

        lines = ["## Trade Situation"]
        participants = trade_context.get("participants", []) # Includes player and partner
        player_offer = trade_context.get("player_offer", {"items": [], "currency": 0})
        partner_offer = trade_context.get("partner_offer", {"items": [], "currency": 0})
        trade_partner_id = trade_context.get("trade_partner_id", "unknown_merchant")
        player_inventory = trade_context.get("player_inventory_summary", "Not available") # Expect summaries
        partner_inventory = trade_context.get("partner_inventory_summary", "Not available")

        # Format offers
        def format_offer(offer):
            items_str = ", ".join([f"{i.get('name', '?')} (x{i.get('quantity', 1)})" for i in offer.get('items', [])]) or "Nothing"
            curr = offer.get('currency', 0)
            # Basic currency assumption (copper) - needs refinement based on game system
            curr_str = f"{curr} copper" if curr else ""
            if items_str != "Nothing" and curr_str:
                return f"Items: {items_str}, Currency: {curr_str}"
            elif items_str != "Nothing":
                return f"Items: {items_str}"
            elif curr_str:
                return f"Currency: {curr_str}"
            else:
                return "Offer is empty"

        lines.append(f"- Trading With: {trade_partner_id}") # Assuming partner ID is known
        lines.append(f"- Player Offer: {format_offer(player_offer)}")
        lines.append(f"- Partner Offer: {format_offer(partner_offer)}")
        lines.append("### Player Inventory (Relevant for Trade)")
        lines.append(player_inventory) # Assumes pre-formatted summary
        lines.append("### Partner Inventory (Relevant for Trade)")
        lines.append(partner_inventory) # Assumes pre-formatted summary

        return "\n".join(lines)


    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """ Prepare messages, adding trade context. """
        messages = super()._prepare_messages(context) # Get base messages

        # Find the user message and prepend trade context
        for msg in reversed(messages):
            if msg["role"] == "user":
                trade_context_str = self._format_trade_context(context)
                if trade_context_str:
                     original_user_content = msg["content"]
                     input_marker = "## Player Input"
                     if input_marker in original_user_content:
                         parts = original_user_content.split(input_marker, 1)
                         msg["content"] = f"{parts[0]}{trade_context_str}\n\n{input_marker}{parts[1]}"
                     else:
                         msg["content"] = f"{trade_context_str}\n\n{original_user_content}"
                break
        return messages

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a trade request.
        """
        logger.info(f"Processing request with Trade agent in mode: {context.game_state.get('mode', 'N/A')}")

        messages = self._prepare_messages(context)

        try:
            llm_response_content = self._llm_service.generate_response(messages)
            if not llm_response_content:
                 raise ValueError("LLM returned empty content.")
            logger.debug(f"Raw LLM Response (Trade):\n{llm_response_content}")

            try:
                cleaned_response = re.sub(r'^```json\s*|\s*```$', '', llm_response_content, flags=re.MULTILINE | re.DOTALL).strip()
                parsed_output = json.loads(cleaned_response)

                if not isinstance(parsed_output, dict) or \
                   "narrative" not in parsed_output or \
                   "requests" not in parsed_output or \
                   not isinstance(parsed_output["requests"], list):
                    raise ValueError("LLM response is not a valid AgentOutput JSON structure.")

                validated_requests = []
                for req in parsed_output["requests"]:
                    if not isinstance(req, dict) or "action" not in req:
                        logger.warning(f"Skipping invalid request structure: {req}")
                        continue
                    validated_requests.append(req)

                agent_output: AgentOutput = {
                    "narrative": parsed_output.get("narrative", "Error: Narrative missing."),
                    "requests": validated_requests
                }

            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Trade LLM response as JSON: {e}\nRaw response: {llm_response_content}")
                agent_output: AgentOutput = {
                    "narrative": f"[Trade Error: Parse failed] {llm_response_content}",
                    "requests": []
                }
            except ValueError as e:
                 logger.error(f"Invalid AgentOutput structure from Trade LLM: {e}\nParsed: {parsed_output}")
                 agent_output: AgentOutput = {
                    "narrative": f"[Trade Error: Invalid structure] {parsed_output.get('narrative', llm_response_content)}",
                    "requests": []
                 }

        except Exception as e:
            logger.exception(f"Error during Trade processing: {e}")
            agent_output: AgentOutput = {
                "narrative": f"[Trade Error: Processing failed: {e}]",
                "requests": []
            }

        logger.info(f"Trade generated {len(agent_output['requests'])} requests.")
        return agent_output

    def supports_command(self, command: str) -> bool:
        return False # Handles interactions via natural language and structured requests

# Convenience function
def get_trade_agent() -> TradeAgent:
    return TradeAgent()
```

### File: core\base\state\__init__.py

```python
"""
State management module for the RPG game.

This module provides classes for managing the game state,
including player state, world state, and game session information.
"""

from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from core.base.state.game_state import GameState
from core.base.state.state_manager import StateManager, get_state_manager

```

### File: core\base\state\calendar_state.py

```python
#!/usr/bin/env python3
"""
Canonical calendar state representation for the RPG game.

This defines the hierarchical calendar components:
Era > Cycle > Phase > Tide > Span > Day

The breakdown is computed from the configured unit lengths in config/calendar.
"""

from dataclasses import dataclass, field
from typing import Dict, Any

from core.base.config import get_config
from core.utils.logging_config import get_logger

logger = get_logger("CALENDAR")


@dataclass
class CalendarState:
    era: int = 1
    cycle: int = 1
    phase: int = 1
    tide: int = 1
    span: int = 1
    day: int = 1

    def to_dict(self) -> Dict[str, Any]:
        return {
            "era": self.era,
            "cycle": self.cycle,
            "phase": self.phase,
            "tide": self.tide,
            "span": self.span,
            "day": self.day,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CalendarState":
        logger.debug(f"CalendarState.from_dict: data received: {data}")
        if not isinstance(data, dict):
            logger.debug("CalendarState.from_dict: data is not a dict, returning default CalendarState.")
            return cls()
        return cls(
            era=int(data.get("era", 1) or 1),
            cycle=int(data.get("cycle", 1) or 1),
            phase=int(data.get("phase", 1) or 1),
            tide=int(data.get("tide", 1) or 1),
            span=int(data.get("span", 1) or 1),
            day=int(data.get("day", 1) or 1),
        )

    def recalc_from_game_time(self, game_time_seconds: float) -> None:
        """Recalculate the calendar breakdown based on game time and configured unit lengths."""
        try:
            cfg = get_config()
            units = cfg.get("calendar.units", {}) or {}
            day_len = int(units.get("day_length_seconds", 86400))
            span_days = int(units.get("span_length_days", 5))
            tide_spans = int(units.get("tide_length_spans", 3))
            phase_tides = int(units.get("phase_length_tides", 4))
            cycle_phases = int(units.get("cycle_length_phases", 6))
            era_cycles = int(units.get("era_length_cycles", 8))

            if day_len <= 0:
                day_len = 86400

            # Total days elapsed since epoch start (0-based)
            total_days = int(max(0, game_time_seconds) // day_len)

            days_per_span = max(1, span_days)
            days_per_tide = days_per_span * max(1, tide_spans)
            days_per_phase = days_per_tide * max(1, phase_tides)
            days_per_cycle = days_per_phase * max(1, cycle_phases)
            days_per_era = days_per_cycle * max(1, era_cycles)

            remaining = total_days
            self.era = (remaining // days_per_era) + 1
            remaining = remaining % days_per_era

            self.cycle = (remaining // days_per_cycle) + 1
            remaining = remaining % days_per_cycle

            self.phase = (remaining // days_per_phase) + 1
            remaining = remaining % days_per_phase

            self.tide = (remaining // days_per_tide) + 1
            remaining = remaining % days_per_tide

            self.span = (remaining // days_per_span) + 1
            remaining = remaining % days_per_span

            self.day = (remaining % days_per_span) + 1
        except Exception as e:
            logger.warning(f"Failed to recalc calendar from game time: {e}")

```

### File: core\base\state\game_state.py

```python
"""
Game state for the RPG game.

This module provides the GameState class for managing the overall game state.
"""

import uuid
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any

from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from core.utils.logging_config import get_logger
from core.interaction.enums import InteractionMode


# Import here but use type hints with string to avoid circular imports
# This import is only used for type checking
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.combat.combat_manager import CombatManager

# Get the module logger
logger = get_logger("GAME")

@dataclass
class GameState:
    """
    Overall game state.
    
    This dataclass contains all state information for a game session,
    including player and world state.
    """
    # Session information
    session_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: float = field(default_factory=time.time)
    last_saved_at: Optional[float] = None
    
    # Game version
    game_version: str = "0.1.0"
    
    # States
    player: PlayerState = field(default_factory=lambda: PlayerState(name="Player"))
    world: WorldState = field(default_factory=WorldState)
    
    # Combat manager (optional, only present during combat)
    combat_manager: Optional['CombatManager'] = None
    
    # Conversation history (simple for now, will be expanded)
    conversation_history: List[Dict[str, Any]] = field(default_factory=list)
    
    # Event log (game-time receipts of what happened in this session)
    event_log: List[Dict[str, Any]] = field(default_factory=list)
    
    # Last command (for context)
    last_command: Optional[str] = None
    
    
    # Interaction Mode
    current_mode: InteractionMode = field(default=InteractionMode.NARRATIVE)
    
    # Mode-specific state
    current_combatants: List[str] = field(default_factory=list)  # IDs of entities in combat/social conflict
    current_trade_partner_id: Optional[str] = None             # ID of the NPC being traded with
    
    # Cooldowns for mode transitions (target_mode: timestamp_expires)
    mode_transition_cooldowns: Dict[str, float] = field(default_factory=dict)
    
    # Transition state flags
    is_transitioning_to_combat: bool = False  # Flag for narrative->combat transition
    combat_narrative_buffer: List[str] = field(default_factory=list)  # Buffer for combat intro narrative

    @property
    def game_time(self):
        """
        Compatibility property for web server to access game time.
        
        Returns:
            A GameTime object representing the game time from world state.
        """
        from core.base.game_loop import GameTime
        return GameTime(game_time=self.world.game_time)
    
    def add_conversation_entry(self, role: str, content: str) -> None:
        """
        Add an entry to the conversation history.
        
        Args:
            role: The role of the speaker (e.g., "player", "gm").
            content: The content of the message.
        """
        entry = {
            "role": role,
            "content": content,
            "timestamp": time.time(),
        }
        self.conversation_history.append(entry)
        
        # Limit history size (keep last 100 entries)
        if len(self.conversation_history) > 100:
            self.conversation_history = self.conversation_history[-100:]
    

    def get_interaction_mode(self) -> InteractionMode:
        """Return the current interaction mode."""
        return self.current_mode

    def set_interaction_mode(self, new_mode: InteractionMode) -> None:
        """
        Set the interaction mode and reset mode-specific state if necessary.

        Args:
            new_mode: The InteractionMode to switch to.
        """
        if new_mode == self.current_mode:
            return  # No change

        old_mode = self.current_mode
        logger.info(f"Changing interaction mode from {old_mode.name} to {new_mode.name}")

        # --- ECFA Change: is_transitioning_to_combat flag management ---
        # This flag is primarily set to True by mode_transitions.py *before* this method is called.
        # This method mainly handles cleanup and ensures the flag is reset appropriately.

        if old_mode == InteractionMode.NARRATIVE and new_mode == InteractionMode.COMBAT:
            # If is_transitioning_to_combat is not already True, it means this is a direct
            # call to set COMBAT mode (e.g., dev command, or unexpected flow).
            # Set it True to ensure UI buffers any initial narrative if it comes *after* this call.
            if not self.is_transitioning_to_combat:
                logger.warning("set_interaction_mode called directly to COMBAT without transition prep. Setting is_transitioning_to_combat=True.")
                self.is_transitioning_to_combat = True
            # The flag (is_transitioning_to_combat) will be reset by MainWindow after
            # it processes the buffered narrative and switches the UI view.
        
        elif old_mode == InteractionMode.COMBAT and new_mode != InteractionMode.COMBAT:
            # Leaving combat mode
            logger.debug(f"Leaving COMBAT mode for {new_mode.name}. Resetting combat transition flags.")
            self.is_transitioning_to_combat = False # Explicitly reset
            self.combat_narrative_buffer = [] # Clear any residual buffer
            # CombatManager itself is cleared by GameEngine or mode_transitions logic
            # when combat actually ends (e.g., PLAYER_DEFEAT, VICTORY).
            # This method simply reacts to the mode having been changed.
            if self.combat_manager:
                 logger.info(f"Combat mode ended. Last CombatManager state: {self.combat_manager.state.name if self.combat_manager.state else 'N/A'}")
            # self.combat_manager = None # This is typically done by the Engine when combat fully resolves.

        elif self.is_transitioning_to_combat and new_mode != InteractionMode.COMBAT:
            # If we were in the process of transitioning TO combat, but are now
            # being set to a different mode (e.g., error, or immediate override),
            # then cancel the combat transition state.
            logger.warning(f"Combat transition was in progress, but now switching to {new_mode.name}. Resetting transition flags.")
            self.is_transitioning_to_combat = False
            self.combat_narrative_buffer = []

        # Reset mode-specific state based on the mode we are *leaving*
        if old_mode in [InteractionMode.COMBAT, InteractionMode.SOCIAL_CONFLICT]:
            if new_mode not in [InteractionMode.COMBAT, InteractionMode.SOCIAL_CONFLICT]:
                logger.debug(f"Clearing current_combatants list when leaving {old_mode.name} for {new_mode.name}.")
                self.current_combatants = []
        
        if old_mode == InteractionMode.TRADE:
            if new_mode != InteractionMode.TRADE:
                logger.debug(f"Clearing current_trade_partner_id when leaving TRADE for {new_mode.name}.")
                self.current_trade_partner_id = None

        # Set the new mode
        self.current_mode = new_mode
        logger.info(f"Interaction mode is now set to {self.current_mode.name}")

    def to_dict(self) -> Dict[str, Any]:
        """Convert GameState to a dictionary for serialization."""
        result = {
            "session_id": self.session_id,
            "created_at": self.created_at,
            "last_saved_at": self.last_saved_at or time.time(),
            "game_version": self.game_version,
            "player": self.player.to_dict(),
            "world": self.world.to_dict(),
            "conversation_history": self.conversation_history,
            "event_log": self.event_log,
            "last_command": self.last_command,
            # Interaction Mode State
            "current_mode": self.current_mode.name,  # Store enum name as string
            "current_combatants": self.current_combatants,
            "current_trade_partner_id": self.current_trade_partner_id,
            "mode_transition_cooldowns": self.mode_transition_cooldowns,
            "is_transitioning_to_combat": self.is_transitioning_to_combat,
            "combat_narrative_buffer": self.combat_narrative_buffer,
        }
        
        # Include journal if present
        if hasattr(self, 'journal') and isinstance(self.journal, dict):
            result["journal"] = self.journal
        
        # Add combat_manager if it exists
        if self.combat_manager is not None:
            result["combat_manager"] = self.combat_manager.to_dict()
            
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GameState':
        """Create a GameState from a dictionary."""
        player_data = data.get("player", {})
        world_data = data.get("world", {})
        
        game_state = cls(
            session_id=data.get("session_id", str(uuid.uuid4())),
            created_at=data.get("created_at", time.time()),
            last_saved_at=data.get("last_saved_at"),
            game_version=data.get("game_version", "0.1.0"),
            player=PlayerState.from_dict(player_data),
            world=WorldState.from_dict(world_data),
            conversation_history=data.get("conversation_history", []),
            last_command=data.get("last_command"),
            # Load Interaction Mode State
            current_combatants=data.get("current_combatants", []),
            current_trade_partner_id=data.get("current_trade_partner_id"),
            mode_transition_cooldowns=data.get("mode_transition_cooldowns", {}),
            is_transitioning_to_combat=data.get("is_transitioning_to_combat", False),
            combat_narrative_buffer=data.get("combat_narrative_buffer", []),
        )

        # Convert stored mode name back to enum
        mode_name = data.get("current_mode", InteractionMode.NARRATIVE.name)
        try:
            game_state.current_mode = InteractionMode[mode_name]
        except KeyError:
            logger.warning(f"Unknown interaction mode '{mode_name}' found in save data. Defaulting to NARRATIVE.")
            game_state.current_mode = InteractionMode.NARRATIVE
        
        # Restore journal if present
        if "journal" in data and isinstance(data["journal"], dict):
            game_state.journal = data["journal"]
        
        # Restore event log if present
        if "event_log" in data and isinstance(data["event_log"], list):
            game_state.event_log = data["event_log"]
        else:
            game_state.event_log = []
        
        # Load combat_manager if it exists in data
        if "combat_manager" in data:
            from core.combat.combat_manager import CombatManager
            game_state.combat_manager = CombatManager.from_dict(data["combat_manager"])
            
        return game_state

```

### File: core\base\state\player_state.py

```python
"""
Player state for the RPG game.

This module provides the PlayerState class for managing player information.
"""

import uuid
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, TYPE_CHECKING

from core.utils.logging_config import get_logger
from core.interaction.social_effects import StatusEffectData # Import StatusEffectData

# Get the module logger
logger = get_logger("PLAYER")

@dataclass
class PlayerState:
    """
    Player state information.

    This dataclass contains all persistent information about the player,
    including basic attributes, location, and derived stats.
    """
    # Basic player information
    name: str
    race: str = "Human"  # Default race
    path: str = "Wanderer"  # Default path/class
    background: str = "Commoner"  # Default background
    sex: str = "Male"  # Default sex/gender
    origin_id: Optional[str] = None # Added origin_id

    # Player attributes
    level: int = 1
    experience: int = 0

    # Stats manager ID - reference to the stats manager for this player
    stats_manager_id: Optional[str] = None

    # Location
    current_location: str = ""
    current_district: str = ""

    # Inventory (to be properly integrated later)
    inventory_id: Optional[str] = None
    equipped_items: Dict[str, str] = field(default_factory=dict)  # slot -> item_id

    # Active quests (to be properly integrated later)
    active_quests: List[str] = field(default_factory=list)  # quest_ids
    completed_quests: List[str] = field(default_factory=list)  # quest_ids

    # Dynamic state related to social/combat
    current_resolve: float = 0.0 # Current social 'health'
    active_social_effects: List[StatusEffectData] = field(default_factory=list)

    # Character appearance
    character_image: Optional[str] = None

    @property
    def experience_to_next_level(self) -> int:
        """
        Calculate the experience required to reach the next level.

        This is a simple formula: 100 * current level
        Can be adjusted for different game progression rates.

        Returns:
            The experience points needed to level up.
        """
        return 100 * self.level

    def to_dict(self) -> Dict[str, Any]:
        """Convert PlayerState to a dictionary for serialization."""
        return {
            "name": self.name,
            "race": self.race,
            "path": self.path,
            "background": self.background,
            "sex": self.sex,
            "origin_id": self.origin_id, # Added
            "level": self.level,
            "experience": self.experience,
            "stats_manager_id": self.stats_manager_id,
            "current_location": self.current_location,
            "current_district": self.current_district,
            "inventory_id": self.inventory_id,
            "equipped_items": self.equipped_items,
            "active_quests": self.active_quests,
            "completed_quests": self.completed_quests,
            "character_image": self.character_image,
            "current_resolve": self.current_resolve,
            "active_social_effects": [effect.to_dict() for effect in self.active_social_effects],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PlayerState':
        """Create a PlayerState from a dictionary."""
        return cls(
            name=data.get("name", "Unknown"),
            race=data.get("race", "Human"),
            path=data.get("path", "Wanderer"),
            background=data.get("background", "Commoner"),
            sex=data.get("sex", "Male"),
            origin_id=data.get("origin_id"), # Added
            level=data.get("level", 1),
            experience=data.get("experience", 0),
            stats_manager_id=data.get("stats_manager_id"),
            current_location=data.get("current_location", ""),
            current_district=data.get("current_district", ""),
            inventory_id=data.get("inventory_id"),
            equipped_items=data.get("equipped_items", {}),
            active_quests=data.get("active_quests", []),
            completed_quests=data.get("completed_quests", []),
            character_image=data.get("character_image"),
            current_resolve=data.get("current_resolve", 0.0),
            active_social_effects=[
                StatusEffectData.from_dict(effect_data)
                for effect_data in data.get("active_social_effects", [])
            ]
        )
```

### File: core\base\state\state_manager.py

```python
"""
State manager for the RPG game.

This module provides the StateManager class for managing game state.
"""

import os
import uuid
import datetime
import json
from typing import Dict, List, Optional, Any
from core.stats.stats_base import StatType
from PySide6.QtCore import QTimer
from core.base.state.game_state import GameState
from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.character.npc_system import NPCSystem
from core.character.npc_base import NPCInteractionType
from core.stats.modifier import ModifierSource, StatModifier, ModifierType
from core.stats.stats_base import StatType
from core.utils.logging_config import get_logger
from core.utils.json_utils import save_json, load_json
from core.base.config import get_config

# Get the module logger
logger = get_logger("STATE")

class StateManager:
    """
    Manager for game state.
    
    This class handles creating, loading, and saving game states.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(StateManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self, saves_dir: Optional[str] = None):
        """Initialize the state manager."""
        if self._initialized:
            return
        
        # Get configuration
        config = get_config()
        self._saves_dir = saves_dir or config.get("system.save_dir", "saves")
        
        # Create saves directory if it doesn't exist
        os.makedirs(self._saves_dir, exist_ok=True)
        
        # Current game state
        self._current_state: Optional[GameState] = None
        
        # Last deleted save (for undo)
        self._last_deleted_save: Optional[Dict[str, Any]] = None
        
        # Stats manager instance (set when creating or loading a game)
        self._stats_manager = None
        
        self._initialized = True
    
    @property
    def current_state(self) -> Optional[GameState]:
        """Get the current game state."""
        return self._current_state
    
    # Compatibility property for web server
    @property
    def state(self) -> Optional[GameState]:
        """Compatibility property for web server to access the current state."""
        return self._current_state
    
    @property
    def stats_manager(self):
        """Get the stats manager for the current player."""
        if self._stats_manager is None and self._current_state is not None:
            # Get stats manager singleton
            try:
                from core.stats.stats_manager import get_stats_manager
                self._stats_manager = get_stats_manager()
                
                # Link stats manager ID with player
                if self._current_state.player.stats_manager_id is None:
                    self._current_state.player.stats_manager_id = str(uuid.uuid4())
                
                # Do not emit signals automatically here - UI components will request stats when needed
                # This prevents duplicate updates and reduces unnecessary processing
                # UI components like CharacterSheetWidget will directly request stats when needed
            except Exception as e:
                logger.error(f"Failed to initialize stats manager: {e}")
        
        return self._stats_manager
                
    def ensure_stats_manager_initialized(self):
        """Ensure the stats manager is initialized."""
        # Simply access the property to ensure initialization
        return self.stats_manager
        
    def get_npc_system(self) -> Optional['NPCSystem']:
        """Get the NPC system instance."""
        if self._npc_system is None:
            # Try to initialize NPC system if needed
            try:
                from core.character.npc_system import NPCSystem
                self._npc_system = NPCSystem()
                logger.info("NPC system initialized")
            except Exception as e:
                logger.error(f"Failed to initialize NPC system: {e}")
        
        return self._npc_system
        
    def set_npc_system(self, npc_system: 'NPCSystem') -> None:
        """Set the NPC system instance."""
        self._npc_system = npc_system
    
    def create_new_game(self, player_name: str, race: str = "Human", 
                       path: str = "Wanderer", background: str = "Commoner",
                       sex: str = "Male", character_image: Optional[str] = None,
                       stats: Optional[Dict[str, int]] = None,
                       origin_id: Optional[str] = None) -> GameState: # Added origin_id parameter
        """
        Create a new game state.
        
        Args:
            player_name: The name of the player character.
            race: The race of the player character.
            path: The class/path of the player character.
            background: The background of the player character.
            sex: The sex/gender of the player character.
            character_image: Path to the character's portrait image.
            stats: Optional dictionary of starting stats.
            origin_id: The ID of the player's chosen origin.
        
        Returns:
            The new game state.
        """
        logger.info(f"Creating new game for player {player_name}, origin: {origin_id}")
        
        # Create player state
        player = PlayerState(
            name=player_name,
            race=race,
            path=path,
            background=background,
            sex=sex,
            character_image=character_image,
            stats_manager_id=str(uuid.uuid4()),
            origin_id=origin_id # Set origin_id
        )
        
        # Create world state (default values)
        world = WorldState()
        
        # Create game state
        self._current_state = GameState(
            player=player,
            world=world,
        )
        
        # Initialize stats manager - use singleton instance
        try:
            from core.stats.stats_manager import get_stats_manager
            self._stats_manager = get_stats_manager()
            
            # Ensure the singleton StatsManager starts from a clean slate for the new game
            try:
                if hasattr(self._stats_manager, 'reset_for_new_game'):
                    self._stats_manager.reset_for_new_game()
                    logger.info("StatsManager reset to a clean state for new game.")
            except Exception as e_reset:
                logger.warning(f"Failed to fully reset StatsManager for new game: {e_reset}")
            
            # Add comprehensive logging
            logger.info(f"Stats manager initialized for player {player_name}")
            
            # Log whether custom stats were provided
            if stats:
                logger.info(f"Custom stats provided for player {player_name}: {stats}")
            else:
                logger.info(f"No custom stats provided for player {player_name}, using defaults")
            
            # First clear any existing race/class modifiers if stats are being set manually
            # This helps ensure clean application of custom stats
            if stats:

                self._stats_manager.remove_modifiers_by_source(ModifierSource.RACIAL)
                self._stats_manager.remove_modifiers_by_source(ModifierSource.CLASS)
                logger.debug("Cleared existing race and class modifiers before applying custom stats")
            
            # Apply custom stats if provided
            if stats:
                for stat_name, value in stats.items():
                    try:
                        stat_type = StatType.from_string(stat_name.upper())
                        self._stats_manager.set_base_stat(stat_type, value)
                        logger.info(f"Set {stat_name} to {value} from custom stats")
                    except Exception as e:
                        logger.warning(f"Failed to set custom stat {stat_name}: {e}")
                
                # Make sure all stats are recalculated properly
                self._stats_manager._recalculate_derived_stats()
                logger.info("Recalculated derived stats after setting custom stats")
            
            # Apply race modifiers from config file
            try:
                # Load race configuration 
                import os, json
                project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
                race_config_path = os.path.join(project_root, "config", "character", "races.json")
                
                if os.path.exists(race_config_path):
                    with open(race_config_path, 'r') as f:
                        race_data = json.load(f)
                        
                    if race in race_data.get("races", {}):
                        race_modifiers = race_data["races"][race].get("stat_modifiers", {})
                        for stat_name, modifier in race_modifiers.items():
                            try:
                                stat_type = StatType.from_string(stat_name.upper())
                                # Create and add the modifier instead of changing base stat
                                race_modifier = StatModifier(
                                    stat=stat_type,
                                    value=modifier,
                                    source_type=ModifierSource.RACIAL,
                                    source_name=f"{race} Racial Bonus",
                                    modifier_type=ModifierType.PERMANENT,
                                    is_percentage=False,
                                    duration=None
                                )
                                self._stats_manager.add_modifier(race_modifier)
                                logger.info(f"Applied race modifier {stat_name}: {modifier}")
                            except Exception as e:
                                logger.warning(f"Failed to apply race modifier for {stat_name}: {e}")
            except Exception as e:
                logger.warning(f"Failed to apply race modifiers: {e}")
            
            # Apply class modifiers from config file
            try:
                class_config_path = os.path.join(project_root, "config", "character", "classes.json")
                
                if os.path.exists(class_config_path):
                    with open(class_config_path, 'r') as f:
                        class_data = json.load(f)
                        
                    if path in class_data.get("classes", {}):
                        class_modifiers = class_data["classes"][path].get("stat_modifiers", {})
                        for stat_name, modifier in class_modifiers.items():
                            try:
                                stat_type = StatType.from_string(stat_name.upper())
                                # Create and add the modifier instead of changing base stat
                                class_modifier = StatModifier(
                                    stat=stat_type,
                                    value=modifier,
                                    source_type=ModifierSource.CLASS,
                                    source_name=f"{path} Class Bonus",
                                    modifier_type=ModifierType.PERMANENT,
                                    is_percentage=False,
                                    duration=None
                                )
                                self._stats_manager.add_modifier(class_modifier)
                                logger.info(f"Applied class modifier {stat_name}: {modifier}")
                            except Exception as e:
                                logger.warning(f"Failed to apply class modifier for {stat_name}: {e}")
            except Exception as e:
                logger.warning(f"Failed to apply class modifiers: {e}")
            
            # Log final stats after all modifications
            try:
                all_stats = self._stats_manager.get_all_stats()
                logger.info(f"Final character stats after creation:")
                
                # Log primary stats
                if "primary" in all_stats:
                    primary_stats_list = []
                    for stat_key, stat_data_val in all_stats['primary'].items():
                        if isinstance(stat_data_val, dict): # New structure
                            primary_stats_list.append(f"{stat_key}={stat_data_val.get('value')}")
                        else: # Old structure (direct value)
                            primary_stats_list.append(f"{stat_key}={stat_data_val}")
                    logger.info(f"Primary stats: {', '.join(primary_stats_list)}")

                # Log derived stats
                for category in ["combat", "resources", "social", "other"]:
                    if category in all_stats and all_stats[category]:
                        cat_stats_list = []
                        for stat_key, stat_data_val in all_stats[category].items():
                            if isinstance(stat_data_val, dict): # New structure
                                cat_stats_list.append(f"{stat_key}={stat_data_val.get('value')}")
                            else: # Old structure
                                 cat_stats_list.append(f"{stat_key}={stat_data_val}")
                        logger.info(f"{category.capitalize()} stats: {', '.join(cat_stats_list)}")
            except Exception as e:
                logger.error(f"Error logging final character stats: {e}")
            
        except Exception as e:
            logger.error(f"Failed to initialize stats manager: {e}")
        
        # Initialize inventory manager and connect to stats manager
        self._connect_inventory_and_stats_managers()
        
        # Initialize memory/context system
        self.initialize_memory_context(self._current_state)
        
        # Explicitly ensure stats manager is initialized and signal is emitted
        self.ensure_stats_manager_initialized()
        
        logger.info(f"New game created with session ID {self._current_state.session_id}")
        return self._current_state
    
    def save_game(self, filename: Optional[str] = None, 
                 auto_save: bool = False) -> Optional[str]:
        """
        Save the current game state.
        
        This method saves the full game state including stats, memory/context information,
        equipment, and quest data if those systems are implemented.
        
        Args:
            filename: The name of the save file. If None, uses a default name.
            auto_save: Whether this is an auto-save.
        
        Returns:
            The path to the save file, or None if the save failed.
        """
        if self._current_state is None:
            logger.error("Cannot save: No current game state")
            return None
        
        # Update last saved time
        self._current_state.last_saved_at = datetime.datetime.now().timestamp()
        
        # Generate filename if not provided
        if filename is None:
            player_name = self._current_state.player.name
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            prefix = "auto_" if auto_save else ""
            filename = f"{prefix}{player_name}_{timestamp}.json"
        
        # Ensure filename has .json extension
        if not filename.endswith(".json"):
            filename += ".json"
        
        # Prepare full state dict with enhanced data
        state_dict = self._current_state.to_dict()
        
        # Add stats data if available
        try:
            if self.stats_manager is not None:
                stats_data = self.stats_manager.to_dict()
                state_dict['character_stats'] = stats_data
                logger.info("Including character stats data in save")
        except Exception as e:
            logger.warning(f"Error including stats data in save: {e}")
        
        # Add memory/context data if available
        try:
            # This will be expanded when memory/context modules are implemented
            if hasattr(self, 'get_memory_context_data'):
                memory_data = self.get_memory_context_data()
                if memory_data:
                    state_dict['memory_context'] = memory_data
                    logger.info("Including memory/context data in save")
        except Exception as e:
            logger.warning(f"Error including memory/context data in save: {e}")
        
        # Add enhanced inventory/equipment data if available
        try:
            if self._current_state.player.inventory_id:
                from core.inventory.item_manager import get_inventory_manager
                inv_manager = get_inventory_manager()
                if inv_manager:
                    inventory_data = inv_manager.to_dict()
                    state_dict['detailed_inventory'] = inventory_data
                    logger.info("Including detailed inventory data in save")
        except Exception as e:
            logger.warning(f"Error including detailed inventory data in save: {e}")
        
        # Add quest data if available (future implementation)
        try:
            if hasattr(self._current_state, 'quests') and self._current_state.quests:
                state_dict['detailed_quests'] = self._current_state.quests
                logger.info("Including detailed quest data in save")
        except Exception as e:
            logger.warning(f"Error including quest data in save: {e}")
        
        # Save state
        try:
            save_path = os.path.join(self._saves_dir, filename)
            save_json(state_dict, save_path)
            
            logger.info(f"Game saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Error saving game: {e}")
            return None
    
    def load_game(self, filename: str) -> Optional[GameState]:
        """
        Load a game state from a file.
        
        This method loads the full game state including stats, memory/context information,
        equipment, and quest data if those were included in the save.
        
        Args:
            filename: The name of the save file.
        
        Returns:
            The loaded game state, or None if the load failed.
        """
        # Ensure filename has .json extension
        if not filename.endswith(".json"):
            filename += ".json"
        
        # Load state
        try:
            load_path = os.path.join(self._saves_dir, filename)
            if not os.path.exists(load_path):
                logger.error(f"Save file not found: {load_path}")
                return None
            
            data = load_json(load_path)
            self._current_state = GameState.from_dict(data)
            
            # Restore stats data if available
            if 'character_stats' in data:
                try:
                    from core.stats.stats_manager import get_stats_manager
                    self._stats_manager = get_stats_manager()
                    # Load saved stats into the singleton instance
                    if isinstance(data['character_stats'], dict):
                        for stat_type, stat_dict in data['character_stats'].get('stats', {}).items():
                            if 'base_value' in stat_dict:
                                try:
                                    self._stats_manager.set_base_stat(stat_type, stat_dict['base_value'])
                                except Exception as e:
                                    logger.warning(f"Failed to restore stat {stat_type}: {e}")
                    # Make sure to recalculate derived stats and emit signal
                    self._stats_manager._recalculate_derived_stats()
                    logger.info("Recalculated derived stats and emitted stats_changed signal")
                    logger.info("Restored character stats data from save")
                except Exception as e:
                    logger.warning(f"Error restoring character stats data: {e}")
                    
            # Restore memory/context data if available
            if 'memory_context' in data:
                try:
                    # This will be expanded when memory/context modules are implemented
                    if hasattr(self, 'restore_memory_context_data'):
                        self.restore_memory_context_data(data['memory_context'])
                        logger.info("Restored memory/context data from save")
                except Exception as e:
                    logger.warning(f"Error restoring memory/context data: {e}")
            
            # Restore detailed inventory/equipment data if available
            if 'detailed_inventory' in data:
                try:
                    from core.inventory.item_manager import get_inventory_manager
                    inv_manager = get_inventory_manager()
                    if inv_manager:
                        inv_manager.load_from_dict(data['detailed_inventory'])
                        logger.info("Restored detailed inventory data from save")
                        
                        # Update inventory ID in player state if needed
                        if not self._current_state.player.inventory_id and inv_manager.inventory_id:
                            self._current_state.player.inventory_id = inv_manager.inventory_id
                except Exception as e:
                    logger.warning(f"Error restoring detailed inventory data: {e}")
            
            # Restore quest data if available (future implementation)
            if 'detailed_quests' in data:
                try:
                    # This would set up the quest manager when implemented
                    if hasattr(self._current_state, 'quests'):
                        self._current_state.quests = data['detailed_quests']
                        logger.info("Restored detailed quest data from save")
                except Exception as e:
                    logger.warning(f"Error restoring quest data: {e}")
            
            # Connect inventory and stats managers for equipment modifier synchronization
            self._connect_inventory_and_stats_managers()
            
            # Explicitly ensure stats manager is initialized and signal is emitted
            self.ensure_stats_manager_initialized()

            # If we loaded during combat, rehydrate the combat UI and sync stats
            try:
                if self._current_state and getattr(self._current_state, 'current_mode', None) and \
                   self._current_state.current_mode.name == 'COMBAT' and \
                   getattr(self._current_state, 'combat_manager', None):
                    cm = self._current_state.combat_manager
                    # Ensure NPC StatsManagers are available/linked by loading NPC system state and prepping NPCs
                    try:
                        npc_system = self.get_npc_system()
                        if npc_system:
                            # Load NPCs from persistence if available (best effort)
                            try:
                                npc_system.load_state()
                            except Exception as e_load_npcs:
                                logger.warning(f"NPCSystem.load_state failed during load_game: {e_load_npcs}")
                            # Prepare each non-player entity for combat to guarantee StatsManagers exist (fallback by name)
                            try:
                                player_id = getattr(self._current_state.player, 'id', None) or getattr(self._current_state.player, 'stats_manager_id', None)
                                for entity_id, entity in getattr(cm, 'entities', {}).items():
                                    if entity_id != player_id:
                                        try:
                                            npc_system.prepare_npc_for_interaction(
                                                getattr(entity, 'name', None) or getattr(entity, 'combat_name', ''),
                                                NPCInteractionType.COMBAT
                                            )
                                        except Exception:
                                            # Best-effort per-entity; continue on errors
                                            continue
                            except Exception as e_prep:
                                logger.warning(f"Error preparing NPCs for combat after load: {e_prep}")
                    except Exception as e_link:
                        logger.warning(f"NPC StatsManager linkage step failed: {e_link}")
                    # Sync StatsManagers to saved CombatEntity values
                    try:
                        cm.sync_stats_with_managers_from_entities()
                    except Exception as e:
                        logger.warning(f"Failed to sync stats from combat entities after load: {e}")

                    # Queue a BUFFER_FLUSH to repopulate the Combat Log from display_log
                    try:
                        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                        from core.base.engine import get_game_engine
                        engine = get_game_engine()
                        # Bind orchestrator to the loaded CombatManager so resume signals work
                        try:
                            if hasattr(engine, '_combat_orchestrator') and cm is not None:
                                engine._combat_orchestrator.set_combat_manager(cm)
                                logger.info("Bound loaded CombatManager to CombatOutputOrchestrator.")
                        except Exception as bind_err:
                            logger.warning(f"Failed to bind CombatManager to orchestrator after load: {bind_err}")
                        html_snapshot = getattr(cm, 'display_log_html', "")
                        if html_snapshot:
                            set_event = DisplayEvent(
                                type=DisplayEventType.COMBAT_LOG_SET_HTML,
                                content=html_snapshot,
                                role='system',
                                target_display=DisplayTarget.COMBAT_LOG,
                                gradual_visual_display=False,
                                tts_eligible=False,
                                source_step='REHYDRATE_FROM_SAVE',
                                metadata={"session_id": self._current_state.session_id if self._current_state else None}
                            )
                            # Option A: enqueue synchronously to avoid cross-session leakage/race
                            try:
                                engine._combat_orchestrator.add_event_to_queue(set_event)
                            except Exception as e_enq:
                                logger.warning(f"Failed to enqueue COMBAT_LOG_SET_HTML synchronously: {e_enq}")
                        # Additionally, sync the player's resource bars (HP/MP/Stamina) via Phase 2 UI events
                        try:
                            from core.stats.stats_base import DerivedStatType
                            from core.combat.combat_entity import EntityType
                            player_entity_id = None
                            for eid, e in getattr(cm, 'entities', {}).items():
                                if getattr(e, 'entity_type', None) == EntityType.PLAYER:
                                    player_entity_id = eid
                                    break
                            sm_local = self.stats_manager
                            if player_entity_id and sm_local and hasattr(engine, '_combat_orchestrator'):
                                # Build and enqueue Phase 2 events for HP, Stamina, and Mana
                                try:
                                    hp_cur = sm_local.get_current_stat_value(DerivedStatType.HEALTH)
                                    hp_max = sm_local.get_stat_value(DerivedStatType.MAX_HEALTH)
                                    ev_hp = DisplayEvent(
                                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                        content={},
                                        metadata={"entity_id": player_entity_id, "bar_type": "hp", "final_new_value": hp_cur, "max_value": hp_max, "session_id": self._current_state.session_id if self._current_state else None},
                                        target_display=DisplayTarget.COMBAT_LOG,
                                        source_step='REHYDRATE_FROM_SAVE'
                                    )
                                    # Option A: enqueue synchronously
                                    try:
                                        engine._combat_orchestrator.add_event_to_queue(ev_hp)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                                try:
                                    stam_cur = sm_local.get_current_stat_value(DerivedStatType.STAMINA)
                                    stam_max = sm_local.get_stat_value(DerivedStatType.MAX_STAMINA)
                                    ev_st = DisplayEvent(
                                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                        content={},
                                        metadata={"entity_id": player_entity_id, "bar_type": "stamina", "final_new_value": stam_cur, "max_value": stam_max, "session_id": self._current_state.session_id if self._current_state else None},
                                        target_display=DisplayTarget.COMBAT_LOG,
                                        source_step='REHYDRATE_FROM_SAVE'
                                    )
                                    # Option A: enqueue synchronously
                                    try:
                                        engine._combat_orchestrator.add_event_to_queue(ev_st)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                                try:
                                    mana_cur = sm_local.get_current_stat_value(DerivedStatType.MANA)
                                    mana_max = sm_local.get_stat_value(DerivedStatType.MAX_MANA)
                                    ev_mp = DisplayEvent(
                                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                        content={},
                                        metadata={"entity_id": player_entity_id, "bar_type": "mana", "final_new_value": mana_cur, "max_value": mana_max, "session_id": self._current_state.session_id if self._current_state else None},
                                        target_display=DisplayTarget.COMBAT_LOG,
                                        source_step='REHYDRATE_FROM_SAVE'
                                    )
                                    # Option A: enqueue synchronously
                                    try:
                                        engine._combat_orchestrator.add_event_to_queue(ev_mp)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                        except Exception as e_syncbars:
                            logger.warning(f"Failed to enqueue player resource bar sync events after load: {e_syncbars}")
                    except Exception as e:
                        logger.warning(f"Failed to queue combat log rehydrate event: {e}")
            except Exception as e:
                logger.warning(f"Combat rehydrate block failed: {e}")
            
            logger.info(f"Game loaded from {load_path}")
            return self._current_state
        except Exception as e:
            logger.error(f"Error loading game: {e}")
            return None
    
    def get_available_saves(self) -> List[Dict[str, Any]]:
        """
        Get a list of available save files.
        
        Returns:
            A list of dictionaries with information about each save file.
        """
        saves = []
        
        try:
            for filename in os.listdir(self._saves_dir):
                if filename.endswith(".json"):
                    file_path = os.path.join(self._saves_dir, filename)
                    try:
                        # Get file info
                        stat = os.stat(file_path)
                        
                        # Try to read basic save info without loading the whole state
                        with open(file_path, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                            
                            # Extract basic info
                            save_info = {
                                "filename": filename,
                                "player_name": data.get("player", {}).get("name", "Unknown"),
                                "level": data.get("player", {}).get("level", 1),
                                "created_at": data.get("created_at", 0),
                                "last_saved_at": data.get("last_saved_at", 0),
                                "location": data.get("player", {}).get("current_location", "Unknown"),
                                "file_size": stat.st_size,
                                "mod_time": stat.st_mtime,
                                "is_auto_save": filename.startswith("auto_"),
                            }
                            
                            saves.append(save_info)
                    except Exception as e:
                        logger.warning(f"Error reading save file {filename}: {e}")
                        # Include basic file info even if we couldn't read the full save
                        saves.append({
                            "filename": filename,
                            "mod_time": os.path.getmtime(file_path),
                            "file_size": os.path.getsize(file_path),
                            "error": str(e),
                        })
        except Exception as e:
            logger.error(f"Error listing save files: {e}")
        
        # Sort by last modified time, newest first
        saves.sort(key=lambda x: x.get("mod_time", 0), reverse=True)
        
        return saves
    
    def delete_save(self, filename: str) -> bool:
        """
        Delete a save file.
        
        Args:
            filename: The name of the save file.
        
        Returns:
            True if the file was deleted, False otherwise.
        """
        # Ensure filename has .json extension
        if not filename.endswith(".json"):
            filename += ".json"
        
        # Delete the file
        try:
            file_path = os.path.join(self._saves_dir, filename)
            
            # Store file info for undo
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    self._last_deleted_save = {
                        "filename": filename,
                        "content": f.read(),
                    }
            
            # Delete the file
            os.remove(file_path)
            
            logger.info(f"Save file deleted: {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error deleting save file: {e}")
            return False
    
    def undo_delete(self) -> bool:
        """
        Undo the last save file deletion.
        
        Returns:
            True if the deletion was undone, False otherwise.
        """
        if self._last_deleted_save is None:
            logger.warning("No save file deletion to undo")
            return False
        
        try:
            filename = self._last_deleted_save["filename"]
            content = self._last_deleted_save["content"]
            
            file_path = os.path.join(self._saves_dir, filename)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.info(f"Restored deleted save file: {file_path}")
            
            # Clear the stored deleted save
            self._last_deleted_save = None
            
            return True
        except Exception as e:
            logger.error(f"Error restoring deleted save file: {e}")
            return False

    def initialize_memory_context(self, game_state: GameState) -> None:
        """
        Initialize memory and context system for a new game state.
        
        This is a stub method that will be implemented when the memory/context
        system is fully developed. For now, it does nothing but log the call.
        
        Args:
            game_state: The game state to initialize memory/context for.
        """
        logger.info("Memory/context initialization stub called (not fully implemented)")
        # Will be implemented when memory/context modules are added
    
    def get_memory_context_data(self) -> Optional[Dict[str, Any]]:
        """
        Get memory and context data for saving.
        
        This is a stub method that will be implemented when the memory/context
        system is fully developed. For now, it returns minimal placeholder data.
        
        Returns:
            A dictionary of memory/context data, or None if not available.
        """
        logger.info("Memory/context data retrieval stub called (not fully implemented)")
        # Placeholder for future implementation
        return {
            "version": "0.1.0",
            "memory_entries": [],
            "context_state": {}
        }
    
    def restore_memory_context_data(self, data: Dict[str, Any]) -> None:
        """
        Restore memory and context data from a save.
        
        This is a stub method that will be implemented when the memory/context
        system is fully developed. For now, it does nothing but log the call.
        
        Args:
            data: The memory/context data to restore.
        """
        logger.info("Memory/context restoration stub called (not fully implemented)")
        # Will be implemented when memory/context modules are added
    
    def _connect_inventory_and_stats_managers(self) -> None:
        """
        Connect the inventory manager and stats manager for equipment modifier synchronization.
        
        This establishes the bidirectional connection so that equipment changes
        automatically update stat modifiers.
        """
        try:
            # Get both managers
            stats_manager = self.stats_manager  # This property handles initialization
            
            if not stats_manager:
                logger.warning("Stats manager not available for inventory connection")
                return
            
            # Get inventory manager singleton
            from core.inventory.item_manager import get_inventory_manager
            inventory_manager = get_inventory_manager()
            
            if not inventory_manager:
                logger.warning("Inventory manager not available for stats connection")
                return
            
            # Establish bidirectional connection
            stats_manager.set_inventory_manager(inventory_manager)
            inventory_manager.set_stats_manager(stats_manager)
            
            # Trigger initial equipment modifier synchronization
            if hasattr(inventory_manager, '_equipment_modifiers') and inventory_manager._equipment_modifiers:
                stats_manager.sync_equipment_modifiers()
                logger.info("Initial equipment modifier synchronization completed")
            
            logger.info("Successfully connected inventory and stats managers")
            
        except Exception as e:
            logger.error(f"Error connecting inventory and stats managers: {e}", exc_info=True)


# Convenience function
def get_state_manager() -> StateManager:
    """Get the state manager instance."""
    return StateManager()

```

### File: core\base\state\stats_integration.py

```python
"""
Stats integration module for connecting the stats system to the GUI.

This module provides functionality to integrate the stats system with the GUI,
ensuring that the stats tab in the GUI is always up to date.
"""

import logging
from typing import Dict, Any, Optional, Callable
from PySide6.QtCore import QObject, Signal, Slot

from core.base.state.state_manager import StateManager, get_state_manager
from core.stats.stats_base import StatType, DerivedStatType, Stat

# Get module logger
logger = logging.getLogger("STATS_INTEGRATION")

class StatsIntegration(QObject):
    """
    Class for integrating stats with the GUI.
    
    This class provides signals for stats changes and methods for updating the GUI.
    It acts as a bridge between the stats system and the GUI.
    """
    
    # Signal emitted when stats change
    stats_changed = Signal(dict)
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(StatsIntegration, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the stats integration."""
        if self._initialized:
            return
            
        super().__init__()
        
        # State manager reference
        self._state_manager = get_state_manager()
        
        # Last known stats state
        self._last_stats = {}
        
        # Callbacks for specific stat changes
        self._stat_callbacks = {}
        
        self._initialized = True
        
        logger.info("Stats integration initialized")
    
    def update_gui(self):
        """
        Update the GUI with the current stats.
        
        This method retrieves the current stats from the stats manager
        and emits the stats_changed signal if they have changed.
        """
        if not self._state_manager or not self._state_manager.stats_manager:
            logger.debug("Stats manager not available")
            return
        
        try:
            # Get all stats
            current_stats = self._state_manager.stats_manager.get_all_stats()
            
            # Check if stats have changed
            if current_stats != self._last_stats:
                # Store the new stats
                self._last_stats = current_stats
                
                # Emit signal with the stats
                self.stats_changed.emit(current_stats)
                
                # Call any registered callbacks
                self._call_stat_callbacks(current_stats)
                
                logger.debug("Stats updated in GUI")
        except Exception as e:
            logger.error(f"Error updating stats in GUI: {e}")
    
    def register_stat_callback(self, stat_name: str, callback: Callable[[Any], None]):
        """
        Register a callback for a specific stat.
        
        Args:
            stat_name: The name of the stat (e.g., "strength", "health").
            callback: The callback function to call when the stat changes.
                     The function should take a single argument, which is the stat value.
        """
        if stat_name not in self._stat_callbacks:
            self._stat_callbacks[stat_name] = []
        
        self._stat_callbacks[stat_name].append(callback)
        logger.debug(f"Registered callback for stat: {stat_name}")
    
    def unregister_stat_callback(self, stat_name: str, callback: Callable[[Any], None]):
        """
        Unregister a callback for a specific stat.
        
        Args:
            stat_name: The name of the stat.
            callback: The callback function to unregister.
        """
        if stat_name in self._stat_callbacks:
            if callback in self._stat_callbacks[stat_name]:
                self._stat_callbacks[stat_name].remove(callback)
                logger.debug(f"Unregistered callback for stat: {stat_name}")
    
    def _call_stat_callbacks(self, stats: Dict[str, Dict[str, Dict[str, Any]]]):
        """
        Call registered callbacks for stats that have changed.
        
        Args:
            stats: The current stats dictionary.
        """
        # Iterate through all stat categories and stats
        for category, category_stats in stats.items():
            for stat_name, stat_info in category_stats.items():
                # Check if there are callbacks for this stat
                callbacks = self._stat_callbacks.get(stat_name.lower(), [])
                
                # Call each callback with the stat value
                for callback in callbacks:
                    try:
                        callback(stat_info)
                    except Exception as e:
                        logger.error(f"Error calling callback for stat {stat_name}: {e}")
    
    def attach_to_stat_manager(self):
        """
        Attach to the stats manager to receive updates.
        
        This method should be called after the stats manager is initialized.
        """
        try:
            from core.stats.stats_manager import StatsManager
            
            # Get stats manager instance
            stats_manager = self._state_manager.stats_manager
            
            if stats_manager:
                # Add this as an observer or hook into the stats manager's update methods
                # This will depend on how the stats manager is implemented
                
                # For now, we'll need to poll regularly or integrate with the stats manager
                # when it's fully implemented
                
                logger.info("Attached to stats manager")
                return True
            else:
                logger.warning("Stats manager not available")
                return False
        except Exception as e:
            logger.error(f"Error attaching to stats manager: {e}")
            return False


# Convenience function
def get_stats_integration() -> StatsIntegration:
    """Get the stats integration instance."""
    return StatsIntegration()

```

### File: core\base\state\world_state.py

```python
"""
World state for the RPG game.

This module provides the WorldState class for managing the game world.
"""

import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any

from core.utils.logging_config import get_logger
from core.utils.enhanced_time_manager import get_enhanced_time_manager
from core.base.state.calendar_state import CalendarState
from core.base.config import get_config

# Get the module logger
logger = get_logger("WORLD")

@dataclass
class WorldState:
    """
    World state information.
    
    This dataclass contains information about the game world,
    including time, weather, and global variables.
    """
    # Game time
    # Phase 1: Do not initialize from real-world time. Start from 0.0 and
    # advance explicitly via engine logic (LLM time_passage, etc.).
    game_time: float = 0.0  # Seconds since epoch (logical counter)
    game_date: str = "Day 1"  # In-game calendar date
    
    # Canonical calendar (era/cycle/phase/tide/span/day)
    calendar: CalendarState = field(default_factory=CalendarState)
    
    # World conditions
    weather: str = "Clear"
    is_day: bool = True
    
    # Special conditions
    magical_conditions: Dict[str, Any] = field(default_factory=dict)
    
    # Global variables (for quest states, world events, etc.)
    global_vars: Dict[str, Any] = field(default_factory=dict)
    
    # Active world events
    active_events: List[str] = field(default_factory=list)
    
    # For web server compatibility - will be updated by engine
    _current_location: str = ""
    
    @property
    def current_location(self) -> str:
        """
        Compatibility property for web server - returns the current location.
        This should be kept in sync with player.current_location.
        """
        return self._current_location
    
    @current_location.setter
    def current_location(self, value: str) -> None:
        """Set the current location."""
        self._current_location = value
    
    def advance_time(self, seconds: float) -> None:
        """
        Advance game time by the specified number of seconds.
        
        Args:
            seconds: Number of seconds to advance.
        """
        self.game_time += seconds
        
        # Recalculate canonical calendar from game time
        try:
            self.calendar.recalc_from_game_time(self.game_time)
            # Build rich calendar string (with names)
            self.game_date = self._build_calendar_string()
        except Exception as e:
            logger.warning(f"Failed to recalc calendar on advance_time: {e}")
        
        # Update day/night cycle using enhanced time manager
        time_manager = get_enhanced_time_manager()
        self.is_day = time_manager.is_daylight_period(self.game_time)
    
    def __post_init__(self):
        """Initialize or recalc calendar and date from current game_time at creation."""
        try:
            self.calendar.recalc_from_game_time(self.game_time)
            self.game_date = self._build_calendar_string()
        except Exception as e:
            logger.debug(f"WorldState __post_init__ calendar setup skipped: {e}")
    
    def _build_calendar_string(self) -> str:
        """Build a rich, named calendar string using config-driven names and current indices."""
        try:
            cfg = get_config()
            units = cfg.get("calendar.units", {}) or {}
            day_len = int(units.get("day_length_seconds", 86400)) or 86400
            if day_len <= 0:
                day_len = 86400
            names_map = cfg.get("calendar.names", {}) or {}
            year_label = names_map.get("year", "Year")
            start_year = int(cfg.get("calendar.start_year", 1) or 1)
            # Name arrays
            era_names = cfg.get("calendar.era_names", []) or []
            phase_names = cfg.get("calendar.phase_names", []) or []
            tide_names = cfg.get("calendar.tide_names", []) or []
            span_names = cfg.get("calendar.span_names", []) or []  # treat as months across a cycle (wrap around)
            dow_names = cfg.get("calendar.day_of_week_names", []) or []
            # Compute helper totals
            total_days = int(max(0, self.game_time) // day_len)
            # Year = cycle
            era_name = None
            if era_names:
                era_name = era_names[(self.calendar.era - 1) % len(era_names)]
            # Names for phase/tide
            phase_name = phase_names[(self.calendar.phase - 1) % len(phase_names)] if phase_names else f"Phase {self.calendar.phase}"
            tide_name = tide_names[(self.calendar.tide - 1) % len(tide_names)] if tide_names else f"Tide {self.calendar.tide}"
            # Determine span index across the cycle for month name
            span_days = int(units.get("span_length_days", 5)) or 5
            tide_spans = int(units.get("tide_length_spans", 3)) or 3
            phase_tides = int(units.get("phase_length_tides", 4)) or 4
            cycle_phases = int(units.get("cycle_length_phases", 6)) or 6
            days_per_span = max(1, span_days)
            days_per_tide = days_per_span * max(1, tide_spans)
            days_per_phase = days_per_tide * max(1, phase_tides)
            days_per_cycle = days_per_phase * max(1, cycle_phases)
            days_into_cycle = total_days % days_per_cycle
            span_index_in_cycle = (days_into_cycle // days_per_span) + 1
            month_name = span_names[(span_index_in_cycle - 1) % len(span_names)] if span_names else f"Span {span_index_in_cycle}"
            # Day-of-week
            if dow_names:
                day_of_week_name = dow_names[total_days % len(dow_names)]
            else:
                day_of_week_name = f"Day {((total_days % 7) + 1)}"
            # Compose
            parts = []
            parts.append(era_name if era_name else f"{names_map.get('era','Era')} {self.calendar.era}")
            year_number = start_year + (self.calendar.cycle - 1)
            parts.append(f"{year_label} {year_number}")
            parts.append(phase_name)
            parts.append(tide_name)
            parts.append(f"{month_name} {self.calendar.day} ({day_of_week_name})")
            return ", ".join(parts)
        except Exception as e:
            logger.debug(f"Failed to build calendar string: {e}")
            # Fallback to numeric representation
            names = get_config().get("calendar.names", {}) or {}
            return (
                f"{names.get('era','Era')} {self.calendar.era}, "
                f"{names.get('cycle','Cycle')} {self.calendar.cycle}, "
                f"{names.get('phase','Phase')} {self.calendar.phase}, "
                f"{names.get('tide','Tide')} {self.calendar.tide}, "
                f"{names.get('span','Span')} {self.calendar.span}, "
                f"{names.get('day','Day')} {self.calendar.day}"
            )
    
    @property
    def calendar_string(self) -> str:
        """Public accessor for the rich calendar string."""
        try:
            return self._build_calendar_string()
        except Exception:
            return self.game_date or ""
    
    @property
    def calendar_compact(self) -> str:
        """
        Return a compact canonical calendar string for auditing/debugging.
        Format: E{era}.C{cycle}.PH{phase}.TD{tide}.SP{span}.D{day} HH:MM
        """
        try:
            cfg = get_config()
            units = cfg.get("calendar.units", {}) or {}
            day_len = int(units.get("day_length_seconds", 86400)) or 86400
            if day_len <= 0:
                day_len = 86400
            secs = int(max(0, self.game_time)) % day_len
            hh = secs // 3600
            mm = (secs % 3600) // 60
            return (
                f"E{self.calendar.era}.C{self.calendar.cycle}.PH{self.calendar.phase}."
                f"TD{self.calendar.tide}.SP{self.calendar.span}.D{self.calendar.day} "
                f"{hh:02d}:{mm:02d}"
            )
        except Exception:
            # Fallback to numeric without time-of-day
            return (
                f"E{getattr(self.calendar, 'era', 1)}.C{getattr(self.calendar, 'cycle', 1)}.PH{getattr(self.calendar, 'phase', 1)}."
                f"TD{getattr(self.calendar, 'tide', 1)}.SP{getattr(self.calendar, 'span', 1)}.D{getattr(self.calendar, 'day', 1)}"
            )
    
    @property
    def time_of_day(self) -> str:
        """
        Get the current time of day as a narrative description.
        
        This replaces the old clock-based time display with rich narrative descriptions.
        
        Returns:
            A narrative description of the current time (e.g., "morning", "sunset", "deep night")
        """
        time_manager = get_enhanced_time_manager()
        season = self.get_global_var("current_season")
        return time_manager.get_time_description(self.game_time, "primary", season)
    
    @property 
    def atmospheric_time(self) -> str:
        """
        Get an atmospheric description of the current time for narrative contexts.
        
        Returns:
            An atmospheric time description (e.g., "as the first rays pierce the darkness")
        """
        time_manager = get_enhanced_time_manager()
        season = self.get_global_var("current_season")
        return time_manager.get_contextual_time(self.game_time, "narrative", season)
    
    @property
    def time_period_info(self) -> Dict[str, Any]:
        """
        Get comprehensive information about the current time period.
        
        Returns:
            Dictionary with detailed time period information
        """
        time_manager = get_enhanced_time_manager()
        return time_manager.get_period_info(self.game_time)
    
    def get_time_of_day(self) -> str:
        """
        Legacy method for backward compatibility.
        
        DEPRECATED: Use time_of_day property instead.
        This method now returns narrative time instead of clock time.
        """
        logger.warning("get_time_of_day() is deprecated, use time_of_day property instead")
        return self.time_of_day
    
    def update_weather(self, new_weather: str) -> None:
        """
        Update the current weather.
        
        Args:
            new_weather: The new weather condition.
        """
        self.weather = new_weather
        logger.info(f"Weather changed to {new_weather}")
    
    def set_global_var(self, key: str, value: Any) -> None:
        """
        Set a global variable.
        
        Args:
            key: The variable name.
            value: The variable value.
        """
        self.global_vars[key] = value
        logger.debug(f"Global variable {key} set to {value}")
    
    def get_global_var(self, key: str, default: Any = None) -> Any:
        """
        Get a global variable.
        
        Args:
            key: The variable name.
            default: The default value if the variable doesn't exist.
        
        Returns:
            The variable value, or the default if not found.
        """
        return self.global_vars.get(key, default)
    
    def add_event(self, event_id: str) -> None:
        """
        Add an active world event.
        
        Args:
            event_id: The ID of the event to add.
        """
        if event_id not in self.active_events:
            self.active_events.append(event_id)
            logger.info(f"World event added: {event_id}")
    
    def remove_event(self, event_id: str) -> None:
        """
        Remove an active world event.
        
        Args:
            event_id: The ID of the event to remove.
        """
        if event_id in self.active_events:
            self.active_events.remove(event_id)
            logger.info(f"World event removed: {event_id}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert WorldState to a dictionary for serialization."""
        return {
            "game_time": self.game_time,
            "game_date": self.game_date,
            "calendar": self.calendar.to_dict(),
            "weather": self.weather,
            "is_day": self.is_day,
            "magical_conditions": self.magical_conditions,
            "global_vars": self.global_vars,
            "active_events": self.active_events,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldState':
        """Create a WorldState from a dictionary with legacy fallbacks."""
        # Legacy fallback: if game_time is missing but time_of_day provided, map to an approximate hour
        game_time_val = data.get("game_time")
        if game_time_val is None and isinstance(data.get("time_of_day"), str):
            try:
                from core.utils.time_utils import HOUR
                time_period_hours = {
                    'deep_night': 2, 'pre_dawn': 4.5, 'dawn': 6, 'morning': 9,
                    'noon': 12, 'afternoon': 15, 'evening': 18, 'sunset': 20.5, 'night': 22
                }
                period = str(data.get("time_of_day")).strip().lower()
                # Normalize some common human words
                aliases = {
                    'midday': 'noon', 'dusk': 'sunset', 'twilight': 'sunset', 'daybreak': 'dawn', 'sunrise': 'dawn'
                }
                if period in aliases:
                    period = aliases[period]
                hour = time_period_hours.get(period, 9)
                game_time_val = hour * HOUR
            except Exception:
                game_time_val = 0.0
        if game_time_val is None:
            game_time_val = 0.0
        
        # Construct instance
        instance = cls(
            game_time=game_time_val,
            game_date=data.get("game_date", "Day 1"),
            weather=data.get("weather", "Clear"),
            is_day=data.get("is_day", True),
            magical_conditions=data.get("magical_conditions", {}),
            global_vars=data.get("global_vars", {}),
            active_events=data.get("active_events", []),
        )
        
        # Load or compute calendar state
        try:
            calendar_data = data.get("calendar")
            logger.debug(f"WorldState.from_dict: calendar_data received: {calendar_data}")
            if isinstance(calendar_data, dict):
                instance.calendar = CalendarState.from_dict(calendar_data)
            else:
                logger.debug("WorldState.from_dict: 'calendar' data not a dict or missing, recalculating from game_time.")
                instance.calendar.recalc_from_game_time(instance.game_time)
            # Build rich calendar string
            instance.game_date = instance._build_calendar_string()
        except Exception as e:
            logger.warning(f"Failed to initialize calendar from saved data: {e}")
        
        return instance

```

### File: core\base\__init__.py

```python
"""
Base package for the RPG game core.

This package contains the foundational classes for the game engine,
including state management, command processing, and configuration.
"""
```

### File: core\base\commands.py

```python
#!/usr/bin/env python3
"""
Command processing for the RPG game.

This module provides a framework for registering, parsing, and executing
player commands. It includes a CommandProcessor class for handling commands
and a CommandResult dataclass for representing command execution results.
"""

import re
import inspect
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple, Callable, Union
import logging
from enum import Enum, auto

from core.utils.logging_config import get_logger
from core.base.state import GameState

# Get the module logger
logger = get_logger("GAME")

class CommandStatus(Enum):
    """Status of a command execution."""
    SUCCESS = auto()
    FAILURE = auto()
    ERROR = auto()
    INVALID = auto()
    # Special statuses
    EXIT = auto()  # Command requests program exit
    HELP = auto()  # Command requests help


@dataclass
class CommandResult:
    """
    Result of a command execution.
    
    This dataclass contains information about the result of executing
    a command, including status, message, and any data produced.
    """
    status: CommandStatus
    message: str
    data: Optional[Dict[str, Any]] = None
    
    @classmethod
    def success(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create a success result."""
        return cls(CommandStatus.SUCCESS, message, data)
    
    @classmethod
    def failure(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create a failure result."""
        return cls(CommandStatus.FAILURE, message, data)
    
    @classmethod
    def error(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create an error result."""
        return cls(CommandStatus.ERROR, message, data)
    
    @classmethod
    def invalid(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create an invalid command result."""
        return cls(CommandStatus.INVALID, message, data)
    
    @classmethod
    def exit(cls, message: str = "Exiting the game.", data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create an exit result."""
        return cls(CommandStatus.EXIT, message, data)
    
    @classmethod
    def help(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create a help result."""
        return cls(CommandStatus.HELP, message, data)
    
    @property
    def is_success(self) -> bool:
        """Check if the result is a success."""
        return self.status == CommandStatus.SUCCESS
    
    @property
    def is_failure(self) -> bool:
        """Check if the result is a failure."""
        return self.status in [CommandStatus.FAILURE, CommandStatus.ERROR, CommandStatus.INVALID]
    
    @property
    def is_exit(self) -> bool:
        """Check if the result requests an exit."""
        return self.status == CommandStatus.EXIT
    
    @property
    def is_help(self) -> bool:
        """Check if the result requests help."""
        return self.status == CommandStatus.HELP


class CommandProcessor:
    """
    Processor for parsing and executing commands.
    
    This class manages the registration of command handlers and the
    processing of player input into commands. It handles both built-in
    commands and commands extracted from LLM responses.
    """
    
    # Singleton instance
    _instance = None
    
    # Command handler type
    CommandHandler = Callable[[GameState, List[str]], CommandResult]
    
    # Command help data
    @dataclass
    class CommandHelp:
        """Help information for a command."""
        command: str
        syntax: str
        description: str
        examples: List[str] = field(default_factory=list)
        aliases: List[str] = field(default_factory=list)
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(CommandProcessor, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the command processor."""
        if self._initialized:
            return
        
        # Command handlers by name
        self._handlers: Dict[str, CommandProcessor.CommandHandler] = {}
        
        # Developer command handlers by name
        self._dev_handlers: Dict[str, CommandProcessor.CommandHandler] = {}
        
        # Command aliases (pointing to main command names)
        self._aliases: Dict[str, str] = {}
        
        # Help information by command name
        self._help_data: Dict[str, CommandProcessor.CommandHelp] = {}
        
        # LLM command extraction pattern
        self._llm_command_pattern = re.compile(r'\{([A-Z_]+)(?:\s+(.+?))?\}')
        
        # Register built-in meta commands (help, quit)
        self._register_meta_commands()
        
        self._initialized = True
    
    def _register_meta_commands(self):
        """Register meta commands like help and quit."""
        # Register the help command
        self.register_command(
            name="help",
            handler=self._help_command,
            syntax="help [command]",
            description="Display help information for commands.",
            examples=["help", "help save", "help inventory"],
            aliases=["?", "commands"]
        )
        
        # Register the quit command
        self.register_command(
            name="quit",
            handler=self._quit_command,
            syntax="quit",
            description="Exit the game.",
            examples=["quit"],
            aliases=["exit", "bye"]
        )
        
        # Register the save command
        self.register_command(
            name="save",
            handler=self._save_command,
            syntax="save [name]",
            description="Save the current game state.",
            examples=["save", "save my_adventure"],
            aliases=[]
        )
        
        # Register the load command
        self.register_command(
            name="load",
            handler=self._load_command,
            syntax="load <save_id_or_name>",
            description="Load a saved game state.",
            examples=["load 1", "load my_adventure"],
            aliases=[]
        )
        
        # Register the list_saves command
        self.register_command(
            name="list_saves",
            handler=self._list_saves_command,
            syntax="list_saves",
            description="List all available saved games.",
            examples=["list_saves"],
            aliases=["saves", "ls"]
        )
        
        # Register the look command
        self.register_command(
            name="look",
            handler=self._look_command,
            syntax="look [target]",
            description="Look around or examine something specific.",
            examples=["look", "look chest", "look north"],
            aliases=["examine", "inspect"]
        )
        
        # Register the llm command to toggle/check LLM status
        self.register_command(
            name="llm",
            handler=self._llm_command,
            syntax="llm [on|off|status]",
            description="Toggle or check the status of the LLM system.",
            examples=["llm on", "llm off", "llm status"],
            aliases=[]
        )
    
    def _help_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Display help information for commands.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional command name to get help for.
            
        Returns:
            CommandResult with help information.
        """
        # If a command was specified, check if it's a developer command
        if args and args[0]:
            command = args[0].lower()
            
            # Handle //help as a special case
            if command.startswith("//"):
                dev_command = command[2:]
                help_data = None
                
                # Check if it's in dev_handlers
                if dev_command in self._dev_handlers:
                    help_data = self.get_command_help(f"//dev:{dev_command}")
                
                if help_data:
                    # Build help text for specific command
                    help_text = [
                        f"Developer Command: {help_data.command}",
                        f"Syntax: {help_data.syntax}",
                        f"Description: {help_data.description[6:]}"  # Remove [DEV] prefix
                    ]
                    
                    if help_data.examples:
                        help_text.append("Examples:")
                        for example in help_data.examples:
                            help_text.append(f"  {example}")
                    
                    return CommandResult.success("\n".join(help_text))
                else:
                    return CommandResult.failure(f"No help available for developer command '{dev_command}'.")
            
            # If args[0] is "dev", show all developer commands
            if command == "dev":
                dev_commands = self.get_all_dev_commands()
                if not dev_commands:
                    return CommandResult.success("No developer commands are currently registered.")
                
                dev_commands.sort()  # Alphabetical order
                
                help_text = ["Available Developer Commands:"]
                
                for cmd in dev_commands:
                    help_data = self.get_command_help(f"//dev:{cmd}")
                    if help_data:
                        # Add a short description for each command
                        description = help_data.description.split('.')[0][6:] + '.'  # First sentence, remove [DEV] prefix
                        help_text.append(f"  //{cmd}: {description}")
                
                help_text.append("\nType '//<command>' to use a developer command.")
                help_text.append("Type 'help //command' for more information on a specific developer command.")
                
                return CommandResult.success("\n".join(help_text))
            
            # For regular commands
            help_data = self.get_command_help(command)
            
            if not help_data:
                return CommandResult.failure(f"No help available for '{command}'. Type 'help' for a list of commands.")
            
            # Build help text for specific command
            help_text = [
                f"Command: {help_data.command}",
                f"Syntax: {help_data.syntax}",
                f"Description: {help_data.description}"
            ]
            
            if help_data.aliases:
                help_text.append(f"Aliases: {', '.join(help_data.aliases)}")
            
            if help_data.examples:
                help_text.append("Examples:")
                for example in help_data.examples:
                    help_text.append(f"  {example}")
            
            return CommandResult.success("\n".join(help_text))
        
        # Otherwise, show a list of all commands
        commands = self.get_all_commands()
        commands.sort()  # Alphabetical order
        
        help_text = ["Available commands:"]
        
        for cmd in commands:
            help_data = self.get_command_help(cmd)
            if help_data:
                # Add a short description for each command
                description = help_data.description.split('.')[0] + '.'  # First sentence
                help_text.append(f"  {cmd}: {description}")
        
        help_text.append("\nType 'help <command>' for more information on a specific command.")
        
        # Add information about developer commands
        dev_commands = self.get_all_dev_commands()
        if dev_commands:
            help_text.append("\nDeveloper Commands:")
            help_text.append("Use '/help dev' to see available developer commands.")
        
        return CommandResult.success("\n".join(help_text))
    
    def _quit_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Exit the game.
        
        Args:
            game_state: The current game state.
            args: Command arguments (ignored).
            
        Returns:
            CommandResult with EXIT status.
        """
        return CommandResult.exit("Exiting the game. Thank you for playing!")
    
    def _save_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Save the current game state.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional save name.
            
        Returns:
            CommandResult indicating success or failure.
        """
        import uuid
        from core.utils.save_manager import SaveManager
        
        # Get save name if provided
        save_name = args[0] if args else f"Save_{game_state.player.name}_{game_state.game_time.get_formatted_time()}"
        
        try:
            # Generate a unique ID for the save
            save_id = str(uuid.uuid4())
            
            # Create the save using the StateManager
            game_state.state_manager.save_game(save_id)
            
            # Update metadata with the SaveManager
            save_manager = SaveManager()
            save_manager.update_metadata(
                save_id=save_id,
                updates={
                    "save_name": save_name,
                    "player_name": game_state.player.name,
                    "player_level": game_state.player.level,
                    "world_time": game_state.game_time.get_formatted_time(),
                    "location": game_state.world.current_location,
                    "playtime": game_state.playtime
                }
            )
            
            return CommandResult.success(f"Game saved as '{save_name}'.")
        except Exception as e:
            logger.error(f"Error saving game: {e}", exc_info=True)
            return CommandResult.error(f"Failed to save game: {str(e)}")
    
    def _load_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Load a saved game state.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Required save ID or name.
            
        Returns:
            CommandResult indicating success or failure.
        """
        from core.utils.save_manager import SaveManager
        
        if not args:
            return CommandResult.invalid("Please specify a save ID or name to load.")
        
        save_id_or_name = args[0]
        save_manager = SaveManager()
        
        try:
            # First, try to interpret the argument as a save ID
            save_id = save_id_or_name
            
            # If it's not a UUID, try to find a save with the given name
            if not self._is_valid_uuid(save_id):
                # Get all saves and look for a name match
                saves = save_manager.get_save_list()
                for save in saves:
                    if save.save_name.lower() == save_id_or_name.lower():
                        save_id = save.save_id
                        break
                else:
                    return CommandResult.failure(f"No save found with ID or name '{save_id_or_name}'.")
            
            # Now load the game
            success = game_state.state_manager.load_game(save_id)
            
            if success:
                return CommandResult.success(f"Game loaded successfully.")
            else:
                return CommandResult.failure(f"Failed to load game with ID '{save_id}'.")
                
        except Exception as e:
            logger.error(f"Error loading game: {e}", exc_info=True)
            return CommandResult.error(f"Failed to load game: {str(e)}")
    
    def _look_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Look around or examine something specific.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional target to examine.
            
        Returns:
            CommandResult with description.
        """
        # Process the look command directly if LLM is disabled
        # Otherwise, it should be handled by the LLM
        from core.base.engine import get_game_engine
        engine = get_game_engine()
        
        # If LLM is enabled, this command should not be directly processed
        # The engine should route it to the LLM system
        if engine._use_llm:
            return CommandResult.success("This command should be processed by the LLM system. If you're seeing this message, there might be an issue with LLM integration.")
        
        # Basic fallback implementation for when LLM is disabled
        location = game_state.player.current_location
        target = " ".join(args) if args else None
        
        if not target:
            # Look around the current location
            return CommandResult.success(
                f"You are in {location}. This is a simple placeholder description since the LLM system is disabled."
                f"\nUse '/llm on' command to enable the LLM system for rich descriptions."
            )
        else:
            # Look at a specific target
            return CommandResult.success(
                f"You examine the {target}. This is a simple placeholder description since the LLM system is disabled."
                f"\nUse '/llm on' command to enable the LLM system for rich descriptions."
            )

    def _llm_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Toggle or check the status of the LLM system.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional subcommand (on, off, status).
            
        Returns:
            CommandResult indicating success or failure.
        """
        # Get the game engine (needed to toggle LLM)
        from core.base.engine import get_game_engine
        engine = get_game_engine()
        
        # Check if any arguments were provided
        if not args:
            # No arguments, just show status
            status = "enabled" if engine._use_llm else "disabled"
            return CommandResult.success(f"LLM system is currently {status}.")
        
        # Process the subcommand
        subcommand = args[0].lower()
        
        if subcommand == "on" or subcommand == "enable":
            engine.set_llm_enabled(True)
            return CommandResult.success("LLM system enabled.")
        
        elif subcommand == "off" or subcommand == "disable":
            engine.set_llm_enabled(False)
            return CommandResult.success("LLM system disabled.")
        
        elif subcommand == "status":
            status = "enabled" if engine._use_llm else "disabled"
            return CommandResult.success(f"LLM system is currently {status}.")
        
        else:
            return CommandResult.invalid(f"Unknown subcommand: {subcommand}. Use 'on', 'off', or 'status'.")
    
    def _list_saves_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        List all available saved games.
        
        Args:
            game_state: The current game state.
            args: Command arguments (ignored).
            
        Returns:
            CommandResult with list of saves.
        """
        from core.utils.save_manager import SaveManager
        
        try:
            save_manager = SaveManager()
            saves = save_manager.get_save_list()
            
            if not saves:
                return CommandResult.success("No saved games found.")
            
            result_lines = ["Available saved games:"]
            
            for i, save in enumerate(saves, 1):
                # Format: 1. Save Name (Player Name, Level X) - 2023-04-15 14:30
                result_lines.append(
                    f"{i}. {save.save_name} ({save.player_name}, Level {save.player_level}) - {save.formatted_save_time}"
                )
            
            result_lines.append("\nUse 'load <save_name>' to load a saved game.")
            
            return CommandResult.success("\n".join(result_lines))
        except Exception as e:
            logger.error(f"Error listing saves: {e}", exc_info=True)
            return CommandResult.error(f"Failed to list saves: {str(e)}")
    
    def _is_valid_uuid(self, uuid_str: str) -> bool:
        """Check if a string is a valid UUID."""
        try:
            import uuid
            uuid.UUID(uuid_str)
            return True
        except (ValueError, AttributeError):
            return False
    
    def register_command(self, 
                         name: str, 
                         handler: CommandHandler,
                         syntax: str = "",
                         description: str = "",
                         examples: List[str] = None,
                         aliases: List[str] = None) -> None:
        """
        Register a command handler.
        
        Args:
            name: The name of the command.
            handler: The function to handle the command.
            syntax: The command syntax.
            description: A description of the command.
            examples: Example usages of the command.
            aliases: Alternative names for the command.
        """
        # Register the handler
        self._handlers[name.lower()] = handler
        
        # Register help information
        self._help_data[name.lower()] = CommandProcessor.CommandHelp(
            command=name.lower(),
            syntax=syntax or f"{name} [args...]",
            description=description or "No description available.",
            examples=examples or [],
            aliases=aliases or []
        )
        
        # Register aliases
        if aliases:
            for alias in aliases:
                self._aliases[alias.lower()] = name.lower()
        
        logger.debug(f"Registered command: {name}")
        
    def register_dev_command(self, 
                           name: str, 
                           handler: CommandHandler,
                           syntax: str = "",
                           description: str = "",
                           examples: List[str] = None) -> None:
        """
        Register a developer command handler.
        
        Args:
            name: The name of the command (without // prefix).
            handler: The function to handle the command.
            syntax: The command syntax.
            description: A description of the command.
            examples: Example usages of the command.
        """
        if examples is None:
            examples = []
            
        # Add the handler to dev_handlers
        self._dev_handlers[name.lower()] = handler
        
        # Add help information (reusing the same help system)
        self._help_data[f"//dev:{name.lower()}"] = CommandProcessor.CommandHelp(
            command=f"//{name.lower()}",
            syntax=syntax or f"//{name} [args...]",
            description=f"[DEV] {description or 'No description available.'}",
            examples=[f"//{ex}" for ex in examples] if examples else [],
            aliases=[]
        )
        
        logger.debug(f"Registered developer command: //{name}")
    
    def get_command_handler(self, command: str) -> Optional[CommandHandler]:
        """
        Get the handler for a command.
        
        Args:
            command: The command name.
        
        Returns:
            The command handler, or None if not found.
        """
        command = command.lower()
        
        # Check for direct command
        if command in self._handlers:
            return self._handlers[command]
        
        # Check for alias
        if command in self._aliases:
            return self._handlers[self._aliases[command]]
        
        return None
    
    def get_all_commands(self) -> List[str]:
        """
        Get a list of all registered commands.
        
        Returns:
            A list of command names.
        """
        return list(self._handlers.keys())
        
    def get_all_dev_commands(self) -> List[str]:
        """
        Get a list of all registered developer commands.
        
        Returns:
            A list of command names.
        """
        return list(self._dev_handlers.keys())
    
    def get_command_help(self, command: str) -> Optional[CommandHelp]:
        """
        Get help information for a command.
        
        Args:
            command: The command name.
        
        Returns:
            The command help, or None if not found.
        """
        command = command.lower()
        
        # Check for direct command
        if command in self._help_data:
            return self._help_data[command]
        
        # Check for alias
        if command in self._aliases:
            return self._help_data[self._aliases[command]]
        
        return None
    
    def process_command(self, game_state: GameState, command_text: str) -> CommandResult:
        """
        Process a command.
        
        Args:
            game_state: The current game state.
            command_text: The command text to process.
        
        Returns:
            The result of executing the command.
        """
        if not command_text:
            return CommandResult.invalid("Please enter a command.")
        
        # Update last command in game state
        game_state.last_command = command_text
        
        # Check if it's a developer command (starts with //)
        if command_text.startswith("//"):
            # Extract the command name (without //)
            parts = command_text[2:].split(maxsplit=1)
            command_name = parts[0].lower()
            args = parts[1] if len(parts) > 1 else ""
            
            # Get the developer command handler
            handler = self._dev_handlers.get(command_name)
            if handler is None:
                return CommandResult.invalid(f"Unknown developer command: {command_name}")
            
            try:
                # Execute the command
                logger.debug(f"Executing developer command: {command_name} with args: {args}")
                
                # Parse args
                arg_list = []
                if args:
                    # This regex splits by spaces except within quoted strings
                    arg_pattern = re.compile(r'(?:[^\s,"]|"(?:\\.|[^"])*")++') 
                    arg_list = arg_pattern.findall(args)
                    
                    # Remove quotes from quoted arguments
                    arg_list = [
                        arg[1:-1] if (arg.startswith('"') and arg.endswith('"')) else arg 
                        for arg in arg_list
                    ]
                
                # Call the handler
                result = handler(game_state, arg_list)
                
                # Log the result
                if result.is_success:
                    logger.debug(f"Developer command {command_name} succeeded: {result.message}")
                else:
                    logger.debug(f"Developer command {command_name} failed: {result.message}")
                
                return result
            except Exception as e:
                logger.error(f"Error executing developer command {command_name}: {e}", exc_info=True)
                return CommandResult.error(f"Error executing developer command: {e}")
        
        # Add to conversation history (if not a system command) - moved here after developer command check
        if not command_text.startswith("/"):
            game_state.add_conversation_entry("player", command_text)
            
            # In a full implementation, this would be sent to an LLM agent for natural
            # language processing. For now, we'll just treat it as a direct command.
            # We'll still parse as a command for the basic framework.
        
        # Parse the command (strip leading / if present)
        command_text = command_text.lstrip("/")
        parts = command_text.split(maxsplit=1)
        command_name = parts[0].lower()
        args = parts[1] if len(parts) > 1 else ""
        
        # Get the command handler
        handler = self.get_command_handler(command_name)
        if handler is None:
            return CommandResult.invalid(f"Unknown command: {command_name}")
        
        try:
            # Execute the command
            logger.debug(f"Executing command: {command_name} with args: {args}")
            
            # Split args by whitespace, but respect quoted strings
            arg_list = []
            if args:
                # This regex splits by spaces except within quoted strings
                arg_pattern = re.compile(r'(?:[^\s,"]|"(?:\\.|[^"])*")++') 
                arg_list = arg_pattern.findall(args)
                
                # Remove quotes from quoted arguments
                arg_list = [
                    arg[1:-1] if (arg.startswith('"') and arg.endswith('"')) else arg 
                    for arg in arg_list
                ]
            
            # Call the handler
            result = handler(game_state, arg_list)
            
            # Log the result
            if result.is_success:
                logger.debug(f"Command {command_name} succeeded: {result.message}")
            else:
                logger.debug(f"Command {command_name} failed: {result.message}")
            
            return result
        except Exception as e:
            logger.error(f"Error executing command {command_name}: {e}", exc_info=True)
            return CommandResult.error(f"Error executing command: {e}")
    
    def extract_llm_commands(self, text: str) -> List[Tuple[str, str]]:
        """
        Extract LLM commands from text.
        
        Args:
            text: The text to extract commands from.
        
        Returns:
            A list of (command, args) tuples.
        """
        matches = self._llm_command_pattern.findall(text)
        return [(command, args or "") for command, args in matches]
    
    def process_llm_commands(self, game_state: GameState, text: str) -> Tuple[str, List[CommandResult]]:
        """
        Process LLM commands embedded in text.
        
        Args:
            game_state: The current game state.
            text: The text containing LLM commands.
        
        Returns:
            A tuple of (processed_text, command_results).
        """
        # Extract commands
        commands = self.extract_llm_commands(text)
        
        # Store results
        results = []
        
        # Process each command and replace in the text
        processed_text = text
        
        for cmd, args in commands:
            # Check if command is registered
            handler = self.get_command_handler(cmd)
            
            if handler:
                # Split args
                arg_list = args.split() if args else []
                
                # Execute the command
                try:
                    result = handler(game_state, arg_list)
                    results.append(result)
                    
                    # Replace the command in the text with its result
                    pattern = rf'\{{{cmd}(?:\s+{re.escape(args)})?\}}'
                    replacement = result.message if result.is_success else f"[Command Error: {result.message}]"
                    processed_text = re.sub(pattern, replacement, processed_text)
                except Exception as e:
                    logger.error(f"Error executing LLM command {cmd}: {e}", exc_info=True)
                    pattern = rf'\{{{cmd}(?:\s+{re.escape(args)})?\}}'
                    processed_text = re.sub(pattern, f"[Command Error: {e}]", processed_text)
            else:
                # Unknown command
                logger.warning(f"Unknown LLM command: {cmd}")
                pattern = rf'\{{{cmd}(?:\s+{re.escape(args)})?\}}'
                processed_text = re.sub(pattern, f"[Unknown Command: {cmd}]", processed_text)
        
        return processed_text, results


# Convenience function
def get_command_processor() -> CommandProcessor:
    """Get the command processor instance."""
    return CommandProcessor()


# Example usage (this would be filled in during the Command Handlers phase)
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.DEBUG)
    
    # Get the command processor - commands are now registered automatically
    processor = get_command_processor()
    
    print("Command registration example")
    print("Commands:", processor.get_all_commands())
    
    # Example of command processing
    from core.base.state import GameState, PlayerState, WorldState
    game_state = GameState(player=PlayerState(name="Test Player"))
    
    result = processor.process_command(game_state, "help")
    print(f"Result: {result.message}")
    
    # Test a few basic commands
    print("\nTesting more commands:")
    commands = ["quit", "help save", "list_saves"]
    
    for cmd in commands:
        print(f"\nExecuting: {cmd}")
        result = processor.process_command(game_state, cmd)
        print(f"Status: {result.status}")
        print(f"Result: {result.message}")
    
    # Example of LLM command processing
    text = "You find a chest. {ITEM_CREATE chest common container}"
    processed_text, results = processor.process_llm_commands(game_state, text)
    print(f"\nProcessed text: {processed_text}")
```

### File: core\base\config.py

```python
#!/usr/bin/env python3
"""
Configuration management for the RPG game.

This module provides a GameConfig class for loading, managing, and accessing
configuration data from JSON files.
"""

import os
import logging
from typing import Any, Dict, List, Optional, Tuple, Union
import json

from core.utils.json_utils import load_json, save_json
from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

class GameConfig:
    """
    Game configuration manager.

    This class handles loading configuration from JSON files,
    providing access to configuration values, and saving
    updated configurations.

    It supports dot notation for accessing nested configuration values
    (e.g., config.get("gui.window.width")).
    """

    # Singleton instance
    _instance = None

    # Default configuration directory relative to project root
    _CONFIG_DIR = "config"

    # Default configuration files, mapping domain to relative path within _CONFIG_DIR
    _DEFAULT_CONFIG_FILES = {
        "game": "game_config.json",
        "system": "system_config.json",
        "gui": "gui_config.json",
        "llm": "llm/base_config.json", # Added LLM config
        "combat_display_settings": "combat_display_settings.json",
        "combat": os.path.join("combat", "combat_config.json"),
        "classes": os.path.join("character", "classes.json"),
        "races": os.path.join("character", "races.json"),
        "origins": os.path.join("world", "scenarios", "origins.json"),
        "quests": os.path.join("world", "scenarios", "quests.json"),
        "locations": os.path.join("world", "locations", "locations.json"),
        "aliases": os.path.join("world", "aliases.json"),
        # Character stats and canonical registries
        "stat_registry": os.path.join("character", "stat_registry.json"),
        "canonical_lists": os.path.join("gameplay", "canonical_lists.json"),
        # Canonical calendar configuration (era/cycle/phase/tide/span/day)
        "calendar": os.path.join("gameplay", "calendar.json"),
        # Calendar master reference for journal seeding
        "calendar_master": os.path.join("gameplay", "calendar_master.json"),
        # New NPC configuration domains (families system)
        "npc_families": os.path.join("npc", "families.json"),
        "npc_families_factions": os.path.join("npc", "families_factions.json"),
        "npc_variants": os.path.join("npc", "variants.json"),
        "npc_tags": os.path.join("npc", "tags.json"),
        "npc_roles": os.path.join("npc", "roles.json"),
        "npc_abilities": os.path.join("npc", "abilities.json"),
        "npc_boss_overlays": os.path.join("npc", "boss_overlays.json"),
        "npc_generation_rules": os.path.join("npc", "generation_rules.json"),
        "npc_entity_aliases": os.path.join("aliases", "entities.json"),
        # Legacy NPC templates for name pools (read-only, temporary during migration)
        "npc_legacy_templates": os.path.join("character", "npc_templates.json"),
        # Names guidance for LLM and generator
        "npc_names": os.path.join("npc", "names.json"),
        # World location defaults (e.g., culture mix)
        "location_defaults": os.path.join("world", "locations", "defaults.json"),
    }

    # Configurations loaded from files
    _config_data: Dict[str, Dict[str, Any]] = {}

    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(GameConfig, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self, config_dir: str = None):
        """Initialize the configuration."""
        # Prevent re-initialization
        if hasattr(self, '_initialized') and self._initialized:
            return

        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        self._config_dir_abs = os.path.join(project_root, config_dir or self._CONFIG_DIR)

        self._config_data = {}

        os.makedirs(self._config_dir_abs, exist_ok=True)

        for domain in self._DEFAULT_CONFIG_FILES:
            self._config_data[domain] = {}

        # Load configurations
        self._load_all_configs()

        self._initialized = True

    def _load_all_configs(self):
        """Load all configuration files."""
        for domain, filename_rel in self._DEFAULT_CONFIG_FILES.items():
            self._load_config(domain, filename_rel)

    def _load_config(self, domain: str, filename_rel: str):
        """
        Load a configuration file for the specified domain.

        Args:
            domain: The configuration domain name (e.g., "game", "classes").
            filename_rel: The relative path of the file within the config directory
                          (e.g., "game_config.json", "character/classes.json").
        """
        # Construct the absolute file path
        file_path = os.path.join(self._config_dir_abs, filename_rel)

        # Log the attempt
        logger.info(f"Attempting to load configuration for domain '{domain}' from: {file_path}")

        # If the file doesn't exist, handle defaults or warnings
        if not os.path.exists(file_path):
            # Only create defaults for the original base configs
            if domain in ["game", "system", "gui", "llm"]: # Add llm here if it needs defaults
                logger.warning(f"Config file for '{domain}' not found. Creating default: {file_path}")
                self._create_default_config(domain, file_path) # Pass absolute path
            else:
                # For other configs like classes, races, origins just warn and set empty data
                logger.warning(f"Configuration file for domain '{domain}' not found at {file_path}. Skipping load.")
                self._config_data[domain] = {} # Ensure domain exists but is empty
            return # Stop processing if file doesn't exist (and wasn't created)

        try:
            loaded_data = load_json(file_path)
            if loaded_data is None: # Check if load_json returned None
                 logger.error(f"Failed to load or parse JSON for domain '{domain}' from {file_path}")
                 self._config_data[domain] = {} # Ensure domain exists but is empty
                 return

            # --- Specific Handling for files with top-level keys ---
            # Check if the domain is 'classes' and the loaded data has a top-level 'classes' key
            if domain == "classes" and isinstance(loaded_data, dict) and "classes" in loaded_data:
                self._config_data[domain] = loaded_data["classes"]
                logger.debug(f"Extracted 'classes' key content for domain '{domain}'.")
            # Check if the domain is 'races' and the loaded data has a top-level 'races' key
            elif domain == "races" and isinstance(loaded_data, dict) and "races" in loaded_data:
                self._config_data[domain] = loaded_data["races"]
                logger.debug(f"Extracted 'races' key content for domain '{domain}'.")
            # Check if the domain is 'origins' and the loaded data has a top-level 'origins' key
            elif domain == "origins" and isinstance(loaded_data, dict) and "origins" in loaded_data:
                 self._config_data[domain] = loaded_data["origins"]
                 logger.info(f"Extracted 'origins' key content for domain '{domain}'.")
                 # Add a check for the structure - expecting a dict of origins
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'origins' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {} # Reset if structure is wrong
            # Check if the domain is 'quests' and the loaded data has a top-level 'quests' key
            elif domain == "quests" and isinstance(loaded_data, dict) and "quests" in loaded_data:
                 self._config_data[domain] = loaded_data["quests"]
                 logger.info(f"Extracted 'quests' key content for domain '{domain}'.")
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'quests' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {}
            # Check if the domain is 'locations' and the loaded data has a top-level 'locations' key
            elif domain == "locations" and isinstance(loaded_data, dict) and "locations" in loaded_data:
                 self._config_data[domain] = loaded_data["locations"]
                 logger.debug(f"Extracted 'locations' key content for domain '{domain}'.")
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'locations' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {}
            # Aliases domain may or may not have top-level 'aliases' key; accept either
            elif domain == "aliases" and isinstance(loaded_data, dict):
                 self._config_data[domain] = loaded_data.get("aliases", loaded_data)
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'aliases' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {}
            else:
                # Default behavior: store the entire loaded data
                self._config_data[domain] = loaded_data

            logger.info(f"Successfully loaded configuration for domain '{domain}'.")


        except Exception as e:
            logger.exception(f"Error loading configuration for domain '{domain}' from {file_path}: {e}")
            # Ensure domain exists even on error, maybe with empty data
            if domain not in self._config_data:
                self._config_data[domain] = {}

    def _create_default_config(self, domain: str, file_path: str):
        """
        Create a default configuration file for the specified domain.

        Args:
            domain: The configuration domain name.
            file_path: The absolute path where the file should be created.
        """
        # Define default configurations
        default_configs = {
            "game": {
                "version": "0.1.0",
                "title": "RPG Game",
                "default_save_slot": "auto",
                "auto_save_interval": 300,  # seconds
                "max_save_slots": 10,
                "debug": {
                    "time_audit_log_enabled": True
                },
                "time": {
                    "tick_enabled": False,
                    "post_combat_increment_seconds": 300
                }
            },
            "system": {
                "log_level": "INFO",
                "log_to_file": True,
                "log_to_console": True,
                "debug_mode": False,
                "save_dir": "saves", # Relative to project root
                "log_dir": "logs",   # Relative to project root
            },
            "gui": {
                "resolution": {
                    "width": 1280,
                    "height": 720,
                },
                "fullscreen": False,
                "theme": "default",
                "font_size": 12,
                "show_fps": False,
            },
            "llm": {
                 "default_provider_type": "GOOGLE", # Changed default
                 "default_temperature": 0.7,
                 "max_tokens": 1500, # Increased default
                 "timeout_seconds": 45, # Increased default
                 "retry_attempts": 2,
                 "retry_delay_seconds": 3,
                 "run_diagnostics_on_start": False,
                 "log_prompts": False, # Changed default
                 "log_completions": False, # Changed default
                 "cost_tracking_enabled": True,
                 "enabled": True # Explicitly add enabled flag
            }
            # No defaults needed for classes/races/origins here, as they should exist
        }

        default_config = default_configs.get(domain, {})
        if not default_config:
             logger.warning(f"No default configuration defined for domain '{domain}'")
             return # Don't create empty files for non-base domains

        self._config_data[domain] = default_config # Update in-memory config too

        try:
            # Create directory if it doesn't exist (handles nested paths)
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            # Save default configuration
            save_json(default_config, file_path)
            logger.info(f"Created default configuration for {domain} at {file_path}")
        except Exception as e:
            logger.error(f"Error creating default configuration for {domain} at {file_path}: {e}")

    def get(self, key_path: str, default: Any = None) -> Any:
        """
        Get a configuration value using dot notation.

        Args:
            key_path: The path to the configuration value (e.g., "gui.resolution.width", "origins.harmonia_initiate.description").
            default: The default value to return if the key is not found.

        Returns:
            The configuration value, or the default if not found.
        """
        # Split the key path into parts
        parts = key_path.split(".")

        # The first part is the domain (e.g., "gui", "origins")
        domain = parts[0]

        # If the domain doesn't exist in our loaded data, return the default
        if domain not in self._config_data:
            return default

        # Start with the domain's configuration data
        current = self._config_data[domain]

        # Traverse the configuration hierarchy using the remaining parts
        for part in parts[1:]:
            # Check if current level is a dictionary and the key exists
            if isinstance(current, dict):
                if part in current:
                    current = current[part]
                else:
                    # Key not found at this level
                    return default
            # Check if current level is a list and the key is an integer index
            elif isinstance(current, list):
                 try:
                      index = int(part)
                      if 0 <= index < len(current):
                           current = current[index]
                      else:
                           # Index out of bounds
                           return default
                 except ValueError:
                      # Key is not a valid integer index for the list
                      return default
            else:
                 # Current level is not a dict or list, cannot traverse further
                 return default


        return current

    def set(self, key_path: str, value: Any) -> bool:
        """
        Set a configuration value using dot notation and save the corresponding file.

        Args:
            key_path: The path to the configuration value (e.g., "gui.resolution.width").
            value: The value to set.

        Returns:
            True if the value was set and saved successfully, False otherwise.
        """
        # Split the key path into parts
        parts = key_path.split(".")

        # The first part is the domain (e.g., "gui")
        domain = parts[0]

        # Check if the domain is known (has a default file mapping)
        if domain not in self._DEFAULT_CONFIG_FILES:
             logger.error(f"Cannot set configuration for unknown domain '{domain}'. Add it to _DEFAULT_CONFIG_FILES.")
             return False

        # If the domain doesn't exist in data, create it
        if domain not in self._config_data:
            logger.warning(f"Domain '{domain}' not found in configuration data, creating it.")
            self._config_data[domain] = {}

        # Start with the domain's configuration
        current = self._config_data[domain]

        # Traverse the configuration hierarchy, creating nodes as needed
        for part in parts[1:-1]:
            if part not in current or not isinstance(current[part], dict):
                 # If key doesn't exist or is not a dict, create/overwrite with a dict
                current[part] = {}
            current = current[part]

        # Set the final value
        final_key = parts[-1]
        # Ensure the final level is a dictionary before setting
        if not isinstance(current, dict):
             logger.error(f"Cannot set '{key_path}': Intermediate path does not lead to a dictionary.")
             return False

        current[final_key] = value
        logger.info(f"Set configuration '{key_path}' to: {value}")

        # --- Save the updated configuration file ---
        try:
            filename_rel = self._DEFAULT_CONFIG_FILES[domain]
            file_path = os.path.join(self._config_dir_abs, filename_rel)

            # Prepare data to save - handle potential top-level keys for specific domains
            data_to_save = self._config_data[domain]
            if domain == "classes":
                data_to_save = {"classes": self._config_data[domain]}
            elif domain == "races":
                 data_to_save = {"races": self._config_data[domain]}
            elif domain == "origins": # Added origins handler
                 data_to_save = {"origins": self._config_data[domain]}
            elif domain == "quests": # Added quests handler
                 data_to_save = {"quests": self._config_data[domain]}
            elif domain == "locations": # Added locations handler
                 data_to_save = {"locations": self._config_data[domain]}

            # Ensure the directory exists before saving
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            save_json(data_to_save, file_path)
            logger.info(f"Saved updated configuration for domain '{domain}' to {file_path}")
            return True
        except Exception as e:
            logger.exception(f"Error saving configuration for domain '{domain}' to {file_path}: {e}")
            return False

    def get_all(self, domain: str = None) -> Dict[str, Any]:
        """
        Get all configuration values for a domain, or all domains.

        Args:
            domain: The domain to get (e.g., "gui", "origins"). If None, return all domains.

        Returns:
            A dictionary of configuration values. Returns an empty dict if domain not found.
        """
        if domain is None:
            # Return a copy to prevent external modification
            return self._config_data.copy()

        if domain not in self._config_data:
            logger.warning(f"Domain '{domain}' not found in configuration")
            return {}

        # Return a copy
        return self._config_data[domain].copy()

    def reload(self, domain: str = None) -> bool:
        """
        Reload configuration from files.

        Args:
            domain: The domain to reload (e.g., "gui", "origins"). If None, reload all domains.

        Returns:
            True if the configuration was reloaded successfully, False otherwise.
        """
        logger.info(f"Reloading configuration for domain: {'ALL' if domain is None else domain}")
        try:
            if domain is None:
                self._load_all_configs()
                logger.info("Reloaded all configurations.")
                return True

            if domain not in self._DEFAULT_CONFIG_FILES:
                logger.warning(f"Cannot reload unknown domain '{domain}'.")
                return False

            filename_rel = self._DEFAULT_CONFIG_FILES[domain]
            self._load_config(domain, filename_rel)
            logger.info(f"Reloaded configuration for domain '{domain}'.")
            return True
        except Exception as e:
            logger.exception(f"Error reloading configuration: {e}")
            return False

    def validate(self) -> Tuple[bool, List[str]]:
        """
        Validate the configuration. (Basic validation for now)

        Returns:
            A tuple of (is_valid, error_messages).
        """
        is_valid = True
        errors = []

        # Updated required domains list
        required_domains = ["game", "system", "gui", "llm", "classes", "races", "origins"]
        for domain in required_domains:
            if domain not in self._config_data or not self._config_data[domain]:
                # Allow empty if the file genuinely didn't exist and wasn't required to have defaults
                filename_rel = self._DEFAULT_CONFIG_FILES.get(domain)
                if filename_rel:
                    file_path = os.path.join(self._config_dir_abs, filename_rel)
                    # Check if the file exists OR if it's a base config that should have defaults
                    if os.path.exists(file_path) or domain in ["game", "system", "gui", "llm"]:
                         is_valid = False
                         error = f"Configuration for domain '{domain}' is missing or empty."
                         errors.append(error)
                         logger.error(error)
                else: # Domain not even in default files - should not happen with current logic
                     is_valid = False
                     error = f"Configuration for domain '{domain}' is missing entirely."
                     errors.append(error)
                     logger.error(error)


        if is_valid:
            logger.info("Configuration validation passed.")
        else:
            logger.warning(f"Configuration validation failed: {errors}")

        return is_valid, errors


# Convenience functions

def get_config() -> GameConfig:
    """Get the game configuration singleton instance."""
    return GameConfig()


# Example usage
if __name__ == "__main__":
    # Set up basic logging for example run
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    print("--- Initializing Config ---")
    config = get_config()
    print("\n--- Config Initialized ---")

    # Validate after load
    config.validate()

    # Get some values
    print("\n--- Getting Values ---")
    resolution_width = config.get("gui.resolution.width")
    print(f"GUI Resolution width: {resolution_width}")

    log_level = config.get("system.log_level", "DEBUG") # Example with default
    print(f"System Log Level: {log_level}")

    # Try getting a class description
    warrior_desc = config.get("classes.Warrior.description")
    if warrior_desc:
        print(f"Warrior Description: {warrior_desc}")
    else:
        print("Warrior class description not found (or classes.json missing/empty).")

    # Try getting an origin description
    harmonia_initiate_desc = config.get("origins.harmonia_initiate.description")
    if harmonia_initiate_desc:
         print(f"Harmonia Initiate Description: {harmonia_initiate_desc}")
    else:
         print("Harmonia Initiate origin not found (or origins.json missing/empty).")


    # Try getting a non-existent value
    non_existent = config.get("game.some_new_setting.value", "DefaultValue")
    print(f"Non-existent setting: {non_existent}")

    # Get all config for a domain
    print("\n--- Getting All GUI Config ---")
    gui_config = config.get_all("gui")
    print(json.dumps(gui_config, indent=2))

    print("\n--- Getting All Origins Config ---")
    origins_config = config.get_all("origins")
    if origins_config:
         print(f"Number of origins loaded: {len(origins_config)}")
         # print(json.dumps(origins_config, indent=2)) # Might be large
    else:
        print("No origins configuration loaded.")


    # Set a value (will save gui_config.json)
    print("\n--- Setting Value ---")
    success = config.set("gui.font_size", 14)
    print(f"Set gui.font_size success: {success}")
    print(f"New gui.font_size: {config.get('gui.font_size')}")

    # Reload config
    print("\n--- Reloading Config ---")
    config.reload("gui")
    print(f"Reloaded gui.font_size: {config.get('gui.font_size')}") # Should be 14 if save worked

    print("\n--- Example Finished ---")
```

### File: core\base\engine.py

```python
#!/usr/bin/env python3
"""
Game engine for the RPG game.

This module provides the central GameEngine class that coordinates
between state management, command processing, and game loop components.
"""


import time
import json
from typing import Any, Dict, Optional
from PySide6.QtCore import QObject, Signal, Slot
from core.combat.enums import CombatStep, CombatState
from core.interaction.enums import InteractionMode
from core.orchestration.events import DisplayEventType
from core.utils.logging_config import get_logger
from core.base.state import StateManager, GameState
from core.base.commands import CommandProcessor, CommandResult
from core.base.game_loop import GameLoop, GameSpeed
from core.base.config import get_config
from core.agents.agent_manager import get_agent_manager 
from core.agents.rule_checker import RuleCheckerAgent
from core.agents.combat_narrator import get_combat_narrator_agent 
from core.stats.stats_manager import get_stats_manager 
from core.character.npc_manager import get_npc_manager as get_entity_manager 
from core.inventory.item_manager import get_inventory_manager as get_item_manager 
from core.inventory import register_inventory_commands 

# Import the new game flow modules
from core.game_flow import lifecycle
from core.game_flow import command_router
from core.game_flow.input_router import get_input_router

logger = get_logger("GAME_ENGINE") 

class GameEngine(QObject): 
    """
    Central game engine.
    
    This class coordinates between the state manager, command processor,
    and game loop. It provides a high-level API for controlling the game.
    """
    output_generated = Signal(str, str) 
    
    _instance = None
    orchestrated_event_to_ui = Signal(object)

    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(GameEngine, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the game engine."""
        if hasattr(self, '_initialized') and self._initialized:
            return
        
        super().__init__()
        logger.info("Initializing GameEngine")
        
        self._config = get_config()
        self._state_manager = StateManager()
        self._command_processor = CommandProcessor()
        self._game_loop = GameLoop()
        # Phase 1: One-time log: GameLoop time advancement is disabled.
        try:
            logger.info("PHASE 1: GameLoop time advancement is DISABLED. World time advances only via LLM time_passage and post-combat increments.")
        except Exception:
            pass

        try:
            from core.character.npc_system import NPCSystem
            self._npc_system = NPCSystem() 
            self._state_manager.set_npc_system(self._npc_system) 
            logger.info("NPCSystem initialized and set in StateManager.")
        except Exception as e:
            logger.error(f"Failed to initialize or set NPCSystem in StateManager: {e}", exc_info=True)
            self._npc_system = None 

        self._agent_manager = get_agent_manager()
        self._entity_manager = get_entity_manager() 
        self._item_manager = get_item_manager() 
        self._stats_manager = get_stats_manager() 
        
        self._rule_checker = RuleCheckerAgent(
            entity_manager=self._entity_manager,
            item_manager=self._item_manager,
            stats_manager=self._stats_manager,
        )
        
        self._running = False
        self._auto_save_timer = 0

        self._combat_narrator_agent = get_combat_narrator_agent()
        logger.info(f"Combat narrator agent initialized: {self._combat_narrator_agent is not None}")
        logger.info(f"Combat narrator has narrate_outcome: {hasattr(self._combat_narrator_agent, 'narrate_outcome')}")

        from core.orchestration.combat_orchestrator import CombatOutputOrchestrator
        from core.audio.tts_manager import TTSManager 
        self._combat_orchestrator = CombatOutputOrchestrator(self) 
        self._tts_manager = TTSManager(self) 
        self._combat_orchestrator.set_references(self, self._tts_manager)
        self._combat_orchestrator.load_config() 

        self._game_loop.add_tick_callback(self._handle_tick_callback)
        
        # Phase 1 autosave refactor: turn-based autosave settings
        self._autosave_turns: int = 0  # 0 = off
        self._turns_since_autosave: int = 0
        try:
            self.reload_autosave_settings()
            logger.info(f"Autosave configured: every {self._autosave_turns} turns (0=off)")
        except Exception as e:
            logger.warning(f"Failed to load autosave settings: {e}")

        # Apply QSettings gameplay values (difficulty, encounter_size) into config if present
        try:
            from PySide6.QtCore import QSettings
            s = QSettings("RPGGame", "Settings")
            diff_ui = s.value("gameplay/difficulty", None)
            enc_ui = s.value("gameplay/encounter_size", None)
            # Map UI values to tokens used by generator
            diff_map = {"Story": "story", "Normal": "normal", "Hard": "hard", "Expert": "expert"}
            enc_map = {"Solo": "solo", "Pack": "pack", "Mixed": "mixed"}
            if diff_ui:
                self._config._config_data.setdefault("game", {})
                self._config._config_data["game"]["difficulty"] = diff_map.get(diff_ui, "normal")
            if enc_ui:
                self._config._config_data.setdefault("game", {})
                self._config._config_data["game"]["encounter_size"] = enc_map.get(enc_ui, "solo")
        except Exception:
            pass
        
        register_inventory_commands()
        
        self._input_router = get_input_router()
        
        self._use_llm = True  
        self._waiting_for_closing_narrative_display: bool = False # New flag for ECFA
        self._post_combat_finalization_in_progress: bool = False  # Prevent duplicate auto-finalization
        
        self._initialized = True
        logger.info("GameEngine initialized")
    
    # Compatibility properties and methods for web server integration
    @property
    def state_manager(self):
        """Compatibility property for web server."""
        return self._state_manager
    
    @property
    def game_loop(self):
        """Compatibility property for web server."""
        return self._game_loop
    
    def initialize(self, new_game=True, player_name="Player", race="Human", 
                   path="Wanderer", background="Commoner", sex="Male",
                   character_image=None, use_llm=True, 
                   origin_id: Optional[str] = None): # Added origin_id
        """
        Initialize the game engine with a new or loaded game.
        
        This is a compatibility method for the web server integration.
        
        Args:
            new_game: Whether to start a new game or not.
            player_name: The name of the player character (for new games).
            race: The race of the player character (for new games).
            path: The class/path of the player character (for new games).
            background: The background of the player character (for new games).
            sex: The sex/gender of the player character (for new games).
            character_image: Path to character image (for new games).
            use_llm: Whether to enable LLM functionality.
            origin_id: The ID of the player's chosen origin (for new games).
        
        Returns:
            The game state.
        """
        # First, handle game initialization
        game_state = None
        if new_game:
            game_state = self.start_new_game(
                player_name=player_name, 
                race=race,
                path=path, 
                background=background,
                sex=sex,
                character_image=character_image,
                origin_id=origin_id # Pass origin_id
            )
        else:
            game_state = self._state_manager.current_state
        
        # Then, configure LLM as requested
        if use_llm != self._use_llm:
            self.set_llm_enabled(use_llm)
        
        return game_state
    
    def start_new_game(self, player_name: str, race: str = "Human", 
                        path: str = "Wanderer", background: str = "Commoner",
                        sex: str = "Male", character_image: Optional[str] = None,
                        stats: Optional[Dict[str, int]] = None, 
                        origin_id: Optional[str] = None) -> GameState:
        """
        Start a new game.
        
        This method properly handles starting a new game regardless of the current state.
        If there's an ongoing game, it will be properly cleaned up first.
        
        Args:
            player_name: The name of the player character.
            race: The race of the player character.
            path: The class/path of the player character.
            background: The background of the player character.
            sex: The sex/gender of the player character.
            character_image: Path to character image.
        
        Returns:
            The new game state.
        """
        logger.info(f"Starting new game for player {player_name}")
        
        # Clean up existing game if present
        if self._state_manager.current_state is not None:
            logger.info("Cleaning up existing game before starting new one")
            # Stop the game loop if it's running
            if self._game_loop.is_running:
                self._game_loop.pause()
                
            # Reset agent state if LLM is enabled
            if self._agent_manager is not None and self._use_llm:
                try:
                    self._agent_manager.reset_state()
                except Exception as e:
                    logger.warning(f"Error resetting agent state: {e}")
        
        # Reset any lingering post-combat flags and orchestrator state prior to creating the new game state
        try:
            self._waiting_for_closing_narrative_display = False
            self._post_combat_finalization_in_progress = False
            if hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                try:
                    self._combat_orchestrator.set_combat_manager(None)
                except Exception:
                    pass
                self._combat_orchestrator.clear_queue_and_reset_flags()
                # Explicitly clear Combat Log UI to avoid any stale content from prior session
                try:
                    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                    clear_event = DisplayEvent(
                        type=DisplayEventType.COMBAT_LOG_SET_HTML,
                        content="",
                        role='system',
                        target_display=DisplayTarget.COMBAT_LOG,
                        gradual_visual_display=False,
                        tts_eligible=False,
                        source_step='NEW_GAME_RESET'
                    )
                    self._combat_orchestrator.add_event_to_queue(clear_event)
                except Exception:
                    pass
            # Clear NPCSystem memory so name-based lookups (e.g., 'wolf_1') do not reuse stale NPCs from previous session
            try:
                if hasattr(self, '_npc_system') and self._npc_system:
                    self._npc_system.clear_all_npcs()
                    logger.info("NPCSystem cleared for new game session.")
            except Exception as npce:
                logger.warning(f"Failed to clear NPCSystem for new game: {npce}")
        except Exception as e:
            logger.warning(f"Error resetting orchestrator/flags before new game: {e}")

        # Create new game state - this will be passed to lifecycle.start_new_game
        # We don't want to create a new one there as well
        game_state = self._state_manager.create_new_game(
            player_name=player_name,
            race=race,
            path=path,
            background=background,
            sex=sex,
            character_image=character_image,
            stats=stats,
            origin_id=origin_id # Pass origin_id
        )
        if background: # background from params is the origin description
            game_state.player.background = background # Ensure it's set if not already set by StateManager

        return lifecycle.start_new_game_with_state(
            self, game_state
        )
    
    def load_game(self, filename: str) -> Optional[GameState]:
        """
        Load a game from a save file.
        
        This method handles loading a game state with proper initialization of
        all systems, including LLM integration if enabled.
        
        Args:
            filename: The name of the save file.
        
        Returns:
            The loaded game state, or None if the load failed.
        """
        # Delegate to the lifecycle module
        return lifecycle.load_game(self, filename)

    
    def save_game(self, filename: Optional[str] = None, 
                 auto_save: bool = False) -> Optional[str]:
        """
        Save the current game.
        
        Args:
            filename: The name of the save file. If None, generates a name.
            auto_save: Whether this is an auto-save.
        
        Returns:
            The path to the save file, or None if the save failed.
        """
        # Delegate to the lifecycle module
        return lifecycle.save_game(self, filename, auto_save)

    
    def reload_autosave_settings(self) -> None:
        """Reload autosave settings from QSettings. Uses turn-based interval.
        gameplay/autosave_interval: integer number of narrative turns between auto-saves. 0 means Off.
        """
        try:
            from PySide6.QtCore import QSettings
            s = QSettings("RPGGame", "Settings")
            turns = s.value("gameplay/autosave_interval", 0, int)
            if turns is None:
                turns = 0
            self._autosave_turns = max(0, int(turns))
            # Reset counter when changing policy to avoid immediate autosave on change
            self._turns_since_autosave = 0
            logger.info(f"Reloaded autosave setting: {self._autosave_turns} turns (0=off)")
        except Exception as e:
            logger.warning(f"Could not reload autosave settings: {e}")
    
    def _maybe_autosave_after_narrative(self) -> None:
        """Increment narrative turn counter and autosave if threshold reached.
        Robustly re-reads the current setting from QSettings to respect runtime changes (OFF/turns).
        """
        try:
            # Re-read current setting to ensure immediate effect when user toggles OFF
            try:
                from PySide6.QtCore import QSettings
                turns = QSettings("RPGGame", "Settings").value("gameplay/autosave_interval", 0, int)
                self._autosave_turns = max(0, int(turns or 0))
            except Exception:
                # keep previous value if QSettings not available
                pass
            
            if self._autosave_turns and self._autosave_turns > 0:
                self._turns_since_autosave += 1
                if self._turns_since_autosave >= self._autosave_turns:
                    self._turns_since_autosave = 0
                    try:
                        lifecycle.save_game(self, auto_save=True)
                        logger.info("Auto-saved game after reaching narrative turn threshold.")
                    except Exception as e:
                        logger.warning(f"Autosave failed: {e}")
        except Exception as e:
            logger.warning(f"Autosave counter error: {e}")
    
    def process_command(self, command_text: str) -> CommandResult:
        """
        Process a command.
        
        This method delegates to the CommandProcessor or AgentManager to handle the command,
        then processes any side effects (like exiting the game).
        
        Args:
            command_text: The command text to process.
        
        Returns:
            The result of executing the command.
        """
        # Delegate command processing to the command router module
        return command_router.route_command(self, command_text)
        
    def process_input(self, command_text: str) -> CommandResult:
        """
        Process player input. Checks for combat end state first.

        Args:
            command_text: The text input from the player.

        Returns:
            The result of processing the input.
        """
        game_state = self._state_manager.current_state
        if not game_state:
            logger.warning("Cannot process input: No current game state")
            return CommandResult.error("No game in progress.")

        # If waiting for closing narrative, don't process new input
        if self._waiting_for_closing_narrative_display:
            logger.info("Input received while waiting for closing narrative display. Ignoring.")
            return CommandResult.error("Please wait for the current action to complete.")

        # --- Check for Combat End State First ---
        if game_state.current_mode == InteractionMode.COMBAT:
            combat_manager = game_state.combat_manager
            if combat_manager and combat_manager.current_step == CombatStep.COMBAT_ENDED:
                logger.info("CombatManager step is COMBAT_ENDED. Transitioning to NARRATIVE mode.")
                
                game_state.set_interaction_mode(InteractionMode.NARRATIVE)
                # Advance a default 5 minutes to capture combat duration immersively
                try:
                    if getattr(game_state, 'world', None):
                        from core.time.time_controller import get_time_controller
                        get_time_controller().apply_post_combat_increment(game_state.world)
                except Exception:
                    pass
                final_combat_outcome = combat_manager.state.name if combat_manager.state else "Unknown"
                
                # Clear combat manager from game state and orchestrator
                game_state.combat_manager = None 
                if hasattr(self, '_combat_orchestrator'):
                    self._combat_orchestrator.set_combat_manager(None)
                    self._combat_orchestrator.clear_queue_and_reset_flags() # Clear any pending combat events

                # Queue system message for "Combat has concluded" via orchestrator for MAIN_GAME_OUTPUT
                # This assumes the orchestrator might be used for NARRATIVE mode outputs too, or a similar one exists.
                # For now, we'll make the orchestrator handle this specific post-combat sequence.
                from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                
                system_end_event = DisplayEvent(
                    type=DisplayEventType.SYSTEM_MESSAGE,
                    content=f"Combat has concluded. Outcome: {final_combat_outcome}.",
                    target_display=DisplayTarget.MAIN_GAME_OUTPUT, # Important: To GameOutputWidget
                    gradual_visual_display=False,
                    tts_eligible=False 
                )
                self._combat_orchestrator.add_event_to_queue(system_end_event)

                if self._use_llm:
                    closing_prompt = f"The combat has just ended. The outcome was: {final_combat_outcome}. Provide a brief, immersive closing narrative (1-2 sentences) describing the aftermath for the player."
                    
                    # This needs to be handled carefully. We need the LLM call to happen,
                    # then its result queued with the orchestrator.
                    # The actual input processing (command_text) should wait until this whole sequence is done.
                    
                    # For now, let's set a flag and the orchestrator will handle the LLM call after the system message.
                    # This is complex. Simpler: GameEngine makes LLM call, then queues result.
                    self._waiting_for_closing_narrative_display = True # Block further input

                    # Perform LLM call for closing narrative (can be async or in a separate thread later)
                    try:
                        from core.game_flow.interaction_core import _build_interaction_context, _get_agent_response
                        logger.info(f"Requesting closing combat narrative with prompt: {closing_prompt}")
                        context = _build_interaction_context(game_state, InteractionMode.COMBAT, actor_id=getattr(game_state.player, 'id', None))
                        agent_output = _get_agent_response(self, game_state, context, closing_prompt, InteractionMode.COMBAT)
                        closing_text = agent_output.get('narrative') if agent_output else None
                        if closing_text:
                            closing_narrative_event = DisplayEvent(
                                type=DisplayEventType.NARRATIVE_GENERAL,
                                content=closing_text,
                                role="gm",
                                target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                                gradual_visual_display=True,
                                tts_eligible=True
                            )
                            self._combat_orchestrator.add_event_to_queue(closing_narrative_event)
                            logger.info(f"Queued closing combat narrative. Waiting for display.")
                        else:
                            logger.warning("Failed to generate closing combat narrative from LLM.")
                            self._waiting_for_closing_narrative_display = False # Allow input if LLM fails
                            
                    except Exception as e:
                        logger.error(f"Error generating closing combat narrative: {e}", exc_info=True)
                        self._waiting_for_closing_narrative_display = False # Allow input on error

                else: # LLM disabled, just log conclusion
                    logger.info(f"LLM disabled. Combat concluded ({final_combat_outcome}).")

                # If not waiting for LLM narrative (or it failed), allow new input.
                # Otherwise, return "processing" to block further input until narrative displays.
                if not self._waiting_for_closing_narrative_display:
                    logger.info(f"Mode transitioned to NARRATIVE. Now processing initial input: '{command_text}'")
                    # Fall through to process the current command_text in NARRATIVE mode
                else:
                    logger.info("Waiting for closing combat narrative to display before processing new input.")
                    return CommandResult.success("Concluding combat...") # Indicate processing

            elif not combat_manager and game_state.current_mode == InteractionMode.COMBAT:
                logger.error("In COMBAT mode but CombatManager is None. Resetting to NARRATIVE.")
                game_state.set_interaction_mode(InteractionMode.NARRATIVE)
                if hasattr(self, '_combat_orchestrator'):
                    self._combat_orchestrator.set_combat_manager(None)


        # --- Proceed with Input Routing (using the potentially updated mode) ---
        return self._input_router.route_input(self, command_text)

    def _finalize_combat_transition_if_needed(self) -> None:
        """Automatically transition to NARRATIVE and queue post-combat output when combat ends successfully.
        This is invoked by the Orchestrator when it becomes idle after the final combat event.
        It intentionally does nothing for PLAYER_DEFEAT because Game Over is handled elsewhere in the GUI.
        """
        try:
            game_state = self._state_manager.current_state
            if not game_state:
                return
            # Only react if currently in COMBAT mode
            if game_state.current_mode != InteractionMode.COMBAT:
                return
            combat_manager = getattr(game_state, 'combat_manager', None)
            if not combat_manager:
                return
            # Only proceed when CombatManager signaled the end of combat
            if combat_manager.current_step != CombatStep.COMBAT_ENDED:
                return
            # Skip auto-transition on player defeat (Game Over flow handles this)
            if getattr(combat_manager, 'state', None) == CombatState.PLAYER_DEFEAT:
                logger.info("Auto finalize skipped: PLAYER_DEFEAT handled by Game Over flow.")
                return

            if self._post_combat_finalization_in_progress:
                # Avoid duplicate invocations
                return
            self._post_combat_finalization_in_progress = True

            # Transition mode and detach combat manager
            game_state.set_interaction_mode(InteractionMode.NARRATIVE)
            # Advance a default 5 minutes to capture combat duration immersively
            try:
                if getattr(game_state, 'world', None):
                    from core.time.time_controller import get_time_controller
                    get_time_controller().apply_post_combat_increment(game_state.world)
            except Exception:
                pass
            final_combat_outcome = combat_manager.state.name if getattr(combat_manager, 'state', None) else "Unknown"
            game_state.combat_manager = None

            # Reset orchestrator for post-combat messages
            if hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                self._combat_orchestrator.set_combat_manager(None)
                self._combat_orchestrator.clear_queue_and_reset_flags()

            # Ensure UI reflects the mode change promptly
            try:
                from PySide6.QtCore import QTimer
                if hasattr(self, 'main_window_ref') and self.main_window_ref:
                    main_window = self.main_window_ref()
                    if main_window and hasattr(main_window, '_update_ui'):
                        QTimer.singleShot(0, main_window._update_ui)
            except Exception:
                pass

            # Queue post-combat system message and closing narrative via orchestrator
            try:
                from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                system_end_event = DisplayEvent(
                    type=DisplayEventType.SYSTEM_MESSAGE,
                    content=f"Combat has concluded. Outcome: {final_combat_outcome}.",
                    target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                    gradual_visual_display=False,
                    tts_eligible=False
                )
                if hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                    self._combat_orchestrator.add_event_to_queue(system_end_event)

                if self._use_llm and hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                    # Request a short closing narrative
                    self._waiting_for_closing_narrative_display = True
                    try:
                        from core.game_flow.interaction_core import process_with_llm
                        closing_prompt = (
                            f"The combat has just ended. The outcome was: {final_combat_outcome}. "
                            f"Provide a brief, immersive closing narrative (1-2 sentences) describing the aftermath for the player."
                        )
                        logger.info(f"Requesting closing combat narrative with prompt: {closing_prompt}")
                        closing_result = process_with_llm(game_state, closing_prompt)
                        if closing_result.is_success and closing_result.message:
                            closing_narrative_event = DisplayEvent(
                                type=DisplayEventType.NARRATIVE_GENERAL,
                                content=closing_result.message,
                                role="gm",
                                target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                                gradual_visual_display=True,
                                tts_eligible=True
                            )
                            self._combat_orchestrator.add_event_to_queue(closing_narrative_event)
                            logger.info("Queued closing combat narrative after auto-finalize.")
                        else:
                            logger.warning("Failed to generate closing combat narrative after auto-finalize.")
                            self._waiting_for_closing_narrative_display = False
                    except Exception as e:
                        logger.error(f"Error generating closing combat narrative after auto-finalize: {e}", exc_info=True)
                        self._waiting_for_closing_narrative_display = False
            except Exception as e:
                logger.error(f"Error queuing post-combat messages during auto-finalize: {e}", exc_info=True)
        finally:
            self._post_combat_finalization_in_progress = False

    def set_llm_enabled(self, enabled: bool) -> None:
        """
        Enable or disable the LLM system.

        Args:
            enabled: Whether to enable the LLM system.
        """
        self._use_llm = enabled
        logger.info(f"LLM system {'enabled' if enabled else 'disabled'}")
        if hasattr(self, '_initialized') and self._initialized and not enabled:
            self._output("system", f"LLM system disabled")

    def reload_llm_settings(self) -> None:
        """
        Reload LLM-related agent settings at runtime so provider/model changes
        take effect immediately (including during ongoing combat).
        """
        # Reload AgentManager-managed agents
        try:
            if hasattr(self, '_agent_manager') and self._agent_manager is not None:
                self._agent_manager.reload_settings()
                # After reloading settings, fully reset agent state to reinitialize any cached clients/models
                try:
                    self._agent_manager.reset_state()
                except Exception as e_reset:
                    logger.warning(f"Error resetting AgentManager state after reload: {e_reset}")
                logger.info("AgentManager settings reloaded.")
        except Exception as e:
            logger.warning(f"Error reloading AgentManager settings: {e}")
        
        # Reload Combat Narrator agent (owned by GameEngine)
        try:
            if hasattr(self, '_combat_narrator_agent') and self._combat_narrator_agent is not None:
                self._combat_narrator_agent.reload_settings()
                logger.info("CombatNarratorAgent settings reloaded.")
        except Exception as e:
            logger.warning(f"Error reloading CombatNarratorAgent settings: {e}")
        
        # Optional: Provide user feedback in UI
        try:
            self._output("system", "LLM settings reloaded.")
        except Exception:
            # Avoid failing if UI is not connected yet
            pass

    def _output(self, role: str, content: str) -> None:
        """
        Output a message by emitting the output_generated signal.
        This method is now simplified. The primary responsibility is to add to
        conversation history (if applicable) and emit the signal.
        Buffering and complex routing are handled by MainWindow and Orchestrator
        based on DisplayEvents.
        Args:
            role: The role of the speaker (e.g., "system", "gm", "player").
            content: The content of the message.
        """
        logger.info(f"ENGINE._output called with role='{role}', content='{content[:50]}...'")
        
        # Special logging for reintroductory narrative debugging
        if role == "gm" and ("night air" in content or "find yourself" in content):
            logger.info(f"LIFECYCLE_DEBUG: ENGINE._output - This appears to be reintroductory narrative")
            logger.info(f"LIFECYCLE_DEBUG: Full content length: {len(content)}")
            logger.info(f"LIFECYCLE_DEBUG: Content preview: '{content[:300]}...'")
        
        if self._state_manager.current_state is not None and role != "system":
            self._state_manager.current_state.add_conversation_entry(role, content)
            logger.debug(f"Added to conversation history: role='{role}'")

        try:
            logger.debug(f"Emitting output_generated signal with role='{role}', content (type: {type(content).__name__})")
            logger.info(f"LIFECYCLE_DEBUG: About to emit output_generated signal to GUI")
            self.output_generated.emit(role, content) # MainWindow will handle DisplayEvent objects if content is one
            logger.debug("Signal emission successful")
            logger.info(f"LIFECYCLE_DEBUG: output_generated signal emitted successfully")
        except RuntimeError as e:
            logger.error(f"RuntimeError emitting output_generated signal: {e}", exc_info=True)
        except Exception as e:
            logger.error(f"Error emitting output_generated signal: {e}", exc_info=True)
        
        # After emitting, handle turn-based autosave on narrative outputs (NARRATIVE mode only)
        try:
            state = self._state_manager.current_state
            if role == "gm" and state is not None:
                try:
                    from core.interaction.enums import InteractionMode as _IM
                    if getattr(state, 'current_mode', None) == _IM.NARRATIVE:
                        self._maybe_autosave_after_narrative()
                except Exception:
                    # Fallback: if enum import fails, attempt name check
                    mode = getattr(getattr(state, 'current_mode', None), 'name', '')
                    if mode == 'NARRATIVE':
                        self._maybe_autosave_after_narrative()
        except Exception as e:
            logger.debug(f"Turn-based autosave check skipped due to error: {e}")

        # Dev-only time audit log after narrative outputs (disabled by default)
        try:
            state = self._state_manager.current_state
            if role == "gm" and state is not None:
                mode_name = getattr(getattr(state, 'current_mode', None), 'name', '')
                if mode_name == 'NARRATIVE':
                    from core.base.config import get_config as _get_cfg
                    cfg = _get_cfg()
                    # Default ON via game domain if not explicitly set
                    val_debug = cfg.get('debug.time_audit_log_enabled', None)
                    val_system = cfg.get('system.debug.time_audit_log_enabled', None)
                    val_game = cfg.get('game.debug.time_audit_log_enabled', None)
                    enabled = bool(
                        (val_debug is True) or (val_system is True) or (val_game if val_game is not None else True)
                    )
                    if enabled:
                        w = getattr(state, 'world', None)
                        if w is not None:
                            payload = {
                                'ts': int(time.time()),
                                'mode': mode_name,
                                'game_time_s': float(getattr(w, 'game_time', 0.0) or 0.0),
                                'calendar_compact': getattr(w, 'calendar_compact', None),
                                'period': getattr(w, 'time_of_day', None),
                            }
                            try:
                                from core.utils.logging_config import get_logger as _gl
                                _gl('TIME_AUDIT').info(json.dumps(payload, ensure_ascii=False))
                            except Exception:
                                pass
        except Exception:
            # Never let audit logging break gameplay
            pass

    def _handle_tick_callback(self, elapsed_game_time: float) -> None:
        """Callback for game loop tick, delegates to lifecycle module."""
        lifecycle.handle_tick(self, elapsed_game_time)

    def run(self, target_fps: int = 30) -> None:
        """
        Run the game loop.
        (Kept in Engine as it manages the loop state)
        Args:
            target_fps: The target frames per second.
        """
        logger.warning(f"Engine.run() invoked with target FPS: {target_fps}. Time advancement is DISABLED (Phase 1).")
        self._running = True
        self._game_loop.unpause()
        try:
            while self._running:
                self._game_loop.tick()  # no-op advancement
                time.sleep(1.0 / target_fps)
        except KeyboardInterrupt:
            logger.info("Game engine interrupted")
        except Exception as e:
            logger.error(f"Error in game engine: {e}", exc_info=True)
        finally:
            self._game_loop.pause()
            logger.info("Game engine stopped")

    def stop(self) -> None:
        """Stop the game engine."""
        logger.info("Stopping game engine")
        self._running = False
        self._game_loop.pause()
        # No autosave scheduler to stop (turn-based autosave only)
        try:
            self._turns_since_autosave = 0
        except Exception:
            pass

    def set_game_speed(self, speed: GameSpeed) -> None:
        """
        Set the game speed.
        (Kept in Engine as it controls the game loop)
        Args:
            speed: The new game speed.
        """
        self._game_loop.speed = speed
        logger.info(f"Game speed set to {speed.name}")
        logger.warning("Note: Phase 1 – Time advancement is disabled; speed affects no time progression.")
        self._output("system", f"Game speed set to {speed.name.lower()} (no time progression in Phase 1)")

    def toggle_pause(self) -> bool:
        """
        Toggle the game pause state.
        (Kept in Engine as it controls the game loop)
        Returns:
            The new pause state (True if paused, False if unpaused).
        """
        paused = self._game_loop.toggle_pause()
        if paused:
            self._output("system", "Game paused")
        else:
            self._output("system", "Game unpaused")
        return paused
    
    # --- ECFA Change: New method for MainWindow to call ---
    @Slot(object) # Use object for DisplayEvent type hint if DisplayEvent is complex
    def main_window_handle_orchestrated_event(self, display_event): # game_state is implicit via self._state_manager
        """
        Called by the CombatOutputOrchestrator to route a DisplayEvent's
        content to the MainWindow's _handle_game_output method.
        This decouples Orchestrator from directly knowing MainWindow.
        """
        from core.orchestration.events import DisplayEvent # Local import for type check
        if not isinstance(display_event, DisplayEvent):
            logger.error(f"Engine received non-DisplayEvent object: {type(display_event)}")
            return

        logger.debug(f"Engine routing orchestrated event to MainWindow: {display_event}")
        
        # MainWindow's _handle_game_output will now need to understand DisplayEvent or its parts
        # It's better if _handle_game_output is adapted or a new method is called.
        # For now, we pass DisplayEvent directly and expect MainWindow to adapt.
        
        # We emit a new signal or call a direct method on MainWindow.
        # Let's assume MainWindow has a slot `handle_orchestrated_display_event(DisplayEvent)`
        
        # To avoid direct MainWindow dependency here, GameEngine can emit a specific signal
        # that MainWindow listens to, or MainWindow can connect to a slot on the engine.
        # For simplicity with current structure, assuming GameEngine's output_generated
        # is caught by MainWindow which then checks if the content is a DisplayEvent.
        # This is not ideal. A more direct call/signal is better.

        # Alternative: Add a new signal on GameEngine for orchestrated events
        # class GameEngine(QObject):
        #     orchestrated_event_for_main_window = Signal(DisplayEvent) # Define this signal

        # Then emit it:
        # self.orchestrated_event_for_main_window.emit(display_event)

        # For now, re-using _output with a special role or by passing the event itself.
        # Let's modify _output slightly or add a new way for MainWindow to get this.

        # The simplest for now is to call MainWindow's handler directly if MainWindow ref is stored.
        # Assuming MainWindow is accessible via engine for this example, though this creates coupling.
        # A better way is a new signal from engine that MainWindow connects to.
        if hasattr(self, 'main_window_ref') and self.main_window_ref: # Assuming MainWindow registers itself
            main_window = self.main_window_ref()
            if main_window:
                # MainWindow needs a method to handle this, e.g., process_display_event_from_orchestrator
                if hasattr(main_window, 'process_orchestrated_display_event'):
                    main_window.process_orchestrated_display_event(display_event)
                else:
                    # Fallback: use existing _output, MainWindow's _handle_game_output must adapt
                    if isinstance(display_event.content, str):
                        self._output(display_event.role or "system", display_event.content)
                    elif isinstance(display_event.content, list) and display_event.type == DisplayEventType.BUFFER_FLUSH:
                        for line in display_event.content:
                             self._output(display_event.role or "gm", line) # Assume buffer is GM narrative
                    else:
                        logger.warning(f"Orchestrated event content type not directly printable: {type(display_event.content)}")
            else:
                logger.error("MainWindow reference lost in GameEngine.")
        else:
            logger.error("GameEngine does not have a reference to MainWindow to send orchestrated event.")    

    @Slot()
    def on_orchestrator_idle_and_combat_manager_resumed(self):
        """
        Called by the orchestrator when it's idle AND after it has signaled
        CombatManager to resume (if CM was waiting).
        This specifically handles the post-combat closing narrative.
        """
        if self._waiting_for_closing_narrative_display:
            logger.info("Orchestrator idle and CM resumed (or was not waiting). Closing narrative display should be complete.")
            self._waiting_for_closing_narrative_display = False
            # Potentially trigger UI re-enable or next game prompt if needed here.
            # For now, just unblocks further input in process_input.

# Convenience function (remains the same)
def get_game_engine() -> GameEngine:
    """Get the game engine instance."""
    return GameEngine()
```

### File: core\base\game_loop.py

```python
#!/usr/bin/env python3
"""
Game loop and time management for the RPG game.

This module provides classes for managing the game loop, 
game time, and tick processing. It handles advancing time
in the game world and executing scheduled events.
"""

import time
import threading
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set, Any, Union, Callable
from enum import Enum, auto
import datetime
import logging

from core.utils.logging_config import get_logger
from core.base.state import WorldState

# Get the module logger
logger = get_logger("GAME")

class GameSpeed(Enum):
    """Game speed settings."""
    PAUSED = 0
    NORMAL = 1
    FAST = 3
    SUPER_FAST = 10


@dataclass
class GameTime:
    """
    Game time management.
    
    This class handles tracking and manipulating the game time,
    including conversions between real time and game time.
    
    NOTE: DEPRECATED (Phase 1): The project no longer advances time based on
    real-world passage. Fields like `time_scale` and `start_time` are kept
    for backward compatibility and serialization only and should not be used
    to compute world time. Game time now advances only via explicit
    game context (LLM `time_passage`) and the fixed post-combat increment.
    """
    # Current game time in seconds
    game_time: float = 0.0
    
    # Time scale (game seconds per real second)
    # DEPRECATED: Retained for backward compatibility. Do not use.
    time_scale: float = 60.0  # Default preserved for legacy reads
    
    # Game start timestamp (real time)
    # DEPRECATED: Retained for backward compatibility. Do not use.
    start_time: float = field(default_factory=time.time)
    
    # Day cycle in seconds (24 hours)
    DAY_CYCLE: float = 24 * 60 * 60  # 86400 seconds
    
    # Hour in seconds
    HOUR: float = 60 * 60  # 3600 seconds
    
    # Minute in seconds
    MINUTE: float = 60  # 60 seconds
    
    def get_game_datetime(self) -> datetime.datetime:
        """
        Get the current game time as a datetime object.
        
        Returns:
            A datetime object representing the current game time.
        """
        # Use a fixed start date for the game world
        start_date = datetime.datetime(year=1000, month=1, day=1)
        
        # Calculate the total days that have passed
        days_passed = int(self.game_time / self.DAY_CYCLE)
        
        # Calculate the remaining seconds in the current day
        day_seconds = self.game_time % self.DAY_CYCLE
        
        # Create a timedelta and add it to the start date
        delta = datetime.timedelta(days=days_passed, seconds=day_seconds)
        return start_date + delta
    
    def get_formatted_time(self, format_str: str = "%Y-%m-%d %H:%M:%S") -> str:
        """
        Get the current game time as a formatted string.
        
        Args:
            format_str: The format string to use.
        
        Returns:
            A formatted string representing the current game time.
        """
        return self.get_game_datetime().strftime(format_str)
    
    def get_time_of_day(self) -> str:
        """
        Get the current time of day as a narrative description.
        
        DEPRECATED: This method now uses enhanced time descriptions.
        
        Returns:
            A narrative description of the time of day (e.g., "morning", "sunset", "deep night").
        """
        try:
            from core.utils.enhanced_time_manager import get_simple_time
            return get_simple_time(self.game_time)
        except ImportError:
            # Fallback to old logic if enhanced time manager not available
            hour = self.get_game_datetime().hour
            
            if 5 <= hour < 12:
                return "Morning"
            elif 12 <= hour < 17:
                return "Afternoon"
            elif 17 <= hour < 21:
                return "Evening"
            else:
                return "Night"
    
    def advance(self, seconds: float) -> None:
        """
        Advance the game time by the specified number of seconds.
        
        Args:
            seconds: The number of seconds to advance.
        """
        self.game_time += seconds
        logger.debug(f"Game time advanced by {seconds} seconds to {self.get_formatted_time()}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert GameTime to a dictionary for serialization."""
        return {
            "game_time": self.game_time,
            "time_scale": self.time_scale,
            "start_time": self.start_time,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GameTime':
        """Create a GameTime from a dictionary."""
        return cls(
            game_time=data.get("game_time", 0.0),
            time_scale=data.get("time_scale", 60.0),
            start_time=data.get("start_time", time.time()),
        )


@dataclass
class ScheduledEvent:
    """
    An event scheduled to occur at a specific game time.
    
    This dataclass represents a function to be called when the game
    time reaches a specific value.
    """
    time: float  # Game time when the event should occur
    callback: Callable[[], None]  # Function to call
    id: str  # Unique identifier
    repeats: bool = False  # Whether the event repeats
    interval: Optional[float] = None  # Interval for repeating events


class GameLoop:
    """
    Game loop manager.
    
    This class manages the game loop, including tick processing,
    time advancement, and scheduled events. It provides control
    over game speed and pausing.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(GameLoop, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self, world_state = None):
        """Initialize the game loop."""
        if self._initialized:
            return
        
        # Game time
        self._game_time = GameTime()
        
        # Game speed
        self._speed = GameSpeed.NORMAL
        
        # Paused state
        self._paused = True
        
        # Tick counter
        self._tick_count = 0
        
        # Last real-time tick
        self._last_tick_time = time.time()
        
        # Callbacks for tick events
        self._tick_callbacks: List[Callable[[float], None]] = []
        
        # Scheduled events
        self._events: Dict[str, ScheduledEvent] = {}
        
        # Reference to the world state (for time updates)
        self._world_state = world_state
        
        # Lock for thread safety
        self._lock = threading.RLock()
        
        # Phase 1: Disable real-time advancement of game time.
        # Time now advances only via explicit engine calls (LLM time_passage, post-combat increment).
        self._time_advance_disabled: bool = True
        logger.info("GameLoop initialized with time advancement DISABLED (Phase 1).")
        
        self._initialized = True
    
    @property
    def game_time(self) -> GameTime:
        """Get the game time."""
        return self._game_time
    
    @property
    def is_paused(self) -> bool:
        """Check if the game is paused."""
        return self._paused
    
    @property
    def is_running(self) -> bool:
        """Compatibility property for web server - checks if game is running (not paused)."""
        return not self._paused
    
    @property
    def speed(self) -> GameSpeed:
        """Get the game speed."""
        return self._speed
    
    @speed.setter
    def speed(self, value: GameSpeed) -> None:
        """Set the game speed.
        NOTE: Phase 1 – time advancement is disabled; speed changes have no effect on time.
        """
        if not isinstance(value, GameSpeed):
            raise TypeError(f"Expected GameSpeed, got {type(value)}")
        
        with self._lock:
            self._speed = value
            logger.debug(f"Game speed set to {value.name}")
            if self._time_advance_disabled:
                logger.warning("GameLoop speed changed while time advancement is DISABLED. This does not affect world time (Phase 1).")
    
    def set_world_state(self, world_state: WorldState) -> None:
        """
        Set the world state reference.
        
        Args:
            world_state: The world state to reference.
        """
        with self._lock:
            self._world_state = world_state
    
    def pause(self) -> None:
        """Pause the game loop."""
        with self._lock:
            if not self._paused:
                self._paused = True
                logger.debug("Game paused")
    
    def unpause(self) -> None:
        """Unpause the game loop.
        NOTE: Phase 1 – unpausing does not cause time progression by itself.
        """
        with self._lock:
            if self._paused:
                self._paused = False
                self._last_tick_time = time.time()  # Reset the tick timer
                logger.debug("Game unpaused")
                if self._time_advance_disabled:
                    logger.warning("GameLoop unpaused while time advancement is DISABLED. No time progression will occur (Phase 1).")
    
    def toggle_pause(self) -> bool:
        """
        Toggle the pause state.
        
        Returns:
            The new pause state (True if paused, False if unpaused).
        """
        with self._lock:
            if self._paused:
                self.unpause()
            else:
                self.pause()
            return self._paused
    
    def add_tick_callback(self, callback: Callable[[float], None]) -> None:
        """
        Add a callback to be called on every tick.
        
        Args:
            callback: A function that takes the elapsed game time as an argument.
        """
        with self._lock:
            self._tick_callbacks.append(callback)
    
    def remove_tick_callback(self, callback: Callable[[float], None]) -> None:
        """
        Remove a tick callback.
        
        Args:
            callback: The callback to remove.
        """
        with self._lock:
            if callback in self._tick_callbacks:
                self._tick_callbacks.remove(callback)
    
    def schedule_event(self, game_time: float, callback: Callable[[], None], 
                      event_id: str, repeats: bool = False, 
                      interval: Optional[float] = None) -> None:
        """
        Schedule an event to occur at a specific game time.
        
        Args:
            game_time: The game time when the event should occur.
            callback: The function to call when the event occurs.
            event_id: A unique identifier for the event.
            repeats: Whether the event repeats.
            interval: The interval for repeating events.
        """
        with self._lock:
            if event_id in self._events:
                logger.warning(f"Replacing existing event with ID {event_id}")
            
            self._events[event_id] = ScheduledEvent(
                time=game_time,
                callback=callback,
                id=event_id,
                repeats=repeats,
                interval=interval
            )
            
            logger.debug(f"Scheduled event {event_id} at game time {game_time}")
    
    def cancel_event(self, event_id: str) -> bool:
        """
        Cancel a scheduled event.
        
        Args:
            event_id: The ID of the event to cancel.
        
        Returns:
            True if the event was cancelled, False if not found.
        """
        with self._lock:
            if event_id in self._events:
                del self._events[event_id]
                logger.debug(f"Cancelled event {event_id}")
                return True
            return False
    
    def tick(self) -> None:
        """
        Process a single tick.
        
        Phase 1: Real-time based advancement is DISABLED. This tick will not advance
        world time. It will only notify callbacks with 0 elapsed time to avoid
        breaking any auxiliary logic that may still listen to ticks.
        """
        with self._lock:
            # Skip if paused
            if self._paused:
                self._last_tick_time = time.time()
                return
            
            # Update last tick time to avoid drift in any external references
            self._last_tick_time = time.time()
            
            elapsed_game = 0.0
            old_game_time = self._game_time.game_time
            
            if not self._time_advance_disabled:
                # Defensive: If someone re-enabled it, warn and still prevent advancement.
                logger.error("GameLoop time advancement was re-enabled unexpectedly. Preventing advancement (Phase 1 invariant).")
                self._time_advance_disabled = True
            
            # Do NOT advance self._game_time or world_state here.
            # Do NOT process scheduled events that depend on time progression.
            # (If event processing by absolute time is needed in future, it must be driven by explicit time passage.)
            
            # Call tick callbacks with 0 elapsed
            for callback in self._tick_callbacks:
                try:
                    callback(elapsed_game)
                except Exception as e:
                    logger.error(f"Error in tick callback: {e}", exc_info=True)
            
            # Increment tick counter
            self._tick_count += 1
            
            # Log tick data at debug level periodically
            if self._tick_count % 100 == 0:
                logger.debug(f"Tick {self._tick_count} (no-op advancement). Game time remains: {self._game_time.get_formatted_time()}")
    
    def _process_events(self, from_time: float, to_time: float) -> None:
        """
        Process events that should occur between the specified times.
        
        Args:
            from_time: The start of the time range.
            to_time: The end of the time range.
        """
        # Collect events to reschedule
        reschedule = []
        
        # Process each event
        for event_id, event in list(self._events.items()):
            # Check if the event time is in the range [from_time, to_time]
            if from_time <= event.time <= to_time:
                # Execute the event
                try:
                    event.callback()
                    logger.debug(f"Executed event {event_id}")
                except Exception as e:
                    logger.error(f"Error executing event {event_id}: {e}", exc_info=True)
                
                # Handle repeating events
                if event.repeats and event.interval is not None:
                    # Schedule the next occurrence
                    next_time = event.time + event.interval
                    reschedule.append((event_id, event.callback, next_time, event.repeats, event.interval))
                
                # Remove the event
                del self._events[event_id]
        
        # Reschedule repeating events
        for event_id, callback, next_time, repeats, interval in reschedule:
            self.schedule_event(next_time, callback, event_id, repeats, interval)
    
    def run(self, target_fps: int = 30) -> None:
        """
        Run the game loop at the specified framerate.
        
        Phase 1: Time advancement is disabled. This loop will not advance world time.
        
        Args:
            target_fps: The target frames per second.
        """
        target_frame_time = 1.0 / target_fps
        running = True
        
        logger.warning(f"Starting GameLoop.run() with time advancement DISABLED (Phase 1). target_fps={target_fps}")
        
        try:
            while running:
                # Record the start time
                start_time = time.time()
                
                # Process a tick (no-op advancement)
                self.tick()
                
                # Calculate how long to sleep
                elapsed = time.time() - start_time
                sleep_time = max(0, target_frame_time - elapsed)
                
                # Sleep to maintain the target FPS
                if sleep_time > 0:
                    time.sleep(sleep_time)
        except KeyboardInterrupt:
            logger.info("Game loop interrupted")
        except Exception as e:
            logger.error(f"Error in game loop: {e}", exc_info=True)
        finally:
            logger.info("Game loop stopped")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert GameLoop state to a dictionary for serialization."""
        with self._lock:
            return {
                "game_time": self._game_time.to_dict(),
                "speed": self._speed.name,
                "paused": self._paused,
                "tick_count": self._tick_count,
                # Phase 1 flag (for diagnostics only; not required for load)
                "time_advance_disabled": True,
                # Note: We don't serialize callbacks or events as they are function references
            }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any], world_state = None) -> 'GameLoop':
        """Create a GameLoop from a dictionary."""
        instance = cls(world_state)
        
        with instance._lock:
            if "game_time" in data:
                instance._game_time = GameTime.from_dict(data["game_time"])
            
            if "speed" in data:
                instance._speed = GameSpeed[data["speed"]]
            
            if "paused" in data:
                instance._paused = data["paused"]
            
            if "tick_count" in data:
                instance._tick_count = data["tick_count"]
            
            # Enforce Phase 1 invariant regardless of persisted data
            instance._time_advance_disabled = True
        
        return instance


# Convenience function
def get_game_loop() -> GameLoop:
    """Get the game loop instance."""
    return GameLoop()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.DEBUG)
    
    # Create a game loop
    loop = get_game_loop()
    
    # Add a tick callback
    def on_tick(elapsed_game_time):
        if loop.game_time.game_time % 3600 < elapsed_game_time:  # Every hour of game time
            print(f"Game time: {loop.game_time.get_formatted_time()}")
    
    loop.add_tick_callback(on_tick)
    
    # Schedule an event
    def test_event():
        print("Test event executed!")
    
    # Schedule to occur after 10 seconds of game time
    loop.schedule_event(
        loop.game_time.game_time + 10,
        test_event,
        "test_event"
    )
    
    # Start the game loop
    print("Starting game loop, press Ctrl+C to stop")
    loop.unpause()
    loop.run()
```

### File: core\base\init_modules.py

```python
"""
Module initialization for the RPG game.

This module imports all necessary modules to ensure they are initialized properly.
"""

import logging
from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

def init_modules():
    """Initialize all necessary modules."""
    logger.info("Initializing game modules...")
    
    # Import core modules
    try:
        # Import inventory
        import core.inventory
        logger.info("Inventory module initialized")
        
        # Import combat system
        import core.combat
        logger.info("Combat module initialized")
        
        # Add other modules as needed
        
        logger.info("All modules initialized successfully")
        return True
    except Exception as e:
        logger.error(f"Error initializing modules: {e}", exc_info=True)
        return False

```

### File: core\base\state.py

```python
"""
State management for the RPG game.

This module provides classes for managing the overall game state,
including player state, world state, and game session information.

Note: This module is now a wrapper around the more granular modules in core.base.state package.
"""

# Re-export from the new modules
from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from core.base.state.game_state import GameState
from core.base.state.state_manager import StateManager, get_state_manager

__all__ = [
    'PlayerState',
    'WorldState',
    'GameState',
    'StateManager',
    'get_state_manager',
]

```

### File: core\character\background_generator.py

```python
#!/usr/bin/env python3
"""
Character background generation and enhancement module.

This module provides functionality for generating and enhancing character backgrounds
using LLM technology based on character attributes.
"""

import logging
from typing import Dict, Any, Optional, List

from core.utils.logging_config import get_logger, LogCategory
from core.llm.llm_manager import get_llm_manager, LLMRole

logger = get_logger(LogCategory.AGENT)

class BackgroundGenerator:
    """
    Handles character background generation and enhancement using LLM technology.
    """
    
    def __init__(self):
        """Initialize the background generator."""
        self.llm_manager = get_llm_manager()
        logger.info("Initialized BackgroundGenerator")
    
    def improve_background(self, background_text: str, character_data: Dict[str, Any]) -> Optional[str]:
        """
        Improve an existing character background.
        
        Args:
            background_text: The original background text to improve.
            character_data: Character data including race, class, etc.
            
        Returns:
            An improved version of the background text, or None if the request failed.
        """
        if not background_text.strip():
            logger.warning("Cannot improve empty background")
            return None
        
        try:
            logger.info("Improving character background")
            
            # Extract character info
            name = character_data.get('name', 'Character')
            race = character_data.get('race', 'Unknown')
            character_class = character_data.get('path', 'Unknown')
            background = character_data.get('background', 'Unknown')
            sex = character_data.get('sex', 'Unknown')
            
            # Create prompt for LLM
            messages = [
                {
                    "role": LLMRole.SYSTEM,
                    "content": f"""You are a creative writer specializing in fantasy RPG character backgrounds. 
                    You will be provided with a character background that needs improvement.
                    Your task is to enhance this background, making it more engaging, detailed, and aligned with fantasy RPG tropes.
                    Maintain the core elements and intentions of the original text, but improve the writing style, add depth,
                    and ensure it aligns well with the character's race, class, background, and sex.
                    
                    Your response should ONLY include the improved background text, with no additional commentary, explanations, or meta-text.
                    Keep the length reasonable - between 150-300 words is ideal."""
                },
                {
                    "role": LLMRole.USER,
                    "content": f"""Here's a character background that needs improvement:
                    
                    Character Info:
                    - Name: {name}
                    - Race: {race}
                    - Class: {character_class}
                    - Background: {background}
                    - Sex: {sex}
                    
                    Original background text:
                    "{background_text}"
                    
                    Please improve this background, making it more engaging and aligned with fantasy RPG conventions.
                    Remember to maintain the core elements while enhancing the writing style and depth.
                    Return ONLY the improved background text with no additional commentary.
                    """
                }
            ]
            
            # Get completion from LLM
            response = self.llm_manager.get_completion(messages)
            
            if response:
                improved_text = response.content.strip()
                logger.info(f"Successfully improved background (tokens: {response.total_tokens})")
                return improved_text
            else:
                logger.error("Failed to improve background: No response from LLM")
                return None
            
        except Exception as e:
            logger.error(f"Error improving background: {e}")
            return None
    
    def generate_background(self, character_data: Dict[str, Any]) -> Optional[str]:
        """
        Generate a new character background.
        
        Args:
            character_data: Character data including race, class, etc.
            
        Returns:
            A generated background text, or None if the request failed.
        """
        try:
            logger.info("Generating new character background")
            
            # Extract character info
            name = character_data.get('name', 'Character')
            race = character_data.get('race', 'Unknown')
            character_class = character_data.get('path', 'Unknown')
            background = character_data.get('background', 'Unknown')
            sex = character_data.get('sex', 'Unknown')
            
            # Extract stats if available
            stats_text = ""
            if 'stats' in character_data:
                stats = character_data['stats']
                stats_list = []
                for stat_name, stat_info in stats.items():
                    value = stat_info.get('value', 10)
                    stats_list.append(f"{stat_name}: {value}")
                stats_text = "\n".join(stats_list)
            
            # Create prompt for LLM
            messages = [
                {
                    "role": LLMRole.SYSTEM,
                    "content": f"""You are a creative writer specializing in fantasy RPG character backgrounds. 
                    You will be provided with details about a character, and your task is to create an engaging,
                    immersive background story for them.
                    
                    Create a background that:
                    1. Fits the character's race, class, background origin, and sex
                    2. Includes formative experiences that led them to their current class/profession
                    3. Incorporates appropriate fantasy RPG tropes without being cliché
                    4. Has some interesting hook or unique aspect to make the character memorable
                    5. Could serve as the beginning of an adventure
                    
                    Your response should ONLY include the background story, with no additional commentary, explanations, or meta-text.
                    The background should be between 200-350 words."""
                },
                {
                    "role": LLMRole.USER,
                    "content": f"""Please create an interesting character background for:
                    
                    Character Info:
                    - Name: {name}
                    - Race: {race}
                    - Class: {character_class}
                    - Background Origin: {background}
                    - Sex: {sex}
                    {f"- Stats:\n{stats_text}" if stats_text else ""}
                    
                    Generate a background story for this character that fits their attributes and would be engaging in a fantasy RPG setting.
                    The character's background origin is '{background}', which should inform their upbringing and formative experiences.
                    Return ONLY the background text with no additional commentary.
                    """
                }
            ]
            
            # Get completion from LLM
            response = self.llm_manager.get_completion(messages)
            
            if response:
                background_text = response.content.strip()
                logger.info(f"Successfully generated background (tokens: {response.total_tokens})")
                return background_text
            else:
                logger.error("Failed to generate background: No response from LLM")
                return None
            
        except Exception as e:
            logger.error(f"Error generating background: {e}")
            return None

# Convenience function
def get_background_generator() -> BackgroundGenerator:
    """Get a background generator instance."""
    return BackgroundGenerator()


# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    generator = get_background_generator()
    
    # Example character data
    character_data = {
        'name': 'Tordek',
        'race': 'Dwarf',
        'path': 'Warrior',
        'background': 'Soldier',
        'sex': 'Male'
    }
    
    # Example of improving a background
    original_background = "Tordek was born in the mountains and became a warrior. He fought in many battles and is now seeking adventure."
    improved = generator.improve_background(original_background, character_data)
    
    if improved:
        print("Original background:")
        print(original_background)
        print("\nImproved background:")
        print(improved)
    
    # Example of generating a new background
    generated = generator.generate_background(character_data)
    
    if generated:
        print("\nGenerated background:")
        print(generated)

```

### File: core\game_flow\__init__.py

```python
# This file makes the core/game_flow directory a Python package.

```

### File: core\game_flow\command_handlers.py

```python
"""
Handles the execution of specific direct commands (e.g., /save, /quit, mode changes).
"""

import logging
from typing import List, TYPE_CHECKING, Optional

from core.base.commands import CommandResult
from core.interaction.enums import InteractionMode
from core.utils.logging_config import get_logger
from core.inventory import get_inventory_manager, EquipmentSlot, get_item_factory # Added EquipmentSlot, get_item_factory

if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState

# Get the module logger
logger = get_logger("COMMAND_HANDLERS")

# --- Special LLM Command Handlers ---

def handle_mode_transition(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the MODE_TRANSITION command from LLM output.

    Format is: target_mode:origin_mode:surprise:target_entity_id:reason
    """
    logger.info(f"Handling mode transition command with args: {args}")
    if not args:
        return CommandResult.invalid("MODE_TRANSITION command requires arguments.")

    # Parse the arguments string
    arg_str = args[0]
    parts = arg_str.split(":", 4)  # Allow up to 5 parts
    
    if len(parts) < 2:
        return CommandResult.invalid("MODE_TRANSITION requires at least target_mode and origin_mode.")
    
    # Extract the parts
    target_mode_str = parts[0].upper()
    origin_mode_str = parts[1].upper()
    surprise = parts[2].lower() == "true" if len(parts) > 2 else False
    target_entity_id = parts[3] if len(parts) > 3 and parts[3] else None
    reason = parts[4] if len(parts) > 4 else "Mode transition requested."
    
    logger.info(f"Mode transition requested: {origin_mode_str} -> {target_mode_str} (Surprise: {surprise}, Target: {target_entity_id}, Reason: {reason})")
    
    # Create a structured request for the mode transition handler
    request = {
        "target_mode": target_mode_str,
        "origin_mode": origin_mode_str,
        "surprise": surprise,
        "target_entity_id": target_entity_id,
        "reason": reason
    }
    
    # Import the handler directly
    from core.game_flow.mode_transitions import _handle_transition_request
    
    # Get the actor ID (typically the player)
    actor_id = getattr(game_state.player, 'id', getattr(game_state.player, 'stats_manager_id', 'player_default_id'))
    
    # Call the transition handler
    narrative_result = _handle_transition_request(engine, game_state, request, actor_id)
    
    # Return the result
    return CommandResult.success(narrative_result or "Mode transition processed.")


def handle_start_trade(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /start_trade command."""
    if len(args) < 1:
        return CommandResult.invalid("Usage: /start_trade <npc_id>")
    npc_id = args[0]
    # TODO: Add validation here to check if npc_id exists and is tradeable
    logger.info(f"Initiating trade with NPC: {npc_id}")
    game_state.current_trade_partner_id = npc_id
    game_state.set_interaction_mode(InteractionMode.TRADE)
    engine._output("system", f"Starting trade with {npc_id}.")
    # TODO: Trigger initial trade narration/UI update
    return CommandResult.success(f"Starting trade with {npc_id}.")

def handle_start_social(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /start_social command."""
    if len(args) < 1:
        return CommandResult.invalid("Usage: /start_social <npc_id>")
    npc_id = args[0]
    # TODO: Add validation here to check if npc_id exists and can enter social conflict
    logger.info(f"Initiating social conflict with NPC: {npc_id}")
    player_id = getattr(game_state.player, 'id', None)
    if player_id is None:
        logger.error("Player ID not found in game state for social conflict.")
        return CommandResult.error("Internal error: Player ID missing.")
    # TODO: Initialize social conflict state properly (e.g., setting resolve)
    game_state.current_combatants = [player_id, npc_id] # Using combatants for now
    game_state.set_interaction_mode(InteractionMode.SOCIAL_CONFLICT)
    engine._output("system", f"Starting social conflict with {npc_id}.")
    # TODO: Trigger initial social conflict narration/UI update
    return CommandResult.success(f"Starting social conflict with {npc_id}.")

def handle_end_combat(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /end_combat command."""
    if game_state.current_mode != InteractionMode.COMBAT:
        return CommandResult.invalid("Not currently in combat.")
    logger.info("Ending combat mode.")
    # TODO: Add combat cleanup logic (rewards, status effects removal?)
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
    engine._output("system", "Combat ended.")
    return CommandResult.success("Combat ended.")

def handle_leave_trade(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /leave_trade command."""
    if game_state.current_mode != InteractionMode.TRADE:
        return CommandResult.invalid("Not currently trading.")
    logger.info("Ending trade mode.")
    # TODO: Add trade finalization logic?
    game_state.current_trade_partner_id = None
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
    engine._output("system", "Trade concluded.")
    return CommandResult.success("Trade concluded.")

def handle_end_social(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /end_social command."""
    if game_state.current_mode != InteractionMode.SOCIAL_CONFLICT:
        return CommandResult.invalid("Not currently in social conflict.")
    logger.info("Ending social conflict mode.")
    # TODO: Add social conflict resolution logic
    game_state.current_combatants = [] # Clear participants
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
    engine._output("system", "Social conflict resolved.")
    return CommandResult.success("Social conflict resolved.")

def _handle_equip_command(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles direct 'equip' commands."""
    if not args:
        return CommandResult.invalid("Usage: equip <item_id_or_name> [slot_name]")
    
    inventory_manager = get_inventory_manager()
    item_identifier = args[0]
    preferred_slot_str: Optional[str] = args[1] if len(args) > 1 else None
    preferred_slot_enum: Optional[EquipmentSlot] = None

    if preferred_slot_str:
        try:
            preferred_slot_enum = EquipmentSlot(preferred_slot_str.lower().replace(" ", "_"))
        except ValueError:
            return CommandResult.invalid(f"Invalid slot name: {preferred_slot_str}. Valid slots are: {', '.join([s.value for s in EquipmentSlot])}")

    item = inventory_manager.get_item(item_identifier)
    if not item: # Try finding by name
        found_items = inventory_manager.find_items(name=item_identifier) # Basic name search
        if found_items:
            item = found_items[0] # Take the first match for simplicity
            logger.info(f"Found item '{item.name}' by name for equip command.")
        else:
            return CommandResult.failure(f"Item '{item_identifier}' not found in inventory.")

    if not item.is_equippable:
        return CommandResult.failure(f"Item '{item.name}' is not equippable.")

    if inventory_manager.equip_item(item.id, preferred_slot_enum):
        # Determine the actual slot it was equipped to for the message
        equipped_slot_str = "a suitable slot"
        for slot_enum_loop, item_id_loop in inventory_manager.equipment.items():
            if item_id_loop == item.id:
                equipped_slot_str = slot_enum_loop.value.replace("_", " ")
                break
        return CommandResult.success(f"Equipped {item.name} to {equipped_slot_str}.")
    else:
        return CommandResult.failure(f"Could not equip {item.name}. Check available slots or item requirements.")

def _handle_unequip_command(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles direct 'unequip' commands."""
    if not args:
        return CommandResult.invalid("Usage: unequip <slot_name_or_item_id_or_item_name>")
    
    inventory_manager = get_inventory_manager()
    identifier = args[0]
    
    # Try to interpret as slot first
    try:
        slot_to_unequip = EquipmentSlot(identifier.lower().replace(" ", "_"))
        item_id_in_slot = inventory_manager.equipment.get(slot_to_unequip)
        if not item_id_in_slot:
            return CommandResult.failure(f"No item equipped in {slot_to_unequip.value.replace('_', ' ')}.")
        
        item_name = inventory_manager.get_item(item_id_in_slot).name if item_id_in_slot else "Unknown item"
        if inventory_manager.unequip_item(slot_to_unequip):
            return CommandResult.success(f"Unequipped {item_name} from {slot_to_unequip.value.replace('_', ' ')}.")
        else: # Should not happen if item_id_in_slot was found
            return CommandResult.error(f"Failed to unequip item from {slot_to_unequip.value.replace('_', ' ')}.")

    except ValueError: # Not a valid slot name, try as item ID or name
        item_to_unequip = inventory_manager.get_item(identifier)
        if not item_to_unequip: # Try by name
            found_items = inventory_manager.find_items(name=identifier)
            if found_items:
                item_to_unequip = found_items[0]
            else:
                return CommandResult.failure(f"Item '{identifier}' not found equipped or in inventory to identify.")
        
        if not item_to_unequip: # Still not found
            return CommandResult.failure(f"Item '{identifier}' not found.")

        # Find which slot it's equipped in
        slot_equipped_in: Optional[EquipmentSlot] = None
        for slot_enum_loop, item_id_loop in inventory_manager.equipment.items():
            if item_id_loop == item_to_unequip.id:
                slot_equipped_in = slot_enum_loop
                break
        
        if not slot_equipped_in:
            return CommandResult.failure(f"{item_to_unequip.name} is not currently equipped.")
            
        if inventory_manager.unequip_item(slot_equipped_in):
            return CommandResult.success(f"Unequipped {item_to_unequip.name} from {slot_equipped_in.value.replace('_', ' ')}.")
        else:
            return CommandResult.error(f"Failed to unequip {item_to_unequip.name}.")

# --- Main Direct Command Dispatch ---

MODE_TRANSITION_COMMANDS = {
    "start_trade": handle_start_trade,
    "start_social": handle_start_social,
    "end_combat": handle_end_combat,
    "leave_trade": handle_leave_trade,
    "end_social": handle_end_social,
    "equip": _handle_equip_command,
    "unequip": _handle_unequip_command,
    # Add other mode transition commands here
}

# --- LLM Command Mapping ---

LLM_COMMAND_HANDLERS = {
    "MODE_TRANSITION": handle_mode_transition,
    "QUEST_UPDATE": None,   # placeholders; set below after function defs
    "QUEST_STATUS": None,
    "STATE_CHANGE": None,
}

def _parse_single_json_arg(args: List[str]) -> dict:
    try:
        import json
        if not args:
            return {}
        payload = args[0]
        if isinstance(payload, dict):
            return payload
        return json.loads(payload)
    except Exception:
        return {}


def _handle_quest_update(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles QUEST_UPDATE command with a JSON payload from LLM.
    Payload schema: {"quest_id","objective_id","new_status","confidence", "evidence": [...]}
    """
    payload = _parse_single_json_arg(args)
    try:
        from core.game_flow.quest_updates import apply_objective_update_from_llm
        ok, msg = apply_objective_update_from_llm(engine, game_state, payload)
        return CommandResult.success(msg) if ok else CommandResult.failure(msg)
    except Exception as e:
        return CommandResult.error(f"Quest update error: {e}")


def _handle_quest_status(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles QUEST_STATUS command with a JSON payload from LLM.
    Payload schema: {"quest_id","new_status","confidence","evidence": [...]}"""
    payload = _parse_single_json_arg(args)
    try:
        from core.game_flow.quest_updates import apply_quest_status_from_llm
        ok, msg = apply_quest_status_from_llm(engine, game_state, payload)
        return CommandResult.success(msg) if ok else CommandResult.failure(msg)
    except Exception as e:
        return CommandResult.error(f"Quest status error: {e}")


def _handle_state_change(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handle STATE_CHANGE requests from the LLM.

    Supports at least inventory mutations via JSON payload with schema similar to:
      {
        "action": "request_state_change",
        "target_id": "player",     # normalized by AgentManager
        "attribute": "inventory",   # or other attributes like stamina (acknowledged only)
        "change_type": "add",       # add|remove|drop|consume
        "quantity": 1,
        "template_id": "test_apple" # or item_template | item_id | item_spec
      }
    Fallback colon format is also parsed: target:attribute:change_type:value:item_identifier
    """
    import json as _json

    # Try JSON payload first
    payload = _parse_single_json_arg(args)

    if not payload:
        # Fallback: parse colon-delimited string
        arg_str = args[0] if args else ""
        parts = arg_str.split(":") if arg_str else []
        payload = {
            "target_id": parts[0] if len(parts) > 0 else None,
            "attribute": parts[1] if len(parts) > 1 else None,
            "change_type": parts[2] if len(parts) > 2 else None,
            "value": parts[3] if len(parts) > 3 else None,
            "item_id": parts[4] if len(parts) > 4 else None,
        }

    attribute = (payload.get("attribute") or "").lower()

    if attribute == "inventory":
        try:
            inventory = get_inventory_manager()
            item_factory = get_item_factory()

            change_type = (payload.get("change_type") or payload.get("change") or "add").lower()

            # Quantity may be specified as 'quantity' or (poorly) as 'value'
            q_raw = payload.get("quantity", payload.get("value", 1))
            try:
                quantity = int(q_raw)
            except Exception:
                quantity = 1
            if quantity <= 0:
                quantity = 1

            if change_type in ("add", "give", "pickup", "obtain", "create"):
                item_obj = None
                # Prefer explicit item_spec if provided
                item_spec = payload.get("item_spec") or payload.get("item_data")
                if isinstance(item_spec, dict):
                    try:
                        item_obj = item_factory.create_item_from_spec(item_spec)
                    except Exception as e:
                        logger.warning(f"STATE_CHANGE inventory add: invalid item_spec: {e}")

                if item_obj is None:
                    # template id options
                    template_id = payload.get("template_id") or payload.get("item_template")
                    # if item_id references an existing inventory item, use it as prototype
                    ref_item_id = payload.get("item_id")
                    if ref_item_id:
                        existing = inventory.get_item(ref_item_id)
                        if existing:
                            item_obj = existing
                        elif not template_id:
                            template_id = ref_item_id  # treat as template id fallback

                    if item_obj is None and template_id:
                        item_obj = item_factory.create_item_from_template(template_id, variation=False)

                if item_obj is None:
                    # Last resort: try by name among inventory (not ideal for new items)
                    item_name = payload.get("item_name") or payload.get("name")
                    if item_name:
                        found = inventory.find_items(name=item_name)
                        if found:
                            item_obj = found[0]

                if item_obj is None:
                    return CommandResult.failure("STATE_CHANGE inventory add: could not resolve item to add.")

                added_ids = inventory.add_item(item_obj, quantity=quantity)
                if not added_ids:
                    return CommandResult.failure(f"Could not add {quantity}x {getattr(item_obj, 'name', 'item')}.")
                return CommandResult.success(f"Added {quantity}x {item_obj.name} to inventory.")

            elif change_type in ("remove", "drop", "discard", "consume", "delete"):
                target_item = None
                # Identify target by item_id, template_id, or name
                ref_item_id = payload.get("item_id")
                if ref_item_id:
                    target_item = inventory.get_item(ref_item_id)

                if not target_item:
                    template_id = payload.get("template_id") or payload.get("item_template")
                    if template_id:
                        # Search inventory by template_id
                        for it in getattr(inventory, "_items", {}).values():
                            if getattr(it, "template_id", None) == template_id:
                                target_item = it
                                break

                if not target_item:
                    item_name = payload.get("item_name") or payload.get("name")
                    if item_name:
                        found = inventory.find_items(name=item_name)
                        if found:
                            target_item = found[0]

                if not target_item:
                    return CommandResult.failure("STATE_CHANGE inventory remove: target item not found in inventory.")

                ok = inventory.remove_item(target_item.id, quantity)
                return CommandResult.success(f"Removed {quantity}x {target_item.name} from inventory.") if ok else CommandResult.failure(f"Failed to remove {quantity}x {target_item.name}.")
            else:
                return CommandResult.invalid(f"STATE_CHANGE inventory: unsupported change_type '{change_type}'.")
        except Exception as e:
            logger.exception("STATE_CHANGE inventory error")
            return CommandResult.error(f"Inventory state change error: {e}")

    elif attribute == "location":
        # Developer-only direct location change for test convenience
        try:
            from PySide6.QtCore import QSettings
            q = QSettings("RPGGame", "Settings")
            dev_enabled = bool(q.value("dev/enabled", False, type=bool) or q.value("dev/quest_verbose", False, type=bool))
        except Exception:
            dev_enabled = False

        location_id = str(payload.get("value") or payload.get("location") or "").strip()
        logger.debug(f"STATE_CHANGE location requested -> '{location_id}', dev_enabled={dev_enabled}")

        if not location_id:
            return CommandResult.invalid("STATE_CHANGE location: missing 'value'.")

        if not dev_enabled:
            explanation = None
            try:
                if hasattr(engine, "_rule_checker") and engine._rule_checker is not None:
                    from core.agents.base_agent import AgentContext
                    from core.interaction.context_builder import ContextBuilder
                    from core.interaction.enums import InteractionMode
                    ctx = ContextBuilder().build_context(game_state, InteractionMode.NARRATIVE, actor_id="player")
                    validation_input = f"STATE_CHANGE location -> {location_id} (request denied in normal play)"
                    agent_ctx = AgentContext(
                        game_state=ctx,
                        player_state=ctx.get("player", {}),
                        world_state={
                            "location": ctx.get("location"),
                            "time_of_day": ctx.get("time_of_day"),
                            "environment": ctx.get("environment"),
                        },
                        player_input=validation_input,
                        conversation_history=getattr(game_state, "conversation_history", []),
                        relevant_memories=[],
                        additional_context=ctx,
                    )
                    is_valid, reason = engine._rule_checker.validate_action(agent_ctx)
                    if not is_valid and reason:
                        explanation = reason
            except Exception:
                pass
            if not explanation:
                explanation = "developer-only teleportation is disabled in normal play"
            return CommandResult.failure(f"This action is not permitted - {explanation}.")

        try:
            game_state.player.current_location = location_id
            if hasattr(game_state, "world"):
                game_state.world.current_location = location_id
            try:
                from core.game_flow.event_log import record_location_visited
                record_location_visited(game_state, location_id=location_id)
            except Exception:
                pass
            logger.info(f"STATE_CHANGE location applied (dev): {location_id}")
            return CommandResult.success(f"Location set to {location_id} (dev).")
        except Exception as e:
            logger.exception("STATE_CHANGE location error")
            return CommandResult.error(f"Failed to change location: {e}")

    # Non-inventory attributes: acknowledge but do not apply mechanics here unless explicitly supported
    return CommandResult.invalid(f"STATE_CHANGE not supported for attribute '{attribute}'.")
def process_llm_command(engine: 'GameEngine', command: str, args: List[str], game_state: 'GameState') -> CommandResult:
    """Process a command from the LLM output.
    
    Args:
        engine: The GameEngine instance.
        command: The command name (e.g., MODE_TRANSITION, STAT_CHECK)
        args: The command arguments
        game_state: The current game state
        
    Returns:
        The result of processing the command
    """
    logger.info(f"Processing LLM command: {command} with args: {args}")
    
    # Check if command is in our LLM command handlers
    if command.upper() in LLM_COMMAND_HANDLERS:
        handler = LLM_COMMAND_HANDLERS[command.upper()]
        if handler is None:
            return CommandResult.error(f"Handler not initialized for {command}")
        return handler(engine, game_state, args)
    else:
        # Fall back to CommandProcessor for unknown commands
        logger.warning(f"Unknown LLM command: {command}, falling back to CommandProcessor")
        cmd_args_str = " ".join(args) if args else ""
        result = engine._command_processor.process_llm_commands(game_state, f"{{{command} {cmd_args_str}}}")
        # Return a simple CommandResult from the tuple returned by process_llm_commands
        if isinstance(result, tuple) and len(result) == 2:
            return CommandResult.success(result[0])
        return CommandResult.success("Command processed.")

def process_direct_command(engine: 'GameEngine', command_text: str) -> CommandResult:
    """
    Process a direct command (e.g., starting with '/', 'command:', or '//').

    This function determines if it's a mode transition or should be passed
    to the core CommandProcessor.

    Args:
        engine: The GameEngine instance.
        command_text: The command text to process (without the leading '/' or 'command:').

    Returns:
        The result of executing the command.
    """
    current_state = engine._state_manager.current_state
    if current_state is None:
        return CommandResult.error("No game in progress.")

    # Handle developer commands separately first if needed
    if command_text.startswith('//'):
        logger.debug(f"Processing developer command: {command_text}")
        # Delegate directly to CommandProcessor for dev commands
        result = engine._command_processor.process_command(current_state, command_text)
        # Dev commands typically handle their own output via CommandProcessor registration
        return result

    # Parse command and arguments for regular direct commands
    parts = command_text.split()
    if not parts: # Handle empty command after stripping prefix
        return CommandResult.invalid("Empty command received.")
        
    command_verb = parts[0].lower() # Use verb for dictionary lookup
    args = parts[1:]

    # Check if it's a mode transition command handled here
    if command_verb in MODE_TRANSITION_COMMANDS:
        handler = MODE_TRANSITION_COMMANDS[command_verb]
        result = handler(engine, current_state, args)
        # Mode transition handlers (like equip/unequip) might return messages
        # that should NOT be outputted if they are purely mechanical UI feedback.
        # The individual handlers should decide if their message is for internal logging or UI.
        # For equip/unequip, they are now silent.
        if result.message and command_verb not in ["equip", "unequip"]: # Don't output for equip/unequip
            engine._output("system", result.message)
        return result
    else:
        # Otherwise, delegate to the core CommandProcessor
        logger.debug(f"Delegating direct command to CommandProcessor: {command_text}")
        result = engine._command_processor.process_command(current_state, command_text)

        # Handle side effects like exit
        if result.is_exit:
            logger.info("Exit command received via CommandProcessor")
            engine._running = False # Signal engine to stop

        # Output the result message from CommandProcessor if one exists,
        # unless it's a command that should not have direct output (like a UI-proxied drop before LLM)
        if result.message:
            # Check if the original command was a UI-proxied drop.
            # If so, and drop_command returned a message, suppress it here because LLM handles output.
            is_ui_drop_command = command_verb == "drop" and any('-' in arg for arg in args)
            
            if not (is_ui_drop_command and result.is_success): # Don't output success of mechanical drop if UI initiated and LLM handles narrative
                output_role = "gm" if result.is_success else "system"
                engine._output(output_role, result.message)

        return result

# Initialize handlers now that functions are defined
LLM_COMMAND_HANDLERS["QUEST_UPDATE"] = _handle_quest_update
LLM_COMMAND_HANDLERS["QUEST_STATUS"] = _handle_quest_status
LLM_COMMAND_HANDLERS["STATE_CHANGE"] = _handle_state_change

```

### File: core\game_flow\command_router.py

```python
#!/usr/bin/env python3
"""
Handles routing of player commands based on game mode and input type.

This module now serves as a compatibility layer that delegates to InputRouter.
"""

from typing import TYPE_CHECKING

from core.base.commands import CommandResult
from core.utils.logging_config import get_logger
from core.game_flow.input_router import get_input_router

if TYPE_CHECKING:
    from core.base.engine import GameEngine

# Get the module logger
logger = get_logger("COMMAND_ROUTER")

def route_command(engine: 'GameEngine', command_text: str) -> CommandResult:
    """
    Process a command by routing it based on game state and input type.
    This function is now a compatibility wrapper for InputRouter.
    
    Args:
        engine: The GameEngine instance.
        command_text: The raw command text from the player.

    Returns:
        The result of executing the command.
    """
    logger.debug(f"Routing raw input (legacy): '{command_text}'")
    logger.warning("route_command is deprecated - use InputRouter.route_input directly")
    
    # Use InputRouter for processing
    input_router = get_input_router()
    return input_router.route_input(engine, command_text)

```

### File: core\game_flow\event_log.py

```python
#!/usr/bin/env python3
"""
Event log utilities for recording game-time receipts of player/world actions.
"""
from __future__ import annotations
from typing import Dict, Any, Optional

from core.utils.logging_config import get_logger

logger = get_logger("EVENT_LOG")

# Event types (string constants to keep it simple and JSON-friendly)
EV_ENEMY_DEFEATED = "EnemyDefeated"
EV_ITEM_DELTA = "ItemDelta"
EV_LOCATION_VISITED = "LocationVisited"
EV_DIALOGUE = "DialogueCompleted"
EV_INTERACTION = "InteractionCompleted"
EV_FLAG_SET = "FlagSet"
EV_OBJECTIVE_STATUS = "ObjectiveStatusChange"
EV_QUEST_STATUS = "QuestStatusChange"


def _append(game_state, event: Dict[str, Any]) -> None:
    try:
        if not hasattr(game_state, 'event_log') or not isinstance(game_state.event_log, list):
            game_state.event_log = []
        game_state.event_log.append(event)
    except Exception as e:
        logger.warning(f"Failed to append event: {e}")
        return

    # Phase 1: trigger quest evaluation after appending relevant events
    try:
        from core.base.engine import get_game_engine
        from core.game_flow.quest_updates import process_event_for_quests
        engine = get_game_engine()
        if engine is not None:
            process_event_for_quests(engine, game_state, event)
    except Exception as e:
        # Non-fatal: continue
        logger.debug(f"Quest evaluation hook error (ignored): {e}")


def record_enemy_defeated(game_state, *, entity_id: str, template_id: Optional[str], tags: Dict[str, Any], location_id: Optional[str]) -> None:
    ev = {
        'type': EV_ENEMY_DEFEATED,
        'entity_id': entity_id,
        'template_id': template_id,
        'tags': tags or {},
        'location_id': location_id,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_item_delta(game_state, *, item_id: str, delta: int, source: str) -> None:
    ev = {
        'type': EV_ITEM_DELTA,
        'item_id': item_id,
        'delta': int(delta),
        'source': source,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_location_visited(game_state, *, location_id: str) -> None:
    ev = {
        'type': EV_LOCATION_VISITED,
        'location_id': location_id,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_dialogue(game_state, *, dialogue_id: str, npc_id: Optional[str] = None) -> None:
    ev = {
        'type': EV_DIALOGUE,
        'dialogue_id': dialogue_id,
        'npc_id': npc_id,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_interaction(game_state, *, interaction_id: str, meta: Optional[Dict[str, Any]] = None) -> None:
    ev = {
        'type': EV_INTERACTION,
        'interaction_id': interaction_id,
        'meta': meta or {},
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_flag_set(game_state, *, key: str, value: Any) -> None:
    ev = {
        'type': EV_FLAG_SET,
        'key': key,
        'value': value,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_objective_status(game_state, *, quest_id: str, objective_id: str, new_status: str) -> None:
    ev = {
        'type': EV_OBJECTIVE_STATUS,
        'quest_id': quest_id,
        'objective_id': objective_id,
        'new_status': new_status,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_quest_status(game_state, *, quest_id: str, new_status: str) -> None:
    ev = {
        'type': EV_QUEST_STATUS,
        'quest_id': quest_id,
        'new_status': new_status,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


```

### File: core\game_flow\game_flow_utils.py

```python
#!/usr/bin/env python3
"""
Utility functions for game flow modules.
"""

import logging
from typing import Optional, Any

from core.base.state import GameState
from core.interaction.enums import InteractionMode
from core.character.npc_base import NPC # Moved from local import

# Get the module logger
logger = logging.getLogger("GAME_FLOW_UTILS")

def get_participant_by_id(game_state: 'GameState', entity_id: str, try_fuzzy_match: bool = True) -> Optional[Any]: # Use Any for broader compatibility
    """Helper to find a participant (player or NPC/CombatEntity) by ID.
    
    Args:
        game_state: The current game state
        entity_id: The ID or name of the entity to find
        try_fuzzy_match: If True, attempt fuzzy matching if exact match fails
    
    Returns:
        The found entity or None if not found
    """
    logger.debug(f"Attempting to find participant with ID: {entity_id}")

    # Check for special case 'player' id string
    if entity_id == 'player' and game_state.player:
        logger.debug(f"Found participant '{entity_id}' as player")
        return game_state.player

    # Check if it matches player's actual ID
    if game_state.player and getattr(game_state.player, 'id', None) == entity_id:
        logger.debug(f"Found participant '{entity_id}' matching player ID")
        return game_state.player
    
    # Check if it matches player's name (case insensitive)
    player_name = getattr(game_state.player, 'name', '')
    if player_name and player_name.lower() == entity_id.lower():
        logger.debug(f"Found participant '{entity_id}' matching player name")
        return game_state.player

    # Check combat manager entities first if in combat
    if game_state.current_mode == InteractionMode.COMBAT and game_state.combat_manager:
        try:
            # Try exact match first
            participant = game_state.combat_manager.get_entity_by_id(entity_id)
            if participant:
                logger.debug(f"Found entity {entity_id} in combat manager")
                return participant
            
            # Try to match by name if exact ID match failed
            for eid, entity in game_state.combat_manager.entities.items():
                entity_name = getattr(entity, 'name', '')
                if entity_name and entity_name.lower() == entity_id.lower():
                    logger.debug(f"Found entity with name '{entity_id}' in combat manager (ID: {eid})")
                    return entity
        except Exception as e:
            logger.error(f"Error getting entity from combat manager: {e}")
            # Continue to other lookup methods if this fails

    # Check current location for NPCs by ID
    current_location = None
    if hasattr(game_state, 'player') and hasattr(game_state.player, 'current_location'):
        current_location = game_state.player.current_location
    
    if current_location and hasattr(game_state, 'world') and hasattr(game_state.world, 'get_location'):
        try:
            location = game_state.world.get_location(current_location)
            if location and hasattr(location, 'npcs') and location.npcs:
                # Try exact match on ID first
                for npc in location.npcs:
                    if getattr(npc, 'id', '') == entity_id:
                        logger.debug(f"Found NPC '{entity_id}' in current location")
                        return npc
                    
                # Try name match
                for npc in location.npcs:
                    if getattr(npc, 'name', '').lower() == entity_id.lower():
                        logger.debug(f"Found NPC with name '{entity_id}' in current location")
                        return npc
        except Exception as e:
            logger.error(f"Error getting NPCs from current location: {e}")

    # Check current_combatants (used for social conflict)
    if hasattr(game_state, 'current_combatants') and entity_id in game_state.current_combatants:
         # Need a way to get the actual NPC/Player object from the ID
         if game_state.player and getattr(game_state.player, 'id', None) == entity_id:
             logger.debug(f"Found participant '{entity_id}' in current_combatants (matches player ID)")
             return game_state.player
         # Option 2: Check NPC manager/system
         if hasattr(game_state, 'npc_system') and game_state.npc_system:
             if hasattr(game_state.npc_system, 'get_npc_by_id'):
                 npc = game_state.npc_system.get_npc_by_id(entity_id)
                 if npc:
                     logger.debug(f"Found participant '{entity_id}' in current_combatants (via NPC system)")
                     return npc
             # Try to find by name if get_npc_by_id exists
             if hasattr(game_state.npc_system, 'get_npcs') and try_fuzzy_match:
                 try:
                     all_npcs = game_state.npc_system.get_npcs()
                     for npc in all_npcs:
                         if getattr(npc, 'name', '').lower() == entity_id.lower():
                             logger.debug(f"Found NPC with name '{entity_id}' via NPC system")
                             return npc
                 except Exception as e:
                     logger.error(f"Error getting NPCs from NPC system: {e}")
         # Option 3: Check entity manager (if it holds NPCs)
         if hasattr(game_state, 'entity_manager') and game_state.entity_manager and hasattr(game_state.entity_manager, 'get_entity_by_id'):
              entity = game_state.entity_manager.get_entity_by_id(entity_id)
              # Check if the entity is compatible (e.g., is an NPC or Player)
              if isinstance(entity, NPC) or hasattr(entity, 'entity_type'): # Or a common base class
                  logger.debug(f"Found participant '{entity_id}' in current_combatants (via entity manager)")
                  return entity

    # Fallback: Check world NPCs
    if game_state.world:
        # Check if get_npc_by_id method exists for exact ID match
        if hasattr(game_state.world, 'get_npc_by_id'):
            npc = game_state.world.get_npc_by_id(entity_id)
            if npc:
                logger.debug(f"Found participant '{entity_id}' in world NPCs")
                return npc
        
        # Try to match by name if we have access to all NPCs
        if try_fuzzy_match and hasattr(game_state.world, 'get_all_npcs'):
            try:
                all_npcs = game_state.world.get_all_npcs()
                for npc in all_npcs:
                    if getattr(npc, 'name', '').lower() == entity_id.lower():
                        logger.debug(f"Found NPC with name '{entity_id}' via world.get_all_npcs")
                        return npc
            except Exception as e:
                logger.error(f"Error accessing all NPCs: {e}")

    # If NPC system exists, try to get all NPCs and match by name
    if try_fuzzy_match and hasattr(game_state, 'npc_system') and game_state.npc_system:
        if hasattr(game_state.npc_system, 'get_npcs'):
            try:
                all_npcs = game_state.npc_system.get_npcs()
                for npc in all_npcs:
                    npc_name = getattr(npc, 'name', '')
                    if npc_name and npc_name.lower() == entity_id.lower():
                        logger.debug(f"Found NPC with name '{entity_id}' via npc_system.get_npcs")
                        return npc
            except Exception as e:
                logger.error(f"Error getting NPCs from NPC system: {e}")

    logger.warning(f"Could not find participant with ID or name: {entity_id} in current context.")
    return None
```

### File: core\game_flow\input_router.py

```python
"""
Centralized input router for the RPG game.

This module provides a unified approach to routing player input based on
game mode, input type, and content analysis.
"""

from typing import Any, Dict, Optional, Tuple, TYPE_CHECKING

from core.base.commands import CommandResult
from core.combat.combat_entity import EntityType
from core.combat.enums import CombatState, CombatStep
from core.interaction.enums import InteractionMode
from core.utils.logging_config import get_logger

# Import the modules for processing the input after routing
from core.game_flow import command_handlers
# Import functions from the refactored interaction processor modules
from core.game_flow.interaction_core import run_unified_loop, process_interactive_text, should_narrative_use_unified_loop
from core.game_flow.npc_interaction import get_npc_intent


if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState
    from core.agents.base_agent import BaseAgent

# Get the module logger
logger = get_logger("INPUT_ROUTER")

# Define essential commands allowed in any mode (without the leading '/')
# These bypass the mode-specific intent handling.
ESSENTIAL_COMMANDS = {"quit", "exit", "save", "load", "help", "status", "llm", "speed", "pause"}
UI_PROXY_COMMANDS = {"examine", "equip", "unequip", "drop", "use"} # Commands that might originate from UI buttons


class InputRouter:
    """
    Centralized router for player input based on game mode and input type.
    
    This class handles the routing of all player input to the appropriate
    processors based on the current game mode, input format, and content analysis.
    It also handles mode transitions and logging of routing decisions.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(InputRouter, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the input router."""
        if self._initialized:
            return
        
        self._initialized = True
        # The command processor instance is not currently used in this class.
        # self._command_processor = get_command_processor()

        logger.info("InputRouter initialized")
    
    def route_input(self, engine: 'GameEngine', input_text: str) -> CommandResult:
        """
        Route player input to the appropriate processor based on mode and type.

        Args:
            engine: The GameEngine instance.
            input_text: The raw input text from the player.

        Returns:
            The result of processing the input.
        """
        logger.debug(f"Routing input: '{input_text}'")

        game_state = engine._state_manager.current_state
        if game_state is None:
            logger.warning("Cannot process input: No current game state")
            return CommandResult.error("No game in progress. Start a new game or load a saved game.")

        input_text = input_text.strip()
        if not input_text:
            return CommandResult.invalid("Please enter a command or action.")

        current_mode = game_state.current_mode
        logger.debug(f"Current mode: {current_mode.name}")
        
        # Check if this input might be a UI-proxied command that should be handled directly
        # by the command_handlers.py and not echoed as player input to GameOutputWidget.
        # This is specifically for commands like "examine {uuid}" which are generated by UI clicks.
        is_ui_generated_command = False
        try:
            parts = input_text.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in UI_PROXY_COMMANDS:
                # Further check if the second part looks like a UUID (simple check)
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10: # Basic UUID-like check
                    is_ui_generated_command = True
                    logger.info(f"Identified as UI-generated command, will not echo: '{input_text}'")
        except Exception:
            pass # Ignore parsing errors here, will be handled by normal routing

        if self._is_essential_command(input_text):
            logger.info(f"Processing essential command: '{input_text}'")
            return self._process_direct_command(engine, game_state, input_text)

        if self._is_direct_command(input_text) and not is_ui_generated_command:
            # Direct commands typed by user (e.g. /look) should still be echoed.
            # UI-generated commands like "examine {uuid}" are "direct" but should not be echoed.
            logger.info(f"Processing direct command: '{input_text}'")
            if not input_text.startswith('//'): # Don't echo dev commands starting with //
                engine._output("player", input_text) # Echo direct commands typed by player
            return self._process_direct_command(engine, game_state, input_text)
        elif is_ui_generated_command: # Handle UI-generated commands that look like direct commands but shouldn't be echoed
            logger.info(f"Processing UI-generated command directly (no echo): '{input_text}'")
            return self._process_direct_command(engine, game_state, input_text)


        # --- Mode-specific routing ---
        if current_mode == InteractionMode.COMBAT:
            logger.info(f"COMBAT input received: '{input_text}'")
            if game_state.combat_manager is None:
                logger.error("COMBAT mode active but CombatManager is None.")
                return CommandResult.error("Internal Error: Combat state invalid.")

            combat_manager = game_state.combat_manager

            # Check if it's awaiting player input specifically
            if combat_manager.current_step == CombatStep.AWAITING_PLAYER_INPUT:
                # Echo player input immediately
                engine._output("player", input_text)
                # Delegate action receiving to CombatManager, passing engine and intent
                combat_manager.receive_player_action(engine, input_text) 
                # Signal that the action was received, combat manager will process
                return CommandResult.success("Action received...")
            else:
                # Not awaiting player input (e.g., NPC turn, resolving action)
                display_name = "Someone else"
                active_id = getattr(combat_manager, '_active_entity_id', None)
                if active_id:
                    entity = combat_manager.entities.get(active_id)
                    if entity: display_name = entity.combat_name
                logger.info(f"Input received during non-player-input step ({combat_manager.current_step.name}). Ignoring.")
                return CommandResult.invalid(f"Please wait, currently processing {display_name}'s turn or resolving actions.")

        elif current_mode == InteractionMode.NARRATIVE:
            # ... (rest of narrative logic remains the same) ...
            if should_narrative_use_unified_loop(input_text):
                logger.info(f"NARRATIVE input routed to unified loop: '{input_text}'")
                if not is_ui_generated_command: engine._output("player", input_text)
                return run_unified_loop(engine, game_state, input_text)
            else:
                logger.info(f"NARRATIVE input routed to interactive text: '{input_text}'")
                # Echo player input if processed by LLM and not UI-generated
                if engine._use_llm and not is_ui_generated_command:
                    engine._output("player", input_text)
                result = process_interactive_text(engine, input_text)
                # Output LLM response if applicable
                is_welcome_narration = "I've just started a new game" in input_text and "introduce me to the game world" in input_text
                if result.is_success and result.data and "commands" in result.data and not is_welcome_narration:
                    logger.debug(f"Sending output from LLM result. Role 'gm'. Snippet: '{result.message[:100]}...'")
                    if result.message: # Only output if there's a message
                         engine._output("gm", result.message)
                elif result.is_success and result.message: # LLM response without commands, still output it
                    engine._output("gm", result.message)
                return result

        elif current_mode in [InteractionMode.SOCIAL_CONFLICT, InteractionMode.TRADE]:
            # ... (logic for these modes remains the same) ...
            logger.info(f"{current_mode.name} input routed to unified loop: '{input_text}'")
            if not is_ui_generated_command: engine._output("player", input_text)
            # TODO: Implement proper turn handling/state checks for these modes if needed
            return run_unified_loop(engine, game_state, input_text)

        else:
            logger.warning(f"Unknown mode: {current_mode.name}. Falling back to narrative.")
            if not is_ui_generated_command: engine._output("player", input_text)
            return process_interactive_text(engine, input_text)
    
    def _is_essential_command(self, input_text: str) -> bool:
        """Check if the input is an essential command."""
        if input_text.startswith('/'):
            try:
                command_verb = input_text[1:].split(maxsplit=1)[0].lower()
                return command_verb in ESSENTIAL_COMMANDS
            except IndexError:
                pass  # Input was just '/'
        return False
    
    def _is_direct_command(self, input_text: str) -> bool:
        """Check if the input is a direct command (bypassing mode-specific processing)."""
        return (input_text.startswith('command:') or 
                input_text.startswith('//') or 
                input_text.startswith('/'))
    
    def _process_direct_command(self, engine: 'GameEngine', game_state: 'GameState', input_text: str) -> CommandResult:
        """Process a direct command."""
        # Strip 'command:' prefix if present
        command_to_process = input_text
        if input_text.startswith('command:'):
            command_to_process = input_text[8:].strip()
        elif input_text.startswith('/'): # Also strip '/' for consistency if it's not a dev command
            if not input_text.startswith('//'):
                command_to_process = input_text[1:].strip()
            
        # Pass to the command handlers
        return command_handlers.process_direct_command(engine, command_to_process)
    
    def _get_entity_display_name(self, game_state: 'GameState', entity_id: str) -> str:
        """Get the display name for an entity."""
        # Try combat manager first
        if game_state.current_mode == InteractionMode.COMBAT and game_state.combat_manager:
            try:
                entity = game_state.combat_manager.get_entity_by_id(entity_id)
                if entity and hasattr(entity, 'name'):
                    return entity.name
            except Exception as e:
                logger.warning(f"Error getting entity name from combat manager: {e}")

        # Try NPC system
        if hasattr(game_state, 'npc_system') and game_state.npc_system:
            npc = getattr(game_state.npc_system, 'get_npc', lambda id: None)(entity_id)
            if npc and hasattr(npc, 'name'):
                return npc.name

        # Fallback to ID
        return entity_id

# Convenience function
def get_input_router() -> InputRouter:
    """Get the input router instance."""
    return InputRouter()
```

### File: core\game_flow\interaction_core.py

```python
#!/usr/bin/env python3
"""
Core interaction processing loop and main entry points for natural language input.
"""

import json
import logging
from typing import Optional, TYPE_CHECKING, Dict, Any, List, Tuple

from core.base.commands import CommandResult
from core.interaction.enums import InteractionMode
from core.interaction.context_builder import ContextBuilder
from core.interaction.structured_requests import AgentOutput 
from core.agents.base_agent import AgentContext
from core.agents.rule_checker import RuleCheckerAgent
from core.base.state import GameState
from core.game_flow.mode_transitions import _handle_transition_request
from core.game_flow.request_handlers import _process_skill_check_request, _process_state_change_request


if TYPE_CHECKING:
    from core.base.engine import GameEngine

logger = logging.getLogger("INTERACTION_PROC") # Keep original logger name for minimal changes

# --- Helper Functions (General) ---

def should_narrative_use_unified_loop(intent: str) -> bool:
    """
    Decide whether narrative input should use the unified loop.

    Design decision: always route Narrative mode input through the
    unified loop so that structured requests (skill checks, state
    changes, mode transitions) are validated and executed consistently.
    """
    return True

# --- Core Interaction Processing ---

def process_interactive_text(engine: 'GameEngine', command_text: str) -> CommandResult:
    """
    Process interactive text input, potentially using LLM.
    
    Args:
        engine: The GameEngine instance.
        command_text: The player's input text.
        
    Returns:
        CommandResult with the response.
    """
    if not engine._state_manager or not engine._state_manager.current_state:
        logger.error("Cannot process interactive text: No current game state.")
        return CommandResult.error("No game in progress.")

    current_game_state = engine._state_manager.current_state

    if engine._use_llm:
        logger.info(f"Processing interactive text with LLM: {command_text[:100]}...")
        # Pass the actual GameState object to process_with_llm
        return process_with_llm(current_game_state, command_text)
    else:
        # Handle non-LLM interactive text (e.g., simple parser, keyword matching)
        # For now, just echo back or provide a canned response
        logger.info(f"LLM disabled. Echoing interactive text: {command_text[:100]}...")
        return CommandResult.success(f"You said: {command_text}")
    
def process_with_llm(game_state: GameState, player_input: str) -> CommandResult:
    """
    Process player input using the LLM agent manager.

    Args:
        game_state: The current game state.
        player_input: The player's input text.

    Returns:
        CommandResult with the LLM's response.
    """
    # Import get_game_engine here to ensure it's available
    from core.base.engine import get_game_engine
    engine = get_game_engine() # Get the engine instance

    if not engine:
        logger.error("GameEngine instance not found in process_with_llm.")
        return CommandResult.error("System error: Game engine unavailable.")

    if not engine._agent_manager:
        logger.error("AgentManager not initialized in process_with_llm.")
        return CommandResult.error("System error: Agent manager unavailable.")

    if not game_state: # Should have been checked by caller, but good to be safe
        logger.error("GameState not provided to process_with_llm.")
        return CommandResult.error("System error: Game state unavailable.")

    logger.info(f"Processing with LLM: {player_input[:100]}...")
    logger.info("LIFECYCLE_DEBUG: Sending request to LLM agent manager")
    
    try:
        # Process the input through the agent manager
        logger.info("LIFECYCLE_DEBUG: About to call agent_manager.process_input()")
        response_text, commands = engine._agent_manager.process_input(
            game_state=game_state, 
            player_input=player_input
        )
        logger.info(f"LIFECYCLE_DEBUG: Received LLM response - Length: {len(response_text) if response_text else 0} chars")
        logger.info(f"LIFECYCLE_DEBUG: Response preview: '{response_text[:150] if response_text else 'None'}...'")
        logger.info(f"LIFECYCLE_DEBUG: Commands returned: {len(commands) if commands else 0}")
        
        # For now, we're primarily interested in the response text.
        # Command processing from LLM output will be handled by the engine
        # if this function is called as part of a larger command processing flow.
        # If called directly for narration (like in lifecycle), commands might be ignored
        # or handled differently depending on context.
        
        if commands:
            logger.info(f"LLM response included {len(commands)} commands: {commands}")
            # Here, we could potentially process these commands immediately if needed,
            # or pass them up for the main game loop to handle.
            # For initial welcome narration, commands are less likely/important.
            # For general input, GameEngine.process_command would handle them.
            
            # If this function is meant to also execute commands, we'd need engine access here.
            # For now, assuming lifecycle uses this primarily for narrative generation.
            # The CommandResult can carry these commands if needed.
            pass # Commands are noted but not processed directly within this function.

        result = CommandResult.success(response_text, data={"commands": commands})
        logger.info(f"LIFECYCLE_DEBUG: Returning CommandResult - Success: {result.is_success}, Message length: {len(result.message) if result.message else 0}")
        return result
        
    except Exception as e:
        logger.error(f"Error processing input with LLM: {e}", exc_info=True)
        logger.error("LIFECYCLE_DEBUG: Exception in process_with_llm, returning error result")
        return CommandResult.error(f"LLM processing error: {e}")
    
# --- Unified Loop Helper Functions ---

def _build_interaction_context(game_state: 'GameState', current_mode: InteractionMode, actor_id: Optional[str]) -> Dict[str, Any]:
    """Builds the context dictionary for the current interaction."""
    logger.debug(f"Building context for Actor: {actor_id}, Mode: {current_mode.name}")
    context_builder = ContextBuilder()
    context = context_builder.build_context(game_state, current_mode, actor_id=actor_id)
    logger.debug("Context built successfully.")
    return context

def _get_agent_response(engine: 'GameEngine', game_state: 'GameState', context: Dict[str, Any], intent: str, current_mode: InteractionMode) -> Optional[AgentOutput]:
    """Calls the appropriate LLM agent based on the mode and returns the structured output."""
    logger.debug(f"Getting agent response for Mode: {current_mode.name}, Intent: '{intent}'")

    # Compute internal exact calendar string for prompt (do not show to user)
    try:
        exact_time_str = getattr(getattr(game_state, 'world', None), 'game_date', '') or ''
    except Exception:
        exact_time_str = ''

    # Provide richer world_state to the agent
    agent_context = AgentContext(
        game_state=context, # Pass context dict as game_state for agent
        player_state=context.get('player', {}),
        world_state={
            'location': context.get('location'),
            'time_of_day': context.get('time_of_day'),
            'is_day': getattr(getattr(game_state, 'world', None), 'is_day', True),
            'environment': context.get('environment'),
            'exact_game_time': exact_time_str,
            'calendar': exact_time_str
        },
        player_input=intent, # Use the intent as the input
        conversation_history=game_state.conversation_history,
        relevant_memories=[], # Placeholder
        additional_context=context
    )

    agent_output: Optional[AgentOutput] = None
    # Select appropriate agent
    if current_mode == InteractionMode.COMBAT and engine._combat_narrator_agent:
        logger.debug(f"Using CombatNarratorAgent for mode {current_mode.name}")
        agent_output = engine._combat_narrator_agent.process(agent_context)
    # TODO: Add elif for SOCIAL_CONFLICT, TRADE agents
    else:
        # For Narrative (and other non-combat unified flows), call NarratorAgent directly
        # to obtain structured AgentOutput with requests.
        try:
            from core.agents.narrator import get_narrator_agent
            narrator = get_narrator_agent()
            logger.debug("Using NarratorAgent for structured AgentOutput in unified loop")
            agent_output = narrator.process(agent_context)
        except Exception as e:
            logger.error(f"Failed to obtain structured AgentOutput from NarratorAgent: {e}")
            agent_output = None


    if not agent_output:
        logger.error("LLM Agent did not return structured output.")
        return None

    # Log the received output
    logger.debug(f"Agent Output received (JSON): {json.dumps(agent_output, indent=2)}")
    narrative_snippet = agent_output.get('narrative', '')[:50]
    requests_list = agent_output.get('requests', [])
    logger.debug(f"Agent Output received. Narrative: '{narrative_snippet}...', Requests: {len(requests_list)}")

    return agent_output

def _validate_agent_action(engine: 'GameEngine', context: Dict[str, Any], agent_output: AgentOutput, intent: str) -> tuple[bool, str]:
    """Validates the agent's proposed action using the RuleCheckerAgent."""
    logger.debug(f"Validating agent action. Intent: '{intent}', Output: {json.dumps(agent_output, indent=2)}")

    # Prepare validation context, embedding the structured request in the input
    validation_input = f"Action intent: {intent}\nStructured requests: {json.dumps(agent_output.get('requests', []), indent=2)}"
    validation_context = AgentContext(
        game_state=context,
        player_state=context.get('player', {}),
        world_state={
            'location': context.get('location'),
            'time_of_day': context.get('time_of_day'),
            'environment': context.get('environment')
        },
        player_input=validation_input,
        conversation_history=context.get('conversation_history', []), # Get history from context if available
        relevant_memories=[], # Placeholder
        additional_context=context
    )

    # Ensure rule checker agent is available
    if not engine._rule_checker:
        logger.error("RuleCheckerAgent not available for validation.")
        # In a real game, this might be a critical error or allow actions without validation
        # For now, assume validation fails if the agent isn't there.
        return False, "System Error: Rule checker is not available."


    is_valid, validation_feedback = engine._rule_checker.validate_action(validation_context)

    if not is_valid:
        logger.warning(f"Action validation failed: {validation_feedback}")
    else:
        logger.debug("Action validation successful.")

    return is_valid, validation_feedback

# Modify _execute_validated_requests in core/game_flow/interaction_core.py
def _execute_validated_requests(engine: 'GameEngine', game_state: 'GameState', agent_output: AgentOutput, effective_actor_id: str, intent: str) -> list[str]:
    """Processes the validated requests from the agent output."""
    final_narrative_parts = []
    requests_list = agent_output.get('requests', [])
    initial_narrative = agent_output.get('narrative', '') # CAPTURE initial narrative

    logger.debug(f"Executing {len(requests_list)} validated requests for actor {effective_actor_id}.")
    logger.info(f"Request list contents: {json.dumps(requests_list, indent=2)}")

    # --- Separate request types ---
    mode_transitions = []
    other_requests = []
    data_retrieval_requests = []

    for request in requests_list:
        if not isinstance(request, dict):
            logger.warning(f"Skipping non-dictionary request item: {request}")
            continue

        action_type = request.get("action")
        if action_type == "request_mode_transition":
            mode_transitions.append(request)
        elif action_type == "request_data_retrieval":
            data_retrieval_requests.append(request)
        else:
            other_requests.append(request)

    # --- Handle Data Retrieval First (if any) ---
    if data_retrieval_requests:
        logger.info(f"Processing {len(data_retrieval_requests)} data retrieval requests.")
        retrieved_data_narrative = []
        from core.agents.data_retrieval_commands import process_data_retrieval_command # Import here
        for req in data_retrieval_requests:
            data_type = req.get("data_type", "unknown")
            # Format args if needed, currently assuming no args for simple GETs
            retrieved_data = process_data_retrieval_command(f"GET_{data_type.upper()}", "", game_state)
            # Format the retrieved data into a readable string (basic example)
            # In a real scenario, this might call another LLM to summarize or format
            retrieved_data_narrative.append(f"--- {data_type.upper()} ---")
            retrieved_data_narrative.append(json.dumps(retrieved_data, indent=2, default=str))

        if retrieved_data_narrative:
             # Output data retrieval results (usually replaces narrative)
             data_narrative_str = "\n".join(retrieved_data_narrative)
             engine._output("gm", data_narrative_str) # Output retrieved data
             # If data was retrieved, usually we don't process other requests/narrative
             # unless specifically designed otherwise. Clear other lists.
             mode_transitions = []
             other_requests = []
             initial_narrative = "" # Clear original narrative if data was requested


    # --- Process Mode Transitions (if not superseded by data retrieval) ---
    processed_mode_transition = False
    if mode_transitions:
        request = mode_transitions[0]
        logger.info(f"Processing mode transition request: {json.dumps(request, indent=2)}")

        # Pass the INITIAL narrative into the context for the transition function
        if request.get("target_mode") == "COMBAT":
            request["additional_context"] = {
                "original_intent": intent,
                "narrative_context": initial_narrative
            }

        # Call the function from mode_transitions.py
        # This function will now only PREPARE combat, not fully start it.
        # It will output the initiating narrative.
        narrative_result = _handle_transition_request(engine, game_state, request, effective_actor_id)
        # The narrative_result from _handle_transition_request is now mainly for logging/errors,
        # as the initiating narrative is handled within it.
        if narrative_result and "System Error" in narrative_result:
            final_narrative_parts.append(narrative_result) # Append error messages

        processed_mode_transition = True
        if game_state.current_mode.name != request.get("origin_mode", ""):
            logger.info(f"Mode changed to {game_state.current_mode.name}. Clearing other pending requests.")
            other_requests = []

    # --- Process Other Requests (if no mode transition occurred or they weren't cleared) ---
    if not processed_mode_transition or other_requests: # Process if no transition or if requests remain
        for request in other_requests:
            action_type = request.get("action")
            narrative_result = ""

            if action_type == "request_skill_check":
                request["intent_hint"] = intent # Pass intent hint
                narrative_result = _process_skill_check_request(engine, game_state, request, effective_actor_id)
            elif action_type == "request_state_change":
                narrative_result = _process_state_change_request(engine, game_state, request, effective_actor_id)
            else:
                logger.warning(f"Unknown or missing action type in request: {request}")
                narrative_result = f"System Error: Unknown action type '{action_type}'."

            if narrative_result:
                final_narrative_parts.append(narrative_result)

    return final_narrative_parts


# --- Main Unified Loop Function ---

def run_unified_loop(engine: 'GameEngine', game_state: 'GameState', intent: str, actor_id: Optional[str] = None) -> CommandResult:
    """
    Implements the Unified Core Loop using helper methods.
    Handles context building, agent calls, validation, and execution for an actor's intent.

    Args:
        engine: The GameEngine instance.
        game_state: The current game state.
        intent: The description of the intended action (from player or generated for NPC).
        actor_id: The ID of the entity performing the action. Defaults to player if None.

    Returns:
        The result of processing the action.
    """
    current_mode = game_state.current_mode
    # Determine the acting entity's ID, defaulting to player if not specified
    effective_actor_id = actor_id or getattr(game_state.player, 'id', getattr(game_state.player, 'stats_manager_id', 'player_default_id'))
    logger.debug(f"Entering Unified Loop for Actor ID: {effective_actor_id}, Mode: {current_mode.name}, Intent: '{intent}'")

    # --- Get Actor Combat Name ---
    actor_combat_name = "Unknown" # Default
    actor_entity = None
    if game_state.combat_manager:
         actor_entity = game_state.combat_manager.get_entity_by_id(effective_actor_id)
         if actor_entity:
             actor_combat_name = getattr(actor_entity, 'combat_name', actor_entity.name)
         else:
             logger.warning(f"Could not find actor entity with ID {effective_actor_id} in combat manager.")
    elif effective_actor_id == getattr(game_state.player, 'id', 'player_default_id'):
         actor_combat_name = getattr(game_state.player, 'name', 'Player') # Fallback for player outside combat?
    else:
         # Try getting from NPC system if not in combat? Less likely scenario.
         pass
    logger.debug(f"Determined effective actor combat name: '{actor_combat_name}'")
    # --- End Get Actor Combat Name ---


    try:
        # 1. Build Context
        context = _build_interaction_context(game_state, current_mode, effective_actor_id)

        # 2. Get Agent Response
        agent_output = _get_agent_response(engine, game_state, context, intent, current_mode)
        if not agent_output:
            engine._output("system", "Sorry, I couldn't process that request properly (Agent Error).")
            return CommandResult.error("Agent failed to produce structured output.")

        # Log structured agent output JSON for diagnostics
        try:
            import json as _json
            logger.info(f"[LLM_AGENT_OUTPUT_STRUCTURED] {_json.dumps(agent_output, ensure_ascii=False)}")
        except Exception:
            logger.info("[LLM_AGENT_OUTPUT_STRUCTURED] <unavailable>")

        requests_list = agent_output.get('requests', [])
        if requests_list and actor_combat_name != "Unknown":
            corrected_requests = []
            for req in requests_list:
                 if isinstance(req, dict) and "actor_id" in req:
                     llm_actor_id = req.get("actor_id")
                     if not llm_actor_id or llm_actor_id == "Unknown" or llm_actor_id != actor_combat_name:
                          if llm_actor_id and llm_actor_id != "Unknown":
                              logger.warning(f"Correcting actor_id in request: LLM provided '{llm_actor_id}', expected '{actor_combat_name}'.")
                          else:
                               logger.debug(f"Setting actor_id in request to known actor: '{actor_combat_name}' (LLM provided '{llm_actor_id}').")
                          req["actor_id"] = actor_combat_name 
                 corrected_requests.append(req)
            agent_output["requests"] = corrected_requests

        # 3. Time passage handling (pre-validation): advance time only outside COMBAT
        try:
            current_mode_name = game_state.current_mode.name if hasattr(game_state.current_mode, 'name') else str(game_state.current_mode)
        except Exception:
            current_mode_name = 'NARRATIVE'
        try:
            from core.utils.time_utils import parse_time_string, MINUTE
            if current_mode_name != 'COMBAT':
                tp = agent_output.get('time_passage') if isinstance(agent_output, dict) else None
                logger.info(f"[TIME_CAPTURE] raw_time_passage_field={tp!r}")
                seconds = parse_time_string(tp) if tp else None
                # If missing, first try to parse player's intent
                if seconds is None:
                    try:
                        import re
                        intent_text = intent or ""
                        m = re.search(r"(\d+)\s*(hour|hours|hr|hrs)", intent_text, re.IGNORECASE)
                        if m:
                            seconds = float(m.group(1)) * 3600.0
                        else:
                            m = re.search(r"(\d+)\s*(minute|minutes|min|mins)", intent_text, re.IGNORECASE)
                            if m:
                                seconds = float(m.group(1)) * 60.0
                            else:
                                m = re.search(r"(\d+)\s*(day|days)", intent_text, re.IGNORECASE)
                                if m:
                                    seconds = float(m.group(1)) * 86400.0
                        # Number words from intent
                        if seconds is None:
                            ones = "one|two|three|four|five|six|seven|eight|nine"
                            teens = "ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen"
                            tens = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety"
                            number_word_re = rf"((?:{teens}|(?:{tens})(?:[- ](?:{ones}))?|(?:{ones})))"
                            def _word_to_num(txt: str) -> float:
                                txt = (txt or '').strip().lower().replace('-', ' ')
                                base_map = {
                                    'one':1,'two':2,'three':3,'four':4,'five':5,'six':6,'seven':7,'eight':8,'nine':9,
                                    'ten':10,'eleven':11,'twelve':12,'thirteen':13,'fourteen':14,'fifteen':15,'sixteen':16,'seventeen':17,'eighteen':18,'nineteen':19,
                                    'twenty':20,'thirty':30,'forty':40,'fifty':50,'sixty':60,'seventy':70,'eighty':80,'ninety':90
                                }
                                total = 0
                                for p in [p for p in txt.split() if p]:
                                    if p in base_map: total += base_map[p]
                                    else: return 0
                                return float(total)
                            m = re.search(rf"\b{number_word_re}\s*(hour|hours|hr|hrs)\b", intent_text, re.IGNORECASE)
                            if m: seconds = _word_to_num(m.group(1)) * 3600.0
                            if seconds is None or seconds == 0:
                                m = re.search(rf"\b{number_word_re}\s*(minute|minutes|min|mins)\b", intent_text, re.IGNORECASE)
                                if m: seconds = _word_to_num(m.group(1)) * 60.0
                            if seconds is None or seconds == 0:
                                m = re.search(rf"\b{number_word_re}\s*(day|days)\b", intent_text, re.IGNORECASE)
                                if m: seconds = _word_to_num(m.group(1)) * 86400.0
                    except Exception:
                        seconds = None
                # If still missing, try to parse the narrative
                if seconds is None:
                    # Heuristic: attempt to detect simple time mentions in the narrative (e.g., "12 hours")
                    try:
                        import re
                        narr = (agent_output.get('narrative') or '') if isinstance(agent_output, dict) else ''
                        m = re.search(r"(\d+)\s*(hour|hours|hr|hrs)", narr, re.IGNORECASE)
                        if m:
                            seconds = float(m.group(1)) * 3600.0
                        else:
                            m = re.search(r"(\d+)\s*(minute|minutes|min|mins)", narr, re.IGNORECASE)
                            if m:
                                seconds = float(m.group(1)) * 60.0
                            else:
                                m = re.search(r"(\d+)\s*(day|days)", narr, re.IGNORECASE)
                                if m:
                                    seconds = float(m.group(1)) * 86400.0
                        # If still None, try number words (e.g., 'twelve hours', 'twenty-one minutes')
                        if seconds is None:
                            # Build regex for number words up to 99 (tens + optional ones)
                            ones = "one|two|three|four|five|six|seven|eight|nine"
                            teens = "ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen"
                            tens = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety"
                            number_word_re = rf"((?:{teens}|(?:{tens})(?:[- ](?:{ones}))?|(?:{ones})))"
                            # Try hours
                            m = re.search(rf"\b{number_word_re}\s*(hour|hours|hr|hrs)\b", narr, re.IGNORECASE)
                            def _word_to_num(txt: str) -> float:
                                txt = (txt or '').strip().lower()
                                # normalize hyphens to spaces
                                txt = txt.replace('-', ' ')
                                parts = [p for p in txt.split() if p]
                                base_map = {
                                    'one':1,'two':2,'three':3,'four':4,'five':5,'six':6,'seven':7,'eight':8,'nine':9,
                                    'ten':10,'eleven':11,'twelve':12,'thirteen':13,'fourteen':14,'fifteen':15,'sixteen':16,'seventeen':17,'eighteen':18,'nineteen':19,
                                    'twenty':20,'thirty':30,'forty':40,'fifty':50,'sixty':60,'seventy':70,'eighty':80,'ninety':90
                                }
                                total = 0
                                for p in parts:
                                    if p in base_map:
                                        total += base_map[p]
                                    else:
                                        # unknown word
                                        return 0
                                return float(total)
                            if m:
                                seconds = _word_to_num(m.group(1)) * 3600.0
                            if seconds is None or seconds == 0:
                                m = re.search(rf"\b{number_word_re}\s*(minute|minutes|min|mins)\b", narr, re.IGNORECASE)
                                if m:
                                    seconds = _word_to_num(m.group(1)) * 60.0
                            if seconds is None or seconds == 0:
                                m = re.search(rf"\b{number_word_re}\s*(day|days)\b", narr, re.IGNORECASE)
                                if m:
                                    seconds = _word_to_num(m.group(1)) * 86400.0
                    except Exception:
                        seconds = None
                if seconds is None:
                    seconds = 1 * MINUTE
                # Advance world time
                if getattr(game_state, 'world', None):
                    logger.info(f"[TIME_CAPTURE] computed_seconds={seconds}")
                    game_state.world.advance_time(seconds)
        except Exception as _e_time:
            logger.warning(f"Time passage handling failed: {_e_time}")

        # 4. Validate Action
        is_valid, validation_feedback = _validate_agent_action(engine, context, agent_output, intent)
        if not is_valid:
            is_npc_action = hasattr(game_state, 'is_processing_npc_action') and game_state.is_processing_npc_action
            if is_npc_action:
                logger.warning(f"NPC action validation failed: {validation_feedback}")
                logger.info("Proceeding with NPC action despite validation failure to maintain combat flow")
            else:
                engine._output("system", f"Action cannot be performed: {validation_feedback}")
                return CommandResult.invalid(f"Action invalid: {validation_feedback}")


        # 4. Output primary narrative (if any) before executing mechanics, unless it's a pure data retrieval
        primary_narrative = agent_output.get('narrative', '') or ''
        requests_list = agent_output.get('requests', []) or []
        has_data_retrieval = any(isinstance(r, dict) and r.get('action') == 'request_data_retrieval' for r in requests_list)
        if primary_narrative.strip() and not has_data_retrieval:
            engine._output("gm", primary_narrative)

        # 5. Execute Validated Requests & Handle outcome/system lines
        final_narrative_parts = _execute_validated_requests(engine, game_state, agent_output, effective_actor_id, intent)

        # 5. Output Final System Messages (Results of checks/changes)
        if final_narrative_parts:
            final_outcome_narrative = "\n".join(final_narrative_parts)
            engine._output("system", final_outcome_narrative)

        processed_requests_count = len(agent_output.get('requests', []))
        return CommandResult.success("Action processed.", data={"processed_requests": processed_requests_count})

    except Exception as e:
        logger.error(f"Error in Unified Core Loop for mode {current_mode.name}: {e}", exc_info=True)
        engine._output("system", f"An unexpected error occurred while processing your action: {e}")
        return CommandResult.error(f"Internal error processing action: {e}")
```

### File: core\game_flow\interaction_processor.py

```python
# This file has been refactored and its contents moved to the following modules:
# - core.game_flow.interaction_core
# - core.game_flow.mode_transitions
# - core.game_flow.request_handlers
# - core.game_flow.npc_interaction
# Please update any imports to use the new modules.

```

### File: core\game_flow\lifecycle.py

```python
#!/usr/bin/env python3
"""
Handles game lifecycle operations like starting, loading, saving, and ticking.
"""

import os
import logging
from typing import Any, Dict, Optional

# Need to import GameEngine for type hinting and accessing its members
# Use a forward reference (string) to avoid circular import at runtime
# from core.base.engine import GameEngine
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState # Keep GameState

# Import interaction_core to call its functions
from core.game_flow import interaction_core
from core.base.state import GameState
from core.utils.logging_config import get_logger
from core.inventory import get_inventory_manager, get_item_factory

# Get the module logger (using a distinct name)
logger = get_logger("LIFECYCLE")


def start_new_game_with_state(engine: 'GameEngine', game_state: 'GameState') -> 'GameState':
    """
    Initializes systems for a new game using an already created GameState.
    
    Args:
        engine: The game engine instance.
        game_state: The pre-created and StatManager-initialized game state.
    
    Returns:
        The initialized game state.
    """
    logger.info(f"Starting new game for player {game_state.player.name} using existing game state")
    
    # Set current state in state manager
    engine._state_manager._current_state = game_state

    # Ensure the engine-level RuleChecker (used by GUI flow) is clean for this session
    try:
        if hasattr(engine, "_rule_checker") and hasattr(engine._rule_checker, "reset"):
            engine._rule_checker.reset()
            logger.info("Engine RuleChecker reset for new game session.")
    except Exception as e:
        logger.warning(f"Failed to reset engine RuleChecker for new game: {e}")
    
    # Initialize memory/context system
    engine._state_manager.initialize_memory_context(game_state)
    logger.info("Memory/context system initialized for new game")

    # Initialize player's inventory
    inventory_manager = get_inventory_manager()
    logger.info(f"LIFECYCLE: Using InventoryManager instance ID: {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
    inventory_manager.clear() 
    if hasattr(inventory_manager, 'inventory_id_for_debug'): # Check for the debug ID
        game_state.player.inventory_id = inventory_manager.inventory_id_for_debug
    elif hasattr(inventory_manager, 'instance_id_for_debug'): # Fallback to the new debug ID
         game_state.player.inventory_id = inventory_manager.instance_id_for_debug
    else: # Fallback if InventoryManager doesn't have a direct inventory_id attribute
        import uuid
        inventory_manager_id = str(uuid.uuid4())
        try:
            setattr(inventory_manager, 'inventory_id_for_debug', inventory_manager_id) 
        except AttributeError:
            logger.warning("Could not set 'inventory_id_for_debug' on InventoryManager instance.")
        game_state.player.inventory_id = inventory_manager_id
        logger.warning(f"InventoryManager instance did not have 'inventory_id_for_debug'. Assigned new ID for player state: {inventory_manager_id}")


    # Configure world time and settings based on origin
    origin_id = game_state.player.origin_id 

    if origin_id:
        from core.base.config import get_config
        config = get_config() 
        origins_config = config.get('origins') 

        if origins_config and isinstance(origins_config, dict) and origin_id in origins_config:
            origin_data = origins_config[origin_id]
            
            # Set starting location based on origin settings
            starting_location_id = origin_data.get('starting_location_id')
            if starting_location_id:
                # Resolve to location name via GameConfig locations domain
                location_name = config.get(f"locations.{starting_location_id}.name")
                resolved_location = location_name or starting_location_id
                game_state.player.current_location = resolved_location
                game_state.world.current_location = resolved_location
                logger.info(f"Set starting location to '{resolved_location}' (id='{starting_location_id}') for origin '{origin_id}'")
            else:
                logger.warning(f"Origin '{origin_id}' has no starting_location_id. Leaving current_location unchanged.")
            
            # Set up world time based on origin settings
            starting_time_period = origin_data.get('starting_time_period')
            starting_season = origin_data.get('starting_season')
            
            if starting_time_period:
                # Convert time period to actual game time
                from core.utils.enhanced_time_manager import get_enhanced_time_manager, TimePeriod
                from core.utils.time_utils import HOUR
                
                # Map time periods to approximate hours
                time_period_hours = {
                    'deep_night': 2, 'pre_dawn': 4.5, 'dawn': 6, 'morning': 9,
                    'noon': 12, 'afternoon': 15, 'evening': 18, 'sunset': 20.5, 'night': 22
                }
                
                if starting_time_period in time_period_hours:
                    target_hour = time_period_hours[starting_time_period]
                    game_state.world.game_time = target_hour * HOUR
                    logger.info(f"Set starting time to {starting_time_period} ({target_hour}:00) for origin '{origin_id}'")
                
            if starting_season:
                # Set the season in world global variables
                game_state.world.set_global_var('current_season', starting_season)
                logger.info(f"Set starting season to {starting_season} for origin '{origin_id}'")
            
            # Add starting items from origin
            starting_item_ids_from_origin = origin_data.get('starting_items', [])
            item_factory = get_item_factory()

            logger.info(f"Processing starting items for origin '{origin_id}': {starting_item_ids_from_origin}")
            for item_template_id in starting_item_ids_from_origin:
                logger.debug(f"Attempting to create starting item from template_id: '{item_template_id}'")
                item_instance = item_factory.create_item_from_template(item_template_id, variation=False)
                if item_instance:
                    added_ids = inventory_manager.add_item(item_instance)
                    if added_ids:
                        logger.info(f"Added starting item '{item_instance.name}' (ID: {added_ids[0]}) to inventory via manager {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}.")
                    else:
                        logger.warning(f"Failed to add starting item '{item_template_id}' to inventory for player '{game_state.player.name}'.")
                else:
                    logger.warning(f"Could not create starting item from template_id: '{item_template_id}' for player '{game_state.player.name}'. Template not found or creation failed.")
        elif not origins_config:
            logger.warning("Origins configuration data not found or is not a dictionary. Cannot add starting items.")
        else: 
            logger.warning(f"Origin ID '{origin_id}' not found in origins configuration. Cannot add starting items.")
    else:
        logger.warning("No origin_id found on game_state.player. Cannot add starting items.")

    # If starting time wasn't set by origin, use calendar initial_time_of_day from config
    try:
        if getattr(game_state.world, 'game_time', 0.0) in (0, 0.0):
            from core.base.config import get_config
            from core.utils.time_utils import HOUR
            cfg = get_config()
            init_period = (cfg.get("calendar.initial_time_of_day") or "morning").lower()
            time_period_hours = {
                'deep_night': 2, 'pre_dawn': 4.5, 'dawn': 6, 'morning': 9,
                'noon': 12, 'afternoon': 15, 'evening': 18, 'sunset': 20.5, 'night': 22
            }
            target_hour = time_period_hours.get(init_period, 9)
            game_state.world.game_time = float(target_hour) * HOUR
            # Recalc calendar now that game_time is set
            try:
                from core.base.state.calendar_state import CalendarState
                game_state.world.calendar.recalc_from_game_time(game_state.world.game_time)
            except Exception:
                pass
            logger.info(f"Initialized starting time from calendar setting: {init_period} ({target_hour}:00)")
    except Exception as _e_init_time:
        logger.warning(f"Failed to apply calendar initial_time_of_day: {_e_init_time}")

    # --- Activate initial quests from origin ---
    try:
        origin_id = game_state.player.origin_id
        if origin_id:
            from core.base.config import get_config
            config = get_config()
            origins_cfg = config.get('origins') or {}
            quests_cfg = config.get('quests') or {}
            if isinstance(origins_cfg, dict) and isinstance(quests_cfg, dict) and origin_id in origins_cfg:
                init_ids = origins_cfg[origin_id].get('initial_quests', []) or []
                # Ensure journal exists on state
                if not hasattr(game_state, 'journal') or not isinstance(getattr(game_state, 'journal'), dict):
                    game_state.journal = {"character": "", "quests": {}, "notes": []}
                started_events: list[tuple[str, str]] = []  # (id, title)
                # Activate each quest: add to journal.quests with status=active and copy objectives
                for qid in init_ids:
                    if qid in quests_cfg and qid not in game_state.journal["quests"]:
                        qdef = quests_cfg[qid]
                        # Build objectives with default mandatory=True unless marked (O)
                        built_objectives = []
                        for index, obj in enumerate(qdef.get("objectives", [])):
                            if isinstance(obj, dict):
                                desc_text = obj.get("description") or ""
                                oid = obj.get("id") or str(index)
                                mandatory = obj.get("mandatory")
                            else:
                                desc_text = str(obj)
                                oid = str(index)
                                mandatory = None
                            text_lower = desc_text.lower()
                            is_optional = "(o)" in text_lower if isinstance(desc_text, str) else False
                            # If 'mandatory' explicitly given, use it; otherwise infer from tags
                            is_mandatory = (mandatory if isinstance(mandatory, bool) else ("(m)" in text_lower or not is_optional))

                            # Build hydrated objective entry with all relevant fields for evaluation
                            hydrated_obj = {
                                "id": oid,
                                "description": desc_text,
                                "completed": False,
                                "failed": False,
                                "mandatory": bool(is_mandatory),
                            }
                            if isinstance(obj, dict):
                                for k in ["type", "target_id", "location_id", "completion_criteria", "condition_dsl", "time_limit_s", "fail_if"]:
                                    if k in obj:
                                        hydrated_obj[k] = obj[k]
                            built_objectives.append(hydrated_obj)

                        title = qdef.get("title", qid)
                        game_state.journal["quests"][qid] = {
                            "title": title,
                            "description": qdef.get("description", ""),
                            "status": "active",
                            "objectives": built_objectives,
                            "rewards": qdef.get("rewards", {}),
                            "prerequisites": qdef.get("prerequisites", []),
                            "tags": qdef.get("tags", []),
                        }
                        started_events.append((qid, title))
                logger.info(f"Activated {len(init_ids)} initial quests for origin '{origin_id}'.")
    except Exception as e:
        logger.error(f"Failed to activate initial quests: {e}")

    # Seed calendar journal entry (Resonance Calendar) if configured
    try:
        from core.base.config import get_config
        cfg = get_config()
        cal_entry = (cfg.get('calendar_master.journal_entry') or {}) if cfg else {}
        if isinstance(cal_entry, dict) and cal_entry:
            # Ensure journal exists
            if not hasattr(game_state, 'journal') or not isinstance(getattr(game_state, 'journal'), dict):
                game_state.journal = {"character": "", "quests": {}, "notes": []}
            notes = game_state.journal.get('notes') if isinstance(game_state.journal, dict) else None
            if isinstance(notes, list):
                # Avoid duplicates by id or title
                entry_id = cal_entry.get('id', 'resonance_calendar')
                title = cal_entry.get('title', 'Resonance Calendar')
                already = any((isinstance(n, dict) and (n.get('id') == entry_id or n.get('title') == title)) for n in notes)
                if not already:
                    notes.append({
                        'id': entry_id,
                        'type': cal_entry.get('type', 'lore'),
                        'title': title,
                        'summary': cal_entry.get('summary', ''),
                        'content': cal_entry.get('body', cal_entry.get('content', '')),
                        'pinned': bool(cal_entry.get('pinned', False)),
                    })
    except Exception as _e_seed:
        logger.warning(f"Failed to seed calendar journal entry: {_e_seed}")

    # Send welcome message
    welcome_message_base = f"==== WELCOME TO YOUR ADVENTURE ====\n\nGreetings, {game_state.player.name} the {game_state.player.race} {game_state.player.path} from {game_state.player.background}!"
    
    introduction_text_for_llm = game_state.player.background 
    if origin_id: 
        from core.base.config import get_config
        config = get_config() 
        origins_config = config.get('origins') 
        if origins_config and isinstance(origins_config, dict) and origin_id in origins_config:
            introduction_text_for_llm = origins_config[origin_id].get('introduction_text', game_state.player.background)
    
    full_welcome_message = f"{welcome_message_base}\n\nYour journey begins now..." 
    
    logger.info(f"Sending welcome message: '{full_welcome_message[:100]}...' with role 'gm'")
    engine._output("gm", full_welcome_message)
    
    # Send help message
    help_message = "Type 'help' for a list of commands."
    engine._output("system", help_message)
    
    # Generate initial narrative if LLM is enabled
    if engine._use_llm:
        logger.info("Generating welcome narration (structured)")
        narration_prompt = (
            f"I've just started a new game as {game_state.player.name}, a {game_state.player.race} {game_state.player.path}. "
            f"My background is: \"{introduction_text_for_llm}\". "
            f"Please provide an initial immersive narration based on this, describing my immediate surroundings and current situation as the game begins. "
            f"This is the first narrative in the game, so make it welcoming and informative."
        )

        # Use structured narrator path to obtain narrative and time_passage
        try:
            from core.game_flow.interaction_core import _build_interaction_context, _get_agent_response
            from core.interaction.enums import InteractionMode
            context = _build_interaction_context(game_state, InteractionMode.NARRATIVE, actor_id=getattr(game_state.player, 'id', None))
            agent_output = _get_agent_response(engine, game_state, context, narration_prompt, InteractionMode.NARRATIVE) or {}
            # Log structured agent output for welcome
            try:
                import json as _json
                logger.info(f"[LLM_AGENT_OUTPUT_STRUCTURED] {_json.dumps(agent_output, ensure_ascii=False)}")
            except Exception:
                logger.info("[LLM_AGENT_OUTPUT_STRUCTURED] <unavailable>")
            narrative_text = agent_output.get('narrative') or "The world awaits your command..."
            # Advance time for NARRATIVE welcome based on time_passage (fallback to 1m)
            try:
                from core.utils.time_utils import parse_time_string, MINUTE
                tp = agent_output.get('time_passage')
                logger.info(f"[TIME_CAPTURE] raw_time_passage_field={tp!r}")
                seconds = parse_time_string(tp) if tp else None
                if seconds is None:
                    seconds = 1 * MINUTE
                if getattr(game_state, 'world', None):
                    logger.info(f"[TIME_CAPTURE] computed_seconds={seconds}")
                    from core.time.time_controller import get_time_controller
                    get_time_controller().apply_llm_increment(game_state.world, seconds)
            except Exception as e_time:
                logger.warning(f"Welcome time passage handling failed: {e_time}")
        except Exception as e:
            logger.warning(f"Structured welcome generation failed: {e}")
            narrative_text = "The world awaits your command..."

        # Route the initial narrative through the orchestrator so we can append quest-start messages afterwards
        try:
            if hasattr(engine, '_combat_orchestrator') and engine._combat_orchestrator:
                from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                engine._combat_orchestrator.add_event_to_queue(
                    DisplayEvent(
                        type=DisplayEventType.NARRATIVE_GENERAL,
                        content=narrative_text,
                        role="gm",
                        target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                        gradual_visual_display=True,
                        tts_eligible=True,
                    )
                )
                # After the narrative is queued, append quest-start system messages to the queue
                try:
                    started_events = locals().get('started_events', [])
                except Exception:
                    started_events = []
                # Consolidate all started quests into a single instant system line
                titles = [title for _, title in started_events] if started_events else []
                if titles:
                    msg = "Quests started: " + "; ".join(titles)
                    engine._combat_orchestrator.add_event_to_queue(
                        DisplayEvent(
                            type=DisplayEventType.SYSTEM_MESSAGE,
                            content=msg,
                            target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                            gradual_visual_display=False,
                            tts_eligible=False,
                        )
                    )
            else:
                # Fallback: no orchestrator. Output narrative immediately, then quest messages.
                engine._output("gm", narrative_text)
                for qid, title in locals().get('started_events', []):
                    engine._output("system", f"Quest Started: {title}")
        except Exception as e:
            logger.warning(f"Failed to route initial narrative/quest-start via orchestrator: {e}")
    else:
        engine._output("gm", "The world awaits your command...")
        # With LLM disabled, we can emit quest start messages immediately afterwards (no gradual display to wait for)
        try:
            titles = [title for _, title in locals().get('started_events', [])]
            if titles:
                engine._output("system", "Quests started: " + "; ".join(titles))
        except Exception:
            pass
        
    logger.info(f"New game started for {game_state.player.name}")
    return game_state

def start_new_game(engine: 'GameEngine', player_name: str, race: str = "Human",
                   path: str = "Wanderer", background: str = "Commoner",
                   sex: str = "Male", character_image: Optional[str] = None,
                   stats: Optional[Dict[str, int]] = None) -> GameState:
    """
    Start a new game.

    Args:
        engine: The GameEngine instance.
        player_name: The name of the player character.
        race: The race of the player character.
        path: The class/path of the player character.
        background: The background of the player character.
        sex: The sex/gender of the player character.
        character_image: Path to character image.
        stats: Optional dictionary of starting stats.

    Returns:
        The new game state.
    """
    logger.info(f"Starting new game for player {player_name}")

    # Clean up existing game if present
    if engine._state_manager.current_state is not None:
        logger.info("Cleaning up existing game before starting new one")
        if engine._game_loop.is_running:
            engine._game_loop.pause()
        if engine._agent_manager is not None and engine._use_llm:
            try:
                engine._agent_manager.reset_state()
            except Exception as e:
                logger.warning(f"Error resetting agent state: {e}")

    # Create new game state
    game_state = engine._state_manager.create_new_game(
        player_name=player_name,
        race=race,
        path=path,
        background=background,
        sex=sex,
        character_image=character_image,
        stats=stats
    )
    
    # Now use the shared function to start the game with this state
    return start_new_game_with_state(engine, game_state)


def load_game(engine: 'GameEngine', filename: str) -> Optional[GameState]:
    """
    Load a game from a save file.

    Args:
        engine: The GameEngine instance.
        filename: The name of the save file.

    Returns:
        The loaded game state, or None if the load failed.
    """
    logger.info(f"Loading game from {filename}")

    # Clean up existing game if present
    if engine._state_manager.current_state is not None:
        logger.info("Cleaning up existing game before loading")
        if engine._game_loop.is_running:
            engine._game_loop.pause()
        if engine._agent_manager is not None and engine._use_llm:
            try:
                engine._agent_manager.reset_state()
            except Exception as e:
                logger.warning(f"Error resetting agent state: {e}")
        # Also reset the engine-level RuleChecker which is used for validation in GUI
        try:
            if hasattr(engine, "_rule_checker") and hasattr(engine._rule_checker, "reset"):
                engine._rule_checker.reset()
                logger.info("Engine RuleChecker reset before load.")
        except Exception as e:
            logger.warning(f"Failed to reset engine RuleChecker before load: {e}")

    # Load the game state
    game_state = engine._state_manager.load_game(filename)

    if game_state is None:
        logger.error(f"Failed to load game from {filename}")
        engine._output("system", f"Failed to load game from {filename}")
        return None

    # Set up the game loop with the loaded world state
    engine._game_loop.set_world_state(game_state.world)

    # Sync player location with world current_location for web server compatibility
    game_state.world.current_location = game_state.player.current_location

    # Reset auto-save timer
    engine._auto_save_timer = 0

    # Initialize memory/context system if available
    try:
        if hasattr(engine._state_manager, 'initialize_memory_context'):
            engine._state_manager.initialize_memory_context(game_state)
            logger.info("Memory/context system initialized for loaded game")
    except Exception as e:
        logger.warning(f"Error initializing memory/context system: {e}")

    # Prepare agent system for the loaded game if LLM is enabled
    if engine._use_llm and engine._agent_manager is not None:
        try:
            logger.info("Preparing agent system for loaded game")
            # Reset agent state to prepare for loaded context
            engine._agent_manager.reset_state()
            logger.info("Agent manager state reset for loaded game")
        except Exception as e:
            logger.warning(f"Error preparing agent system: {e}")
    # Ensure the engine-level RuleChecker is also cleared for the loaded session
    try:
        if hasattr(engine, "_rule_checker") and hasattr(engine._rule_checker, "reset"):
            engine._rule_checker.reset()
            logger.info("Engine RuleChecker reset for loaded game.")
    except Exception as e:
        logger.warning(f"Failed to reset engine RuleChecker after load: {e}")

    # Start/unpause the game loop if it was paused
    if engine._game_loop.is_paused:
        logger.info("Unpausing game loop for loaded game")
        engine._game_loop.unpause()

    # Output welcome back message
    engine._output(
        "gm",
        f"Welcome back, {game_state.player.name}! You are currently at {game_state.player.current_location}."
    )

    # Output system info about time using narrative description
    world_state = game_state.world
    time_description = world_state.time_of_day
    engine._output(
        "system",
        f"It is {time_description}."
    )

    # Generate reintroductory narrative if LLM is enabled (AFTER initial messages like new game)
    if engine._use_llm:
        logger.info("Generating reintroductory narrative for loaded game")
        reintroductory_narrative = _generate_reintroductory_narrative_content(engine, game_state)
        
        if reintroductory_narrative:
            logger.info(f"Received reintroductory narrative from LLM, first 100 chars: '{reintroductory_narrative[:100]}...'")
            engine._output("gm", reintroductory_narrative)
        else:
            logger.warning("Failed to generate reintroductory narrative from LLM.")
            engine._output("system", "You continue your adventure...")

    return game_state


def _generate_reintroductory_narrative_content(engine: 'GameEngine', game_state: 'GameState') -> Optional[str]:
    """
    Generate reintroductory narrative content for loaded games (without sending it).
    
    This provides context to help players re-engage with their saved game,
    summarizing their current situation and recent context.
    
    Args:
        engine: The game engine instance.
        game_state: The loaded game state.
        
    Returns:
        The generated narrative content, or None if generation failed.
    """
    try:
        # Build contextual prompt for reintroduction
        player = game_state.player
        current_location = player.current_location or "an unknown location"
        
        # Use enhanced time descriptions instead of clock time
        world_state = game_state.world
        time_of_day = world_state.atmospheric_time  # Rich atmospheric description
        
        # Get player's background/origin context if available
        background_context = ""
        if hasattr(player, 'background') and player.background:
            background_context = f"Background: {player.background}. "
        
        # Build the reintroduction prompt
        reintro_prompt = (
            f"I'm continuing my adventure as {player.name}, a {player.race} {player.path}. "
            f"{background_context}"
            f"I'm currently at {current_location}. "
            f"It is {time_of_day}. "
            f"Please provide an immersive narrative that reintroduces me to my current situation. "
            f"Describe my immediate surroundings and give me a sense of what I was doing or what's happening. "
            f"Make it atmospheric, but not overly narrative and help me get back into the story - I need all most important details from my previous game."
        )
        
        # Generate the narrative using structured narrator
        try:
            from core.game_flow.interaction_core import _build_interaction_context, _get_agent_response
            from core.interaction.enums import InteractionMode
            context = _build_interaction_context(game_state, InteractionMode.NARRATIVE, actor_id=getattr(game_state.player, 'id', None))
            agent_output = _get_agent_response(engine, game_state, context, reintro_prompt, InteractionMode.NARRATIVE) or {}
            # Log structured agent output for reintro
            try:
                import json as _json
                logger.info(f"[LLM_AGENT_OUTPUT_STRUCTURED] {_json.dumps(agent_output, ensure_ascii=False)}")
            except Exception:
                logger.info("[LLM_AGENT_OUTPUT_STRUCTURED] <unavailable>")
            narrative = agent_output.get('narrative')
            if narrative:
                # Advance time outside combat (NARRATIVE): use time_passage fallback to 1m
                try:
                    from core.utils.time_utils import parse_time_string, MINUTE
                    tp = agent_output.get('time_passage')
                    logger.info(f"[TIME_CAPTURE] raw_time_passage_field={tp!r}")
                    seconds = parse_time_string(tp) if tp else None
                    if seconds is None:
                        seconds = 1 * MINUTE
                    if getattr(game_state, 'world', None):
                        logger.info(f"[TIME_CAPTURE] computed_seconds={seconds}")
                        from core.time.time_controller import get_time_controller
                        get_time_controller().apply_llm_increment(game_state.world, seconds)
                except Exception as e_time:
                    logger.warning(f"Reintro time passage handling failed: {e_time}")
                return narrative
        except Exception as e:
            logger.warning(f"Structured reintro generation failed: {e}")

        # Fallback logic for when narrative generation fails or returns empty.
        logger.warning("Failed to generate reintroductory narrative. Using fallback.")
        fallback_message = (
            f"You find yourself at {current_location} as {time_of_day.lower()} settles in. "
            f"The familiar surroundings remind you of your ongoing adventure."
        )
        logger.info("LIFECYCLE_DEBUG: Returning fallback narrative content")
        return fallback_message
            
    except Exception as e:
        logger.error(f"Error generating reintroductory narrative: {e}", exc_info=True)
        # Provide a minimal fallback
        return "You take a moment to gather your bearings and continue your adventure."


def save_game(engine: 'GameEngine', filename: Optional[str] = None,
              auto_save: bool = False) -> Optional[str]:
    """
    Save the current game.

    Args:
        engine: The GameEngine instance.
        filename: The name of the save file. If None, generates a name.
        auto_save: Whether this is an auto-save.

    Returns:
        The path to the save file, or None if the save failed.
    """
    logger.info(f"Saving game{' (auto)' if auto_save else ''}")

    if engine._state_manager.current_state is None:
        logger.error("Cannot save: No current game state")
        engine._output("system", "Cannot save: No game in progress")
        return None

    # Save the game state
    save_path = engine._state_manager.save_game(filename, auto_save)

    if save_path is None:
        logger.error("Failed to save game")
        engine._output("system", "Failed to save game")
        return None

    # Output save confirmation (unless auto-save)
    if not auto_save:
        engine._output("system", f"Game saved to {os.path.basename(save_path)}")

    return save_path


def handle_tick(engine: 'GameEngine', elapsed_game_time: float) -> None:
    """
    DEPRECATED (Phase 1): Tick-driven autosave has been migrated to a scheduler
    independent of GameLoop. This function remains for backward compatibility
    but should no longer be used as a driver for autosave or time-based logic.

    Args:
        engine: The GameEngine instance.
        elapsed_game_time: The elapsed game time in seconds since the last tick.
    """
    logger.debug("handle_tick called but deprecated in Phase 1; no autosave triggered here.")
    # If any future non-time-driving periodic tasks are needed, they can be handled elsewhere.
    return

```

### File: core\game_flow\reference_resolver.py

```python
#!/usr/bin/env python3
"""
ReferenceResolver: resolves narrative labels to canonical references (template_id, ids) using
config-defined aliases. This is a lightweight Phase 1 resolver; LLM-assisted mapping can be
added later behind this interface.
"""
from __future__ import annotations
from typing import Dict, List, Optional

from core.base.config import GameConfig
from core.utils.logging_config import get_logger

logger = get_logger("REF_RESOLVER")

class ReferenceResolver:
    """Resolves labels to canonical IDs based on config aliases.

    Aliases config shape suggestion (config/world/aliases.json):
    {
      "entities": { "white_wolf": ["wolf_alpha", "test_wolf_alpha"] },
      "items": { "healing_herb": ["herb_healing"] },
      "locations": { "ruins": ["ancient_ruins"] },
      "dialogues": { },
      "interactions": { }
    }
    Values can be a string or list of strings (candidate canonical IDs).
    """

    def __init__(self) -> None:
        self._config = GameConfig()

    def _get_domain_aliases(self, domain: str) -> Dict[str, List[str]]:
        try:
            # Primary global aliases
            data = self._config.get("aliases", {})
            dom = data.get(domain, {}) if isinstance(data, dict) else {}
            # Optional NPC entity-specific aliases (config/aliases/entities.json)
            if domain == "entities":
                npc_aliases = self._config.get("npc_entity_aliases.entities", {}) or {}
                # Merge npc_entity_aliases into dom (prefer explicitly provided lists)
                if isinstance(npc_aliases, dict):
                    for k, v in npc_aliases.items():
                        key = str(k).lower()
                        if key not in dom:
                            dom[key] = v
                        else:
                            # Merge lists if both exist
                            try:
                                existing = dom.get(key, [])
                                if isinstance(existing, list) and isinstance(v, list):
                                    dom[key] = list({*map(str, existing), *map(str, v)})
                            except Exception:
                                pass
            # Normalize to list[str]
            out: Dict[str, List[str]] = {}
            for k, v in (dom or {}).items():
                if isinstance(v, list):
                    out[str(k).lower()] = [str(x) for x in v]
                elif isinstance(v, str):
                    out[str(k).lower()] = [v]
            return out
        except Exception:
            return {}

    def resolve(self, domain: str, label: str) -> List[str]:
        """Return candidate canonical IDs for label within domain.
        If no mapping found, return [label] as identity fallback.
        """
        if not label:
            return []
        key = str(label).lower()
        dom_aliases = self._get_domain_aliases(domain)
        mapped = dom_aliases.get(key)
        if mapped:
            return mapped
        return [label]


_resolver_instance: Optional[ReferenceResolver] = None

def get_reference_resolver() -> ReferenceResolver:
    global _resolver_instance
    if _resolver_instance is None:
        _resolver_instance = ReferenceResolver()
    return _resolver_instance

```

### File: core\game_flow\request_handlers.py

```python
#!/usr/bin/env python3
"""
Handles execution of validated structured requests (skill checks, state changes).
"""

import logging
from typing import Dict, List, Optional, Any, TYPE_CHECKING

# --- Core Imports ---
from core.stats.combat_effects import StatusEffect, StatusEffectType
from core.stats.enums import Skill
from core.stats.stats_base import StatType, DerivedStatType
from core.stats.stats_manager import get_stats_manager
from core.interaction.enums import InteractionMode
from core.interaction.social_effects import SocialStatusEffect
from core.combat.combat_entity import CombatEntity, EntityType
from core.combat.combat_manager import CombatManager
from core.combat.enums import CombatState
from core.combat.combat_action import CombatAction, ActionType, AttackAction # Import relevant actions

# --- Utils ---
from core.game_flow.game_flow_utils import get_participant_by_id

if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState

# --- Logger ---
logger = logging.getLogger("INTERACTION_PROC") # Keep original logger name


def _process_skill_check_request(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """
    Processes a skill check request by constructing and performing the corresponding
    CombatAction via the CombatManager. Uses combat_name for lookups.
    """
    skill_name_str = request.get("skill_name")
    # --- MODIFICATION: Get names instead of IDs ---
    actor_combat_name = request.get("actor_id") # This field now holds the combat_name
    target_combat_name = request.get("target_actor_id")
    # --- END MODIFICATION ---
    context_msg = request.get("context", f"Attempting {skill_name_str or 'skill check'}")

    logger.debug(f"Processing SkillCheckRequest for actor '{actor_combat_name}': {request}")

    try:
        if not skill_name_str: raise ValueError("Missing 'skill_name'")
        if not game_state.combat_manager: raise ValueError("CombatManager not found in GameState.")
        if not actor_combat_name: raise ValueError("Missing 'actor_id' (combat_name) in request")

        # --- MODIFICATION: Find entities by combat_name ---
        actor = game_state.combat_manager._find_entity_by_combat_name(actor_combat_name)
        if not actor: raise ValueError(f"Actor '{actor_combat_name}' not found in combat.")
        actor_internal_id = actor.id # Get the actual UUID

        target = None
        target_internal_id = None
        is_attack_skill = skill_name_str.upper() in ["MELEE_ATTACK", "RANGED_ATTACK", "UNARMED_ATTACK", "SPELL_ATTACK"]
        if is_attack_skill:
            if not target_combat_name:
                raise ValueError(f"Attack skill '{skill_name_str}' requires a target_actor_id (combat_name).")
            target = game_state.combat_manager._find_entity_by_combat_name(target_combat_name)
            if not target:
                 # Allow action to proceed but log error and potentially return specific message
                 logger.error(f"Target '{target_combat_name}' not found for skill check {skill_name_str}.")
                 # Return error message immediately, prevents further processing with invalid target
                 return f"Action failed: Target '{target_combat_name}' not found."
            target_internal_id = target.id # Get the actual UUID
        # --- END MODIFICATION ---

        action_to_perform: Optional[CombatAction] = None
        skill_upper = skill_name_str.upper()

        if is_attack_skill:
            # Use internal UUIDs for the action
            action_to_perform = AttackAction(
                performer_id=actor_internal_id,
                target_id=target_internal_id,
                weapon_name=request.get("weapon_name", skill_name_str),
                dice_notation=request.get("dice_notation", "1d6"),
            )
            action_to_perform.action_type = ActionType.ATTACK
        elif skill_upper == "DEFENSE":
             logger.warning("DEFENSE skill check request currently not linked to a CombatAction.")
             return f"{actor.combat_name} attempts to defend (DEFENSE check not fully implemented)."
        elif skill_upper == "DODGE":
             logger.warning("DODGE skill check request currently not linked to a CombatAction.")
             return f"{actor.combat_name} attempts to dodge (DODGE check not fully implemented)."
        else:
             logger.warning(f"Unhandled skill check request type for direct action: {skill_name_str}. Processing as generic check.")
             return f"System Error: Skill check '{skill_name_str}' cannot be directly performed as a combat action in this context."

        if action_to_perform:
            logger.info(f"Attempting to perform action via CombatManager: {action_to_perform.name} by {actor.combat_name} ({actor_internal_id})")
            action_result = game_state.combat_manager.perform_action(action_to_perform)

            # --- Format Narrative from Action Result (Uses combat_names) ---
            performer_name_display = action_result.get("performer", actor.combat_name)
            target_name_display = action_result.get("target", target.combat_name if target else "target")

            if action_result.get("success"):
                damage = action_result.get("damage", 0)
                hp_remaining_val = action_result.get("target_hp_remaining", '?')
                hp_remaining = f"{hp_remaining_val:.0f}" if isinstance(hp_remaining_val, (int, float)) else '?'
                max_hp_val = action_result.get("target_max_hp", '?') # Assuming result might include max hp
                max_hp = f"{max_hp_val:.0f}" if isinstance(max_hp_val, (int, float)) else '?'
                target_defeated = action_result.get("target_defeated", False)
                crit_str = " Critically!" if action_result.get("is_critical") else ""

                if damage > 0:
                    narrative = f"{performer_name_display} hits {target_name_display}{crit_str} for {damage} damage."
                    if target_defeated: narrative += f" {target_name_display} is defeated!"
                    else: narrative += f" (HP: {hp_remaining}/{max_hp})"
                else:
                    narrative = f"{performer_name_display}'s attack hits {target_name_display} but deals no damage."

                stamina_cost_val = action_result.get('stamina_cost')
                stamina_rem_val = action_result.get('stamina_remaining')
                stamina_cost_str = f"{stamina_cost_val:.1f}" if isinstance(stamina_cost_val, (int, float)) else '?'
                stamina_rem_str = f"{stamina_rem_val:.1f}" if isinstance(stamina_rem_val, (int, float)) else '?'
                narrative += f" (Stamina Cost: {stamina_cost_str}, Remaining: {stamina_rem_str})"

            else: # Action failed
                narrative = action_result.get("message", f"{performer_name_display}'s action failed.")
                stamina_cost_val = action_result.get('stamina_cost')
                stamina_rem_val = action_result.get('stamina_remaining')
                if stamina_cost_val is not None and stamina_rem_val is not None:
                    stamina_cost_str = f"{stamina_cost_val:.1f}" if isinstance(stamina_cost_val, (int, float)) else '?'
                    stamina_rem_str = f"{stamina_rem_val:.1f}" if isinstance(stamina_rem_val, (int, float)) else '?'
                    narrative += f" (Stamina Cost: {stamina_cost_str}, Remaining: {stamina_rem_str})"

            logger.info(f"Skill Check Action Result Narrative: {narrative}")
            return narrative
        else:
            logger.error(f"No CombatAction constructed for skill check request: {request}")
            return f"System Error: Could not determine action for skill '{skill_name_str}'."

    except ValueError as e:
        logger.error(f"Validation error processing SkillCheckRequest {request}: {e}")
        return f"System Error: Invalid skill check request ({e})."
    except AttributeError as e:
         logger.error(f"Missing attribute processing SkillCheckRequest {request}: {e}", exc_info=True)
         return f"System Error: Missing data for skill check ({e})."
    except Exception as e:
        logger.error(f"Unexpected error performing skill check {request}: {e}", exc_info=True)
        return f"System Error: Unexpected error during {skill_name_str or 'skill'} check."

def _process_state_change_request(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Processes a single state change request and returns the narrative result. Uses combat_name.
    Also supports a simplified narrative-mode path when no CombatManager exists (applies to the player).
    """
    # --- MODIFICATION: Get combat_name instead of ID ---
    target_combat_name = request.get("target_entity")
    # --- END MODIFICATION ---
    attribute = request.get("attribute")
    value = request.get("value")
    duration_str = request.get("duration")

    # Narrative-mode support: if no CombatManager, apply basic state changes to the player via StatsManager
    if not getattr(game_state, 'combat_manager', None):
        try:
            # Default target is the player in narrative mode
            player_stats = engine.state_manager.stats_manager if hasattr(engine, 'state_manager') else get_stats_manager()
            if not player_stats:
                return ""
            # Normalize attribute keys
            attr_key = (str(attribute or "").strip().lower())
            # Helper to coerce numeric value
            try:
                delta = float(value)
            except Exception:
                delta = None
            from core.stats.stats_base import DerivedStatType
            if attr_key in ("hp", "health") and delta is not None:
                cur = player_stats.get_current_stat_value(DerivedStatType.HEALTH)
                new_v = max(0.0, cur + delta)
                ok = player_stats.set_current_stat(DerivedStatType.HEALTH, new_v)
                if ok:
                    max_v = player_stats.get_stat_value(DerivedStatType.MAX_HEALTH)
                    if delta < 0:
                        return f"You take {abs(delta):.0f} damage. Current HP: {new_v:.0f}/{max_v:.0f}."
                    else:
                        return f"You recover {delta:.0f} HP. Current HP: {new_v:.0f}/{max_v:.0f}."
                return ""
            if attr_key == "stamina" and delta is not None:
                cur = player_stats.get_current_stat_value(DerivedStatType.STAMINA)
                new_v = max(0.0, cur + delta)
                ok = player_stats.set_current_stat(DerivedStatType.STAMINA, new_v)
                if ok:
                    max_v = player_stats.get_stat_value(DerivedStatType.MAX_STAMINA)
                    if delta < 0:
                        return f"You spend {abs(delta):.1f} stamina. Remaining: {new_v:.1f}/{max_v:.1f}."
                    else:
                        return f"You recover {delta:.1f} stamina. Current: {new_v:.1f}/{max_v:.1f}."
                return ""
            if attr_key == "mana" and delta is not None:
                cur = player_stats.get_current_stat_value(DerivedStatType.MANA)
                new_v = max(0.0, cur + delta)
                ok = player_stats.set_current_stat(DerivedStatType.MANA, new_v)
                if ok:
                    max_v = player_stats.get_stat_value(DerivedStatType.MAX_MANA)
                    if delta < 0:
                        return f"You spend {abs(delta):.1f} mana. Remaining: {new_v:.1f}/{max_v:.1f}."
                    else:
                        return f"You recover {delta:.1f} mana. Current: {new_v:.1f}/{max_v:.1f}."
                return ""
            # Unknown or unsupported attribute in narrative mode: no error, ignore silently
            return ""
        except Exception:
            # Be quiet in narrative mode
            return ""

    duration_int: Optional[int] = None
    if duration_str is not None:
        try:
            duration_int = int(duration_str)
        except (ValueError, TypeError):
            logger.warning(f"Invalid duration format '{duration_str}' in state change request. Ignoring duration.")

    logger.debug(f"Processing StateChangeRequest: {request}")
    if not target_combat_name or not attribute: # Check name
        logger.error(f"StateChangeRequest missing target_entity (combat_name) or attribute: {request}")
        return "System Error: State change request is incomplete."

    # Handle inventory before any combat-specific lookups (no CombatManager required)
    if attribute == "inventory":
        try:
            from core.inventory import get_inventory_manager, get_item_factory
            inv = get_inventory_manager()
            item_factory = get_item_factory()

            change_type_raw = (request.get("change_type") or request.get("change") or "add").lower()
            qty_raw = request.get("quantity", request.get("count", 1))
            try:
                quantity = int(qty_raw)
            except Exception:
                quantity = 1
            if quantity <= 0:
                quantity = 1

            if change_type_raw in ("add", "give", "pickup", "obtain", "create"):
                item_obj = None
                item_spec = request.get("item_spec") or request.get("item_data")
                if isinstance(item_spec, dict):
                    try:
                        item_obj = item_factory.create_item_from_spec(item_spec)
                    except Exception:
                        item_obj = None
                if item_obj is None:
                    template_id = request.get("template_id") or request.get("item_template")
                    ref_item_id = request.get("item_id")
                    if ref_item_id:
                        existing = inv.get_item(ref_item_id)
                        if existing:
                            item_obj = existing
                        elif not template_id:
                            template_id = ref_item_id
                    if item_obj is None and template_id:
                        item_obj = item_factory.create_item_from_template(template_id, variation=False)
                if item_obj is None:
                    item_name = request.get("item_name") or request.get("name")
                    if item_name:
                        found = inv.find_items(name=item_name)
                        if found:
                            item_obj = found[0]
                if item_obj is not None:
                    inv.add_item(item_obj, quantity=quantity)
                return ""  # silent
            elif change_type_raw in ("remove", "drop", "discard", "consume", "delete"):
                target_item = None
                ref_item_id = request.get("item_id")
                if ref_item_id:
                    target_item = inv.get_item(ref_item_id)
                if not target_item:
                    template_id = request.get("template_id") or request.get("item_template")
                    if template_id:
                        for it in getattr(inv, "_items", {}).values():
                            if getattr(it, "template_id", None) == template_id:
                                target_item = it
                                break
                if not target_item:
                    item_name = request.get("item_name") or request.get("name")
                    if item_name:
                        found = inv.find_items(name=item_name)
                        if found:
                            target_item = found[0]
                if target_item is not None:
                    inv.remove_item(target_item.id, quantity=quantity)
                return ""  # silent regardless
            else:
                return ""
        except Exception:
            return ""

    try:
        # --- MODIFICATION: Find participant by combat_name ---
        if not game_state.combat_manager: raise ValueError("CombatManager not found.")
        participant = game_state.combat_manager._find_entity_by_combat_name(target_combat_name)
        if not participant:
            # Check if the target is the effective actor (e.g., applying buff to self)
            effective_actor = game_state.combat_manager._find_entity_by_combat_name(effective_actor_id) # Find actor by name
            if effective_actor and effective_actor.combat_name == target_combat_name:
                 participant = effective_actor
                 logger.debug(f"State change target is the actor themselves: {target_combat_name}")
            else:
                 raise ValueError(f"Target entity '{target_combat_name}' not found.")
        # --- END MODIFICATION ---

        target_internal_id = participant.id # Get the actual internal ID
        change_applied = False
        change_narrative = ""
        participant_name_display = participant.combat_name # Use combat name for display

        # Get the StatsManager for the target participant
        stats_manager = engine._get_entity_stats_manager(target_internal_id) # Use internal ID
        if not stats_manager:
            raise ValueError(f"Could not get StatsManager for target '{participant_name_display}' ({target_internal_id}).")

        # --- Apply State Change (using StatsManager) ---
        if attribute == "hp":
            try:
                delta = float(value)
                current_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                new_hp = current_hp + delta
                set_ok = stats_manager.set_current_stat(DerivedStatType.HEALTH, new_hp)

                if set_ok:
                    final_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                    max_hp = stats_manager.get_stat_value(DerivedStatType.MAX_HEALTH)
                    if delta < 0:
                         change_narrative = f"{participant_name_display} takes {abs(delta):.0f} damage. Current HP: {final_hp:.0f}/{max_hp:.0f}."
                    else:
                         change_narrative = f"{participant_name_display} heals {delta:.0f} HP. Current HP: {final_hp:.0f}/{max_hp:.0f}."
                    change_applied = True
                    if final_hp <= 0 and game_state.combat_manager:
                         # Ensure combat entity HP also reflects 0
                         combat_entity = game_state.combat_manager.get_entity_by_id(target_internal_id)
                         if combat_entity: combat_entity.current_hp = 0
                         change_narrative += f" {participant_name_display} is defeated!"
                         if hasattr(game_state.combat_manager, '_check_combat_state'):
                              game_state.combat_manager._check_combat_state()
                else:
                    change_narrative = f"System Error: Failed to apply HP change to {participant_name_display}."
            except (ValueError, TypeError):
                 change_narrative = f"System Error: Invalid HP change value '{value}'."

        elif attribute == "stamina":
            try:
                delta = float(value)
                current_stamina = stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                new_stamina = current_stamina + delta
                set_ok = stats_manager.set_current_stat(DerivedStatType.STAMINA, new_stamina)

                if set_ok:
                    final_stamina = stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                    max_stamina = stats_manager.get_stat_value(DerivedStatType.MAX_STAMINA)
                    if delta < 0:
                        change_narrative = f"{participant_name_display} spends {abs(delta):.1f} stamina. Remaining: {final_stamina:.1f}/{max_stamina:.1f}."
                    else:
                        change_narrative = f"{participant_name_display} recovers {delta:.1f} stamina. Current: {final_stamina:.1f}/{max_stamina:.1f}."
                    change_applied = True
                else:
                    if delta < 0 and current_stamina < abs(delta):
                         change_narrative = f"{participant_name_display} does not have enough stamina (Needs {abs(delta):.1f}, Has {current_stamina:.1f})."
                    else:
                         change_narrative = f"System Error: Failed to apply Stamina change to {participant_name_display}."
            except (ValueError, TypeError):
                 change_narrative = f"System Error: Invalid Stamina change value '{value}'."

        elif attribute == "add_status_effect":
            if isinstance(value, str):
                effect_name = value
                # Pass converted integer duration
                stats_manager.add_status_effect(StatusEffect(name=effect_name, description=f"Applied {effect_name}", effect_type=StatusEffectType.SPECIAL, duration=duration_int if duration_int is not None else -1))
                # Also update the CombatEntity's local status_effects dict
                participant.add_status_effect(effect_name, duration=duration_int)
                duration_str_narrative = f" for {duration_int} turns" if duration_int is not None else ""
                change_narrative = f"{participant_name_display} is now afflicted with {effect_name}{duration_str_narrative}."
                change_applied = True
            else:
                change_narrative = f"System Error: Invalid status effect name '{value}'."

        elif attribute == "remove_status_effect":
            if isinstance(value, str):
                effect_name = value
                removed_count = stats_manager.status_effect_manager.remove_effects_by_name(effect_name)
                # Also remove from CombatEntity's local status_effects dict
                participant.remove_status_effect(effect_name)
                if removed_count > 0:
                     change_narrative = f"{participant_name_display} is no longer affected by {effect_name}."
                     change_applied = True
                else:
                     change_narrative = f"{participant_name_display} was not affected by {effect_name}."
            else:
                change_narrative = f"System Error: Invalid status effect name '{value}'."


        elif attribute == "location":
            # Developer-only direct location change to support testing visit/explore objectives.
            try:
                # Check Developer Mode via QSettings (GUI)
                from PySide6.QtCore import QSettings
                q = QSettings("RPGGame", "Settings")
                dev_enabled = bool(q.value("dev/enabled", False, type=bool) or q.value("dev/quest_verbose", False, type=bool))
            except Exception:
                dev_enabled = False

            location_id = str(value) if value is not None else ""

            if not dev_enabled:
                # Attempt to get an explanation from the RuleChecker; if none, fall back to a simple message.
                explanation = None
                try:
                    if hasattr(engine, '_rule_checker') and engine._rule_checker is not None:
                        from core.agents.base_agent import AgentContext
                        from core.interaction.context_builder import ContextBuilder
                        from core.interaction.enums import InteractionMode
                        context_dict = ContextBuilder().build_context(game_state, InteractionMode.NARRATIVE, actor_id=effective_actor_id)
                        validation_input = f"STATE_CHANGE location -> {location_id} (request denied in normal play)"
                        agent_ctx = AgentContext(
                            game_state=context_dict,
                            player_state=context_dict.get('player', {}),
                            world_state={
                                'location': context_dict.get('location'),
                                'time_of_day': context_dict.get('time_of_day'),
                                'environment': context_dict.get('environment')
                            },
                            player_input=validation_input,
                            conversation_history=game_state.conversation_history if hasattr(game_state, 'conversation_history') else [],
                            relevant_memories=[],
                            additional_context=context_dict
                        )
                        is_valid, reason = engine._rule_checker.validate_action(agent_ctx)
                        if not is_valid and reason:
                            explanation = reason
                except Exception:
                    pass
                if not explanation:
                    explanation = "developer-only teleportation is disabled in normal play"
                return f"This action is not permitted - {explanation}."

            # Developer mode enabled: apply direct location change and record visit event.
            try:
                game_state.player.current_location = location_id
                if hasattr(game_state, 'world'):
                    game_state.world.current_location = location_id
                try:
                    from core.game_flow.event_log import record_location_visited
                    record_location_visited(game_state, location_id=location_id)
                except Exception:
                    pass
                change_applied = True
                change_narrative = f"Location set to {location_id} (dev)."
            except Exception as e:
                change_narrative = f"System Error: Failed to change location to '{location_id}' ({e})."

        # Add Social Effect / Remove Social Effect (These might need specific logic if not handled by StatsManager)
        # elif attribute == "add_social_effect":
        #      # TODO: Implement social effect handling, potentially on NPC state or a dedicated system
        #      change_narrative = f"Applying social effect '{value}' to {participant_name} (Not fully implemented)."
        #      logger.warning(f"Social effect application for '{value}' on {target_entity_id} not fully implemented.")

        # elif attribute == "remove_social_effect":
        #      # TODO: Implement social effect removal
        #      change_narrative = f"Removing social effect '{value}' from {participant_name} (Not fully implemented)."
        #      logger.warning(f"Social effect removal for '{value}' on {target_entity_id} not fully implemented.")

        # else:
        #     # Fallback for unhandled attributes
        #     logger.warning(f"Unhandled StateChangeRequest attribute: {attribute} for target {participant_name}")
        #     change_narrative = f"State change requested for {target_entity_id}.{attribute} (Unhandled)."

        # Output the narrative result of the state change
        if change_narrative:
            engine._output("system", change_narrative)
        return ""

    except ValueError as e:
         logger.error(f"Invalid value or target in StateChangeRequest: {request} ({e})")
         return f"System Error: Invalid state change request ({e})."
    except AttributeError as e:
        logger.error(f"Missing attribute processing StateChangeRequest {request}: {e}", exc_info=True)
        return f"System Error: Cannot modify {attribute} for {target_combat_name} ({e})."
    except Exception as e:
        logger.error(f"Error applying state change {request}: {e}", exc_info=True)
        return f"Error applying state change for {target_combat_name}.{attribute}."
```

### File: core\interaction\context_builder.py

```python
from typing import Any, Dict, List, Optional, TYPE_CHECKING
from .enums import EnvironmentalTag, InteractionMode # Import the new enum and InteractionMode

# Placeholder for actual GameState type - replace with real import
if TYPE_CHECKING:
    from core.base.state.game_state import GameState # Corrected GameState import path
    # Add imports for other managers/states if needed, e.g.:
    # from core.player import PlayerState
    # from core.world import WorldState
    # from core.inventory import InventoryManager
    # from core.combat import CombatManager
    # from core.event import EventLog # Assu Katarzyna was ming an event log system

class ContextBuilder:
    """
    Gathers and structures relevant game state information to provide context
    for LLM agents based on the current interaction mode.
    """

    def build_context(self, game_state: 'GameState', mode: InteractionMode, actor_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Builds a context dictionary based on the game state and interaction mode.

        Args:
            game_state: The current state of the game.
            mode: The current interaction mode.
            actor_id: Optional ID of the entity whose perspective the context is for (e.g., player or NPC).

        Returns:
            A dictionary containing structured context information suitable for LLM consumption.
        """
        if not isinstance(mode, InteractionMode):
            raise TypeError(f"Expected InteractionMode, got {type(mode)}")

        common_context = self._get_common_context(game_state)
        mode_specific_context = {}

        if mode == InteractionMode.COMBAT:
            mode_specific_context = self._get_combat_context(game_state)
        elif mode == InteractionMode.SOCIAL_CONFLICT:
            # Assuming social conflict shares similarities with combat for participants
            mode_specific_context = self._get_social_conflict_context(game_state)
        elif mode == InteractionMode.TRADE:
            mode_specific_context = self._get_trade_context(game_state)
        elif mode == InteractionMode.NARRATIVE:
            mode_specific_context = self._get_narrative_context(game_state)
        else:
            # Fallback or error for unsupported modes
            print(f"Warning: Context building not fully implemented for mode: {mode.value}")
            # Or raise NotImplementedError("Context building not implemented for this mode")

        # --- Add Environmental Tags ---
        environment_tags = []
        world_state = getattr(game_state, 'world', None)
        if world_state:
            location = getattr(world_state, 'current_location', None)
            if location:
                # Assume location has an 'environmental_tags' attribute
                # containing EnvironmentalTag enums or strings
                raw_tags = getattr(location, 'environmental_tags', [])
                environment_tags = [tag.name if isinstance(tag, EnvironmentalTag) else str(tag) for tag in raw_tags]
        # --- End Environmental Tags ---


        # Merge common and mode-specific contexts
        # Mode-specific context can override common context keys if necessary
        full_context = {
            'mode': mode.value,
            **common_context,
            **mode_specific_context,
            'environment': environment_tags # Add the environmental tags
        }

        return full_context

    def _get_common_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context common to all interaction modes."""
        # --- Access game state components ---
        player_state = game_state.player
        world_state = game_state.world
        
        # For proper stat access, try to get the stats manager
        from core.stats.stats_manager import get_stats_manager
        stats_manager = get_stats_manager()
        # --- End access ---

        context = {}

        # Player Info
        if player_state:
            player_info = {
                'name': getattr(player_state, 'name', 'Player'),
                'id': getattr(player_state, 'id', getattr(player_state, 'stats_manager_id', 'player_id')),
                'stats': {}
            }
            
            # Try to get stats from stats manager
            try:
                player_info['stats'] = {
                    'hp': stats_manager.get_stat_value("HEALTH"),
                    'max_hp': stats_manager.get_stat_value("MAX_HEALTH"),
                    'resolve': stats_manager.get_stat_value("RESOLVE"),
                    'max_resolve': stats_manager.get_stat_value("MAX_RESOLVE"),
                    'strength': stats_manager.get_stat_value("STRENGTH"),
                    'dexterity': stats_manager.get_stat_value("DEXTERITY"),
                    'constitution': stats_manager.get_stat_value("CONSTITUTION"),
                    'intelligence': stats_manager.get_stat_value("INTELLIGENCE"),
                    'wisdom': stats_manager.get_stat_value("WISDOM"),
                    'charisma': stats_manager.get_stat_value("CHARISMA")
                }
            except Exception as e:
                # Fallback to direct attribute access if stats manager doesn't work
                player_info['stats'] = {
                    'hp': getattr(player_state, 'current_hp', None),
                    'max_hp': getattr(player_state, 'max_hp', None),
                    'resolve': getattr(player_state, 'current_resolve', 0.0),
                    'max_resolve': getattr(player_state, 'max_resolve', None)
                }
            
            # Get player status effects
            status_effects = []
            if hasattr(player_state, 'status_effects'):
                # Similar pattern to how we handled combat entities
                if isinstance(player_state.status_effects, dict):
                    status_effects = [{'name': k, 'duration': v} for k, v in player_state.status_effects.items()]
                elif hasattr(player_state, 'get_active_status_effects'):
                    status_effects = player_state.get_active_status_effects()
                elif isinstance(player_state.status_effects, (list, set)):
                    status_effects = list(player_state.status_effects)
            player_info['status_effects'] = status_effects
            
            context['player'] = player_info

        # Inventory Info (Relevant Items)
        inventory_manager = getattr(player_state, 'inventory_manager', None)
        if inventory_manager:
            equipped = getattr(inventory_manager, 'get_equipped_items', lambda: [])() # Placeholder
            quest_items = getattr(inventory_manager, 'get_quest_items', lambda: [])() # Placeholder
            context['inventory'] = {
                'equipped': [item.name for item in equipped], # Assuming items have a 'name' attribute
                'quest_items': [item.name for item in quest_items],
            }

        # World/Environment Info
        if world_state:
            location = getattr(world_state, 'current_location', None) # Placeholder
            if location:
                context['location'] = {
                    'name': getattr(location, 'name', 'Unknown Area'), # Placeholder
                    'description': getattr(location, 'description', ''), # Placeholder
                    'tags': getattr(location, 'tags', []), # Placeholder (e.g., ['forest', 'dark', 'ruins'])
                }
            # Use enhanced time description instead of clock time
            context['time_of_day'] = world_state.time_of_day if hasattr(world_state, 'time_of_day') else 'Unknown'

        # Recent Events
        event_log = getattr(world_state, 'event_log', None) # Placeholder
        if event_log:
            # Get the last N significant events (adjust N as needed)
            recent_events = getattr(event_log, 'get_recent_events', lambda limit: [])(limit=5) # Placeholder
            context['recent_events'] = [str(event) for event in recent_events] # Assuming events have __str__

        return context

    def _get_combat_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to combat mode."""
        # --- Access game state components directly ---
        combat_manager = game_state.combat_manager
        world_state = game_state.world
        # --- End Access ---

        context = {}

        if combat_manager:
            participants_data = []
            # Try to get combat entities directly from the combat manager
            entities = getattr(combat_manager, 'entities', {})
            
            # Current entity info
            current_entity_id = getattr(combat_manager, 'get_current_entity_id', lambda: None)()
            current_entity = entities.get(current_entity_id) if current_entity_id else None
            
            # Find player entity
            player_entity = None
            player_id = None
            for entity_id, entity in entities.items():
                if hasattr(entity, 'entity_type') and hasattr(entity.entity_type, 'name') and entity.entity_type.name == 'PLAYER':
                    player_entity = entity
                    player_id = entity_id
                    break
            
            # Add entities as participants
            for entity_id, entity in entities.items():
                if not hasattr(entity, 'name'): 
                    continue  # Skip entities with missing data
                
                # Get status effects formatted safely
                status_effects = []
                if hasattr(entity, 'status_effects'):
                    if isinstance(entity.status_effects, dict):
                        # New method using dict of status effects
                        status_effects = [{'name': effect_name, 'duration': duration} 
                                        for effect_name, duration in entity.status_effects.items()]
                    elif isinstance(entity.status_effects, (list, set)):
                        # Old method using list/set of effect names
                        status_effects = [{'name': effect} for effect in entity.status_effects]
                
                # Format entity data
                entity_data = {
                    'id': entity_id,
                    'name': entity.name,
                    'hp': getattr(entity, 'current_hp', 0),
                    'max_hp': getattr(entity, 'max_hp', 0),
                    'mp': getattr(entity, 'current_mp', 0) if hasattr(entity, 'current_mp') else 0,
                    'max_mp': getattr(entity, 'max_mp', 0) if hasattr(entity, 'max_mp') else 0,
                    'status_effects': status_effects,
                    'entity_type': getattr(entity.entity_type, 'name', 'UNKNOWN') if hasattr(entity, 'entity_type') else 'UNKNOWN'
                }
                
                # Include combat stats if available
                if hasattr(entity, 'stats') and isinstance(entity.stats, dict):
                    # Extract key combat stats
                    combat_stats = {
                        'strength': entity.stats.get('strength', 0),
                        'dexterity': entity.stats.get('dexterity', 0),
                        'constitution': entity.stats.get('constitution', 0),
                        'intelligence': entity.stats.get('intelligence', 0), 
                        'wisdom': entity.stats.get('wisdom', 0),
                        'charisma': entity.stats.get('charisma', 0),
                        'attack': entity.stats.get('attack', 0),
                        'defense': entity.stats.get('defense', 0),
                        'initiative': entity.stats.get('initiative', 0),
                    }
                    entity_data['stats'] = combat_stats
                
                participants_data.append(entity_data)
                
            # Store participants
            context['participants'] = participants_data
            
            # Build combat-specific context
            combat_context = {
                'turn_order': combat_manager.turn_order,
                'current_turn': current_entity_id,
                'round': combat_manager.round_number,
                'current_entity': None,
                'player': None
            }
            
            # Add current entity info
            if current_entity:
                combat_context['current_entity'] = {
                    'id': current_entity_id,
                    'name': current_entity.name,
                    'hp': getattr(current_entity, 'current_hp', 0),
                    'max_hp': getattr(current_entity, 'max_hp', 0)
                }
                
            # Add player entity info
            if player_entity:
                combat_context['player'] = {
                    'id': player_id,
                    'name': player_entity.name,
                    'hp': getattr(player_entity, 'current_hp', 0),
                    'max_hp': getattr(player_entity, 'max_hp', 0)
                }
                
            context['combat_context'] = combat_context

        # Environment details relevant to combat
        if world_state:
            location = getattr(world_state, 'current_location', None)
            if location:
                 # Example: Filter tags or get specific combat-relevant properties
                interactables = getattr(location, 'get_interactables', lambda: [])() # Placeholder
                context['environment_interactables'] = [str(i) for i in interactables] # Placeholder

        return context

    def _get_social_conflict_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to social conflict mode."""
        context = {}
        participants_data = []
        # Access current_combatants directly from game_state
        # Need to fetch actual participant objects based on IDs
        participant_ids = game_state.current_combatants
        world = game_state.world # Assume world has a way to get characters by ID
        participants = [getattr(world, 'get_character', lambda char_id: None)(pid) for pid in participant_ids]
        participants = [p for p in participants if p is not None] # Filter out not found participants

        # Define key social elements to fetch
        social_stats_keys = ['Charisma', 'Willpower', 'Insight']
        social_skills_keys = ['Persuasion', 'Intimidation', 'Deception', 'Insight'] # Assuming Insight skill exists too

        for p in participants:
            # Access stats manager, assuming it exists on participant objects
            stats_manager = getattr(p, 'stats_manager', None)

            social_stats = {}
            social_skills = {}
            if stats_manager:
                for stat in social_stats_keys:
                    social_stats[stat] = getattr(stats_manager, 'get_stat_value', lambda k, d=None: d)(stat, None)
                for skill in social_skills_keys:
                    social_skills[skill] = getattr(stats_manager, 'get_skill_value', lambda k, d=None: d)(skill, None)

            # Get active *social* effects specifically
            active_effects = getattr(p, 'active_social_effects', [])
            # Ensure effects are serializable (e.g., get their names or dict representation)
            serializable_effects = []
            for effect in active_effects:
                if hasattr(effect, 'to_dict'):
                    serializable_effects.append(effect.to_dict())
                elif hasattr(effect, 'name'):
                     serializable_effects.append(effect.name)
                else:
                     serializable_effects.append(str(effect))


            participants_data.append({
                'id': getattr(p, 'id', 'unknown_id'),
                'name': getattr(p, 'name', 'Unknown Participant'),
                'resolve': getattr(p, 'current_resolve', None),
                'max_resolve': getattr(p, 'max_resolve', None),
                'social_stats': social_stats,
                'social_skills': social_skills,
                'active_social_effects': serializable_effects,
                # 'disposition': getattr(p, 'disposition_towards_player', 'neutral'), # Optional/Future
            })

        context['participants'] = participants_data

        # Recent social events might be implicitly covered by 'recent_events' in common context
        # If more specific social event tracking exists, add it here.

        return context

    def _get_trade_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to trade mode."""
        context = {}
        # Assume inventory manager is part of player state or accessible differently
        player = game_state.player
        inventory_manager = getattr(player, 'inventory_manager', None) # Example: Access via player
        world = game_state.world
        partner_id = game_state.current_trade_partner_id

        if not inventory_manager or not world or not player:
            # Log warning or handle missing components
            return context # Cannot build full trade context

        # --- Player Trade Info ---
        player_currency = 0
        player_trade_items = []
        if player and hasattr(player, 'id'): # Check if player object and id exist
            player_currency = getattr(inventory_manager, 'get_currency', lambda owner_id: 0)(player.id)
            player_inv = getattr(inventory_manager, 'get_inventory', lambda owner_id: [])(player.id)
            player_trade_items = [
                {'name': item.name, 'value': getattr(item, 'base_value', 0), 'id': getattr(item, 'id', None)} # Assuming items have name, base_value, id
                for item in player_inv if getattr(item, 'can_be_traded', True) # Filter for tradable items
            ]

        context['player_trade_info'] = {
            'currency': player_currency,
            'inventory': player_trade_items
        }

        # --- Trade Partner Info ---
        if partner_id:
            partner = getattr(world, 'get_character', lambda char_id: None)(partner_id) # Fetch partner object
            if partner:
                partner_currency = getattr(inventory_manager, 'get_currency', lambda owner_id: 0)(partner.id) # Get partner currency
                partner_inv = getattr(inventory_manager, 'get_inventory', lambda owner_id: [])(partner.id) # Get partner inventory
                partner_trade_items = [
                    {'name': item.name, 'value': getattr(item, 'base_value', 0), 'id': getattr(item, 'id', None)}
                    for item in partner_inv if getattr(item, 'can_be_traded', True)
                ]

                context['trade_partner'] = {
                    'id': partner_id,
                    'name': getattr(partner, 'name', 'Unknown Merchant'),
                    'currency': partner_currency, # Include partner currency
                    'inventory': partner_trade_items,
                    # Add disposition or other relevant partner info if available
                    # 'disposition': getattr(partner, 'disposition_towards_player', 'neutral'),
                }
            else:
                # Log warning: Partner ID set but character not found
                context['trade_partner'] = {'id': partner_id, 'error': 'Character not found'}
        else:
             context['trade_partner'] = None # No active trade partner

        return context

    def _get_narrative_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to narrative mode."""
        # --- Access game state components directly ---
        # Assuming quest_manager and dialogue_manager are part of world or player state
        world_state = game_state.world
        player_state = game_state.player
        quest_manager = getattr(player_state, 'quest_manager', None) # Example access via player
        dialogue_manager = getattr(world_state, 'dialogue_manager', None) # Example access via world
        # --- End Access ---

        context = {}

        # Active Quests
        if quest_manager:
            active_quests = getattr(quest_manager, 'get_active_quests', lambda: [])() # Placeholder
            context['active_quests'] = [
                {'name': q.name, 'objective': getattr(q, 'current_objective', '')} # Assuming quests have name/objective
                for q in active_quests
            ]

        # Recent Dialogue
        if dialogue_manager:
            recent_lines = getattr(dialogue_manager, 'get_recent_dialogue', lambda limit: [])(limit=5) # Placeholder
            context['recent_dialogue'] = [str(line) for line in recent_lines] # Assuming lines have __str__

        # Known NPCs/Locations nearby (if available)
        if world_state:
            location = getattr(world_state, 'current_location', None)
            if location:
                nearby_npcs = getattr(location, 'get_nearby_npcs', lambda: [])() # Placeholder
                nearby_locations = getattr(location, 'get_nearby_locations', lambda: [])() # Placeholder
                context['nearby_npcs'] = [npc.name for npc in nearby_npcs] # Assuming NPCs have name
                context['nearby_locations'] = [loc.name for loc in nearby_locations] # Assuming locations have name

        return context

# Example Usage (Conceptual - requires actual GameState and managers)
if __name__ == '__main__':
    # This is conceptual and won't run without actual game state implementation
    class MockGameState:
        # Add mock attributes/methods matching placeholders used above
        player = type('obj', (object,), {'name': 'MockPlayer', 'current_hp': 90, 'max_hp': 100, 'current_resolve': 50, 'max_resolve': 50, 'get_active_status_effects': lambda: ['focused']})()
        inventory_manager = type('obj', (object,), {
            'get_equipped_items': lambda: [type('obj', (object,), {'name': 'Iron Sword'})()],
            'get_quest_items': lambda: [type('obj', (object,), {'name': 'Mystic Key'})()],
            'get_currency': lambda: 150
        })()
        world = type('obj', (object,), {
            'current_location': type('obj', (object,), {'name': 'Whispering Woods', 'description': 'Ancient trees loom overhead.', 'tags': ['forest', 'overgrown'], 'get_interactables': lambda: ['old_shrine', 'fallen_log']})(),
            'time_of_day': 'afternoon'
        })()
        event_log = type('obj', (object,), {'get_recent_events': lambda limit: ['Player entered Whispering Woods.', 'A twig snapped nearby.']})()
        combat_manager = type('obj', (object,), {
            'get_participants': lambda: [
                type('obj', (object,), {'id': 'wolf_1', 'name': 'Dire Wolf', 'current_hp': 40, 'max_hp': 40, 'get_active_status_effects': lambda: [], 'position': 'close', 'is_player': False})(),
                type('obj', (object,), {'id': 'wolf_2', 'name': 'Alpha Wolf', 'current_hp': 60, 'max_hp': 60, 'get_active_status_effects': lambda: ['enraged'], 'position': 'medium', 'is_player': False})()
            ]
        })()
        # Add mock managers for other modes as needed

    mock_game_state = MockGameState()
    builder = ContextBuilder()

    print("--- Combat Context ---")
    combat_context = builder.build_context(mock_game_state, InteractionMode.COMBAT)
    import json
    print(json.dumps(combat_context, indent=2))

    print("\n--- Narrative Context (Minimal Mock) ---")
    narrative_context = builder.build_context(mock_game_state, InteractionMode.NARRATIVE)
    print(json.dumps(narrative_context, indent=2))

    # Add calls for other modes (TRADE, SOCIAL_CONFLICT) if mocks are implemented
```

### File: core\interaction\enums.py

```python
from enum import Enum, auto

class InteractionMode(Enum):
    """
    Represents the different modes of interaction the player can be in.
    """
    NARRATIVE = auto()        # Default mode, story progression, exploration
    COMBAT = auto()           # Turn-based or real-time combat encounters
    SOCIAL_CONFLICT = auto()  # Debates, negotiations, persuasion challenges
    TRADE = auto()            # Exchanging goods or services with NPCs


class EnvironmentalTag(Enum):
    """
    Represents descriptive tags for environmental features in a scene.
    """
    LOW_COVER = auto()
    HIGH_COVER = auto()
    FLAMMABLE_OBJECT = auto()
    UNSTABLE_GROUND = auto()
    THROWABLE_OBJECT = auto()
    DARK = auto()
    BRIGHT_LIGHT = auto()
    OBSTACLE_SMALL = auto()
    OBSTACLE_LARGE = auto()
    INTERACTIVE_LEVER = auto() # Added an example interactive object
    WATER_SOURCE = auto()
    DIFFICULT_TERRAIN = auto()

```

### File: core\interaction\social_effects.py

```python
"""
Defines status effects specific to social interactions.
"""

from enum import Enum, auto
from dataclasses import dataclass
from typing import Any, Dict, Optional

@dataclass
class StatusEffectData:
    """Holds data for an active status effect."""
    effect_type: Enum  # Could be SocialStatusEffect or CombatStatusEffect etc.
    duration: Optional[int] = None  # Turns or time units, None for permanent
    intensity: Optional[float] = None # Magnitude of the effect (e.g., penalty amount)
    source: Optional[str] = None # Origin of the effect (e.g., ability name, character ID)

    def __str__(self) -> str:
        details = []
        if self.duration is not None:
            details.append(f"duration={self.duration}")
        if self.intensity is not None:
            details.append(f"intensity={self.intensity}")
        if self.source:
            details.append(f"source='{self.source}'")
        details_str = f" ({', '.join(details)})" if details else ""
        return f"{self.effect_type.name}{details_str}"

    def to_dict(self) -> Dict[str, Any]:
        """Convert StatusEffectData to a dictionary for serialization."""
        return {
            "effect_type_name": self.effect_type.name, # Store enum name
            "duration": self.duration,
            "intensity": self.intensity,
            "source": self.source,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StatusEffectData':
        """Create a StatusEffectData from a dictionary."""
        effect_type_name = data.get("effect_type_name")
        effect_type = None
        if effect_type_name:
            try:
                # Assuming SocialStatusEffect for now, might need adjustment if other types exist
                effect_type = SocialStatusEffect[effect_type_name]
            except KeyError:
                # Handle cases where the effect type name is invalid or from a different enum
                print(f"Warning: Unknown status effect type '{effect_type_name}' found in data.") # Or use logger

        return cls(
            effect_type=effect_type, # Store the actual enum member or None
            duration=data.get("duration"),
            intensity=data.get("intensity"),
            source=data.get("source"),
        )


class SocialStatusEffect(Enum):
    """Status effects resulting from social interactions."""
    # Positive/Neutral
    CHARMED = auto()        # Highly positive disposition, susceptible to requests.
    CONVINCED = auto()      # Believes a specific argument or piece of information.
    TRUSTING = auto()       # Generally believes what the source says.
    FRIENDLY = auto()       # Positive disposition towards the source.

    # Negative
    INTIMIDATED = auto()    # Fearful, less likely to oppose, may comply reluctantly.
    ANGERED = auto()        # Hostile disposition, likely to refuse or argue.
    SUSPICIOUS = auto()     # Distrustful, likely to question motives or statements.
    UNFRIENDLY = auto()     # Negative disposition towards the source.
    DECEIVED = auto()       # Believes a falsehood presented by the source.

    # Could add more nuanced effects like:
    # INSPIRED, DEMORALIZED, CONFUSED, OBLIGATED, GRATEFUL, RESENTFUL

    def __str__(self) -> str:
        return self.name
```

### File: core\interaction\structured_requests.py

```python
"""
Defines the standardized structures for requests generated by LLM agents.

These structures are intended to be parsed by the core game loop and validated
by the RuleCheckerAgent before being executed.
"""

from typing import TypedDict, Optional, Union, List, Dict, Any

# --- Skill Check Request ---

class SkillCheckRequest(TypedDict):
    """
    Represents a request for a skill check to be performed.
    """
    action: str  # Always 'request_skill_check'
    actor_id: str # ID of the entity performing the check (e.g., 'player')
    skill_name: str # The specific skill being used (e.g., 'lockpicking', 'persuasion')
    stat_name: Optional[str] # Optional: Base stat if different from skill's default (e.g., using Strength for an Athletics check)
    target_actor_id: Optional[str] # Optional: ID of the entity being targeted by the skill check
    difficulty_class: Optional[int] # Optional: A specific DC set by the narrative/situation
    # Optional: Modifiers specific to this check instance (e.g., situational bonuses/penalties)
    # Example: {'advantage': 1, 'circumstance_bonus': 2, 'penalty_reason': "Distracted"}
    modifiers: Optional[Dict[str, Any]]
    # Optional: Contextual information about why the check is being made
    context: Optional[str]


# --- State Change Request ---

class StateChangeRequest(TypedDict):
    """
    Represents a request to modify the game state programmatically.
    """
    action: str # Always 'request_state_change'
    target_id: str # ID of the entity or object whose state is changing (e.g., 'player', 'goblin_1', 'door_A')
    attribute: str # The specific attribute to change (e.g., 'hp', 'status_effects', 'position', 'inventory', 'relationship_stance')
    change_type: str # How to apply the change ('set', 'add', 'remove', 'append', 'update_dict')
    value: Any # The value to set, add, remove, etc.
    # Optional: Duration for temporary effects (e.g., in turns or seconds, depending on context)
    duration: Optional[int]
    # Optional: Contextual information about why the state change is occurring
    context: Optional[str]


# --- Agent Output Structure ---
# An agent's response might contain narrative and potentially multiple requests.

class AgentOutputRequired(TypedDict):
    """
    Required fields for agent outputs.
    """
    narrative: str  # The descriptive text generated by the agent.
    requests: List[Union[SkillCheckRequest, StateChangeRequest]]  # List of structured requests. Can be empty.

class AgentOutput(AgentOutputRequired, total=False):
    """
    Standard output structure for LLM agents.
    Optional fields are declared with total=False to allow omission.
    """
    time_passage: str  # Compact duration like "30s", "1m", "2h", "1d".

```

### File: core\llm\__init__.py

```python
#!/usr/bin/env python3
"""
LLM module for provider management and completions.

This module provides classes for managing LLM providers, handling completions
from different LLM services (OpenAI, Anthropic, Google), and managing settings.
"""

from core.llm.provider_manager import ProviderManager, ProviderType, get_provider_manager
from core.llm.llm_manager import LLMManager, LLMResponse, LLMRole, get_llm_manager
from core.llm.settings_manager import SettingsManager, get_settings_manager

__all__ = [
    'ProviderManager',
    'ProviderType',
    'get_provider_manager',
    'LLMManager',
    'LLMResponse',
    'LLMRole',
    'get_llm_manager',
    'SettingsManager',
    'get_settings_manager'
]
```

### File: core\llm\llm_manager.py

```python
#!/usr/bin/env python3
"""
LLM manager for handling completions and interactions.

This module provides a LLMManager class that handles high-level LLM
interactions, including prompt formatting, completion retrieval,
and error handling.
"""

import time
import json
import asyncio
import datetime
from typing import Dict, List, Optional, Any, Union, Tuple, Callable
import logging
from enum import Enum

from core.utils.logging_config import get_logger
from core.base.config import get_config
from core.llm.provider_manager import ProviderManager, ProviderType, get_provider_manager

# Get the module logger
logger = get_logger("LLM")

class LLMRole(str, Enum):
    """Roles for LLM conversation."""
    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"
    FUNCTION = "function"

class LLMResponse:
    """
    Response from an LLM.
    
    This class represents a response from an LLM, including
    the content, token usage, and provider information.
    """
    
    def __init__(self, 
                 content: str,
                 provider_type: ProviderType,
                 model: str,
                 prompt_tokens: int = 0,
                 completion_tokens: int = 0,
                 total_tokens: int = 0,
                 cost: float = 0.0,
                 finish_reason: Optional[str] = None):
        """Initialize the LLM response."""
        self.content = content
        self.provider_type = provider_type
        self.model = model
        self.prompt_tokens = prompt_tokens
        self.completion_tokens = completion_tokens
        self.total_tokens = total_tokens or (prompt_tokens + completion_tokens)
        self.cost = cost
        self.finish_reason = finish_reason
        self.timestamp = datetime.datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "content": self.content,
            "provider_type": self.provider_type.name,
            "model": self.model,
            "prompt_tokens": self.prompt_tokens,
            "completion_tokens": self.completion_tokens,
            "total_tokens": self.total_tokens,
            "cost": self.cost,
            "finish_reason": self.finish_reason,
            "timestamp": self.timestamp
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LLMResponse':
        """Create an LLMResponse from a dictionary."""
        provider_type = ProviderType[data.get("provider_type", "OPENAI")]
        return cls(
            content=data.get("content", ""),
            provider_type=provider_type,
            model=data.get("model", "unknown"),
            prompt_tokens=data.get("prompt_tokens", 0),
            completion_tokens=data.get("completion_tokens", 0),
            total_tokens=data.get("total_tokens", 0),
            cost=data.get("cost", 0.0),
            finish_reason=data.get("finish_reason")
        )


class LLMManager:
    """
    Manager for LLM interactions.
    
    This class handles high-level LLM interactions, including
    prompt formatting, completion retrieval, and error handling.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(LLMManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the LLM manager."""
        if self._initialized:
            return
        
        logger.info("Initializing LLMManager")
        
        # Get configuration
        self._config = get_config()
        
        # Get provider manager
        self._provider_manager = get_provider_manager()
        
        # Load LLM settings
        self._llm_settings = self._load_llm_settings()
        
        # Previously: optionally run diagnostics on startup based on settings.
        # Now: diagnostics are initiated from the GUI/CLI on-demand. Startup should not test providers.
        self._run_diagnostics = self._llm_settings.get("run_diagnostics_on_start", False)
        logger.debug("Skipping LLM diagnostics on startup; will run on-demand from GUI/CLI if requested.")
        
        self._initialized = True
        logger.info("LLMManager initialized")
    
    def _load_llm_settings(self) -> Dict[str, Any]:
        """
        Load LLM settings from configuration.
        
        Returns:
            Dictionary of LLM settings.
        """
        # Default settings
        default_settings = {
            "default_provider_type": "OPENAI",
            "default_temperature": 0.7,
            "max_tokens": 1000,
            "timeout_seconds": 30,
            "retry_attempts": 3,
            "retry_delay_seconds": 2,
            "run_diagnostics_on_start": False,
            "log_prompts": True,
            "log_completions": True,
            "cost_tracking_enabled": True
        }
        
        # Get settings from config
        config_settings = self._config.get("llm", {})
        
        # Merge with default settings
        merged_settings = {**default_settings, **config_settings}
        
        return merged_settings
    
    def get_completion(self, 
                      messages: List[Dict[str, str]],
                      provider_type: Optional[ProviderType] = None,
                      model: Optional[str] = None,
                      temperature: Optional[float] = None,
                      max_tokens: Optional[int] = None,
                      timeout: Optional[int] = None,
                      retry_attempts: Optional[int] = None) -> Optional[LLMResponse]:
        """
        Get a completion from an LLM.
        
        Args:
            messages: List of message dictionaries (role, content).
            provider_type: The provider type to use. If None, uses the default.
            model: The model to use. If None, uses the provider's default.
            temperature: The temperature to use. If None, uses the default.
            max_tokens: The maximum number of tokens to generate. If None, uses the default.
            timeout: The timeout in seconds. If None, uses the default.
            retry_attempts: The number of retry attempts. If None, uses the default.
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Determine the provider type
        if provider_type is None:
            provider_type_str = self._llm_settings.get("default_provider_type", "OPENAI")
            try:
                provider_type = ProviderType[provider_type_str]
            except (KeyError, ValueError):
                provider_type = ProviderType.OPENAI
                logger.warning(f"Invalid default provider type: {provider_type_str}. Using OpenAI.")
        
        # Check if the provider is available
        if not self._provider_manager.is_provider_available(provider_type):
            # Try to find an available provider
            fallback_provider = self._provider_manager.get_default_provider()
            if fallback_provider is None:
                logger.error("No LLM providers available")
                return None
            
            logger.warning(f"Provider {provider_type.name} not available. Falling back to {fallback_provider.name}.")
            provider_type = fallback_provider
        
        # Get provider client and settings
        client = self._provider_manager.get_client(provider_type)
        provider_settings = self._provider_manager.get_provider_settings(provider_type)
        
        # Determine model
        if model is None:
            model = provider_settings.get("default_model")
        
        # Set parameters
        temperature = temperature if temperature is not None else self._llm_settings.get("default_temperature", 0.7)
        max_tokens = max_tokens if max_tokens is not None else self._llm_settings.get("max_tokens", 1000)
        timeout = timeout if timeout is not None else self._llm_settings.get("timeout_seconds", 30)
        retry_attempts = retry_attempts if retry_attempts is not None else self._llm_settings.get("retry_attempts", 3)
        
        # Log the request
        if self._llm_settings.get("log_prompts", True):
            logger.debug(f"LLM Request: provider={provider_type.name}, model={model}, temperature={temperature}")
            for msg in messages:
                logger.debug(f"  {msg.get('role', 'unknown')}: {msg.get('content', '')[:100]}...")
        
        # Make the request with retries
        for attempt in range(retry_attempts + 1):
            try:
                if provider_type == ProviderType.OPENAI or provider_type == ProviderType.OPENROUTER:
                    return self._get_openai_completion(
                        client=client,
                        messages=messages,
                        model=model,
                        temperature=temperature,
                        max_tokens=max_tokens,
                        timeout=timeout,
                        provider_type=provider_type
                    )
                
                elif provider_type == ProviderType.ANTHROPIC:
                    return self._get_anthropic_completion(
                        client=client,
                        messages=messages,
                        model=model,
                        temperature=temperature,
                        max_tokens=max_tokens,
                        timeout=timeout,
                        provider_type=provider_type
                    )
                
                elif provider_type == ProviderType.GOOGLE:
                    return self._get_google_completion(
                        client=client,
                        messages=messages,
                        model=model,
                        temperature=temperature,
                        max_tokens=max_tokens,
                        timeout=timeout,
                        provider_type=provider_type
                    )
                
                else:
                    logger.error(f"Unsupported provider type: {provider_type.name}")
                    return None
                
            except Exception as e:
                if attempt < retry_attempts:
                    retry_delay = self._llm_settings.get("retry_delay_seconds", 2)
                    logger.warning(f"LLM request failed (attempt {attempt+1}/{retry_attempts+1}): {e}. Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    logger.error(f"LLM request failed after {retry_attempts+1} attempts: {e}")
                    return None
    
    def _get_openai_completion(self,
                              client: Any,
                              messages: List[Dict[str, str]],
                              model: str,
                              temperature: float,
                              max_tokens: int,
                              timeout: int,
                              provider_type: ProviderType) -> Optional[LLMResponse]:
        """
        Get a completion from OpenAI.
        
        Args:
            client: The OpenAI client.
            messages: List of message dictionaries.
            model: The model to use.
            temperature: The temperature to use.
            max_tokens: The maximum number of tokens to generate.
            timeout: The timeout in seconds.
            provider_type: The provider type (OpenAI or OpenRouter).
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Create the request parameters
        request_params = {
            "model": model,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens,
            "timeout": timeout
        }
        
        # Make the request
        response = client.chat.completions.create(**request_params)
        
        # Parse the response
        try:
            # Check if response is None or doesn't have expected structure
            if not response or not hasattr(response, 'choices') or not response.choices:
                logger.error(f"Invalid response format from {provider_type.name}: {response}")
                return None

            # Get message content
            content = response.choices[0].message.content
            
            # Get token usage (with fallbacks for OpenRouter which may not provide usage)
            if hasattr(response, 'usage') and response.usage:
                prompt_tokens = getattr(response.usage, 'prompt_tokens', 0)
                completion_tokens = getattr(response.usage, 'completion_tokens', 0)
                total_tokens = getattr(response.usage, 'total_tokens', 0) or (prompt_tokens + completion_tokens)
            else:
                # Estimate tokens if usage not provided
                logger.warning(f"Token usage not provided by {provider_type.name}, estimating")
                prompt_tokens = sum(len(msg.get("content", "")) for msg in messages) // 4  # Rough estimate
                completion_tokens = len(content) // 4  # Rough estimate
                total_tokens = prompt_tokens + completion_tokens
            
            # Get finish reason (with fallback)
            finish_reason = getattr(response.choices[0], 'finish_reason', 'unknown')
            
            # Log completion
            if self._llm_settings.get("log_completions", True):
                logger.debug(f"LLM Completion: provider={provider_type.name}, model={model}, tokens={total_tokens}")
                logger.debug(f"  content: {content[:100]}...")
            
            # Calculate cost (this is an approximation)
            cost = self._calculate_cost(model, prompt_tokens, completion_tokens, provider_type)
            
            return LLMResponse(
                content=content,
                provider_type=provider_type,
                model=model,
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                total_tokens=total_tokens,
                cost=cost,
                finish_reason=finish_reason
            )
            
        except Exception as e:
            logger.error(f"Error parsing OpenAI response: {e}")
            return None
    
    def _get_anthropic_completion(self,
                                 client: Any,
                                 messages: List[Dict[str, str]],
                                 model: str,
                                 temperature: float,
                                 max_tokens: int,
                                 timeout: int,
                                 provider_type: ProviderType) -> Optional[LLMResponse]:
        """
        Get a completion from Anthropic.
        
        Args:
            client: The Anthropic client.
            messages: List of message dictionaries.
            model: The model to use.
            temperature: The temperature to use.
            max_tokens: The maximum number of tokens to generate.
            timeout: The timeout in seconds.
            provider_type: The provider type.
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Convert messages to Anthropic format (human/assistant conversation)
        prompt = ""
        for msg in messages:
            role = msg.get("role", "user")
            content = msg.get("content", "")
            
            if role == "system":
                # Anthropic doesn't have system messages; add to the first user message
                continue
            elif role == "user":
                prompt += f"\n\nHuman: {content}"
            elif role == "assistant":
                prompt += f"\n\nAssistant: {content}"
        
        # Add final assistant prompt
        prompt += "\n\nAssistant:"
        
        # Create the request parameters
        request_params = {
            "prompt": prompt,
            "model": model,
            "temperature": temperature,
            "max_tokens_to_sample": max_tokens,
            "stop_sequences": ["\n\nHuman:"]
        }
        
        # Make the request
        response = client.completions.create(**request_params)
        
        # Parse the response
        try:
            content = response.completion
            
            # Anthropic doesn't provide token usage in the response
            # We can estimate based on content length
            prompt_tokens = len(prompt) // 4  # Rough estimate
            completion_tokens = len(content) // 4  # Rough estimate
            total_tokens = prompt_tokens + completion_tokens
            
            # Log completion
            if self._llm_settings.get("log_completions", True):
                logger.debug(f"LLM Completion: provider={provider_type.name}, model={model}, est_tokens={total_tokens}")
                logger.debug(f"  content: {content[:100]}...")
            
            # Calculate cost (this is an approximation)
            cost = self._calculate_cost(model, prompt_tokens, completion_tokens, provider_type)
            
            return LLMResponse(
                content=content,
                provider_type=provider_type,
                model=model,
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                total_tokens=total_tokens,
                cost=cost,
                finish_reason="stop"
            )
            
        except Exception as e:
            logger.error(f"Error parsing Anthropic response: {e}")
            return None
    
    def _get_google_completion(self,
                              client: Any,
                              messages: List[Dict[str, str]],
                              model: str,
                              temperature: float,
                              max_tokens: int,
                              timeout: int,
                              provider_type: ProviderType) -> Optional[LLMResponse]:
        """
        Get a completion from Google.
        
        Args:
            client: The Google client.
            messages: List of message dictionaries.
            model: The model to use.
            temperature: The temperature to use.
            max_tokens: The maximum number of tokens to generate.
            timeout: The timeout in seconds.
            provider_type: The provider type.
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Initialize Google model
        generation_config = {
            "temperature": temperature,
            "max_output_tokens": max_tokens,
        }
        
        # Handle potentially empty safety settings for newer models
        if "gemini-2.0" in model or "gemini-2.5" in model:
            # For Gemini 2.0 and 2.5 models, we need to set safety settings explicitly
            safety_settings = {
                # Add minimal safety settings to avoid causing issues
                "HARASSMENT": "block_none",
                "HATE": "block_none",
                "SEXUAL": "block_none",
                "DANGEROUS": "block_none"
            }
            google_model = client.GenerativeModel(
                model_name=model,
                generation_config=generation_config,
                safety_settings=safety_settings
            )
        else:
            # For older models, use default safety settings
            google_model = client.GenerativeModel(
                model_name=model,
                generation_config=generation_config
            )
        
        # Convert messages to Google format
        gemini_messages = []
        system_content = ""
        
        # Extract system messages first
        for msg in messages:
            if msg.get("role") == "system":
                system_content += msg.get("content", "") + "\n"
        
        # Add system content as a prefix to the first user message if any
        user_msg_found = False
        
        for msg in messages:
            role = msg.get("role", "user")
            content = msg.get("content", "")
            
            if role == "user":
                if not user_msg_found and system_content:
                    # Add system content to first user message
                    content = system_content + "\n\n" + content
                    system_content = ""
                    user_msg_found = True
                
                # Ensure content is not empty
                if not content.strip():
                    content = "Hello, please respond."
                    
                gemini_messages.append({"role": "user", "parts": [content]})
            elif role == "assistant":
                # Ensure content is not empty
                if not content.strip():
                    continue  # Skip empty assistant messages
                    
                gemini_messages.append({"role": "model", "parts": [content]})
        
        # Make sure we have at least one user message
        if not user_msg_found and system_content:
            gemini_messages.append({"role": "user", "parts": [system_content]})
        
        # Make sure we have at least one message
        if not gemini_messages:
            gemini_messages.append({"role": "user", "parts": ["Hello, please respond."]})
        
        # Generate a response
        # Debugging the exact message format sent
        logger.debug(f"Sending Gemini messages: {json.dumps(gemini_messages, indent=2)}")
        
        # Handle message formatting based on Gemini model
        try:
            if "gemini-2.0" in model:
                if len(gemini_messages) == 1:
                    # For single messages with newer Gemini models
                    content = gemini_messages[0]["parts"][0]
                    response = google_model.generate_content(content)
                else:
                    # For conversations with newer Gemini models
                    # Convert to Google's newer chat format
                    chat = []
                    for msg in gemini_messages:
                        if msg["role"] == "user":
                            chat.append({"role": "user", "parts": [{"text": msg["parts"][0]}]})
                        elif msg["role"] == "model":
                            chat.append({"role": "model", "parts": [{"text": msg["parts"][0]}]})
                    
                    response = google_model.generate_content(chat)
            else:
                # For older Gemini models
                response = google_model.generate_content(gemini_messages)
        except Exception as e:
            # Fallback to the simplest possible request
            logger.warning(f"Error with standard Gemini format: {e}. Trying fallback format...")
            
            # Create a simple prompt from the messages
            combined_prompt = ""
            for msg in messages:
                role = msg.get("role", "unknown")
                content = msg.get("content", "")
                if content:
                    combined_prompt += f"{role}: {content}\n\n"
            
            if not combined_prompt:
                combined_prompt = "Hello, please respond."
                
            response = google_model.generate_content(combined_prompt)
        
        # Parse the response
        try:
            content = response.text
            
            # Google doesn't provide token usage in the response
            # We can estimate based on content length
            prompt_tokens = sum(len(msg.get("content", "")) for msg in messages) // 4  # Rough estimate
            completion_tokens = len(content) // 4  # Rough estimate
            total_tokens = prompt_tokens + completion_tokens
            
            # Log completion
            if self._llm_settings.get("log_completions", True):
                logger.debug(f"LLM Completion: provider={provider_type.name}, model={model}, est_tokens={total_tokens}")
                logger.debug(f"  content: {content[:100]}...")
            
            # Calculate cost (this is an approximation)
            cost = self._calculate_cost(model, prompt_tokens, completion_tokens, provider_type)
            
            return LLMResponse(
                content=content,
                provider_type=provider_type,
                model=model,
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                total_tokens=total_tokens,
                cost=cost,
                finish_reason="stop"
            )
            
        except Exception as e:
            logger.error(f"Error parsing Google response: {e}")
            return None
    
    def _calculate_cost(self, 
                       model: str, 
                       prompt_tokens: int, 
                       completion_tokens: int,
                       provider_type: ProviderType) -> float:
        """
        Calculate the cost of a completion.
        
        Args:
            model: The model used.
            prompt_tokens: The number of prompt tokens.
            completion_tokens: The number of completion tokens.
            provider_type: The provider type.
        
        Returns:
            The cost in USD.
        """
        # Define pricing by provider and model
        # These are approximate and may need to be updated
        pricing = {
            ProviderType.OPENAI: {
                "gpt-4o-mini": {
                    "prompt": 0.0015,  # per 1000 tokens
                    "completion": 0.002  # per 1000 tokens
                },
                "gpt-4o": {
                    "prompt": 0.03,  # per 1000 tokens
                    "completion": 0.06  # per 1000 tokens
                }
            },
            ProviderType.ANTHROPIC: {
                "claude-3-7-sonnet-latest": {
                    "prompt": 0.01,  # per 1000 tokens
                    "completion": 0.03  # per 1000 tokens
                },
                "claude-3-5-haiku-latest": {
                    "prompt": 0.0015,  # per 1000 tokens
                    "completion": 0.0055  # per 1000 tokens
                }
            },
            ProviderType.GOOGLE: {
                "gemini-pro": {
                    "prompt": 0.0005,  # per 1000 tokens
                    "completion": 0.0015  # per 1000 tokens
                }
            },
            ProviderType.OPENROUTER: {
                # OpenRouter has variable pricing; using approximations
                "google/gemini-2.0-flash-lite-preview-02-05:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                },
                "nousresearch/deephermes-3-llama-3-8b-preview:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                },
                "google/gemini-2.0-pro-exp-02-05:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0 # per 1000 tokens
                },
                "mistralai/mistral-small-3.1-24b-instruct:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                },
                "mistralai/mistral-small-3.1-24b-instruct:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                }
            }
        }
        
        # Get pricing for the model
        provider_pricing = pricing.get(provider_type, {})
        model_pricing = provider_pricing.get(model, None)
        
        if model_pricing is None:
            # Use default pricing if the model is not found
            model_pricing = {"prompt": 0.001, "completion": 0.002}
        
        # Calculate cost
        prompt_cost = (prompt_tokens / 1000) * model_pricing["prompt"]
        completion_cost = (completion_tokens / 1000) * model_pricing["completion"]
        
        return prompt_cost + completion_cost
    
    def run_llm_diagnostics(self) -> Dict[str, Any]:
        """
        Run diagnostics on available LLM providers.
        
        Returns:
            Dictionary with diagnostic results.
        """
        results = {
            "timestamp": datetime.datetime.now().isoformat(),
            "providers": {}
        }
        
        # Check available providers
        available_providers = self._provider_manager.get_available_providers()
        
        if not available_providers:
            logger.warning("No LLM providers available")
            results["status"] = "error"
            results["error"] = "No LLM providers available"
            return results
        
        # Test each available provider
        for provider in available_providers:
            provider_name = provider.name
            
            logger.info(f"Testing LLM provider: {provider_name}")
            
            # Verify the client
            client_ok = self._provider_manager.verify_client(provider)
            
            if not client_ok:
                logger.warning(f"Provider {provider_name} client verification failed")
                results["providers"][provider_name] = {
                    "status": "error",
                    "error": "Client verification failed"
                }
                continue
            
            # Test a simple completion
            test_messages = [
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": "Hello, world! Please respond with 'Hello from the LLM!'"}
            ]
            
            try:
                response = self.get_completion(
                    messages=test_messages,
                    provider_type=provider,
                    temperature=0.0,  # Use deterministic output for testing
                    max_tokens=20,
                    timeout=30,
                    retry_attempts=1
                )
                
                if response:
                    logger.info(f"Provider {provider_name} test successful")
                    
                    results["providers"][provider_name] = {
                        "status": "success",
                        "model": response.model,
                        "response_content": response.content.strip(),
                        "tokens": {
                            "prompt": response.prompt_tokens,
                            "completion": response.completion_tokens,
                            "total": response.total_tokens
                        },
                        "cost": response.cost
                    }
                else:
                    logger.warning(f"Provider {provider_name} test failed: No response")
                    
                    results["providers"][provider_name] = {
                        "status": "error",
                        "error": "No response from LLM"
                    }
            
            except Exception as e:
                logger.error(f"Provider {provider_name} test error: {e}")
                
                results["providers"][provider_name] = {
                    "status": "error",
                    "error": str(e)
                }
        
        # Overall status
        success_count = sum(1 for p in results["providers"].values() if p.get("status") == "success")
        
        if success_count > 0:
            results["status"] = "success"
            results["message"] = f"{success_count}/{len(results['providers'])} providers operational"
        else:
            results["status"] = "error"
            results["message"] = "No operational providers found"
        
        # Log summary
        logger.info(f"LLM diagnostics complete: {results['message']}")
        
        return results


# Convenience function
def get_llm_manager() -> LLMManager:
    """Get the LLM manager instance."""
    return LLMManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the LLM manager
    manager = get_llm_manager()
    
    # Run diagnostics
    diagnostics = manager.run_llm_diagnostics()
    print(f"Diagnostics: {diagnostics['status']} - {diagnostics['message']}")
    
    # Test completion
    messages = [
        {"role": "system", "content": "You are a helpful assistant for an RPG game."},
        {"role": "user", "content": "Describe a small village."}
    ]
    
    response = manager.get_completion(messages)
    
    if response:
        print(f"Response from {response.provider_type.name} ({response.model}):")
        print(response.content)
        print(f"Tokens: {response.total_tokens} (${response.cost:.6f})")
    else:
        print("No response from LLM.")
```

### File: core\llm\provider_manager.py

```python
#!/usr/bin/env python3
"""
Provider manager for LLM interactions.

This module provides a ProviderManager class that handles initialization
and management of different LLM providers (OpenAI, Anthropic, Google).
"""

import os
import json
from typing import Dict, List, Optional, Any, Union
import logging
from enum import Enum, auto

from core.utils.logging_config import get_logger
from core.base.config import get_config

# Load environment variables from .env if present (applies to GUI and web server contexts)
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    # dotenv is optional; continue without failing if not available
    pass

# Import LLM provider libraries
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
except ImportError:
    ANTHROPIC_AVAILABLE = False

try:
    import google.generativeai as genai
    GOOGLE_AVAILABLE = True
except ImportError:
    GOOGLE_AVAILABLE = False

# Get the module logger
logger = get_logger("LLM")

class ProviderType(Enum):
    """Enum for different LLM providers."""
    OPENAI = auto()
    ANTHROPIC = auto()
    GOOGLE = auto()
    OPENROUTER = auto()

class ProviderManager:
    """
    Manager for LLM providers.
    
    This class handles initialization and management of different LLM providers,
    including API keys, client creation, and provider configuration.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(ProviderManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the provider manager."""
        if self._initialized:
            return
        
        logger.info("Initializing ProviderManager")
        
        # Get configuration
        self._config = get_config()
        
        # Load provider settings
        self._provider_settings = self._load_provider_settings()
        
        # Initialize clients dictionary
        self._clients = {}
        
        # Initialize provider availability
        self._provider_availability = {
            ProviderType.OPENAI: OPENAI_AVAILABLE,
            ProviderType.ANTHROPIC: ANTHROPIC_AVAILABLE,
            ProviderType.GOOGLE: GOOGLE_AVAILABLE,
            ProviderType.OPENROUTER: OPENAI_AVAILABLE,  # OpenRouter uses OpenAI's API
        }
        
        # Initialize the providers
        self._initialize_providers()
        
        self._initialized = True
        logger.info("ProviderManager initialized")
    
    def _load_provider_settings(self) -> Dict[str, Any]:
        """
        Load provider settings from configuration files, then override with environment variables.
        
        Returns:
            Dictionary of provider settings.
        """
        # Default settings
        default_settings = {
            "openai": {
                "api_key": "",
                "organization": "",
                "api_base": "https://api.openai.com/v1",
                "default_model": "gpt-4o-mini",
                "available_models": ["gpt-4o-mini"],
                "enabled": True
            },

            "google": {
                "api_key": "",
                "default_model": "gemini-2.0-flash",
                "enabled": True
            },
            "openrouter": {
                "api_key": "",
                "api_base": "https://openrouter.ai/api/v1",
                "default_model": "nousresearch/deephermes-3-llama-3-8b-preview:free",
                "available_models": [
                "google/gemini-2.0-flash-exp:free",
                "google/gemini-2.0-flash-lite-preview-02-05:free",
                "nousresearch/deephermes-3-llama-3-8b-preview:free",
                "google/gemini-2.0-pro-exp-02-05:free",
                "mistralai/mistral-small-3.1-24b-instruct:free"
                ],
                "enabled": True
            }
        }
        
        # Try to load provider settings from file
        providers_file = os.path.join("config", "llm", "providers.json")
        if os.path.exists(providers_file):
            try:
                with open(providers_file, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    
                    # Merge with default settings
                    for provider, settings in loaded_settings.items():
                        if provider in default_settings:
                            default_settings[provider].update(settings)
                        else:
                            default_settings[provider] = settings
                            
                logger.info(f"Loaded provider settings from {providers_file}")
            except Exception as e:
                logger.error(f"Error loading provider settings: {e}")
        else:
            logger.warning(f"Provider settings file not found: {providers_file}")
            
            # Create default provider settings file
            try:
                os.makedirs(os.path.dirname(providers_file), exist_ok=True)
                with open(providers_file, 'w', encoding='utf-8') as f:
                    json.dump(default_settings, f, indent=4)
                logger.info(f"Created default provider settings file: {providers_file}")
            except Exception as e:
                logger.error(f"Error creating default provider settings file: {e}")
        
        # Override with environment variables if present (prefers env over file)
        env_overrides: Dict[str, Dict[str, Optional[str]]] = {
            "openai": {
                "api_key": os.getenv("OPENAI_API_KEY"),
                "organization": os.getenv("OPENAI_ORG") or os.getenv("OPENAI_ORGANIZATION"),
                "api_base": os.getenv("OPENAI_API_BASE") or os.getenv("OPENAI_BASE_URL"),
            },
            "google": {
                "api_key": os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY"),
            },
            "openrouter": {
                "api_key": os.getenv("OPENROUTER_API_KEY"),
                "api_base": os.getenv("OPENROUTER_API_BASE"),
            },
            "anthropic": {
                "api_key": os.getenv("ANTHROPIC_API_KEY"),
            },
        }
        
        for provider, fields in env_overrides.items():
            if provider not in default_settings:
                default_settings[provider] = {}
            for key, value in fields.items():
                if value and isinstance(value, str) and value.strip():
                    default_settings[provider][key] = value.strip()
                    # Don't log secrets; only note which provider field came from env
                    logger.debug(f"Using environment value for {provider}.{key}")
        
        return default_settings
    
    def _initialize_providers(self) -> None:
        """Initialize LLM provider clients."""
        self._initialize_openai()
        self._initialize_anthropic()
        self._initialize_google()
        self._initialize_openrouter()
    
    def _initialize_openai(self) -> None:
        """Initialize OpenAI client."""
        if not self._provider_availability[ProviderType.OPENAI]:
            logger.warning("OpenAI library not available")
            return
        
        settings = self._provider_settings.get("openai", {})
        if not settings.get("enabled", True):
            logger.info("OpenAI provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("OpenAI API key not configured")
            return
        
        try:
            # Initialize the client
            client = openai.OpenAI(
                api_key=api_key,
                organization=settings.get("organization", ""),
                base_url=settings.get("api_base", "https://api.openai.com/v1")
            )
            
            # Store the client
            self._clients[ProviderType.OPENAI] = {
                "client": client,
                "settings": settings
            }
            
            logger.info("OpenAI client initialized")
        except Exception as e:
            logger.error(f"Error initializing OpenAI client: {e}")
    
    def _initialize_anthropic(self) -> None:
        """Initialize Anthropic client."""
        if not self._provider_availability[ProviderType.ANTHROPIC]:
            logger.warning("Anthropic library not available")
            return
        
        settings = self._provider_settings.get("anthropic", {})
        if not settings.get("enabled", True):
            logger.info("Anthropic provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("Anthropic API key not configured")
            return
        
        try:
            # Initialize the client
            client = anthropic.Anthropic(
                api_key=api_key
            )
            
            # Store the client
            self._clients[ProviderType.ANTHROPIC] = {
                "client": client,
                "settings": settings
            }
            
            logger.info("Anthropic client initialized")
        except Exception as e:
            logger.error(f"Error initializing Anthropic client: {e}")
    
    def _initialize_google(self) -> None:
        """Initialize Google client."""
        if not self._provider_availability[ProviderType.GOOGLE]:
            logger.warning("Google library not available")
            return
        
        settings = self._provider_settings.get("google", {})
        if not settings.get("enabled", True):
            logger.info("Google provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("Google API key not configured")
            return
        
        try:
            # Initialize the client
            genai.configure(api_key=api_key)
            
            # Store the client
            self._clients[ProviderType.GOOGLE] = {
                "client": genai,
                "settings": settings
            }
            
            logger.info("Google client initialized")
        except Exception as e:
            logger.error(f"Error initializing Google client: {e}")
    
    def _initialize_openrouter(self) -> None:
        """Initialize OpenRouter client."""
        if not self._provider_availability[ProviderType.OPENROUTER]:
            logger.warning("OpenRouter requires OpenAI library which is not available")
            return
        
        settings = self._provider_settings.get("openrouter", {})
        if not settings.get("enabled", True):
            logger.info("OpenRouter provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("OpenRouter API key not configured")
            return
        
        try:
            # Initialize the client
            client = openai.OpenAI(
                api_key=api_key,
                base_url=settings.get("api_base", "https://openrouter.ai/api/v1")
            )
            
            # Store the client
            self._clients[ProviderType.OPENROUTER] = {
                "client": client,
                "settings": settings
            }
            
            logger.info("OpenRouter client initialized")
        except Exception as e:
            logger.error(f"Error initializing OpenRouter client: {e}")
    
    def get_client(self, provider_type: ProviderType) -> Optional[Any]:
        """
        Get a provider client.
        
        Args:
            provider_type: The type of provider.
        
        Returns:
            The provider client, or None if not available.
        """
        if provider_type not in self._clients:
            logger.warning(f"Provider client not available: {provider_type.name}")
            return None
        
        return self._clients[provider_type]["client"]
    
    def get_provider_settings(self, provider_type: ProviderType) -> Dict[str, Any]:
        """
        Get provider settings.
        
        Args:
            provider_type: The type of provider.
        
        Returns:
            The provider settings.
        """
        provider_map = {
            ProviderType.OPENAI: "openai",
            ProviderType.ANTHROPIC: "anthropic",
            ProviderType.GOOGLE: "google",
            ProviderType.OPENROUTER: "openrouter"
        }
        
        provider_name = provider_map.get(provider_type)
        return self._provider_settings.get(provider_name, {})
    
    def is_provider_available(self, provider_type: ProviderType) -> bool:
        """
        Check if a provider is available.
        
        Args:
            provider_type: The type of provider.
        
        Returns:
            True if the provider is available, False otherwise.
        """
        # Check library availability
        if not self._provider_availability.get(provider_type, False):
            return False
        
        # Check if provider is enabled and initialized
        return provider_type in self._clients
    
    def get_available_providers(self) -> List[ProviderType]:
        """
        Get a list of available providers.
        
        Returns:
            List of available provider types.
        """
        return [
            provider for provider in ProviderType 
            if self.is_provider_available(provider)
        ]
    
    def verify_client(self, provider_type: ProviderType) -> bool:
        """
        Verify that a provider client is working.
        
        Args:
            provider_type: The type of provider to verify.
        
        Returns:
            True if the client is working, False otherwise.
        """
        if not self.is_provider_available(provider_type):
            logger.warning(f"Provider not available: {provider_type.name}")
            return False
        
        # Get the client
        client = self.get_client(provider_type)
        if not client:
            return False
        
        # Test prompt
        test_prompt = "Hello, this is a test prompt to verify API connectivity. Please respond with 'OK'."
        
        try:
            # Attempt to get a completion based on provider type
            if provider_type == ProviderType.OPENAI:
                response = client.chat.completions.create(
                    model=self.get_provider_settings(provider_type).get("default_model"),
                    messages=[{"role": "user", "content": test_prompt}],
                    max_tokens=10
                )
                return True
            
            elif provider_type == ProviderType.ANTHROPIC:
                response = client.completions.create(
                    prompt=f"\n\nHuman: {test_prompt}\n\nAssistant:",
                    model=self.get_provider_settings(provider_type).get("default_model"),
                    max_tokens_to_sample=10
                )
                return True
            
            elif provider_type == ProviderType.GOOGLE:
                model = client.GenerativeModel(
                    self.get_provider_settings(provider_type).get("default_model")
                )
                response = model.generate_content(test_prompt)
                return True
            
            elif provider_type == ProviderType.OPENROUTER:
                response = client.chat.completions.create(
                    model=self.get_provider_settings(provider_type).get("default_model"),
                    messages=[{"role": "user", "content": test_prompt}],
                    max_tokens=10
                )
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"Error verifying {provider_type.name} client: {e}")
            return False
    
    def get_default_provider(self) -> Optional[ProviderType]:
        """
        Get the default provider type based on availability.
        
        Returns:
            The default provider type, or None if no providers are available.
        """
        available_providers = self.get_available_providers()
        
        if not available_providers:
            return None
            
        # Return the first available provider in priority order
        priority_order = [
            ProviderType.OPENAI, 
            ProviderType.ANTHROPIC, 
            ProviderType.GOOGLE,
            ProviderType.OPENROUTER
        ]
        
        for provider in priority_order:
            if provider in available_providers:
                return provider
        
        # If none in priority order, return the first available
        return available_providers[0]
    
    def update_provider_settings(self, provider_type: ProviderType, 
                                settings: Dict[str, Any]) -> bool:
        """
        Update settings for a provider.
        
        Args:
            provider_type: The type of provider.
            settings: The new settings.
        
        Returns:
            True if the settings were updated successfully, False otherwise.
        """
        provider_map = {
            ProviderType.OPENAI: "openai",
            ProviderType.ANTHROPIC: "anthropic",
            ProviderType.GOOGLE: "google",
            ProviderType.OPENROUTER: "openrouter"
        }
        
        provider_name = provider_map.get(provider_type)
        if not provider_name:
            return False
        
        try:
            # Update in-memory settings
            if provider_name in self._provider_settings:
                self._provider_settings[provider_name].update(settings)
            else:
                self._provider_settings[provider_name] = settings
            
            # Update settings file
            providers_file = os.path.join("config", "llm", "providers.json")
            with open(providers_file, 'w', encoding='utf-8') as f:
                json.dump(self._provider_settings, f, indent=4)
            
            # Reinitialize the provider
            if provider_type == ProviderType.OPENAI:
                self._initialize_openai()
            elif provider_type == ProviderType.ANTHROPIC:
                self._initialize_anthropic()
            elif provider_type == ProviderType.GOOGLE:
                self._initialize_google()
            elif provider_type == ProviderType.OPENROUTER:
                self._initialize_openrouter()
            
            logger.info(f"Updated settings for provider: {provider_name}")
            return True
        
        except Exception as e:
            logger.error(f"Error updating provider settings: {e}")
            return False


# Convenience function
def get_provider_manager() -> ProviderManager:
    """Get the provider manager instance."""
    return ProviderManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the provider manager
    manager = get_provider_manager()
    
    # Check available providers
    available_providers = manager.get_available_providers()
    print(f"Available providers: {[p.name for p in available_providers]}")
    
    # Get default provider
    default_provider = manager.get_default_provider()
    if default_provider:
        print(f"Default provider: {default_provider.name}")
    else:
        print("No providers available")
```

### File: core\llm\settings_cli.py

```python
#!/usr/bin/env python3
"""
Command line interface for managing LLM settings.

This module provides a command line utility for managing LLM settings,
including API keys, provider selection, and agent configuration.
"""

import os
import sys
import argparse
import json
from typing import Dict, List, Optional, Any
import logging

from core.utils.logging_config import get_logger
from core.llm.settings_manager import SettingsManager, get_settings_manager
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = get_logger("LLM")

def print_header(text: str) -> None:
    """Print a header with decoration."""
    print("\n" + "=" * 60)
    print(f"  {text}")
    print("=" * 60)

def print_section(text: str) -> None:
    """Print a section header."""
    print(f"\n-- {text} --")

def print_json(data: Dict[str, Any]) -> None:
    """Print data as formatted JSON."""
    print(json.dumps(data, indent=2))

def format_provider_type(provider_type: ProviderType) -> str:
    """Format a provider type for display."""
    return provider_type.name.capitalize()

class SettingsCLI:
    """
    Command line interface for managing LLM settings.
    """
    
    def __init__(self):
        """Initialize the settings CLI."""
        self._settings_manager = get_settings_manager()
    
    def show_main_menu(self) -> None:
        """Show the main menu."""
        while True:
            print_header("LLM Settings Manager")
            print("\n1. Manage LLM General Settings")
            print("2. Manage Provider Settings")
            print("3. Manage Agent Settings")
            print("4. Run LLM Diagnostics")
            print("0. Exit")
            
            choice = input("\nEnter your choice: ")
            
            if choice == '1':
                self.manage_llm_settings()
            elif choice == '2':
                self.manage_provider_settings()
            elif choice == '3':
                self.manage_agent_settings()
            elif choice == '4':
                self.run_llm_diagnostics()
            elif choice == '0':
                print("Exiting. Goodbye!")
                break
            else:
                print("Invalid choice. Please try again.")
    
    def manage_llm_settings(self) -> None:
        """Manage general LLM settings."""
        print_header("General LLM Settings")
        
        settings = self._settings_manager.get_llm_settings()
        print_json(settings)
        
        print_section("Update Settings")
        print("Which setting would you like to update? (Enter setting name, or 'back' to go back)")
        
        setting_name = input("> ")
        
        if setting_name.lower() == 'back':
            return
        
        if setting_name in settings:
            current_value = settings[setting_name]
            print(f"Current value: {current_value} (type: {type(current_value).__name__})")
            
            if isinstance(current_value, bool):
                new_value_str = input(f"New value (true/false): ").lower()
                new_value = new_value_str in ['true', 'yes', 'y', '1']
            elif isinstance(current_value, int):
                new_value = int(input(f"New value (integer): "))
            elif isinstance(current_value, float):
                new_value = float(input(f"New value (number): "))
            elif isinstance(current_value, list):
                print("Enter values separated by commas:")
                new_value = [item.strip() for item in input("> ").split(',')]
            elif isinstance(current_value, dict):
                print("Cannot update nested dictionary from CLI. Please edit the JSON file directly.")
                return
            else:
                new_value = input(f"New value (string): ")
            
            # Update the setting
            self._settings_manager.update_llm_settings({setting_name: new_value})
            print(f"Updated {setting_name} to {new_value}")
        else:
            print(f"Setting '{setting_name}' not found.")
    
    def manage_provider_settings(self) -> None:
        """Manage provider settings."""
        while True:
            print_header("Provider Settings")
            
            # Get provider settings
            all_settings = self._settings_manager.get_provider_settings()
            
            # Display provider menu
            for i, (provider, _) in enumerate(all_settings.items(), 1):
                print(f"{i}. {provider.capitalize()}")
            
            print("0. Back")
            
            choice = input("\nSelect provider: ")
            
            if choice == '0':
                return
            
            try:
                index = int(choice) - 1
                if 0 <= index < len(all_settings):
                    provider = list(all_settings.keys())[index]
                    self.manage_specific_provider(provider)
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Please enter a number.")
    
    def manage_specific_provider(self, provider_name: str) -> None:
        """
        Manage settings for a specific provider.
        
        Args:
            provider_name: The name of the provider.
        """
        provider_map = {
            "openai": ProviderType.OPENAI,
            "anthropic": ProviderType.ANTHROPIC,
            "google": ProviderType.GOOGLE,
            "openrouter": ProviderType.OPENROUTER
        }
        
        provider_type = provider_map.get(provider_name)
        if not provider_type:
            print(f"Unknown provider: {provider_name}")
            return
        
        while True:
            print_header(f"{provider_name.capitalize()} Provider Settings")
            
            # Get provider settings
            settings = self._settings_manager.get_provider_settings(provider_type)
            print_json(settings)
            
            print_section("Options")
            print("1. Update API Key")
            print("2. Toggle Provider Enabled")
            print("3. Change Default Model")
            print("0. Back")
            
            choice = input("\nEnter your choice: ")
            
            if choice == '1':
                api_key = input("Enter API Key (leave empty to cancel): ")
                if api_key:
                    self._settings_manager.set_api_key(provider_type, api_key)
                    print("API Key updated.")
            
            elif choice == '2':
                enabled = settings.get("enabled", False)
                new_enabled = not enabled
                self._settings_manager.enable_provider(provider_type, new_enabled)
                print(f"Provider {provider_name} {'enabled' if new_enabled else 'disabled'}.")
            
            elif choice == '3':
                # Get available models
                available_models = settings.get("available_models", [])
                
                print_section("Available Models")
                for i, model in enumerate(available_models, 1):
                    print(f"{i}. {model}")
                
                choice = input("\nSelect model (or enter a custom model name): ")
                
                try:
                    index = int(choice) - 1
                    if 0 <= index < len(available_models):
                        model = available_models[index]
                    else:
                        raise ValueError
                except ValueError:
                    model = choice
                
                self._settings_manager.update_provider_settings(provider_type, {"default_model": model})
                print(f"Default model set to {model}.")
            
            elif choice == '0':
                return
            
            else:
                print("Invalid choice. Please try again.")
    
    def manage_agent_settings(self) -> None:
        """Manage agent settings."""
        while True:
            print_header("Agent Settings")
            
            # Get list of agents
            agents = self._settings_manager.list_available_agents()
            
            # Display agent menu
            for i, agent in enumerate(agents, 1):
                print(f"{i}. {agent.capitalize()}")
            
            print("0. Back")
            
            choice = input("\nSelect agent: ")
            
            if choice == '0':
                return
            
            try:
                index = int(choice) - 1
                if 0 <= index < len(agents):
                    agent = agents[index]
                    self.manage_specific_agent(agent)
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Please enter a number.")
    
    def manage_specific_agent(self, agent_name: str) -> None:
        """
        Manage settings for a specific agent.
        
        Args:
            agent_name: The name of the agent.
        """
        while True:
            print_header(f"{agent_name.capitalize()} Agent Settings")
            
            # Get agent settings
            settings = self._settings_manager.get_agent_settings(agent_name)
            print_json(settings)
            
            print_section("Options")
            print("1. Change Provider")
            print("2. Change Model")
            print("3. Update Temperature")
            print("4. Update Max Tokens")
            print("0. Back")
            
            choice = input("\nEnter your choice: ")
            
            if choice == '1':
                # Get available providers
                provider_types = [
                    ProviderType.OPENAI,
                    ProviderType.ANTHROPIC,
                    ProviderType.GOOGLE,
                    ProviderType.OPENROUTER
                ]
                
                print_section("Available Providers")
                for i, provider in enumerate(provider_types, 1):
                    print(f"{i}. {format_provider_type(provider)}")
                
                choice = input("\nSelect provider: ")
                
                try:
                    index = int(choice) - 1
                    if 0 <= index < len(provider_types):
                        provider = provider_types[index]
                        self._settings_manager.set_agent_provider(agent_name, provider)
                        print(f"Provider set to {format_provider_type(provider)}.")
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Please enter a number.")
            
            elif choice == '2':
                # Get current provider
                provider_type = self._settings_manager.get_agent_provider(agent_name)
                
                if provider_type:
                    # Get available models for the provider
                    models = self._settings_manager.get_available_models(provider_type)
                    
                    print_section(f"Available Models for {format_provider_type(provider_type)}")
                    for i, model in enumerate(models, 1):
                        print(f"{i}. {model}")
                    
                    choice = input("\nSelect model (or enter a custom model name): ")
                    
                    try:
                        index = int(choice) - 1
                        if 0 <= index < len(models):
                            model = models[index]
                        else:
                            raise ValueError
                    except ValueError:
                        model = choice
                    
                    self._settings_manager.set_agent_model(agent_name, model)
                    print(f"Model set to {model}.")
                else:
                    print("Provider not set for this agent.")
            
            elif choice == '3':
                # Update temperature
                current_temp = settings.get("temperature", 0.7)
                print(f"Current temperature: {current_temp}")
                
                try:
                    new_temp = float(input("New temperature (0.0-1.0): "))
                    if 0.0 <= new_temp <= 1.0:
                        self._settings_manager.update_agent_settings(agent_name, {"temperature": new_temp})
                        print(f"Temperature set to {new_temp}.")
                    else:
                        print("Temperature must be between 0.0 and 1.0.")
                except ValueError:
                    print("Please enter a valid number.")
            
            elif choice == '4':
                # Update max tokens
                current_max = settings.get("max_tokens", 1000)
                print(f"Current max tokens: {current_max}")
                
                try:
                    new_max = int(input("New max tokens: "))
                    if new_max > 0:
                        self._settings_manager.update_agent_settings(agent_name, {"max_tokens": new_max})
                        print(f"Max tokens set to {new_max}.")
                    else:
                        print("Max tokens must be a positive number.")
                except ValueError:
                    print("Please enter a valid number.")
            
            elif choice == '0':
                return
            
            else:
                print("Invalid choice. Please try again.")
    
    def run_llm_diagnostics(self) -> None:
        """Run LLM diagnostics."""
        print_header("Running LLM Diagnostics")
        
        from core.llm.llm_manager import get_llm_manager
        
        llm_manager = get_llm_manager()
        diagnostics = llm_manager.run_llm_diagnostics()
        
        print_section("Diagnostic Results")
        print(f"Status: {diagnostics.get('status', 'unknown')}")
        print(f"Message: {diagnostics.get('message', 'No message')}")
        
        print_section("Provider Results")
        for provider, result in diagnostics.get("providers", {}).items():
            print(f"\n{provider}:")
            print(f"  Status: {result.get('status', 'unknown')}")
            
            if result.get("status") == "success":
                print(f"  Model: {result.get('model', 'unknown')}")
                print(f"  Response: {result.get('response_content', '')}")
                print(f"  Tokens: {result.get('tokens', {})}")
                print(f"  Cost: ${result.get('cost', 0):.6f}")
            else:
                print(f"  Error: {result.get('error', 'Unknown error')}")


def main() -> None:
    """Main entry point for the CLI."""
    parser = argparse.ArgumentParser(description="LLM Settings Manager CLI")
    
    parser.add_argument("--set-api-key", action="store_true", help="Set API key for a provider")
    parser.add_argument("--provider", type=str, help="Provider name (openai, anthropic, google, openrouter)")
    parser.add_argument("--key", type=str, help="API key")
    
    parser.add_argument("--enable", action="store_true", help="Enable a provider")
    parser.add_argument("--disable", action="store_true", help="Disable a provider")
    
    parser.add_argument("--list-providers", action="store_true", help="List available providers")
    parser.add_argument("--list-agents", action="store_true", help="List available agents")
    
    parser.add_argument("--show-diagnostics", action="store_true", help="Run LLM diagnostics")
    
    args = parser.parse_args()
    
    settings_manager = get_settings_manager()
    
    # Handle command line arguments
    if args.set_api_key:
        if not args.provider or not args.key:
            print("Error: --provider and --key required with --set-api-key")
            return
        
        provider_map = {
            "openai": ProviderType.OPENAI,
            "anthropic": ProviderType.ANTHROPIC,
            "google": ProviderType.GOOGLE,
            "openrouter": ProviderType.OPENROUTER
        }
        
        if args.provider.lower() not in provider_map:
            print(f"Error: Unknown provider '{args.provider}'. Must be one of: {', '.join(provider_map.keys())}")
            return
        
        provider_type = provider_map[args.provider.lower()]
        success = settings_manager.set_api_key(provider_type, args.key)
        
        if success:
            print(f"API key for {args.provider} updated successfully.")
        else:
            print(f"Failed to update API key for {args.provider}.")
    
    elif args.enable or args.disable:
        if not args.provider:
            print("Error: --provider required with --enable or --disable")
            return
        
        provider_map = {
            "openai": ProviderType.OPENAI,
            "anthropic": ProviderType.ANTHROPIC,
            "google": ProviderType.GOOGLE,
            "openrouter": ProviderType.OPENROUTER
        }
        
        if args.provider.lower() not in provider_map:
            print(f"Error: Unknown provider '{args.provider}'. Must be one of: {', '.join(provider_map.keys())}")
            return
        
        provider_type = provider_map[args.provider.lower()]
        success = settings_manager.enable_provider(provider_type, args.enable)
        
        if success:
            print(f"Provider {args.provider} {'enabled' if args.enable else 'disabled'} successfully.")
        else:
            print(f"Failed to {'enable' if args.enable else 'disable'} provider {args.provider}.")
    
    elif args.list_providers:
        provider_settings = settings_manager.get_provider_settings()
        print_header("Available Providers")
        
        for provider, settings in provider_settings.items():
            enabled = settings.get("enabled", False)
            api_key_set = bool(settings.get("api_key", ""))
            default_model = settings.get("default_model", "unknown")
            
            print(f"{provider.capitalize()}: {'Enabled' if enabled else 'Disabled'}, API Key: {'Set' if api_key_set else 'Not Set'}, Default Model: {default_model}")
    
    elif args.list_agents:
        agents = settings_manager.list_available_agents()
        print_header("Available Agents")
        
        for agent in agents:
            agent_settings = settings_manager.get_agent_settings(agent)
            provider_type_str = agent_settings.get("provider_type", "OPENAI")
            model = agent_settings.get("model", "default")
            
            print(f"{agent.capitalize()}: Provider={provider_type_str}, Model={model}")
    
    elif args.show_diagnostics:
        cli = SettingsCLI()
        cli.run_llm_diagnostics()
    
    else:
        # No arguments, run interactive CLI
        SettingsCLI().show_main_menu()


if __name__ == "__main__":
    main()
```

### File: core\llm\settings_manager.py

```python
#!/usr/bin/env python3
"""
Settings manager for LLM and agent configuration.

This module provides a SettingsManager class that handles viewing and modifying
LLM settings, API keys, and agent configurations.
"""

import os
import json
from typing import Dict, List, Optional, Any, Union
import logging

from core.utils.logging_config import get_logger
from core.base.config import get_config
from core.llm.provider_manager import ProviderType, get_provider_manager

# Get the module logger
logger = get_logger("LLM")

class SettingsManager:
    """
    Manager for LLM and agent settings.
    
    This class provides methods for viewing and modifying settings related
    to LLM providers, API keys, and agent configurations.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(SettingsManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the settings manager."""
        if self._initialized:
            return
        
        logger.info("Initializing SettingsManager")
        
        # Get configuration
        self._config = get_config()
        
        # Get provider manager
        self._provider_manager = get_provider_manager()
        
        # Set paths
        self._llm_config_path = os.path.join("config", "llm", "base_config.json")
        self._providers_path = os.path.join("config", "llm", "providers.json")
        self._agents_dir = os.path.join("config", "llm", "agents")
        
        # Ensure directories exist
        os.makedirs(self._agents_dir, exist_ok=True)
        
        self._initialized = True
        logger.info("SettingsManager initialized")
    
    def get_llm_settings(self) -> Dict[str, Any]:
        """
        Get general LLM settings.
        
        Returns:
            Dictionary of LLM settings.
        """
        try:
            if os.path.exists(self._llm_config_path):
                with open(self._llm_config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                logger.warning(f"LLM config file not found: {self._llm_config_path}")
                return {}
        except Exception as e:
            logger.error(f"Error getting LLM settings: {e}")
            return {}
    
    def update_llm_settings(self, settings: Dict[str, Any]) -> bool:
        """
        Update general LLM settings.
        
        Args:
            settings: Dictionary of settings to update.
        
        Returns:
            True if successful, False otherwise.
        """
        try:
            # Get current settings
            current_settings = self.get_llm_settings()
            
            # Update settings
            current_settings.update(settings)
            
            # Write updated settings
            with open(self._llm_config_path, 'w', encoding='utf-8') as f:
                json.dump(current_settings, f, indent=4)
            
            logger.info("Updated LLM settings")
            return True
        except Exception as e:
            logger.error(f"Error updating LLM settings: {e}")
            return False
    
    def get_provider_settings(self, provider_type: Optional[ProviderType] = None) -> Dict[str, Any]:
        """
        Get provider settings.
        
        Args:
            provider_type: The provider type. If None, get all provider settings.
        
        Returns:
            Dictionary of provider settings.
        """
        try:
            if os.path.exists(self._providers_path):
                with open(self._providers_path, 'r', encoding='utf-8') as f:
                    providers_data = json.load(f)
                
                if provider_type:
                    # Convert ProviderType to provider name
                    provider_map = {
                        ProviderType.OPENAI: "openai",
                        ProviderType.ANTHROPIC: "anthropic",
                        ProviderType.GOOGLE: "google",
                        ProviderType.OPENROUTER: "openrouter"
                    }
                    
                    provider_name = provider_map.get(provider_type)
                    if provider_name and provider_name in providers_data:
                        return providers_data[provider_name]
                    else:
                        logger.warning(f"Provider not found: {provider_type.name if provider_type else None}")
                        return {}
                else:
                    return providers_data
            else:
                logger.warning(f"Providers file not found: {self._providers_path}")
                return {}
        except Exception as e:
            logger.error(f"Error getting provider settings: {e}")
            return {}
    
    def update_provider_settings(self, provider_type: ProviderType, settings: Dict[str, Any]) -> bool:
        """
        Update settings for a provider.
        
        Args:
            provider_type: The type of provider.
            settings: The new settings.
        
        Returns:
            True if successful, False otherwise.
        """
        # Get provider name
        provider_map = {
            ProviderType.OPENAI: "openai",
            ProviderType.ANTHROPIC: "anthropic",
            ProviderType.GOOGLE: "google",
            ProviderType.OPENROUTER: "openrouter"
        }
        
        provider_name = provider_map.get(provider_type)
        if not provider_name:
            logger.error(f"Invalid provider type: {provider_type}")
            return False
        
        try:
            # Get all provider settings
            all_providers = self.get_provider_settings()
            
            # Update provider settings
            if provider_name in all_providers:
                all_providers[provider_name].update(settings)
            else:
                all_providers[provider_name] = settings
            
            # Write updated settings
            with open(self._providers_path, 'w', encoding='utf-8') as f:
                json.dump(all_providers, f, indent=4)
            
            # Update provider in provider manager
            self._provider_manager.update_provider_settings(provider_type, settings)
            
            logger.info(f"Updated settings for provider: {provider_name}")
            return True
        except Exception as e:
            logger.error(f"Error updating provider settings: {e}")
            return False
    
    def set_api_key(self, provider_type: ProviderType, api_key: str) -> bool:
        """
        Set the API key for a provider.
        
        Args:
            provider_type: The type of provider.
            api_key: The API key.
        
        Returns:
            True if successful, False otherwise.
        """
        # Update provider settings with the new API key
        return self.update_provider_settings(provider_type, {"api_key": api_key})
    
    def get_agent_settings(self, agent_name: Optional[str] = None) -> Dict[str, Any]:
        """
        Get agent settings.
        
        Args:
            agent_name: The name of the agent. If None, get all agent settings.
        
        Returns:
            Dictionary of agent settings.
        """
        if agent_name:
            # Get settings for a specific agent
            agent_path = os.path.join(self._agents_dir, f"{agent_name.lower()}.json")
            
            try:
                if os.path.exists(agent_path):
                    with open(agent_path, 'r', encoding='utf-8') as f:
                        return json.load(f)
                else:
                    logger.warning(f"Agent settings file not found: {agent_path}")
                    return {}
            except Exception as e:
                logger.error(f"Error getting agent settings: {e}")
                return {}
        else:
            # Get settings for all agents
            agent_settings = {}
            
            try:
                for filename in os.listdir(self._agents_dir):
                    if filename.endswith(".json"):
                        agent_name = os.path.splitext(filename)[0]
                        agent_path = os.path.join(self._agents_dir, filename)
                        
                        with open(agent_path, 'r', encoding='utf-8') as f:
                            agent_settings[agent_name] = json.load(f)
            except Exception as e:
                logger.error(f"Error getting all agent settings: {e}")
            
            return agent_settings
    
    def update_agent_settings(self, agent_name: str, settings: Dict[str, Any]) -> bool:
        """
        Update settings for an agent.
        
        Args:
            agent_name: The name of the agent.
            settings: The new settings.
        
        Returns:
            True if successful, False otherwise.
        """
        agent_path = os.path.join(self._agents_dir, f"{agent_name.lower()}.json")
        
        try:
            # Get current settings
            current_settings = {}
            if os.path.exists(agent_path):
                with open(agent_path, 'r', encoding='utf-8') as f:
                    current_settings = json.load(f)
            
            # Update settings
            current_settings.update(settings)
            
            # Write updated settings
            with open(agent_path, 'w', encoding='utf-8') as f:
                json.dump(current_settings, f, indent=4)
            
            logger.info(f"Updated settings for agent: {agent_name}")
            return True
        except Exception as e:
            logger.error(f"Error updating agent settings: {e}")
            return False
    
    def list_available_agents(self) -> List[str]:
        """
        List all available agents.
        
        Returns:
            List of agent names.
        """
        agents = []
        
        try:
            for filename in os.listdir(self._agents_dir):
                if filename.endswith(".json"):
                    agent_name = os.path.splitext(filename)[0]
                    agents.append(agent_name)
        except Exception as e:
            logger.error(f"Error listing agents: {e}")
        
        return agents
    
    def get_agent_provider(self, agent_name: str) -> Optional[ProviderType]:
        """
        Get the provider type for an agent.
        
        Args:
            agent_name: The name of the agent.
        
        Returns:
            The provider type, or None if not found.
        """
        agent_settings = self.get_agent_settings(agent_name)
        
        if not agent_settings:
            return None
        
        provider_type_str = agent_settings.get("provider_type")
        
        if not provider_type_str:
            return None
        
        try:
            return ProviderType[provider_type_str]
        except (KeyError, ValueError):
            logger.warning(f"Invalid provider type in agent settings: {provider_type_str}")
            return None
    
    def set_agent_provider(self, agent_name: str, provider_type: ProviderType) -> bool:
        """
        Set the provider type for an agent.
        
        Args:
            agent_name: The name of the agent.
            provider_type: The provider type.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_agent_settings(agent_name, {"provider_type": provider_type.name})
    
    def set_agent_model(self, agent_name: str, model: str) -> bool:
        """
        Set the model for an agent.
        
        Args:
            agent_name: The name of the agent.
            model: The model name.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_agent_settings(agent_name, {"model": model})
    
    def get_available_models(self, provider_type: ProviderType) -> List[str]:
        """
        Get available models for a provider.
        
        Args:
            provider_type: The provider type.
        
        Returns:
            List of model names.
        """
        provider_settings = self.get_provider_settings(provider_type)
        return provider_settings.get("available_models", [])
    
    def is_provider_enabled(self, provider_type: ProviderType) -> bool:
        """
        Check if a provider is enabled.
        
        Args:
            provider_type: The provider type.
        
        Returns:
            True if enabled, False otherwise.
        """
        provider_settings = self.get_provider_settings(provider_type)
        return provider_settings.get("enabled", False)
    
    def enable_provider(self, provider_type: ProviderType, enabled: bool) -> bool:
        """
        Enable or disable a provider.
        
        Args:
            provider_type: The provider type.
            enabled: Whether to enable the provider.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_provider_settings(provider_type, {"enabled": enabled})


# Convenience function
def get_settings_manager() -> SettingsManager:
    """Get the settings manager instance."""
    return SettingsManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the settings manager
    manager = get_settings_manager()
    
    # Print LLM settings
    llm_settings = manager.get_llm_settings()
    print(f"LLM settings: {llm_settings}")
    
    # Print provider settings
    provider_settings = manager.get_provider_settings()
    print(f"Provider settings: {provider_settings}")
    
    # Print agent settings
    agent_settings = manager.get_agent_settings()
    print(f"Agent settings: {agent_settings}")
```

### File: core\orchestration\__init__.py

```python

```

### File: core\orchestration\combat_orchestrator.py

```python
"""
Manages the sequential display of combat events, including narratives,
system messages, and UI updates, respecting delays and completion signals.
"""
import collections
import logging
import weakref
from typing import Dict, Optional, TYPE_CHECKING

from PySide6.QtCore import QObject, QTimer, Signal, Slot

from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget

if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.combat.combat_manager import CombatManager
    from core.audio.tts_manager import TTSManager # Placeholder

logger = logging.getLogger("ORCHESTRATOR") # New logger category

class CombatOutputOrchestrator(QObject):
    """
    Orchestrates the output of combat-related information to ensure
    sequential display, inter-step delays, and TTS compatibility.
    """
    # Signal to resume CombatManager processing
    resume_combat_manager = Signal()
    # Developer-mode: notify UI whether orchestrator is waiting for manual release
    dev_waiting_state_changed = Signal(bool)

    def __init__(self, parent: Optional[QObject] = None):
        super().__init__(parent)
        self.event_queue: collections.deque[DisplayEvent] = collections.deque()
        self.is_processing_event: bool = False
        self.is_waiting_for_visual: bool = False
        self.is_waiting_for_tts: bool = False # Placeholder for TTS

        self.inter_step_delay_timer: QTimer = QTimer(self)
        self.inter_step_delay_timer.setSingleShot(True)
        self.inter_step_delay_timer.timeout.connect(self._on_inter_step_delay_timeout)

        self.engine_ref: Optional[weakref.ref['GameEngine']] = None
        self.combat_manager_ref: Optional[weakref.ref['CombatManager']] = None
        self.tts_manager_ref: Optional[weakref.ref['TTSManager']] = None # Placeholder

        self.config_delay_ms: int = 1000 # Default 1 second, load from config later
        self.current_event: Optional[DisplayEvent] = None

        # Developer mode controls
        self.dev_manual_step_mode: bool = False
        self.dev_waiting_for_next_click: bool = False
        self.dev_last_skip_delay: bool = False

    def set_references(self, engine: 'GameEngine', tts_manager: Optional['TTSManager'] = None):
        """Set references to other core components. CombatManager is set per combat."""
        self.engine_ref = weakref.ref(engine)
        if tts_manager:
            self.tts_manager_ref = weakref.ref(tts_manager)
        logger.info("CombatOutputOrchestrator references set.")

    def set_combat_manager(self, combat_manager: Optional['CombatManager']):
        """Set or clear the current CombatManager reference."""
        if combat_manager:
            self.combat_manager_ref = weakref.ref(combat_manager)
            logger.debug(f"Orchestrator now referencing CombatManager: {combat_manager.id if combat_manager else 'None'}")
        else:
            self.combat_manager_ref = None
            logger.debug("Orchestrator cleared CombatManager reference.")


    def load_config(self):
        """Loads configuration, e.g., inter-step delay."""
        engine = self.engine_ref() if self.engine_ref else None
        if engine and hasattr(engine, '_config'):
            self.config_delay_ms = engine._config.get("combat.inter_step_delay_ms", 1000)
            logger.info(f"Orchestrator inter-step delay set to {self.config_delay_ms}ms from config.")
        else:
            logger.warning("Could not load orchestrator config, using default delay.")


    def add_event_to_queue(self, event: DisplayEvent):
        """Adds a DisplayEvent to the processing queue."""
        # Guard against stale rehydrate events crossing session boundaries
        try:
            engine = self.engine_ref() if self.engine_ref else None
            if engine and getattr(event, 'source_step', None) == 'REHYDRATE_FROM_SAVE':
                # Accept only if session_id matches current state's session
                expected = None
                try:
                    meta = getattr(event, 'metadata', None) or {}
                    expected = meta.get('session_id')
                except Exception:
                    expected = None
                curr_state = getattr(engine, '_state_manager', None).current_state if engine and hasattr(engine, '_state_manager') else None
                curr_sess = getattr(curr_state, 'session_id', None) if curr_state else None
                if expected is not None and curr_sess is not None and expected != curr_sess:
                    logger.info("Dropping stale REHYDRATE_FROM_SAVE event due to session_id mismatch.")
                    return
        except Exception:
            # Non-fatal: if guard fails, proceed to enqueue (better to over-show than crash)
            pass

        self.event_queue.append(event)
        logger.debug(f"Event added to queue: {event}. Queue size: {len(self.event_queue)}")
        if not self.is_processing_event and not self.inter_step_delay_timer.isActive():
            # If nothing is currently happening (not processing, not in delay), start processing.
            # This handles the case where CombatManager queues an event and immediately pauses.
            logger.debug("Orchestrator was idle, triggering _process_next_event_from_queue.")
            self._process_next_event_from_queue()


    @Slot()
    def _process_next_event_from_queue(self):
        """Processes the next event from the queue if conditions allow."""
        if self.is_processing_event or self.inter_step_delay_timer.isActive():
            logger.debug("Orchestrator busy or in delay, skipping _process_next_event_from_queue.")
            return

        if not self.event_queue:
            logger.debug("Event queue empty. Orchestrator idle.")
            combat_manager = self.combat_manager_ref() if self.combat_manager_ref else None
            engine = self.engine_ref() if self.engine_ref else None
            if combat_manager and getattr(combat_manager, 'waiting_for_display_completion', False):
                 logger.debug("Event queue empty, but CombatManager was waiting. Signalling resume (end of sub-step).")
                 self._signal_combat_manager_resume()
            elif engine and getattr(engine, '_waiting_for_closing_narrative_display', False):
                 logger.info("Orchestrator queue empty, and engine was waiting for closing narrative. Signaling engine completion.")
                 if hasattr(engine, 'on_orchestrator_idle_and_combat_manager_resumed'):
                     engine.on_orchestrator_idle_and_combat_manager_resumed()
            return

        # --- ECFA Fix: Use a local variable for the event being processed ---
        event_being_processed = self.event_queue.popleft()
        # Guard again at processing time against stale rehydrate events that were enqueued before a session change
        try:
            engine = self.engine_ref() if self.engine_ref else None
            if engine and getattr(event_being_processed, 'source_step', None) == 'REHYDRATE_FROM_SAVE':
                meta = getattr(event_being_processed, 'metadata', None) or {}
                expected = meta.get('session_id')
                curr_state = getattr(engine, '_state_manager', None).current_state if engine and hasattr(engine, '_state_manager') else None
                curr_sess = getattr(curr_state, 'session_id', None) if curr_state else None
                if expected is not None and curr_sess is not None and expected != curr_sess:
                    logger.info("Skipping processing of stale REHYDRATE_FROM_SAVE event due to session_id mismatch.")
                    # Immediately move on to next event
                    self.is_processing_event = False
                    self.current_event_id_for_signals = None
                    # Recurse to process next event quickly
                    self._process_next_event_from_queue()
                    return
        except Exception:
            pass

        self.current_event_id_for_signals = event_being_processed.event_id # Store ID for slots to check
        # Track the current event object for timing decisions later
        self.current_event = event_being_processed
        # --- End ECFA Fix ---
        
        logger.info(f"Processing event: {event_being_processed}")
        self.is_processing_event = True # Mark orchestrator as busy with THIS event
        self.is_waiting_for_visual = False
        self.is_waiting_for_tts = False

        engine = self.engine_ref() if self.engine_ref else None
        if not engine:
            logger.error("Engine reference not available in Orchestrator. Cannot process event.")
            self.is_processing_event = False
            self.current_event_id_for_signals = None
            # If an event was popped, try to simulate its completion to avoid stall
            # by directly calling check_event_processing_complete as if it finished.
            self._check_event_processing_complete(event_being_processed.event_id)
            return

        if event_being_processed.type == DisplayEventType.REQUEST_CLOSING_NARRATIVE:
            logger.info("Orchestrator handling REQUEST_CLOSING_NARRATIVE.")
            self._handle_request_closing_narrative(engine, event_being_processed.metadata)
            self.is_processing_event = False 
            self.current_event_id_for_signals = None
            self._process_next_event_from_queue() 
            return

        if event_being_processed.type == DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE:
            logger.debug(f"Applying model resource update: {event_being_processed.metadata}")
            try:
                meta = event_being_processed.metadata or {}
                entity_id = meta.get("entity_id")
                bar_type = str(meta.get("bar_type", "")).lower()
                value = meta.get("final_new_value")
                max_value = meta.get("max_value")
                if entity_id is not None and value is not None:
                    # Clamp value between 0 and max_value if provided
                    try:
                        if max_value is not None:
                            value = max(0, min(int(value), int(max_value)))
                        else:
                            value = max(0, int(value))
                    except Exception:
                        pass
                    cm = self.combat_manager_ref() if self.combat_manager_ref else None
                    if cm:
                        # Update through entity-specific stats manager when available
                        stats_mgr = getattr(cm, '_get_entity_stats_manager', None)
                        entity_stats_mgr = stats_mgr(entity_id) if stats_mgr else None
                        from core.stats.stats_base import DerivedStatType
                        # Map bar_type to stat
                        if bar_type in ("hp", "health"):
                            if entity_stats_mgr:
                                entity_stats_mgr.set_current_stat(DerivedStatType.HEALTH, value)
                            entity = cm.entities.get(entity_id)
                            if entity: entity.set_current_hp(value)
                        elif bar_type in ("stamina",):
                            if entity_stats_mgr:
                                entity_stats_mgr.set_current_stat(DerivedStatType.STAMINA, value)
                            entity = cm.entities.get(entity_id)
                            if entity: entity.set_current_stamina(value)
                        elif bar_type in ("mana", "mp"):
                            if entity_stats_mgr:
                                entity_stats_mgr.set_current_stat(DerivedStatType.MANA, value)
                            entity = cm.entities.get(entity_id)
                            if entity is not None:
                                try:
                                    entity.current_mp = value
                                except Exception:
                                    pass
                        else:
                            logger.warning(f"Unknown bar_type '{bar_type}' in APPLY_ENTITY_RESOURCE_UPDATE")
                    else:
                        logger.error("CombatManager reference missing; cannot apply resource update.")
            except Exception as e:
                logger.error(f"Error applying entity resource update: {e}", exc_info=True)
            # Event-based completion for this non-visual event: keep is_processing_event True so completion advances queue
            logger.debug(f"APPLY_ENTITY_RESOURCE_UPDATE done for {event_being_processed.event_id}; advancing queue")
            self._check_event_processing_complete(event_being_processed.event_id)
            return

        if event_being_processed.type == DisplayEventType.APPLY_ENTITY_STATE_UPDATE:
            logger.debug(f"Applying model state update: {event_being_processed.metadata}")
            try:
                meta = event_being_processed.metadata or {}
                entity_id = meta.get("entity_id")
                cm = self.combat_manager_ref() if self.combat_manager_ref else None
                if cm and entity_id in cm.entities:
                    entity = cm.entities.get(entity_id)
                    if entity is not None:
                        if "is_active_in_combat" in meta:
                            try:
                                entity.is_active_in_combat = bool(meta.get("is_active_in_combat"))
                            except Exception:
                                pass
                else:
                    logger.warning("Cannot apply entity state update; missing CombatManager or entity.")
            except Exception as e:
                logger.error(f"Error applying entity state update: {e}", exc_info=True)
            # Event-based completion for this non-visual event: keep is_processing_event True so completion advances queue
            logger.debug(f"APPLY_ENTITY_STATE_UPDATE done for {event_being_processed.event_id}; advancing queue")
            self._check_event_processing_complete(event_being_processed.event_id)
            return

        # --- Handle special non-visual events ---

        # --- Route event content to UI for visual display ---
        # Assuming UI_BAR_UPDATE and VISUAL_EFFECT also go through orchestrated_event_to_ui
        # and their handlers in MainWindow will call _handle_visual_display_complete appropriately.
        self.is_waiting_for_visual = True
        engine.orchestrated_event_to_ui.emit(event_being_processed)

        # Special case: BUFFER_FLUSH to text displays does not need visual completion waiting
        try:
            if event_being_processed.type in (DisplayEventType.BUFFER_FLUSH, DisplayEventType.COMBAT_LOG_SET_HTML):
                # We consider batch text append immediate for orchestrator purposes
                self.is_waiting_for_visual = False
        except Exception:
            pass

        # No persistence needed here; HTML snapshot approach will be used for rehydration.
        
        # --- Handle TTS ---
        tts_manager = self.tts_manager_ref() if self.tts_manager_ref else None
        if event_being_processed.tts_eligible and tts_manager and tts_manager.is_enabled:
            content_to_speak = ""
            if isinstance(event_being_processed.content, str):
                content_to_speak = event_being_processed.content
            elif isinstance(event_being_processed.content, list) and event_being_processed.type == DisplayEventType.BUFFER_FLUSH:
                content_to_speak = "\n".join(str(item) for item in event_being_processed.content)
            
            if content_to_speak.strip():
                self.is_waiting_for_tts = True
                tts_manager.speak(content_to_speak)
        
        # If neither visual nor TTS is awaited (e.g., event type doesn't require it, or TTS disabled)
        # then call _check_event_processing_complete.
        # This path is tricky because is_waiting_for_visual is set true, expecting a signal.
        # If an event type TRULY has no visual and no TTS, it should bypass setting these flags.
        # For now, assume all emitted events will lead to _handle_visual_display_complete.
        if not self.is_waiting_for_visual and not self.is_waiting_for_tts:
            logger.debug(f"No visual or TTS initially awaited for event {event_being_processed.event_id}. Checking completion.")
            self._check_event_processing_complete(event_being_processed.event_id)

    @Slot()
    def _handle_visual_display_complete(self):
        """Slot called when a UI widget finishes displaying text."""
        # --- ECFA Fix: Check against stored event ID ---
        # This slot might be called for an event that's already "completed" if UI signals are rapid
        # or if a previous event's signal arrives late.
        # We only care if it's for the event we are currently marked as 'processing'.
        if not self.is_processing_event: 
            logger.debug(f"Received visualDisplayComplete but Orchestrator not actively processing an event (or already completed it). Ignoring.")
            return
        # If we want to be super sure, we could pass event_id with the signal, but that makes UI more complex.
        # For now, if is_processing_event is true, assume it's for the event whose ID is in self.current_event_id_for_signals.
        logger.debug(f"Received visualDisplayComplete for current processing cycle (event_id around: {self.current_event_id_for_signals}).")
        # --- End ECFA Fix ---
        
        self.is_waiting_for_visual = False
        self._check_event_processing_complete(self.current_event_id_for_signals)

    @Slot()
    def _handle_tts_playback_complete(self):
        """Slot called when TTS finishes speaking."""
        if not self.is_processing_event:
            logger.debug(f"Received ttsPlaybackComplete but Orchestrator not actively processing an event. Ignoring.")
            return
        logger.debug(f"Received ttsPlaybackComplete for current processing cycle (event_id around: {self.current_event_id_for_signals}).")
        self.is_waiting_for_tts = False
        self._check_event_processing_complete(self.current_event_id_for_signals)

    def _check_event_processing_complete(self, event_id_completed: Optional[str]):
        """
        Checks if all parts of the current event are done (visual, TTS).
        Uses event_id_completed to ensure we are finalizing the correct event.
        """
        # --- ECFA Fix: Only proceed if this completion matches the event being processed ---
        if not self.is_processing_event or self.current_event_id_for_signals != event_id_completed:
            if self.is_processing_event: # Mismatch
                logger.warning(f"_check_event_processing_complete called for event '{event_id_completed}', "
                               f"but currently processing event '{self.current_event_id_for_signals}'. Ignoring this completion call.")
            # Else, already not processing, so this is a late signal for a past event.
            return 
        # --- End ECFA Fix ---

        if not self.is_waiting_for_visual and not self.is_waiting_for_tts:
            logger.info(f"Event processing truly complete for: {self.current_event_id_for_signals}")
            self.is_processing_event = False
            self.current_event_id_for_signals = None # Clear the ID of the event just completed

            # Decide whether to apply an inter-step delay based on event type
            skip_delay = False
            try:
                from core.orchestration.events import DisplayEventType
                if hasattr(self, 'current_event') and self.current_event and \
                   self.current_event.type in (DisplayEventType.UI_BAR_UPDATE_PHASE1, DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                               DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE, DisplayEventType.APPLY_ENTITY_STATE_UPDATE):
                    skip_delay = True
            except Exception:
                pass

            # Always clear current_event once we've computed skip_delay
            self.dev_last_skip_delay = skip_delay
            self.current_event = None

            # Developer manual step gating
            if getattr(self, 'dev_manual_step_mode', False):
                logger.debug("Developer Step Mode: waiting for manual release before continuing.")
                self.dev_waiting_for_next_click = True
                try:
                    self.dev_waiting_state_changed.emit(True)
                except Exception:
                    pass
                return

            if skip_delay:
                logger.debug("Skipping inter-step delay after UI_BAR_UPDATE event to keep UI updates in sync.")
                self._process_next_event_from_queue()
            else:
                self.inter_step_delay_timer.start(self.config_delay_ms)
                logger.debug(f"Started inter-step delay: {self.config_delay_ms}ms after event {event_id_completed}")

    @Slot()
    def _on_inter_step_delay_timeout(self):
        logger.debug("Inter-step delay timeout.")
        resumed_cm_and_cm_is_not_waiting = self._signal_combat_manager_resume() 
        
        # If we were in dev manual step mode and waiting, clear waiting state upon timeout
        if getattr(self, 'dev_manual_step_mode', False) and getattr(self, 'dev_waiting_for_next_click', False):
            self.dev_waiting_for_next_click = False
            try:
                self.dev_waiting_state_changed.emit(False)
            except Exception:
                pass
        
        engine = self.engine_ref() if self.engine_ref else None
        if engine and hasattr(engine, 'main_window_ref'): # Assuming MainWindow registers itself with engine
            main_window = engine.main_window_ref()
            if main_window and hasattr(main_window, '_update_ui'):
                 logger.debug("Orchestrator delay timeout: Triggering MainWindow._update_ui()")
                 QTimer.singleShot(0, main_window._update_ui) # Schedule UI update

        if not self.is_processing_event and self.event_queue:
            logger.debug("Processing next event from queue after delay.")
            self._process_next_event_from_queue()
        elif not self.is_processing_event and not self.event_queue:
            logger.debug("Queue empty after delay and CM resume signal. Orchestrator idle.")
            # If combat just ended successfully, trigger engine's auto-finalization to switch to narrative mode.
            try:
                engine = self.engine_ref() if self.engine_ref else None
                if engine:
                    from core.interaction.enums import InteractionMode
                    from core.combat.enums import CombatStep, CombatState
                    state_manager = getattr(engine, '_state_manager', None)
                    game_state = state_manager.current_state if state_manager else None
                    if game_state and game_state.current_mode == InteractionMode.COMBAT and getattr(game_state, 'combat_manager', None):
                        cm = game_state.combat_manager
                        if getattr(cm, 'current_step', None) == CombatStep.COMBAT_ENDED and getattr(cm, 'state', None) != CombatState.PLAYER_DEFEAT:
                            QTimer.singleShot(0, engine._finalize_combat_transition_if_needed)
            except Exception as e:
                logger.error(f"Error scheduling automatic post-combat finalization: {e}", exc_info=True)
            # Always notify engine that orchestrator is idle so it can clear any waiting flags
            try:
                self.resume_combat_manager.emit()
            except Exception:
                pass


    def _signal_combat_manager_resume(self) -> bool:
        """Signals CM to resume. Returns True if CM was resumed and is NOT now waiting."""
        combat_manager = self.combat_manager_ref() if self.combat_manager_ref else None
        engine = self.engine_ref() if self.engine_ref else None
        resumed_and_not_waiting_again = False

        if combat_manager and getattr(combat_manager, 'waiting_for_display_completion', False):
            # Do not resume if combat is no longer in progress
            try:
                from core.combat.enums import CombatState
                cm_state = getattr(combat_manager, 'state', None)
                logger.info(f"CombatManager resume check. State: {cm_state.name if cm_state else 'Not available'}")
                if cm_state is not None and cm_state != CombatState.IN_PROGRESS:
                    logger.info(f"CombatManager state is {cm_state.name}, not IN_PROGRESS. Clearing stale events and nudging CM for final messages.")
                    # 1. Clear any stale events from the normal combat flow.
                    self.clear_queue_and_reset_flags()
                    # 2. Nudge the CombatManager to run its final step (_step_ending_combat).
                    #    This will add the correct final messages (loot, conclusion) to the now-clean queue.
                    if engine:
                        QTimer.singleShot(0, lambda: combat_manager.process_combat_step(engine))
                    # 3. Return False because we are not resuming the normal combat loop.
                    return False
            except Exception:
                pass
            logger.info("Signaling CombatManager to resume processing.")
            combat_manager.waiting_for_display_completion = False
            if engine:
                # Use QTimer to allow event loop to process signals first.
                QTimer.singleShot(0, lambda: combat_manager.process_combat_step(engine))
                resumed_and_not_waiting_again = not getattr(combat_manager, 'waiting_for_display_completion', True)
            else:
                logger.error("Cannot resume CombatManager: Engine reference missing.")
        else:
            logger.debug("CombatManager not waiting or not available. No resume signal sent.")
        return resumed_and_not_waiting_again
    
    def clear_queue_and_reset_flags(self):
        """Resets the orchestrator state, typically when combat ends or is forcefully stopped."""
        logger.info("Clearing event queue and resetting orchestrator flags.")
        self.event_queue.clear()
        if self.inter_step_delay_timer.isActive():
            self.inter_step_delay_timer.stop()
        self.is_processing_event = False
        self.is_waiting_for_visual = False
        self.is_waiting_for_tts = False
        self.current_event = None
        # Do not clear combat_manager_ref here, it's managed by set_combat_manager

    def shutdown(self):
        """Called when the engine is shutting down to stop timers."""
        logger.info("Shutting down CombatOutputOrchestrator.")
        self.clear_queue_and_reset_flags()
        self.dev_manual_step_mode = False
        self.dev_waiting_for_next_click = False
        if self.inter_step_delay_timer:
            self.inter_step_delay_timer.timeout.disconnect(self._on_inter_step_delay_timeout)

    def _handle_request_closing_narrative(self, engine: 'GameEngine', metadata: Optional[Dict]):
        """Handles the event to request and queue the closing combat narrative."""
        if not metadata or "outcome" not in metadata:
            logger.error("REQUEST_CLOSING_NARRATIVE missing outcome metadata.")
            # To prevent stalling, we should still allow engine to proceed
            if getattr(engine, '_waiting_for_closing_narrative_display', False):
                 engine._waiting_for_closing_narrative_display = False
            return

        outcome = metadata["outcome"]
        closing_prompt = f"The combat has just ended. The outcome was: {outcome}. Provide a brief, immersive closing narrative (1-2 sentences) describing the aftermath for the player."
        
        llm_narrative = "[Default Closing: The dust settles on the battlefield.]" # Fallback
        if engine._use_llm:
            try:
                logger.info(f"Orchestrator requesting closing combat narrative with prompt: {closing_prompt}")
                from core.game_flow.interaction_core import _build_interaction_context, _get_agent_response
                from core.interaction.enums import InteractionMode
                gs = engine._state_manager.current_state if hasattr(engine, '_state_manager') and engine._state_manager else None
                context = _build_interaction_context(gs, InteractionMode.COMBAT, actor_id=getattr(getattr(gs, 'player', None), 'id', None)) if gs else {}
                agent_output = _get_agent_response(engine, gs, context, closing_prompt, InteractionMode.COMBAT) or {}
                narrative = agent_output.get('narrative')
                if narrative:
                    llm_narrative = narrative
                    logger.info(f"Orchestrator received closing narrative: {llm_narrative[:70]}...")
                else:
                    logger.warning("Failed to generate closing combat narrative from LLM (no narrative).")
            except Exception as e:
                logger.error(f"Error generating closing combat narrative via structured path: {e}", exc_info=True)
        else:
            logger.info("LLM disabled, using default closing narrative.")

        closing_narrative_event = DisplayEvent(
            type=DisplayEventType.NARRATIVE_GENERAL,
            content=llm_narrative,
            role="gm",
            target_display=DisplayTarget.MAIN_GAME_OUTPUT,
            gradual_visual_display=True,
            tts_eligible=True,
            source_step="CLOSING_COMBAT_NARRATIVE"
        )
        # Add to the front of the queue to be processed next
        self.event_queue.appendleft(closing_narrative_event)
        logger.debug(f"Queued closing narrative event: {closing_narrative_event}")

    @Slot(bool)
    def toggle_dev_step_mode(self, enabled: bool) -> None:
        """Enable/disable developer manual step mode."""
        prev = getattr(self, 'dev_manual_step_mode', False)
        self.dev_manual_step_mode = bool(enabled)
        logger.info(f"Developer Step Mode set to {self.dev_manual_step_mode}")
        if prev and not self.dev_manual_step_mode:
            # If we were waiting and dev mode is turned off, release automatically
            if getattr(self, 'dev_waiting_for_next_click', False):
                logger.debug("Developer Step Mode disabled during waiting; auto-releasing next step.")
                self.dev_waiting_for_next_click = False
                try:
                    self.dev_waiting_state_changed.emit(False)
                except Exception:
                    pass
                # Follow normal path depending on last skip decision
                if getattr(self, 'dev_last_skip_delay', False):
                    self._process_next_event_from_queue()
                else:
                    self.inter_step_delay_timer.start(self.config_delay_ms)

    @Slot()
    def dev_release_next_step(self) -> None:
        """When in developer manual step mode, release the next event step."""
        if not getattr(self, 'dev_manual_step_mode', False):
            logger.debug("dev_release_next_step called but Developer Step Mode is OFF. Ignoring.")
            return
        if not getattr(self, 'dev_waiting_for_next_click', False):
            logger.debug("dev_release_next_step called but orchestrator is not waiting.")
            return
        logger.info("Developer Step Mode: releasing next step.")
        self.dev_waiting_for_next_click = False
        try:
            self.dev_waiting_state_changed.emit(False)
        except Exception:
            pass
        # Continue according to the last skip-delay decision
        if getattr(self, 'dev_last_skip_delay', False):
            self._process_next_event_from_queue()
        else:
            self.inter_step_delay_timer.start(self.config_delay_ms)


```

### File: core\orchestration\events.py

```python
"""
Defines event structures for the CombatOutputOrchestrator.
"""
from enum import Enum, auto
from dataclasses import dataclass, field
from typing import Union, Dict, Any, Optional, List
import uuid

class DisplayEventType(Enum):
    """Types of events the CombatOutputOrchestrator can handle."""
    NARRATIVE_ATTEMPT = auto()      # LLM narrative describing an action attempt
    NARRATIVE_IMPACT = auto()       # LLM narrative describing an action's outcome
    NARRATIVE_GENERAL = auto()      # Other general narrative from LLM during combat or post-combat
    SYSTEM_MESSAGE = auto()         # Game system messages (rolls, status changes, turns)
    UI_BAR_UPDATE_PHASE1 = auto()   # Initiate visual phase 1 for HP/Stamina/Mana bar decrease
    UI_BAR_UPDATE_PHASE2 = auto()   # Finalize visual phase 2 for HP/Stamina/Mana bar decrease
    VISUAL_EFFECT_TRIGGER = auto()  # Placeholder for triggering visual effects
    BUFFER_FLUSH = auto()           # Special event to process buffered narrative
    REQUEST_CLOSING_NARRATIVE = auto() # New: Event to trigger LLM call for closing combat summary
    TURN_ORDER_UPDATE = auto()      # New: Event to update turn order displays
    COMBAT_LOG_SET_HTML = auto()    # New: Directly set Combat Log HTML (rehydration)
    APPLY_ENTITY_RESOURCE_UPDATE = auto()  # New: Apply a resource (hp/mp/stamina) change to an entity's model
    APPLY_ENTITY_STATE_UPDATE = auto()     # New: Apply state flags (e.g., is_active_in_combat)
    # Add more event types as needed
    
class DisplayTarget(Enum):
    """Specifies where the display event should be primarily rendered."""
    COMBAT_LOG = auto()
    MAIN_GAME_OUTPUT = auto()
    # UI_ELEMENT (for direct UI manipulations not via text, like bar animations) - handled by metadata for now

@dataclass
class DisplayEvent:
    """
    Represents a piece of information to be displayed to the player,
    managed by the CombatOutputOrchestrator.
    """
    type: DisplayEventType
    content: Union[str, List[str], Dict[str, Any]] # Text, list of texts (for buffer), or data for UI updates
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    role: Optional[str] = "system" # Default role for MainWindow._handle_game_output
    target_display: DisplayTarget = DisplayTarget.COMBAT_LOG
    gradual_visual_display: bool = False # Hint for UI on how to display text
    tts_eligible: bool = False # Whether this content should be spoken by TTS
    source_step: Optional[str] = None # For debugging, e.g., CombatManager's current_step.name
    metadata: Optional[Dict[str, Any]] = None # For UI_BAR_UPDATE, VISUAL_EFFECT, etc.

    def __str__(self):
        content_str = ""
        if isinstance(self.content, list):
            content_str = f"[{len(self.content)} items]"
        elif isinstance(self.content, dict):
            content_str = f"{ {k: str(v)[:20] + '...' if len(str(v)) > 20 else str(v) for k, v in self.content.items()} }"
        else:
            content_str = str(self.content)[:50] + ('...' if len(str(self.content)) > 50 else '')

        return (f"DisplayEvent(id={self.event_id}, type={self.type.name}, target={self.target_display.name}, "
                f"tts={self.tts_eligible}, gradual={self.gradual_visual_display}, content='{content_str}')")
```

### File: core\time\time_controller.py

```python
#!/usr/bin/env python3
"""
TimeController: central policy for world time progression.

- Freezes tick-based time in NARRATIVE, SOCIAL/TRADE, and COMBAT modes
- Centralizes LLM-based increments and post-combat increments
- Reads toggles from config (game.time.tick_enabled, game.time.post_combat_increment_seconds)

This is an architectural clarification on top of Phase 1 where the tick
is already a no-op for time; the controller provides a single source of truth
for time policy decisions.
"""

from typing import Optional

from core.utils.logging_config import get_logger
from core.base.config import get_config

logger = get_logger("TIME_POLICY")


class TimeController:
    _instance: Optional["TimeController"] = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if getattr(self, "_initialized", False):
            return
        self.reload()
        self._initialized = True
        logger.info(
            "TimeController initialized: tick_enabled=%s, post_combat_increment_s=%s",
            self._tick_enabled,
            self._post_combat_increment_s,
        )

    def reload(self) -> None:
        cfg = get_config()
        # Global tick toggle (default False as per Phase 1 policy)
        self._tick_enabled = bool(cfg.get("game.time.tick_enabled", False))
        # Post-combat increment (default 300 seconds = 5 minutes)
        try:
            v = cfg.get("game.time.post_combat_increment_seconds", 300)
            self._post_combat_increment_s = int(v) if v is not None else 300
        except Exception:
            self._post_combat_increment_s = 300

    # Policy checks
    def is_tick_enabled(self) -> bool:
        return self._tick_enabled

    def should_advance_on_tick(self, mode_name: str) -> bool:
        """
        Whether tick should advance world time under the current mode.
        mode_name: InteractionMode name (string), e.g., 'NARRATIVE', 'COMBAT', 'TRADE'
        """
        if not self._tick_enabled:
            return False
        # Freeze for narrative/social/trade/combat
        frozen = {"NARRATIVE", "COMBAT", "TRADE", "SOCIAL_CONFLICT"}
        return mode_name not in frozen

    # Actions
    def apply_llm_increment(self, world, seconds: float) -> None:
        """Advance time due to LLM-declared passage, respecting global toggle but ignoring tick policy."""
        try:
            if not seconds:
                return
            # LLM increments are allowed in all modes by design
            world.advance_time(float(seconds))
        except Exception as e:
            logger.warning("apply_llm_increment failed: %s", e)

    def apply_post_combat_increment(self, world) -> None:
        try:
            inc = float(max(0, self._post_combat_increment_s))
            if inc > 0:
                world.advance_time(inc)
        except Exception as e:
            logger.warning("apply_post_combat_increment failed: %s", e)


# Convenience getter
def get_time_controller() -> TimeController:
    return TimeController()
```

### File: core\utils\dice.py

```python
"""
Dice rolling utilities for the game.
"""

import re
import random
from typing import List, Tuple, Dict, Any, Union, Optional
import logging

logger = logging.getLogger(__name__)

# Regular expression for dice notation, e.g., "2d6+3"
DICE_PATTERN = re.compile(r'(\d+)d(\d+)(?:([\+\-])(\d+))?')


def roll_die(sides: int) -> int:
    """
    Roll a single die with the given number of sides.
    
    Args:
        sides: Number of sides on the die.
        
    Returns:
        The result of the roll.
    """
    return random.randint(1, sides)


def roll_dice(num_dice: int, sides: int) -> List[int]:
    """
    Roll multiple dice with the given number of sides.
    
    Args:
        num_dice: Number of dice to roll.
        sides: Number of sides on each die.
        
    Returns:
        List of individual die results.
    """
    return [roll_die(sides) for _ in range(num_dice)]


def roll_dice_sum(num_dice: int, sides: int) -> int:
    """
    Roll multiple dice and return the sum.
    
    Args:
        num_dice: Number of dice to roll.
        sides: Number of sides on each die.
        
    Returns:
        Sum of all dice rolled.
    """
    return sum(roll_dice(num_dice, sides))


def roll_with_advantage(sides: int) -> Tuple[int, int, int]:
    """
    Roll two dice and take the higher result.
    
    Args:
        sides: Number of sides on each die.
        
    Returns:
        Tuple of (result, roll1, roll2) where result is the higher of roll1 and roll2.
    """
    roll1 = roll_die(sides)
    roll2 = roll_die(sides)
    result = max(roll1, roll2)
    return result, roll1, roll2


def roll_with_disadvantage(sides: int) -> Tuple[int, int, int]:
    """
    Roll two dice and take the lower result.
    
    Args:
        sides: Number of sides on each die.
        
    Returns:
        Tuple of (result, roll1, roll2) where result is the lower of roll1 and roll2.
    """
    roll1 = roll_die(sides)
    roll2 = roll_die(sides)
    result = min(roll1, roll2)
    return result, roll1, roll2


def parse_dice_notation(notation: str) -> Dict[str, Any]:
    """
    Parse a dice notation string (e.g., "2d6+3").
    
    Args:
        notation: The dice notation string.
        
    Returns:
        Dictionary with keys 'num_dice', 'sides', 'modifier_type', and 'modifier_value'.
        
    Raises:
        ValueError: If the notation is invalid.
    """
    match = DICE_PATTERN.match(notation)
    if not match:
        raise ValueError(f"Invalid dice notation: {notation}")
    
    num_dice = int(match.group(1))
    sides = int(match.group(2))
    
    result = {
        'num_dice': num_dice,
        'sides': sides,
        'modifier_type': None,
        'modifier_value': 0
    }
    
    # If there's a modifier
    if match.group(3) and match.group(4):
        result['modifier_type'] = match.group(3)
        result['modifier_value'] = int(match.group(4))
    
    return result


def roll_dice_notation(notation: str, crit_roll: bool = False) -> Dict[str, Any]:
    """
    Roll dice based on D&D-style notation (e.g., "2d6+3", "1d20-1").

    Args:
        notation: The dice notation string.
        crit_roll: If true, doubles the number of dice rolled (for critical hits).

    Returns:
        A dictionary with 'total', 'rolls' (list of individual dice results),
        and 'rolls_str' (string representation of rolls).
    """
    if not isinstance(notation, str) or not notation:
        logger.warning(f"Invalid or empty dice notation received: '{notation}'. Defaulting to 0.")
        return {"total": 0, "rolls": [], "rolls_str": "[]", "modifier": 0, "num_dice": 0, "die_size": 0}

    original_notation = notation
    notation = notation.lower().strip()
    
    num_dice = 1
    die_size = 0
    modifier = 0

    # Regex to parse dice notation: (NdM)(+/-X)
    # It captures:
    #   Group 1: (optional) Number of dice (e.g., "2" in "2d6")
    #   Group 2: Die size (e.g., "6" in "2d6")
    #   Group 3: (optional) Sign of the modifier (+ or -)
    #   Group 4: (optional) Value of the modifier
    match = re.match(r"(\d*)d(\d+)(?:([+\-])(\d+))?", notation)

    if not match:
        # Check if it's just a flat number
        if notation.isdigit() or (notation.startswith('-') and notation[1:].isdigit()):
            flat_value = int(notation)
            logger.debug(f"Interpreting notation '{original_notation}' as flat value: {flat_value}")
            return {"total": flat_value, "rolls": [flat_value], "rolls_str": f"[{flat_value}]", "modifier": 0, "num_dice": 0, "die_size": 0}
        else:
            logger.error(f"Invalid dice notation format: '{original_notation}'")
            raise ValueError(f"Invalid dice notation: {original_notation}")

    groups = match.groups()

    if groups[0]:  # Number of dice specified
        num_dice = int(groups[0])
    
    die_size = int(groups[1])

    if groups[2] and groups[3]:  # Modifier specified
        mod_sign = groups[2]
        mod_value = int(groups[3])
        modifier = mod_value if mod_sign == "+" else -mod_value
        
    if crit_roll:
        num_dice *= 2 # Double the dice for a critical hit
        logger.debug(f"Critical roll: Number of dice doubled to {num_dice} for {original_notation}")

    rolls = [random.randint(1, die_size) for _ in range(num_dice)]
    total_dice_roll = sum(rolls)
    final_total = total_dice_roll + modifier
    
    # --- ECFA Fix: Add 'rolls_str' ---
    rolls_str_representation = str(rolls) # e.g., "[3, 5]"
    # --- End ECFA Fix ---

    logger.debug(f"Rolled {original_notation}{' (crit)' if crit_roll else ''}: Rolls={rolls}, DiceTotal={total_dice_roll}, Mod={modifier}, Final={final_total}")
    
    return {
        "total": final_total, 
        "rolls": rolls,
        "rolls_str": rolls_str_representation, # Added
        "modifier": modifier,
        "num_dice": num_dice,
        "die_size": die_size
    }


def calculate_success_probability(
    target_number: int,
    dice_notation: str,
    advantage: bool = False,
    disadvantage: bool = False
) -> float:
    """
    Calculate the probability of rolling at or above a target number.
    
    Args:
        target_number: The number to meet or exceed.
        dice_notation: The dice notation string.
        advantage: Whether the roll has advantage (roll twice, take higher).
        disadvantage: Whether the roll has disadvantage (roll twice, take lower).
        
    Returns:
        Probability of success as a value between 0 and 1.
        
    Raises:
        ValueError: If the notation is invalid or if both advantage and disadvantage are True.
    """
    if advantage and disadvantage:
        raise ValueError("Cannot have both advantage and disadvantage")
    
    parsed = parse_dice_notation(dice_notation)
    num_dice = parsed['num_dice']
    sides = parsed['sides']
    
    # Apply modifier to target number
    if parsed['modifier_type'] == '+':
        adjusted_target = target_number - parsed['modifier_value']
    elif parsed['modifier_type'] == '-':
        adjusted_target = target_number + parsed['modifier_value']
    else:
        adjusted_target = target_number
    
    # Ensure target is within possible range
    min_roll = num_dice
    max_roll = num_dice * sides
    
    if adjusted_target <= min_roll:
        return 1.0  # Always succeed
    if adjusted_target > max_roll:
        return 0.0  # Always fail
    
    # For single die, calculation is simple
    if num_dice == 1:
        success_range = sides - adjusted_target + 1
        probability = success_range / sides
        
        if advantage:
            # Probability of at least one success in two rolls
            return 1 - (1 - probability) ** 2
        elif disadvantage:
            # Probability of success in both rolls
            return probability ** 2
        else:
            return probability
    
    # For multiple dice, use a simplified estimate for common cases
    # In a proper implementation, we'd use a more sophisticated approach
    # to calculate the exact probability distribution
    
    # Average roll for XdY is X * (Y+1)/2
    average_roll = num_dice * (sides + 1) / 2
    
    # Standard deviation (approximation for sum of dice)
    std_dev = (num_dice * (sides ** 2 - 1) / 12) ** 0.5
    
    # Normalize the target
    z_score = (adjusted_target - average_roll) / std_dev
    
    # Approximate probability using normal distribution
    # This is a rough approximation and works better with more dice
    import math
    probability = 0.5 * (1 - math.erf(z_score / math.sqrt(2)))
    
    if advantage:
        return 1 - (1 - probability) ** 2
    elif disadvantage:
        return probability ** 2
    else:
        return probability


def roll_critical(dice_notation: str, critical_multiplier: int = 2) -> Dict[str, Any]:
    """
    Roll dice with a critical hit (typically doubling the number of dice).
    
    Args:
        dice_notation: The dice notation string.
        critical_multiplier: The multiplier for the number of dice (default: 2).
        
    Returns:
        Dictionary with roll information.
        
    Raises:
        ValueError: If the notation is invalid.
    """
    parsed = parse_dice_notation(dice_notation)
    
    # For a critical hit, we multiply the number of dice
    critical_num_dice = parsed['num_dice'] * critical_multiplier
    
    # Roll the critical dice
    rolls = roll_dice(critical_num_dice, parsed['sides'])
    roll_sum = sum(rolls)
    
    # Apply modifier (usually only once, even on criticals)
    if parsed['modifier_type'] == '+':
        total = roll_sum + parsed['modifier_value']
    elif parsed['modifier_type'] == '-':
        total = roll_sum - parsed['modifier_value']
    else:
        total = roll_sum
    
    result = {
        'rolls': rolls,
        'total': total,
        'original_notation': dice_notation,
        'critical_num_dice': critical_num_dice,
        'sides': parsed['sides'],
        'modifier_type': parsed['modifier_type'],
        'modifier_value': parsed['modifier_value'],
        'critical_multiplier': critical_multiplier
    }
    
    log_str = f"Critical hit! Rolled {critical_num_dice}d{parsed['sides']}: {rolls}"
    if parsed['modifier_type']:
        log_str += f" {parsed['modifier_type']}{parsed['modifier_value']}"
    log_str += f" = {total}"
    logger.debug(log_str)
    
    return result


def check_success(roll: int, dc: int, is_attack: bool = False) -> Tuple[bool, bool, bool]:
    """
    Checks if a roll (d20 portion) is successful against a DC, 
    also determining critical success or fumble if it's an attack.

    Args:
        roll: The raw d20 dice roll result (1-20).
        dc: The difficulty class to beat.
        is_attack: If True, applies critical success (nat 20) and fumble (nat 1) rules.

    Returns:
        A tuple: (success_bool, is_critical_bool, is_fumble_bool).
        'success_bool' here is based on raw roll vs DC, primarily for non-attack skill checks.
        For attacks, the caller typically uses the total modified roll to determine final success,
        but uses is_critical and is_fumble from this function.
    """
    is_critical = False
    is_fumble = False

    if is_attack:
        if roll == 20:
            is_critical = True
          
            return True, is_critical, is_fumble
        if roll == 1:
            is_fumble = True
            return False, is_critical, is_fumble
    
 
    success = (roll >= dc)
    
    return success, is_critical, is_fumble

```

### File: core\utils\dotdict.py

```python
#!/usr/bin/env python3
"""
DotDict utility for the RPG game.

This module provides a dictionary subclass that allows accessing keys
using dot notation (e.g., d.key instead of d['key']).
"""

from typing import Any, Dict, List, Optional, Set, Tuple, Union
import logging

from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

class DotDict(dict):
    """
    Dictionary that supports dot notation access to keys.
    
    This class extends the built-in dict to allow accessing keys
    using dot notation (e.g., d.key instead of d['key']). It also
    automatically converts nested dictionaries to DotDict objects.
    """
    
    def __init__(self, *args, **kwargs):
        """
        Initialize a DotDict.
        
        Args:
            *args: Arguments to pass to dict.__init__.
            **kwargs: Keyword arguments to pass to dict.__init__.
        """
        super().__init__(*args, **kwargs)
        # Convert nested dictionaries to DotDict objects
        self.__convert_nested_dicts()
    
    def __convert_nested_dicts(self):
        """Convert nested dictionaries to DotDict objects."""
        for key, value in self.items():
            if isinstance(value, dict) and not isinstance(value, DotDict):
                self[key] = DotDict(value)
            elif isinstance(value, list):
                self[key] = [
                    DotDict(item) if isinstance(item, dict) and not isinstance(item, DotDict) else item
                    for item in value
                ]
    
    def __getattr__(self, key: str) -> Any:
        """
        Get an attribute (key) from the dictionary.
        
        This method is called when an attribute is accessed that doesn't
        exist in the instance's __dict__. It looks up the key in the
        dictionary instead.
        
        Args:
            key: The attribute (key) to get.
        
        Returns:
            The value associated with the key.
        
        Raises:
            AttributeError: If the key is not in the dictionary.
        """
        try:
            return self[key]
        except KeyError:
            raise AttributeError(f"'DotDict' object has no attribute '{key}'")
    
    def __setattr__(self, key: str, value: Any) -> None:
        """
        Set an attribute (key) in the dictionary.
        
        Args:
            key: The attribute (key) to set.
            value: The value to set.
        """
        self[key] = value
        
        # Convert to DotDict if it's a dict
        if isinstance(value, dict) and not isinstance(value, DotDict):
            self[key] = DotDict(value)
    
    def __delattr__(self, key: str) -> None:
        """
        Delete an attribute (key) from the dictionary.
        
        Args:
            key: The attribute (key) to delete.
        
        Raises:
            AttributeError: If the key is not in the dictionary.
        """
        try:
            del self[key]
        except KeyError:
            raise AttributeError(f"'DotDict' object has no attribute '{key}'")
    
    def get(self, key: str, default: Any = None) -> Any:
        """
        Get a value from the dictionary with a default.
        
        Similar to dict.get, but supports dot notation for nested keys.
        
        Args:
            key: The key to get. Can be a dot-separated path (e.g., 'a.b.c').
            default: The default value to return if the key is not found.
        
        Returns:
            The value associated with the key, or the default if not found.
        """
        if "." not in key:
            return super().get(key, default)
        
        # Handle nested keys
        parts = key.split(".")
        current = self
        
        for part in parts[:-1]:
            if part not in current or not isinstance(current[part], (dict, DotDict)):
                return default
            current = current[part]
        
        return current.get(parts[-1], default)
    
    def set(self, key: str, value: Any) -> None:
        """
        Set a value in the dictionary.
        
        Supports dot notation for nested keys, creating intermediate
        dictionaries as needed.
        
        Args:
            key: The key to set. Can be a dot-separated path (e.g., 'a.b.c').
            value: The value to set.
        """
        if "." not in key:
            self[key] = value
            if isinstance(value, dict) and not isinstance(value, DotDict):
                self[key] = DotDict(value)
            return
        
        # Handle nested keys
        parts = key.split(".")
        current = self
        
        for part in parts[:-1]:
            if part not in current:
                current[part] = DotDict()
            elif not isinstance(current[part], (dict, DotDict)):
                current[part] = DotDict()
            current = current[part]
        
        current[parts[-1]] = value
        if isinstance(value, dict) and not isinstance(value, DotDict):
            current[parts[-1]] = DotDict(value)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the DotDict to a regular dictionary.
        
        This method recursively converts all nested DotDict objects to
        regular dictionaries.
        
        Returns:
            A regular dictionary.
        """
        result = {}
        
        for key, value in self.items():
            if isinstance(value, DotDict):
                result[key] = value.to_dict()
            elif isinstance(value, list):
                result[key] = [
                    item.to_dict() if isinstance(item, DotDict) else item
                    for item in value
                ]
            else:
                result[key] = value
        
        return result
    
    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> 'DotDict':
        """
        Create a DotDict from a regular dictionary.
        
        Args:
            d: The dictionary to convert.
        
        Returns:
            A DotDict with the same keys and values.
        """
        return cls(d)


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create a DotDict
    config = DotDict({
        "game": {
            "title": "RPG Game",
            "version": "0.1.0",
            "settings": {
                "difficulty": "normal",
                "sound": {
                    "volume": 0.8,
                    "music": True,
                    "effects": True
                }
            }
        },
        "player": {
            "name": "Test Player",
            "stats": {
                "health": 100,
                "mana": 50
            },
            "inventory": [
                {"name": "Sword", "damage": 10},
                {"name": "Potion", "healing": 25}
            ]
        }
    })
    
    # Access values using dot notation
    print(f"Game title: {config.game.title}")
    print(f"Game version: {config.game.version}")
    print(f"Sound volume: {config.game.settings.sound.volume}")
    print(f"Player name: {config.player.name}")
    print(f"Player health: {config.player.stats.health}")
    
    # Access nested list items (these remain list items, not DotDicts)
    print(f"First inventory item: {config.player.inventory[0].name}")
    
    # Set values using dot notation
    config.player.stats.health = 90
    print(f"Updated player health: {config.player.stats.health}")
    
    # Add new keys
    config.game.settings.graphics = DotDict({"quality": "high", "fullscreen": True})
    print(f"Graphics quality: {config.game.settings.graphics.quality}")
    
    # Use get with dot notation for nested keys
    fps = config.get("game.settings.graphics.fps", 60)
    print(f"FPS: {fps}")
    
    # Use set with dot notation for nested keys
    config.set("game.settings.graphics.fps", 120)
    print(f"Updated FPS: {config.game.settings.graphics.fps}")
    
    # Convert back to dict
    regular_dict = config.to_dict()
    print(f"Regular dict: {type(regular_dict)}")
    
    # Create from dict
    new_config = DotDict.from_dict({"test": {"value": 42}})
    print(f"New config test value: {new_config.test.value}")
```

### File: core\utils\enhanced_time_manager.py

```python
#!/usr/bin/env python3
"""
Enhanced time management system for the RPG game.

This module provides rich, narrative time descriptions while keeping 
actual game time tracking in the background. It replaces clock-based
time references with immersive descriptive periods.
"""

import random
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

from core.utils.logging_config import get_logger
from core.utils.time_utils import game_time_to_datetime, GAME_EPOCH
from core.base.config import get_config

logger = get_logger("TIME_MANAGER")


class TimePeriod(Enum):
    """Time periods for narrative descriptions."""
    DEEP_NIGHT = "deep_night"        # 0:00-4:00
    PRE_DAWN = "pre_dawn"            # 4:00-5:00  
    DAWN = "dawn"                    # 5:00-7:00
    MORNING = "morning"              # 7:00-11:00
    NOON = "noon"                    # 11:00-13:00
    AFTERNOON = "afternoon"          # 13:00-17:00
    EVENING = "evening"              # 17:00-20:00
    SUNSET = "sunset"                # 20:00-21:00
    NIGHT = "night"                  # 21:00-24:00


@dataclass
class TimeDescription:
    """A rich time description with multiple variants."""
    primary: str                     # Main description
    variants: List[str]             # Alternative descriptions
    atmospheric: List[str]          # Atmospheric descriptions
    seasonal_modifiers: Dict[str, List[str]]  # Season-specific variants


class EnhancedTimeManager:
    """
    Manages rich, narrative time descriptions for the RPG game.
    
    This class converts game time into immersive narrative descriptions,
    avoiding clock-based references that break immersion.
    """
    
    def __init__(self):
        """Initialize the enhanced time manager."""
        self._time_descriptions = self._initialize_time_descriptions()
        self._last_description_cache = {}  # Cache to avoid repetition
        
    def _initialize_time_descriptions(self) -> Dict[TimePeriod, TimeDescription]:
        """Initialize the comprehensive time description database."""
        return {
            TimePeriod.DEEP_NIGHT: TimeDescription(
                primary="deep night",
                variants=[
                    "the depths of night",
                    "the small hours", 
                    "the darkest hours",
                    "the dead of night",
                    "the quiet hours"
                ],
                atmospheric=[
                    "when shadows reign supreme",
                    "while the world sleeps",
                    "in the hushed darkness",
                    "beneath the star-filled sky",
                    "when only creatures of the night stir"
                ],
                seasonal_modifiers={
                    "Winter": ["the bitter night", "the frost-touched darkness"],
                    "Summer": ["the warm night air", "the gentle darkness"],
                    "Spring": ["the crisp night", "the awakening darkness"], 
                    "Fall": ["the cool night", "the harvest-time darkness"]
                }
            ),
            
            TimePeriod.PRE_DAWN: TimeDescription(
                primary="the hours before dawn",
                variants=[
                    "the pre-dawn darkness",
                    "the final hours of night",
                    "just before daybreak",
                    "the threshold of dawn"
                ],
                atmospheric=[
                    "when the world holds its breath",
                    "as night prepares to yield to day",
                    "in the expectant darkness",
                    "when the eastern sky begins to stir"
                ],
                seasonal_modifiers={
                    "Winter": ["the bitter pre-dawn", "before winter's pale sunrise"],
                    "Summer": ["the gentle pre-dawn", "before summer's golden sunrise"],
                    "Spring": ["the fresh pre-dawn", "before spring's bright sunrise"],
                    "Fall": ["the crisp pre-dawn", "before autumn's misty sunrise"]
                }
            ),
            
            TimePeriod.DAWN: TimeDescription(
                primary="dawn",
                variants=[
                    "daybreak",
                    "sunrise", 
                    "the break of day",
                    "first light",
                    "the dawn's early light",
                    "the morning's first breath"
                ],
                atmospheric=[
                    "as the first rays pierce the darkness",
                    "when the eastern sky blooms with color",
                    "as night surrenders to day",
                    "when shadows begin their retreat",
                    "as the world awakens from slumber"
                ],
                seasonal_modifiers={
                    "Winter": ["the pale winter dawn", "dawn's cold embrace"],
                    "Summer": ["the golden summer sunrise", "dawn's warm caress"],
                    "Spring": ["the vibrant spring daybreak", "dawn's fresh kiss"],
                    "Fall": ["the misty autumn sunrise", "dawn's gentle touch"]
                }
            ),
            
            TimePeriod.MORNING: TimeDescription(
                primary="morning",
                variants=[
                    "early morning",
                    "mid-morning", 
                    "late morning",
                    "the morning hours",
                    "forenoon"
                ],
                atmospheric=[
                    "as the day gains strength",
                    "when morning mist dances",
                    "while dew still glitters",
                    "as the world comes alive",
                    "when birdsong fills the air"
                ],
                seasonal_modifiers={
                    "Winter": ["the crisp winter morning", "morning's frost-kissed air"],
                    "Summer": ["the bright summer morning", "morning's warm embrace"],
                    "Spring": ["the fresh spring morning", "morning's renewed energy"],
                    "Fall": ["the cool autumn morning", "morning's harvest scents"]
                }
            ),
            
            TimePeriod.NOON: TimeDescription(
                primary="midday",
                variants=[
                    "noon",
                    "the height of day",
                    "high noon",
                    "the meridian hour",
                    "when the sun stands highest"
                ],
                atmospheric=[
                    "when shadows grow short",
                    "as the sun reaches its peak",
                    "when the day blazes brightest",
                    "at the pinnacle of daylight",
                    "when the world basks in full sunlight"
                ],
                seasonal_modifiers={
                    "Winter": ["the pale winter noon", "midday's weak warmth"],
                    "Summer": ["the blazing summer noon", "midday's intense heat"],
                    "Spring": ["the pleasant spring midday", "noon's gentle warmth"],
                    "Fall": ["the mellow autumn noon", "midday's golden light"]
                }
            ),
            
            TimePeriod.AFTERNOON: TimeDescription(
                primary="afternoon",
                variants=[
                    "early afternoon",
                    "mid-afternoon",
                    "late afternoon", 
                    "the afternoon hours",
                    "post-meridian"
                ],
                atmospheric=[
                    "as the day matures",
                    "when shadows begin to lengthen",
                    "while warmth lingers in the air",
                    "as the sun starts its descent",
                    "when the day grows contemplative"
                ],
                seasonal_modifiers={
                    "Winter": ["the short winter afternoon", "afternoon's fleeting warmth"],
                    "Summer": ["the long summer afternoon", "afternoon's lingering heat"],
                    "Spring": ["the pleasant spring afternoon", "afternoon's mild air"],
                    "Fall": ["the golden autumn afternoon", "afternoon's harvest light"]
                }
            ),
            
            TimePeriod.EVENING: TimeDescription(
                primary="evening",
                variants=[
                    "early evening",
                    "late evening",
                    "the evening hours",
                    "eventide",
                    "vespers"
                ],
                atmospheric=[
                    "as day begins to fade",
                    "when shadows grow long",
                    "as the world prepares for rest",
                    "while daylight softens",
                    "when peace settles over the land"
                ],
                seasonal_modifiers={
                    "Winter": ["the early winter evening", "evening's cold embrace"],
                    "Summer": ["the long summer evening", "evening's gentle coolness"],
                    "Spring": ["the mild spring evening", "evening's fresh air"],
                    "Fall": ["the crisp autumn evening", "evening's harvest moon"]
                }
            ),
            
            TimePeriod.SUNSET: TimeDescription(
                primary="sunset",
                variants=[
                    "dusk",
                    "twilight",
                    "gloaming", 
                    "the dying of the light",
                    "day's end",
                    "the sunset hour"
                ],
                atmospheric=[
                    "as the sky burns with color",
                    "when day surrenders to night",
                    "as golden light fades to purple",
                    "while the sun kisses the horizon",
                    "when the world is painted in fire"
                ],
                seasonal_modifiers={
                    "Winter": ["the brief winter sunset", "dusk's cold beauty"],
                    "Summer": ["the spectacular summer sunset", "twilight's warm glow"],
                    "Spring": ["the hopeful spring sunset", "dusk's fresh promise"],
                    "Fall": ["the magnificent autumn sunset", "twilight's golden glory"]
                }
            ),
            
            TimePeriod.NIGHT: TimeDescription(
                primary="night",
                variants=[
                    "early night",
                    "nightfall",
                    "the night hours",
                    "darkness",
                    "nocturne"
                ],
                atmospheric=[
                    "as darkness claims the land",
                    "when stars begin to twinkle",
                    "while night creatures stir",
                    "as the moon rises",
                    "when the world grows quiet"
                ],
                seasonal_modifiers={
                    "Winter": ["the long winter night", "night's frozen stillness"],
                    "Summer": ["the short summer night", "night's gentle coolness"],
                    "Spring": ["the mild spring night", "night's awakening energy"],
                    "Fall": ["the crisp autumn night", "night's harvest mystery"]
                }
            )
        }
    
    def get_time_period(self, game_time: float) -> TimePeriod:
        """
        Determine the narrative time period from game time.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            The appropriate TimePeriod enum value
        """
        # Compute an effective 24h hour-of-day based on configured day length
        try:
            cfg = get_config()
            units = cfg.get("calendar.units", {}) or {}
            day_len = int(units.get("day_length_seconds", 86400))
            if day_len <= 0:
                day_len = 86400
            secs_in_day = game_time % day_len
            # Map fraction of day to a 24h-style hour for period selection
            hour = int((secs_in_day / float(day_len)) * 24.0)
        except Exception:
            # Fallback to datetime mapping
            dt = game_time_to_datetime(game_time, GAME_EPOCH)
            hour = dt.hour
        
        if 0 <= hour < 4:
            return TimePeriod.DEEP_NIGHT
        elif 4 <= hour < 5:
            return TimePeriod.PRE_DAWN
        elif 5 <= hour < 7:
            return TimePeriod.DAWN
        elif 7 <= hour < 11:
            return TimePeriod.MORNING
        elif 11 <= hour < 13:
            return TimePeriod.NOON
        elif 13 <= hour < 17:
            return TimePeriod.AFTERNOON
        elif 17 <= hour < 20:
            return TimePeriod.EVENING
        elif 20 <= hour < 21:
            return TimePeriod.SUNSET
        else:  # 21 <= hour < 24
            return TimePeriod.NIGHT
    
    def get_time_description(self, game_time: float, 
                           style: str = "primary", 
                           season: Optional[str] = None,
                           avoid_repetition: bool = True) -> str:
        """
        Get a rich narrative description of the current time.
        
        Args:
            game_time: Game time in seconds since epoch
            style: Description style - "primary", "variant", "atmospheric", "seasonal"
            season: Current season for seasonal modifiers
            avoid_repetition: Whether to avoid recently used descriptions
            
        Returns:
            A narrative time description string
        """
        period = self.get_time_period(game_time)
        description_data = self._time_descriptions[period]
        
        # Build available descriptions based on style
        available_descriptions = []
        
        if style in ["primary", "any"]:
            available_descriptions.append(description_data.primary)
            
        if style in ["variant", "any"]:
            available_descriptions.extend(description_data.variants)
            
        if style in ["atmospheric", "any"]:
            available_descriptions.extend(description_data.atmospheric)
            
        if style == "seasonal" and season and season in description_data.seasonal_modifiers:
            available_descriptions.extend(description_data.seasonal_modifiers[season])
        elif style == "any" and season and season in description_data.seasonal_modifiers:
            available_descriptions.extend(description_data.seasonal_modifiers[season])
        
        # If no descriptions available, fall back to primary
        if not available_descriptions:
            available_descriptions = [description_data.primary]
        
        # Avoid repetition if requested
        if avoid_repetition:
            cache_key = f"{period.value}_{style}"
            recently_used = self._last_description_cache.get(cache_key, [])
            
            # Filter out recently used descriptions
            fresh_descriptions = [d for d in available_descriptions if d not in recently_used]
            if fresh_descriptions:
                available_descriptions = fresh_descriptions
            
            # Select description
            selected = random.choice(available_descriptions)
            
            # Update cache (keep last 3 descriptions)
            recently_used.append(selected)
            if len(recently_used) > 3:
                recently_used.pop(0)
            self._last_description_cache[cache_key] = recently_used
            
            return selected
        else:
            return random.choice(available_descriptions)
    
    def get_contextual_time(self, game_time: float, 
                          context: str = "general",
                          season: Optional[str] = None) -> str:
        """
        Get a contextually appropriate time description.
        
        Args:
            game_time: Game time in seconds since epoch
            context: Context type - "general", "narrative", "combat", "social"
            season: Current season
            
        Returns:
            A contextually appropriate time description
        """
        if context == "narrative":
            return self.get_time_description(game_time, "atmospheric", season)
        elif context == "combat":
            return self.get_time_description(game_time, "primary", season)
        elif context == "social":
            return self.get_time_description(game_time, "variant", season)
        else:
            return self.get_time_description(game_time, "any", season)
    
    def is_daylight_period(self, game_time: float) -> bool:
        """
        Check if the current time is considered daylight.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            True if it's a daylight period, False otherwise
        """
        period = self.get_time_period(game_time)
        daylight_periods = {
            TimePeriod.DAWN, TimePeriod.MORNING, 
            TimePeriod.NOON, TimePeriod.AFTERNOON
        }
        return period in daylight_periods
    
    def is_night_period(self, game_time: float) -> bool:
        """
        Check if the current time is considered nighttime.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            True if it's a night period, False otherwise
        """
        period = self.get_time_period(game_time)
        night_periods = {
            TimePeriod.DEEP_NIGHT, TimePeriod.PRE_DAWN,
            TimePeriod.SUNSET, TimePeriod.NIGHT
        }
        return period in night_periods
    
    def is_transition_period(self, game_time: float) -> bool:
        """
        Check if the current time is a transition period (dawn/dusk).
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            True if it's a transition period, False otherwise
        """
        period = self.get_time_period(game_time)
        return period in {TimePeriod.DAWN, TimePeriod.SUNSET}
    
    def get_period_info(self, game_time: float) -> Dict[str, any]:
        """
        Get comprehensive information about the current time period.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            Dictionary with period information
        """
        period = self.get_time_period(game_time)
        
        return {
            "period": period.value,
            "is_daylight": self.is_daylight_period(game_time),
            "is_night": self.is_night_period(game_time),
            "is_transition": self.is_transition_period(game_time),
            "description": self.get_time_description(game_time),
            "atmospheric_description": self.get_time_description(game_time, "atmospheric"),
        }


# Singleton instance
_time_manager_instance = None


def get_enhanced_time_manager() -> EnhancedTimeManager:
    """
    Get the singleton instance of the Enhanced Time Manager.
    
    Returns:
        The EnhancedTimeManager singleton instance
    """
    global _time_manager_instance
    if _time_manager_instance is None:
        _time_manager_instance = EnhancedTimeManager()
        logger.info("Enhanced Time Manager initialized")
    return _time_manager_instance


# Convenience functions for easy integration
def get_narrative_time(game_time: float, season: Optional[str] = None) -> str:
    """Get a narrative time description for the given game time."""
    return get_enhanced_time_manager().get_contextual_time(game_time, "narrative", season)


def get_simple_time(game_time: float, season: Optional[str] = None) -> str:
    """Get a simple time description for the given game time."""
    return get_enhanced_time_manager().get_time_description(game_time, "primary", season)


def is_daylight(game_time: float) -> bool:
    """Check if the given game time is during daylight hours."""
    return get_enhanced_time_manager().is_daylight_period(game_time)


def is_nighttime(game_time: float) -> bool:
    """Check if the given game time is during nighttime hours."""
    return get_enhanced_time_manager().is_night_period(game_time)


if __name__ == "__main__":
    # Example usage and testing
    import time
    from core.utils.time_utils import DAY, HOUR
    
    # Test different times of day
    test_times = [
        (2 * HOUR, "Deep Night"),
        (5 * HOUR, "Dawn"), 
        (9 * HOUR, "Morning"),
        (12 * HOUR, "Noon"),
        (15 * HOUR, "Afternoon"),
        (18 * HOUR, "Evening"),
        (20.5 * HOUR, "Sunset"),
        (22 * HOUR, "Night")
    ]
    
    manager = get_enhanced_time_manager()
    
    print("=== Enhanced Time Manager Test ===\n")
    
    for game_time, label in test_times:
        print(f"{label} ({game_time/HOUR:.1f}h):")
        print(f"  Primary: {manager.get_time_description(game_time, 'primary')}")
        print(f"  Variant: {manager.get_time_description(game_time, 'variant')}")
        print(f"  Atmospheric: {manager.get_time_description(game_time, 'atmospheric')}")
        print(f"  Seasonal (Spring): {manager.get_time_description(game_time, 'seasonal', 'Spring')}")
        print(f"  Contextual: {manager.get_contextual_time(game_time, 'narrative', 'Spring')}")
        print(f"  Is Daylight: {manager.is_daylight_period(game_time)}")
        print()
```

### File: core\utils\json_utils.py

```python
#!/usr/bin/env python3
"""
JSON utilities for the RPG game.

This module provides enhanced JSON encoding/decoding capabilities
for handling complex data types used throughout the application.
"""

import json
import uuid
import dataclasses
import datetime
import enum
from typing import Any, Dict, List, Set, Tuple, Union, Optional
import logging

# Get the module logger
logger = logging.getLogger(__name__)

class EnhancedJSONEncoder(json.JSONEncoder):
    """Enhanced JSON encoder to handle various Python types."""
    
    def default(self, obj: Any) -> Any:
        """Convert Python objects to JSON serializable types."""
        # Handle dataclasses
        if dataclasses.is_dataclass(obj):
            return {
                "_type": f"{obj.__class__.__module__}.{obj.__class__.__name__}",
                "_data": {f.name: getattr(obj, f.name) for f in dataclasses.fields(obj)}
            }
        
        # Handle enums
        if isinstance(obj, enum.Enum):
            return {
                "_type": "enum",
                "_class": f"{obj.__class__.__module__}.{obj.__class__.__name__}",
                "_name": obj.name,
                "_value": obj.value
            }
        
        # Handle datetime objects
        if isinstance(obj, datetime.datetime):
            return {
                "_type": "datetime",
                "_value": obj.isoformat()
            }
        
        # Handle date objects
        if isinstance(obj, datetime.date):
            return {
                "_type": "date",
                "_value": obj.isoformat()
            }
        
        # Handle time objects
        if isinstance(obj, datetime.time):
            return {
                "_type": "time",
                "_value": obj.isoformat()
            }
        
        # Handle UUID objects
        if isinstance(obj, uuid.UUID):
            return {
                "_type": "uuid",
                "_value": str(obj)
            }
        
        # Handle sets
        if isinstance(obj, set):
            return {
                "_type": "set",
                "_value": list(obj)
            }
        
        # Handle any object with a to_dict method
        if hasattr(obj, "to_dict") and callable(getattr(obj, "to_dict")):
            result = obj.to_dict()
            result["_type"] = f"{obj.__class__.__module__}.{obj.__class__.__name__}"
            return result
        
        # Let the parent class handle the rest
        try:
            return super().default(obj)
        except TypeError as e:
            logger.warning(f"Could not JSON serialize {type(obj)}: {e}")
            return str(obj)  # Fallback to string representation


class EnhancedJSONDecoder(json.JSONDecoder):
    """Enhanced JSON decoder to reconstruct Python objects from JSON."""
    
    def __init__(self, *args, **kwargs):
        """Initialize the decoder with custom object hook."""
        kwargs["object_hook"] = self._object_hook
        super().__init__(*args, **kwargs)
    
    def _object_hook(self, obj: Dict[str, Any]) -> Any:
        """Convert JSON objects back to Python objects."""
        # Check if this is a specially encoded object
        if "_type" not in obj:
            return obj
        
        obj_type = obj["_type"]
        
        # Handle enums
        if obj_type == "enum":
            try:
                module_name, class_name = obj["_class"].rsplit(".", 1)
                module = __import__(module_name, fromlist=[class_name])
                enum_class = getattr(module, class_name)
                return enum_class[obj["_name"]]
            except (ImportError, AttributeError, KeyError) as e:
                logger.warning(f"Could not decode enum: {e}")
                return obj
        
        # Handle datetime objects
        if obj_type == "datetime":
            return datetime.datetime.fromisoformat(obj["_value"])
        
        # Handle date objects
        if obj_type == "date":
            return datetime.date.fromisoformat(obj["_value"])
        
        # Handle time objects
        if obj_type == "time":
            return datetime.time.fromisoformat(obj["_value"])
        
        # Handle UUID objects
        if obj_type == "uuid":
            return uuid.UUID(obj["_value"])
        
        # Handle sets
        if obj_type == "set":
            return set(obj["_value"])
        
        # Handle dataclasses and other custom objects
        try:
            module_name, class_name = obj_type.rsplit(".", 1)
            module = __import__(module_name, fromlist=[class_name])
            cls = getattr(module, class_name)
            
            # If it's a dataclass
            if dataclasses.is_dataclass(cls):
                return cls(**obj["_data"])
            
            # If it has a from_dict method
            if hasattr(cls, "from_dict") and callable(getattr(cls, "from_dict")):
                # Remove the _type field first
                obj_copy = obj.copy()
                obj_copy.pop("_type")
                return cls.from_dict(obj_copy)
        except (ImportError, AttributeError, ValueError) as e:
            logger.warning(f"Could not decode custom object: {e}")
        
        # Return the original object if we couldn't decode it
        return obj


# Utility functions

def to_json(obj: Any, pretty: bool = False) -> str:
    """Convert an object to a JSON string."""
    indent = 4 if pretty else None
    try:
        return json.dumps(obj, cls=EnhancedJSONEncoder, indent=indent)
    except Exception as e:
        logger.error(f"Error serializing to JSON: {e}")
        raise


def from_json(json_str: str) -> Any:
    """Convert a JSON string back to Python objects."""
    try:
        return json.loads(json_str, cls=EnhancedJSONDecoder)
    except Exception as e:
        logger.error(f"Error deserializing from JSON: {e}")
        raise


def save_json(obj: Any, file_path: str, pretty: bool = True) -> None:
    """Save an object to a JSON file."""
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(obj, f, cls=EnhancedJSONEncoder, indent=4 if pretty else None)
    except Exception as e:
        logger.error(f"Error saving JSON to {file_path}: {e}")
        raise


def load_json(file_path: str) -> Any:
    """Load an object from a JSON file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return json.load(f, cls=EnhancedJSONDecoder)
    except Exception as e:
        logger.error(f"Error loading JSON from {file_path}: {e}")
        raise


# Add alias functions for compatibility with save_manager.py
def enhanced_json_dumps(obj: Any, indent: Optional[int] = None) -> str:
    """Alias for to_json for compatibility with save_manager."""
    return to_json(obj, pretty=indent is not None)


def enhanced_json_loads(json_str: str) -> Any:
    """Alias for from_json for compatibility with save_manager."""
    return from_json(json_str)


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Example dataclass
    @dataclasses.dataclass
    class Person:
        name: str
        age: int
        created_at: datetime.datetime = dataclasses.field(
            default_factory=lambda: datetime.datetime.now()
        )
        id: uuid.UUID = dataclasses.field(
            default_factory=uuid.uuid4
        )
        tags: Set[str] = dataclasses.field(default_factory=set)
    
    # Example enum
    class Color(enum.Enum):
        RED = 1
        GREEN = 2
        BLUE = 3
    
    # Create test objects
    person = Person(name="Alice", age=30)
    person.tags.add("player")
    person.tags.add("admin")
    
    favorite_color = Color.BLUE
    
    # Test serialization
    data = {
        "person": person,
        "favorite_color": favorite_color,
        "current_time": datetime.datetime.now(),
        "settings": {
            "debug": True,
            "volume": 0.8
        }
    }
    
    # Serialize to JSON
    json_str = to_json(data, pretty=True)
    print("Serialized JSON:")
    print(json_str)
    
    # Deserialize from JSON
    restored_data = from_json(json_str)
    print("\nDeserialized data:")
    print(f"Person name: {restored_data['person'].name}")
    print(f"Person age: {restored_data['person'].age}")
    print(f"Person created at: {restored_data['person'].created_at}")
    print(f"Person ID: {restored_data['person'].id}")
    print(f"Person tags: {restored_data['person'].tags}")
    print(f"Favorite color: {restored_data['favorite_color']}")
    print(f"Current time: {restored_data['current_time']}")
    print(f"Settings: {restored_data['settings']}")
```

### File: core\utils\logging_config.py

```python
"""
Logging configuration for the game.
"""

import os
import logging
import logging.handlers
import time
from typing import Dict, Optional

# Global configuration
DEFAULT_LEVEL = logging.DEBUG
LOGGERS: Dict[str, logging.Logger] = {}
LOGGER_FORMAT = '%(asctime)s [%(name)s] %(levelname)s: %(message)s'
DATE_FORMAT = '%Y-%m-%d %H:%M:%S'
LOG_DIRECTORY = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'logs')

# Migration tracking - add to track fixed imports
LOG_MIGRATION_FIXES = True


def setup_logging(level: int = DEFAULT_LEVEL) -> None:
    """
    Set up the logging system for the application.
    
    Args:
        level: The log level to use.
    """
    return configure_logging(level)


def configure_logging(level: int = DEFAULT_LEVEL) -> None:
    """
    Configure the logging system.
    
    Args:
        level: The log level to use.
    """
    # Create log directory if it doesn't exist
    if not os.path.exists(LOG_DIRECTORY):
        os.makedirs(LOG_DIRECTORY)
    
    # Configure the root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    
    # Remove all handlers
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
    
    # Create a console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    
    # Set the format
    formatter = logging.Formatter(LOGGER_FORMAT, DATE_FORMAT)
    console_handler.setFormatter(formatter)
    
    # Add the console handler to the root logger
    root_logger.addHandler(console_handler)
    
    # Create a file handler for all logs
    log_file = os.path.join(LOG_DIRECTORY, f'game_{time.strftime("%Y%m%d_%H%M%S")}.log')
    file_handler = logging.handlers.RotatingFileHandler(
        log_file,
        maxBytes=10*1024*1024,  # 10 MB
        backupCount=5,
        encoding='utf-8'  # Explicitly set encoding
    )
    file_handler.setLevel(level)
    file_handler.setFormatter(formatter)
    
    # Add the file handler to the root logger
    root_logger.addHandler(file_handler)
    
    # Create a file handler for errors only
    error_log_file = os.path.join(LOG_DIRECTORY, f'error_{time.strftime("%Y%m%d_%H%M%S")}.log')
    error_file_handler = logging.handlers.RotatingFileHandler(
        error_log_file,
        maxBytes=5*1024*1024,  # 5 MB
        backupCount=5,
        encoding='utf-8'  # Explicitly set encoding
    )
    error_file_handler.setLevel(logging.ERROR)
    error_file_handler.setFormatter(formatter)
    
    # Add the error file handler to the root logger
    root_logger.addHandler(error_file_handler)
    
    # Log that logging is configured
    root_logger.info("Logging configured")


def get_logger(name: str) -> logging.Logger:
    """
    Get a logger with the given name.
    
    If the logger doesn't exist, it will be created and configured.
    
    Args:
        name: The name of the logger.
    
    Returns:
        The logger.
    """
    # Check if the logger is already cached
    if name in LOGGERS:
        return LOGGERS[name]
    
    # Create a new logger
    logger = logging.getLogger(name)
    
    # Special per-logger file sink for TIME_AUDIT
    try:
        if name == "TIME_AUDIT":
            # Ensure log directory exists
            if not os.path.exists(LOG_DIRECTORY):
                os.makedirs(LOG_DIRECTORY)
            audit_log_file = os.path.join(LOG_DIRECTORY, 'time_audit.log')
            # Attach a rotating file handler specifically for audit lines
            audit_handler = logging.handlers.RotatingFileHandler(
                audit_log_file,
                maxBytes=5*1024*1024,  # 5 MB
                backupCount=3,
                encoding='utf-8'
            )
            audit_handler.setLevel(logging.INFO)
            audit_formatter = logging.Formatter('%(asctime)s [%(name)s] %(levelname)s: %(message)s', DATE_FORMAT)
            audit_handler.setFormatter(audit_formatter)
            # Avoid duplicate handlers if logger was created but not cached
            if not any(isinstance(h, logging.handlers.RotatingFileHandler) and getattr(h, 'baseFilename', '') == audit_log_file for h in logger.handlers):
                logger.addHandler(audit_handler)
            logger.setLevel(logging.INFO)
            # Let it also propagate to root if desired (kept True)
            logger.propagate = True
    except Exception:
        # Never fail logger creation due to audit setup
        pass
    
    # Cache the logger
    LOGGERS[name] = logger
    
    return logger


def log_migration_fix(module_name: str, old_import: str, new_import: str) -> None:
    """
    Log a migration fix for import paths.
    
    Args:
        module_name: The name of the module being fixed
        old_import: The old, incorrect import path
        new_import: The new, correct import path
    """
    if not LOG_MIGRATION_FIXES:
        return
        
    logger = get_logger("MIGRATION")
    logger.info(f"Fixed import in {module_name}: '{old_import}' -> '{new_import}'")
```

### File: core\utils\save_manager.py

```python
#!/usr/bin/env python3
"""
Save file management utilities for the RPG game.

This module provides classes and functions for managing saved game files,
including listing, backup creation, validation, and metadata operations.
It works alongside StateManager but focuses on file operations rather than
actual game state serialization.
"""

import os
import json
import shutil
import glob
import uuid
import time
import datetime
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Any, Union
from pathlib import Path

from core.utils.logging_config import get_logger
from core.utils.json_utils import enhanced_json_loads, enhanced_json_dumps, EnhancedJSONEncoder

logger = get_logger(__name__)

@dataclass
class SaveMetadata:
    """Metadata for a saved game file."""
    save_id: str  # UUID string
    save_name: str  # User-friendly name
    save_time: float  # Unix timestamp
    version: str  # Game version
    player_name: str  # Name of player character
    player_level: int  # Level of player character
    world_time: str  # In-game time when saved
    location: str  # Current location
    playtime: float  # Time played in seconds
    screenshot: Optional[str] = None  # Path to screenshot image (relative to save)
    custom_notes: str = ""  # User notes about this save
    tags: List[str] = field(default_factory=list)  # User-defined tags
    auto_save: bool = False  # Whether this was an auto-save
    backup_of: Optional[str] = None  # ID of save this is a backup of (if any)
    
    @property
    def formatted_save_time(self) -> str:
        """Return the save time as a formatted string."""
        dt = datetime.datetime.fromtimestamp(self.save_time)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    
    @property
    def formatted_playtime(self) -> str:
        """Return the playtime as a formatted string (HH:MM:SS)."""
        hours, remainder = divmod(int(self.playtime), 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "save_id": self.save_id,
            "save_name": self.save_name,
            "save_time": self.save_time,
            "version": self.version,
            "player_name": self.player_name,
            "player_level": self.player_level,
            "world_time": self.world_time,
            "location": self.location,
            "playtime": self.playtime,
            "screenshot": self.screenshot,
            "custom_notes": self.custom_notes,
            "tags": self.tags,
            "auto_save": self.auto_save,
            "backup_of": self.backup_of
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SaveMetadata':
        """Create a SaveMetadata instance from a dictionary."""
        # Handle potential missing fields with defaults
        return cls(
            save_id=data.get("save_id", str(uuid.uuid4())),
            save_name=data.get("save_name", "Unknown Save"),
            save_time=data.get("save_time", time.time()),
            version=data.get("version", "0.0.0"),
            player_name=data.get("player_name", "Unknown"),
            player_level=data.get("player_level", 1),
            world_time=data.get("world_time", "00:00"),
            location=data.get("location", "Unknown"),
            playtime=data.get("playtime", 0.0),
            screenshot=data.get("screenshot"),
            custom_notes=data.get("custom_notes", ""),
            tags=data.get("tags", []),
            auto_save=data.get("auto_save", False),
            backup_of=data.get("backup_of")
        )


class SaveFileError(Exception):
    """Base exception for save file operations."""
    pass


class SaveFileNotFoundError(SaveFileError):
    """Exception raised when a save file doesn't exist."""
    pass


class SaveFileCorruptedError(SaveFileError):
    """Exception raised when a save file is corrupted or invalid."""
    pass


class SaveManager:
    """
    Manages saved game files, providing operations for listing, backup creation,
    validation, metadata management, and file operations.
    
    This class works alongside StateManager but focuses on file operations
    rather than actual game state serialization.
    """
    
    DEFAULT_SAVE_DIR = "saves"
    BACKUP_DIR = "backups"
    METADATA_FILENAME = "metadata.json"
    STATE_FILENAME = "state.json"
    MAX_AUTO_BACKUPS = 5
    
    def __init__(self, save_dir: Optional[str] = None):
        """
        Initialize the SaveManager.
        
        Args:
            save_dir: Directory where save files are stored. If None, uses the default.
        """
        if save_dir is None:
            save_dir = self.DEFAULT_SAVE_DIR
        
        self.save_dir = save_dir
        self.backup_dir = os.path.join(save_dir, self.BACKUP_DIR)
        
        # Ensure save directories exist
        os.makedirs(self.save_dir, exist_ok=True)
        os.makedirs(self.backup_dir, exist_ok=True)
        
        logger.info(f"SaveManager initialized with save directory: {self.save_dir}")
    
    def get_save_list(self, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Get a list of available save files with their metadata.
        
        Args:
            include_backups: Whether to include backup saves in the list.
            
        Returns:
            List of SaveMetadata objects.
        """
        saves = []
        
        # Get all save directories
        search_path = os.path.join(self.save_dir, "*", self.METADATA_FILENAME)
        metadata_files = glob.glob(search_path)
        
        # Get all backup directories if requested
        if include_backups:
            backup_search_path = os.path.join(self.backup_dir, "*", self.METADATA_FILENAME)
            metadata_files.extend(glob.glob(backup_search_path))
        
        # Load metadata from each file
        for metadata_file in metadata_files:
            try:
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata_dict = json.loads(f.read())
                    metadata = SaveMetadata.from_dict(metadata_dict)
                    saves.append(metadata)
            except Exception as e:
                logger.warning(f"Failed to load metadata from {metadata_file}: {e}")
        
        # Sort by save time, most recent first
        saves.sort(key=lambda x: x.save_time, reverse=True)
        
        return saves
    
    def get_save_path(self, save_id: str, is_backup: bool = False) -> str:
        """
        Get the directory path for a specific save.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Path to the save directory.
        """
        base_dir = self.backup_dir if is_backup else self.save_dir
        return os.path.join(base_dir, save_id)
    
    def get_metadata(self, save_id: str, is_backup: bool = False) -> SaveMetadata:
        """
        Get metadata for a specific save.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            SaveMetadata object.
            
        Raises:
            SaveFileNotFoundError: If the save file doesn't exist.
            SaveFileCorruptedError: If the metadata is corrupted.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
        
        if not os.path.exists(metadata_path):
            raise SaveFileNotFoundError(f"Save metadata not found for {save_id}")
        
        try:
            with open(metadata_path, 'r', encoding='utf-8') as f:
                metadata_dict = json.loads(f.read())
                return SaveMetadata.from_dict(metadata_dict)
        except Exception as e:
            raise SaveFileCorruptedError(f"Failed to load metadata: {e}")
    
    def update_metadata(self, save_id: str, updates: Dict[str, Any], 
                        is_backup: bool = False) -> SaveMetadata:
        """
        Update metadata for a specific save.
        
        Args:
            save_id: The UUID of the save.
            updates: Dictionary of updates to apply.
            is_backup: Whether this is a backup save.
            
        Returns:
            Updated SaveMetadata object.
            
        Raises:
            SaveFileNotFoundError: If the save file doesn't exist.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
        except SaveFileNotFoundError:
            raise
        except SaveFileCorruptedError:
            # Create new metadata if corrupted
            metadata = SaveMetadata(
                save_id=save_id,
                save_name="Recovered Save",
                save_time=time.time(),
                version="0.0.0",
                player_name="Unknown",
                player_level=1,
                world_time="00:00",
                location="Unknown",
                playtime=0.0
            )
        
        # Apply updates
        for key, value in updates.items():
            if hasattr(metadata, key):
                setattr(metadata, key, value)
            else:
                logger.warning(f"Unknown metadata field: {key}")
        
        # Save updated metadata
        save_dir = self.get_save_path(save_id, is_backup)
        metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
        
        os.makedirs(save_dir, exist_ok=True)
        
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
        
        return metadata
    
    def create_backup(self, save_id: str) -> str:
        """
        Create a backup of a save file.
        
        Args:
            save_id: The UUID of the save to back up.
            
        Returns:
            The UUID of the backup save.
            
        Raises:
            SaveFileNotFoundError: If the save file doesn't exist.
        """
        source_dir = self.get_save_path(save_id)
        
        if not os.path.exists(source_dir):
            raise SaveFileNotFoundError(f"Save not found: {save_id}")
        
        # Create a new ID for the backup
        backup_id = str(uuid.uuid4())
        backup_dir = self.get_save_path(backup_id, is_backup=True)
        
        # Copy all files
        shutil.copytree(source_dir, backup_dir)
        
        # Update metadata to mark as backup
        try:
            metadata = self.get_metadata(backup_id, is_backup=True)
            metadata.backup_of = save_id
            metadata.save_time = time.time()  # Update backup time
            
            metadata_path = os.path.join(backup_dir, self.METADATA_FILENAME)
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                
            logger.info(f"Created backup {backup_id} of save {save_id}")
            return backup_id
            
        except Exception as e:
            # If metadata update fails, remove the backup
            shutil.rmtree(backup_dir, ignore_errors=True)
            logger.error(f"Failed to create backup: {e}")
            raise
    
    def auto_backup(self, save_id: str) -> Optional[str]:
        """
        Create an automatic backup of a save file, managing rotation.
        
        Args:
            save_id: The UUID of the save to back up.
            
        Returns:
            The UUID of the backup save, or None if backup wasn't needed.
        """
        try:
            # Get existing backups for this save
            existing_backups = [
                meta for meta in self.get_save_list(include_backups=True)
                if meta.backup_of == save_id and meta.auto_save
            ]
            
            # If we already have max backups, remove the oldest
            if len(existing_backups) >= self.MAX_AUTO_BACKUPS:
                existing_backups.sort(key=lambda x: x.save_time)
                oldest_backup = existing_backups[0]
                self.delete_save(oldest_backup.save_id, is_backup=True)
            
            # Create new backup
            backup_id = self.create_backup(save_id)
            
            # Mark as auto backup
            self.update_metadata(backup_id, {"auto_save": True}, is_backup=True)
            
            return backup_id
            
        except Exception as e:
            logger.error(f"Failed to create auto backup: {e}")
            return None
    
    def delete_save(self, save_id: str, is_backup: bool = False) -> bool:
        """
        Delete a save file.
        
        Args:
            save_id: The UUID of the save to delete.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        
        if not os.path.exists(save_dir):
            logger.warning(f"Cannot delete non-existent save: {save_id}")
            return False
        
        try:
            shutil.rmtree(save_dir)
            logger.info(f"Deleted save: {save_id}")
            return True
        except Exception as e:
            logger.error(f"Failed to delete save {save_id}: {e}")
            return False
    
    def rename_save(self, save_id: str, new_name: str, is_backup: bool = False) -> bool:
        """
        Rename a save file.
        
        Args:
            save_id: The UUID of the save to rename.
            new_name: The new name for the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            metadata.save_name = new_name
            
            save_dir = self.get_save_path(save_id, is_backup)
            metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
            
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
            
            logger.info(f"Renamed save {save_id} to '{new_name}'")
            return True
            
        except Exception as e:
            logger.error(f"Failed to rename save {save_id}: {e}")
            return False
    
    def validate_save(self, save_id: str, is_backup: bool = False) -> Tuple[bool, Optional[str]]:
        """
        Validate a save file for integrity.
        
        Args:
            save_id: The UUID of the save to validate.
            is_backup: Whether this is a backup save.
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        save_dir = self.get_save_path(save_id, is_backup)
        
        # Check if directory exists
        if not os.path.exists(save_dir):
            return False, "Save directory does not exist"
        
        # Check metadata file
        metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
        if not os.path.exists(metadata_path):
            return False, "Metadata file missing"
        
        # Try to load metadata
        try:
            with open(metadata_path, 'r', encoding='utf-8') as f:
                metadata_dict = json.loads(f.read())
                # Basic validation that required fields exist
                for field in ["save_id", "save_name", "save_time", "version"]:
                    if field not in metadata_dict:
                        return False, f"Metadata missing required field: {field}"
        except json.JSONDecodeError:
            return False, "Metadata file is not valid JSON"
        except Exception as e:
            return False, f"Failed to read metadata: {e}"
        
        # Check state file
        state_path = os.path.join(save_dir, self.STATE_FILENAME)
        if not os.path.exists(state_path):
            return False, "State file missing"
        
        # Try to load state (just check if it's valid JSON)
        try:
            with open(state_path, 'r', encoding='utf-8') as f:
                json.loads(f.read())
        except json.JSONDecodeError:
            return False, "State file is not valid JSON"
        except Exception as e:
            return False, f"Failed to read state file: {e}"
        
        return True, None
    
    def restore_backup(self, backup_id: str, replace_original: bool = True) -> Optional[str]:
        """
        Restore a backup to its original save location.
        
        Args:
            backup_id: The UUID of the backup to restore.
            replace_original: Whether to replace the original save.
            
        Returns:
            The UUID of the restored save, or None if restoration failed.
        """
        try:
            backup_metadata = self.get_metadata(backup_id, is_backup=True)
            
            if not backup_metadata.backup_of:
                logger.warning(f"Backup {backup_id} does not reference an original save")
                return None
            
            original_id = backup_metadata.backup_of
            backup_dir = self.get_save_path(backup_id, is_backup=True)
            original_dir = self.get_save_path(original_id)
            
            # Check if original exists and backup if needed
            if os.path.exists(original_dir):
                if replace_original:
                    # Create a temporary backup of the current state before overwriting
                    temp_backup_id = self.create_backup(original_id)
                    self.update_metadata(temp_backup_id, {
                        "save_name": f"Pre-restore backup of {backup_metadata.save_name}",
                        "custom_notes": "Automatic backup created before restoring from another backup"
                    }, is_backup=True)
                    
                    # Delete original to prepare for copy
                    shutil.rmtree(original_dir)
                else:
                    # Create a new ID for the restored save
                    new_id = str(uuid.uuid4())
                    original_dir = self.get_save_path(new_id)
                    original_id = new_id
            
            # Copy backup to original/new location
            shutil.copytree(backup_dir, original_dir)
            
            # Update metadata if this is a new save ID
            if original_id != backup_metadata.backup_of:
                try:
                    metadata = self.get_metadata(original_id)
                    metadata.save_id = original_id
                    metadata.backup_of = None
                    metadata.save_name += " (Restored)"
                    metadata.save_time = time.time()
                    
                    metadata_path = os.path.join(original_dir, self.METADATA_FILENAME)
                    with open(metadata_path, 'w', encoding='utf-8') as f:
                        json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                        
                except Exception as e:
                    logger.error(f"Failed to update restored save metadata: {e}")
            
            logger.info(f"Restored backup {backup_id} to save {original_id}")
            return original_id
            
        except Exception as e:
            logger.error(f"Failed to restore backup {backup_id}: {e}")
            return None
    
    def get_save_content(self, save_id: str, is_backup: bool = False) -> Optional[Dict[str, Any]]:
        """
        Get the content of a save file (the actual game state).
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Dictionary containing the game state, or None if loading failed.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        state_path = os.path.join(save_dir, self.STATE_FILENAME)
        
        if not os.path.exists(state_path):
            logger.warning(f"State file not found for save {save_id}")
            return None
        
        try:
            with open(state_path, 'r', encoding='utf-8') as f:
                return enhanced_json_loads(f.read())
        except Exception as e:
            logger.error(f"Failed to load state for save {save_id}: {e}")
            return None
    
    def create_save_directory(self, save_id: str, is_backup: bool = False) -> str:
        """
        Create a new save directory structure.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Path to the save directory.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        os.makedirs(save_dir, exist_ok=True)
        return save_dir
    
    def save_screenshot(self, save_id: str, screenshot_data: bytes, 
                        is_backup: bool = False) -> Optional[str]:
        """
        Save a screenshot for a save file.
        
        Args:
            save_id: The UUID of the save.
            screenshot_data: The raw image data.
            is_backup: Whether this is a backup save.
            
        Returns:
            Relative path to the screenshot, or None if saving failed.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        screenshots_dir = os.path.join(save_dir, "screenshots")
        os.makedirs(screenshots_dir, exist_ok=True)
        
        # Create a filename with timestamp
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"screenshot_{timestamp}.png"
        filepath = os.path.join(screenshots_dir, filename)
        
        try:
            with open(filepath, 'wb') as f:
                f.write(screenshot_data)
            
            # Return path relative to save directory
            rel_path = os.path.join("screenshots", filename)
            
            # Update metadata with screenshot path
            try:
                self.update_metadata(save_id, {"screenshot": rel_path}, is_backup)
            except Exception as e:
                logger.warning(f"Failed to update metadata with screenshot: {e}")
            
            return rel_path
            
        except Exception as e:
            logger.error(f"Failed to save screenshot: {e}")
            return None
    
    def get_screenshot_path(self, save_id: str, is_backup: bool = False) -> Optional[str]:
        """
        Get the path to the latest screenshot for a save file.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Full path to the screenshot, or None if not found.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            if not metadata.screenshot:
                return None
            
            save_dir = self.get_save_path(save_id, is_backup)
            return os.path.join(save_dir, metadata.screenshot)
            
        except Exception as e:
            logger.warning(f"Failed to get screenshot path: {e}")
            return None
    
    def add_save_tag(self, save_id: str, tag: str, is_backup: bool = False) -> bool:
        """
        Add a tag to a save file.
        
        Args:
            save_id: The UUID of the save.
            tag: The tag to add.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            if tag not in metadata.tags:
                metadata.tags.append(tag)
                
                save_dir = self.get_save_path(save_id, is_backup)
                metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
                
                with open(metadata_path, 'w', encoding='utf-8') as f:
                    json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                
                return True
            return True  # Tag already exists, consider this success
            
        except Exception as e:
            logger.error(f"Failed to add tag to save {save_id}: {e}")
            return False
    
    def remove_save_tag(self, save_id: str, tag: str, is_backup: bool = False) -> bool:
        """
        Remove a tag from a save file.
        
        Args:
            save_id: The UUID of the save.
            tag: The tag to remove.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            if tag in metadata.tags:
                metadata.tags.remove(tag)
                
                save_dir = self.get_save_path(save_id, is_backup)
                metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
                
                with open(metadata_path, 'w', encoding='utf-8') as f:
                    json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                
                return True
            return True  # Tag doesn't exist, consider this success
            
        except Exception as e:
            logger.error(f"Failed to remove tag from save {save_id}: {e}")
            return False
    
    def update_save_notes(self, save_id: str, notes: str, is_backup: bool = False) -> bool:
        """
        Update user notes for a save file.
        
        Args:
            save_id: The UUID of the save.
            notes: The notes to set.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        return bool(self.update_metadata(save_id, {"custom_notes": notes}, is_backup))
    
    def find_saves_by_tag(self, tag: str, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Find saves with a specific tag.
        
        Args:
            tag: The tag to search for.
            include_backups: Whether to include backup saves.
            
        Returns:
            List of SaveMetadata objects with the specified tag.
        """
        all_saves = self.get_save_list(include_backups=include_backups)
        return [save for save in all_saves if tag in save.tags]
    
    def find_saves_by_player(self, player_name: str, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Find saves for a specific player.
        
        Args:
            player_name: The player name to search for.
            include_backups: Whether to include backup saves.
            
        Returns:
            List of SaveMetadata objects for the specified player.
        """
        all_saves = self.get_save_list(include_backups=include_backups)
        return [save for save in all_saves if save.player_name.lower() == player_name.lower()]
    
    def get_recent_saves(self, count: int = 5, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Get the most recent saves.
        
        Args:
            count: Maximum number of saves to return.
            include_backups: Whether to include backup saves.
            
        Returns:
            List of the most recent SaveMetadata objects.
        """
        all_saves = self.get_save_list(include_backups=include_backups)
        return all_saves[:min(count, len(all_saves))]
    
    def count_saves(self, include_backups: bool = False) -> int:
        """
        Count the number of saves.
        
        Args:
            include_backups: Whether to include backup saves.
            
        Returns:
            Number of saves.
        """
        return len(self.get_save_list(include_backups=include_backups))


# Example usage
if __name__ == "__main__":
    save_manager = SaveManager()
    
    # List available saves
    saves = save_manager.get_save_list()
    print(f"Found {len(saves)} saves:")
    for save in saves:
        print(f"  {save.save_name} ({save.formatted_save_time})")
    
    # Create a test save if none exist
    if not saves:
        print("\nCreating a test save...")
        save_id = str(uuid.uuid4())
        save_dir = save_manager.create_save_directory(save_id)
        
        # Create sample metadata
        metadata = SaveMetadata(
            save_id=save_id,
            save_name="Test Save",
            save_time=time.time(),
            version="0.1.0",
            player_name="TestPlayer",
            player_level=5,
            world_time="13:45",
            location="Test Village",
            playtime=3600.0,
            tags=["test"]
        )
        
        # Save metadata
        metadata_path = os.path.join(save_dir, SaveManager.METADATA_FILENAME)
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
        
        # Create sample state
        state = {
            "player": {
                "name": "TestPlayer",
                "level": 5,
                "stats": {"health": 100, "mana": 50}
            },
            "world": {
                "current_location": "Test Village",
                "time": "13:45",
                "weather": "clear"
            }
        }
        
        # Save state
        state_path = os.path.join(save_dir, SaveManager.STATE_FILENAME)
        with open(state_path, 'w', encoding='utf-8') as f:
            f.write(enhanced_json_dumps(state, indent=2))
        
        print(f"Created test save with ID: {save_id}")
        
        # Create a backup
        backup_id = save_manager.create_backup(save_id)
        print(f"Created backup with ID: {backup_id}")
        
        # List saves again
        saves = save_manager.get_save_list(include_backups=True)
        print(f"\nNow found {len(saves)} saves (including backups):")
        for save in saves:
            save_type = "Backup" if save.backup_of else "Regular"
            print(f"  {save.save_name} - {save_type} ({save.formatted_save_time})")
```

### File: core\utils\time_utils.py

```python
#!/usr/bin/env python3
"""
Time utilities for the RPG game.

This module provides utility functions for manipulating and formatting
time in the game world, including conversions between game time and
real time, and human-readable time formatting.
"""

import time
import datetime
from typing import Optional, Tuple, Union, Dict, Any
import logging

from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

# Constants for time units in seconds
SECOND = 1
MINUTE = 60 * SECOND
HOUR = 60 * MINUTE
DAY = 24 * HOUR
WEEK = 7 * DAY
MONTH = 30 * DAY  # Approximation
YEAR = 365 * DAY  # Approximation

# Default game time scale (1 real second = 60 game seconds)
DEFAULT_TIME_SCALE = 60.0

# Game time epoch (reference point for game time)
# Using Jan 1, 1000 as a default fantasy setting start date
GAME_EPOCH = datetime.datetime(year=1000, month=1, day=1)


def game_time_to_datetime(game_time: float, epoch: datetime.datetime = None) -> datetime.datetime:
    """
    Convert game time (seconds since game epoch) to a datetime object.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A datetime object representing the game time.
    """
    epoch = epoch or GAME_EPOCH
    
    # Calculate days and remaining seconds
    days = int(game_time / DAY)
    remaining_seconds = game_time % DAY
    
    # Add to the epoch
    return epoch + datetime.timedelta(days=days, seconds=remaining_seconds)


def datetime_to_game_time(dt: datetime.datetime, epoch: datetime.datetime = None) -> float:
    """
    Convert a datetime object to game time (seconds since game epoch).
    
    Args:
        dt: The datetime to convert.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        The game time in seconds.
    """
    epoch = epoch or GAME_EPOCH
    
    # Calculate the difference
    delta = dt - epoch
    
    # Convert to seconds
    return delta.total_seconds()


def format_game_time(game_time: float, format_str: str = "%Y-%m-%d %H:%M:%S", 
                   epoch: datetime.datetime = None) -> str:
    """
    Format game time as a string using a datetime format string.
    
    Args:
        game_time: The game time in seconds since the epoch.
        format_str: The format string to use.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A formatted string representing the game time.
    """
    dt = game_time_to_datetime(game_time, epoch)
    return dt.strftime(format_str)


def format_time_of_day(game_time: float, epoch: datetime.datetime = None) -> str:
    """
    DEPRECATED: Use enhanced_time_manager.get_simple_time() instead.
    
    Get the time of day as a string (e.g., "Morning", "Afternoon").
    This function is kept for backward compatibility but now delegates
    to the enhanced time manager for better narrative descriptions.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A string representing the time of day.
    """
    logger.warning("format_time_of_day() is deprecated, use enhanced_time_manager.get_simple_time() instead")
    
    # Use enhanced time manager for better descriptions
    try:
        from core.utils.enhanced_time_manager import get_simple_time
        return get_simple_time(game_time)
    except ImportError:
        # Fallback to old logic if enhanced time manager not available
        dt = game_time_to_datetime(game_time, epoch)
        hour = dt.hour
        
        if 5 <= hour < 12:
            return "Morning"
        elif 12 <= hour < 17:
            return "Afternoon"
        elif 17 <= hour < 21:
            return "Evening"
        else:
            return "Night"


def format_date(game_time: float, epoch: datetime.datetime = None) -> str:
    """
    Format the game date in a human-readable way.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A formatted date string (e.g., "January 1, 1000").
    """
    dt = game_time_to_datetime(game_time, epoch)
    return dt.strftime("%B %d, %Y")


def format_duration(seconds: float) -> str:
    """
    Format a duration in seconds as a human-readable string.
    
    Args:
        seconds: The duration in seconds.
    
    Returns:
        A formatted duration string (e.g., "2 days, 3 hours, 45 minutes").
    """
    # Handle negative durations
    is_negative = seconds < 0
    seconds = abs(seconds)
    
    # Calculate time units
    days, remainder = divmod(seconds, DAY)
    hours, remainder = divmod(remainder, HOUR)
    minutes, seconds = divmod(remainder, MINUTE)
    
    # Build the string
    parts = []
    
    if days > 0:
        parts.append(f"{int(days)} day{'' if days == 1 else 's'}")
    
    if hours > 0:
        parts.append(f"{int(hours)} hour{'' if hours == 1 else 's'}")
    
    if minutes > 0:
        parts.append(f"{int(minutes)} minute{'' if minutes == 1 else 's'}")
    
    if seconds > 0 or not parts:
        # Only include seconds if it's the only component or if there are some
        parts.append(f"{int(seconds)} second{'' if seconds == 1 else 's'}")
    
    # Join with commas and add negative sign if needed
    result = ", ".join(parts)
    if is_negative:
        result = f"negative {result}"
    
    return result


def parse_time_string(time_str: str) -> Optional[float]:
    """
    Parse a time string into seconds.
    
    Supports formats like:
    - "10s" (10 seconds)
    - "5m" (5 minutes)
    - "2h" (2 hours)
    - "1d" (1 day)
    - "1h30m" (1 hour and 30 minutes)
    
    Args:
        time_str: The time string to parse.
    
    Returns:
        The time in seconds, or None if parsing failed.
    """
    try:
        # Replace common variations
        time_str = time_str.lower().replace(" ", "")
        
        # Initialize total seconds
        total_seconds = 0
        
        # Parse different units
        units = {
            "s": SECOND,
            "m": MINUTE,
            "h": HOUR,
            "d": DAY,
            "w": WEEK,
            "mo": MONTH,
            "y": YEAR
        }
        
        # Extract numbers followed by units
        import re
        pattern = r"(\d+)([a-z]+)"
        matches = re.findall(pattern, time_str)
        
        if not matches:
            # Try to parse as a plain number (assumed to be seconds)
            try:
                return float(time_str)
            except ValueError:
                return None
        
        # Sum up all parts
        for value_str, unit in matches:
            value = float(value_str)
            
            if unit not in units:
                logger.warning(f"Unknown time unit: {unit}")
                return None
            
            total_seconds += value * units[unit]
        
        return total_seconds
    
    except Exception as e:
        logger.warning(f"Error parsing time string '{time_str}': {e}")
        return None


def real_to_game_time(real_seconds: float, time_scale: float = DEFAULT_TIME_SCALE) -> float:
    """
    DEPRECATED (Phase 1): Real-time based conversions are no longer used to advance
    world time. This function remains for legacy compatibility only.
    
    Args:
        real_seconds: The real time in seconds.
        time_scale: The time scale (game seconds per real second).
    
    Returns:
        The game time in seconds.
    """
    logger.warning("time_utils.real_to_game_time called (DEPRECATED in Phase 1)")
    return real_seconds * time_scale


def game_to_real_time(game_seconds: float, time_scale: float = DEFAULT_TIME_SCALE) -> float:
    """
    DEPRECATED (Phase 1): Real-time based conversions are no longer used to advance
    world time. This function remains for legacy compatibility only.
    
    Args:
        game_seconds: The game time in seconds.
        time_scale: The time scale (game seconds per real second).
    
    Returns:
        The real time in seconds.
    """
    logger.warning("time_utils.game_to_real_time called (DEPRECATED in Phase 1)")
    if time_scale <= 0:
        logger.warning(f"Invalid time scale: {time_scale}")
        return 0
    
    return game_seconds / time_scale


def get_current_game_time(start_time: float, elapsed_real: float, 
                        time_scale: float = DEFAULT_TIME_SCALE) -> float:
    """
    DEPRECATED (Phase 1): Real-time based calculations are no longer used to
    determine world time. This function remains for legacy compatibility only.
    
    Args:
        start_time: The starting game time.
        elapsed_real: The elapsed real time since the game started.
        time_scale: The time scale (game seconds per real second).
    
    Returns:
        The current game time.
    """
    logger.warning("time_utils.get_current_game_time called (DEPRECATED in Phase 1)")
    return start_time + real_to_game_time(elapsed_real, time_scale)


def is_daytime(game_time: float, epoch: datetime.datetime = None) -> bool:
    """
    Check if the current game time is daytime (between 6 AM and 6 PM).
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        True if it's daytime, False otherwise.
    """
    dt = game_time_to_datetime(game_time, epoch)
    hour = dt.hour
    return 6 <= hour < 18


def get_season(game_time: float, epoch: datetime.datetime = None) -> str:
    """
    Get the current season based on the game time.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        The current season ("Spring", "Summer", "Fall", or "Winter").
    """
    dt = game_time_to_datetime(game_time, epoch)
    month = dt.month
    
    if 3 <= month < 6:
        return "Spring"
    elif 6 <= month < 9:
        return "Summer"
    elif 9 <= month < 12:
        return "Fall"
    else:
        return "Winter"


def time_until(target_game_time: float, current_game_time: float) -> float:
    """
    Calculate the game time until a target time.
    
    Args:
        target_game_time: The target game time.
        current_game_time: The current game time.
    
    Returns:
        The game time until the target time (negative if in the past).
    """
    return target_game_time - current_game_time


def format_timestamp(timestamp: float, format_str: str = "%Y-%m-%d %H:%M:%S") -> str:
    """
    Format a Unix timestamp as a datetime string.
    
    Args:
        timestamp: The Unix timestamp (seconds since Jan 1, 1970).
        format_str: The format string to use.
    
    Returns:
        A formatted datetime string.
    """
    dt = datetime.datetime.fromtimestamp(timestamp)
    return dt.strftime(format_str)


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Example game time (1 day and 12 hours from epoch)
    game_time = DAY + 12 * HOUR
    
    # Convert to datetime
    dt = game_time_to_datetime(game_time)
    print(f"Game time {game_time} is datetime: {dt}")
    
    # Format as string
    formatted = format_game_time(game_time)
    print(f"Formatted: {formatted}")
    
    # Get time of day
    time_of_day = format_time_of_day(game_time)
    print(f"Time of day: {time_of_day}")
    
    # Parse a time string
    parsed = parse_time_string("2h30m15s")
    print(f"Parsed '2h30m15s': {parsed} seconds")
    
    # Convert real time to game time
    real_time = 60  # 1 minute real time
    converted = real_to_game_time(real_time)
    print(f"{real_time} seconds real time = {converted} seconds game time")
    
    # Format a duration
    duration = format_duration(parsed)
    print(f"Duration: {duration}")
```

### File: gui\dialogs\save_game_dialog.py

```python
#!/usr/bin/env python3
"""
Save game dialog for the RPG game GUI.
This module provides a dialog for saving the game.
"""

import logging
import os
from typing import Optional, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QGroupBox, QListWidget, QListWidgetItem
)
from PySide6.QtCore import Qt, Signal, Slot

class SaveGameDialog(QDialog):
    """Dialog for saving the game."""
    
    def __init__(self, parent=None):
        """Initialize the save game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Save Game")
        self.setMinimumWidth(400)
        self.setMinimumHeight(300)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QLineEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create save name input section
        name_layout = QVBoxLayout()
        
        # Create save name label
        name_label = QLabel("Save Name:")
        
        # Create save name edit
        self.save_name_edit = QLineEdit()
        self.save_name_edit.setPlaceholderText("Enter a name for this save...")
        
        # Add widgets to name layout
        name_layout.addWidget(name_label)
        name_layout.addWidget(self.save_name_edit)
        
        # Add name layout to main layout
        main_layout.addLayout(name_layout)
        
        # Create existing saves group
        existing_group = QGroupBox("Existing Saves")
        existing_layout = QVBoxLayout(existing_group)
        existing_layout.setContentsMargins(10, 20, 10, 10)
        
        # Create existing saves list
        self.saves_list = QListWidget()
        self.saves_list.setAlternatingRowColors(True)
        
        # Add saves list to existing layout
        existing_layout.addWidget(self.saves_list)
        
        # Add existing group to main layout
        main_layout.addWidget(existing_group)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create save button
        self.save_button = QPushButton("Save Game")
        self.save_button.setEnabled(False)  # Disable until name is entered
        self.save_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.save_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load existing saves
        self._load_existing_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Enable/disable save button based on name field
        self.save_name_edit.textChanged.connect(self._validate_form)
        
        # Update name field when an existing save is selected
        self.saves_list.itemClicked.connect(self._on_save_selected)
    
    def _validate_form(self):
        """Validate the form and enable/disable the save button."""
        # Check if name is not empty
        has_name = bool(self.save_name_edit.text().strip())
        
        # Enable/disable save button
        self.save_button.setEnabled(has_name)
    
    def _load_existing_saves(self):
        """Load existing saves into the list."""
        # Clear the list
        self.saves_list.clear()
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to list
        for save_file in save_files:
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Create and add the item
            item = QListWidgetItem(save_name)
            self.saves_list.addItem(item)
    
    def _on_save_selected(self, item):
        """Handle save selection."""
        # Set the save name edit to the selected save
        self.save_name_edit.setText(item.text())

```

### File: gui\dialogs\load_game_dialog.py

```python
#!/usr/bin/env python3
"""
Load game dialog for the RPG game GUI.
This module provides a dialog for loading a saved game.
"""

import logging
import os
import json
from typing import Optional, List, Dict
from datetime import datetime

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
    QPushButton, QGroupBox, QListWidget, QListWidgetItem,
    QSplitter, QWidget, QTextEdit, QHeaderView, QTableWidget,
    QTableWidgetItem, QAbstractItemView
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon, QFont

from gui.dialogs.base_dialog import BaseDialog

class LoadGameDialog(BaseDialog):
    """Dialog for loading a saved game."""
    
    def __init__(self, parent=None):
        """Initialize the load game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Load Game")
        self.setMinimumWidth(600)
        self.setMinimumHeight(400)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget, QTableWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item, QTableWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected, QTableWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover, QTableWidget::item:hover {
                background-color: #383838;
            }
            QTextEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QHeaderView::section {
                background-color: #333333;
                color: #E0E0E0;
                padding: 5px;
                border: 1px solid #444444;
            }
            QSplitter::handle {
                background-color: #444444;
            }
        """)
        
        # Selected save
        self.selected_save = None
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create a splitter for the save list and details
        splitter = QSplitter(Qt.Horizontal)
        
        # Create the saves list widget
        saves_widget = QWidget()
        saves_layout = QVBoxLayout(saves_widget)
        saves_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the saves table
        self.saves_table = QTableWidget()
        self.saves_table.setColumnCount(3)
        self.saves_table.setHorizontalHeaderLabels(["Save Name", "Date", "Character"])
        self.saves_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.saves_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.saves_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.saves_table.verticalHeader().setVisible(False)
        self.saves_table.setAlternatingRowColors(True)
        self.saves_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.saves_table.setSelectionMode(QAbstractItemView.SingleSelection)
        self.saves_table.setEditTriggers(QTableWidget.NoEditTriggers)
        
        # Add saves table to layout
        saves_layout.addWidget(self.saves_table)
        
        # Create the details widget
        details_widget = QWidget()
        details_layout = QVBoxLayout(details_widget)
        details_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the details group
        details_group = QGroupBox("Save Details")
        details_group_layout = QVBoxLayout(details_group)
        
        # Create the details text
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        
        # Add details text to group layout
        details_group_layout.addWidget(self.details_text)
        
        # Add details group to layout
        details_layout.addWidget(details_group)
        
        # Add widgets to splitter
        splitter.addWidget(saves_widget)
        splitter.addWidget(details_widget)
        
        # Set initial sizes
        splitter.setSizes([int(self.width() * 0.6), int(self.width() * 0.4)])
        
        # Add splitter to main layout
        main_layout.addWidget(splitter)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create delete button
        self.delete_button = QPushButton("Delete Save")
        self.delete_button.setEnabled(False)
        # self.delete_button.clicked.connect(self._on_delete_clicked)
        
        # Create load button
        self.load_button = QPushButton("Load Game")
        self.load_button.setEnabled(False)
        self.load_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.delete_button)
        button_layout.addWidget(self.load_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load saves
        self._load_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Connect save selection
        self.saves_table.itemSelectionChanged.connect(self._on_save_selected)
        self.saves_table.doubleClicked.connect(self._on_save_double_clicked)
    
    def _load_saves(self):
        """Load saves into the table."""
        # Clear the table
        self.saves_table.setRowCount(0)
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to table
        for i, save_file in enumerate(save_files):
            # Get the full path
            save_path = os.path.join(saves_dir, save_file)
            
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Get the modification time
            mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
            mod_time_str = mod_time.strftime("%Y-%m-%d %H:%M")
            
            # Get the character name (if possible)
            character_name = self._get_character_name(save_path)
            
            # Add row to table
            self.saves_table.insertRow(i)
            self.saves_table.setItem(i, 0, QTableWidgetItem(save_name))
            self.saves_table.setItem(i, 1, QTableWidgetItem(mod_time_str))
            self.saves_table.setItem(i, 2, QTableWidgetItem(character_name))
    
    def _get_character_name(self, save_path: str) -> str:
        """Get the character name from a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The character name, or "Unknown" if not found.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Try to get the character name
                if "player" in save_data and "name" in save_data["player"]:
                    return save_data["player"]["name"]
        except Exception as e:
            pass
        
        return "Unknown"
    
    def _get_save_details(self, save_path: str) -> str:
        """Get the details for a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The save details as a formatted string.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Extract details
                player_data = save_data.get("player", {})
                world_data = save_data.get("world", {})
                
                # Format details
                details = []
                
                # Player details
                if player_data:
                    details.append("Character Information:")
                    details.append(f"Name: {player_data.get('name', 'Unknown')}")
                    details.append(f"Race: {player_data.get('race', 'Unknown')}")
                    details.append(f"Class: {player_data.get('path', 'Unknown')}")
                    details.append(f"Background: {player_data.get('background', 'Unknown')}")
                    details.append(f"Level: {player_data.get('level', 1)}")
                    details.append("")
                
                # World details
                if world_data:
                    details.append("World Information:")
                    details.append(f"Location: {world_data.get('current_location', 'Unknown')}")
                    details.append(f"Time: {world_data.get('game_time', 'Unknown')}")
                    details.append("")
                
                # Game details
                mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
                details.append("Save Information:")
                details.append(f"Created: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}")
                details.append(f"File: {os.path.basename(save_path)}")
                
                return "\n".join(details)
        except Exception as e:
            return f"Error loading save details: {str(e)}"
    
    def _on_save_selected(self):
        """Handle save selection."""
        # Get the selected row
        selected_rows = self.saves_table.selectedItems()
        
        if not selected_rows:
            # No selection
            self.selected_save = None
            self.details_text.clear()
            self.load_button.setEnabled(False)
            self.delete_button.setEnabled(False)
            return
        
        # Get the save name
        save_name = self.saves_table.item(selected_rows[0].row(), 0).text()
        
        # Set the selected save
        self.selected_save = save_name + ".json"
        
        # Get the save path
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        save_path = os.path.join(saves_dir, self.selected_save)
        
        # Update the details
        self.details_text.setText(self._get_save_details(save_path))
        
        # Enable buttons
        self.load_button.setEnabled(True)
        self.delete_button.setEnabled(True)
    
    def _on_save_double_clicked(self, item):
        """Handle save double click."""
        # Accept the dialog to load the selected save
        self.accept()

```

### File: gui\utils\init_settings.py

```python
#!/usr/bin/env python3
"""
Initialize application settings with default values if they don't exist.
"""

import logging
from PySide6.QtCore import QSettings

def init_default_settings():
    """Initialize default settings if they don't exist."""

    settings = QSettings("RPGGame", "Settings")

    # Check if style settings exist and create defaults if not
    if not settings.contains("style/output_bg_color"):
        settings.setValue("style/output_bg_color", "#D2B48C")  # Light brown

    if not settings.contains("style/system_msg_color"):
        settings.setValue("style/system_msg_color", "#FF0000")  # Red

    if not settings.contains("style/font_family"):
        settings.setValue("style/font_family", "Garamond")

    if not settings.contains("style/font_size"):
        settings.setValue("style/font_size", 14)

    if not settings.contains("style/font_color"):
        settings.setValue("style/font_color", "#000000")  # Black

    # Initialize texture and transparency settings
    if not settings.contains("style/texture_name"):
        settings.setValue("style/texture_name", "subtle_noise")

    if not settings.contains("style/output_opacity"):
        settings.setValue("style/output_opacity", 100)

    if not settings.contains("style/input_opacity"):
        settings.setValue("style/input_opacity", 100)

    # Initialize display settings if they don't exist
    if not settings.contains("display/resolution"):
        settings.setValue("display/resolution", (1280, 720))

    if not settings.contains("display/mode"):
        settings.setValue("display/mode", "windowed")

    if not settings.contains("display/ui_scale"):
        settings.setValue("display/ui_scale", 1.0)
    # Initialize text speed setting
    if not settings.contains("display/text_speed_delay"):
        settings.setValue("display/text_speed_delay", 30) # Default delay in ms per character

    # Initialize sound settings if they don't exist
    if not settings.contains("sound/master_volume"):
        settings.setValue("sound/master_volume", 100)

    if not settings.contains("sound/music_volume"):
        settings.setValue("sound/music_volume", 100)

    if not settings.contains("sound/effects_volume"):
        settings.setValue("sound/effects_volume", 100)

    if not settings.contains("sound/enabled"):
        settings.setValue("sound/enabled", True)

    # Initialize gameplay settings if they don't exist
    if not settings.contains("gameplay/difficulty"):
        settings.setValue("gameplay/difficulty", "Normal")
    if not settings.contains("gameplay/encounter_size"):
        settings.setValue("gameplay/encounter_size", "Solo")

    if not settings.contains("gameplay/autosave_interval"):
        settings.setValue("gameplay/autosave_interval", 0)

    if not settings.contains("gameplay/tutorial_enabled"):
        settings.setValue("gameplay/tutorial_enabled", True)

    # Sync settings to disk
    settings.sync()

    logging.info("Default settings initialized")

```

### File: gui\utils\resource_manager.py

```python
#!/usr/bin/env python3
"""
Resource manager for the RPG game GUI.
This module provides a centralized system for loading and managing GUI resources.
"""

import os
import logging
from typing import Dict, Optional, List, Tuple

from PySide6.QtGui import QPixmap, QIcon, QMovie # Added QMovie
from PySide6.QtCore import QSize, QByteArray # Added QByteArray for QMovie

class ResourceManager:
    """Manages the loading and caching of GUI resources."""
    
    _instance = None
    
    def __new__(cls):
        """Singleton pattern implementation."""
        if cls._instance is None:
            cls._instance = super(ResourceManager, cls).__new__(cls)
            cls._instance._initialize()
        return cls._instance
    
    def _initialize(self):
        """Initialize the resource manager."""
        # Cache for loaded resources
        self._pixmap_cache: Dict[str, QPixmap] = {}
        self._icon_cache: Dict[str, QIcon] = {}
        self._movie_cache: Dict[str, QMovie] = {} # Added movie cache

        # Base paths
        self.gui_path = os.path.join("images", "gui")
        self.background_path = os.path.join(self.gui_path, "background") # --- ADDED ---
        
    def get_pixmap(self, name: str, default_size: Optional[QSize] = None) -> QPixmap:
        """
        Get a pixmap resource.
        
        Args:
            name: The resource name (without path or extension)
            default_size: Optional default size for the pixmap
            
        Returns:
            The loaded pixmap
        """
        # Check cache first
        if name in self._pixmap_cache:
            pixmap = self._pixmap_cache[name]
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
            return pixmap
        
        # Try to load the resource
        full_path = os.path.join(self.gui_path, f"{name}.png")
        
        try:
            pixmap = QPixmap(full_path)
            
            if pixmap.isNull():
                logging.warning(f"Failed to load pixmap: {full_path}")
                # Return an empty pixmap
                pixmap = QPixmap()
            else:
                # Cache the resource
                self._pixmap_cache[name] = pixmap
                
            # Scale if needed
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
                
            return pixmap
            
        except Exception as e:
            logging.error(f"Error loading pixmap {full_path}: {e}")
            return QPixmap()
    
    def get_icon(self, name: str) -> QIcon:
        """
        Get an icon resource.
        
        Args:
            name: The resource name (without path or extension)
            
        Returns:
            The loaded icon
        """
        # Check cache first
        if name in self._icon_cache:
            return self._icon_cache[name]
        
        # Try to load the resource
        try:
            # For button states, check for specific state images
            states = {
                "normal": f"{name}.png",
                "hover": f"{name}_hover.png",
                "pressed": f"{name}_pressed.png",
                "disabled": f"{name}_disabled.png"
            }
            
            # Create icon
            icon = QIcon()
            
            # Add states if they exist
            for state_name, filename in states.items():
                full_path = os.path.join(self.gui_path, filename)
                if os.path.exists(full_path):
                    pixmap = QPixmap(full_path)
                    if not pixmap.isNull():
                        if state_name == "normal":
                            icon.addPixmap(pixmap, QIcon.Normal, QIcon.Off)
                        elif state_name == "hover":
                            icon.addPixmap(pixmap, QIcon.Active, QIcon.Off)
                        elif state_name == "pressed":
                            icon.addPixmap(pixmap, QIcon.Selected, QIcon.Off)
                        elif state_name == "disabled":
                            icon.addPixmap(pixmap, QIcon.Disabled, QIcon.Off)
            
            # If no states were added, try to add the base name
            if icon.isNull():
                pixmap = self.get_pixmap(name)
                if not pixmap.isNull():
                    icon.addPixmap(pixmap)
            
            # Cache the icon
            self._icon_cache[name] = icon
            
            return icon
            
        except Exception as e:
            logging.error(f"Error loading icon {name}: {e}")
            return QIcon()
    

    def list_background_names(self) -> List[Tuple[str, str]]:
        """List available background image/animation names and their extensions."""
        backgrounds = []
        if not os.path.isdir(self.background_path):
            logging.warning(f"Background directory not found: {self.background_path}")
            return backgrounds
        try:
            for filename in os.listdir(self.background_path):
                name, ext = os.path.splitext(filename)
                ext_lower = ext.lower()
                if ext_lower in [".png", ".gif"]:
                    backgrounds.append((name, ext)) # Store name and extension
        except Exception as e:
            logging.error(f"Error listing backgrounds in {self.background_path}: {e}")
        return sorted(backgrounds, key=lambda x: x[0]) # Sort by name

    def get_background_pixmap(self, name: str) -> QPixmap:
        """
        Get a pixmap resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded pixmap
        """
        cache_key = f"background_{name}"
        # Check cache first
        if cache_key in self._pixmap_cache:
            return self._pixmap_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.png")

        try:
            pixmap = QPixmap(full_path)

            if pixmap.isNull():
                logging.warning(f"Failed to load background pixmap: {full_path}")
                pixmap = QPixmap() # Return an empty pixmap
            else:
                # Cache the resource
                self._pixmap_cache[cache_key] = pixmap

            return pixmap

        except Exception as e:
            logging.error(f"Error loading background pixmap {full_path}: {e}")
            return QPixmap()

    def get_background_movie(self, name: str) -> QMovie:
        """
        Get a QMovie resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded QMovie
        """
        cache_key = f"background_movie_{name}"
        # Check cache first
        if cache_key in self._movie_cache:
            # Return a new QMovie instance pointing to the same data if needed,
            # but for simplicity, let's assume sharing the instance is okay for now.
            # If issues arise, create new QMovie(self._movie_cache[cache_key].fileName())
            return self._movie_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.gif")

        try:
            # QMovie needs the path, not raw data like QPixmap sometimes uses
            movie = QMovie(full_path)

            if not movie.isValid():
                logging.warning(f"Failed to load or invalid background movie: {full_path}")
                # Return an empty/invalid movie
                return QMovie()
            else:
                # Cache the resource
                self._movie_cache[cache_key] = movie
                return movie

        except Exception as e:
            logging.error(f"Error loading background movie {full_path}: {e}")
            return QMovie()

    def clear_cache(self):
        """Clear the resource cache."""
        self._pixmap_cache.clear()
        self._icon_cache.clear()
        self._movie_cache.clear() # Clear movie cache

# Global instance for easy access
def get_resource_manager() -> ResourceManager:
    """Get the singleton resource manager instance."""
    return ResourceManager()

```

### File: gui\main_window.py

```python
#!/usr/bin/env python3
"""
Main window for the RPG game GUI.
This module provides the MainWindow class that serves as the primary GUI container.
"""

import logging
import os
import weakref
from typing import Optional, List, Dict, Any, Tuple
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QStackedWidget, QDialog, QLabel, QPushButton, 
    QTextEdit, QScrollArea, QGraphicsOpacityEffect, QMessageBox, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QTimer, QSize, QSettings, QObject, QThread, Signal, QParallelAnimationGroup, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QIcon, QPixmap, QPalette, QBrush, QColor, QMovie, QTextCursor # Added QTextCursor
from core.inventory import get_inventory_manager
from core.inventory.item import Item
from core.inventory.item_enums import EquipmentSlot
from gui.dialogs.game_over_dialog import GameOverDialog
from core.base.engine import GameEngine, get_game_engine
from core.combat.enums import CombatState, CombatStep
from core.interaction.enums import InteractionMode # Added import
from core.base.state import GameState, get_state_manager # Added imports
from core.utils.logging_config import get_logger
from gui.components.game_output import GameOutputWidget
from gui.components.command_input import CommandInputWidget
from gui.components.menu_panel import MenuPanelWidget
from gui.components.right_panel import CollapsibleRightPanel
from gui.components.status_bar import GameStatusBar
from gui.components.combat_display import CombatDisplay # Added import
from gui.utils.resource_manager import get_resource_manager
from gui.dialogs.settings.llm_settings_dialog import LLMSettingsDialog

logger = get_logger("GUI")

class MainWindow(QMainWindow):
    """Main window for the RPG game GUI."""
    
    def __init__(self):
            super().__init__()
            
            self._previous_mode = None # Track previous mode for transitions
            
            # Get resource manager
            self.resource_manager = get_resource_manager()
            
            # Get game engine
            self.game_engine = get_game_engine()

            # Register this MainWindow with the engine so orchestrator/engine can nudge UI updates
            try:
                self.game_engine.main_window_ref = weakref.ref(self)
            except Exception:
                pass

            # Set minimum size based on reasonable content size hint
            self.setMinimumSize(1024, 700) # Set a sensible minimum size

            # Store character data temporarily during animation
            self._character_data_for_new_game: Optional[Dict[str, Any]] = None

            # Set up the UI
            self._setup_ui()
            
            # Connect signals and slots
            self._connect_signals()
            
            # Apply initial styling
            self._update_styling()

            self._last_submitted_command = None

    def _apply_initial_window_state(self):
        """Apply saved window state and geometry when the window is first shown."""
        settings = QSettings("RPGGame", "Settings")
        window_state = settings.value("display/window_state", "windowed") # Default to windowed
        
        logger.info(f"Applying initial window state: {window_state}")

        if window_state == "fullscreen":
            self.showFullScreen()
        elif window_state == "maximized":
            self.showMaximized()
        else: # windowed
            # Load saved windowed size or default
            default_size = QSize(1280, 720)
            windowed_size = settings.value("display/windowed_size", default_size)
            # Ensure windowed_size is a QSize object
            if not isinstance(windowed_size, QSize):
                # Attempt conversion if it's a tuple/list or handle potential string format
                if isinstance(windowed_size, (tuple, list)) and len(windowed_size) == 2:
                    windowed_size = QSize(windowed_size[0], windowed_size[1])
                elif isinstance(windowed_size, str):
                     try:
                         parts = windowed_size.strip('()').split(',')
                         windowed_size = QSize(int(parts[0]), int(parts[1]))
                     except Exception:
                         windowed_size = default_size # Fallback on parse error
                else:
                    windowed_size = default_size # Fallback if type is unexpected

            self.showNormal() # Ensure not maximized/fullscreen first
            self.resize(windowed_size) # Apply the loaded/default size
            # Optional: Center the window
            screen_geometry = self.screen().availableGeometry()
            self.move(screen_geometry.center() - self.rect().center())        

    def showEvent(self, event):
        """Override showEvent to apply initial window state after the window is shown."""
        super().showEvent(event)
        # Apply the state only once when the window is first shown
        if not hasattr(self, '_initial_state_applied') or not self._initial_state_applied:
             self._apply_initial_window_state()
             self._initial_state_applied = True

    def closeEvent(self, event):
        """Handle window close event, saving window state."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # --- Save Window State ---
            settings = QSettings("RPGGame", "Settings")
            current_state_str = "windowed" # Default
            if self.isFullScreen():
                current_state_str = "fullscreen"
            elif self.isMaximized():
                current_state_str = "maximized"
            
            settings.setValue("display/window_state", current_state_str)
            
            # Save the *current* size only if the state is 'windowed'
            if current_state_str == "windowed":
                 settings.setValue("display/windowed_size", self.size())
            logger.info(f"Saved window state ({current_state_str}) and size ({self.size() if current_state_str == 'windowed' else 'N/A'}) on exit.")
            # --- End Save Window State ---

            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def _apply_saved_resolution(self):
        """Apply saved resolution from settings."""
        settings = QSettings("RPGGame", "Settings")
        resolution = settings.value("display/resolution", (1280, 720))
        
        # Convert to tuple if it's a string (can happen with some QSettings implementations)
        if isinstance(resolution, str):
            try:
                # Handle string format like "(1280, 720)"
                if resolution.startswith("(") and resolution.endswith(")"):
                    parts = resolution.strip("()").split(",")
                    resolution = (int(parts[0].strip()), int(parts[1].strip()))
            except:
                # Fallback to default if parsing fails
                resolution = (1280, 720)
                logging.warning("Failed to parse resolution setting, using default")
        
        # Set window size
        self.setFixedSize(*resolution)
        logging.info(f"Applied saved resolution: {resolution}")
    
    def _setup_ui(self):
        """Set up the user interface."""
        self.setWindowTitle("RPG Game")
        
        self.background_container = QWidget()
        self.setCentralWidget(self.background_container)
        self.background_container.setStyleSheet("background-color: transparent;")

        self.background_label = QLabel(self.background_container)
        self.background_label.setGeometry(0, 0, self.width(), self.height()) 
        self.background_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.background_label.setScaledContents(True) 

        self.main_content_widget = QWidget(self.background_container)
        self.main_content_widget.setGeometry(0, 0, self.width(), self.height()) 
        self.main_content_widget.setStyleSheet("background-color: transparent;") 

        self.main_layout = QVBoxLayout(self.main_content_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10) 
        self.main_layout.setSpacing(5)
        
        self.mode_stacked_widget = QStackedWidget()
        
        self.narrative_view = QWidget()
        self.narrative_layout = QVBoxLayout(self.narrative_view)
        self.narrative_layout.setContentsMargins(0, 0, 0, 0)
        self.narrative_layout.setSpacing(0)
        
        self.combat_view = QWidget()
        self.combat_layout = QVBoxLayout(self.combat_view)
        self.combat_layout.setContentsMargins(0, 0, 0, 0)
        self.combat_layout.setSpacing(0)
        
        title_pixmap = self.resource_manager.get_pixmap("title_banner")
        if not title_pixmap.isNull():
            self.title_label = QLabel()
            target_height = 100
            scaled_pixmap = title_pixmap.scaled(
                QSize(1000, target_height), 
                Qt.KeepAspectRatio,         
                Qt.SmoothTransformation     
            )
            self.title_label.setPixmap(scaled_pixmap)
            self.title_label.setAlignment(Qt.AlignCenter)
            self.title_label.setContentsMargins(0, 0, 0, 5)
            self.main_layout.addWidget(self.title_label)
        
        self.content_layout = QHBoxLayout()
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.setSpacing(10)
        
        self.menu_panel = MenuPanelWidget()
        
        self.game_output = GameOutputWidget()
        if hasattr(self.game_output, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.game_output.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected GameOutputWidget.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect GameOutputWidget.visualDisplayComplete: Attribute or slot missing.")
        self.narrative_layout.addWidget(self.game_output, 1)
        
        self.narrative_command_input = CommandInputWidget()
        self.narrative_layout.addWidget(self.narrative_command_input, 0)
        
        self.combat_display = CombatDisplay()
        if hasattr(self.combat_display, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.combat_display.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected CombatDisplay.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect CombatDisplay.visualDisplayComplete: Attribute or slot missing.")
        self.combat_layout.addWidget(self.combat_display, 1)
        
        self.combat_command_input = CommandInputWidget()
        self.combat_layout.addWidget(self.combat_command_input, 0)
        
        self.mode_stacked_widget.addWidget(self.narrative_view)
        self.mode_stacked_widget.addWidget(self.combat_view)
        
        self.center_widget = QWidget()
        center_layout = QVBoxLayout(self.center_widget)
        center_layout.setContentsMargins(0, 0, 0, 0)
        center_layout.addWidget(self.mode_stacked_widget)
        
        self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
        
        self.right_panel = CollapsibleRightPanel()
        
        self.content_layout.addWidget(self.menu_panel, 0) # Stretch factor 0 for menu_panel
        self.content_layout.addWidget(self.center_widget, 1) # Stretch factor 1 for center_widget
        self.content_layout.addWidget(self.right_panel, 0) # Stretch factor 0 for right_panel
        
        self.main_layout.addLayout(self.content_layout, 1)
        
        self.music_controls = self._create_music_controls()
        
        self.status_bar = GameStatusBar()
        self.setStatusBar(self.status_bar)

        self._load_and_apply_initial_background()

        self._initialize_panel_effects() 
        
        # Initial state: center, right, and status bar are part of the layout but fully transparent and disabled.
        # setVisible(True) is important for them to be considered by the layout manager from the start.
        self.center_widget.setVisible(True) 
        self.center_widget.setEnabled(False)
        if hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False)
        if hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect.setOpacity(0.0)
            
        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False)
        if hasattr(self, 'status_bar_opacity_effect'):
             self.status_bar_opacity_effect.setOpacity(0.0)

    def _create_music_controls(self):
        """Create music control widgets."""
        # Create a widget for the music controls
        music_widget = QWidget()
        music_layout = QHBoxLayout(music_widget)
        music_layout.setContentsMargins(0, 0, 0, 0)
        music_layout.setSpacing(5)
        
        # Create music control buttons
        play_pause_button = QPushButton()
        play_pause_button.setIcon(self.resource_manager.get_icon("music_play"))
        play_pause_button.setIconSize(QSize(24, 24))
        play_pause_button.setFixedSize(32, 32)
        play_pause_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 16px;
            }
            QPushButton:pressed {
                background-color: rgba(255, 255, 255, 0.2);
            }
        """)
        
        next_button = QPushButton()
        next_button.setIcon(self.resource_manager.get_icon("music_next"))
        next_button.setIconSize(QSize(24, 24))
        next_button.setFixedSize(32, 32)
        next_button.setStyleSheet(play_pause_button.styleSheet())
        
        volume_button = QPushButton()
        volume_button.setIcon(self.resource_manager.get_icon("music_volume"))
        volume_button.setIconSize(QSize(24, 24))
        volume_button.setFixedSize(32, 32)
        volume_button.setStyleSheet(play_pause_button.styleSheet())
        
        # Add buttons to layout
        music_layout.addWidget(play_pause_button)
        music_layout.addWidget(next_button)
        music_layout.addWidget(volume_button)
        
        # Add music controls to the top-right corner
        self.main_layout.insertWidget(0, music_widget, 0, Qt.AlignRight)
        
        # Return the widget for reference
        return music_widget
    
    def _connect_signals(self):
        """Connect signals and slots."""
        self.narrative_command_input.command_submitted.connect(self._process_command)
        self.combat_command_input.command_submitted.connect(self._process_command)

        logger.info("Connecting GameEngine.orchestrated_event_to_ui signal to MainWindow.process_orchestrated_display_event")
        try:
            self.game_engine.orchestrated_event_to_ui.connect(self.process_orchestrated_display_event)
            logger.info("Successfully connected orchestrated_event_to_ui signal")
        except Exception as e:
            logger.error(f"Failed to connect orchestrated_event_to_ui signal: {e}")
        
        logger.info("Connecting game engine output_generated signal to _handle_game_output (for non-orchestrated events)")
        try:
            self.game_engine.output_generated.connect(self._handle_game_output)
            logger.info("Successfully connected engine.output_generated signal")
        except Exception as e:
            logger.error(f"Failed to connect output_generated signal: {e}")

        self.menu_panel.new_game_requested.connect(self._show_new_game_dialog)
        self.menu_panel.save_game_requested.connect(self._show_save_game_dialog)
        self.menu_panel.load_game_requested.connect(self._show_load_game_dialog)
        self.menu_panel.settings_requested.connect(self._show_settings_dialog)
        self.menu_panel.llm_settings_requested.connect(self._show_llm_settings_dialog)
        self.menu_panel.exit_requested.connect(self.close)

        self.right_panel.tab_changed.connect(self._handle_tab_change)

        if hasattr(self.right_panel, 'inventory_panel'):
            self.right_panel.inventory_panel.item_use_requested.connect(self._handle_item_use_requested)
            self.right_panel.inventory_panel.item_examine_requested.connect(self._handle_item_examine_requested)
            self.right_panel.inventory_panel.item_equip_requested.connect(self._handle_item_equip_requested)
            self.right_panel.inventory_panel.item_unequip_requested.connect(self._handle_item_unequip_requested)
            self.right_panel.inventory_panel.item_drop_requested.connect(self._handle_item_drop_requested)
            logger.info("[GUI] MainWindow: Connected signals from InventoryPanelWidget (via right_panel).")
        else:
            logger.error("[GUI] MainWindow: CRITICAL - self.right_panel.inventory_panel not found during signal connection.")

        # Connect signals from CharacterSheetWidget (via right_panel)
        if hasattr(self.right_panel, 'character_sheet'):
            self.right_panel.character_sheet.item_unequip_from_slot_requested.connect(self._handle_item_unequip_from_slot_requested)
            self.right_panel.character_sheet.item_examine_requested.connect(self._handle_item_examine_requested) # Can reuse the same handler
            self.right_panel.character_sheet.item_drop_from_slot_requested.connect(self._handle_item_drop_from_slot_requested)
            logger.info("[GUI] MainWindow: Connected signals from CharacterSheetWidget (via right_panel).")
        else:
            logger.error("[GUI] MainWindow: CRITICAL - self.right_panel.character_sheet not found for signal connection.")


        if self.game_engine.state_manager.stats_manager:
            try:
                self.game_engine.state_manager.stats_manager.stats_changed.disconnect(self._handle_stats_update)
            except (TypeError, RuntimeError): pass 
            self.game_engine.state_manager.stats_manager.stats_changed.connect(self._handle_stats_update)
            logger.info("Connected StatsManager stats_changed signal to MainWindow handler.")
        else:
            logger.warning("StatsManager not available at signal connection time in MainWindow.")
        
        if hasattr(self.game_engine._combat_orchestrator, 'resume_combat_manager') and hasattr(self.game_engine, 'on_orchestrator_idle_and_combat_manager_resumed'):
             self.game_engine._combat_orchestrator.resume_combat_manager.connect(self.game_engine.on_orchestrator_idle_and_combat_manager_resumed)
             logger.info("Connected orchestrator's resume_combat_manager to engine's handler for post-closing-narrative.")
        else:
             logger.error("Could not connect orchestrator's resume signal to engine.")
             
    @Slot(dict)
    def _handle_stats_update(self, stats_data: dict):
        """Handle updates received directly from StatsManager."""
        logger.debug("Received stats update signal in MainWindow")
        state = self.game_engine.state_manager.current_state
        if state:
            # Update Character Sheet (Right Panel)
            # This ensures character sheet gets all data including combat status
            if self.right_panel and hasattr(self.right_panel, 'update_character'):
                self.right_panel.update_character(state.player) # Pass player state for full context
                logger.debug("Updated CharacterSheet (RightPanel) from stats signal.")

            # Update Combat Display if in Combat Mode
            if state.current_mode == InteractionMode.COMBAT:
                logger.debug("Updating CombatDisplay from stats signal")
                self.combat_display.update_display(state) 
            
            # Any other UI elements that need to react to general stats changes can be updated here.

    def _setup_stats_refresh(self):
        """Set up player command tracking and direct signal connections instead of timer-based refresh."""
        # Store the last command submitted by the player to prevent echo
        self._last_submitted_command: Optional[str] = None
        
        # We don't need timer-based stats refresh anymore since we'll use direct signal connections
    
    # The _refresh_stats method is removed since we're using direct signal connections now
    
    def _handle_tab_change(self, index):
        """Handle tab change event."""
        # Update the active tab content
        if index == 0:  # Character tab
            self.right_panel.update_character()
        elif index == 1:  # Inventory tab
            if self.game_engine.state_manager.current_state:
                # Get inventory manager instance
                from core.inventory import get_inventory_manager
                inventory_manager = get_inventory_manager()
                
                if inventory_manager:
                    self.right_panel.update_inventory(inventory_manager)
                else:
                    logger.warning("No inventory manager available")
        elif index == 2:  # Journal tab
            if self.game_engine.state_manager.current_state:
                # Check if journal data exists, create it if not
                if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                    self.game_engine.state_manager.current_state.journal = {
                        "character": "",
                        "quests": {},
                        "notes": []
                    }
                
                self.right_panel.update_journal(
                    self.game_engine.state_manager.current_state.journal
                )
    
    # Define a worker for running commands in a separate thread
    class CommandWorker(QObject):
        finished = Signal()
        error = Signal(str)
        processing = Signal(bool)  # Signal to show/hide processing indicator
        
        def __init__(self, game_engine, command):
            super().__init__()
            self.game_engine = game_engine
            self.command = command
        
        def run(self):
            try:
                self.processing.emit(True)
                # Process input in the worker thread using the new InputRouter-based approach
                command_result = self.game_engine.process_input(self.command) # Original call
                
                # NEW: Process commands returned by LLM
                if command_result.data and "commands" in command_result.data:
                    llm_commands: List[Tuple[str, str]] = command_result.data["commands"]
                    if llm_commands:
                        logger.info(f"CommandWorker: Processing {len(llm_commands)} commands from LLM response: {llm_commands}")
                        # Ensure current_state is available
                        current_game_state = self.game_engine._state_manager.current_state
                        if not current_game_state:
                            logger.error("CommandWorker: Cannot process LLM commands, current_game_state is None.")
                        else:
                            for cmd, args_str in llm_commands:
                                try:
                                    # We need to call the central LLM command processor
                                    # command_handlers.process_llm_command takes (engine, command, args_list, game_state)
                                    # The args_str from the tuple is a single string, so wrap it in a list.
                                    logger.debug(f"CommandWorker: Executing LLM command '{cmd}' with args '{args_str}'")
                                    # Import locally if not already available or pass engine components if needed
                                    from core.game_flow.command_handlers import process_llm_command
                                    
                                    # process_llm_command itself might call engine._output, which triggers _update_ui.
                                    # This is fine, as _update_ui will reflect the state *after* each command.
                                    cmd_exec_result = process_llm_command(self.game_engine, cmd, [args_str], current_game_state)
                                    logger.info(f"CommandWorker: LLM command '{cmd}' execution result: {cmd_exec_result.message if cmd_exec_result else 'No result'}")
                                    if cmd_exec_result and not cmd_exec_result.is_success and cmd_exec_result.message:
                                        # If an LLM command itself fails, output its error message
                                        self.game_engine._output("system", f"Error processing internal command '{cmd}': {cmd_exec_result.message}")

                                except Exception as e_cmd:
                                    logger.error(f"CommandWorker: Error processing extracted LLM command '{cmd}': {e_cmd}", exc_info=True)
                                    self.game_engine._output("system", f"System error processing internal command '{cmd}'.")
                
                self.finished.emit()
            except Exception as e:
                logging.error(f"Error processing input: {e}", exc_info=True)
                self.error.emit(str(e))
            finally:
                self.processing.emit(False)
                
    def _process_command(self, command: str):
        """Process a command using the game engine in a separate thread."""
        if not command.strip():
            return
        
        # --- ECFA Change: Check if waiting for closing narrative ---
        if self.game_engine._waiting_for_closing_narrative_display:
            self.game_output.append_system_message("Please wait, concluding previous actions...", gradual=False)
            # Re-enable input field as this input is being ignored.
            if self.mode_stacked_widget.currentWidget() == self.narrative_view:
                self.narrative_command_input.setEnabled(True)
                self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            else:
                self.combat_command_input.setEnabled(True)
                self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            return
        # --- End ECFA Change ---

        # Check if this command is UI-generated and should not be echoed as player input
        is_ui_generated_command = False
        try:
            parts = command.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in ["examine", "equip", "unequip", "drop", "use"]:
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10: # Basic UUID-like check
                    is_ui_generated_command = True
        except Exception:
            pass

        # Echo player input only in narrative mode; suppress in combat mode
        try:
            state = self.game_engine.state_manager.current_state
            if not is_ui_generated_command and (not state or state.current_mode != InteractionMode.COMBAT):
                self.game_output.append_player_message(command)
            else:
                logger.info("Suppressing player echo in GameOutputWidget (combat mode or UI-generated command).")
        except Exception:
            if not is_ui_generated_command:
                self.game_output.append_player_message(command)
            
        self._last_submitted_command = command # Still store it to prevent potential echoes from engine if it's re-output
        
        active_command_input = self.narrative_command_input if self.mode_stacked_widget.currentWidget() == self.narrative_view else self.combat_command_input
        active_command_input.clear()
        active_command_input.setEnabled(False)
        active_command_input.command_edit.setPlaceholderText("Processing...")
        
        self.status_bar.showMessage("Processing command...", 0)
        
        self.worker_thread = QThread()
        self.worker = self.CommandWorker(self.game_engine, command)
        self.worker.moveToThread(self.worker_thread)
        
        self.worker_thread.started.connect(self.worker.run)
        self.worker.finished.connect(self._on_command_processed)
        self.worker.error.connect(self._on_command_error)
        self.worker.processing.connect(self._set_processing_state) 
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker_thread.finished.connect(self.worker_thread.deleteLater)
        
        self.worker_thread.start()

    def _on_command_processed(self):
        """Handle completion of command processing."""
        # Update UI components
        self._update_ui()
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
    
    def _on_command_error(self, error_msg):
        """Handle error in command processing."""
        self.game_output.append_system_message(f"Error: {error_msg}")
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")

    def _complete_if_same_event(self, event_id: str) -> None:
        """If the orchestrator is still waiting on this exact event, complete it.
        This guards against UI paths that failed to emit completion and prevents stalls.
        """
        try:
            orch = getattr(self.game_engine, '_combat_orchestrator', None)
            if orch is None:
                return
            # Only complete if we are still on the same event and waiting for visual
            if getattr(orch, 'is_processing_event', False) and getattr(orch, 'is_waiting_for_visual', False):
                current_id = getattr(orch, 'current_event_id_for_signals', None)
                if current_id == event_id:
                    logger.warning(f"Safety net: Completing UI_BAR_UPDATE event {event_id} to avoid stall.")
                    try:
                        orch._handle_visual_display_complete()
                    except Exception:
                        pass
        except Exception as e:
            logger.debug(f"_complete_if_same_event guard failed: {e}")
    
    def _set_processing_state(self, is_processing):
        """Update UI to show processing state."""
        if is_processing:
            self.status_bar.showMessage("Processing command...")
            self.narrative_command_input.command_edit.setPlaceholderText("Processing...")
            self.combat_command_input.command_edit.setPlaceholderText("Processing...")
        else:
            self.status_bar.clearMessage()
            self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.narrative_command_input.setEnabled(True)
            self.combat_command_input.setEnabled(True)
    
    def _handle_game_output(self, role: str, content: str):
        """
        Handle non-orchestrated output from the game engine.
        Orchestrated events are handled by `process_orchestrated_display_event`.
        This method is now for general system messages or direct player echoes
        that are NOT part of the CombatOutputOrchestrator's flow.
        """
        logger.info(f"[LEGACY_OUTPUT] Received: role='{role}', content='{content[:200]}...'")
        
        # Special logging for reintroductory narrative debugging
        if role == "gm" and ("night air" in content.lower() or "find yourself" in content.lower()):
            logger.info(f"LIFECYCLE_DEBUG: _handle_game_output - This appears to be reintroductory narrative")
            logger.info(f"LIFECYCLE_DEBUG: Content length: {len(content)}")
            logger.info(f"LIFECYCLE_DEBUG: About to route to GameOutputWidget")
        
        # Prevent echoing the player's command if it somehow comes through this path
        # This also handles the case where UI-generated commands might be echoed by the engine.
        is_ui_generated_command_pattern = False
        try:
            parts = content.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in ["examine", "equip", "unequip", "drop", "use"]:
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10:
                    is_ui_generated_command_pattern = True
        except: # pylint: disable=bare-except
            pass

        if role == "player" and ( (self._last_submitted_command is not None and content == self._last_submitted_command) or is_ui_generated_command_pattern ):
            logger.warning(f"Skipping potential echo of last command or UI-generated command via _handle_game_output: role='{role}', content='{content[:50]}...'")
            if self._last_submitted_command == content: # Clear only if it was an exact match of last submitted
                 self._last_submitted_command = None 
            return
            
        # Clear last submitted command if this output is different, to allow next player input to be echoed
        if self._last_submitted_command is not None and content != self._last_submitted_command:
             self._last_submitted_command = None

        # Route to GameOutputWidget. The append_text method now takes 'gradual'
        # For non-orchestrated output, usually display immediately (gradual=False)
        if role == "system":
            logger.info(f"LIFECYCLE_DEBUG: Routing system message to game_output.append_system_message")
            self.game_output.append_system_message(content, gradual=False)
        elif role == "gm":
            # General GM messages not part of orchestrated combat flow
            logger.info(f"LIFECYCLE_DEBUG: Routing GM message to game_output.append_gm_message with gradual=True")
            self.game_output.append_gm_message(content, gradual=True) # Allow GM narrative to be gradual
        elif role == "player":
            # Do not echo player messages to narrative output while in COMBAT
            try:
                state = self.game_engine.state_manager.current_state
                if state and state.current_mode == InteractionMode.COMBAT:
                    logger.info("Skipping player role output to GameOutputWidget because we're in COMBAT mode.")
                    return
            except Exception:
                pass
            # This path should be rare now, as player input is directly echoed then processed.
            # This will only catch player output if it's *not* the last submitted command.
            self.game_output.append_player_message(content, gradual=False)
        else:
            self.game_output.append_text(f"[{role}] {content}", gradual=False)
                      
        self._update_ui() # Still update UI for general status, etc.
        
    def _update_ui(self):
            """Update UI components based on the current game state."""
            state = self.game_engine.state_manager.current_state
            if not state:
                logger.debug("MainWindow._update_ui: No game state to update UI from.")
                self.status_bar.update_status(location="Not in game", game_time="", calendar="", mode="N/A")
                if hasattr(self.right_panel, 'character_sheet') and self.right_panel.character_sheet: 
                    self.right_panel.character_sheet._clear_stat_displays() 
                
                inventory_manager_for_clear = get_inventory_manager() 
                logger.info(f"MainWindow._update_ui (no game state): Using InventoryManager instance ID: {getattr(inventory_manager_for_clear, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
                if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager_for_clear) 
                return

            game_over = False
            if state.current_mode == InteractionMode.COMBAT and state.combat_manager:
                if state.combat_manager.state == CombatState.PLAYER_DEFEAT:
                    game_over = True
            elif state.current_mode != InteractionMode.COMBAT: 
                try:
                    stats_manager = self.game_engine._stats_manager
                    if stats_manager:
                        from core.stats.stats_base import DerivedStatType
                        player_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                        if player_hp <= 0: game_over = True
                except Exception as e: logger.error(f"MainWindow._update_ui: Error checking player HP for game over: {e}", exc_info=True)

            if game_over and not hasattr(self, '_game_over_dialog_shown'):
                logger.info("MainWindow._update_ui: Player defeat detected. Showing Game Over dialog.")
                self._game_over_dialog_shown = True 
                self.narrative_command_input.setEnabled(False)
                self.combat_command_input.setEnabled(False)
                dialog = GameOverDialog(self)
                dialog.set_reason("You have been defeated!") 
                dialog.new_game_requested.connect(self._show_new_game_dialog)
                dialog.load_game_requested.connect(self._show_load_game_dialog)
                dialog.load_last_save_requested.connect(self._load_last_save)
                dialog.exec()
                self.narrative_command_input.setEnabled(True)
                self.combat_command_input.setEnabled(True)
                if hasattr(self, '_game_over_dialog_shown'): 
                    delattr(self, '_game_over_dialog_shown') 
                return 
            
            current_mode_enum = state.current_mode
            current_mode_name = current_mode_enum.name if hasattr(current_mode_enum, 'name') else str(current_mode_enum)
            logger.info(f"MainWindow._update_ui: Updating UI. Target mode: {current_mode_name}. Current QStackedWidget widget: {self.mode_stacked_widget.currentWidget().objectName() if self.mode_stacked_widget.currentWidget() else 'None'}")

            is_transitioning_to_combat = getattr(state, 'is_transitioning_to_combat', False)
            combat_narrative_buffer = getattr(state, 'combat_narrative_buffer', [])

            if current_mode_name == "COMBAT":
                view_switched_this_call = False
                if self.mode_stacked_widget.currentWidget() != self.combat_view:
                    logger.info(f"MainWindow._update_ui: Switching to combat_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.combat_view)
                    view_switched_this_call = True
                else:
                    logger.info("MainWindow._update_ui: combat_view is already the current widget.")

                # Ensure combat_view is visible and updated, regardless of whether it was just switched.
                self.combat_view.setVisible(True) # Explicitly ensure visibility
                self.combat_view.update() # Request a repaint of the combat_view
                self.mode_stacked_widget.update() # Request a repaint of the QStackedWidget
                
                if view_switched_this_call:
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.combat_view:
                        logger.info(f"MainWindow._update_ui: Successfully set combat_view as current widget in QStackedWidget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set combat_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                    
                    if hasattr(self.right_panel, 'tab_widget'): 
                        self.right_panel.tab_widget.setCurrentIndex(0)

                if is_transitioning_to_combat and combat_narrative_buffer:
                    logger.info(f"MainWindow._update_ui: Combat transition: Queuing {len(combat_narrative_buffer)} buffered messages with Orchestrator.")
                    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
                    
                    buffer_event = DisplayEvent(
                        type=DisplayEventType.BUFFER_FLUSH,
                        content=list(combat_narrative_buffer), 
                        role="gm", 
                        target_display=DisplayTarget.COMBAT_LOG,
                        gradual_visual_display=True,
                        tts_eligible=True
                    )
                    self.game_engine._combat_orchestrator.add_event_to_queue(buffer_event)
                    
                    state.combat_narrative_buffer.clear() 
                    state.is_transitioning_to_combat = False 
                    logger.debug("MainWindow._update_ui: Cleared combat_narrative_buffer and reset is_transitioning_to_combat flag.")
                
                # Call combat_display.update_display to refresh its content
                logger.info("MainWindow._update_ui (COMBAT mode): Calling combat_display.update_display.")
                self.combat_display.update_display(state) 
                
                if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player) 

                combat_manager = state.combat_manager 
                if view_switched_this_call and combat_manager and combat_manager.current_step == CombatStep.STARTING_COMBAT:
                    if not self.game_engine._combat_orchestrator.is_processing_event and not self.game_engine._combat_orchestrator.event_queue:
                        logger.info(f"MainWindow._update_ui (view switched to COMBAT this call) triggering initial CombatManager.process_combat_step() as Orchestrator is idle.")
                        QTimer.singleShot(10, lambda cm=combat_manager, eng=self.game_engine: cm.process_combat_step(eng))
                elif combat_manager and combat_manager.current_step == CombatStep.AWAITING_PLAYER_INPUT:
                     logger.debug("MainWindow._update_ui: CombatManager is AWAITING_PLAYER_INPUT. No nudge needed.")


            else: # Not in Combat mode
                if self.mode_stacked_widget.currentWidget() != self.narrative_view:
                    logger.info(f"MainWindow._update_ui: Switching to narrative_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.narrative_view:
                        logger.info(f"MainWindow._update_ui: Successfully set narrative_view as current widget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set narrative_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                
                self.narrative_view.setVisible(True) # Ensure narrative view is visible
                self.narrative_view.update()
                self.mode_stacked_widget.update()


                if is_transitioning_to_combat: 
                    logger.warning("MainWindow._update_ui: Was transitioning to combat, but now in narrative. Resetting transition flag.")
                    state.is_transitioning_to_combat = False 
                    state.combat_narrative_buffer.clear()


            if current_mode_enum == InteractionMode.TRADE and \
               (self._previous_mode is None or self._previous_mode != InteractionMode.TRADE):
                partner_id = getattr(state, 'current_trade_partner_id', None)
                partner_name = "Unknown NPC"
                if partner_id and state.world: 
                    partner_obj = getattr(state.world, 'get_character', lambda pid: None)(partner_id)
                    if partner_obj: partner_name = getattr(partner_obj, 'name', "Unknown NPC")
                self.game_output.append_system_message(f"Trade started with {partner_name}.", gradual=False)

            self._previous_mode = current_mode_enum
            if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player)

            inventory_manager = get_inventory_manager() 
            logger.info(f"MainWindow._update_ui: Using InventoryManager instance ID: {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
            if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager)
            
            journal_data = getattr(state, "journal", None)
            if journal_data is not None and hasattr(self.right_panel, 'update_journal'): self.right_panel.update_journal(journal_data)

            self.status_bar.update_status(
                location=getattr(state.player, 'current_location', 'Unknown') if state.player else 'N/A',
                game_time=getattr(state.world, 'time_of_day', ''),
                calendar=getattr(state.world, 'calendar_string', ''),
                mode=current_mode_name 
            )

    def _show_game_panels_for_loaded_game(self):
        """Make game panels visible and enabled when loading a saved game."""
        self._initialize_panel_effects()
        
        # Make center widget visible and enabled
        self.center_widget.setVisible(True)
        self.center_widget.setEnabled(True)
        if hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect.setOpacity(1.0)
        
        # Make right panel visible and enabled
        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(True)
        if hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect.setOpacity(1.0)
        # Ensure right panel is in expanded state for loaded games
        if not self.right_panel.isExpanded():
            self.right_panel.setExpanded(True)
        
        # Make status bar visible and enabled
        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(True)
        if hasattr(self, 'status_bar_opacity_effect'):
            self.status_bar_opacity_effect.setOpacity(1.0)
        
        logger.info("Game panels made visible and enabled for loaded game")

    def _show_new_game_dialog(self):
        """Show dialog for creating a new game."""
        from gui.dialogs.character_creation_dialog import CharacterCreationDialog
        dialog = CharacterCreationDialog(self)
        if dialog.exec():
            character_data = dialog.get_character_data()
            if not character_data: 
                logger.warning("New game character creation cancelled or failed validation in dialog.")
                return

            logger.info(f"Character data received from dialog. Preparing to start panel animations.")
            
            # Start panel animations, passing character_data to be used after animation
            # This will eventually call _start_game_flow_after_animation
            self._start_panel_animations(character_data)
            
            # DO NOT start game engine here. It will be started by _start_game_flow_after_animation.
        else:
            logger.info("New game dialog cancelled by user.")

    def _show_save_game_dialog(self):
        """Show dialog for saving the game."""
        from gui.dialogs.save_game_dialog import SaveGameDialog
        dialog = SaveGameDialog(self)
        if dialog.exec():
            # Save the game with the provided name
            save_name = dialog.save_name_edit.text()
            # Capture current combat log HTML snapshot if in COMBAT
            try:
                state = self.game_engine.state_manager.current_state
                if state and state.current_mode.name == 'COMBAT' and state.combat_manager:
                    # Ensure current Combat Log HTML is stored for save
                    html_snapshot = ""
                    if hasattr(self, 'combat_display') and hasattr(self.combat_display, 'log_text'):
                        html_snapshot = self.combat_display.log_text.toHtml()
                    state.combat_manager.display_log_html = html_snapshot or state.combat_manager.display_log_html
            except Exception as e:
                logger.warning(f"Failed to snapshot Combat Log HTML before save: {e}")
            saved_path = self.game_engine.save_game(save_name)
            
            if saved_path:
                QMessageBox.information(
                    self, 
                    "Game Saved", 
                    f"Game saved successfully to {saved_path}"
                )
    
    def _show_load_game_dialog(self):
        """Show dialog for loading a saved game."""
        from gui.dialogs.load_game_dialog import LoadGameDialog
        dialog = LoadGameDialog(self)
        if dialog.exec():
            # Load the selected save
            save_filename = dialog.selected_save
            if save_filename:
                # Pre-clear orchestrator and displays before loading save to preserve new outputs
                try:
                    if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                        self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
                except Exception as e:
                    logger.warning(f"Failed to clear orchestrator state before load: {e}")
                try:
                    self.game_output.clear()
                except Exception as e:
                    logger.warning(f"Failed to clear GameOutputWidget before load: {e}")
                try:
                    self.combat_display.clear_display()
                except Exception as e:
                    logger.warning(f"Failed to clear CombatDisplay before load: {e}")
                self._last_submitted_command = None
                loaded_state = self.game_engine.load_game(save_filename)
                
                if loaded_state:
                    # Clear right panel tabs to avoid stale data before repopulating
                    try:
                        if hasattr(self.right_panel, 'journal_panel'):
                            self.right_panel.journal_panel.clear_all()
                        if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                            # If a clear method exists use it; otherwise update_inventory will refresh
                            try:
                                self.right_panel.inventory_panel.clear()
                            except Exception:
                                pass
                        if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                            self.right_panel.character_sheet._clear_stat_displays()
                    except Exception as e:
                        logger.warning(f"Failed to clear right panel widgets prior to load repopulation: {e}")

                    # Ensure journal exists
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": self.game_engine.state_manager.current_state.player.background,
                            "quests": {},
                            "notes": []
                        }
                    
                    # Ensure the stats manager is fully initialized
                    self.game_engine.state_manager.ensure_stats_manager_initialized()

                    # Make game panels visible and enabled for loaded games
                    self._show_game_panels_for_loaded_game()
                    
                    # Update UI
                    self._update_ui()

                    # Bind orchestrator to loaded CombatManager if save is in COMBAT
                    try:
                        state = self.game_engine.state_manager.current_state
                        if state and state.current_mode.name == 'COMBAT' and getattr(state, 'combat_manager', None):
                            if hasattr(self.game_engine, '_combat_orchestrator'):
                                self.game_engine._combat_orchestrator.set_combat_manager(state.combat_manager)
                                logger.info("Bound loaded CombatManager to Orchestrator in MainWindow (load dialog).")
                    except Exception as e:
                        logger.warning(f"Failed to bind CombatManager after load in MainWindow: {e}")

                    # Emit consolidated stats_changed to refresh UI listeners
                    try:
                        sm = self.game_engine.state_manager.stats_manager
                        if sm and hasattr(sm, 'stats_changed'):
                            sm.stats_changed.emit(sm.get_all_stats())
                            logger.info("Emitted consolidated stats_changed after load to refresh UI.")
                    except Exception as e:
                        logger.warning(f"Failed to emit stats_changed after load: {e}")
                    
                    # Force character sheet update with current player
                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                else:
                    QMessageBox.warning(
                        self, 
                        "Load Failed", 
                        f"Failed to load game from {save_filename}"
                    )
    
    def _show_settings_dialog(self):
        """Show dialog for game settings."""
        logger.info("Attempting to show SettingsDialog...") # Log entry
        from gui.dialogs.settings.settings_dialog import SettingsDialog
        logger.info("Imported SettingsDialog.") # Log import success

        try:
            dialog = SettingsDialog(self)
            logger.info("SettingsDialog instance created.") # Log instance creation
        except Exception as e:
            logger.error(f"Error INSTANTIATING SettingsDialog: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"Failed to create settings dialog:\n{e}")
            return

        # Connect the background preview signal from the BackgroundTab within the SettingsDialog
        connected = False
        if hasattr(dialog, 'background_tab') and hasattr(dialog.background_tab, 'preview_background_changed'):
            try:
                # Connect the signal that now emits the full filename
                dialog.background_tab.preview_background_changed.connect(self.update_background)
                connected = True
                logger.info("Connected background_preview_changed signal for live preview.")
            except Exception as e:
                 logger.error(f"Error connecting background_preview_changed signal: {e}")
        else:
            logger.warning("Could not find background_tab or preview_background_changed signal in SettingsDialog.")

        saved = False
        try:
            logger.info("Attempting to execute SettingsDialog...") # Log before exec
            # Execute the dialog
            result = dialog.exec()
            logger.info(f"SettingsDialog execution finished with result: {result}") # Log after exec
            if result == QDialog.Accepted: # Check result code
                saved = True
        except Exception as e:
             logger.error(f"Error EXECUTING SettingsDialog: {e}", exc_info=True)
             QMessageBox.critical(self, "Error", f"Failed to execute settings dialog:\n{e}")
        finally:
            # Disconnect signal after dialog is closed
            if connected:
                try:
                    dialog.background_tab.preview_background_changed.disconnect(self.update_background)
                    logger.info("Disconnected background_preview_changed signal.")
                except Exception as e:
                     logger.warning(f"Failed to disconnect background_preview_changed signal: {e}")

        if saved: # Process saved settings only if dialog was accepted
            logger.info("Settings dialog accepted. Applying settings...") # Log applying settings
            # Apply new settings
            settings = SettingsDialog.get_settings() # Re-fetch to be sure

            # Update dev controls visibility immediately after settings change
            try:
                q_settings = QSettings("RPGGame", "Settings")
                dev_enabled = q_settings.value("dev/enabled", False, type=bool)
                if hasattr(self, 'combat_display') and hasattr(self.combat_display, 'dev_controls_container'):
                    self.combat_display.dev_controls_container.setVisible(bool(dev_enabled))
                # Also toggle orchestrator step mode to match dev setting default (off until user toggles)
                if hasattr(self.game_engine, '_combat_orchestrator') and hasattr(self.game_engine._combat_orchestrator, 'toggle_dev_step_mode'):
                    self.game_engine._combat_orchestrator.toggle_dev_step_mode(False)
            except Exception as e:
                logger.warning(f"Failed to update dev controls visibility post settings: {e}")

            # Update resolution if needed
            resolution = settings["display"]["windowed_size"] # Use windowed_size now
            current_state = settings["display"]["window_state"]

            logger.info(f"Applying settings - State: {current_state}, Windowed Size: {resolution}")

            # Apply window state changes
            if current_state == "fullscreen":
                if not self.isFullScreen(): self.showFullScreen()
            elif current_state == "maximized":
                 if not self.isMaximized(): self.showMaximized()
            else: # windowed
                 if self.isFullScreen() or self.isMaximized(): self.showNormal()
                 # Check if size actually needs changing
                 if QSize(resolution[0], resolution[1]) != self.size():
                     self.resize(resolution[0], resolution[1]) # Use tuple values

            # Update styling (includes non-background styles)
            self._update_styling()

            # Explicitly apply the *saved* background setting after dialog closes
            q_settings = QSettings("RPGGame", "Settings")
            saved_filename = q_settings.value("style/background_filename", None)
            if saved_filename:
                 logger.info(f"Applying saved background from QSettings: {saved_filename}")
                 self.update_background(saved_filename)
            else:
                 logger.warning("Could not read saved background filename after settings dialog closed.")

            # Update UI based on new settings (e.g., status bar, panels)
            # self._update_ui() # Update UI can be complex, might re-trigger things, maybe call specific updates?
            # Let's rely on the window state change and styling update for now.

            # Reload autosave settings (turn-based) in the engine
            try:
                if hasattr(self.game_engine, 'reload_autosave_settings'):
                    self.game_engine.reload_autosave_settings()
            except Exception as e:
                logger.warning(f"Failed to reload autosave settings after saving: {e}")

            # Show confirmation
            self.game_output.append_system_message("Settings saved successfully.")
            logger.info("Settings applied successfully.")
        else:
             logger.info("Settings dialog cancelled or closed without saving.")
    
    def update_background(self, filename: Optional[str]):
        """Load and apply a new background image or GIF to the main window."""
        logger.info(f"Attempting to update background to: {filename}")

        # Stop and clear any existing movie/pixmap
        current_movie = self.background_label.movie()
        if current_movie:
            current_movie.stop()
            self.background_label.setMovie(None)
        self.background_label.setPixmap(QPixmap())
        # Reset palette to default in case previous was PNG
        self.background_container.setAutoFillBackground(False) # Important! Don't let palette fill container
        self.background_label.setProperty("current_background", None) # Store current bg filename

        if not filename:
            logger.warning("No background filename provided, clearing background.")
            # Optionally set a default color on the label if needed
            self.background_label.setStyleSheet("background-color: #1E1E1E;")
            return

        name, ext = os.path.splitext(filename)
        ext_lower = ext.lower()

        if ext_lower == ".png":
            pixmap = self.resource_manager.get_background_pixmap(name)
            if not pixmap.isNull():
                self.background_label.setPixmap(pixmap) # Label scales content
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied PNG background: {filename}")
            else:
                logger.warning(f"Failed to load PNG background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")

        elif ext_lower == ".gif":
            movie = self.resource_manager.get_background_movie(name)
            if movie.isValid():
                self.background_label.setMovie(movie)
                movie.start()
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied GIF background: {filename}")
            else:
                logger.warning(f"Failed to load GIF background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")
        else:
            logger.error(f"Unsupported background file type: {filename}")
            self.background_label.setStyleSheet("background-color: #1E1E1E;") # Fallback color

    def _load_and_apply_initial_background(self):
        """Load the saved background filename from settings and apply it.
        If no valid setting is found, use the first available background alphabetically.
        """
        settings = QSettings("RPGGame", "Settings")
        # Read the full filename setting
        saved_filename = settings.value("style/background_filename", None)

        available_backgrounds = self.resource_manager.list_background_names() # Gets list of (name, ext)
        final_filename = None

        # Check if saved filename exists in the available list
        if saved_filename:
            found = False
            for name, ext in available_backgrounds:
                if f"{name}{ext}" == saved_filename:
                    final_filename = saved_filename
                    found = True
                    break
            if found:
                logger.info(f"Using saved background: {final_filename}")
            else:
                logger.warning(f"Saved background '{saved_filename}' not found in available list.")
                saved_filename = None # Treat as not found

        # If no valid saved name, use the first available background
        if not final_filename and available_backgrounds:
            first_name, first_ext = available_backgrounds[0] # Use first alphabetically
            final_filename = f"{first_name}{first_ext}"
            logger.info(f"No valid saved background found. Using first available: {final_filename}")
        elif not final_filename:
             logger.warning("No saved background setting found and no backgrounds available in images/gui/background/. Applying fallback color.")
             # update_background will handle the fallback color if name is None

        self.update_background(final_filename) # Pass None if no background is available

    def _update_styling(self):
        """Update UI styling based on saved settings."""
        # Update game output styling and formats
        self.game_output._update_formats()
        self.game_output._setup_background()
        
        # Get settings for command input styling
        settings = QSettings("RPGGame", "Settings")
        
        # Update command input styling
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")
        
        # Create a dark frame around command input and enter button
        # Get transparency setting
        input_opacity = int(settings.value("style/input_opacity", 100))
        opacity_percent = input_opacity / 100.0
        
        # Calculate RGB values for the background
        bg_color_obj = QColor("#333333")
        r, g, b = bg_color_obj.red(), bg_color_obj.green(), bg_color_obj.blue()
        
        # Common style for command inputs
        command_input_style = f"""
            CommandInputWidget {{
                background-color: rgba({r}, {g}, {b}, {opacity_percent});
                border-radius: 10px;
                padding: 5px;
                border: 2px solid #333333; /* Same as left/right panels */
            }}
            QLineEdit {{
                background-color: rgba(255, 255, 255, 0.7);
                color: {user_input_font_color};
                border: 1px solid #c4b59d;
                border-radius: 4px;
                padding: 8px;
                font-family: '{user_input_font_family}';
                font-size: {user_input_font_size}pt;
                margin-left: 5px;
                margin-right: 5px;
            }}
        """
        
        # Apply style to both command inputs
        self.narrative_command_input.setStyleSheet(command_input_style)
        self.combat_command_input.setStyleSheet(command_input_style)
    
    def _show_llm_settings_dialog(self):
        """Show dialog for LLM settings."""
        dialog = LLMSettingsDialog(self)
        dialog.settings_saved.connect(self._on_llm_settings_saved)
        dialog.exec()
    
    def _on_llm_settings_saved(self):
        """Handle LLM settings saved event."""
        # Update UI elements that depend on LLM settings
        is_llm_enabled = self.game_engine._use_llm
        
        # Add UI feedback to show LLM status when explicitly changed through settings
        if is_llm_enabled:
            self.game_output.append_system_message("LLM processing is now enabled.")
        else:
            self.game_output.append_system_message("LLM processing is now disabled.")

    # Removed _delayed_character_update method - we now use direct update instead of timers
    
    def closeEvent(self, event):
        """Handle window close event."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.Yes | QMessageBox.No, 
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def resizeEvent(self, event):
        """Handle window resize event to keep background and content sized correctly."""
        super().resizeEvent(event)
        # Keep background label and content widget filling the container
        if hasattr(self, 'background_label'): # Check if widgets exist yet
             self.background_label.setGeometry(0, 0, event.size().width(), event.size().height())
        if hasattr(self, 'main_content_widget'):
             self.main_content_widget.setGeometry(0, 0, event.size().width(), event.size().height())

    def _load_last_save(self):
        """Loads the most recent non-auto save file."""
        logger.info("Attempting to load last save.")
        from core.utils.save_manager import SaveManager # Local import
        save_manager = SaveManager()
        try:
            # Get recent saves, excluding backups and auto-saves initially
            saves = save_manager.get_recent_saves(count=10, include_backups=False) # Get a few recent ones
            last_manual_save = None
            for save in saves:
                 if not save.auto_save:
                      last_manual_save = save
                      break # Found the most recent manual save

            if last_manual_save:
                save_filename = f"{last_manual_save.save_id}/{SaveManager.STATE_FILENAME}" # Need correct path format if StateManager expects full path or just ID
                save_id = last_manual_save.save_id # Use the ID for loading
                logger.info(f"Found last manual save: {last_manual_save.save_name} (ID: {save_id})")

                # Clear any previous UI content and pending orchestrator events BEFORE loading
                try:
                    if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                        self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
                except Exception as e:
                    logger.warning(f"Failed to clear orchestrator state before load: {e}")
                
                try:
                    self.game_output.clear()
                except Exception as e:
                    logger.warning(f"Failed to clear GameOutputWidget before load: {e}")
                
                try:
                    self.combat_display.clear_display()
                except Exception as e:
                    logger.warning(f"Failed to clear CombatDisplay before load: {e}")
                
                # Also clear right panel content to avoid stale state
                try:
                    if hasattr(self.right_panel, 'journal_panel'):
                        self.right_panel.journal_panel.clear_all()
                    if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                        try:
                            self.right_panel.inventory_panel.clear()
                        except Exception:
                            pass
                    if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                        self.right_panel.character_sheet._clear_stat_displays()
                except Exception as e:
                    logger.warning(f"Failed to clear right panel widgets before load: {e}")
                
                self._last_submitted_command = None
                
                # Call engine's load_game method
                loaded_state = self.game_engine.load_game(save_id) # Pass save_id

                if loaded_state:
                    # Ensure journal exists (similar to _show_load_game_dialog)
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": getattr(self.game_engine.state_manager.current_state.player, 'background', ''),
                            "quests": {},
                            "notes": []
                        }
                    self.game_engine.state_manager.ensure_stats_manager_initialized()

                    # Make game panels visible and enabled for loaded games
                    self._show_game_panels_for_loaded_game()
                    
                    self._update_ui() # Update UI after load

                    # Bind orchestrator to loaded CombatManager if save is in COMBAT
                    try:
                        state = self.game_engine.state_manager.current_state
                        if state and state.current_mode.name == 'COMBAT' and getattr(state, 'combat_manager', None):
                            if hasattr(self.game_engine, '_combat_orchestrator'):
                                self.game_engine._combat_orchestrator.set_combat_manager(state.combat_manager)
                                logger.info("Bound loaded CombatManager to Orchestrator in MainWindow (load last save).")
                    except Exception as e:
                        logger.warning(f"Failed to bind CombatManager after loading last save: {e}")

                    # Emit consolidated stats_changed to refresh UI listeners
                    try:
                        sm = self.game_engine.state_manager.stats_manager
                        if sm and hasattr(sm, 'stats_changed'):
                            sm.stats_changed.emit(sm.get_all_stats())
                            logger.info("Emitted consolidated stats_changed after loading last save.")
                    except Exception as e:
                        logger.warning(f"Failed to emit stats_changed after loading last save: {e}")

                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                    self.game_output.append_system_message(f"Loaded last save: {last_manual_save.save_name}")
                else:
                    QMessageBox.warning(self, "Load Failed", f"Failed to load last save: {last_manual_save.save_name}")
                    # If last save fails, open the regular load dialog
                    self._show_load_game_dialog()
            else:
                logger.warning("No manual saves found to load.")
                QMessageBox.information(self, "No Last Save", "No manual save file found. Please load manually or start a new game.")
                # Open the regular load dialog as fallback
                self._show_load_game_dialog()
        except Exception as e:
            logger.error(f"Error loading last save: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An error occurred while trying to load the last save:\n{e}")
            self._show_load_game_dialog() # Fallback to regular load dialog

    @Slot(object) 
    def process_orchestrated_display_event(self, event):
        """
        Handles DisplayEvents routed from the CombatOutputOrchestrator via the GameEngine.
        This method sends the content to the appropriate UI display widget.
        """
        from core.orchestration.events import DisplayEvent, DisplayTarget, DisplayEventType 
        if not isinstance(event, DisplayEvent):
            logger.error(f"MainWindow received non-DisplayEvent object: {type(event)}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()
            return

        logger.info(f"MainWindow processing orchestrated event: {event}")
        state = self.game_engine.state_manager.current_state

        target_widget = None
        # Determine primary target widget
        if event.target_display == DisplayTarget.COMBAT_LOG:
            target_widget = self.combat_display
        elif event.target_display == DisplayTarget.MAIN_GAME_OUTPUT:
            target_widget = self.game_output
            # Ensure the narrative view is visible if routing to MAIN_GAME_OUTPUT AND we are not currently in COMBAT mode
            try:
                state_for_switch = self.game_engine.state_manager.current_state
                if state_for_switch and state_for_switch.current_mode != InteractionMode.COMBAT:
                    if self.mode_stacked_widget.currentWidget() != self.narrative_view:
                        logger.info("MainWindow: MAIN_GAME_OUTPUT event and current mode not COMBAT. Switching to narrative_view.")
                        self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
                        self.narrative_view.setVisible(True)
                        self.mode_stacked_widget.update()
            except Exception as e:
                logger.warning(f"Failed conditional switch to narrative_view on MAIN_GAME_OUTPUT event: {e}")
        else: # Default based on mode if target not explicit
            if state and state.current_mode == InteractionMode.COMBAT:
                target_widget = self.combat_display
            else:
                target_widget = self.game_output
        
        if not target_widget and event.type not in [DisplayEventType.TURN_ORDER_UPDATE, DisplayEventType.UI_BAR_UPDATE_PHASE1, DisplayEventType.UI_BAR_UPDATE_PHASE2]: # These might not have a primary text widget
            logger.error(f"No target widget found for orchestrated event: {event} and not a special UI event.")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete() 
            return

        # Handle event types
        if event.type == DisplayEventType.BUFFER_FLUSH:
            if isinstance(event.content, list) and target_widget == self.combat_display:
                # New: perfect fidelity replay with role per line, batched to a single completion
                try:
                    # Suppress per-line completion during batch
                    if hasattr(self.combat_display, '_suppress_visual_complete'):
                        self.combat_display._suppress_visual_complete = True
                    for item in event.content:
                        if isinstance(item, dict) and 'text' in item:
                            line_text = str(item.get('text', ''))
                            line_role = item.get('role', event.role or 'gm')
                            if line_text:
                                self.combat_display.append_orchestrated_event_content(line_text, line_role, is_gradual=False)
                        else:
                            # Fallback: treat as plain string
                            self.combat_display.append_orchestrated_event_content(str(item), event.role or 'gm', is_gradual=False)
                except Exception as e:
                    logger.error(f"Error during BUFFER_FLUSH replay: {e}", exc_info=True)
                finally:
                    if hasattr(self.combat_display, '_suppress_visual_complete'):
                        self.combat_display._suppress_visual_complete = False
                # Signal completion once for the whole batch (async to avoid re-entrancy)
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    try:
                        QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)
                    except Exception:
                        # Fallback to direct call if QTimer not available
                        self.game_engine._combat_orchestrator._handle_visual_display_complete()
            else:
                logger.error(f"Invalid content type or target for BUFFER_FLUSH event: {type(event.content)}, target: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()

        elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1 or event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
            logger.debug(f"Handling UI_BAR_UPDATE event: {event.metadata}")
            entity_id = event.metadata.get("entity_id")
            bar_type = event.metadata.get("bar_type") 
            
            # Diagnostic: player mapping and widget presence
            player_id_diag = None
            state_for_diag = self.game_engine.state_manager.current_state
            if state_for_diag and state_for_diag.player:
                player_id_diag = getattr(state_for_diag.player, 'id', getattr(state_for_diag.player, 'stats_manager_id', None))
            logger.info(f"UI_BAR_UPDATE {event.type.name}: bar={bar_type}, entity={entity_id}, is_player={(entity_id==player_id_diag)}")
            
            # Update CharacterSheet if it's the player (do this first to align visual timing with CombatDisplay)
            player_id = None
            if state and state.player:
                 player_id = getattr(state.player, 'id', getattr(state.player, 'stats_manager_id', None))

            player_bar_updated = False
            if entity_id == player_id and self.right_panel and self.right_panel.character_sheet:
                try:
                    if event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1:
                        self.right_panel.character_sheet.player_resource_bar_update_phase1(bar_type, event.metadata)
                        player_bar_updated = True
                    elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
                        self.right_panel.character_sheet.player_resource_bar_update_phase2(bar_type, event.metadata)
                        player_bar_updated = True
                except Exception as e:
                    logger.error(f"Error updating CharacterSheet for player bar update: {e}", exc_info=True)

            # Update CombatEntityWidget in CombatDisplay
            entity_widget_combat_display = self.combat_display.entity_widgets.get(entity_id)
            logger.info(f"CombatDisplay widget exists for entity? {bool(entity_widget_combat_display)}")
            animation_invoked = False
            if entity_widget_combat_display:
                method_name = f"animate_{event.type.name.lower()}"
                try:
                    if hasattr(entity_widget_combat_display, method_name):
                        getattr(entity_widget_combat_display, method_name)(event.metadata)
                        animation_invoked = True
                    else:
                        logger.warning(f"CombatEntityWidget missing method {method_name} for entity {entity_id}. Will complete event to prevent stall.")
                except Exception as e:
                    logger.error(f"Error invoking {method_name} on CombatEntityWidget for entity {entity_id}: {e}", exc_info=True)

            # If no animation method was invoked, or if widget is missing, proactively complete to avoid stall
            if (not entity_widget_combat_display) or (not animation_invoked):
                 if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    try:
                        QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)
                    except Exception:
                        self.game_engine._combat_orchestrator._handle_visual_display_complete()
                 if not entity_widget_combat_display:
                     logger.warning(f"UI_BAR_UPDATE for entity {entity_id} but no CombatEntityWidget found. Signalled completion to avoid stall.")
                 else:
                     logger.info(f"UI_BAR_UPDATE fallback completion invoked (no animation) for entity {entity_id}.")

            # Final safety net: if the orchestrator is still processing this same event shortly after, complete it
            try:
                QTimer.singleShot(10, lambda ev_id=event.event_id: self._complete_if_same_event(ev_id))
            except Exception:
                pass


        elif event.type == DisplayEventType.TURN_ORDER_UPDATE:
            if self.right_panel and self.right_panel.character_sheet and hasattr(self.right_panel.character_sheet, 'handle_turn_order_update'):
                self.right_panel.character_sheet.handle_turn_order_update(event.content) # event.content is the data dict
            # This event is primarily for CharacterSheet, CombatDisplay updates turn order itself.
            # Signal completion immediately as CharacterSheet update is synchronous.
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                 QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)


        elif event.type == DisplayEventType.COMBAT_LOG_SET_HTML:
            # Directly set Combat Log HTML for instant rehydration
            try:
                if target_widget == self.combat_display and isinstance(event.content, str):
                    # Freeze updates for fast set
                    self.combat_display.log_text.setUpdatesEnabled(False)
                    self.combat_display.log_text.setHtml(event.content)
                    # Move caret to end and ensure visible using correct API
                    self.combat_display.log_text.moveCursor(QTextCursor.MoveOperation.End)
                    self.combat_display.log_text.ensureCursorVisible()
                    self.combat_display.log_text.setUpdatesEnabled(True)
                else:
                    logger.error(f"COMBAT_LOG_SET_HTML received but target or content invalid: {target_widget}, {type(event.content)}")
            except Exception as e:
                logger.error(f"Error applying COMBAT_LOG_SET_HTML: {e}", exc_info=True)
            # No need to explicitly call visual completion; orchestrator doesn't wait for this type
        elif isinstance(event.content, str): # For NARRATIVE_*, SYSTEM_MESSAGE
            if target_widget == self.combat_display:
                # Log event routing for diagnostics
                logger.info(f"MainWindow: Routing string event to CombatDisplay id={event.event_id} type={event.type.name} gradual={bool(event.gradual_visual_display)}")
                self.combat_display.append_orchestrated_event_content(
                    event_content=event.content,
                    event_role=event.role or "system",
                    is_gradual=event.gradual_visual_display,
                    event_id=event.event_id
                )
            elif target_widget == self.game_output:
                text_format = None 
                if event.role == "system": text_format = self.game_output.system_format
                elif event.role == "gm": text_format = self.game_output.gm_format
                elif event.role == "player": text_format = self.game_output.player_format
                # Hide [DEV] messages unless dev mode is enabled
                try:
                    if isinstance(event.content, str) and event.content.strip().startswith("[DEV]"):
                        q_settings = QSettings("RPGGame", "Settings")
                        if not q_settings.value("dev/enabled", False, type=bool):
                            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                                self.game_engine._combat_orchestrator._handle_visual_display_complete()
                            return
                except Exception:
                    pass
                self.game_output.append_text(event.content, text_format, event.gradual_visual_display)
            elif target_widget is None and event.type == DisplayEventType.TURN_ORDER_UPDATE:
                 # This was already handled above, but log if it falls through
                 logger.debug("TURN_ORDER_UPDATE already handled for CharacterSheet, no primary text widget needed.")
            else:
                logger.error(f"Unhandled target widget for orchestrated string event: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()
        else:
            logger.error(f"Orchestrated event has non-string content and is not a known special type: {event}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()

    def _initialize_panel_effects(self):
        """Initialize QGraphicsOpacityEffect for panels that will be animated."""
        if not hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect = QGraphicsOpacityEffect(self.center_widget)
            self.center_widget.setGraphicsEffect(self.center_opacity_effect)
            self.center_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect = QGraphicsOpacityEffect(self.right_panel)
            self.right_panel.setGraphicsEffect(self.right_panel_opacity_effect)
            self.right_panel_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'status_bar_opacity_effect'):
            self.status_bar_opacity_effect = QGraphicsOpacityEffect(self.status_bar)
            self.status_bar.setGraphicsEffect(self.status_bar_opacity_effect)
            self.status_bar_opacity_effect.setOpacity(0.0)

    def _start_panel_animations(self, character_data: Dict[str, Any]):
        """Starts the animation sequence for showing the main game panels."""
        self._character_data_for_new_game = character_data 

        self._initialize_panel_effects()

        # 1. Make panels visible (for layout) but keep them disabled and transparent
        self.center_widget.setVisible(True)
        self.center_widget.setEnabled(False) # Keep disabled during animation
        self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False) # Keep disabled during animation
        # Ensure right_panel is set to its desired initial expanded state before animation
        if not self.right_panel.isExpanded(): 
             self.right_panel.setExpanded(True) # Set its state, width animation will be part of its logic
        self.right_panel_opacity_effect.setOpacity(0.0)

        animation_duration = 300 

        center_anim = QPropertyAnimation(self.center_opacity_effect, b"opacity", self)
        center_anim.setDuration(animation_duration)
        center_anim.setStartValue(0.0)
        center_anim.setEndValue(1.0)
        center_anim.setEasingCurve(QEasingCurve.InOutQuad)

        right_panel_anim = QPropertyAnimation(self.right_panel_opacity_effect, b"opacity", self)
        right_panel_anim.setDuration(animation_duration)
        right_panel_anim.setStartValue(0.0)
        right_panel_anim.setEndValue(1.0)
        right_panel_anim.setEasingCurve(QEasingCurve.InOutQuad)

        self.parallel_anim_group = QParallelAnimationGroup(self)
        self.parallel_anim_group.addAnimation(center_anim)
        self.parallel_anim_group.addAnimation(right_panel_anim)

        self.parallel_anim_group.finished.connect(self._animate_status_bar_in)
        self.parallel_anim_group.start(QPropertyAnimation.DeleteWhenStopped)

    @Slot()
    def _animate_status_bar_in(self):
        """Makes the status bar visible and animates its fade-in."""
        # Enable the center and right panels now that their fade-in is complete
        self.center_widget.setEnabled(True)
        self.right_panel.setEnabled(True)
        logger.info("Center widget and Right panel enabled after fade-in.")

        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False) # Keep disabled during its own animation
        self.status_bar_opacity_effect.setOpacity(0.0)

        status_bar_anim = QPropertyAnimation(self.status_bar_opacity_effect, b"opacity", self)
        status_bar_anim.setDuration(200) 
        status_bar_anim.setStartValue(0.0)
        status_bar_anim.setEndValue(1.0)
        status_bar_anim.setEasingCurve(QEasingCurve.InOutQuad)

        status_bar_anim.finished.connect(self._start_game_flow_after_animation)
        status_bar_anim.start(QPropertyAnimation.DeleteWhenStopped) 

    @Slot()
    def _start_game_flow_after_animation(self):
        """Final step after all panel animations are complete. Starts the game engine flow."""
        self.status_bar.setEnabled(True)
        logger.info("Status bar enabled after fade-in.")
        logger.info("All panel animations complete. Starting game engine flow.")

        character_data = getattr(self, '_character_data_for_new_game', None)
        if not character_data:
            logger.error("Character data not found after animation. Cannot start new game.")
            QMessageBox.critical(self, "Error", "Failed to retrieve character data to start the game.")
            # Reset UI to pre-new-game state
            self.center_widget.setVisible(False)
            self.center_widget.setEnabled(False)
            if hasattr(self, 'center_opacity_effect'): self.center_opacity_effect.setOpacity(0.0)
            
            self.right_panel.setVisible(False)
            self.right_panel.setEnabled(False)
            if hasattr(self, 'right_panel_opacity_effect'): self.right_panel_opacity_effect.setOpacity(0.0)

            self.status_bar.setVisible(False)
            self.status_bar.setEnabled(False)
            if hasattr(self, 'status_bar_opacity_effect'): self.status_bar_opacity_effect.setOpacity(0.0)
            return

        player_name = character_data['name']
        race = character_data['race']
        path = character_data['path']
        origin_id = character_data.get('origin_id', '') # Get origin_id
        sex = character_data.get('sex', 'Male')
        # 'description' from character_data is the origin's intro_text/background
        origin_description_as_background = character_data.get('description', '') 
        character_image = character_data.get('character_image')
        use_llm = character_data.get('use_llm', True)
        custom_stats = None
        if 'stats' in character_data:
            if all(isinstance(val, int) for val in character_data['stats'].values()):
                custom_stats = character_data['stats']
            else: 
                logger.warning("Unexpected stats format from character_data, attempting to parse.")
                temp_stats = {}
                for stat_name, stat_info in character_data['stats'].items():
                    if isinstance(stat_info, dict) and 'base' in stat_info:
                        temp_stats[stat_name] = stat_info['base']
                    elif isinstance(stat_info, int):
                         temp_stats[stat_name] = stat_info
                if temp_stats: custom_stats = temp_stats
        
        logger.info(f"Starting new game with resolved data: Name={player_name}, Race={race}, Path={path}, OriginID={origin_id}, Sex={sex}, LLM={use_llm}, Stats={custom_stats is not None}")

        # Pre-clear any previous session UI and orchestrator state if starting a new game during an ongoing session
        try:
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                # Detach any existing CombatManager and clear queued events
                try:
                    self.game_engine._combat_orchestrator.set_combat_manager(None)
                except Exception:
                    pass
                self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
        except Exception as e:
            logger.warning(f"Failed to clear orchestrator state before starting new game: {e}")
        # Ensure any lingering closing-narrative wait flag is reset
        try:
            if hasattr(self.game_engine, '_waiting_for_closing_narrative_display'):
                self.game_engine._waiting_for_closing_narrative_display = False
        except Exception:
            pass
        # Clear visible outputs to avoid mixing old content
        try:
            self.game_output.clear()
        except Exception as e:
            logger.warning(f"Failed to clear GameOutputWidget before starting new game: {e}")
        try:
            self.combat_display.clear_display()
        except Exception as e:
            logger.warning(f"Failed to clear CombatDisplay before starting new game: {e}")
        # Clear right panel widgets to avoid stale state
        try:
            if hasattr(self.right_panel, 'journal_panel'):
                self.right_panel.journal_panel.clear_all()
            if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                try:
                    self.right_panel.inventory_panel.clear()
                except Exception:
                    pass
            if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                self.right_panel.character_sheet._clear_stat_displays()
        except Exception as e:
            logger.warning(f"Failed to clear right panel widgets before starting new game: {e}")
        # Reset last submitted command tracking
        self._last_submitted_command = None

        self.game_engine.start_new_game(
            player_name=player_name, 
            race=race, 
            path=path, 
            background=origin_description_as_background, # Pass origin description as background
            sex=sex,
            character_image=character_image,
            stats=custom_stats,
            origin_id=origin_id # Pass origin_id here
        )
        
        self.game_engine.set_llm_enabled(use_llm)
        
        # Ensure journal quests is a dictionary
        initial_quests_data = character_data.get('initial_quests', [])
        journal_quests = {}
        if isinstance(initial_quests_data, dict):
            journal_quests = initial_quests_data
        elif isinstance(initial_quests_data, list):
            logger.warning(f"Initial quests from origin is a list: {initial_quests_data}. Initializing journal quests as an empty dictionary. Full quest population from origin list is not yet implemented here.")
        
        current_game_state = self.game_engine.state_manager.current_state
        if current_game_state:
            if not hasattr(current_game_state, "journal") or current_game_state.journal is None:
                current_game_state.journal = {
                    "character": origin_description_as_background, # Use the same background/origin text
                    "quests": journal_quests,
                    "notes": []
                }
            # Ensure player state's origin_id is set, if GameEngine.start_new_game didn't already
            if not current_game_state.player.origin_id:
                 current_game_state.player.origin_id = origin_id
        
        self._update_ui() 
        self.game_engine.state_manager.ensure_stats_manager_initialized()
        
        if current_game_state and current_game_state.player:
            self.right_panel.update_character(current_game_state.player)

        # Clean up the temporary data
        if hasattr(self, '_character_data_for_new_game'):
            delattr(self, '_character_data_for_new_game')

    @Slot(str)
    def _handle_item_use_requested(self, item_id: str):
        """Handle item use request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item use requested for ID: {item_id}")
        # Placeholder: Implement logic to use the item via InventoryManager or GameEngine
        # For example, this might involve checking if the item is consumable,
        # applying its effects, and removing it from inventory.
        # This could also involve a command like "use <item_id>"
        
        # Example:
        # result = self.game_engine.process_command(f"use {item_id}")
        # self._update_ui() # Update UI after action
        self.game_output.append_system_message(f"Attempting to use item: {item_id} (Handler not fully implemented).")
        # This should ideally go through the command processing loop if 'use' is a player command
        self._process_command(f"use {item_id}")

    @Slot(str)
    def _handle_item_examine_requested(self, item_id: str):
        """Handle item examine request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item examine requested for ID: {item_id}")
        
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item_details_for_dialog(item_id)

        if item:
            from gui.dialogs.item_info_dialog import ItemInfoDialog # Local import
            dialog = ItemInfoDialog(item, self)
            dialog.exec()
        else:
            self.game_output.append_system_message(f"Could not find details for item ID: {item_id}", gradual=False)
            logger.error(f"Could not get item details for ID: {item_id} to show dialog.")
        
        self._update_ui() # Update UI in case item properties were discovered

    @Slot(str) 
    def _handle_item_unequip_requested(self, item_identifier: str): 
        """Handle item unequip request from inventory panel. This is now fully mechanical.
           item_identifier is expected to be an item_id from InventoryPanel.
        """
        logger.info(f"[GUI] MainWindow: Mechanical item unequip requested for ITEM_ID: {item_identifier}")
        inventory_manager = get_inventory_manager()
        
        item_to_unequip = inventory_manager.get_item(item_identifier) 
        if not item_to_unequip: 
            logger.error(f"Cannot unequip: Item ID '{item_identifier}' not found.")
            self._update_ui()
            return
        
        slot_found: Optional[EquipmentSlot] = None
        # inventory_manager.equipment is Dict[EquipmentSlot, Optional[Item]]
        for slot_enum_loop, item_obj_loop in inventory_manager.equipment.items(): 
            if item_obj_loop and isinstance(item_obj_loop, Item) and item_obj_loop.id == item_to_unequip.id:
                slot_found = slot_enum_loop
                break
        
        if not slot_found:
            logger.info(f"{item_to_unequip.name} is not currently equipped (triggered by ID from InventoryPanel).")
            self._update_ui()
            return
        
        item_name_unequipped = item_to_unequip.name
        slot_unequipped_from_str = slot_found.value.replace("_", " ")

        if inventory_manager.unequip_item(slot_found): # unequip_item takes slot
            logger.info(f"Successfully unequipped {item_name_unequipped} from {slot_unequipped_from_str}.")
        else:
            logger.warning(f"Failed to unequip {item_name_unequipped} (Identifier: {item_identifier}).")

        self._update_ui()

    @Slot(str)
    def _handle_item_drop_requested(self, item_id: str):
        """Handle item drop request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item drop requested for ID: {item_id}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id)

        if not item:
            logger.error(f"Drop requested for non-existent item ID: {item_id}")
            self._update_ui()
            return

        if inventory_manager.is_item_equipped(item_id):
            reply = QMessageBox.question(
                self,
                "Confirm Drop Equipped Item",
                f"'{item.name}' is currently equipped. Are you sure you want to drop it?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                logger.info(f"Drop cancelled by user for equipped item: {item.name}")
                return 

            slot_to_unequip: Optional[EquipmentSlot] = None
            for slot_enum, equipped_item_obj in inventory_manager.equipment.items(): 
                if equipped_item_obj and isinstance(equipped_item_obj, Item) and equipped_item_obj.id == item_id: # Check type
                    slot_to_unequip = slot_enum
                    break
            if slot_to_unequip:
                inventory_manager.unequip_item(slot_to_unequip)
                logger.info(f"Unequipped '{item.name}' from {slot_to_unequip.value} prior to dropping.")
                self._update_ui() 
            else:
                logger.error(f"Could not find slot for equipped item '{item.name}' to unequip before dropping.")
                return
        
        logger.info(f"Processing drop command for item ID: {item_id} via LLM.")
        self._process_command(f"drop {item_id}") 

    @Slot(str) 
    def _handle_item_equip_requested(self, item_id: str): 
        """Handle item equip request from inventory panel. This is now fully mechanical."""
        logger.info(f"[GUI] MainWindow: Mechanical item equip requested for ID: {item_id}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id)

        if not item:
            # self.game_output.append_system_message(f"Cannot equip: Item ID {item_id} not found.", gradual=False)
            logger.error(f"Failed to equip item {item_id}: Not found in InventoryManager.")
            self._update_ui() # Update UI to reflect potential state changes even on error
            return

        if not item.is_equippable:
            # self.game_output.append_system_message(f"Cannot equip {item.name}: It is not equippable.", gradual=False)
            logger.info(f"Cannot equip {item.name}: It is not equippable.")
            self._update_ui()
            return

        if inventory_manager.equip_item(item.id): # Preferred slot logic is inside equip_item
            equipped_slot_str = "a suitable slot"
            for slot_enum, equipped_item_id in inventory_manager.equipment.items():
                if equipped_item_id == item.id:
                    equipped_slot_str = slot_enum.value.replace("_", " ")
                    break
            logger.info(f"Successfully equipped {item.name} to {equipped_slot_str}.")
            # No direct output to GameOutputWidget here for mechanical actions
        else:
            # self.game_output.append_system_message(f"Could not equip {item.name}. No suitable slot available or other restriction.", gradual=False)
            logger.warning(f"Failed to equip {item.name} (ID: {item.id}). InventoryManager.equip_item returned false.")

        self._update_ui()

    @Slot(EquipmentSlot)
    def _handle_item_unequip_from_slot_requested(self, slot_to_unequip: EquipmentSlot):
        """Handles unequip request specifically from a known slot (e.g., CharacterSheet)."""
        logger.info(f"[GUI] MainWindow: Mechanical item unequip from slot requested: {slot_to_unequip.value}")
        inventory_manager = get_inventory_manager()
        
        item_obj_in_slot = inventory_manager.equipment.get(slot_to_unequip) # This is an Item object or None
        item_name = "Item"
        if item_obj_in_slot and isinstance(item_obj_in_slot, Item): # Check type
            item_name = item_obj_in_slot.name
        
        if inventory_manager.unequip_item(slot_to_unequip):
            logger.info(f"Successfully unequipped {item_name} from {slot_to_unequip.value}.")
        else:
            logger.warning(f"Failed to unequip item from slot: {slot_to_unequip.value}")
        
        self._update_ui()

    @Slot(EquipmentSlot, str)
    def _handle_item_drop_from_slot_requested(self, slot_to_unequip: EquipmentSlot, item_id_to_drop: str):
        """Handles drop request for an item currently equipped in a slot."""
        logger.info(f"[GUI] MainWindow: Item drop from slot requested. Slot: {slot_to_unequip.value}, Item ID: {item_id_to_drop}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id_to_drop)
        item_name = item.name if item else "the item"

        reply = QMessageBox.question(
            self,
            "Confirm Drop",
            f"Are you sure you want to drop the equipped item '{item_name}' from your {slot_to_unequip.value.replace('_',' ')}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            if inventory_manager.unequip_item(slot_to_unequip):
                logger.info(f"Unequipped {item_name} from {slot_to_unequip.value} prior to dropping.")
                self._process_command(f"drop {item_id_to_drop}") 
            else:
                logger.error(f"Failed to unequip {item_name} (ID: {item_id_to_drop}) from slot {slot_to_unequip.value} before dropping.")
        else:
            logger.info(f"Drop cancelled for item {item_name} from slot {slot_to_unequip.value}.")
        
        self._update_ui()
```

### File: main.py

```python
#!/usr/bin/env python3
"""
Main entry point for the RPG game.
This script handles initialization and startup of the game in GUI mode.
"""

import sys
import argparse
import logging
from dotenv import load_dotenv # Import load_dotenv

# Import module initializer
from core.base.init_modules import init_modules
# Use centralized logging config
from core.utils.logging_config import setup_logging as core_setup_logging

# Application version
VERSION = "0.1.0"

def setup_logging():
    """Set up logging using the centralized project configuration."""
    core_setup_logging()

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="RPG Game")
    parser.add_argument("--version", action="version", version=f"RPG Game v{VERSION}")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    
    return parser.parse_args()

def main():
    """Main entry point for the game."""
    load_dotenv() # Load environment variables from .env file
    # Parse command line arguments
    args = parse_arguments()
    
    # Set up logging
    setup_logging()
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Log startup information
    logging.info(f"Starting RPG Game v{VERSION}")
    
    # Initialize all game modules
    init_modules()
    
    # GUI mode
    logging.info("Running in GUI mode")
    try:
        # Import the GUI runner
        from run_gui import run_gui
        run_gui()
    except ImportError as e:
        logging.error(f"Failed to import GUI components: {e}")
        print("Error: Could not start GUI mode. See log for details.")
        sys.exit(1)
    except Exception as e:
        logging.exception(f"Error starting GUI: {e}")
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### File: run_gui.py

```python
#!/usr/bin/env python3
"""
GUI runner for the RPG game.
This script initializes and runs the GUI interface.
"""

import sys
import logging
from PySide6.QtWidgets import QApplication

from gui.main_window import MainWindow
from core.base.engine import get_game_engine
from core.utils.logging_config import setup_logging
from gui.utils.init_settings import init_default_settings
from core.base.init_modules import init_modules

def run_gui():
    """Initialize and run the GUI application."""
    # Set up logging
    setup_logging()
    logger = logging.getLogger("GUI")
    logger.info("Initializing GUI application")
    
    try:
        # Initialize all game modules
        init_modules()
        
        # Create Qt Application
        app = QApplication(sys.argv)
        app.setApplicationName("RPG Game")
        
        # Initialize default settings
        init_default_settings()
        
        # Initialize game engine
        engine = get_game_engine()
        
        # Create main window
        win = MainWindow()
        win.show()
        
        logger.info("GUI application started")
        
        # Run the application
        return app.exec()
    
    except Exception as e:
        logger.exception(f"Error initializing GUI: {e}")
        raise

if __name__ == "__main__":
    # Exit with the application return code
    sys.exit(run_gui())

```

### File: saves\test_time_1.json

```json
{
    "session_id": "71e4c94c-d56d-48b9-b1cd-b4d8148866dc",
    "created_at": 1759610482.2364948,
    "last_saved_at": 1760002305.602825,
    "game_version": "0.1.0",
    "player": {
        "name": "Lars",
        "race": "Cinderspawn",
        "path": "Cleric",
        "background": "The Eternal Flame at the center of the Ashen Camp dances hypnotically, casting long shadows from the temporary structures that surround it. You've arrived just days ago, but already the Covenant has accepted you as one of their own \u2013 an unusually quick integration into their normally closed society. Perhaps they saw something in you that suggested an affinity for their ways, or perhaps the ancestors spoke your name during a ritual.\n\nYour tent, like all others in the camp, is designed for quick assembly and disassembly. The nomadic Ashen Covenant never stays in one place long, following ancient migration patterns known only to their elders. All possessions are considered temporary \u2013 including the ritual dagger you were gifted this morning, which you're expected to surrender during the next Possession Exchange ceremony.\n\nAn elder approaches you now, their skin bearing the distinctive gray markings that indicate frequent Ash Walking \u2013 the mysterious practice of projecting consciousness through the ashes of the dead to commune with ancestors or travel spiritually to the Ashen plane. They've promised to begin your initial training today, starting with the fundamental philosophy that nothing \u2013 not possessions, not places, not even lives \u2013 is permanent. All returns to ash eventually, and in understanding this, the Covenant finds freedom.",
        "sex": "Male",
        "origin_id": "ashen_covenant_recruit",
        "level": 1,
        "experience": 0,
        "stats_manager_id": "a6e77603-8dd1-4639-8bb0-8330bc2dfc29",
        "current_location": "Ashen Camp",
        "current_district": "",
        "inventory_id": "961064b1-9bd4-4873-8128-30648052626a",
        "equipped_items": {},
        "active_quests": [],
        "completed_quests": [],
        "character_image": "D:\\coding\\RPG project\\latest version\\images\\character_icons\\Cinderspawn_Cleric\\1_Cinderspawn_Cleric_Male_male_cleric.jpg",
        "current_resolve": 0.0,
        "active_social_effects": []
    },
    "world": {
        "game_time": 1759653742.2364948,
        "game_date": "Day 1",
        "weather": "Clear",
        "is_day": true,
        "magical_conditions": {},
        "global_vars": {},
        "active_events": []
    },
    "conversation_history": [
        {
            "role": "gm",
            "content": "==== WELCOME TO YOUR ADVENTURE ====\n\nGreetings, Lars the Cinderspawn Cleric from The Eternal Flame at the center of the Ashen Camp dances hypnotically, casting long shadows from the temporary structures that surround it. You've arrived just days ago, but already the Covenant has accepted you as one of their own \u2013 an unusually quick integration into their normally closed society. Perhaps they saw something in you that suggested an affinity for their ways, or perhaps the ancestors spoke your name during a ritual.\n\nYour tent, like all others in the camp, is designed for quick assembly and disassembly. The nomadic Ashen Covenant never stays in one place long, following ancient migration patterns known only to their elders. All possessions are considered temporary \u2013 including the ritual dagger you were gifted this morning, which you're expected to surrender during the next Possession Exchange ceremony.\n\nAn elder approaches you now, their skin bearing the distinctive gray markings that indicate frequent Ash Walking \u2013 the mysterious practice of projecting consciousness through the ashes of the dead to commune with ancestors or travel spiritually to the Ashen plane. They've promised to begin your initial training today, starting with the fundamental philosophy that nothing \u2013 not possessions, not places, not even lives \u2013 is permanent. All returns to ash eventually, and in understanding this, the Covenant finds freedom.!\n\nYour journey begins now...",
            "timestamp": 1759610482.2740648
        },
        {
            "role": "gm",
            "content": "Welcome back, Lars! You are currently at Ashen Camp.",
            "timestamp": 1759962839.299874
        },
        {
            "role": "gm",
            "content": "The air hangs heavy with the scent of woodsmoke and ash as the setting sun paints the canvas tents of the Ashen Camp in hues of orange and deep purple. You, Lars, a Cinderspawn Cleric, stand just outside your temporary dwelling, the ritual dagger gifted to you this morning resting in your hand. The Elder's words echo in your mind: \"Nothing is permanent.\" The hypnotic dance of the Eternal Flame at the camp's center draws your gaze, its flickering light a stark contrast to the encroaching darkness. The Elder, with their ash-marked skin, awaits you to begin your training, their presence a silent invitation to embrace the Covenant's philosophy.",
            "timestamp": 1759962840.9859867
        },
        {
            "role": "player",
            "content": "i dont know why, but I fall asleep for the next 12 hours...",
            "timestamp": 1759962857.2135456
        },
        {
            "role": "gm",
            "content": "The Elder nods sagely as you confess your sudden, overwhelming fatigue. Without protest, you retreat into your tent, the sounds of the Ashen Camp fading as sleep claims you. The rhythmic crackle of the Eternal Flame provides a strange lullaby, carrying you deep into slumber for what feels like an eternity.",
            "timestamp": 1759962860.988099
        }
    ],
    "event_log": [
        {
            "type": "ItemDelta",
            "item_id": "ash-treated_clothing",
            "delta": 1,
            "source": "inventory_add",
            "game_time": 1759610482.2364948
        },
        {
            "type": "ItemDelta",
            "item_id": "covenant_pendant",
            "delta": 1,
            "source": "inventory_add",
            "game_time": 1759610482.2364948
        },
        {
            "type": "ItemDelta",
            "item_id": "fire_striker",
            "delta": 1,
            "source": "inventory_add",
            "game_time": 1759610482.2364948
        },
        {
            "type": "ItemDelta",
            "item_id": "ritual_dagger",
            "delta": 1,
            "source": "inventory_add",
            "game_time": 1759610482.2364948
        },
        {
            "type": "ItemDelta",
            "item_id": "small_pouch_of_ancestral_ash",
            "delta": 1,
            "source": "inventory_add",
            "game_time": 1759610482.2364948
        },
        {
            "type": "ItemDelta",
            "item_id": "test_apple",
            "delta": 1,
            "source": "inventory_add",
            "game_time": 1759610482.2364948
        }
    ],
    "last_command": null,
    "current_mode": "NARRATIVE",
    "current_combatants": [],
    "current_trade_partner_id": null,
    "mode_transition_cooldowns": {},
    "is_transitioning_to_combat": false,
    "combat_narrative_buffer": [],
    "journal": {
        "character": "",
        "quests": {
            "551cdb35-a4bb-4b23-b6c1-4d2772947efb": {
                "title": "Whispers of the Ash Plane (Ashen Covenant Recruit)",
                "description": "The Ashen Elder has tasked you with your first practical Ash Walking ritual. The Covenant needs to find a new, safe migration path, and the Elder believes a long-dead ancestor holds the key within the Ash Plane. You must project your consciousness, seek the ancestral spirit, and glean crucial information to guide your people.",
                "status": "active",
                "objectives": [
                    {
                        "id": "gather_ritual_ashes",
                        "description": "Gather specific ritual ashes from the designated area near the Ashen Camp.",
                        "completed": false,
                        "failed": false,
                        "mandatory": false,
                        "type": "fetch",
                        "target_id": "ritual_ashes",
                        "location_id": "ashen_camp",
                        "completion_criteria": "Collect the required ritual ashes for the Ash Walking ceremony."
                    },
                    {
                        "id": "perform_ash_walking_ritual",
                        "description": "Perform the guided Ash Walking ritual at the sacred altar within the Ashen Camp.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "ash_walking_altar",
                        "location_id": "ashen_camp",
                        "completion_criteria": "Successfully initiate the Ash Walking ritual and project your consciousness."
                    },
                    {
                        "id": "seek_ancestral_guidance",
                        "description": "Within the Ash Plane, seek out the ancestral spirit and glean information about a safe migration path.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "explore",
                        "target_id": "ancestral_spirit_echo",
                        "location_id": "ashen_camp",
                        "completion_criteria": "Obtain the cryptic message or vision from the ancestral spirit."
                    },
                    {
                        "id": "interpret_ancestral_message",
                        "description": "Return to your body and consult with the Ashen Elder to interpret the ancestral message.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "deliver",
                        "target_id": "ashen_elder",
                        "location_id": "ashen_camp",
                        "completion_criteria": "Discuss the ancestral message with the Ashen Elder to understand its meaning."
                    },
                    {
                        "id": "scout_new_migration_path",
                        "description": "Based on the interpreted ancestral guidance, scout the new migration path in Echo Woods.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "explore",
                        "target_id": "migration_path_entrance",
                        "location_id": "echo_woods",
                        "completion_criteria": "Locate and assess the viability of the new migration path as indicated by the ancestor."
                    }
                ],
                "rewards": {
                    "gold": 50,
                    "items": [
                        "ash_walker_talisman"
                    ],
                    "xp": 200
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q01": {
                "title": "Q01 \u2013 Fetch an Apple",
                "description": "Obtain a test apple.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Obtain 1 test_apple.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "fetch",
                        "target_id": "test_apple",
                        "location_id": "",
                        "completion_criteria": "Have at least 1 test_apple in inventory."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q02": {
                "title": "Q02 \u2013 Defeat the Test Wolf",
                "description": "Defeat the wolf",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Defeat a wolf (test).",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "kill",
                        "target_id": "wolf",
                        "location_id": "harmonia",
                        "completion_criteria": "Eliminate the wolf"
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": "[]"
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q03": {
                "title": "Q03 \u2013 Visit the Test Ruins",
                "description": "Visit test_ancient_ruins.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Visit test_ancient_ruins.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "explore",
                        "target_id": "test_ancient_ruins",
                        "location_id": "test_ancient_ruins",
                        "completion_criteria": "Enter the test_ancient_ruins location."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q04": {
                "title": "Q04 \u2013 Speak to the Test Elder",
                "description": "Ensure flag test_spoke_to_elder is true.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Speak with the test_elder.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_elder",
                        "location_id": "test_area",
                        "completion_criteria": "Conversation with test_elder completed."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q05": {
                "title": "Q05 \u2013 Beat the Clock (Before 5m)",
                "description": "Complete before time < 300.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Finish the timed task before 300s.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_timer_gate",
                        "location_id": "test_area",
                        "completion_criteria": "Objective completed in under 300 seconds."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q06": {
                "title": "Q06 \u2013 After Time Gate (After 10m)",
                "description": "Complete only after time > 600.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Finish the timed task after 600s.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_timer_gate",
                        "location_id": "test_area",
                        "completion_criteria": "Objective completed after 600 seconds have elapsed."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q07": {
                "title": "Q07 \u2013 All Composite",
                "description": "Have test_key and defeat test_guardian.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Have test_key and defeat test_guardian.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_guardian_gate",
                        "location_id": "test_area",
                        "completion_criteria": "Gate opened with test_key and guardian defeated."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q08": {
                "title": "Q08 \u2013 Any Composite",
                "description": "Visit either test_dock or test_harbor.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Visit test_dock OR test_harbor.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "explore",
                        "target_id": "test_dock_or_harbor",
                        "location_id": "test_coast",
                        "completion_criteria": "Arrive at either test_dock or test_harbor."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q09": {
                "title": "Q09 \u2013 None Composite",
                "description": "Alarm must NOT be triggered.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Ensure alarm remains silent.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_alarm_system",
                        "location_id": "test_area",
                        "completion_criteria": "Objective completed with no alarm raised."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q10": {
                "title": "Q10 \u2013 Mandatory + Optional",
                "description": "Mandatory item; optional visit.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Obtain test_badge.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "fetch",
                        "target_id": "test_badge",
                        "location_id": "",
                        "completion_criteria": "Acquire the test_badge."
                    },
                    {
                        "id": "O2",
                        "description": "Optionally visit test_outpost.",
                        "completed": false,
                        "failed": false,
                        "mandatory": false,
                        "type": "explore",
                        "target_id": "test_outpost",
                        "location_id": "test_outpost",
                        "completion_criteria": "Enter the test_outpost (optional)."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q11": {
                "title": "Q11 \u2013 Two Mandatory Objectives",
                "description": "Complete both mandatory objectives.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Defeat test_bandit_captain.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "kill",
                        "target_id": "test_bandit_captain",
                        "location_id": "test_road",
                        "completion_criteria": "Defeat the test_bandit_captain."
                    },
                    {
                        "id": "O2",
                        "description": "Collect 3 test_gem.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "fetch",
                        "target_id": "test_gem",
                        "location_id": "",
                        "completion_criteria": "Possess 3 test_gem."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q12": {
                "title": "Q12 \u2013 Semantic Only (No DSL)",
                "description": "Objective completion via semantic inference.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Convince the test_mayor to help.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_mayor",
                        "location_id": "test_town",
                        "completion_criteria": "Mayor agrees to help."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q13": {
                "title": "Q13 \u2013 Semantic Mandatory + Optional DSL",
                "description": "Mandatory semantic objective and optional visit objective.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Broker peace between test_factions.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_faction_council",
                        "location_id": "test_hall",
                        "completion_criteria": "Agreement reached between factions."
                    },
                    {
                        "id": "O2",
                        "description": "Optionally visit test_neutral_ground.",
                        "completed": false,
                        "failed": false,
                        "mandatory": false,
                        "type": "explore",
                        "target_id": "test_neutral_ground",
                        "location_id": "test_neutral_ground",
                        "completion_criteria": "Enter test_neutral_ground (optional)."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q14": {
                "title": "Q14 \u2013 Flag Chain",
                "description": "Require both flags set (speak to guard and acquire pass).",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Speak to guard and acquire pass.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_gate_guard",
                        "location_id": "test_gate",
                        "completion_criteria": "Guard spoken to and pass acquired."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q15": {
                "title": "Q15 \u2013 Inventory Count",
                "description": "Collect 3 test_herb.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Collect 3 test_herb.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "fetch",
                        "target_id": "test_herb",
                        "location_id": "",
                        "completion_criteria": "Possess 3 test_herb."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q16": {
                "title": "Q16 \u2013 Any of Three Enemies",
                "description": "Defeat any one of three test bandits.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Defeat any bandit (1 of 3).",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "kill",
                        "target_id": "test_bandit_group",
                        "location_id": "test_road",
                        "completion_criteria": "Defeat at least one of test_bandit_1/2/3."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q17": {
                "title": "Q17 \u2013 Visit Two Key Locations",
                "description": "Visit both test_gate and test_keep.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Visit test_gate and test_keep.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "explore",
                        "target_id": "test_gate_and_keep",
                        "location_id": "test_realm",
                        "completion_criteria": "Enter both test_gate and test_keep."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q18": {
                "title": "Q18 \u2013 Negative Flag (Not Banished)",
                "description": "Ensure not banished.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Ensure test_banished is false.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_citizenship_check",
                        "location_id": "test_town",
                        "completion_criteria": "Status confirms not banished."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q19": {
                "title": "Q19 \u2013 Mixed All/Any",
                "description": "Travel to dock or harbor and have a test_ticket.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Visit test_dock or test_harbor and show test_ticket.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_port_entry",
                        "location_id": "test_coast",
                        "completion_criteria": "Entry permitted with test_ticket at dock or harbor."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q20": {
                "title": "Q20 \u2013 Optional Does Not Block",
                "description": "Optional objective should not block completion.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Deliver test_letter.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "deliver",
                        "target_id": "test_recipient",
                        "location_id": "test_town",
                        "completion_criteria": "Deliver the test_letter to recipient."
                    },
                    {
                        "id": "O2",
                        "description": "Explore test_garden (optional).",
                        "completed": false,
                        "failed": false,
                        "mandatory": false,
                        "type": "explore",
                        "target_id": "test_garden",
                        "location_id": "test_garden",
                        "completion_criteria": "Enter the test_garden."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q21": {
                "title": "Q21 \u2013 Narrative-Heavy Objective",
                "description": "Deliver an inspiring speech to the council.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Deliver an inspiring speech to the test_council about unity and cooperation.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_council",
                        "location_id": "test_hall",
                        "completion_criteria": "Speech delivered; council acknowledges."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q22": {
                "title": "Q22 \u2013 Three Mandatory Objectives",
                "description": "Complete three distinct tasks.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Defeat test_ogre.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "kill",
                        "target_id": "test_ogre",
                        "location_id": "test_ogre_cave",
                        "completion_criteria": "Ogre defeated."
                    },
                    {
                        "id": "O2",
                        "description": "Collect 2 test_ogre_tooth.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "fetch",
                        "target_id": "test_ogre_tooth",
                        "location_id": "",
                        "completion_criteria": "Possess 2 test_ogre_tooth."
                    },
                    {
                        "id": "O3",
                        "description": "Visit test_ogre_cave.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "explore",
                        "target_id": "test_ogre_cave",
                        "location_id": "test_ogre_cave",
                        "completion_criteria": "Enter the ogre cave."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q23": {
                "title": "Q23 \u2013 Semantic Failure Gating",
                "description": "Objective completion depends on semantic inference only.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Convince test_skeptic to trust you.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_skeptic",
                        "location_id": "test_village",
                        "completion_criteria": "Skeptic indicates trust."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q24": {
                "title": "Q24 \u2013 Abandon/Fallback Scenario",
                "description": "Regular quest for abandon/failure flow testing.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Recover the test_relic.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "fetch",
                        "target_id": "test_relic",
                        "location_id": "test_ruins",
                        "completion_criteria": "Obtain the test_relic."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            },
            "TEST_Q25": {
                "title": "Q25 \u2013 Complex Mixed Conditions",
                "description": "Any of two routes, but no alarm and with resource gate.",
                "status": "active",
                "objectives": [
                    {
                        "id": "O1",
                        "description": "Route A (visit test_tower AND have test_rope) OR Route B (defeat test_spider_queen) with no alarm.",
                        "completed": false,
                        "failed": false,
                        "mandatory": true,
                        "type": "interact",
                        "target_id": "test_tower_or_spider_queen",
                        "location_id": "test_vale",
                        "completion_criteria": "No alarm triggered; either tower+rope route or spider queen defeated."
                    }
                ],
                "rewards": {
                    "xp": 0,
                    "gold": 0,
                    "items": []
                },
                "prerequisites": [],
                "tags": []
            }
        },
        "notes": []
    },
    "character_stats": {
        "level": 1,
        "stats": {
            "STR": {
                "name": "STRENGTH",
                "base_value": 14,
                "category": "PRIMARY",
                "description": "Physical power, affects melee damage and carrying capacity."
            },
            "DEX": {
                "name": "DEXTERITY",
                "base_value": 11,
                "category": "PRIMARY",
                "description": "Agility and reflexes, affects ranged attacks, initiative, and dodge."
            },
            "CON": {
                "name": "CONSTITUTION",
                "base_value": 12,
                "category": "PRIMARY",
                "description": "Physical resilience, affects health, stamina, and resistance to poison/disease."
            },
            "INT": {
                "name": "INTELLIGENCE",
                "base_value": 8,
                "category": "PRIMARY",
                "description": "Mental acuity, affects spell power and learning ability."
            },
            "WIS": {
                "name": "WISDOM",
                "base_value": 15,
                "category": "PRIMARY",
                "description": "Intuition and perception, affects magical resistance and willpower."
            },
            "CHA": {
                "name": "CHARISMA",
                "base_value": 12,
                "category": "PRIMARY",
                "description": "Social influence, affects dialogue, prices, and persuasion."
            },
            "WIL": {
                "name": "WILLPOWER",
                "base_value": 8,
                "category": "PRIMARY",
                "description": "Mental fortitude, resistance to influence and fear."
            },
            "INS": {
                "name": "INSIGHT",
                "base_value": 8,
                "category": "PRIMARY",
                "description": "Understanding situations, detecting lies, and sensing motives."
            }
        },
        "derived_stats": {
            "Max Health Points": {
                "name": "MAX_HEALTH",
                "base_value": 11.0,
                "category": "DERIVED",
                "description": "Your maximum hit points."
            },
            "Max Mana Points": {
                "name": "MAX_MANA",
                "base_value": 6.0,
                "category": "DERIVED",
                "description": "Your maximum magical energy."
            },
            "Max Stamina": {
                "name": "MAX_STAMINA",
                "base_value": 14.0,
                "category": "DERIVED",
                "description": "Your maximum physical energy."
            },
            "Max Resolve": {
                "name": "MAX_RESOLVE",
                "base_value": 8.0,
                "category": "DERIVED",
                "description": "Your maximum social/mental composure."
            },
            "Melee Attack": {
                "name": "MELEE_ATTACK",
                "base_value": 4.0,
                "category": "DERIVED",
                "description": "Your ability to hit opponents in melee combat."
            },
            "Ranged Attack": {
                "name": "RANGED_ATTACK",
                "base_value": 2.0,
                "category": "DERIVED",
                "description": "Your ability to hit opponents with ranged weapons."
            },
            "Magic Attack": {
                "name": "MAGIC_ATTACK",
                "base_value": 1.0,
                "category": "DERIVED",
                "description": "Your ability to hit opponents with magical attacks."
            },
            "Defense": {
                "name": "DEFENSE",
                "base_value": 11.0,
                "category": "DERIVED",
                "description": "Your ability to avoid physical damage."
            },
            "Magic Defense": {
                "name": "MAGIC_DEFENSE",
                "base_value": 11.0,
                "category": "DERIVED",
                "description": "Your ability to resist magical effects."
            },
            "Damage Reduction": {
                "name": "DAMAGE_REDUCTION",
                "base_value": 0.0,
                "category": "DERIVED",
                "description": "Reduces incoming physical damage by a flat amount."
            },
            "Initiative": {
                "name": "INITIATIVE",
                "base_value": 1.0,
                "category": "DERIVED",
                "description": "Determines your turn order in combat."
            },
            "Carry Capacity": {
                "name": "CARRY_CAPACITY",
                "base_value": 120.0,
                "category": "DERIVED",
                "description": "The maximum weight you can carry."
            },
            "Movement": {
                "name": "MOVEMENT",
                "base_value": 30.0,
                "category": "DERIVED",
                "description": "How far you can move in combat."
            },
            "Health Points": {
                "name": "HEALTH",
                "base_value": 11,
                "category": "DERIVED",
                "description": "Your current hit points. When this reaches zero, you are incapacitated."
            },
            "Resolve": {
                "name": "RESOLVE",
                "base_value": 8,
                "category": "DERIVED",
                "description": "Your current social/mental composure. Reduced by stress or social defeats."
            },
            "Mana Points": {
                "name": "MANA",
                "base_value": 6,
                "category": "DERIVED",
                "description": "Your current magical energy. Required for casting spells."
            },
            "Stamina": {
                "name": "STAMINA",
                "base_value": 14,
                "category": "DERIVED",
                "description": "Your current physical energy. Required for special physical actions."
            }
        },
        "modifiers": {
            "modifiers": [],
            "modifier_groups": []
        },
        "status_effects": {
            "active_effects": {}
        }
    },
    "memory_context": {
        "version": "0.1.0",
        "memory_entries": [],
        "context_state": {}
    },
    "detailed_inventory": {
        "items": {
            "ebb90ee3-78d7-44b1-b3da-99acbb5f42d9": {
                "id": "ebb90ee3-78d7-44b1-b3da-99acbb5f42d9",
                "name": "Ash-Treated Clothing",
                "description": "Simple, durable clothing treated with sacred ashes for resilience and a faint connection to ancestral spirits. Common among the Ashen Covenant.",
                "item_type": "armor",
                "rarity": "common",
                "weight": 2.0,
                "value": 20,
                "icon_path": "/images/icons/armor/helmet_1.png",
                "is_equippable": true,
                "equip_slots": [
                    "chest"
                ],
                "is_consumable": false,
                "is_stackable": false,
                "stack_limit": null,
                "quantity": 1,
                "is_quest_item": false,
                "durability": 80,
                "current_durability": 80,
                "is_destroyed": false,
                "tags": [
                    "clothing",
                    "armor",
                    "ashen_covenant",
                    "treated"
                ],
                "template_id": "ash-treated_clothing",
                "is_template": false,
                "source": "template_copy",
                "custom_properties": {},
                "discovered_at": "2025-10-04T22:41:22.262549",
                "stats": [
                    {
                        "name": "defense",
                        "value": 1,
                        "display_name": "Armor",
                        "is_percentage": false
                    },
                    {
                        "name": "fire_resistance",
                        "value": 5,
                        "display_name": "Fire Resistance",
                        "is_percentage": true
                    }
                ],
                "dice_roll_effects": [],
                "known_properties": [
                    "is_equippable",
                    "value",
                    "quantity",
                    "id",
                    "is_stackable",
                    "stat_defense",
                    "equip_slots",
                    "name",
                    "weight",
                    "item_type",
                    "icon_path",
                    "description",
                    "tags",
                    "rarity",
                    "stats",
                    "is_quest_item",
                    "current_durability",
                    "durability"
                ]
            },
            "dade0bbd-2b88-4eec-a7f2-30549effede2": {
                "id": "dade0bbd-2b88-4eec-a7f2-30549effede2",
                "name": "Covenant Pendant",
                "description": "A small, carved bone pendant bearing the symbol of the Ashen Covenant. It's said to ward off minor malevolent spirits.",
                "item_type": "accessory",
                "rarity": "common",
                "weight": 0.1,
                "value": 15,
                "icon_path": "/images/icons/accessory/amulet_1.png",
                "is_equippable": true,
                "equip_slots": [
                    "neck"
                ],
                "is_consumable": false,
                "is_stackable": false,
                "stack_limit": null,
                "quantity": 1,
                "is_quest_item": false,
                "durability": null,
                "current_durability": null,
                "is_destroyed": false,
                "tags": [
                    "amulet",
                    "ashen_covenant",
                    "spiritual"
                ],
                "template_id": "covenant_pendant",
                "is_template": false,
                "source": "template_copy",
                "custom_properties": {},
                "discovered_at": "2025-10-04T22:41:22.266069",
                "stats": [
                    {
                        "name": "willpower_save_bonus",
                        "value": 1,
                        "display_name": "Willpower Save Bonus",
                        "is_percentage": false
                    }
                ],
                "dice_roll_effects": [],
                "known_properties": [
                    "is_equippable",
                    "value",
                    "quantity",
                    "id",
                    "is_stackable",
                    "equip_slots",
                    "name",
                    "weight",
                    "item_type",
                    "icon_path",
                    "description",
                    "tags",
                    "rarity",
                    "is_quest_item"
                ]
            },
            "ed13e34a-ebaf-42f8-a191-32517b38588d": {
                "id": "ed13e34a-ebaf-42f8-a191-32517b38588d",
                "name": "Fire Striker",
                "description": "A reliable flint and steel for starting fires. Essential for survival and Covenant rituals.",
                "item_type": "tool",
                "rarity": "common",
                "weight": 0.3,
                "value": 5,
                "icon_path": "/images/icons/tool/hammer_1.png",
                "is_equippable": false,
                "equip_slots": [],
                "is_consumable": false,
                "is_stackable": false,
                "stack_limit": null,
                "quantity": 1,
                "is_quest_item": false,
                "durability": null,
                "current_durability": null,
                "is_destroyed": false,
                "tags": [
                    "tool",
                    "fire",
                    "survival"
                ],
                "template_id": "fire_striker",
                "is_template": false,
                "source": "template_copy",
                "custom_properties": {},
                "discovered_at": "2025-10-04T22:41:22.268369",
                "stats": [],
                "dice_roll_effects": [],
                "known_properties": [
                    "value",
                    "quantity",
                    "id",
                    "is_stackable",
                    "name",
                    "weight",
                    "item_type",
                    "icon_path",
                    "description",
                    "tags",
                    "rarity",
                    "is_quest_item"
                ]
            },
            "1b0e26d2-6c85-40d4-9dd1-b65c3b12ecb4": {
                "id": "1b0e26d2-6c85-40d4-9dd1-b65c3b12ecb4",
                "name": "Ritual Dagger",
                "description": "A ceremonial dagger, sharp and well-balanced, used by the Ashen Covenant in their rites. It feels strangely warm to the touch.",
                "item_type": "weapon",
                "rarity": "uncommon",
                "weight": 0.5,
                "value": 75,
                "icon_path": "/images/icons/weapon/dagger_1.png",
                "is_equippable": true,
                "equip_slots": [
                    "main_hand",
                    "off_hand"
                ],
                "is_consumable": false,
                "is_stackable": false,
                "stack_limit": null,
                "quantity": 1,
                "is_quest_item": false,
                "durability": 70,
                "current_durability": 70,
                "is_destroyed": false,
                "tags": [
                    "weapon",
                    "dagger",
                    "ritual",
                    "ashen_covenant"
                ],
                "template_id": "ritual_dagger",
                "is_template": false,
                "source": "template_copy",
                "custom_properties": {},
                "discovered_at": "2025-10-04T22:41:22.270088",
                "stats": [
                    {
                        "name": "attack_bonus",
                        "value": 1,
                        "display_name": "Attack Bonus",
                        "is_percentage": false
                    }
                ],
                "dice_roll_effects": [],
                "known_properties": [
                    "is_equippable",
                    "value",
                    "quantity",
                    "id",
                    "is_stackable",
                    "equip_slots",
                    "name",
                    "weight",
                    "item_type",
                    "icon_path",
                    "description",
                    "tags",
                    "rarity",
                    "is_quest_item",
                    "current_durability",
                    "durability"
                ]
            },
            "c88b8af8-4a6f-464c-a335-f26f4a581bc6": {
                "id": "c88b8af8-4a6f-464c-a335-f26f4a581bc6",
                "name": "Small Pouch of Ancestral Ash",
                "description": "A leather pouch containing a mixture of sacred ashes from revered ancestors of the Ashen Covenant. Used in rituals and for guidance.",
                "item_type": "miscellaneous",
                "rarity": "uncommon",
                "weight": 0.2,
                "value": 50,
                "icon_path": "/images/icons/miscellaneous/generic_1.png",
                "is_equippable": false,
                "equip_slots": [],
                "is_consumable": false,
                "is_stackable": false,
                "stack_limit": null,
                "quantity": 1,
                "is_quest_item": true,
                "durability": null,
                "current_durability": null,
                "is_destroyed": false,
                "tags": [
                    "ritual_component",
                    "ashen_covenant",
                    "spiritual",
                    "ash"
                ],
                "template_id": "small_pouch_of_ancestral_ash",
                "is_template": false,
                "source": "template_copy",
                "custom_properties": {},
                "discovered_at": "2025-10-04T22:41:22.271071",
                "stats": [],
                "dice_roll_effects": [],
                "known_properties": [
                    "value",
                    "quantity",
                    "id",
                    "is_stackable",
                    "name",
                    "weight",
                    "item_type",
                    "icon_path",
                    "description",
                    "tags",
                    "rarity",
                    "is_quest_item"
                ]
            },
            "d7951e58-25e5-44a2-b141-606ae04765ca": {
                "id": "d7951e58-25e5-44a2-b141-606ae04765ca",
                "name": "Test apple",
                "description": "A test apple.",
                "item_type": "miscellaneous",
                "rarity": "common",
                "weight": 0.1,
                "value": 1,
                "icon_path": "/images/icons/miscellaneous/generic_1.png",
                "is_equippable": false,
                "equip_slots": [],
                "is_consumable": true,
                "is_stackable": true,
                "stack_limit": 20,
                "quantity": 1,
                "is_quest_item": false,
                "durability": null,
                "current_durability": null,
                "is_destroyed": false,
                "tags": [
                    "miscellaneous",
                    "consumable",
                    "food"
                ],
                "template_id": "test_apple",
                "is_template": false,
                "source": "template_copy",
                "custom_properties": {},
                "discovered_at": "2025-10-04T22:41:22.273067",
                "stats": [],
                "dice_roll_effects": [],
                "known_properties": [
                    "value",
                    "quantity",
                    "id",
                    "is_stackable",
                    "name",
                    "weight",
                    "item_type",
                    "icon_path",
                    "description",
                    "tags",
                    "rarity",
                    "is_quest_item"
                ]
            }
        },
        "weight_limit_base": 100.0,
        "weight_limit_modifiers": {},
        "slot_limit_base": 20,
        "slot_limit_modifiers": {},
        "equipment": {},
        "currency": {
            "gold": 0,
            "silver": 0,
            "copper": 0,
            "total_copper": 0
        }
    }
}
```

