### File: config\aliases\entities.json

```json
{
  "entities": {
    "white_wolf": {
      "aliases": [
        "white_wolf",
        "wolf_white",
        "white-wolf",
        "albino_wolf",
        "snow_wolf"
      ]
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Alias mappings for entities to support normalization in quests/evidence. Extend freely."
  }
}


```

### File: config\world\base\cultures.json

```json
{
  "cultures": {
    "concordant": {
      "id": "concordant",
      "name": "The Concordant Cities",
      "description": "A confederation of seven interconnected city-states that sit at major Resonance nodes on the Nexus plane. Their architecture constantly shifts as it incorporates elements from other planes during Resonance Events.",
      "values": [
        {
          "name": "Harmony",
          "description": "Balancing the influences of all planes for the benefit of society.",
          "importance": 9
        },
        {
          "name": "Adaptability",
          "description": "Embracing change brought by Resonance Events rather than fearing it.",
          "importance": 8
        },
        {
          "name": "Knowledge",
          "description": "Understanding the patterns of Resonance to better predict and utilize them.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Attunement",
          "description": "A ritual tattooing process that helps citizens maintain their identity during plane shifts. The tattoos contain geometric patterns representing all five planes.",
          "occasion": "Coming of age (16 years)",
          "significance": "Marks full citizenship and provides protection during Resonance Events."
        },
        {
          "name": "Resonance Festival",
          "description": "A celebration held during major predicted Resonance Events, with music, dance, and temporary markets for cross-planar goods.",
          "occasion": "Major Resonance Events (5-7 times per year)",
          "significance": "Celebrates the unique nature of their fractured world and the opportunities it presents."
        }
      ],
      "language_style": "Formal with many technical terms related to planar phenomena. Contains words and sounds borrowed from all five planes.",
      "naming_conventions": {
        "male": "Melodic names with consonant pairs (Jaedin, Thaerol, Vestrian)",
        "female": "Flowing names with multiple vowels (Aliora, Nyaeve, Seraphine)",
        "places": "Often named after Resonance patterns or Luminary fragments (Harmonium, Echopoint, Luminfall)"
      },
      "common_traits": [
        "Diplomatic",
        "Studious",
        "Pragmatic",
        "Adaptable"
      ]
    },
    "verdant": {
      "id": "verdant",
      "name": "The Verdant Collective",
      "description": "A nature-focused society that primarily exists in the Verdant plane but maintains outposts on Nexus. Their societal roles are seasonal, with individuals changing their functions throughout the year.",
      "values": [
        {
          "name": "Symbiosis",
          "description": "Living in harmony with the natural world and each other.",
          "importance": 10
        },
        {
          "name": "Renewal",
          "description": "Embracing the cycles of growth, death, and rebirth.",
          "importance": 8
        },
        {
          "name": "Community",
          "description": "Prioritizing the needs of the collective over the individual.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Season Shifting",
          "description": "A ceremony where individuals transition to new societal roles based on the changing seasons.",
          "occasion": "Each solstice and equinox",
          "significance": "Ensures that everyone experiences different aspects of their society and prevents stagnation."
        },
        {
          "name": "Green Speech Initiation",
          "description": "A ritual where new members learn the secret language of the collective, composed of plant growth patterns and pheromones.",
          "occasion": "Upon joining the collective or coming of age",
          "significance": "Allows communication that outsiders cannot decode, preserving the collective's secrets."
        }
      ],
      "language_style": "Soft spoken verbal language with many metaphors drawn from plant and animal life. Green Speech is non-verbal and uses pheromones and subtle manipulation of nearby plants.",
      "naming_conventions": {
        "male": "Names derived from plant species or natural phenomena (Alder, Rowan, Brook)",
        "female": "Names derived from flowers or natural elements (Willow, Laurel, Dawn)",
        "places": "Named after ecological features (Deeproot, Sunmeadow, Mistcanopy)"
      },
      "common_traits": [
        "Patient",
        "Communal",
        "Secretive with outsiders",
        "Deeply intuitive"
      ]
    },
    "crystalline": {
      "id": "crystalline",
      "name": "The Crystalline Consortium",
      "description": "A highly ordered society with the most stable presence on the Crystalline plane and trading enclaves on Nexus. Personal worth is measured by one's contribution to mathematical and magical precision.",
      "values": [
        {
          "name": "Order",
          "description": "Maintaining structure, hierarchy, and predictability in all things.",
          "importance": 9
        },
        {
          "name": "Excellence",
          "description": "Striving for perfection in one's specialized field.",
          "importance": 8
        },
        {
          "name": "Legacy",
          "description": "Creating lasting works that will endure through time.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Faceting",
          "description": "A coming-of-age ritual where adolescents receive geometric crystal implants that enhance specific mental abilities.",
          "occasion": "Upon completing academic assessment (typically age 14-16)",
          "significance": "Determines one's specialized role in society and enhances natural talents."
        },
        {
          "name": "Calculation Contest",
          "description": "Annual competition where individuals and teams solve increasingly complex mathematical and magical equations.",
          "occasion": "Mid-winter",
          "significance": "Elevates social standing and determines resource allocation for the coming year."
        }
      ],
      "language_style": "Precise and technical with minimal use of metaphor or ambiguity. Mathematical formulae are often incorporated into everyday speech.",
      "naming_conventions": {
        "male": "Geometric or mineral-based names (Hexar, Obsidian, Quartz)",
        "female": "Gemstone or crystalline structure names (Sapphira, Amethyst, Lattice)",
        "places": "Named after mathematical concepts or crystal formations (Dodecahedron, Fibonacci, Geode)"
      },
      "common_traits": [
        "Methodical",
        "Reserved",
        "Perfectionistic",
        "Specialized"
      ]
    },
    "ashen": {
      "id": "ashen",
      "name": "The Ashen Covenant",
      "description": "Nomadic societies traveling the Ashen plane with temporary settlements on Nexus. Their culture focuses on impermanence and rebirth, with no permanent ownership as possessions rotate through the community.",
      "values": [
        {
          "name": "Impermanence",
          "description": "Accepting that all things eventually end and transform.",
          "importance": 9
        },
        {
          "name": "Memory",
          "description": "Preserving the wisdom and stories of those who came before.",
          "importance": 8
        },
        {
          "name": "Transformation",
          "description": "Embracing change and rebirth as natural and necessary.",
          "importance": 8
        }
      ],
      "traditions": [
        {
          "name": "Dust Keeping",
          "description": "The practice of preserving the ashes of ancestors and using them in rituals to communicate with the dead.",
          "occasion": "Death of community members and monthly remembrance ceremonies",
          "significance": "Maintains connection with ancestors and their wisdom, while honoring the cycle of decay and rebirth."
        },
        {
          "name": "Possession Exchange",
          "description": "Periodic ceremony where all material goods are collected and redistributed among the community.",
          "occasion": "New moon of each month",
          "significance": "Reinforces the concept that nothing is permanently owned, teaches detachment from material possessions."
        }
      ],
      "language_style": "Poetic with many euphemisms, especially regarding death and endings. Words often have multiple context-dependent meanings.",
      "naming_conventions": {
        "male": "Names related to fire or earth (Ember, Coal, Dust)",
        "female": "Names related to transition or cycles (Twilight, Echo, Whisper)",
        "places": "Temporary settlements named for events or omens (Ravenfall, Ashbloom, Veilbreak)"
      },
      "common_traits": [
        "Philosophical",
        "Detached",
        "Spiritual",
        "Resilient"
      ]
    },
    "tempest": {
      "id": "tempest",
      "name": "The Tempest Flotilla",
      "description": "A society constantly moving throughout the chaotic Tempest plane with harbors on Nexus during certain celestial alignments. They adapt rapidly to change with fluid social hierarchies that can transform daily.",
      "values": [
        {
          "name": "Freedom",
          "description": "The right to change and choose one's path without constraint.",
          "importance": 10
        },
        {
          "name": "Opportunity",
          "description": "Seizing chances that arise from chaos and unexpected change.",
          "importance": 8
        },
        {
          "name": "Resilience",
          "description": "Weathering storms both literal and metaphorical with flexibility and strength.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Storm Binding",
          "description": "Capturing the essence of Tempest plane storms in tattoos that grant unpredictable magical abilities.",
          "occasion": "When an individual successfully navigates their first major Tempest storm",
          "significance": "Marks true membership in the Flotilla and bestows unique, often chaotic magical gifts."
        },
        {
          "name": "Leadership Flux",
          "description": "A daily ritual where leadership positions are reassigned based on needs and circumstances.",
          "occasion": "Dawn of each day",
          "significance": "Ensures that those best suited to current challenges take command, prevents power entrenchment."
        }
      ],
      "language_style": "Fast-paced with many slang terms that change rapidly. Incorporates sounds mimicking wind and water. Tonal shifts indicate emotional context.",
      "naming_conventions": {
        "male": "Action-oriented names (Surge, Dash, Flint)",
        "female": "Weather or energy-based names (Storm, Spark, Gale)",
        "places": "Named after vessels or weather events (Thunderwake, Squallrider, Maelstrom)"
      },
      "common_traits": [
        "Spontaneous",
        "Bold",
        "Adaptable",
        "Unpredictable"
      ]
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Culture definitions for the RPG game world"
  }
}
```

### File: config\world\base\fundamental_rules.json

```json
{
  "name": "Laws of Aetheris",
  "description": "The fundamental rules that govern how the world of Aetheris operates after The Shattering.",
  "rules": [
    {
      "name": "The Fractured Reality",
      "description": "Aetheris is split into five overlapping planes: Verdant (nature), Crystalline (order), Ashen (decay), Tempest (chaos), and Nexus (the central plane where most inhabitants now dwell).",
      "category": "cosmology",
      "effects": [
        "Most sentient beings live on the Nexus plane, which serves as a crossroads between the other planes",
        "The other planes can be accessed through special portals, during Resonance Events, or through specific magical techniques",
        "Each plane has unique physical laws and resources that influence magic and technology",
        "Time flows slightly differently in each plane, causing travelers to experience temporal distortion"
      ]
    },
    {
      "name": "Resonance Events",
      "description": "Periodic and partly predictable occurrences where planes temporarily merge, causing landscapes, creatures, and cultures to blend before separating again.",
      "category": "planar phenomenon",
      "effects": [
        "Minor Resonance Events are common and localized, affecting small areas",
        "Major Resonance Events are rarer and can transform entire regions",
        "The Resonance Calendar predicts many events, but anomalies are increasing",
        "Beings caught during Resonance Events may be altered or merged with alternate versions of themselves",
        "Some areas become 'Planar Bleed Zones' where the merger becomes permanent"
      ]
    },
    {
      "name": "The Luminaries",
      "description": "Once-unified cosmic entities who maintained balance before The Shattering, now fragmented across the planes. Their fragments still influence reality.",
      "category": "divine",
      "effects": [
        "Luminary fragments manifest as powerful artifacts with reality-altering properties",
        "The Five Speakers can hear and interpret the will of specific Luminaries",
        "Divine magic draws power from Luminary fragments rather than unified deities",
        "Collecting multiple fragments increases power but risks instability",
        "Some fragments have developed sentience and their own agendas"
      ]
    },
    {
      "name": "Planar Affinity",
      "description": "All beings have natural affinities for specific planes, influencing their abilities, temperament, and magical talent.",
      "category": "biology",
      "effects": [
        "Birth location and lineage determine initial planar affinity",
        "Exposure to different planes can gradually shift one's affinity",
        "Magic is easier to perform when aligned with one's planar affinity",
        "Some individuals (Resonance-touched) have multiple affinities",
        "Certain races evolved specific adaptations to their primary plane"
      ]
    },
    {
      "name": "Magical Resonance",
      "description": "Magic in Aetheris is shaped by The Shattering, manifesting differently in each plane and requiring specific techniques based on planar alignment.",
      "category": "magic",
      "effects": [
        "Traditional spellcasting is unreliable across planar boundaries",
        "Song Weaving is the most ancient and stable form of cross-planar magic",
        "Each plane has a signature magical style (e.g., Facet Magic in Crystalline)",
        "Magical education typically focuses on a planar specialty",
        "The most powerful magic often requires components from multiple planes"
      ]
    },
    {
      "name": "Planar Resources",
      "description": "Each plane produces unique materials and resources essential for advanced magic, technology, and medicine.",
      "category": "economy",
      "effects": [
        "Verdant Plane: Living materials, adaptive plant matter, medicinal components",
        "Crystalline Plane: Perfect geometric minerals, resonance crystals, timekeeping devices",
        "Ashen Plane: Memory metals, preservative compounds, spectral essences",
        "Tempest Plane: Energy condensates, probability alloys, chaos crystals",
        "Nexus Plane: Planar binding agents, stabilizing compounds, universal catalysts"
      ]
    }
  ]
}
```

### File: config\world\base\magic_systems.json

```json
{
  "magic_systems": {
    "song_weaving": {
      "id": "song_weaving",
      "name": "Song Weaving",
      "description": "The most ancient form of magic, predating The Shattering. Practitioners create effects through specific melodies and harmonies rather than formal spellcasting.",
      "origin": "Song Weaving is the original form of magic used in Aetheris before The Shattering. It was taught directly by the Luminaries to the first inhabitants of the world, who discovered that certain melodies could tap into the natural magical currents that flowed through the land.",
      "limitations": "Requires vocal ability and musical aptitude. Effects are weaker when performed solo rather than in a group. Cannot be performed silently. Some complex effects require specific musical instruments as foci.",
      "practitioners": "Most commonly practiced among Elves, who have maintained the ancient traditions, and Maelstri, who naturally resonate with the harmonic frequencies. However, any race with sufficient musical talent can learn its basics.",
      "cultural_significance": "Song Weaving is revered as the purest form of magic, especially among older cultures. Annual music festivals in the Concordant Cities often feature Song Weaving performances, and the most skilled practitioners are highly respected across all planes.",
      "racial_affinities": {
        "Elf": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "10% increased potency of all Song Weaving spells"
        },
        "Maelstri": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "Can maintain Song Weaving effects 25% longer than other races"
        },
        "Human": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Mage": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "required_stats": {
            "INT": 12,
            "CHA": 10
          }
        },
        "Cleric": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "required_stats": {
            "WIS": 12,
            "CHA": 10
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "CHA": 12
          }
        },
        "Ranger": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "WIS": 12,
            "CHA": 8
          }
        },
        "Rogue": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "required_stats": {
            "CHA": 14
          }
        },
        "Warrior": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "CHA": 14,
            "INT": 10
          }
        }
      },
      "spells": {
        "harmonic_healing": {
          "id": "harmonic_healing",
          "name": "Harmonic Healing",
          "description": "A soothing melody that accelerates natural healing processes in the target.",
          "mana_cost": 15,
          "casting_time": "10 seconds",
          "range": "5m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 20.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "2d6+8",
              "description": "Immediate healing of wounds and ailments"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "HP Regeneration",
              "status_effect": "",
              "duration": 3,
              "dice_notation": "",
              "description": "Accelerated natural healing for a short duration"
            }
          ],
          "level": 2,
          "components": [
            "voice",
            "focus"
          ],
          "tags": [
            "healing",
            "regeneration",
            "restoration"
          ]
        },
        "resonant_shield": {
          "id": "resonant_shield",
          "name": "Resonant Shield",
          "description": "Creates a barrier of sound waves that deflects incoming attacks.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Sound waves deflect physical and magical attacks"
            }
          ],
          "level": 2,
          "components": [
            "voice",
            "gesture"
          ],
          "tags": [
            "protection",
            "defense",
            "sound"
          ]
        },
        "chorus_of_clarity": {
          "id": "chorus_of_clarity",
          "name": "Chorus of Clarity",
          "description": "A harmonizing melody that clears the mind and enhances perception.",
          "mana_cost": 10,
          "casting_time": "5 seconds",
          "range": "10m",
          "target": "multiple",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "INT",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Temporarily enhances intellectual capabilities"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "WIS",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Temporarily enhances perceptive capabilities"
            }
          ],
          "level": 1,
          "components": [
            "voice",
            "concentration"
          ],
          "tags": [
            "enhancement",
            "mind",
            "perception"
          ]
        },
        "dirge_of_despair": {
          "id": "dirge_of_despair",
          "name": "Dirge of Despair",
          "description": "A haunting melody that instills dread and weakens resolve.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "15m",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -2.0,
              "stat_affected": "CHA",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Weakens social presence and confidence"
            },
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Frightened",
              "duration": 3,
              "dice_notation": "",
              "description": "Targets feel a deep sense of dread and fear"
            }
          ],
          "level": 3,
          "components": [
            "voice",
            "gesture",
            "concentration"
          ],
          "tags": [
            "debuff",
            "fear",
            "control"
          ]
        },
        "planar_harmonization": {
          "id": "planar_harmonization",
          "name": "Planar Harmonization",
          "description": "A complex melody that resonates with the natural frequencies of different planes, facilitating travel and communication between them.",
          "mana_cost": 40,
          "casting_time": "1 minute",
          "range": "30m",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Planar Resonance",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Enhances ability to perceive and interact with planar energies"
            }
          ],
          "level": 5,
          "components": [
            "voice",
            "instrument",
            "focus",
            "concentration"
          ],
          "tags": [
            "planar",
            "utility",
            "ritual"
          ]
        },
        "song_of_mending": {
          "id": "song_of_mending",
          "name": "Song of Mending",
          "description": "A gentle tune that repairs physical objects and mends broken items.",
          "mana_cost": 15,
          "casting_time": "30 seconds",
          "range": "5m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 30.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "",
              "description": "Repairs damage to a non-living object"
            }
          ],
          "level": 2,
          "components": [
            "voice",
            "focus"
          ],
          "tags": [
            "utility",
            "restoration",
            "crafting"
          ]
        }
      }
    },
    "planar_anchoring": {
      "id": "planar_anchoring",
      "name": "Planar Anchoring",
      "description": "The art of maintaining stability during Resonance Events. Practitioners can extend areas of stability or purposefully blur planar boundaries.",
      "origin": "Planar Anchoring emerged shortly after The Shattering as a necessity for survival. The Harmonic Order developed these techniques to protect settlements when the planes would temporarily merge, preventing catastrophic destruction.",
      "limitations": "Requires physical components from multiple planes. Creates significant mental strain on the caster, with prolonged use potentially causing 'planar sickness' - a condition where the practitioner begins to exist partially in multiple planes simultaneously.",
      "practitioners": "Primarily used by the Harmonic Order as part of their duty to protect settlements during Resonance Events. It is also practiced by planar researchers and certain specialized mages who study the boundaries between realities.",
      "cultural_significance": "Planar Anchors are highly respected in all societies, as they serve as protectors during dangerous Resonance Events. In the Concordant Cities, they hold positions of authority and are often consulted on matters of planar significance.",
      "racial_affinities": {
        "Human": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can maintain anchoring effects 20% longer than other races"
        },
        "Prismal": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "15% reduced mana cost for planar anchoring spells"
        },
        "Maelstri": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can detect planar instabilities within 50m radius"
        },
        "Elf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Mage": {
          "affinity_level": "Very High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "INT": 14,
            "WIS": 10
          }
        },
        "Cleric": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 10
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 12,
            "WIS": 12
          }
        },
        "Ranger": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 12
          }
        },
        "Rogue": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14,
            "DEX": 14
          }
        },
        "Warrior": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "required_stats": {
            "INT": 14,
            "CON": 14,
            "WIS": 10
          }
        }
      },
      "spells": {
        "stability_field": {
          "id": "stability_field",
          "name": "Stability Field",
          "description": "Creates a field where planar fluctuations are suppressed, providing safety during Resonance Events.",
          "mana_cost": 30,
          "casting_time": "30 seconds",
          "range": "20m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Planar Stability",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Maintains the current plane's physics and prevents planar bleeding"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 3.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "The stability field provides minor protection against normal attacks as well"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "focus",
            "planar components"
          ],
          "tags": [
            "protection",
            "planar",
            "area effect"
          ]
        },
        "reality_tether": {
          "id": "reality_tether",
          "name": "Reality Tether",
          "description": "Anchors a person or object to their home plane, protecting them from planar shifts and dimensional effects.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -10.0,
              "stat_affected": "Planar Resonance",
              "status_effect": "",
              "duration": 60,
              "dice_notation": "",
              "description": "Reduces susceptibility to planar effects and dimensional displacement"
            }
          ],
          "level": 2,
          "components": [
            "touch",
            "focus",
            "crystalline dust"
          ],
          "tags": [
            "protection",
            "planar",
            "anchoring"
          ]
        },
        "planar_sight": {
          "id": "planar_sight",
          "name": "Planar Sight",
          "description": "Grants the ability to see planar boundaries, resonance patterns, and entities from other planes that might otherwise be invisible.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Perception",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Allows visibility of planar boundaries and cross-planar entities"
            }
          ],
          "level": 2,
          "components": [
            "gesture",
            "prismatic lens"
          ],
          "tags": [
            "divination",
            "planar",
            "perception"
          ]
        },
        "boundary_distortion": {
          "id": "boundary_distortion",
          "name": "Boundary Distortion",
          "description": "Temporarily weakens planar boundaries in a small area, allowing for partial merging of planes or extraction of planar energy.",
          "mana_cost": 35,
          "casting_time": "1 minute",
          "range": "10m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -20.0,
              "stat_affected": "Planar Stability",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Creates a controlled destabilization of planar boundaries"
            }
          ],
          "level": 4,
          "components": [
            "gesture",
            "focus",
            "components from target plane",
            "ritual circle"
          ],
          "tags": [
            "planar",
            "manipulation",
            "advanced"
          ]
        },
        "resonance_shield": {
          "id": "resonance_shield",
          "name": "Resonance Shield",
          "description": "Creates a personal barrier that absorbs planar energy and harmful resonance effects.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Planar Resistance",
              "status_effect": "",
              "duration": 20,
              "dice_notation": "",
              "description": "Provides immunity to harmful effects from planar resonance and instability"
            },
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Magic Resistance",
              "status_effect": "",
              "duration": 20,
              "dice_notation": "",
              "description": "The shield also provides some protection against conventional magic"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "focus",
            "resonant crystal"
          ],
          "tags": [
            "protection",
            "planar",
            "defensive"
          ]
        },
        "planar_transit": {
          "id": "planar_transit",
          "name": "Planar Transit",
          "description": "Creates a stable corridor between planes, allowing safe passage for a short time. Only works between planes currently in resonance.",
          "mana_cost": 50,
          "casting_time": "5 minutes",
          "range": "5m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Planar Transit",
              "duration": 10,
              "dice_notation": "",
              "description": "Creates a controlled passage between planes in resonance"
            }
          ],
          "level": 5,
          "components": [
            "gesture",
            "focus",
            "planar essence",
            "ritual circle",
            "resonance map"
          ],
          "tags": [
            "planar",
            "travel",
            "advanced",
            "ritual"
          ]
        }
      }
    },
    "echo_binding": {
      "id": "echo_binding",
      "name": "Echo Binding",
      "description": "The art of capturing 'echoes' - residual effects from other planes that linger after Resonance Events - and binding them to objects or people to grant temporary planar properties.",
      "origin": "Echo Binding emerged from the opportunistic practices of scavengers who frequented areas after Resonance Events. They discovered that certain residual energies could be captured and preserved for later use, eventually developing sophisticated techniques to harness these 'echoes'.",
      "limitations": "Requires fresh echoes from recent Resonance Events. Prolonged use can cause 'planar bleeding' - uncontrolled manifestations of other planes. The practice is somewhat unstable; effects can be unpredictable if not properly controlled.",
      "practitioners": "Popular among independent magical practitioners, merchants specializing in unique magical items, and adventurers who need versatile magical effects without formal training. The Mercantile Chord employs many Echo Binders to create valuable cross-planar goods.",
      "cultural_significance": "Viewed with mixed opinions across cultures. Some see it as a practical adaptation to the post-Shattering world, while others consider it dangerous tampering with forces that should be left alone. There's a growing black market for illegal echo harvesting, particularly from dangerous or forbidden planes.",
      "racial_affinities": {
        "Human": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can identify echo properties 25% more accurately than other races"
        },
        "Halfling": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Echo bindings last 15% longer when created by Halflings"
        },
        "Maelstri": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "Can naturally sense echoes within 30m radius"
        },
        "Elf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Rogue": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "required_stats": {
            "DEX": 12,
            "INT": 10
          }
        },
        "Mage": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "INT": 12,
            "DEX": 10
          }
        },
        "Wanderer": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "DEX": 12,
            "INT": 10
          }
        },
        "Ranger": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "DEX": 12,
            "WIS": 12
          }
        },
        "Cleric": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 12
          }
        },
        "Warrior": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "STR": 14,
            "DEX": 12
          }
        }
      },
      "spells": {
        "echo_capture": {
          "id": "echo_capture",
          "name": "Echo Capture",
          "description": "Captures a lingering planar echo and stores it temporarily for later use.",
          "mana_cost": 15,
          "casting_time": "30 seconds",
          "range": "5m",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Echo Contained",
              "duration": 60,
              "dice_notation": "",
              "description": "Captures a planar echo for later binding"
            }
          ],
          "level": 1,
          "components": [
            "gesture",
            "echo vessel",
            "focusing crystal"
          ],
          "tags": [
            "utility",
            "planar",
            "gathering"
          ]
        },
        "bind_echo": {
          "id": "bind_echo",
          "name": "Bind Echo",
          "description": "Binds a captured echo to an object or person, transferring its planar properties.",
          "mana_cost": 20,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Planar Essence",
              "status_effect": "",
              "duration": 120,
              "dice_notation": "",
              "description": "Transfers captured echo properties to the target"
            }
          ],
          "level": 2,
          "components": [
            "gesture",
            "captured echo",
            "binding agent"
          ],
          "tags": [
            "enchantment",
            "planar",
            "binding"
          ]
        },
        "echo_sight": {
          "id": "echo_sight",
          "name": "Echo Sight",
          "description": "Grants the ability to see lingering echoes and assess their properties and potential uses.",
          "mana_cost": 10,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Echo Perception",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Allows visibility of planar echoes and understanding of their properties"
            }
          ],
          "level": 1,
          "components": [
            "gesture",
            "residue sample"
          ],
          "tags": [
            "divination",
            "planar",
            "perception"
          ]
        },
        "weapon_echo": {
          "id": "weapon_echo",
          "name": "Weapon Echo",
          "description": "Binds a combat-oriented echo to a weapon, granting it planar offensive properties.",
          "mana_cost": 25,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 6.0,
              "stat_affected": "Damage",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Adds planar damage to weapon attacks"
            },
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Planar Disruption",
              "duration": 3,
              "dice_notation": "",
              "description": "Weapon attacks can disrupt planar abilities of targets"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "combat echo",
            "binding agent",
            "weapon"
          ],
          "tags": [
            "combat",
            "enhancement",
            "planar"
          ]
        },
        "echo_ward": {
          "id": "echo_ward",
          "name": "Echo Ward",
          "description": "Creates a protective barrier using protective echoes, shielding against both physical and planar threats.",
          "mana_cost": 30,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 7.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 60,
              "dice_notation": "",
              "description": "Protects against physical attacks"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 12.0,
              "stat_affected": "Planar Resistance",
              "status_effect": "",
              "duration": 60,
              "dice_notation": "",
              "description": "Protects against planar effects and energies"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "protective echo",
            "binding circle"
          ],
          "tags": [
            "protection",
            "defensive",
            "planar"
          ]
        },
        "echo_mimicry": {
          "id": "echo_mimicry",
          "name": "Echo Mimicry",
          "description": "Binds an entity echo to the caster, temporarily granting traits, abilities, or appearance of creatures from other planes.",
          "mana_cost": 40,
          "casting_time": "2 minutes",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 8.0,
              "stat_affected": "Varied",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Grants traits and abilities based on the specific echo bound"
            },
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Echo Transformation",
              "duration": 30,
              "dice_notation": "",
              "description": "Physically transforms aspects of the caster to match the echo source"
            }
          ],
          "level": 4,
          "components": [
            "gesture",
            "entity echo",
            "binding agent",
            "personal focus"
          ],
          "tags": [
            "transformation",
            "planar",
            "mimicry"
          ]
        }
      }
    },
    "facet_magic": {
      "id": "facet_magic",
      "name": "Facet Magic",
      "description": "A precise form of magic developed by the Crystalline Consortium that uses geometric crystals to channel and focus magical energies with mathematical precision.",
      "origin": "Facet Magic was developed in the Crystalline plane after The Shattering. The Prismals, with their natural crystalline bodies, discovered they could channel magical energies through precisely cut geometric forms, leading to a highly structured and mathematical approach to spellcasting.",
      "limitations": "Requires precisely cut crystals as foci, with different shapes producing different effects. Demands mathematical precision and calculation. Less effective in chaotic environments or when crystals are damaged. Requires significant preparation and is difficult to use spontaneously.",
      "practitioners": "Primarily used by members of the Crystalline Consortium, especially Prismals and mathematically-inclined humans and dwarves. Requires formal education in crystalline geometry and facet theory, making it inaccessible to those without proper training.",
      "cultural_significance": "Facet Magic is seen as the most 'civilized' and scholarly form of magic within the Crystalline Consortium. Practitioners are viewed as elite intellectuals, and the precision of one's faceted crystals is a status symbol. Those who master this art often receive the honorific 'Facet' before their name.",
      "racial_affinities": {
        "Prismal": {
          "affinity_level": "Very High",
          "learning_difficulty": "Very Easy",
          "natural_talent": true,
          "bonus_effects": "20% reduced mana cost for all Facet Magic spells"
        },
        "Dwarf": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Facet crystals crafted by Dwarves last 30% longer before needing recalibration"
        },
        "Human": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Elf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Maelstri": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Mage": {
          "affinity_level": "Very High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "INT": 14
          }
        },
        "Cleric": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 12,
            "WIS": 12
          }
        },
        "Rogue": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 12,
            "DEX": 12
          }
        },
        "Warrior": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14,
            "STR": 12
          }
        },
        "Ranger": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14,
            "DEX": 12
          }
        },
        "Wanderer": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14
          }
        }
      },
      "spells": {
        "prismatic_bolt": {
          "id": "prismatic_bolt",
          "name": "Prismatic Bolt",
          "description": "Creates a beam of concentrated light energy that strikes with geometric precision.",
          "mana_cost": 15,
          "casting_time": "1 action",
          "range": "30m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "damage",
              "value": 25.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "3d8+4",
              "description": "Pure light energy strikes the target with unerring accuracy"
            }
          ],
          "level": 2,
          "components": [
            "octahedral crystal",
            "gesture",
            "calculation"
          ],
          "tags": [
            "attack",
            "precision",
            "light"
          ]
        },
        "crystalline_shield": {
          "id": "crystalline_shield",
          "name": "Crystalline Shield",
          "description": "Forms a perfect geometric barrier of faceted energy that absorbs damage.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 8.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Creates a perfectly calculated defensive barrier"
            }
          ],
          "level": 2,
          "components": [
            "cubic crystal",
            "gesture"
          ],
          "tags": [
            "protection",
            "defensive",
            "barrier"
          ]
        },
        "computational_enhancement": {
          "id": "computational_enhancement",
          "name": "Computational Enhancement",
          "description": "Enhances mental faculties through crystalline resonance with the brain's natural patterns.",
          "mana_cost": 25,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 4.0,
              "stat_affected": "INT",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Temporarily boosts intellectual capacity and computational ability"
            }
          ],
          "level": 3,
          "components": [
            "dodecahedral crystal",
            "mental calculation",
            "touch"
          ],
          "tags": [
            "enhancement",
            "mental",
            "intellect"
          ]
        },
        "perfect_analysis": {
          "id": "perfect_analysis",
          "name": "Perfect Analysis",
          "description": "Uses crystalline resonance to perfectly analyze an object, creature, or phenomenon.",
          "mana_cost": 15,
          "casting_time": "1 minute",
          "range": "5m",
          "target": "single",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 20.0,
              "stat_affected": "Knowledge",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Grants precise information about the target's composition, properties, and nature"
            }
          ],
          "level": 2,
          "components": [
            "tetrahedral crystal",
            "concentration",
            "calculation"
          ],
          "tags": [
            "divination",
            "knowledge",
            "analysis"
          ]
        },
        "geometric_restructuring": {
          "id": "geometric_restructuring",
          "name": "Geometric Restructuring",
          "description": "Manipulates the physical structure of non-living matter by precisely realigning its internal geometry.",
          "mana_cost": 30,
          "casting_time": "5 minutes",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 40.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "",
              "description": "Repairs and restructures non-living matter according to precise calculations"
            }
          ],
          "level": 3,
          "components": [
            "icosahedral crystal",
            "geometric diagram",
            "touch",
            "calculation"
          ],
          "tags": [
            "transmutation",
            "repair",
            "crafting"
          ]
        },
        "crystal_prison": {
          "id": "crystal_prison",
          "name": "Crystal Prison",
          "description": "Encases the target in a perfect crystalline structure that restricts movement.",
          "mana_cost": 35,
          "casting_time": "1 action",
          "range": "15m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Restrained",
              "duration": 5,
              "dice_notation": "",
              "description": "Target is encased in a precisely calculated crystalline structure"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -5.0,
              "stat_affected": "DEX",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Crystal severely restricts movement"
            }
          ],
          "level": 4,
          "components": [
            "cubic crystal",
            "gesture",
            "calculation"
          ],
          "tags": [
            "control",
            "restraint",
            "crystal"
          ]
        }
      }
    },
    "ash_walking": {
      "id": "ash_walking",
      "name": "Ash Walking",
      "description": "A unique form of magic from the Ashen plane that allows practitioners to temporarily transfer their consciousness into the Ashen plane for communication, espionage, and retrieving lost knowledge.",
      "origin": "Ash Walking developed among the nomadic societies of the Ashen plane as a means of maintaining communication across vast distances. After The Shattering, the Cinderspawn refined these techniques into a formal magical practice that allows consciousness to slip between the boundaries of physical existence.",
      "limitations": "Extended use causes physical body to gradually turn to ash. Risk of becoming lost in the Ashen plane increases with duration. Requires absolute concentration, making it vulnerable to interruption. Cannot interact physically with the material world while consciousness is transferred.",
      "practitioners": "Primarily practiced by members of the Ashen Covenant, especially Cinderspawn who have a natural affinity for the practice. Some secretive groups like assassins guilds have adopted modified versions for espionage purposes.",
      "cultural_significance": "Among the Ashen Covenant, Ash Walking is considered sacred, used in important ceremonies to commune with ancestors. Outside these communities, it is often viewed with suspicion or fear, associated with death magic and necromancy, though this is a misunderstanding of its true nature.",
      "racial_affinities": {
        "Cinderspawn": {
          "affinity_level": "Very High",
          "learning_difficulty": "Very Easy",
          "natural_talent": true,
          "bonus_effects": "Can maintain Ash Walking 50% longer without physical degradation"
        },
        "Orc": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": true,
          "bonus_effects": "15% increased perception while Ash Walking"
        },
        "Human": {
          "affinity_level": "Medium",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Elf": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Maelstri": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Rogue": {
          "affinity_level": "Very High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "DEX": 12,
            "WIS": 12
          }
        },
        "Mage": {
          "affinity_level": "High",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 14,
            "WIS": 12
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 14
          }
        },
        "Cleric": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 14,
            "CON": 12
          }
        },
        "Ranger": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "DEX": 12
          }
        },
        "Warrior": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "required_stats": {
            "WIS": 14,
            "CON": 14
          }
        }
      },
      "spells": {
        "minor_projection": {
          "id": "minor_projection",
          "name": "Minor Projection",
          "description": "Temporarily transfers a small portion of consciousness into the Ashen plane, allowing limited perception beyond physical barriers.",
          "mana_cost": 10,
          "casting_time": "30 seconds",
          "range": "50m",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ash Perception",
              "duration": 5,
              "dice_notation": "",
              "description": "Allows perception through solid objects within range"
            }
          ],
          "level": 1,
          "components": [
            "pinch of ash",
            "concentration"
          ],
          "tags": [
            "perception",
            "divination",
            "espionage"
          ]
        },
        "ashen_transit": {
          "id": "ashen_transit",
          "name": "Ashen Transit",
          "description": "Fully transfers consciousness into the Ashen plane, leaving the physical body in a trance-like state.",
          "mana_cost": 25,
          "casting_time": "1 minute",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ash Walking",
              "duration": 15,
              "dice_notation": "",
              "description": "Consciousness fully transfers to the Ashen plane"
            },
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": -10.0,
              "stat_affected": "Physical Defense",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Physical body is vulnerable while consciousness is elsewhere"
            }
          ],
          "level": 3,
          "components": [
            "handful of ashes",
            "ritual circle",
            "concentration"
          ],
          "tags": [
            "transportation",
            "planar",
            "espionage"
          ]
        },
        "whispers_of_ash": {
          "id": "whispers_of_ash",
          "name": "Whispers of Ash",
          "description": "Allows communication through the Ashen plane to another individual, regardless of distance, so long as both parties have access to ash from the same source.",
          "mana_cost": 15,
          "casting_time": "1 minute",
          "range": "unlimited",
          "target": "single",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ash Communication",
              "duration": 10,
              "dice_notation": "",
              "description": "Establishes a mental link through the Ashen plane"
            }
          ],
          "level": 2,
          "components": [
            "shared ash source",
            "concentration"
          ],
          "tags": [
            "communication",
            "utility",
            "social"
          ]
        },
        "ashen_knowledge": {
          "id": "ashen_knowledge",
          "name": "Ashen Knowledge",
          "description": "Accesses the collective memory of the Ashen plane to retrieve lost or forgotten knowledge about a specific subject or location.",
          "mana_cost": 30,
          "casting_time": "10 minutes",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Knowledge",
              "status_effect": "",
              "duration": 1,
              "dice_notation": "",
              "description": "Grants specific knowledge about a subject from the collective memory of the Ashen plane"
            }
          ],
          "level": 4,
          "components": [
            "ash from location or subject",
            "ritual circle",
            "concentration",
            "meditation"
          ],
          "tags": [
            "knowledge",
            "divination",
            "history"
          ]
        },
        "ash_veil": {
          "id": "ash_veil",
          "name": "Ash Veil",
          "description": "Creates a cloud of animate ash that obscures vision and can be mentally controlled by the caster.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "15m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -10.0,
              "stat_affected": "Perception",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Reduces visibility and sensory perception in the affected area"
            }
          ],
          "level": 2,
          "components": [
            "handful of ashes",
            "gesture"
          ],
          "tags": [
            "concealment",
            "control",
            "defense"
          ]
        },
        "ashen_body": {
          "id": "ashen_body",
          "name": "Ashen Body",
          "description": "Temporarily transforms the caster's physical form into ash, allowing them to flow through small openings and resist physical damage.",
          "mana_cost": 35,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ashen Form",
              "duration": 5,
              "dice_notation": "",
              "description": "Physical body becomes partially incorporeal ash"
            },
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Physical Resistance",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Significantly reduces damage from physical attacks"
            }
          ],
          "level": 4,
          "components": [
            "ritual ashes",
            "gesture",
            "concentration"
          ],
          "tags": [
            "transformation",
            "defense",
            "movement"
          ]
        }
      }
    },
    "divine_healing": {
      "id": "divine_healing",
      "name": "Divine Healing",
      "description": "A sacred form of magic that channels divine energy to heal wounds, cure ailments, and restore life force. While healing effects can be achieved through other magical systems, Divine Healing is specifically focused on restoration and protection through spiritual connection.",
      "origin": "Divine Healing predates The Shattering, stemming from the earliest spiritual practices across all planes. After the cosmic trauma of The Shattering, these healing traditions became even more vital, with practitioners developing formalized methods to channel divine energies from fragmented Luminaries.",
      "limitations": "Requires genuine spiritual conviction or connection. Effectiveness is reduced when used for selfish purposes. Cannot typically restore life to the truly dead. More severe injuries require greater spiritual energy and preparation. Some ailments require specific divine connections or rituals.",
      "practitioners": "Most commonly practiced by clerics and spiritual leaders, though anyone with sufficient faith and training can learn its basics. The most powerful practitioners are those who maintain a deep connection with the fragmented Luminaries or other divine entities.",
      "cultural_significance": "Healing practitioners are highly respected in all societies, often serving both spiritual and medical roles in their communities. In many cultures, significant healing rituals mark important life transitions and community events. The ability to heal is seen as one of the most noble uses of magic.",
      "racial_affinities": {
        "Mycora": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "Healing spells are 25% more effective when cast by Mycora"
        },
        "Human": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can sense injuries and ailments within 10m radius"
        },
        "Elf": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can maintain healing effects 20% longer than other races"
        },
        "Dwarf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Maelstri": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Cleric": {
          "affinity_level": "Very High",
          "learning_difficulty": "Very Easy",
          "required_stats": {
            "WIS": 10
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "WIS": 12,
            "CHA": 10
          }
        },
        "Ranger": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 12
          }
        },
        "Mage": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 12
          }
        },
        "Warrior": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "CHA": 12
          }
        },
        "Rogue": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "required_stats": {
            "WIS": 14,
            "CHA": 12
          }
        }
      },
      "spells": {
        "healing_touch": {
          "id": "healing_touch",
          "name": "Healing Touch",
          "description": "Channels divine energy through the caster's hands to heal wounds and injuries.",
          "mana_cost": 15,
          "casting_time": "1 action",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 25.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "2d8+10",
              "description": "Immediate healing of physical wounds and injuries"
            }
          ],
          "level": 2,
          "components": [
            "touch",
            "prayer",
            "focus"
          ],
          "tags": [
            "healing",
            "restoration",
            "touch"
          ]
        },
        "purify_body": {
          "id": "purify_body",
          "name": "Purify Body",
          "description": "Cleanses the body of disease, poison, and other harmful substances through divine intervention.",
          "mana_cost": 20,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Purified",
              "duration": 0,
              "dice_notation": "",
              "description": "Removes disease, poison, and other harmful conditions"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "CON",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Temporarily enhances physical resilience"
            }
          ],
          "level": 3,
          "components": [
            "touch",
            "prayer",
            "holy water",
            "focus"
          ],
          "tags": [
            "purification",
            "restoration",
            "protection"
          ]
        },
        "divine_restoration": {
          "id": "divine_restoration",
          "name": "Divine Restoration",
          "description": "A powerful healing spell that mends severe injuries, regenerates damaged tissue, and restores vitality.",
          "mana_cost": 35,
          "casting_time": "5 minutes",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 50.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "4d10+20",
              "description": "Comprehensive healing of major wounds and injuries"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "HP Regeneration",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Enhances natural healing for a period of time"
            }
          ],
          "level": 4,
          "components": [
            "touch",
            "ritual prayer",
            "holy symbol",
            "focus",
            "sacred herbs"
          ],
          "tags": [
            "healing",
            "restoration",
            "regeneration"
          ]
        },
        "circle_of_healing": {
          "id": "circle_of_healing",
          "name": "Circle of Healing",
          "description": "Creates a sacred circle that radiates healing energy to all within its bounds.",
          "mana_cost": 30,
          "casting_time": "1 minute",
          "range": "10m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 15.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "2d6+5",
              "description": "Immediate healing to all within the circle"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "HP Regeneration",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Enhances natural healing while within the circle"
            }
          ],
          "level": 3,
          "components": [
            "ritual circle",
            "group prayer",
            "holy symbol"
          ],
          "tags": [
            "healing",
            "area effect",
            "support"
          ]
        },
        "protective_blessing": {
          "id": "protective_blessing",
          "name": "Protective Blessing",
          "description": "Invokes divine protection to shield the target from harm and enhance their resilience.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Divine energy creates a protective barrier against harm"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Magic Resistance",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Enhances resistance to harmful magical effects"
            }
          ],
          "level": 3,
          "components": [
            "touch",
            "prayer",
            "holy symbol"
          ],
          "tags": [
            "protection",
            "defensive",
            "blessing"
          ]
        },
        "revitalize": {
          "id": "revitalize",
          "name": "Revitalize",
          "description": "Restores energy and vitality to the exhausted, removing fatigue and granting renewed strength.",
          "mana_cost": 20,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Revitalized",
              "duration": 60,
              "dice_notation": "",
              "description": "Removes exhaustion and fatigue"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Stamina",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Enhances physical endurance and energy"
            }
          ],
          "level": 2,
          "components": [
            "touch",
            "prayer",
            "holy water"
          ],
          "tags": [
            "restoration",
            "enhancement",
            "recovery"
          ]
        }
      }
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Magic system definitions for the RPG game world"
  }
}
```

### File: config\world\base\world_history.json

```json
{
  "name": "Aetheris",
  "description": "A world once unified that was fractured into five overlapping planes by The Shattering, a catastrophic magical event approximately 2,500 years ago.",
  "current_year": 2500,
  "eras": [
    {
      "name": "The Age of Harmony",
      "start_year": -3000,
      "end_year": 0,
      "description": "The ancient era when Aetheris was a singular reality where all races existed in harmony under the watchful eye of the Luminaries - cosmic entities who maintained balance.",
      "events": [
        {
          "year": -3000,
          "title": "The First Settlements",
          "description": "The earliest known civilizations of Aetheris form, following the seasonal magical currents across the unified world.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -2500,
          "title": "The Song of Creation",
          "description": "The first documented use of Song Weaving magic, which becomes the primary magical practice of the era.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -1500,
          "title": "Formation of the Cipher Conclave",
          "description": "A collective of the most powerful mages forms to study the fundamental nature of reality and the Luminaries.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -500,
          "title": "The Luminescent Age",
          "description": "A period of unprecedented growth and prosperity as the Luminaries actively guide civilization.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -100,
          "title": "The Immortality Project",
          "description": "The Cipher Conclave begins experiments to achieve immortality by tapping into the essence of the Luminaries.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Shattering",
      "start_year": 0,
      "end_year": 1,
      "description": "The catastrophic event that tore reality apart, splitting the world into five overlapping planes and scattering the Luminaries.",
      "events": [
        {
          "year": 0,
          "title": "The Fatal Experiment",
          "description": "The Cipher Conclave's attempt to harness immortality goes catastrophically wrong, tearing the fabric of reality.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 0,
          "title": "The Fracturing of the Planes",
          "description": "The unified world splits into five distinct planes: Verdant, Crystalline, Ashen, Tempest, and Nexus.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 0,
          "title": "The Scattering of the Luminaries",
          "description": "The cosmic entities that maintained balance are shattered, their essences fragmented across all planes.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1,
          "title": "The First Resonance",
          "description": "The initial overlap between planes occurs, causing confusion and fear among survivors.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Age of Isolation",
      "start_year": 1,
      "end_year": 1000,
      "description": "A millennium when surviving populations adapted to their new isolated realities while experiencing the first Resonance Events.",
      "events": [
        {
          "year": 50,
          "title": "The Emergence of the Five Speakers",
          "description": "Five individuals across different planes develop the ability to hear the \"voices\" of the fragmented Luminaries.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 127,
          "title": "The First Planar Adaptation",
          "description": "Isolated populations begin developing distinct traits based on their planar environment.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 345,
          "title": "The Founding of Harmonia",
          "description": "The first stable settlement is established on the Nexus plane, later becoming the capital of the Concordant Cities.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 512,
          "title": "The Resonance Calendar",
          "description": "Early attempts to predict and catalogue Resonance Events lead to the creation of a new calendar system.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 827,
          "title": "The First Planar Bleed Zone",
          "description": "An area where two planes permanently merged is discovered, leading to new theories about the nature of reality.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Age of Discovery",
      "start_year": 1000,
      "end_year": 2000,
      "description": "A period when civilizations developed ways to predict and utilize Resonance Events, leading to the first intentional cross-plane settlements.",
      "events": [
        {
          "year": 1024,
          "title": "The Formation of the Harmonic Order",
          "description": "Scholars from across the Nexus plane unite to study and catalogue plane interactions.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1156,
          "title": "The First Controlled Crossing",
          "description": "The Harmonic Order successfully predicts and utilizes a Resonance Event to deliberately travel between planes.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1378,
          "title": "The Verdant Collective",
          "description": "The formation of the first society to deliberately incorporate elements of the Verdant plane into their culture.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1591,
          "title": "The Crystalline Breakthrough",
          "description": "Facet Magic is developed, allowing for precise magical control through geometric crystal structures.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1842,
          "title": "The Ghost Markets",
          "description": "The mysterious trading network that appears only during specific Resonance Events is established by entities known as \"The Between.\"",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Modern Age",
      "start_year": 2000,
      "end_year": 2500,
      "description": "The current era where sophisticated societies have emerged that incorporate elements from multiple planes while facing new challenges.",
      "events": [
        {
          "year": 2025,
          "title": "The Concordant Charter",
          "description": "The seven city-states of the Nexus plane form a unified government known as the Concordant Cities.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2142,
          "title": "The Emergence of the Dissonant Path",
          "description": "A faction forms that believes The Shattering was necessary evolution and actively opposes reunification efforts.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2287,
          "title": "The Luminary Chess Game",
          "description": "The Five Speakers begin a complex metaphysical game that corresponds to real-world events and Resonance patterns.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2398,
          "title": "The Resonance Crisis Begins",
          "description": "Resonance Events become more frequent and unpredictable, causing concern among scholars and leaders.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2489,
          "title": "The Shifting Library",
          "description": "The discovery of a repository of knowledge that exists simultaneously in all planes, containing potential records from before The Shattering.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    }
  ]
}
```

### File: world_configurator\assistant\__init__.py

```python
# Makes this directory a package.


```

### File: world_configurator\assistant\context.py

```python
"""
Assistant context dataclasses and provider protocol.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Protocol, Tuple

JsonObj = Dict[str, Any]

@dataclass
class AssistantContext:
    """Serializable context for the LLM assistant.

    domain: logical domain (e.g., "classes", "origins").
    selection_id: stable identifier for the selected entry.
    content: the current JSON for the selected entry.
    schema: optional JSON schema-like hints.
    allowed_paths: JSON Pointer prefixes that the LLM is allowed to modify.
    exemplars: optional example objects for create-entry tasks.
    references: optional catalogs (skills/items/quests/etc.) to reduce hallucinations.
    """
    domain: str
    selection_id: Optional[str]
    content: Optional[JsonObj]
    schema: Optional[JsonObj]
    allowed_paths: List[str]
    exemplars: Optional[List[JsonObj]] = None
    references: Optional[JsonObj] = None


@dataclass
class PatchOp:
    op: str
    path: str
    value: Any = None
    from_: Optional[str] = None  # reserved for move/copy if needed later


class AssistantContextProvider(Protocol):
    """Interface editors implement to integrate with the assistant."""
    def get_assistant_context(self) -> AssistantContext: ...
    def apply_assistant_patch(self, patch_ops: List[PatchOp]) -> Tuple[bool, str]: ...
    def get_domain_examples(self) -> List[JsonObj]: ...
    def get_reference_catalogs(self) -> JsonObj: ...
    def create_entry_from_llm(self, entry: JsonObj) -> Tuple[bool, str, Optional[str]]: ...


```

### File: world_configurator\assistant\panel.py

```python
"""
Assistant dock widget.
"""
from __future__ import annotations

import json
import traceback
from typing import List, Optional

import logging
from PySide6.QtCore import Qt, QThread, Signal, QObject
from PySide6.QtWidgets import (
    QDockWidget, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox,
    QTextEdit, QPushButton, QTabWidget, QPlainTextEdit, QMessageBox
)

from .context import AssistantContext, PatchOp, AssistantContextProvider
from .prompt_builder import build_messages, build_messages_analyze
from llm.client_base import OpenAILikeClient
from llm.settings import load_llm_settings


logger = logging.getLogger("world_configurator.ui.assistant")

class _Worker(QObject):
    finished = Signal(dict, str)
    failed = Signal(str)

    def __init__(self, mode: str, ctx: AssistantContext, user_text: str, messages: Optional[List[dict]] = None) -> None:
        super().__init__()
        self.mode = mode
        self.ctx = ctx
        self.user_text = user_text
        self._messages = messages

    def run(self) -> None:
        try:
            settings = load_llm_settings()
            if not settings.api_key or not settings.model or not settings.provider:
                self.failed.emit("LLM settings incomplete. Please set provider, model, and API key in Settings.")
                return
            messages = self._messages if self._messages is not None else build_messages(self.mode, self.ctx, self.user_text)
            prov = (settings.provider or '').lower()
            if prov.startswith('google') or prov == 'gemini':
                from llm.gemini import GeminiClient
                client = GeminiClient()
            else:
                client = OpenAILikeClient()
            resp = client.send(messages, settings)
            self.finished.emit(resp, "")
        except Exception as e:
            # Log full details to file, emit concise message to UI
            logger.error("Assistant worker error: %s", e, exc_info=True)
            self.failed.emit("Provider request failed. See logs for details.")


class AssistantDock(QDockWidget):
    def __init__(self, parent=None, get_provider_cb=None) -> None:
        super().__init__("Assistant", parent)
        # Make persistent (no close/maximize/floating controls)
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.setFeatures(QDockWidget.NoDockWidgetFeatures)
        self._get_provider_cb = get_provider_cb  # function returning AssistantContextProvider or None

        container = QWidget()
        self.setWidget(container)
        layout = QVBoxLayout(container)

        # Mode selector
        mode_row = QHBoxLayout()
        mode_row.addWidget(QLabel("Mode:"))
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["Analyze", "Modify", "Create"])
        self.mode_combo.currentTextChanged.connect(self._on_mode_changed)
        mode_row.addWidget(self.mode_combo)
        mode_row.addStretch()
        layout.addLayout(mode_row)

        # User input
        self.input_edit = QTextEdit()
        self.input_edit.setPlaceholderText("Ask for analysis, suggest changes, or describe a new entry to create…")
        layout.addWidget(self.input_edit)

        # Action buttons
        btn_row = QHBoxLayout()
        self.clear_btn = QPushButton("Clear")
        self.clear_btn.clicked.connect(self._on_clear)
        self.reset_conv_btn = QPushButton("Reset conversation")
        self.reset_conv_btn.clicked.connect(self._on_reset_conversation)
        self.send_btn = QPushButton("Send")
        self.send_btn.clicked.connect(self._on_send)
        btn_row.addStretch()
        btn_row.addWidget(self.clear_btn)
        btn_row.addWidget(self.reset_conv_btn)
        btn_row.addWidget(self.send_btn)
        layout.addLayout(btn_row)

        # Results tabs
        self.tabs = QTabWidget()
        self.analysis_out = QPlainTextEdit(); self.analysis_out.setReadOnly(True)
        self.patch_out = QPlainTextEdit(); self.patch_out.setReadOnly(True)
        self.entry_out = QPlainTextEdit(); self.entry_out.setReadOnly(True)
        self.tabs.addTab(self.analysis_out, "Analysis")
        self.tabs.addTab(self.patch_out, "Patch")
        self.tabs.addTab(self.entry_out, "New Entry")
        layout.addWidget(self.tabs)

        # Apply buttons
        apply_row = QHBoxLayout()
        self.apply_patch_btn = QPushButton("Apply Patch")
        self.apply_patch_btn.clicked.connect(self._apply_patch)
        self.apply_patch_btn.setEnabled(False)
        self.create_entry_btn = QPushButton("Create Entry")
        self.create_entry_btn.clicked.connect(self._create_entry)
        self.create_entry_btn.setEnabled(False)
        apply_row.addWidget(self.apply_patch_btn)
        apply_row.addWidget(self.create_entry_btn)
        layout.addLayout(apply_row)

        self._last_patch: Optional[List[PatchOp]] = None
        self._last_entry: Optional[dict] = None

        # Analyze conversation threading: per (domain, selection_id)
        self._analyze_threads: dict = {}
        self._last_run_mode: Optional[str] = None
        self._last_run_key: Optional[tuple] = None
        self._last_user_text: Optional[str] = None

    def _active_provider(self) -> Optional[AssistantContextProvider]:
        return self._get_provider_cb() if self._get_provider_cb else None

    def _on_send(self) -> None:
        provider = self._active_provider()
        if provider is None:
            QMessageBox.warning(self, "No Active Editor", "Select an editor tab that supports the assistant.")
            return
        mode = self.mode_combo.currentText().lower()
        ctx = provider.get_assistant_context()
        # Always provide references to improve grounding
        try:
            ctx.references = provider.get_reference_catalogs()
        except Exception:
            ctx.references = ctx.references or None
        user_text = self.input_edit.toPlainText()
        messages: Optional[List[dict]] = None

        # On-demand targeted search: if user types "search: <term>", try to focus or attach results.
        try:
            low = (user_text or "").strip().lower()
            if low.startswith("search:") and hasattr(provider, "search_for_entries"):
                term = user_text.split(":", 1)[1].strip() if ":" in user_text else ""
                matches = provider.search_for_entries(term) if term else []
                if len(matches) == 1 and hasattr(provider, "focus_entry"):
                    # Auto-focus the only match and refresh context/references
                    provider.focus_entry(matches[0][0])
                    ctx = provider.get_assistant_context()
                    try:
                        ctx.references = provider.get_reference_catalogs()
                    except Exception:
                        pass
                elif len(matches) > 1:
                    # Attach compact results to references for LLM grounding and user visibility
                    refs = ctx.references or {}
                    refs = dict(refs)
                    refs["search_results"] = [{"id": mid, "name": mname, "score": score} for (mid, mname, score) in matches[:10]]
                    ctx.references = refs
        except Exception:
            # Best effort; proceed with normal flow
            pass

        # Heuristic: if user asks to "create/add/generate" N, force create mode for this send
        try:
            import re
            lowtxt = (user_text or "").strip().lower()
            m = re.search(r"\b(create|add|generate)\s+(\d+)\b", lowtxt)
            if m and mode != "create":
                mode = "create"
        except Exception:
            pass

        # For create mode, attach exemplar and clear selection context
        if mode == "create":
            examples = provider.get_domain_examples()
            ctx.exemplars = examples[:1] if examples else None
            ctx.selection_id = None
            ctx.content = None
            messages = build_messages(mode, ctx, user_text)
            self._last_run_mode = None
            self._last_run_key = None
            self._last_user_text = None
        elif mode == "modify":
            messages = build_messages(mode, ctx, user_text)
            self._last_run_mode = None
            self._last_run_key = None
            self._last_user_text = None
        else:  # analyze with threading
            key = (ctx.domain, ctx.selection_id)
            history = self._analyze_threads.get(key, [])
            messages = build_messages_analyze(history, ctx, user_text, lean=True)
            self._last_run_mode = "analyze"
            self._last_run_key = key
            self._last_user_text = user_text
            # Update tab label to reflect current history count immediately
            self._update_analysis_tab_label(len(history))
        self._run_worker(mode, ctx, user_text, messages=messages)

    def _run_worker(self, mode: str, ctx: AssistantContext, user_text: str, messages: Optional[List[dict]] = None) -> None:
        self.send_btn.setEnabled(False)
        self.apply_patch_btn.setEnabled(False)
        self.create_entry_btn.setEnabled(False)
        self.analysis_out.clear(); self.patch_out.clear(); self.entry_out.clear()
        self._last_patch = None; self._last_entry = None

        self._thread = QThread(self)
        self._worker = _Worker(mode, ctx, user_text, messages=messages)
        self._worker.moveToThread(self._thread)
        self._thread.started.connect(self._worker.run)
        self._worker.finished.connect(self._on_worker_done)
        self._worker.failed.connect(self._on_worker_fail)
        self._worker.finished.connect(self._thread.quit)
        self._worker.failed.connect(self._thread.quit)
        self._thread.start()

    def _on_worker_done(self, data: dict, _msg: str) -> None:
        self.send_btn.setEnabled(True)
        # Route by intent
        intent = data.get("intent")
        if intent == "analyze":
            self.tabs.setCurrentIndex(0)
            analysis = data.get("analysis")
            recs = data.get("recommendations", [])
            text = self._sanitize_text(analysis if isinstance(analysis, str) else "")
            if not text and isinstance(data.get("raw"), str):
                text = self._sanitize_text(data.get("raw"))
            if not text:
                # fallback: pretty-print whatever came
                text = json.dumps(data, indent=2, ensure_ascii=False)
            if recs:
                text = text + ("\n\nRecommendations:\n- " + "\n- ".join(recs))
            self.analysis_out.setPlainText(text)
            # Append to analyze history if applicable
            if self._last_run_mode == "analyze" and self._last_run_key is not None and self._last_user_text:
                self._append_analyze_history(self._last_run_key, self._last_user_text, text)
            # optional patch
            if isinstance(data.get("suggested_patch"), list):
                self.tabs.setCurrentIndex(1)
                self.patch_out.setPlainText(json.dumps(data["suggested_patch"], indent=2, ensure_ascii=False))
                self._try_parse_patch(data["suggested_patch"])  # enable apply if valid
        elif intent == "modify_selection":
            self.tabs.setCurrentIndex(1)
            self.patch_out.setPlainText(json.dumps(data.get("patch", []), indent=2, ensure_ascii=False))
            self._try_parse_patch(data.get("patch"))
        elif intent == "create_entry":
            self.tabs.setCurrentIndex(2)
            entry_obj = data.get("entry")
            # Support single object or list of objects for bulk creation
            try:
                self.entry_out.setPlainText(json.dumps(entry_obj, indent=2, ensure_ascii=False))
            except Exception:
                self.entry_out.setPlainText(str(entry_obj))
            self._last_entry = entry_obj if isinstance(entry_obj, (dict, list)) else None
            if isinstance(entry_obj, list):
                self.create_entry_btn.setText(f"Create {len(entry_obj)} Entries")
                self.create_entry_btn.setEnabled(len(entry_obj) > 0)
            else:
                self.create_entry_btn.setText("Create Entry")
                self.create_entry_btn.setEnabled(isinstance(entry_obj, dict))
        else:
            # Raw content fallback
            self.tabs.setCurrentIndex(0)
            raw = data.get("raw") if isinstance(data, dict) else None
            self.analysis_out.setPlainText(self._sanitize_text(raw if isinstance(raw, str) else json.dumps(data, indent=2, ensure_ascii=False)))

    def _on_worker_fail(self, err: str) -> None:
        self.send_btn.setEnabled(True)
        # Keep UI message short; details are in logs
        QMessageBox.critical(self, "Assistant Error", err)
        logger.error("Assistant error surfaced to UI: %s", err)

    def _try_parse_patch(self, patch_list_obj) -> None:
        try:
            if isinstance(patch_list_obj, list):
                ops: List[PatchOp] = []
                for item in patch_list_obj:
                    if isinstance(item, dict) and "op" in item and "path" in item:
                        ops.append(PatchOp(op=item["op"], path=item["path"], value=item.get("value")))
                if ops:
                    self._last_patch = ops
                    self.apply_patch_btn.setEnabled(True)
        except Exception:
            self._last_patch = None
            self.apply_patch_btn.setEnabled(False)

    def _apply_patch(self) -> None:
        if not self._last_patch:
            return
        provider = self._active_provider()
        if provider is None:
            return
        ok, msg = provider.apply_assistant_patch(self._last_patch)
        if ok:
            QMessageBox.information(self, "Patch Applied", "Changes applied successfully.")
            self.apply_patch_btn.setEnabled(False)
        else:
            QMessageBox.warning(self, "Patch Failed", msg)

    def _create_entry(self) -> None:
        if not self._last_entry:
            return
        provider = self._active_provider()
        if provider is None:
            return
        # Handle bulk list or single dict
        if isinstance(self._last_entry, list):
            created = 0; failed = 0
            for e in self._last_entry:
                if not isinstance(e, dict):
                    failed += 1
                    continue
                ok, msg, new_id = provider.create_entry_from_llm(e)
                if ok:
                    created += 1
                else:
                    failed += 1
            QMessageBox.information(self, "Bulk Create", f"Created: {created}, Failed: {failed}")
            self.create_entry_btn.setEnabled(False)
        else:
            ok, msg, new_id = provider.create_entry_from_llm(self._last_entry)
            if ok:
                QMessageBox.information(self, "Entry Created", f"Created new entry with id: {new_id}")
                self.create_entry_btn.setEnabled(False)
            else:
                QMessageBox.warning(self, "Creation Failed", msg)

    def _on_clear(self) -> None:
        self.input_edit.clear()
        self.analysis_out.clear()
        self.patch_out.clear()
        self.entry_out.clear()
        self.apply_patch_btn.setEnabled(False)
        self.create_entry_btn.setEnabled(False)
        self._last_patch = None
        self._last_entry = None
        # Do not touch analyze history. Label remains as-is.

    def _sanitize_text(self, s: str) -> str:
        if not s:
            return ""
        # Strip common code fences
        if s.strip().startswith("```"):
            lines = [ln for ln in s.splitlines() if not ln.strip().startswith("```")]
            s = "\n".join(lines).strip()
        # If it's JSON-looking, try to flatten nicely
        st = s.strip()
        if (st.startswith("{") and st.endswith("}")) or (st.startswith("[") and st.endswith("]")):
            try:
                obj = json.loads(st)
                # If it looks like {analysis: ...}
                if isinstance(obj, dict) and "analysis" in obj and isinstance(obj["analysis"], str):
                    return obj["analysis"]
                return json.dumps(obj, indent=2, ensure_ascii=False)
            except Exception:
                pass
        return s

    def _on_reset_conversation(self) -> None:
        try:
            provider = self._active_provider()
            if provider is None:
                return
            ctx = provider.get_assistant_context()
            key = (ctx.domain, ctx.selection_id)
            if key in self._analyze_threads:
                del self._analyze_threads[key]
            self.analysis_out.clear()
            self._update_analysis_tab_label(0)
        except Exception:
            # Best-effort reset; keep UI responsive even if provider fails
            self.analysis_out.clear()
            self._update_analysis_tab_label(0)

    def _append_analyze_history(self, key: tuple, user_text: str, assistant_text: str) -> None:
        hist = list(self._analyze_threads.get(key, []))
        hist.append({"role": "user", "content": user_text})
        hist.append({"role": "assistant", "content": assistant_text})
        self._analyze_threads[key] = hist
        self._update_analysis_tab_label(len(hist))

    def _update_analysis_tab_label(self, message_count: int) -> None:
        idx = self.tabs.indexOf(self.analysis_out)
        if idx >= 0:
            label = "Analysis" if message_count <= 0 else f"Analysis ({message_count} messages)"
            self.tabs.setTabText(idx, label)

    def _on_mode_changed(self, text: str) -> None:
        if text and text.lower() == "analyze":
            try:
                provider = self._active_provider()
                if provider is None:
                    self._update_analysis_tab_label(0)
                    return
                ctx = provider.get_assistant_context()
                key = (ctx.domain, ctx.selection_id)
                hist = self._analyze_threads.get(key, [])
                self._update_analysis_tab_label(len(hist))
            except Exception:
                self._update_analysis_tab_label(0)


```

### File: world_configurator\assistant\patching.py

```python
"""
JSON Patch helpers with allowed-path validation.
"""
from __future__ import annotations

from dataclasses import asdict
from typing import Any, Dict, List, Tuple
from copy import deepcopy

from .context import AssistantContext, PatchOp

JsonObj = Dict[str, Any]


def _split_pointer(path: str) -> List[str]:
    if not path or path == "/":
        return []
    assert path.startswith("/")
    parts = path.split("/")[1:]
    # unescape ~1 and ~0 per RFC6901
    return [p.replace("~1", "/").replace("~0", "~") for p in parts]


def _get_parent_and_key(doc: Any, path: str) -> Tuple[Any, str]:
    parts = _split_pointer(path)
    if not parts:
        return None, ""  # root
    parent = doc
    for key in parts[:-1]:
        if isinstance(parent, list):
            idx = int(key)
            parent = parent[idx]
        else:
            parent = parent.setdefault(key, {})
    return parent, parts[-1]


def _set_pointer(doc: Any, path: str, value: Any, create: bool = False) -> None:
    parent, key = _get_parent_and_key(doc, path)
    if parent is None:
        raise ValueError("Cannot set the document root directly")
    if isinstance(parent, list):
        if key == "-":
            parent.append(value)
        else:
            idx = int(key)
            if create and idx == len(parent):
                parent.append(value)
            else:
                parent[idx] = value
    else:
        if not create and key not in parent:
            # For replace when key is missing
            pass
        parent[key] = value


def _remove_pointer(doc: Any, path: str) -> None:
    parent, key = _get_parent_and_key(doc, path)
    if parent is None:
        raise ValueError("Cannot remove the document root")
    if isinstance(parent, list):
        idx = int(key)
        parent.pop(idx)
    else:
        parent.pop(key, None)


def is_allowed_path(path: str, allowed: List[str]) -> bool:
    return any(path == a or path.startswith(a + "/") for a in allowed)


def apply_patch_with_validation(ctx: AssistantContext, content: JsonObj, patch_ops: List[PatchOp]) -> Tuple[bool, str, JsonObj]:
    # Validate ops
    for op in patch_ops:
        if op.op not in ("add", "replace", "remove"):
            return False, f"Unsupported op: {op.op}", content
        if not is_allowed_path(op.path, ctx.allowed_paths):
            return False, f"Disallowed path: {op.path}", content

    candidate = deepcopy(content)
    try:
        for op in patch_ops:
            if op.op in ("add", "replace"):
                _set_pointer(candidate, op.path, op.value, create=(op.op == "add"))
            elif op.op == "remove":
                _remove_pointer(candidate, op.path)
        return True, "OK", candidate
    except Exception as e:
        return False, f"Patch error: {e}", content


def _resolve_pointer(doc: Any, path: str) -> Tuple[bool, Any]:
    if path == "/" or path == "":
        return True, doc
    try:
        parent = doc
        for key in _split_pointer(path):
            if isinstance(parent, list):
                idx = int(key)
                parent = parent[idx]
            else:
                if key not in parent:
                    return False, None
                parent = parent[key]
        return True, parent
    except Exception:
        return False, None


def compute_allowed_path_replacements(old: JsonObj, new: JsonObj, allowed_paths: List[str]) -> List[PatchOp]:
    """Compute a minimal set of replace/add/remove ops by comparing allowed path roots.
    For each allowed path prefix, if the subtree differs, emit a single op:
    - add if missing in old and present in new
    - remove if present in old and missing in new
    - replace if both present and differ
    """
    ops: List[PatchOp] = []
    for p in allowed_paths:
        old_exists, old_val = _resolve_pointer(old, p)
        new_exists, new_val = _resolve_pointer(new, p)
        if not old_exists and new_exists:
            ops.append(PatchOp(op="add", path=p, value=new_val))
        elif old_exists and not new_exists:
            ops.append(PatchOp(op="remove", path=p))
        elif old_exists and new_exists:
            if old_val != new_val:
                ops.append(PatchOp(op="replace", path=p, value=new_val))
        # if neither exists, nothing to do
    return ops


```

### File: world_configurator\assistant\prompt_builder.py

```python
"""
Prompt builders for different assistant modes and domains.
"""
from __future__ import annotations

import json
from typing import List

from .context import AssistantContext

ANALYZE_CONTRACT = (
    "Return JSON with keys: intent='analyze', analysis (string), recommendations (list of strings),"
    " optional suggested_patch (list of RFC6902 ops). If the user explicitly requests creating a new entry,"
    " you may return intent='create_entry' with entity_type (string), rationale (string), entry (object OR array of objects) instead."
)

MODIFY_CONTRACT = (
    "Return JSON with keys: intent='modify_selection', rationale (string), patch (list of RFC6902 ops)."
    " Allowed ops: add, replace, remove only."
    " Do not return a full replacement object; only patch the requested sections."
)

CREATE_CONTRACT = (
    "Return JSON with keys: intent='create_entry', entity_type (string), rationale (string), entry (object OR array of objects)."
    " If the user requests multiple entries, set entry to an array with that many items."
    " Each entry must conform to the domain structure, avoid placeholders, and use unique names (no duplicates across the new set or existing entries)."
)


def build_system_prompt(mode: str, ctx: AssistantContext) -> str:
    base = [
        "You are a world-building design assistant for an RPG world configurator.",
        "You will receive domain data (e.g., classes, origins) and MUST follow constraints:",
        "- For modifications, ONLY modify whitelisted JSON Pointer paths.",
        "- Prefer precise RFC6902 JSON Patch ops (add/replace/remove).",
        "- Maintain data consistency and avoid inventing unknown keys.",
        "- Do not return a full replacement object for modify_selection; only return patch ops.",
        "- When creating a new entry, ensure the new name is unique within the domain.",
    ]

    if mode == "analyze":
        base.append(ANALYZE_CONTRACT)
    elif mode == "modify":
        base.append("Allowed edit paths: " + ", ".join(ctx.allowed_paths))
        if ctx.references and isinstance(ctx.references, dict):
            et = ctx.references.get("effect_types")
            if isinstance(et, list) and et:
                base.append("When specifying dice_roll_effects.effect_type, choose only from: " + ", ".join(et))
        # Typed resistances guidance
        if ctx.references and isinstance(ctx.references, dict):
            et = ctx.references.get("effect_types")
            if isinstance(et, list) and et:
                base.append("For custom_properties.typed_resistances: keys MUST be one of these types: " + ", ".join(et) + ". Values are integer percentages in [-100, 100]. Omit entries that are 0.")
        base.append(MODIFY_CONTRACT)
    elif mode == "create":
        # If existing names are provided in references, emphasize not to reuse them
        if ctx.references and isinstance(ctx.references, dict):
            et = ctx.references.get("effect_types")
            if isinstance(et, list) and et:
                base.append("When specifying dice_roll_effects.effect_type, choose only from: " + ", ".join(et))
                base.append("If proposing custom_properties.typed_resistances, use only these types as keys; values are integer percentages in [-100, 100]; omit 0 entries.")
        if ctx.references and isinstance(ctx.references, dict):
            existing = ctx.references.get("existing_names") or ctx.references.get("existing_names_list")
            if existing and isinstance(existing, list) and existing:
                base.append("Do not reuse any of these existing names: " + ", ".join(existing[:50]))
            ids = ctx.references.get("existing_ids")
            if ids and isinstance(ids, list) and ids:
                base.append("IDs must be unique. You may omit 'id' to let the tool assign one.")
        base.append("If the user requests N entries, return exactly N entries in 'entry' as an array. Ensure no duplicates among the new entries.")
        base.append(CREATE_CONTRACT)
    else:
        base.append("Unknown mode; still follow JSON output contracts strictly.")

    return "\n".join(base)


def build_messages(mode: str, ctx: AssistantContext, user_text: str) -> List[dict]:
    """Constructs a list of chat messages for the LLM (single-turn)."""
    sys = build_system_prompt(mode, ctx)

    content_blocks = [
        f"Domain: {ctx.domain}",
        f"Selection ID: {ctx.selection_id or 'N/A'}",
        "Current Selection JSON:\n" + (json.dumps(ctx.content, ensure_ascii=False, indent=2) if ctx.content else "N/A"),
    ]

    if ctx.schema:
        content_blocks.append("Schema Hints:\n" + json.dumps(ctx.schema, ensure_ascii=False, indent=2))
    if ctx.exemplars:
        content_blocks.append("Examples (may inspire new entries):\n" + json.dumps(ctx.exemplars[:1], ensure_ascii=False, indent=2))
    if ctx.references:
        content_blocks.append("Reference Catalogs:\n" + json.dumps(ctx.references, ensure_ascii=False, indent=2))

    # Heuristic guidance: if user mentions resistances, steer to typed_resistances path
    try:
        low = (user_text or "").lower()
        if any(tok in low for tok in ["resistance", "resistances", "resistant", "typed resistance"]):
            allowed = []
            try:
                if isinstance(ctx.references, dict):
                    allowed = ctx.references.get("effect_types") or []
            except Exception:
                pass
            hint = [
                "Assistant Hint:",
                "- Treat 'resistances' as custom_properties.typed_resistances, NOT dice_roll_effects.",
                "- Only use allowed damage types as keys: " + ", ".join(allowed) if allowed else "- Use only valid damage types from references.",
                "- Integer percentages in [-100, 100]. Omit 0 entries.",
                "- In modify mode, return RFC6902 ops targeting /custom_properties/typed_resistances (add or replace).",
            ]
            content_blocks.append("\n".join(hint))
    except Exception:
        pass

    user_context = "\n\n".join(content_blocks)

    return [
        {"role": "system", "content": sys},
        {"role": "user", "content": user_context},
        {"role": "user", "content": "My request:\n" + user_text},
    ]


def build_messages_analyze(history: List[dict], ctx: AssistantContext, user_text: str, lean: bool = True) -> List[dict]:
    """Construct multi-turn messages for Analyze mode.

    - First turn (no history): include system + selection JSON + references + user request.
    - Follow-ups: include system + prior history + new user_text.
      If lean is False, we also resend the selection JSON block before the new user_text.
    """
    sys = build_system_prompt("analyze", ctx)

    if not history:
        # First turn: seed with selection JSON and references
        content_blocks = [
            f"Domain: {ctx.domain}",
            f"Selection ID: {ctx.selection_id or 'N/A'}",
            "Current Selection JSON:\n" + (json.dumps(ctx.content, ensure_ascii=False, indent=2) if ctx.content else "N/A"),
        ]
        if ctx.schema:
            content_blocks.append("Schema Hints:\n" + json.dumps(ctx.schema, ensure_ascii=False, indent=2))
        if ctx.references:
            content_blocks.append("Reference Catalogs:\n" + json.dumps(ctx.references, ensure_ascii=False, indent=2))
        try:
            low = (user_text or "").lower()
            if any(tok in low for tok in ["resistance", "resistances", "resistant", "typed resistance"]):
                allowed = []
                try:
                    if isinstance(ctx.references, dict):
                        allowed = ctx.references.get("effect_types") or []
                except Exception:
                    pass
                hint = [
                    "Assistant Hint:",
                    "- Treat 'resistances' as custom_properties.typed_resistances, NOT dice_roll_effects.",
                    "- Only use allowed damage types as keys: " + ", ".join(allowed) if allowed else "- Use only valid damage types from references.",
                    "- Integer percentages in [-100, 100]. Omit 0 entries.",
                    "- In modify mode, return RFC6902 ops targeting /custom_properties/typed_resistances (add or replace).",
                ]
                content_blocks.append("\n".join(hint))
        except Exception:
            pass
        user_context = "\n\n".join(content_blocks)
        return [
            {"role": "system", "content": sys},
            {"role": "user", "content": user_context},
            {"role": "user", "content": "My request:\n" + user_text},
        ]

    # Follow-up turns
    messages: List[dict] = [
        {"role": "system", "content": sys}
    ]
    messages.extend(history)
    if not lean:
        # Re-ground with selection JSON again if not leaning
        rectx = [
            f"Domain: {ctx.domain}",
            f"Selection ID: {ctx.selection_id or 'N/A'}",
            "Current Selection JSON:\n" + (json.dumps(ctx.content, ensure_ascii=False, indent=2) if ctx.content else "N/A"),
        ]
        if ctx.references:
            rectx.append("Reference Catalogs:\n" + json.dumps(ctx.references, ensure_ascii=False, indent=2))
        messages.append({"role": "user", "content": "\n\n".join(rectx)})
    messages.append({"role": "user", "content": user_text})
    return messages


```

### File: world_configurator\ui\dialogs\__init__.py

```python
"""
Dialog components for the World Configurator Tool.
"""

```

### File: world_configurator\ui\dialogs\base_dialog.py

```python
"""
Base dialog class for the World Configurator Tool.
"""

import logging
from PySide6.QtCore import Qt, QSize
from PySide6.QtWidgets import QDialog
from PySide6.QtGui import QScreen

logger = logging.getLogger("world_configurator.ui.dialogs.base_dialog")


class BaseDialog(QDialog):
    """Base class for dialogs to enforce maximum size constraints."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._constrained_to_screen = False
    
    def showEvent(self, event):
        """Override showEvent to constrain dialog size to screen dimensions."""
        try:
            if not self._constrained_to_screen:
                screen = self.screen()
                if screen:
                    screen_geometry = screen.availableGeometry()
                    max_width = int(screen_geometry.width() * 0.9)
                    max_height = int(screen_geometry.height() * 0.9)
                    
                    # Set maximum size
                    self.setMaximumSize(QSize(max_width, max_height))
                    
                    # Adjust current size if needed
                    current_size = self.size()
                    new_width = min(current_size.width(), max_width)
                    new_height = min(current_size.height(), max_height)
                    
                    if new_width != current_size.width() or new_height != current_size.height():
                        self.resize(new_width, new_height)
                    
                    # Center on screen if possible
                    self.move(
                        screen_geometry.center().x() - self.width() // 2,
                        screen_geometry.center().y() - self.height() // 2
                    )
                
                self._constrained_to_screen = True
                
        except Exception as e:
            logger.error(f"Error adjusting dialog size in BaseDialog.showEvent for '{self.windowTitle()}': {e}", exc_info=True)
            # Ensure the flag is set even on error to prevent repeated attempts
            self._constrained_to_screen = True
        
        super().showEvent(event)
```

### File: world_configurator\ui\dialogs\export_dialog.py

```python
"""
Export dialog for the World Configurator Tool.
"""

import logging
from typing import Dict
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QCheckBox, QLabel,
    QPushButton, QHBoxLayout, QGroupBox
)

from ui.dialogs.base_dialog import BaseDialog

logger = logging.getLogger("world_configurator.ui.dialogs.export")

class ExportDialog(BaseDialog):
    """
    Dialog for exporting project to the game.
    """

    def __init__(self, parent=None):
        """
        Initialize the dialog.

        Args:
            parent: The parent widget.
        """
        super().__init__(parent)

        self.setWindowTitle("Export to Game")
        self.setMinimumWidth(400)

        self._setup_ui()

    def _setup_ui(self):
        """Set up the UI components."""
        # Main layout
        layout = QVBoxLayout(self)

        # Add description
        description = QLabel(
            "This will export the world configuration to the game's configuration directory. "
            "Select the components you want to export:"
        )
        description.setWordWrap(True)
        layout.addWidget(description)

        # Components group box
        components_group = QGroupBox("Components")
        self.components_layout = QVBoxLayout(components_group)

        # Component checkboxes
        self.chk_cultures = QCheckBox("Cultures")
        self.chk_cultures.setChecked(True)
        self.components_layout.addWidget(self.chk_cultures)

        self.chk_races = QCheckBox("Races")
        self.chk_races.setChecked(True)
        self.components_layout.addWidget(self.chk_races)

        self.chk_classes = QCheckBox("Classes")
        self.chk_classes.setChecked(True)
        self.components_layout.addWidget(self.chk_classes)

        self.chk_skills = QCheckBox("Skills") # NEW
        self.chk_skills.setChecked(True)
        self.components_layout.addWidget(self.chk_skills)

        # Item categories - NEW
        self.item_checkboxes: Dict[str, QCheckBox] = {}
        from ..editors.item_editor_panel import ITEM_CATEGORIES as ITEM_CATS_FOR_EXPORT # Use the same source
        for cat_name in ITEM_CATS_FOR_EXPORT.keys():
            chk = QCheckBox(cat_name)
            chk.setChecked(True)
            self.components_layout.addWidget(chk)
            self.item_checkboxes[cat_name] = chk


        self.chk_locations = QCheckBox("Locations")
        self.chk_locations.setChecked(True)
        self.components_layout.addWidget(self.chk_locations)

        # Location defaults (culture mix)
        self.chk_location_defaults = QCheckBox("Culture Mix Defaults (Locations)")
        self.chk_location_defaults.setChecked(True)
        self.components_layout.addWidget(self.chk_location_defaults)

        self.chk_history = QCheckBox("World History")
        self.chk_history.setChecked(True)
        self.components_layout.addWidget(self.chk_history)

        self.chk_rules = QCheckBox("Fundamental Rules")
        self.chk_rules.setChecked(True)
        self.components_layout.addWidget(self.chk_rules)

        self.chk_origins = QCheckBox("Origins")
        self.chk_origins.setChecked(True)
        self.components_layout.addWidget(self.chk_origins)

        self.chk_quests = QCheckBox("Quests")
        self.chk_quests.setChecked(True)
        self.components_layout.addWidget(self.chk_quests)

        self.chk_magic_systems = QCheckBox("Magic Systems")
        self.chk_magic_systems.setChecked(True)
        self.components_layout.addWidget(self.chk_magic_systems)

        self.chk_names = QCheckBox("Names")
        self.chk_names.setChecked(True)
        self.components_layout.addWidget(self.chk_names)
        
        self.chk_variants = QCheckBox("NPC Variants")
        self.chk_variants.setChecked(True)
        self.components_layout.addWidget(self.chk_variants)

        layout.addWidget(components_group)

        # Select all/none buttons
        select_buttons = QHBoxLayout()

        self.select_all_btn = QPushButton("Select All")
        self.select_all_btn.clicked.connect(self._select_all)
        select_buttons.addWidget(self.select_all_btn)

        self.select_none_btn = QPushButton("Select None")
        self.select_none_btn.clicked.connect(self._select_none)
        select_buttons.addWidget(self.select_none_btn)

        layout.addLayout(select_buttons)

        # Buttons
        buttons = QHBoxLayout()

        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)

        self.export_btn = QPushButton("Export")
        self.export_btn.clicked.connect(self.accept)
        self.export_btn.setDefault(True)

        buttons.addWidget(self.cancel_btn)
        buttons.addStretch()
        buttons.addWidget(self.export_btn)

        layout.addLayout(buttons)
        
    def _select_all(self):
        """Select all components."""
        self.chk_cultures.setChecked(True)
        self.chk_races.setChecked(True)
        self.chk_classes.setChecked(True)
        self.chk_skills.setChecked(True) # NEW
        for chk_item_cat in self.item_checkboxes.values(): # NEW
            chk_item_cat.setChecked(True)
        self.chk_locations.setChecked(True)
        self.chk_location_defaults.setChecked(True)
        self.chk_history.setChecked(True)
        self.chk_rules.setChecked(True)
        self.chk_origins.setChecked(True)
        self.chk_quests.setChecked(True)
        self.chk_magic_systems.setChecked(True)
        self.chk_names.setChecked(True)
        self.chk_variants.setChecked(True)

    def _select_none(self):
        """Deselect all components."""
        self.chk_cultures.setChecked(False)
        self.chk_races.setChecked(False)
        self.chk_classes.setChecked(False)
        self.chk_skills.setChecked(False) # NEW
        for chk_item_cat in self.item_checkboxes.values(): # NEW
            chk_item_cat.setChecked(False)
        self.chk_locations.setChecked(False)
        self.chk_location_defaults.setChecked(False)
        self.chk_history.setChecked(False)
        self.chk_rules.setChecked(False)
        self.chk_origins.setChecked(False)
        self.chk_quests.setChecked(False)
        self.chk_magic_systems.setChecked(False)
        self.chk_names.setChecked(False)
        self.chk_variants.setChecked(False)

    def get_export_options(self) -> dict:
        """
        Get the export options selected by the user.

        Returns:
            A dictionary of export options.
        """
        options = {
            "cultures": self.chk_cultures.isChecked(),
            "races": self.chk_races.isChecked(),
            "classes": self.chk_classes.isChecked(),
            "skills": self.chk_skills.isChecked(), # NEW
            "locations": self.chk_locations.isChecked(),
            "location_defaults": self.chk_location_defaults.isChecked(),
            "history": self.chk_history.isChecked(),
            "rules": self.chk_rules.isChecked(),
            "origins": self.chk_origins.isChecked(),
            "quests": self.chk_quests.isChecked(),
            "magic_systems": self.chk_magic_systems.isChecked(),
            "names": self.chk_names.isChecked(),
            "variants": self.chk_variants.isChecked(),
        }
        # Add item categories to options - NEW
        from ..editors.item_editor_panel import ITEM_CATEGORIES as ITEM_CATS_FOR_EXPORT_GET
        for cat_key_export, _ in ITEM_CATS_FOR_EXPORT_GET.items():

            if cat_key_export == "Starting Items":
                options["items_origin"] = self.item_checkboxes[cat_key_export].isChecked()
            elif cat_key_export == "Weapon Templates":
                options["items_weapons"] = self.item_checkboxes[cat_key_export].isChecked()
            elif cat_key_export == "Armor Templates":
                options["items_armor"] = self.item_checkboxes[cat_key_export].isChecked()
            elif cat_key_export == "Consumable Templates":
                options["items_consumables"] = self.item_checkboxes[cat_key_export].isChecked()
            elif cat_key_export == "Miscellaneous Templates":
                options["items_misc"] = self.item_checkboxes[cat_key_export].isChecked()
            # Add more mappings if there are other item categories

        return options
```

### File: world_configurator\ui\dialogs\item_selection_dialog.py

```python
# world_configurator/ui/dialogs/item_selection_dialog.py
"""
Dialog for selecting items from a filterable, sortable list.
"""

import logging
import os
import json
from typing import List, Dict, Optional, Set, Any

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QListWidget,
    QListWidgetItem, QPushButton, QDialogButtonBox, QLabel, QMessageBox
)

from ui.dialogs.base_dialog import BaseDialog
from utils.file_manager import get_project_root, load_json

logger = logging.getLogger("world_configurator.ui.item_selection_dialog")

class ItemSelectionDialog(BaseDialog):
    """
    A dialog that allows users to select items from a list.
    The list is populated from a specified JSON file, supports filtering, sorting,
    and pre-checks existing items.
    """

    def __init__(self, parent: Optional[QWidget] = None,
                 existing_item_ids: Optional[List[str]] = None,
                 item_file_path: str = "config/items/origin_items.json"):
        super().__init__(parent)
        self.setWindowTitle("Select Items")
        self.setMinimumWidth(450)
        self.setMinimumHeight(500)

        self.all_items: Dict[str, Dict[str, Any]] = {}  # Stores item_id: {name, description, ...}
        self.selected_item_ids: Set[str] = set(existing_item_ids) if existing_item_ids else set()
        self.item_file_path_relative = item_file_path # Store relative path for logging

        self._load_items_data(item_file_path)
        self._setup_ui()
        self._populate_item_list()

    def _load_items_data(self, relative_item_file_path: str):
        """Load items from the specified JSON file."""
        try:
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
            full_item_file_path = os.path.join(project_root, relative_item_file_path)

            if not os.path.exists(full_item_file_path):
                logger.error(f"Item file not found at: {full_item_file_path}")
                QMessageBox.critical(self, "Error", f"Could not find item file: {relative_item_file_path}")
                return

            data = load_json(full_item_file_path) # load_json expects a list of items for these files
            if data and isinstance(data, list):
                for item_data in data:
                    item_id = item_data.get("id")
                    item_name = item_data.get("name")
                    if item_id and item_name:
                        self.all_items[item_id] = item_data
                    else:
                        logger.warning(f"Item entry missing 'id' or 'name' in {relative_item_file_path}. Entry: {item_data}")
            else:
                logger.warning(f"Item data is not a list or is empty in {relative_item_file_path}")
        except Exception as e:
            logger.error(f"Error loading items data from {relative_item_file_path}: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An error occurred while loading items from {relative_item_file_path}: {str(e)}")

    def _setup_ui(self):
        """Set up the UI components."""
        layout = QVBoxLayout(self)

        # Filter
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Filter:"))
        self.filter_edit = QLineEdit()
        self.filter_edit.setPlaceholderText("Type to filter items by name or ID...")
        self.filter_edit.textChanged.connect(self._filter_items)
        filter_layout.addWidget(self.filter_edit)
        layout.addLayout(filter_layout)

        # Sorting
        sort_layout = QHBoxLayout()
        self.sort_asc_button = QPushButton("Sort A-Z")
        self.sort_asc_button.clicked.connect(lambda: self.item_list_widget.sortItems(Qt.AscendingOrder))
        sort_layout.addWidget(self.sort_asc_button)

        self.sort_desc_button = QPushButton("Sort Z-A")
        self.sort_desc_button.clicked.connect(lambda: self.item_list_widget.sortItems(Qt.DescendingOrder))
        sort_layout.addWidget(self.sort_desc_button)
        sort_layout.addStretch()
        layout.addLayout(sort_layout)

        # Item list
        self.item_list_widget = QListWidget()
        self.item_list_widget.setSelectionMode(QListWidget.NoSelection) # Checkboxes handle selection
        layout.addWidget(self.item_list_widget)

        # Buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _populate_item_list(self):
        """Populate the item list widget with checkboxes."""
        self.item_list_widget.clear()
        sorted_item_ids = sorted(self.all_items.keys(), key=lambda item_id: self.all_items[item_id].get("name", item_id))

        for item_id in sorted_item_ids:
            item_data = self.all_items[item_id]
            display_name = item_data.get("name", item_id)
            item_type = item_data.get("item_type", "unknown")
            list_display_text = f"{display_name} (ID: {item_id}, Type: {item_type})"

            item = QListWidgetItem(list_display_text)
            item.setData(Qt.UserRole, item_id) # Store the item_id
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)

            if item_id in self.selected_item_ids:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
            self.item_list_widget.addItem(item)

    def _filter_items(self, text: str):
        """Filter the item list based on input text."""
        for i in range(self.item_list_widget.count()):
            item = self.item_list_widget.item(i)
            # Filter by display text (which includes name, ID, and type)
            if text.lower() in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def _on_accept(self):
        """Update the selected_item_ids set before accepting."""
        self.selected_item_ids.clear()
        for i in range(self.item_list_widget.count()):
            item = self.item_list_widget.item(i)
            if item.checkState() == Qt.Checked:
                self.selected_item_ids.add(item.data(Qt.UserRole)) # Store item_id
        self.accept()

    def get_selected_item_ids(self) -> List[str]:
        """
        Return a list of the IDs of the selected items.
        This is called after the dialog is accepted.
        """
        return sorted(list(self.selected_item_ids))
```

### File: world_configurator\ui\dialogs\new_project_dialog.py

```python
"""
New project dialog for the World Configurator Tool.
"""

import logging
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLabel, QLineEdit,
    QPushButton, QHBoxLayout, QMessageBox
)

from ui.dialogs.base_dialog import BaseDialog

logger = logging.getLogger("world_configurator.ui.dialogs.new_project")

class NewProjectDialog(BaseDialog):
    """
    Dialog for creating a new project.
    """
    
    def __init__(self, parent=None):
        """
        Initialize the dialog.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        self.setWindowTitle("New Project")
        self.setMinimumWidth(400)
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the UI components."""
        # Main layout
        layout = QVBoxLayout(self)
        
        # Form layout
        form = QFormLayout()
        
        # Project name field
        self.name_edit = QLineEdit("New World")
        self.name_edit.selectAll()
        form.addRow("Project Name:", self.name_edit)
        
        layout.addLayout(form)
        
        # Buttons
        buttons = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.create_btn = QPushButton("Create")
        self.create_btn.clicked.connect(self._on_create)
        self.create_btn.setDefault(True)
        
        buttons.addWidget(self.cancel_btn)
        buttons.addStretch()
        buttons.addWidget(self.create_btn)
        
        layout.addLayout(buttons)
    
    def _on_create(self):
        """Handle the Create button click."""
        project_name = self.name_edit.text().strip()
        
        if not project_name:
            QMessageBox.warning(
                self,
                "Invalid Name",
                "Please enter a project name."
            )
            return
        
        # Accept the dialog
        self.accept()
    
    def get_project_name(self) -> str:
        """
        Get the project name entered by the user.
        
        Returns:
            The project name.
        """
        return self.name_edit.text().strip()

```

### File: world_configurator\ui\dialogs\quest_selection_dialog.py

```python
"""
Quest selection dialog for choosing existing quest IDs from QuestManager.
"""
from __future__ import annotations

from typing import List, Tuple, Optional

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QListWidget,
    QListWidgetItem, QPushButton, QDialogButtonBox
)


class QuestSelectionDialog(QDialog):
    """Dialog to select one or more existing quest IDs.

    Args:
        parent: Parent widget.
        available_quests: A list of tuples (quest_id, title) to choose from.
        existing_ids: The list of quest IDs currently selected (to pre-check).
    """

    def __init__(self, parent=None, available_quests: Optional[List[Tuple[str, str]]] = None, existing_ids: Optional[List[str]] = None):
        super().__init__(parent)
        self.setWindowTitle("Select Initial Quests")
        self.setMinimumWidth(420)
        self.available_quests = available_quests or []
        self.existing_ids = set(existing_ids or [])

        self._setup_ui()

    def _setup_ui(self) -> None:
        layout = QVBoxLayout(self)

        # Filter row
        filter_row = QHBoxLayout()
        filter_row.addWidget(QLabel("Filter:"))
        self.filter_edit = QLineEdit()
        self.filter_edit.setPlaceholderText("Type to filter by ID or title…")
        self.filter_edit.textChanged.connect(self._apply_filter)
        filter_row.addWidget(self.filter_edit)
        layout.addLayout(filter_row)

        # Quest list (checkable)
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QListWidget.MultiSelection)
        layout.addWidget(self.list_widget)

        # Populate items
        for qid, title in sorted(self.available_quests, key=lambda x: (x[1].lower(), x[0].lower())):
            text = f"{title} ({qid})" if title else qid
            item = QListWidgetItem(text)
            item.setData(Qt.UserRole, qid)
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
            item.setCheckState(Qt.Checked if qid in self.existing_ids else Qt.Unchecked)
            self.list_widget.addItem(item)

        # Quick actions
        actions = QHBoxLayout()
        select_all_btn = QPushButton("Select All")
        select_all_btn.clicked.connect(self._select_all)
        clear_btn = QPushButton("Clear")
        clear_btn.clicked.connect(self._clear_all)
        actions.addWidget(select_all_btn)
        actions.addWidget(clear_btn)
        actions.addStretch()
        layout.addLayout(actions)

        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def _apply_filter(self) -> None:
        term = (self.filter_edit.text() or "").strip().lower()
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            visible = term in it.text().lower()
            it.setHidden(not visible)

    def _select_all(self) -> None:
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            if not it.isHidden():
                it.setCheckState(Qt.Checked)

    def _clear_all(self) -> None:
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            if not it.isHidden():
                it.setCheckState(Qt.Unchecked)

    def get_selected_ids(self) -> List[str]:
        selected: List[str] = []
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            if it.checkState() == Qt.Checked:
                qid = it.data(Qt.UserRole)
                if isinstance(qid, str):
                    selected.append(qid)
        return selected


```

### File: world_configurator\ui\dialogs\settings_dialog.py

```python
"""
Settings dialog for the World Configurator Tool.
"""

import logging
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLabel, QLineEdit,
    QPushButton, QHBoxLayout, QTabWidget, QWidget,
    QCheckBox, QComboBox, QSpinBox, QFileDialog
)
import os
from utils.file_manager import get_config_dir, load_json, save_json

from ui.dialogs.base_dialog import BaseDialog

logger = logging.getLogger("world_configurator.ui.dialogs.settings")

class SettingsDialog(BaseDialog):
    """
    Dialog for editing application settings.
    """
    
    def __init__(self, parent=None):
        """
        Initialize the dialog.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        self.setWindowTitle("Settings")
        self.setMinimumWidth(600)
        self.setMinimumHeight(450)
        
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the UI components."""
        # Main layout
        layout = QVBoxLayout(self)
        
        # Tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        
        # General tab
        self.general_tab = QWidget()
        self.tab_widget.addTab(self.general_tab, "General")
        
        general_layout = QVBoxLayout(self.general_tab)
        
        # Game path setting
        game_path_layout = QHBoxLayout()
        game_path_layout.addWidget(QLabel("Game Path:"))
        
        self.game_path_edit = QLineEdit()
        game_path_layout.addWidget(self.game_path_edit)
        
        self.browse_btn = QPushButton("Browse...")
        self.browse_btn.clicked.connect(self._browse_game_path)
        game_path_layout.addWidget(self.browse_btn)
        
        general_layout.addLayout(game_path_layout)
        
        # Projects folder setting
        projects_path_layout = QHBoxLayout()
        projects_path_layout.addWidget(QLabel("Projects Folder:"))
        
        self.projects_path_edit = QLineEdit()
        projects_path_layout.addWidget(self.projects_path_edit)
        
        self.browse_projects_btn = QPushButton("Browse...")
        self.browse_projects_btn.clicked.connect(self._browse_projects_path)
        projects_path_layout.addWidget(self.browse_projects_btn)
        
        general_layout.addLayout(projects_path_layout)
        
        # Auto-save settings
        self.autosave_check = QCheckBox("Enable Auto-Save")
        general_layout.addWidget(self.autosave_check)
        
        autosave_interval_layout = QHBoxLayout()
        autosave_interval_layout.addWidget(QLabel("Auto-Save Interval (minutes):"))
        
        self.autosave_interval_spin = QSpinBox()
        self.autosave_interval_spin.setRange(1, 60)
        self.autosave_interval_spin.setValue(5)
        autosave_interval_layout.addWidget(self.autosave_interval_spin)
        
        general_layout.addLayout(autosave_interval_layout)
        
        # Add spacer to fill remaining space
        general_layout.addStretch()
        
        # Advanced tab
        self.advanced_tab = QWidget()
        self.tab_widget.addTab(self.advanced_tab, "Advanced")
        
        advanced_layout = QVBoxLayout(self.advanced_tab)
        
        # Logging level setting
        log_level_layout = QHBoxLayout()
        log_level_layout.addWidget(QLabel("Logging Level:"))
        
        self.log_level_combo = QComboBox()
        self.log_level_combo.addItems(["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"])
        self.log_level_combo.setCurrentText("INFO")
        log_level_layout.addWidget(self.log_level_combo)
        
        advanced_layout.addLayout(log_level_layout)
        
        # Add spacer to fill remaining space
        advanced_layout.addStretch()

        # LLM tab
        from llm.providers_registry import ProviderRegistry
        from llm.settings import load_llm_settings, save_llm_settings, LLMSettings
        self.llm_tab = QWidget()
        self.tab_widget.addTab(self.llm_tab, "LLM")
        llm_layout = QVBoxLayout(self.llm_tab)
        
        self.provider_combo = QComboBox()
        self.model_combo = QComboBox()
        self.api_key_edit = QLineEdit(); self.api_key_edit.setEchoMode(QLineEdit.Password)
        
        reg = ProviderRegistry(); reg.load()
        providers = reg.list_providers()
        self.provider_combo.addItems(providers)
        
        saved = load_llm_settings()
        
        def _on_provider_changed():
            self.model_combo.clear()
            prov = self.provider_combo.currentText()
            models = reg.list_models_for(prov)
            self.model_combo.addItems([m.get("id", "") for m in models])
            # Load per-provider key
            key = saved.provider_keys.get(prov, "") if saved else ""
            self.api_key_edit.setText(key)
        self.provider_combo.currentTextChanged.connect(_on_provider_changed)
        
        # Initialize from saved
        if saved.provider and saved.provider in providers:
            self.provider_combo.setCurrentText(saved.provider)
        else:
            if providers:
                self.provider_combo.setCurrentIndex(0)
        _on_provider_changed()
        if saved.model:
            self.model_combo.setCurrentText(saved.model)
        
        llm_layout.addLayout(self._form_row("Provider:", self.provider_combo))
        llm_layout.addLayout(self._form_row("Model:", self.model_combo))
        llm_layout.addLayout(self._form_row("API Key:", self.api_key_edit))
        llm_layout.addStretch()

        # NPC Generation tab (Developer)
        self.npc_tab = QWidget()
        self.tab_widget.addTab(self.npc_tab, "NPC Generation")
        npc_layout = QVBoxLayout(self.npc_tab)

        # Mode
        self.npc_mode_combo = QComboBox()
        self.npc_mode_combo.addItems(["families", "legacy"])  # order: prefer new system
        npc_layout.addLayout(self._form_row("Generation Mode:", self.npc_mode_combo))

        # Difficulty and Encounter options populated from generation_rules.json
        self.npc_difficulty_combo = QComboBox()
        self.npc_encounter_combo = QComboBox()
        self._populate_generation_options()
        npc_layout.addLayout(self._form_row("Default Difficulty:", self.npc_difficulty_combo))
        npc_layout.addLayout(self._form_row("Default Encounter Size:", self.npc_encounter_combo))
        npc_layout.addStretch()

        # Initialize values from game/system config
        self._load_npc_generation_settings()
        
        # Buttons
        buttons = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self._save_all)
        self.save_btn.setDefault(True)
        
        buttons.addWidget(self.cancel_btn)
        buttons.addStretch()
        buttons.addWidget(self.save_btn)
        
        layout.addLayout(buttons)
    
    def _form_row(self, label: str, widget: QWidget) -> QHBoxLayout:
        row = QHBoxLayout()
        row.addWidget(QLabel(label))
        row.addWidget(widget)
        return row
    
    def _populate_generation_options(self) -> None:
        """Load difficulty and encounter keys from npc/generation_rules.json."""
        try:
            cfg_dir = get_config_dir()
            rules_path = os.path.join(cfg_dir, "npc", "generation_rules.json")
            rules = load_json(rules_path) or {}
            scaling = rules.get("scaling", {}) or {}
            diffs = list((scaling.get("difficulty", {}) or {}).keys())
            encs = list((scaling.get("encounter_size", {}) or {}).keys())
            # Reasonable defaults if empty
            if not diffs:
                diffs = ["story", "normal", "hard", "expert"]
            if not encs:
                encs = ["solo", "pack", "mixed"]
            self.npc_difficulty_combo.clear(); self.npc_difficulty_combo.addItems(diffs)
            self.npc_encounter_combo.clear(); self.npc_encounter_combo.addItems(encs)
        except Exception as e:
            logger.warning(f"Failed to load generation rules options: {e}")
            self.npc_difficulty_combo.clear(); self.npc_difficulty_combo.addItems(["normal"])
            self.npc_encounter_combo.clear(); self.npc_encounter_combo.addItems(["solo"])    
    
    def _load_npc_generation_settings(self) -> None:
        """Initialize UI from system_config.json and game_config.json."""
        try:
            cfg_dir = get_config_dir()
            # system
            sys_path = os.path.join(cfg_dir, "system_config.json")
            sys_data = load_json(sys_path) or {}
            mode = (sys_data.get("npc_generation_mode") or "legacy")
            if mode not in ["families", "legacy"]:
                mode = "legacy"
            self.npc_mode_combo.setCurrentText(mode)
            # game
            game_path = os.path.join(cfg_dir, "game_config.json")
            game_data = load_json(game_path) or {}
            diff = (game_data.get("difficulty") or "normal")
            enc = (game_data.get("encounter_size") or "solo")
            # If values not in options, leave current selection
            if self.npc_difficulty_combo.findText(diff) >= 0:
                self.npc_difficulty_combo.setCurrentText(diff)
            if self.npc_encounter_combo.findText(enc) >= 0:
                self.npc_encounter_combo.setCurrentText(enc)
        except Exception as e:
            logger.warning(f"Failed to load NPC generation settings: {e}")
    
    def _browse_game_path(self):
        """Open file dialog to select the game path."""
        directory = QFileDialog.getExistingDirectory(
            self, "Select Game Directory", self.game_path_edit.text()
        )
        if directory:
            self.game_path_edit.setText(directory)
    
    def _browse_projects_path(self):
        """Open file dialog to select the projects folder."""
        directory = QFileDialog.getExistingDirectory(
            self, "Select Projects Directory", self.projects_path_edit.text()
        )
        if directory:
            self.projects_path_edit.setText(directory)
    
    def _save_all(self) -> None:
        # Persist LLM settings
        from llm.settings import save_llm_settings, load_llm_settings, LLMSettings
        # Fill api_base from provider registry if available
        from llm.providers_registry import ProviderRegistry
        reg = ProviderRegistry(); reg.load()
        info = reg.provider_info(self.provider_combo.currentText()) or {}
        current_provider = self.provider_combo.currentText()
        # Load existing and update per-provider keys
        existing = load_llm_settings()
        provider_keys = existing.provider_keys or {}
        provider_keys[current_provider] = self.api_key_edit.text()
        s = LLMSettings(
            provider=current_provider,
            model=self.model_combo.currentText(),
            api_key=self.api_key_edit.text(),
            api_base=info.get("api_base"),
            provider_keys=provider_keys,
        )
        save_llm_settings(s)

        # Persist NPC generation settings to game/system config
        try:
            cfg_dir = get_config_dir()
            # system_config.json
            sys_path = os.path.join(cfg_dir, "system_config.json")
            sys_data = load_json(sys_path) or {}
            sys_data["npc_generation_mode"] = self.npc_mode_combo.currentText()
            save_json(sys_data, sys_path)
            # game_config.json
            game_path = os.path.join(cfg_dir, "game_config.json")
            game_data = load_json(game_path) or {}
            game_data["difficulty"] = self.npc_difficulty_combo.currentText()
            game_data["encounter_size"] = self.npc_encounter_combo.currentText()
            save_json(game_data, game_path)
        except Exception as e:
            logger.error(f"Failed to save NPC generation settings: {e}")

        self.accept()
    
    def get_settings(self) -> dict:
        """
        Get the settings selected by the user.
        
        Returns:
            A dictionary of settings.
        """
        return {
            "game_path": self.game_path_edit.text(),
            "projects_path": self.projects_path_edit.text(),
            "autosave": self.autosave_check.isChecked(),
            "autosave_interval": self.autosave_interval_spin.value(),
            "log_level": self.log_level_combo.currentText()
        }

```

### File: world_configurator\ui\dialogs\skill_selection_dialog.py

```python
# world_configurator/ui/dialogs/skill_selection_dialog.py
"""
Dialog for selecting skills from a filterable, sortable list.
"""

import logging
import os
import json
from typing import Any, List, Dict, Optional, Set

from PySide6.QtCore import Qt, QSortFilterProxyModel, QRegularExpression
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QListWidget,
    QListWidgetItem, QPushButton, QDialogButtonBox, QLabel, QMessageBox
)

from ui.dialogs.base_dialog import BaseDialog # Assuming base_dialog.py is in gui.dialogs
from utils.file_manager import get_project_root, load_json

logger = logging.getLogger("world_configurator.ui.skill_selection_dialog")

class SkillSortFilterProxyModel(QSortFilterProxyModel):
    """Proxy model for sorting and filtering skills."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.setFilterKeyColumn(0) # Assuming skill name is in the first (and only) column

    def filterAcceptsRow(self, source_row: int, source_parent: Any) -> bool:
        # Default behavior: if filter is set, check it.
        # We'll use QListWidget's built-in text filtering for simplicity first,
        # but this proxy could be used for more complex filtering if needed.
        # For now, let QListWidget handle filtering via textChanged signal.
        # This proxy is mainly for potential future sorting if QListWidget sorting isn't enough.
        # However, QListWidget.sortItems() is often sufficient.
        # Let's ensure it passes through if no filter is set from here.
        return super().filterAcceptsRow(source_row, source_parent)


class SkillSelectionDialog(BaseDialog):
    """
    A dialog that allows users to select skills from a list.
    The list is populated from skills.json, supports filtering, sorting,
    and pre-checks existing skills.
    """

    def __init__(self, parent: Optional[QWidget] = None, existing_skills: Optional[List[str]] = None):
        super().__init__(parent)
        self.setWindowTitle("Select Skill Proficiencies")
        self.setMinimumWidth(400)
        self.setMinimumHeight(500)

        self.all_skills: Dict[str, Dict[str, str]] = {} # Stores skill_id: {name, ...}
        self.selected_skill_names: Set[str] = set(existing_skills) if existing_skills else set()

        self._load_skills_data()
        self._setup_ui()
        self._populate_skill_list()

    def _load_skills_data(self):
        """Load skills from skills.json."""
        try:
            # Construct path to skills.json relative to project root
            # utils/file_manager.py -> gui/dialogs (2 levels up) -> project_root
            # config is a sibling of world_configurator
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
            skills_file_path = os.path.join(project_root, "config", "skills.json")

            if not os.path.exists(skills_file_path):
                logger.error(f"Skills file not found at: {skills_file_path}")
                QMessageBox.critical(self, "Error", f"Could not find skills.json at {skills_file_path}")
                return

            data = load_json(skills_file_path)
            if data and "skills" in data:
                # Store as skill_id: {name, description, ...}
                # The key in skills.json *is* the skill_id
                for skill_id, skill_data in data["skills"].items():
                    if "name" in skill_data:
                        self.all_skills[skill_id] = skill_data
                    else:
                        logger.warning(f"Skill entry '{skill_id}' missing 'name' field. Skipping.")
            else:
                logger.warning(f"No 'skills' key found or data is empty in {skills_file_path}")
        except Exception as e:
            logger.error(f"Error loading skills data: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An error occurred while loading skills: {str(e)}")


    def _setup_ui(self):
        """Set up the UI components."""
        layout = QVBoxLayout(self)

        # Filter
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Filter:"))
        self.filter_edit = QLineEdit()
        self.filter_edit.setPlaceholderText("Type to filter skills...")
        self.filter_edit.textChanged.connect(self._filter_skills)
        filter_layout.addWidget(self.filter_edit)
        layout.addLayout(filter_layout)

        # Sorting (simple buttons for now)
        sort_layout = QHBoxLayout()
        self.sort_asc_button = QPushButton("Sort A-Z")
        self.sort_asc_button.clicked.connect(lambda: self.skill_list_widget.sortItems(Qt.AscendingOrder))
        sort_layout.addWidget(self.sort_asc_button)

        self.sort_desc_button = QPushButton("Sort Z-A")
        self.sort_desc_button.clicked.connect(lambda: self.skill_list_widget.sortItems(Qt.DescendingOrder))
        sort_layout.addWidget(self.sort_desc_button)
        sort_layout.addStretch()
        layout.addLayout(sort_layout)

        # Skill list
        self.skill_list_widget = QListWidget()
        self.skill_list_widget.setSelectionMode(QListWidget.NoSelection) # Checkboxes handle selection
        layout.addWidget(self.skill_list_widget)

        # Buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _populate_skill_list(self):
        """Populate the skill list widget with checkboxes."""
        self.skill_list_widget.clear()
        # Sort by display name for initial population
        sorted_skill_ids = sorted(self.all_skills.keys(), key=lambda skill_id: self.all_skills[skill_id].get("name", skill_id))

        for skill_id in sorted_skill_ids:
            skill_data = self.all_skills[skill_id]
            display_name = skill_data.get("name", skill_id) # Use skill_id as fallback

            item = QListWidgetItem(display_name)
            item.setData(Qt.UserRole, skill_id) # Store the skill_id (key)
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)

            # Check if the skill (by name or ID) is in existing_skills
            # The Origin stores skill proficiencies by their name (e.g., "Diplomacy")
            if display_name in self.selected_skill_names or skill_id in self.selected_skill_names:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
            self.skill_list_widget.addItem(item)

    def _filter_skills(self, text: str):
        """Filter the skill list based on input text."""
        for i in range(self.skill_list_widget.count()):
            item = self.skill_list_widget.item(i)
            # Filter by display name
            if text.lower() in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def _on_accept(self):
        """Update the selected_skill_names set before accepting."""
        self.selected_skill_names.clear()
        for i in range(self.skill_list_widget.count()):
            item = self.skill_list_widget.item(i)
            if item.checkState() == Qt.Checked:
                # Return the display name, as this is what's stored in Origin.skill_proficiencies
                self.selected_skill_names.add(item.text())
        self.accept()

    def get_selected_skills(self) -> List[str]:
        """
        Return a list of the display names of the selected skills.
        This is called after the dialog is accepted.
        """
        return sorted(list(self.selected_skill_names))
```

### File: gui\dialogs\settings\__init__.py

```python
"""
Settings dialogs for the RPG game GUI.
This package provides dialogs for configuring game settings.
"""

from gui.dialogs.settings.llm_settings_dialog import LLMSettingsDialog
from gui.dialogs.settings.settings_dialog import SettingsDialog

__all__ = ['LLMSettingsDialog', 'SettingsDialog']

```

### File: gui\dialogs\settings\agent_setup_tab.py

```python
#!/usr/bin/env python3
"""
Agent setup tab for the RPG game GUI.
This module provides a tab for configuring which LLM provider and model to use for each agent.
"""

import logging
from typing import Dict, Any, List, Optional, Tuple
import json
import os

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QComboBox, QTableWidget, QTableWidgetItem, QHeaderView, QSpinBox,
    QDoubleSpinBox, QGroupBox, QDialog, QDialogButtonBox
)
from PySide6.QtCore import Qt, Signal

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.settings_manager import get_settings_manager

# Get the module logger
logger = logging.getLogger("GUI")

class AgentSetupDialog(QDialog):
    """Dialog for configuring an agent's LLM settings."""
    
    def __init__(self, parent=None, agent_name: str = "", agent_settings: Dict[str, Any] = None):
        """Initialize the dialog.
        
        Args:
            parent: Parent widget.
            agent_name: Name of the agent being configured.
            agent_settings: Current agent settings.
        """
        super().__init__(parent)
        
        self.agent_name = agent_name
        self.agent_settings = agent_settings or {}
        self.provider_manager = get_provider_manager()
        self.settings_manager = get_settings_manager()
        
        self.setWindowTitle(f"Configure {agent_name.capitalize()} Agent")
        self.setMinimumWidth(450)
        
        self._setup_ui()
        self._populate_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Form layout
        form_layout = QFormLayout()
        
        # Provider dropdown
        self.provider_combo = QComboBox()
        self._populate_providers()
        form_layout.addRow("Provider:", self.provider_combo)
        
        # Model dropdown
        self.model_combo = QComboBox()
        form_layout.addRow("Model:", self.model_combo)
        
        # Temperature setting
        self.temperature_spin = QDoubleSpinBox()
        self.temperature_spin.setRange(0.0, 1.0)
        self.temperature_spin.setSingleStep(0.1)
        self.temperature_spin.setDecimals(2)
        form_layout.addRow("Temperature:", self.temperature_spin)
        
        # Max tokens
        self.max_tokens_spin = QSpinBox()
        self.max_tokens_spin.setRange(100, 8000)
        self.max_tokens_spin.setSingleStep(100)
        form_layout.addRow("Max Tokens:", self.max_tokens_spin)
        
        # Timeout
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(10, 120)
        self.timeout_spin.setSingleStep(5)
        form_layout.addRow("Timeout (seconds):", self.timeout_spin)
        
        # Connect signals
        self.provider_combo.currentIndexChanged.connect(self._on_provider_changed)
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Add layouts
        layout.addLayout(form_layout)
        layout.addWidget(button_box)
    
    def _populate_providers(self):
        """Populate the providers dropdown."""
        self.provider_combo.clear()
        
        # Get available providers
        available_providers = self.provider_manager.get_available_providers()
        
        # Add each provider to the dropdown
        for provider in available_providers:
            self.provider_combo.addItem(provider.name.capitalize(), provider.name)
        
        # Add a placeholder if no providers are available
        if not available_providers:
            self.provider_combo.addItem("No providers available", "")
    
    def _on_provider_changed(self, index):
        """Handle provider selection change."""
        self.model_combo.clear()
        
        # Get selected provider type
        if index < 0:
            self.model_combo.addItem("Select a provider first", "")
            return
        
        provider_name = self.provider_combo.itemData(index)
        
        # Handle None or empty provider name
        if not provider_name:
            self.model_combo.addItem("Invalid provider", "")
            return
            
        try:
            provider_type = ProviderType[provider_name]
            
            # Get available models for this provider
            models = self.settings_manager.get_available_models(provider_type)
            
            # Add models to the dropdown
            for model in models:
                self.model_combo.addItem(model, model)
            
            # Add a placeholder if no models are available
            if not models:
                self.model_combo.addItem("No models available", "")
                
        except (KeyError, ValueError):
            logger.error(f"Invalid provider type: {provider_name}")
            self.model_combo.addItem("Error loading models", "")
    
    def _populate_settings(self):
        """Populate the dialog with current settings."""
        # Set provider
        provider_type_str = self.agent_settings.get("provider_type", "OPENAI")
        
        # Check if provider_type_str is None and provide a default
        if provider_type_str is None:
            provider_type_str = "OPENAI"
        
        for i in range(self.provider_combo.count()):
            if self.provider_combo.itemData(i) == provider_type_str:
                self.provider_combo.setCurrentIndex(i)
                break
        
        # Model will be populated by _on_provider_changed
        
        # Make sure to call provider change handler to populate the model dropdown
        self._on_provider_changed(self.provider_combo.currentIndex())
        
        # If we have a specific model, select it
        model = self.agent_settings.get("model", "")
        if model:
            for i in range(self.model_combo.count()):
                if self.model_combo.itemData(i) == model:
                    self.model_combo.setCurrentIndex(i)
                    break
        
        # Set other settings
        self.temperature_spin.setValue(self.agent_settings.get("temperature", 0.7))
        self.max_tokens_spin.setValue(self.agent_settings.get("max_tokens", 1000))
        self.timeout_spin.setValue(self.agent_settings.get("timeout_seconds", 30))
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the settings from the dialog.
        
        Returns:
            Dictionary of agent settings.
        """
        # Get provider type
        provider_index = self.provider_combo.currentIndex()
        provider_type_str = self.provider_combo.itemData(provider_index)
        
        # Get model
        model_index = self.model_combo.currentIndex()
        model = self.model_combo.itemData(model_index)
        
        # Build settings dictionary
        settings = {
            "provider_type": provider_type_str,
            "model": model,
            "temperature": self.temperature_spin.value(),
            "max_tokens": self.max_tokens_spin.value(),
            "timeout_seconds": self.timeout_spin.value(),
        }
        
        return settings


class AgentSetupTab(QWidget):
    """Tab for configuring agent LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the agent setup tab."""
        super().__init__(parent)
        
        self.settings_manager = get_settings_manager()
        self.provider_manager = get_provider_manager()
        
        # Store agent settings
        self.agent_settings = {}
        
        self._setup_ui()
        self._load_agent_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Description
        description = QLabel(
            "Configure which LLM provider and model to use for each agent in the game. "
            "Each agent can use a different provider and model configuration."
        )
        description.setWordWrap(True)
        layout.addWidget(description)
        
        # Agents table
        self.agents_table = QTableWidget()
        self.agents_table.setColumnCount(5)
        self.agents_table.setHorizontalHeaderLabels([
            "Agent", "Provider", "Model", "Temperature", "Configure"
        ])
        
        # Set table properties
        header = self.agents_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.Stretch)
        header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)
        
        layout.addWidget(self.agents_table)
    
    def _load_agent_settings(self):
        """Load agent settings and populate the table."""
        # Clear the table
        self.agents_table.setRowCount(0)
        
        # Get available agents
        agents = self.settings_manager.list_available_agents()
        
        # Populate table
        for i, agent_name in enumerate(agents):
            # Get agent settings
            settings = self.settings_manager.get_agent_settings(agent_name)
            self.agent_settings[agent_name] = settings
            
            # Add row
            self.agents_table.insertRow(i)
            
            # Agent name
            name_item = QTableWidgetItem(agent_name.capitalize())
            name_item.setFlags(name_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 0, name_item)
            
            # Provider
            provider_type_str = settings.get("provider_type", "OPENAI")
            # Check if provider_type_str is None and provide a default
            if provider_type_str is None:
                provider_type_str = "OPENAI"
            provider_item = QTableWidgetItem(provider_type_str.capitalize())
            provider_item.setFlags(provider_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 1, provider_item)
            
            # Model
            model = settings.get("model", "default")
            model_item = QTableWidgetItem(model)
            model_item.setFlags(model_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 2, model_item)
            
            # Temperature
            temp = settings.get("temperature", 0.7)
            temp_item = QTableWidgetItem(f"{temp:.2f}")
            temp_item.setFlags(temp_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 3, temp_item)
            
            # Configure button
            self.agents_table.setCellWidget(i, 4, self._create_configure_button(agent_name))
    
    def _create_configure_button(self, agent_name: str) -> QPushButton:
        """Create a configure button for an agent.
        
        Args:
            agent_name: Name of the agent.
            
        Returns:
            Configure button widget.
        """
        button = QPushButton("Configure")
        button.clicked.connect(lambda: self._configure_agent(agent_name))
        return button
    
    def _configure_agent(self, agent_name: str) -> None:
        """Open the agent configuration dialog.
        
        Args:
            agent_name: Name of the agent to configure.
        """
        # Get agent settings
        settings = self.agent_settings.get(agent_name, {})
        
        # Create and show the dialog
        dialog = AgentSetupDialog(self, agent_name, settings)
        
        if dialog.exec():
            # Get updated settings
            updated_settings = dialog.get_settings()
            
            # Update in-memory settings
            self.agent_settings[agent_name] = updated_settings
            
            # Save settings to disk
            success = self.settings_manager.update_agent_settings(agent_name, updated_settings)
            
            if success:
                logger.info(f"Updated settings for agent {agent_name}")
            else:
                logger.error(f"Failed to update settings for agent {agent_name}")
            
            # Reload table
            self._load_agent_settings()
    
    def save_settings(self) -> bool:
        """Save all agent settings.
        
        Returns:
            True if successful, False otherwise.
        """
        success = True
        
        for agent_name, settings in self.agent_settings.items():
            # Save settings to disk
            result = self.settings_manager.update_agent_settings(agent_name, settings)
            
            if not result:
                success = False
                logger.error(f"Failed to save settings for agent {agent_name}")
        
        return success

```

### File: gui\dialogs\settings\anthropic_tab.py

```python
#!/usr/bin/env python3
"""
Anthropic provider tab for the RPG game GUI.
This module provides a tab for configuring Anthropic LLM provider settings.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import QFormLayout
from PySide6.QtCore import Qt

from gui.dialogs.settings.llm_provider_tab import LLMProviderTab
from gui.dialogs.settings.model_management_widget import ModelManagementWidget
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = logging.getLogger("GUI")

class AnthropicTab(LLMProviderTab):
    """Tab for Anthropic settings."""
    
    def __init__(self, parent=None):
        """Initialize the Anthropic settings tab."""
        super().__init__(parent, provider_name="Anthropic")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.ANTHROPIC, "Anthropic")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("Anthropic's Claude models provide thoughtful, creative, and reliable AI assistant capabilities.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Set models in model manager
        self.model_manager.set_models(models)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings

```

### File: gui\dialogs\settings\background_tab.py

```python
#!/usr/bin/env python3
"""
Background selection tab for the settings dialog.
"""

import logging
import os
from typing import List, Optional, Tuple # Added Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize
from PySide6.QtGui import QPixmap, QMovie # Added QMovie

from gui.utils.resource_manager import get_resource_manager

logger = logging.getLogger(__name__)

class BackgroundTab(QWidget):
    """Widget for selecting the main window background."""

    # Signal emitted when the user previews a different background
    # Argument is the full filename of the background (e.g., 'my_bg.gif')
    preview_background_changed = Signal(str)

    def __init__(self, parent=None):
        """Initialize the background tab."""
        super().__init__(parent)

        self.resource_manager = get_resource_manager()
        self.backgrounds: List[Tuple[str, str]] = [] # Stores (name, ext) tuples
        self.current_index: int = -1
        # Default should ideally include extension, but resource manager might find it
        self.default_background_filename = "main_background.png"

        self._setup_ui()
        self._load_available_backgrounds()

    def _setup_ui(self):
        """Set up the user interface for the tab."""
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Preview Area
        preview_layout = QVBoxLayout()
        preview_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.preview_label = QLabel("Background Preview")
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_label.setMinimumSize(400, 225) # Aspect ratio 16:9
        self.preview_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.preview_label.setStyleSheet("border: 1px solid gray; background-color: #333;")
        preview_layout.addWidget(self.preview_label)

        self.name_label = QLabel("Background: N/A")
        self.name_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        preview_layout.addWidget(self.name_label)

        layout.addLayout(preview_layout)

        # Navigation Controls
        nav_layout = QHBoxLayout()
        nav_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.prev_button = QPushButton("< Prev")
        self.prev_button.clicked.connect(self._show_previous_background)
        self.prev_button.setFixedWidth(100)

        self.next_button = QPushButton("Next >")
        self.next_button.clicked.connect(self._show_next_background)
        self.next_button.setFixedWidth(100)

        nav_layout.addWidget(self.prev_button)
        nav_layout.addStretch()
        nav_layout.addWidget(self.next_button)

        layout.addLayout(nav_layout)
        layout.addStretch() # Push controls to the top

    def _load_available_backgrounds(self):
        """Load the list of available background image/animation names and extensions."""
        self.backgrounds = self.resource_manager.list_background_names()
        logger.info(f"Found backgrounds: {self.backgrounds}")
        if not self.backgrounds:
            logger.warning("No background images or GIFs found in images/gui/background/")
            self.prev_button.setEnabled(False)
            self.next_button.setEnabled(False)
        else:
            # Try to set initial index based on saved setting later in load_settings
            self.prev_button.setEnabled(len(self.backgrounds) > 1)
            self.next_button.setEnabled(len(self.backgrounds) > 1)

    def _update_preview(self):
        """Update the preview label with the current background (PNG or GIF)."""
        # Stop any existing movie
        current_movie = self.preview_label.movie()
        if current_movie:
            current_movie.stop()
            self.preview_label.setMovie(None) # Clear movie reference

        # Clear existing pixmap
        self.preview_label.setPixmap(QPixmap())

        if 0 <= self.current_index < len(self.backgrounds):
            name, ext = self.backgrounds[self.current_index]
            filename = f"{name}{ext}"
            self.name_label.setText(f"Background: {filename}")

            if ext.lower() == ".png":
                pixmap = self.resource_manager.get_background_pixmap(name)
                if not pixmap.isNull():
                    scaled_pixmap = pixmap.scaled(self.preview_label.size(),
                                                  Qt.AspectRatioMode.KeepAspectRatio,
                                                  Qt.TransformationMode.SmoothTransformation)
                    self.preview_label.setPixmap(scaled_pixmap)
                else:
                    self.preview_label.setText(f"Failed to load:\n{filename}")

            elif ext.lower() == ".gif":
                movie = self.resource_manager.get_background_movie(name)
                if movie.isValid():
                    self.preview_label.setMovie(movie)
                    # Scale movie if possible (QMovie doesn't scale directly like QPixmap)
                    # We might need to adjust label size policy or container layout
                    # For now, just set it and start
                    movie.setScaledSize(self.preview_label.size()) # Attempt scaling
                    movie.start()
                else:
                    self.preview_label.setText(f"Failed to load:\n{filename}")

            # Emit signal for live preview in main window with full filename
            self.preview_background_changed.emit(filename)
        else:
            self.name_label.setText("Background: N/A")
            self.preview_label.setText("No Background Selected")
            # Ensure both pixmap and movie are cleared
            self.preview_label.setPixmap(QPixmap())
            self.preview_label.setMovie(None)

    def _show_previous_background(self):
        """Navigate to the previous background image/animation."""
        if not self.backgrounds:
            return
        self.current_index = (self.current_index - 1) % len(self.backgrounds)
        self._update_preview()

    def _show_next_background(self):
        """Navigate to the next background image/animation."""
        if not self.backgrounds:
            return
        self.current_index = (self.current_index + 1) % len(self.backgrounds)
        self._update_preview()

    def load_settings(self, settings: QSettings):
        """Load the saved background setting (full filename). Defaults to first available if saved is invalid."""
        # Save/Load the full filename now, e.g., "my_background.gif"
        saved_filename = settings.value("style/background_filename", None)
        logger.info(f"Attempting to load background setting: '{saved_filename}'")

        self.current_index = -1 # Reset index

        if saved_filename:
            # Find the index corresponding to the saved filename
            found = False
            for i, (name, ext) in enumerate(self.backgrounds):
                if f"{name}{ext}" == saved_filename:
                    self.current_index = i
                    logger.info(f"Found saved background '{saved_filename}' at index {self.current_index}")
                    found = True
                    break
            if not found:
                 logger.warning(f"Saved background '{saved_filename}' not found in available list: {self.backgrounds}")
                 if self.backgrounds:
                     self.current_index = 0 # Fallback to first available
                     logger.info(f"Falling back to first available: '{self.backgrounds[self.current_index][0]}{self.backgrounds[self.current_index][1]}'")

        elif self.backgrounds:
            # No setting saved, use the first available
            self.current_index = 0
            logger.info(f"No background setting saved. Using first available: '{self.backgrounds[self.current_index][0]}{self.backgrounds[self.current_index][1]}'")
        else:
            # No setting saved and no backgrounds available
             logger.warning("No saved background setting and no backgrounds available.")
             self.current_index = -1

        # Update preview even if index is -1 (will show N/A)
        self._update_preview()

    def save_settings(self, settings: QSettings):
        """Save the currently selected background filename."""
        if 0 <= self.current_index < len(self.backgrounds):
            selected_name, selected_ext = self.backgrounds[self.current_index]
            selected_filename = f"{selected_name}{selected_ext}"
            settings.setValue("style/background_filename", selected_filename)
            logger.info(f"Saving background setting: '{selected_filename}'")
        else:
            # If somehow no valid index, try saving the default filename
            settings.setValue("style/background_filename", self.default_background_filename)
            logger.warning(f"No valid background selected, saving default filename: {self.default_background_filename}")
```

### File: gui\dialogs\settings\base_settings_dialog.py

```python
#!/usr/bin/env python3
"""
Base settings dialog for the RPG game GUI.
This module provides a base dialog class for settings dialogs.
"""

import os
import json
import logging
from typing import Dict, Any, Optional

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget, QWidget
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QIcon

# Get the module logger
logger = logging.getLogger("GUI")

class BaseSettingsDialog(QDialog):
    """Base dialog for settings dialogs."""
    
    # Signal emitted when settings are saved
    settings_saved = Signal()
    
    def __init__(self, parent=None, title="Settings"):
        """Initialize the base settings dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle(title)
        self.setMinimumWidth(700)
        self.setMinimumHeight(500)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QLineEdit, QComboBox, QSpinBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QComboBox:focus, QSpinBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QPushButton.danger {
                background-color: #D32F2F;
            }
            QPushButton.danger:hover {
                background-color: #F44336;
            }
            QPushButton.danger:pressed {
                background-color: #B71C1C;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #2D2D30;
            }
            QTabWidget::tab-bar {
                left: 5px;
            }
            QTabBar::tab {
                background-color: #333333;
                border: 1px solid #555555;
                border-bottom-color: #555555;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 10px;
                color: #CCCCCC;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #0E639C;
                color: white;
            }
            QTabBar::tab:!selected {
                margin-top: 2px;
            }
            QCheckBox {
                color: #E0E0E0;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 1px solid #555555;
                border-radius: 2px;
                background-color: #1E1E1E;
            }
            QCheckBox::indicator:checked {
                background-color: #0E639C;
                border-color: #0E639C;
            }
        """)
        
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(20, 20, 20, 20)
        self.main_layout.setSpacing(15)
        
        # Set up the bottom button layout
        self._setup_button_layout()
    
    def _setup_button_layout(self):
        """Set up the bottom button layout."""
        # Create bottom button layout
        self.button_layout = QHBoxLayout()
        self.button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create save button
        self.save_button = QPushButton("Save Settings")
        self.save_button.clicked.connect(self._on_save)
        
        # Add buttons to layout
        self.button_layout.addStretch()
        self.button_layout.addWidget(self.cancel_button)
        self.button_layout.addWidget(self.save_button)
    
    def add_button_layout(self):
        """Add the button layout to the main layout."""
        self.main_layout.addLayout(self.button_layout)
    
    def add_left_button(self, button):
        """Add a button to the left side of the button layout."""
        self.button_layout.insertWidget(0, button)
    
    def _on_save(self):
        """Handle save button click."""
        # Save settings
        if self.save_settings():
            # Emit signal
            self.settings_saved.emit()
            
            # Accept dialog
            self.accept()
    
    def save_settings(self) -> bool:
        """
        Save settings.
        
        This method should be implemented by subclasses.
        
        Returns:
            True if settings were saved successfully, False otherwise.
        """
        return True

```

### File: gui\dialogs\settings\llm_general_tab.py

```python
#!/usr/bin/env python3
"""
LLM general settings tab for the RPG game GUI.
This module provides a tab for configuring general LLM settings.
"""

import logging
from typing import Dict, Any

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QGroupBox, 
    QComboBox, QCheckBox, QSpinBox
)
from PySide6.QtCore import Qt

# Get the module logger
logger = logging.getLogger("GUI")

class LLMGeneralTab(QWidget):
    """Tab for general LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the general settings tab."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        
        # Create general settings group
        general_group = QGroupBox("General LLM Settings")
        general_layout = QFormLayout(general_group)
        general_layout.setFieldGrowthPolicy(QFormLayout.AllNonFixedFieldsGrow)
        
        # Create default provider setting
        self.default_provider_combo = QComboBox()
        self.default_provider_combo.addItem("OpenAI", "OPENAI")
        self.default_provider_combo.addItem("Google", "GOOGLE")
        self.default_provider_combo.addItem("OpenRouter", "OPENROUTER")
        general_layout.addRow("Default Provider:", self.default_provider_combo)
        
        # Create LLM toggle checkbox
        self.llm_enabled_check = QCheckBox("Enable LLM Processing")
        self.llm_enabled_check.setToolTip("Toggle LLM processing for game input")
        general_layout.addRow("", self.llm_enabled_check)
        
        # Create diagnostics at startup checkbox
        self.diagnostics_check = QCheckBox("Run diagnostics at startup")
        self.diagnostics_check.setToolTip("Test LLM connections when the application starts")
        general_layout.addRow("", self.diagnostics_check)
        
        # Create advanced settings group
        advanced_group = QGroupBox("Advanced Settings")
        advanced_layout = QFormLayout(advanced_group)
        
        # Create timeout setting
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(5, 120)
        self.timeout_spin.setSuffix(" seconds")
        self.timeout_spin.setToolTip("Maximum time to wait for LLM response")
        advanced_layout.addRow("Request Timeout:", self.timeout_spin)
        
        # Create retry attempts setting
        self.retry_spin = QSpinBox()
        self.retry_spin.setRange(1, 10)
        self.retry_spin.setToolTip("Number of retry attempts for failed requests")
        advanced_layout.addRow("Retry Attempts:", self.retry_spin)
        
        # Create retry delay setting
        self.retry_delay_spin = QSpinBox()
        self.retry_delay_spin.setRange(1, 30)
        self.retry_delay_spin.setSuffix(" seconds")
        self.retry_delay_spin.setToolTip("Delay between retry attempts")
        advanced_layout.addRow("Retry Delay:", self.retry_delay_spin)
        
        # Create temperature setting
        self.temperature_combo = QComboBox()
        self.temperature_combo.addItem("Low (0.3) - More focused, less creative", 0.3)
        self.temperature_combo.addItem("Medium (0.7) - Balanced", 0.7)
        self.temperature_combo.addItem("High (1.0) - More creative, less focused", 1.0)
        self.temperature_combo.setToolTip("Controls randomness of LLM responses")
        advanced_layout.addRow("Default Temperature:", self.temperature_combo)
        
        # Add groups to layout
        layout.addWidget(general_group)
        layout.addWidget(advanced_group)
        layout.addStretch(1)
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings.
        
        Args:
            settings: Dictionary with settings values
        """
        # Set provider type
        provider_type = settings.get("default_provider_type", "OPENAI")
        index = self.default_provider_combo.findData(provider_type)
        if index >= 0:
            self.default_provider_combo.setCurrentIndex(index)
        
        # Set checkboxes
        self.llm_enabled_check.setChecked(settings.get("llm_enabled", False))
        self.diagnostics_check.setChecked(settings.get("run_diagnostics_on_start", False))
        
        # Set spin boxes
        self.timeout_spin.setValue(settings.get("timeout_seconds", 30))
        self.retry_spin.setValue(settings.get("retry_attempts", 3))
        self.retry_delay_spin.setValue(settings.get("retry_delay_seconds", 2))
        
        # Set temperature combo
        temp = settings.get("default_temperature", 0.7)
        if temp <= 0.3:
            self.temperature_combo.setCurrentIndex(0)
        elif temp >= 1.0:
            self.temperature_combo.setCurrentIndex(2)
        else:
            self.temperature_combo.setCurrentIndex(1)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab.
        
        Returns:
            Dictionary with current settings values
        """
        return {
            "default_provider_type": self.default_provider_combo.currentData(),
            "default_temperature": self.temperature_combo.currentData(),
            "timeout_seconds": self.timeout_spin.value(),
            "retry_attempts": self.retry_spin.value(),
            "retry_delay_seconds": self.retry_delay_spin.value(),
            "run_diagnostics_on_start": self.diagnostics_check.isChecked(),
            "llm_enabled": self.llm_enabled_check.isChecked()
        }

```

### File: gui\dialogs\settings\llm_provider_tab.py

```python
#!/usr/bin/env python3
"""
LLM provider settings tab for the RPG game GUI.
This module provides a base tab for configuring LLM provider settings.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QGroupBox, 
    QLineEdit, QComboBox, QCheckBox, QLabel
)
from PySide6.QtCore import Qt

# Get the module logger
logger = logging.getLogger("GUI")

class LLMProviderTab(QWidget):
    """Base tab for provider LLM settings."""
    
    def __init__(self, parent=None, provider_name="Provider"):
        """Initialize the provider settings tab."""
        super().__init__(parent)
        
        # Provider properties
        self.provider_name = provider_name
        self.api_key_setting_name = "api_key"
        self.models = []  # Will be set by subclasses: List of (display_name, value) tuples
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(10)
        
        # Create API settings group
        api_group = QGroupBox(f"{self.provider_name} API Settings")
        api_layout = QFormLayout(api_group)
        
        # Create enabled checkbox
        self.enabled_check = QCheckBox(f"Enable {self.provider_name}")
        self.enabled_check.setToolTip(f"Enable/disable {self.provider_name} provider")
        self.enabled_check.toggled.connect(self._toggle_fields)
        api_layout.addRow("", self.enabled_check)
        
        # Create API key field
        self.api_key_edit = QLineEdit()
        self.api_key_edit.setPlaceholderText(f"Enter your {self.provider_name} API key")
        self.api_key_edit.setEchoMode(QLineEdit.Password)
        api_layout.addRow("API Key:", self.api_key_edit)
        
        # Add info section (to be overridden by subclasses)
        self.info_label = QLabel("")
        self.info_label.setWordWrap(True)
        self.info_label.setStyleSheet("color: #AAAAAA; font-style: italic;")
        
        # Add groups to layout
        self.main_layout.addWidget(api_group)
        self.main_layout.addWidget(self.info_label)
        self.main_layout.addStretch(1)
    
    def add_models(self, models: List[Tuple[str, str]]):
        """Store models data.
        
        Args:
            models: List of (display_name, value) tuples
        """
        self.models = models
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        self.api_key_edit.setEnabled(enabled)
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings.
        
        Args:
            settings: Dictionary with settings values
        """
        # Set enabled checkbox
        self.enabled_check.setChecked(settings.get("enabled", True))
        
        # Set API key
        self.api_key_edit.setText(settings.get(self.api_key_setting_name, ""))
        
        # Toggle fields based on enabled state
        self._toggle_fields(self.enabled_check.isChecked())
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab.
        
        Returns:
            Dictionary with current settings values
        """
        settings = {
            "enabled": self.enabled_check.isChecked(),
            self.api_key_setting_name: self.api_key_edit.text()
        }
        
        return settings

```

### File: gui\dialogs\settings\llm_settings_dialog.py

```python
#!/usr/bin/env python3
"""
LLM settings dialog for the RPG game GUI.
This module provides a dialog for configuring LLM settings.
"""

import os
import json
import logging
from typing import Dict, Any
import shutil
from datetime import datetime

from PySide6.QtWidgets import (
    QTabWidget, QMessageBox, QPushButton
)
from PySide6.QtCore import QSettings

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.llm_manager import get_llm_manager

from gui.dialogs.settings.base_settings_dialog import BaseSettingsDialog
from gui.dialogs.settings.llm_general_tab import LLMGeneralTab
from gui.dialogs.settings.provider_tabs import OpenAITab, GoogleTab, OpenRouterTab
from gui.dialogs.settings.anthropic_tab import AnthropicTab
from gui.dialogs.settings.agent_setup_tab import AgentSetupTab

# Get the module logger
logger = logging.getLogger("GUI")

class LLMSettingsDialog(BaseSettingsDialog):
    """Dialog for configuring LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the LLM settings dialog."""
        super().__init__(parent, title="LLM Settings")
        
        # Get provider manager
        self.provider_manager = get_provider_manager()
        
        # Get LLM manager
        self.llm_manager = get_llm_manager()

        # Get settings manager
        from core.llm.settings_manager import get_settings_manager # Add import if not already present
        self.settings_manager = get_settings_manager()

        # Load settings using SettingsManager
        self.provider_settings = self.settings_manager.get_provider_settings()
        self.base_settings = self.settings_manager.get_llm_settings() # Load base settings directly

        # Remove QSettings dependency entirely
        # self.qsettings = QSettings("RPG_Game", "LLM_Settings_Base")

        # Set up the UI
        self._setup_ui()
        
        # Populate the UI with settings
        self._populate_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create tab widget
        self.tab_widget = QTabWidget()
        
        # Create tabs
        self.general_tab = LLMGeneralTab()
        self.openai_tab = OpenAITab()
        self.google_tab = GoogleTab()
        self.anthropic_tab = AnthropicTab()
        self.openrouter_tab = OpenRouterTab()
        self.agent_setup_tab = AgentSetupTab()
        
        # Add tabs to widget
        self.tab_widget.addTab(self.general_tab, "General")
        self.tab_widget.addTab(self.openai_tab, "OpenAI")
        self.tab_widget.addTab(self.google_tab, "Google")
        self.tab_widget.addTab(self.anthropic_tab, "Anthropic")
        self.tab_widget.addTab(self.openrouter_tab, "OpenRouter")
        self.tab_widget.addTab(self.agent_setup_tab, "Agent Setup")
        
        # Add tab widget to main layout
        self.main_layout.addWidget(self.tab_widget)
        
        # Create reset button
        self.reset_button = QPushButton("Reset to Default")
        self.reset_button.setStyleSheet("QPushButton { background-color: #D32F2F; }")
        self.reset_button.clicked.connect(self._reset_settings)
        
        # Create test button
        self.test_button = QPushButton("Test Connections")
        self.test_button.clicked.connect(self._test_connections)
        
        # Add buttons to left side
        self.add_left_button(self.test_button)
        self.add_left_button(self.reset_button)
        
        # Add button layout
        self.add_button_layout()

    # _load_provider_settings method removed - SettingsManager handles loading in __init__
    # _load_base_settings method definition removed below

    def _populate_settings(self):
        """Populate the UI with current settings."""
        # Always refresh settings from disk because model widgets may seed defaults on init
        self.provider_settings = self.settings_manager.get_provider_settings()
        self.base_settings = self.settings_manager.get_llm_settings()

        # Populate general settings
        self.general_tab.set_settings(self.base_settings)
        
        # Populate provider settings (freshly loaded)
        self.openai_tab.set_settings(self.provider_settings.get("openai", {}))
        self.google_tab.set_settings(self.provider_settings.get("google", {}))
        self.anthropic_tab.set_settings(self.provider_settings.get("anthropic", {}))
        self.openrouter_tab.set_settings(self.provider_settings.get("openrouter", {}))
    
    def _reset_settings(self):
        """Reset settings to default."""
        # Ask for confirmation
        result = QMessageBox.question(
            self, 
            "Reset Settings", 
            "Are you sure you want to reset all LLM settings to default?\n\nThis will remove all API keys and custom configurations.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        try:
            # --- Removed QSettings clear ---
            # self.qsettings.clear()

            # Reset config files
            config_dir = os.path.join("config", "llm")
            
            # Create backup of current config
            backup_dir = os.path.join(config_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Backup providers.json if it exists
            providers_file = os.path.join(config_dir, "providers.json")
            if os.path.exists(providers_file):
                backup_file = os.path.join(backup_dir, f"providers_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
                shutil.copy2(providers_file, backup_file)
                logger.info(f"Backed up providers.json to {backup_file}")
            
            # Backup base_config.json if it exists
            base_file = os.path.join(config_dir, "base_config.json")
            if os.path.exists(base_file):
                backup_file = os.path.join(backup_dir, f"base_config_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
                shutil.copy2(base_file, backup_file)
                logger.info(f"Backed up base_config.json to {backup_file}")
            
            # Create default provider settings file
            default_providers = {
                "openai": {
                    "api_key": "",
                    "organization": "",
                    "api_base": "https://api.openai.com/v1",
                    "default_model": "gpt-4o-mini",
                    "available_models": [
                        "gpt-4.1-nano",
                        "gpt-4.1-mini",
                        "gpt-4.1",
                        "gpt-5-mini",
                        "gpt-4o",
                        "gpt-4o-mini"
                    ],
                    "enabled": True
                },
                "google": {
                    "api_key": "",
                    "default_model": "gemini-2.0-flash",
                    "available_models": [
                        "gemini-2.5-flash-preview-05-20",
                        "gemini-2.5-flash",
                        "gemini-2.0-flash",
                        "gemini-2.0-flash-lite"
                    ],
                    "enabled": True
                },
                "openrouter": {
                    "api_key": "",
                    "api_base": "https://openrouter.ai/api/v1",
                    "default_model": "mistralai/mistral-small-3.1-24b-instruct:free",
                    "available_models": [
                        "deepseek/deepseek-v3-base:free",
                        "google/gemini-2.5-pro-exp-03-25:free",
                        "meta-llama/llama-4-maverick:free",
                        "deepseek/deepseek-r1-0528:free",
                        "mistralai/mistral-small-3.1-24b-instruct:free",
                        "meta-llama/llama-4-scout:free",
                        "nvidia/llama-3.1-nemotron-nano-8b-v1:free",
                        "openrouter/quasar-alpha:free",
                        "moonshotai/kimi-vl-a3b-thinking:free",
                        "qwen/qwen2.5-vl-3b-instruct:free"
                    ],
                    "enabled": True
                },
                "anthropic": {
                    "api_key": "",
                    "api_base": "https://api.anthropic.com",
                    "default_model": "claude-3-5-haiku-latest",
                    "available_models": [
                        "claude-3-5-haiku-latest",
                        "claude-3-7-sonnet-latest",
                        "claude-sonnet-4-20250514-v1:0"
                    ],
                    "enabled": True
                }
            }

            with open(providers_file, 'w', encoding='utf-8') as f:
                json.dump(default_providers, f, indent=4)
            
            # Create default base settings file
            default_base = {
                "default_provider_type": "OPENAI",
                "default_temperature": 0.7,
                "timeout_seconds": 30,
                "retry_attempts": 3,
                "retry_delay_seconds": 2,
                "run_diagnostics_on_start": False,
                "log_prompts": True,
                "log_completions": True,
                "cost_tracking_enabled": True
            }
            
            with open(base_file, 'w', encoding='utf-8') as f:
                json.dump(default_base, f, indent=4)

            # Reload settings using SettingsManager
            self.provider_settings = self.settings_manager.get_provider_settings()
            self.base_settings = self.settings_manager.get_llm_settings()

            # Repopulate UI
            self._populate_settings()
            
            # Show success message
            QMessageBox.information(
                self,
                "Settings Reset",
                "LLM settings have been reset to default values.\nPrevious settings were backed up in the config/llm/backup directory."
            )
            
        except Exception as e:
            logger.error(f"Error resetting settings: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred while resetting settings: {str(e)}"
            )
    
    def _test_connections(self):
        """Test LLM connections."""
        try:
            # Save current settings temporarily
            self.save_settings(show_success=False)
            
            # Reinitialize provider manager
            self.provider_manager = get_provider_manager()
            
            # Run diagnostics
            diagnostics = self.llm_manager.run_llm_diagnostics()
            
            # Build results message
            message = f"LLM Diagnostics: {diagnostics['status']}\n\n"
            
            for provider_name, provider_result in diagnostics.get("providers", {}).items():
                status = provider_result.get("status", "unknown")
                status_text = "✓ Success" if status == "success" else "✗ Failed"
                
                message += f"{provider_name}: {status_text}\n"
                
                if status == "success":
                    model = provider_result.get("model", "unknown")
                    message += f"  Model: {model}\n"
                    message += f"  Response: {provider_result.get('response_content', '')[:50]}...\n"
                else:
                    message += f"  Error: {provider_result.get('error', 'Unknown error')}\n"
                
                message += "\n"
            
            # Show results
            QMessageBox.information(
                self,
                "Connection Test Results",
                message
            )
            
        except Exception as e:
            logger.error(f"Error testing connections: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred while testing connections: {str(e)}"
            )
    
    def save_settings(self, show_success=True) -> bool:
        """Save settings to configuration files and QSettings.
        
        Args:
            show_success: Whether to show a success message
            
        Returns:
            True if settings were saved successfully, False otherwise
        """
        try:
            # Get settings from UI
            
            # Get settings from UI
            base_settings = self.general_tab.get_settings()
            
            # Get provider settings
            provider_settings = {
                "openai": self.openai_tab.get_settings(),
                "anthropic": self.anthropic_tab.get_settings(),
                "google": self.google_tab.get_settings(),
                "openrouter": self.openrouter_tab.get_settings()
            }
            
            # Save agent settings (This saves agent JSON files via SettingsManager)
            self.agent_setup_tab.save_settings()

            # --- Removed saving provider settings to QSettings ---
            # Provider settings are now saved directly to providers.json
            # by the ModelManagementWidget and provider tabs via SettingsManager.
            # The loop below updates the ProviderManager instance, which relies
            # on SettingsManager having already saved the JSON.

            # Save base settings using SettingsManager
            if self.settings_manager.update_llm_settings(base_settings):
                logger.info("Successfully saved base LLM settings to JSON.")
            else:
                logger.error("Failed to save base LLM settings to JSON.")
                # Optionally raise an error or show a specific message

            # --- Removed saving base settings to QSettings ---
            # self.qsettings.beginGroup("base")
            # for key, value in base_settings.items():
            #     self.qsettings.setValue(key, value)
            # self.qsettings.endGroup()

            # Update provider manager (This updates the in-memory state of the manager)
            for provider_type_name, provider_name in [
                (ProviderType.OPENAI, "openai"),
                (ProviderType.GOOGLE, "google"),
                (ProviderType.OPENROUTER, "openrouter")
            ]:
                # Update provider settings
                if provider_name in provider_settings:
                    self.provider_manager.update_provider_settings(
                        provider_type_name, 
                        provider_settings[provider_name]
                    )
            
            # Set LLM enabled state (if explicitly toggled)
            from core.base.engine import get_game_engine
            engine = get_game_engine()
            if "llm_enabled" in base_settings:
                engine.set_llm_enabled(base_settings["llm_enabled"])
            
            # Ensure live agents pick up new provider/model settings immediately
            try:
                engine.reload_llm_settings()
            except Exception as e:
                logger.error(f"Error reloading LLM agent settings: {e}")
            
            # Show success message
            if show_success:
                QMessageBox.information(
                    self,
                    "Settings Saved",
                    "LLM settings have been saved successfully."
                )
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving settings: {e}")
            
            if show_success:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"An error occurred while saving settings: {str(e)}"
                )
            
            return False


# For testing
if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication
    from core.utils.logging_config import setup_logging
    
    # Set up logging
    setup_logging()
    
    # Create application
    app = QApplication(sys.argv)
    
    # Create dialog
    dialog = LLMSettingsDialog()
    
    # Show dialog
    dialog.exec()

```

### File: gui\dialogs\settings\model_management_widget.py

```python
#!/usr/bin/env python3
"""
Model management widget for LLM settings.

This module provides a widget for adding, removing, and modifying
available LLM models for each provider.
"""

import logging
import os
import json
from typing import List, Dict, Any, Callable, Optional, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QDialog, QFormLayout,
    QDialogButtonBox, QGroupBox
)
from PySide6.QtCore import Qt, Signal

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.settings_manager import get_settings_manager

# Get the module logger
logger = logging.getLogger("GUI")

class AddEditModelDialog(QDialog):
    """Dialog for adding or editing a model."""
    
    def __init__(self, parent=None, edit_data: Optional[Tuple[str, str]] = None):
        """Initialize the dialog.
        
        Args:
            parent: Parent widget.
            edit_data: Tuple of (display_name, model_id) if editing, None if adding.
        """
        super().__init__(parent)
        
        self.edit_data = edit_data
        self.setWindowTitle("Add Model" if not edit_data else "Edit Model")
        self.setMinimumWidth(350)
        
        self._setup_ui()
        
        if edit_data:
            self._populate_edit_data(edit_data)
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Form layout for inputs
        form_layout = QFormLayout()
        
        # Model display name field
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Display name shown in UI")
        form_layout.addRow("Display Name:", self.name_edit)
        
        # Model ID/Value field
        self.value_edit = QLineEdit()
        self.value_edit.setPlaceholderText("Actual model ID/name used in API calls")
        form_layout.addRow("Model ID:", self.value_edit)
        
        # Add help text
        help_label = QLabel(
            "Note: Model ID should match the exact identifier expected by the API. "
            "For example: 'gpt-4o' for OpenAI or 'gemini-2.0-flash' for Google."
        )
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Add layouts to main layout
        layout.addLayout(form_layout)
        layout.addWidget(help_label)
        layout.addWidget(button_box)
    
    def _populate_edit_data(self, edit_data: Tuple[str, str]):
        """Populate the dialog with data for editing."""
        display_name, model_id = edit_data
        self.name_edit.setText(display_name)
        self.value_edit.setText(model_id)
    
    def get_model_data(self) -> Tuple[str, str]:
        """Get the model data entered by the user.
        
        Returns:
            Tuple of (display_name, model_id).
        """
        return (self.name_edit.text(), self.value_edit.text())


class ModelManagementWidget(QWidget):
    """Widget for managing LLM models for a provider."""
    
    # Signal emitted when models are updated
    models_updated = Signal(list)  # List of (display_name, model_id) tuples
    
    def __init__(self, parent=None, provider_type: ProviderType = None, provider_name: str = "Provider"):
        """Initialize the widget.
        
        Args:
            parent: Parent widget.
            provider_type: The type of provider.
            provider_name: Human-readable name of the provider.
        """
        super().__init__(parent)
        
        self.provider_type = provider_type
        self.provider_name = provider_name
        self.settings_manager = get_settings_manager()
        self.provider_manager = get_provider_manager()
        
        # Current models list [(display_name, model_id), ...]
        self.models = []
        
        self._setup_ui()
        self._load_models()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Main layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Group box
        group_box = QGroupBox(f"{self.provider_name} Models")
        group_layout = QVBoxLayout(group_box)
        
        # Description
        description = QLabel(f"Manage available models for {self.provider_name}:")
        description.setWordWrap(True)
        group_layout.addWidget(description)
        
        # List and buttons layout
        list_buttons_layout = QHBoxLayout()
        
        # Model list
        self.model_list = QListWidget()
        self.model_list.setMinimumHeight(150)
        self.model_list.itemSelectionChanged.connect(self._handle_selection_changed)
        list_buttons_layout.addWidget(self.model_list)
        
        # Buttons layout
        buttons_layout = QVBoxLayout()
        
        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self._handle_add)
        
        self.edit_button = QPushButton("Edit")
        self.edit_button.clicked.connect(self._handle_edit)
        self.edit_button.setEnabled(False)
        
        self.remove_button = QPushButton("Remove")
        self.remove_button.clicked.connect(self._handle_remove)
        self.remove_button.setEnabled(False)
        
        self.set_default_button = QPushButton("Set Default")
        self.set_default_button.clicked.connect(self._handle_set_default)
        self.set_default_button.setEnabled(False)
        
        buttons_layout.addWidget(self.add_button)
        buttons_layout.addWidget(self.edit_button)
        buttons_layout.addWidget(self.remove_button)
        buttons_layout.addWidget(self.set_default_button)
        buttons_layout.addStretch()
        
        list_buttons_layout.addLayout(buttons_layout)
        
        # Default model info
        self.default_model_label = QLabel("Default model: None")
        
        # Add widgets to layout
        group_layout.addLayout(list_buttons_layout)
        group_layout.addWidget(self.default_model_label)
        
        # Add group box to main layout
        layout.addWidget(group_box)
    
    def _load_models(self):
        """Load models from settings."""
        if not self.provider_type:
            return
        
        # Get provider settings
        settings = self.settings_manager.get_provider_settings(self.provider_type)
        available_models = settings.get("available_models", [])
        default_model = settings.get("default_model", "")

        # Seed from master models if empty/missing
        if not available_models:
            try:
                master_path = os.path.join("config", "llm", "models.json")
                if os.path.exists(master_path):
                    with open(master_path, "r", encoding="utf-8") as f:
                        master = json.load(f)
                    provider_map = {
                        ProviderType.OPENAI: "openai",
                        ProviderType.GOOGLE: "google",
                        ProviderType.OPENROUTER: "openrouter",
                        ProviderType.ANTHROPIC: "anthropic"
                    }
                    key = provider_map.get(self.provider_type)
                    if key and key in master:
                        seed = [m.get("id") for m in master[key] if isinstance(m, dict) and m.get("id")]
                        if seed:
                            available_models = seed
                            # Persist the seed so it sticks
                            self.settings_manager.update_provider_settings(
                                self.provider_type, {"available_models": available_models}
                            )
                            logger.info(f"Seeded {self.provider_name} models from master list: {len(seed)} items")
            except Exception as e:
                logger.warning(f"Could not seed models from master list: {e}")
        
        # Clear current models
        self.models = []
        self.model_list.clear()
        
        # Simple case: just model IDs in the list
        if all(isinstance(model, str) for model in available_models):
            for model_id in available_models:
                # Use the model ID as display name too
                self.models.append((model_id, model_id))
                item = QListWidgetItem(model_id)
                item.setData(Qt.UserRole, model_id)
                self.model_list.addItem(item)
        
        # Update default model label
        if default_model:
            self.default_model_label.setText(f"Default model: {default_model}")
        else:
            self.default_model_label.setText("Default model: None")
    
    def _handle_selection_changed(self):
        """Handle selection change in the model list."""
        selected = self.model_list.selectedItems()
        has_selection = len(selected) > 0
        
        self.edit_button.setEnabled(has_selection)
        self.remove_button.setEnabled(has_selection)
        self.set_default_button.setEnabled(has_selection)
    
    def _handle_add(self):
        """Handle add button click."""
        dialog = AddEditModelDialog(self)
        if dialog.exec():
            display_name, model_id = dialog.get_model_data()
            
            # Validate input
            if not display_name or not model_id:
                QMessageBox.warning(self, "Invalid Input", "Both display name and model ID are required.")
                return
            
            # Check for duplicates
            for _, existing_id in self.models:
                if existing_id == model_id:
                    QMessageBox.warning(
                        self, 
                        "Duplicate Model", 
                        f"A model with ID '{model_id}' already exists."
                    )
                    return
            
            # Add to list
            self.models.append((display_name, model_id))
            item = QListWidgetItem(display_name)
            item.setData(Qt.UserRole, model_id)
            self.model_list.addItem(item)
            
            # Update settings
            self._save_models()
    
    def _handle_edit(self):
        """Handle edit button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        display_name = item.text()
        model_id = item.data(Qt.UserRole)
        
        dialog = AddEditModelDialog(self, (display_name, model_id))
        if dialog.exec():
            new_display_name, new_model_id = dialog.get_model_data()
            
            # Validate input
            if not new_display_name or not new_model_id:
                QMessageBox.warning(self, "Invalid Input", "Both display name and model ID are required.")
                return
            
            # Check for duplicates if model ID changed
            if new_model_id != model_id:
                for _, existing_id in self.models:
                    if existing_id == new_model_id:
                        QMessageBox.warning(
                            self, 
                            "Duplicate Model", 
                            f"A model with ID '{new_model_id}' already exists."
                        )
                        return
            
            # Update list
            index = self.model_list.row(item)
            self.models[index] = (new_display_name, new_model_id)
            
            item.setText(new_display_name)
            item.setData(Qt.UserRole, new_model_id)
            
            # Update settings
            self._save_models()
    
    def _handle_remove(self):
        """Handle remove button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        display_name = item.text()
        model_id = item.data(Qt.UserRole)
        
        # Confirm removal
        result = QMessageBox.question(
            self,
            "Remove Model",
            f"Are you sure you want to remove the model '{display_name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Check if it's the default model
        provider_settings = self.settings_manager.get_provider_settings(self.provider_type)
        default_model = provider_settings.get("default_model", "")
        
        if model_id == default_model:
            result = QMessageBox.question(
                self,
                "Remove Default Model",
                f"This model is currently set as the default model. "
                f"If you remove it, you'll need to select a new default model. "
                f"Do you want to continue?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if result != QMessageBox.Yes:
                return
        
        # Remove from list
        index = self.model_list.row(item)
        self.model_list.takeItem(index)
        self.models.pop(index)
        
        # Update settings
        self._save_models()
        
        # Reset default model if needed
        if model_id == default_model and self.models:
            self._set_default_model(self.models[0][1])  # Use first model as default
    
    def _handle_set_default(self):
        """Handle set default button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        model_id = item.data(Qt.UserRole)
        
        self._set_default_model(model_id)
    
    def _set_default_model(self, model_id: str):
        """Set the default model.
        
        Args:
            model_id: The model ID to set as default.
        """
        if not self.provider_type:
            return
        
        # Update settings
        self.settings_manager.update_provider_settings(
            self.provider_type,
            {"default_model": model_id}
        )
        
        # Update UI
        self.default_model_label.setText(f"Default model: {model_id}")
        
        logger.info(f"Set default model for {self.provider_name} to {model_id}")
    
    def _save_models(self):
        """Save the current models to settings."""
        if not self.provider_type:
            return
        
        # Extract model IDs
        model_ids = [model_id for _, model_id in self.models]
        
        # Update settings
        self.settings_manager.update_provider_settings(
            self.provider_type,
            {"available_models": model_ids}
        )
        
        # Emit signal
        self.models_updated.emit(self.models)
        
        logger.info(f"Updated models for {self.provider_name}: {model_ids}")
    
    def set_models(self, models: List[Tuple[str, str]]):
        """Set the models list.
        
        Args:
            models: List of (display_name, model_id) tuples.
        """
        self.models = models.copy()
        self.model_list.clear()
        
        for display_name, model_id in self.models:
            item = QListWidgetItem(display_name)
            item.setData(Qt.UserRole, model_id)
            self.model_list.addItem(item)
        
        # Notify listeners so parent tabs keep their internal state in sync
        self.models_updated.emit(self.models)

```

### File: gui\dialogs\settings\provider_tabs.py

```python
#!/usr/bin/env python3
"""
LLM provider-specific tabs for the RPG game GUI.
This module provides tabs for different LLM providers.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import (
    QFormLayout, QLineEdit, QLabel, QVBoxLayout
)
from PySide6.QtCore import Qt

from gui.dialogs.settings.llm_provider_tab import LLMProviderTab
from gui.dialogs.settings.model_management_widget import ModelManagementWidget
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = logging.getLogger("GUI")

class OpenAITab(LLMProviderTab):
    """Tab for OpenAI settings."""
    
    def __init__(self, parent=None):
        """Initialize the OpenAI settings tab."""
        super().__init__(parent, provider_name="OpenAI")
        
        # Add OpenAI specific properties
        self.api_key_setting_name = "api_key"
        
        # Add OpenAI specific fields
        form_layout = self.findChild(QFormLayout)
        
        # Organization field
        self.org_edit = QLineEdit()
        self.org_edit.setPlaceholderText("Organization ID (optional)")
        form_layout.insertRow(2, "Organization:", self.org_edit)
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.OPENAI, "OpenAI")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("OpenAI's GPT models are powerful general-purpose models with varying capabilities.")
        
        # Connect signals
        self.enabled_check.toggled.connect(self._toggle_openai_fields)
    
    def _toggle_openai_fields(self, enabled: bool):
        """Toggle OpenAI-specific fields."""
        self.org_edit.setEnabled(enabled)
        self.model_manager.setEnabled(enabled)
        
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set OpenAI-specific settings
        self.org_edit.setText(settings.get("organization", ""))
        self.org_edit.setEnabled(self.enabled_check.isChecked())
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Keep the tab's internal model list in sync so saving doesn't wipe it
        self.models = models
        
        # Set models in model manager
        self.model_manager.set_models(models)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add OpenAI-specific settings
        settings["organization"] = self.org_edit.text()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings


class GoogleTab(LLMProviderTab):
    """Tab for Google settings."""
    
    def __init__(self, parent=None):
        """Initialize the Google settings tab."""
        super().__init__(parent, provider_name="Google AI")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.GOOGLE, "Google AI")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("Google's Gemini models provide strong multilingual capabilities and state-of-the-art performance.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Keep the tab's internal model list in sync so saving doesn't wipe it
        self.models = models
        
        # Set models in model manager
        self.model_manager.set_models(models)
        
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings


class OpenRouterTab(LLMProviderTab):
    """Tab for OpenRouter settings."""
    
    def __init__(self, parent=None):
        """Initialize the OpenRouter settings tab."""
        super().__init__(parent, provider_name="OpenRouter")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.OPENROUTER, "OpenRouter")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("OpenRouter allows access to multiple AI models from different providers through a single API. Create an account at openrouter.ai to get started.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Keep the tab's internal model list in sync so saving doesn't wipe it
        self.models = models
        
        # Set models in model manager
        self.model_manager.set_models(models)
        
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings

```

### File: gui\dialogs\settings\settings_dialog.py

```python
# --- START OF FILE settings_dialog.py ---

#!/usr/bin/env python3
"""
Settings dialog for the RPG game GUI.
This module provides a dialog for configuring game settings.
"""

import logging
import json
import os
from typing import Dict, Any
from core.base.config import get_config

from gui.dialogs.base_dialog import BaseDialog
from gui.dialogs.settings.style_tab import StyleTab
from gui.dialogs.settings.background_tab import BackgroundTab 

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox,
    QPushButton, QTabWidget, QWidget, QFormLayout,
    QCheckBox, QSpinBox, QGroupBox, QRadioButton, QButtonGroup,
    QSlider 
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize, Slot
from PySide6.QtGui import QColor 

class SettingsDialog(BaseDialog):
    """Dialog for configuring game settings."""

    # Signal emitted when settings are saved
    settings_saved = Signal()

    # Signal emitted when a background preview is requested by the BackgroundTab
    background_preview_requested = Signal(str)

    def __init__(self, parent=None):
        """Initialize the settings dialog."""
        super().__init__(parent)


        # # --- ADDED: Ensure dialog has a default background --- 
        # self.setAutoFillBackground(True)
        # palette = self.palette()
        # # Use a light color that usually contrasts well with default black text
        # palette.setColor(self.backgroundRole(), QColor("#F0F0F0")) 
        # self.setPalette(palette)
        # # --- END ADDED --- 

        # Set dialog properties
        self.setWindowTitle("Game Settings")
        self.setMinimumWidth(500)

        # Load current settings
        self.settings = QSettings("RPGGame", "Settings")

        # Set up the UI
        self._setup_ui()

        # Load settings into the UI
        self._load_settings()

    def _setup_ui(self):
        """Set up the user interface."""
        # Create main layout
        layout = QVBoxLayout(self)

        # Create tab widget for settings categories
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget::pane { /* The area where tab pages are displayed */
                border: 1px solid #555555;
                background-color: #2D2D30; /* Dark background for the content pane */
                border-top: 1px solid #555555; /* Ensure top border is visible */
            }
            QTabBar::tab { /* Style for individual tabs */
                background-color: #333333; /* Dark background for non-selected tabs */
                color: #CCCCCC; /* Light text for non-selected tabs */
                border: 1px solid #555555;
                border-bottom: none; /* Remove bottom border for non-selected tabs */
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 12px; /* Adjusted padding */
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2D2D30; /* Match pane background for selected tab */
                color: #E0E0E0; /* Brighter text for selected tab */
                border-bottom: 1px solid #2D2D30; /* Blend selected tab with pane */
            }
            QTabBar::tab:!selected:hover {
                background-color: #454545; /* Slightly lighter for hover on non-selected tabs */
            }
            QTabWidget QWidget { /* Ensure widgets inside tabs also have transparent background if needed */
                 background-color: transparent; /* Or match #2D2D30 if transparency causes issues */
            }
        """)

        # Set up tabs
        self._setup_display_tab()
        self._setup_sound_tab()
        self._setup_gameplay_tab()
        self._setup_style_tab()
        self._setup_background_tab()

        # Add tab widget to layout
        layout.addWidget(self.tab_widget)

        # Create button box
        button_layout = QHBoxLayout()

        # Save button
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self._save_settings)

        # Cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)

        # Add buttons to layout
        button_layout.addStretch()
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.cancel_button)

        # Add button layout to main layout
        layout.addLayout(button_layout)

    def _setup_display_tab(self):
        """Set up the display settings tab."""
        # Create display tab
        display_tab = QWidget()
        display_layout = QVBoxLayout(display_tab)

        # Create form layout for settings
        form_layout = QFormLayout()

        # --- Window Mode Setting ---
        display_mode_group = QGroupBox("Display Mode")
        display_mode_layout = QVBoxLayout(display_mode_group)
        self.display_mode_group = QButtonGroup(self) # Group for radio buttons

        self.windowed_radio = QRadioButton("Windowed")
        self.windowed_fullscreen_radio = QRadioButton("Windowed Fullscreen (Maximized)")
        self.fullscreen_radio = QRadioButton("Fullscreen")

        self.display_mode_group.addButton(self.windowed_radio, 0)
        self.display_mode_group.addButton(self.windowed_fullscreen_radio, 1)
        self.display_mode_group.addButton(self.fullscreen_radio, 2)

        display_mode_layout.addWidget(self.windowed_radio)
        display_mode_layout.addWidget(self.windowed_fullscreen_radio)
        display_mode_layout.addWidget(self.fullscreen_radio)

        # --- Resolution Setting (Enabled only for Windowed) ---
        resolution_layout = QHBoxLayout()
        self.resolution_label = QLabel("Resolution (Windowed):") # Label clarifies when it applies
        self.resolution_combo = QComboBox()
        self.resolution_combo.addItem("800x600", QSize(800, 600))
        self.resolution_combo.addItem("1024x768", QSize(1024, 768))
        self.resolution_combo.addItem("1280x720", QSize(1280, 720))
        self.resolution_combo.addItem("1366x768", QSize(1366, 768))
        self.resolution_combo.addItem("1600x900", QSize(1600, 900))
        self.resolution_combo.addItem("1920x1080", QSize(1920, 1080))
        # Add more resolutions if needed
        resolution_layout.addWidget(self.resolution_label)
        resolution_layout.addWidget(self.resolution_combo)

        # Connect radio button toggle to enable/disable resolution combo
        self.windowed_radio.toggled.connect(self._update_resolution_state)

        # Add display mode and resolution to the form layout
        display_layout.addWidget(display_mode_group)
        display_layout.addLayout(resolution_layout) # Add the HBox layout

        # --- UI Scale Setting ---
        self.ui_scale_combo = QComboBox()
        self.ui_scale_combo.addItem("100%", 1.0)
        self.ui_scale_combo.addItem("125%", 1.25)
        self.ui_scale_combo.addItem("150%", 1.5)
        self.ui_scale_combo.addItem("175%", 1.75)
        self.ui_scale_combo.addItem("200%", 2.0)
        # Add UI Scale to its own layout or directly if preferred
        ui_scale_layout = QHBoxLayout()
        ui_scale_layout.addWidget(QLabel("UI Scale:"))
        ui_scale_layout.addWidget(self.ui_scale_combo)
        display_layout.addLayout(ui_scale_layout)

        # --- Text Speed Setting ---
        text_speed_layout = QHBoxLayout()
        text_speed_layout.addWidget(QLabel("Gradual Text Speed:"))
        self.text_speed_slider = QSlider(Qt.Horizontal)
        self.text_speed_slider.setRange(5, 100)
        self.text_speed_slider.setTickPosition(QSlider.TicksBelow)
        self.text_speed_slider.setTickInterval(10)
        self.text_speed_label = QLabel("30 ms")
        self.text_speed_slider.valueChanged.connect(
            lambda value: self.text_speed_label.setText(f"{value} ms")
        )
        text_speed_layout.addWidget(self.text_speed_slider)
        text_speed_layout.addWidget(self.text_speed_label)
        display_layout.addLayout(text_speed_layout)

        display_layout.addStretch()

        # Add display tab to tab widget
        self.tab_widget.addTab(display_tab, "Display")

    @Slot(bool)
    def _update_resolution_state(self, checked):
        """Enable/disable resolution combo based on Windowed mode selection."""
        is_windowed = self.windowed_radio.isChecked()
        self.resolution_label.setEnabled(is_windowed)
        self.resolution_combo.setEnabled(is_windowed)

    def _setup_sound_tab(self):
        """Set up the sound settings tab."""
        # Create sound tab
        sound_tab = QWidget()
        sound_layout = QVBoxLayout(sound_tab)

        # Create form layout for settings
        form_layout = QFormLayout()

        # Create master volume setting
        self.master_volume_spin = QSpinBox()
        self.master_volume_spin.setRange(0, 100)
        self.master_volume_spin.setSuffix("%")
        form_layout.addRow("Master Volume:", self.master_volume_spin)

        # Create music volume setting
        self.music_volume_spin = QSpinBox()
        self.music_volume_spin.setRange(0, 100)
        self.music_volume_spin.setSuffix("%")
        form_layout.addRow("Music Volume:", self.music_volume_spin)

        # Create sound effects volume setting
        self.effects_volume_spin = QSpinBox()
        self.effects_volume_spin.setRange(0, 100)
        self.effects_volume_spin.setSuffix("%")
        form_layout.addRow("Sound Effects Volume:", self.effects_volume_spin)

        # Create sound enabled checkbox
        self.sound_enabled_check = QCheckBox("Enable Sound")

        # Add form layout to sound layout
        sound_layout.addLayout(form_layout)
        sound_layout.addWidget(self.sound_enabled_check)
        sound_layout.addStretch()

        # Add sound tab to tab widget
        self.tab_widget.addTab(sound_tab, "Sound")

    def _setup_gameplay_tab(self):
        """Set up the gameplay settings tab."""
        # Create gameplay tab
        gameplay_tab = QWidget()
        gameplay_layout = QVBoxLayout(gameplay_tab)

        # Developer Mode group
        dev_group = QGroupBox("Developer Mode")
        dev_layout = QVBoxLayout(dev_group)
        self.dev_mode_checkbox = QCheckBox("Enable Developer Mode (show debug UI and controls)")
        dev_layout.addWidget(self.dev_mode_checkbox)
        gameplay_layout.addWidget(dev_group)

        # Create form layout for settings
        form_layout = QFormLayout()

        # Create difficulty setting (aligned with families generation rules)
        self.difficulty_combo = QComboBox()
        self.difficulty_combo.addItem("Story")
        self.difficulty_combo.addItem("Normal")
        self.difficulty_combo.addItem("Hard")
        self.difficulty_combo.addItem("Expert")
        form_layout.addRow("Difficulty:", self.difficulty_combo)

        # Encounter size setting
        self.encounter_combo = QComboBox()
        self.encounter_combo.addItem("Solo")
        self.encounter_combo.addItem("Pack")
        self.encounter_combo.addItem("Mixed")
        form_layout.addRow("Encounter Size:", self.encounter_combo)

        # Create auto-save interval setting
        self.autosave_spin = QSpinBox()
        self.autosave_spin.setRange(0, 60)
        self.autosave_spin.setSuffix(" minutes")
        self.autosave_spin.setSpecialValueText("Off")
        form_layout.addRow("Auto-save Interval:", self.autosave_spin)

        # Create tutorial checkbox
        self.tutorial_check = QCheckBox("Show Tutorial Tips")

        # Add form layout to gameplay layout
        gameplay_layout.addLayout(form_layout)
        gameplay_layout.addWidget(self.tutorial_check)
        gameplay_layout.addStretch()

        # Add gameplay tab to tab widget
        self.tab_widget.addTab(gameplay_tab, "Gameplay")

    def _load_settings(self):
        """Load settings from QSettings to the UI."""
        # Load display settings
        window_state = self.settings.value("display/window_state", "windowed")
        if window_state == "fullscreen":
            self.fullscreen_radio.setChecked(True)
        elif window_state == "maximized": # Changed key to 'maximized'
            self.windowed_fullscreen_radio.setChecked(True)
        else: # Default to windowed
            self.windowed_radio.setChecked(True)

        # Update resolution combo state initially
        self._update_resolution_state(self.windowed_radio.isChecked())

        # Load windowed resolution (even if not currently windowed)
        default_size = QSize(1280, 720)
        resolution = self.settings.value("display/windowed_size", default_size)
        # Ensure resolution is QSize
        if not isinstance(resolution, QSize):
            if isinstance(resolution, (tuple, list)) and len(resolution) == 2:
                resolution = QSize(resolution[0], resolution[1])
            elif isinstance(resolution, str):
                try:
                    parts = resolution.strip('()').split(',')
                    resolution = QSize(int(parts[0]), int(parts[1]))
                except Exception:
                    resolution = default_size # Fallback on parse error
            else:
                 resolution = default_size # Fallback if type is unexpected

        resolution_str = f"{resolution.width()}x{resolution.height()}"
        found = False
        for i in range(self.resolution_combo.count()):
            if self.resolution_combo.itemText(i) == resolution_str:
                self.resolution_combo.setCurrentIndex(i)
                found = True
                break
        if not found: # If saved resolution isn't in the list, add it? Or default?
            # Option 1: Add it (might make combo long)
            # self.resolution_combo.addItem(resolution_str, resolution)
            # self.resolution_combo.setCurrentIndex(self.resolution_combo.count() - 1)
            # Option 2: Default to first item if not found
             self.resolution_combo.setCurrentIndex(0)
             logging.warning(f"Saved windowed resolution {resolution_str} not found in options. Defaulting.")


        # Load UI scale (unchanged)
        ui_scale = self.settings.value("display/ui_scale", 1.0)
        for i in range(self.ui_scale_combo.count()):
            if self.ui_scale_combo.itemData(i) == ui_scale:
                self.ui_scale_combo.setCurrentIndex(i)
                break

        # Load text speed setting (unchanged)
        text_speed_delay = self.settings.value("display/text_speed_delay", 30, int)
        self.text_speed_slider.setValue(text_speed_delay)
        self.text_speed_label.setText(f"{text_speed_delay} ms")

        # Load sound settings (unchanged)
        self.master_volume_spin.setValue(int(self.settings.value("sound/master_volume", 100)))
        self.music_volume_spin.setValue(int(self.settings.value("sound/music_volume", 100)))
        self.effects_volume_spin.setValue(int(self.settings.value("sound/effects_volume", 100)))
        sound_enabled = self.settings.value("sound/enabled", True)
        if isinstance(sound_enabled, str): sound_enabled = sound_enabled.lower() == "true"
        self.sound_enabled_check.setChecked(sound_enabled)

        # Load gameplay settings
        # Map legacy values if needed ("Easy" -> "Story")
        difficulty = self.settings.value("gameplay/difficulty", "Normal")
        if difficulty == "Easy":
            difficulty = "Story"
        found = False
        for i in range(self.difficulty_combo.count()):
            if self.difficulty_combo.itemText(i) == difficulty:
                self.difficulty_combo.setCurrentIndex(i)
                found = True
                break
        if not found:
            # Default to Normal if unmatched
            for i in range(self.difficulty_combo.count()):
                if self.difficulty_combo.itemText(i) == "Normal":
                    self.difficulty_combo.setCurrentIndex(i)
                    break

        encounter = self.settings.value("gameplay/encounter_size", "Solo")
        found_e = False
        for i in range(self.encounter_combo.count()):
            if self.encounter_combo.itemText(i) == encounter:
                self.encounter_combo.setCurrentIndex(i)
                found_e = True
                break
        if not found_e:
            # Default to Solo
            for i in range(self.encounter_combo.count()):
                if self.encounter_combo.itemText(i) == "Solo":
                    self.encounter_combo.setCurrentIndex(i)
                    break

        self.autosave_spin.setValue(int(self.settings.value("gameplay/autosave_interval", 0)))
        tutorial_enabled = self.settings.value("gameplay/tutorial_enabled", True)
        if isinstance(tutorial_enabled, str): tutorial_enabled = tutorial_enabled.lower() == "true"
        self.tutorial_check.setChecked(tutorial_enabled)

        # Load dev mode
        dev_enabled = self.settings.value("dev/enabled", False)
        if isinstance(dev_enabled, str):
            dev_enabled = dev_enabled.lower() == "true"
        self.dev_mode_checkbox.setChecked(bool(dev_enabled))

        # Load style settings
        if hasattr(self, 'style_tab'):
            self.style_tab._load_settings() 

        if hasattr(self, 'background_tab'):
             self.background_tab.load_settings(self.settings)

    def _setup_style_tab(self):
        """Set up the style settings tab."""
        # Create style tab
        self.style_tab = StyleTab()

        # Add style tab to tab widget
        self.tab_widget.addTab(self.style_tab, "Style")


    def _setup_background_tab(self):
        """Set up the background selection tab."""
        # Create background tab
        self.background_tab = BackgroundTab()

        # Connect the preview signal from the tab to this dialog's signal
        self.background_tab.preview_background_changed.connect(self.background_preview_requested)

        # Add background tab to tab widget
        self.tab_widget.addTab(self.background_tab, "Background")

    def _save_settings(self):
        """Save settings from the UI to QSettings."""
        # Save window state
        window_state_str = "windowed" # Default
        if self.fullscreen_radio.isChecked():
            window_state_str = "fullscreen"
        elif self.windowed_fullscreen_radio.isChecked():
            window_state_str = "maximized" # Use 'maximized' internally
        self.settings.setValue("display/window_state", window_state_str)

        # Save windowed resolution *only* if windowed mode is selected
        if window_state_str == "windowed":
            selected_resolution = self.resolution_combo.currentData()
            if isinstance(selected_resolution, QSize): # Store QSize directly if possible
                self.settings.setValue("display/windowed_size", selected_resolution)
            else: # Fallback to storing tuple if currentData wasn't QSize
                resolution_text = self.resolution_combo.currentText()
                try:
                    w, h = map(int, resolution_text.split('x'))
                    self.settings.setValue("display/windowed_size", (w, h))
                except ValueError:
                    logging.error(f"Could not parse resolution text '{resolution_text}' during save.")
                    # Optionally save a default or skip saving resolution

        # Save UI scale (unchanged)
        self.settings.setValue("display/ui_scale", self.ui_scale_combo.currentData())

        # Save text speed setting (unchanged)
        self.settings.setValue("display/text_speed_delay", self.text_speed_slider.value())

        # Save sound settings (unchanged)
        self.settings.setValue("sound/master_volume", self.master_volume_spin.value())
        self.settings.setValue("sound/music_volume", self.music_volume_spin.value())
        self.settings.setValue("sound/effects_volume", self.effects_volume_spin.value())
        self.settings.setValue("sound/enabled", self.sound_enabled_check.isChecked())

        # Save gameplay settings
        self.settings.setValue("gameplay/difficulty", self.difficulty_combo.currentText())
        self.settings.setValue("gameplay/encounter_size", self.encounter_combo.currentText())
        self.settings.setValue("gameplay/autosave_interval", self.autosave_spin.value())
        self.settings.setValue("gameplay/tutorial_enabled", self.tutorial_check.isChecked())

        # Reflect gameplay settings into in-memory GameConfig for immediate effect
        try:
            cfg = get_config()
            cfg._config_data.setdefault("game", {})
            # Map UI labels to config tokens expected by generator
            diff_map = {"Story": "story", "Normal": "normal", "Hard": "hard", "Expert": "expert"}
            enc_map = {"Solo": "solo", "Pack": "pack", "Mixed": "mixed"}
            cfg._config_data["game"]["difficulty"] = diff_map.get(self.difficulty_combo.currentText(), "normal")
            cfg._config_data["game"]["encounter_size"] = enc_map.get(self.encounter_combo.currentText(), "solo")
        except Exception:
            # Non-fatal if config is unavailable here
            pass

        # Save dev mode
        self.settings.setValue("dev/enabled", self.dev_mode_checkbox.isChecked())

        # Save style settings (unchanged)
        if hasattr(self, 'style_tab'):
            self.style_tab.save_settings()

        # Save background settings (unchanged)
        if hasattr(self, 'background_tab'):
            self.background_tab.save_settings(self.settings)

        # Sync settings to disk
        self.settings.sync()

        # Emit signal
        self.settings_saved.emit()

        # Close dialog
        self.accept()

    @staticmethod
    def get_settings():
        """Get the current settings.

        Returns:
            Dict[str, Any]: The current settings.
        """
        settings = QSettings("RPGGame", "Settings")
        # ... (rest of the method implementation) ...

        # Helper to convert loaded QSize to tuple if needed
        def size_to_tuple(size_val):
            if isinstance(size_val, QSize):
                return (size_val.width(), size_val.height())
            # Handle tuple/list potentially saved previously
            elif isinstance(size_val, (tuple, list)) and len(size_val) == 2:
                return tuple(size_val)
            # Handle string format
            elif isinstance(size_val, str):
                try:
                    parts = size_val.strip('()').split(',')
                    return (int(parts[0]), int(parts[1]))
                except Exception:
                    return (1280, 720) # Fallback
            return (1280, 720) # Default fallback

        return {
            "display": {
                "window_state": settings.value("display/window_state", "windowed"),
                "windowed_size": size_to_tuple(settings.value("display/windowed_size", QSize(1280, 720))), # Get saved windowed size
                "ui_scale": settings.value("display/ui_scale", 1.0),
                "text_speed_delay": settings.value("display/text_speed_delay", 30, int)
            },
            "sound": {
                "master_volume": settings.value("sound/master_volume", 100),
                "music_volume": settings.value("sound/music_volume", 100),
                "effects_volume": settings.value("sound/effects_volume", 100),
                "enabled": settings.value("sound/enabled", True)
            },
            "gameplay": {
                "difficulty": settings.value("gameplay/difficulty", "Normal"),
                "autosave_interval": settings.value("gameplay/autosave_interval", 0),
                "tutorial_enabled": settings.value("gameplay/tutorial_enabled", True)
            },
            "style": {
                "output_bg_color": settings.value("style/output_bg_color", "#D2B48C"),
                "system_msg_color": settings.value("style/system_msg_color", "#FF0000"),
                "font_family": settings.value("style/font_family", "Garamond"),
                "font_size": settings.value("style/font_size", 14),
                "font_color": settings.value("style/font_color", "#000000"),
                "user_input_font_family": settings.value("style/user_input_font_family", "Garamond"),
                "user_input_font_size": settings.value("style/user_input_font_size", 14),
                "user_input_font_color": settings.value("style/user_input_font_color", "#0d47a1"),
                "background_filename": settings.value("style/background_filename", None), # Load filename string
                "texture_name": settings.value("style/texture_name", "subtle_noise"),
                "output_opacity": settings.value("style/output_opacity", 100, int),
                "input_opacity": settings.value("style/input_opacity", 100, int)
            }
        }
```

### File: gui\dialogs\settings\style_tab.py

```python
#!/usr/bin/env python3
"""
Style settings tab for the RPG game GUI.
This module provides a tab for configuring UI style settings.
"""

import os
import logging
from typing import Dict, Any

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, 
    QPushButton, QFormLayout, QGroupBox, QRadioButton, 
    QButtonGroup, QColorDialog, QFontDialog, QGridLayout,
    QFrame, QSlider
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize
from PySide6.QtGui import QFont, QColor, QPixmap, QIcon

class StyleTab(QWidget):
    """Tab for configuring UI style settings."""
    
    def __init__(self, parent=None):
        """Initialize the style tab."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
        
        # Load settings
        self._load_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create main layout
        layout = QVBoxLayout(self)
        
        # Create form layout for settings
        form_layout = QFormLayout()
        
        # Output area background color
        self.output_bg_group = QGroupBox("Output Area Background")
        self.output_bg_layout = QVBoxLayout(self.output_bg_group)
        
        # Predefined colors
        self.predefined_colors_layout = QGridLayout()
        self.predefined_colors_layout.setSpacing(5)
        
        # Add predefined color options
        self.color_buttons = {}
        predefined_colors = [
            ("Light Brown", "#D2B48C"),
            ("Dark Brown", "#8B4513"),
            ("Beige", "#F5F5DC"),
            ("Cream", "#FFFDD0"),
            ("Tan", "#D2B48C"),
            ("Ivory", "#FFFFF0"),
            ("Light Gray", "#D3D3D3"),
            ("Light Blue", "#ADD8E6"),
            ("Light Green", "#90EE90"),
            ("Light Red", "#FFCCCB"),
        ]
        
        # Create a button group for color selection
        self.bg_color_group = QButtonGroup(self)
        self.bg_color_group.setExclusive(True)
        
        # Add color buttons to grid
        row, col = 0, 0
        for i, (color_name, color_hex) in enumerate(predefined_colors):
            button = QRadioButton(color_name)
            # Set a background color style for the button
            button.setStyleSheet(f"QRadioButton {{ background-color: {color_hex}; padding: 5px; border-radius: 3px; }}")
            button.setProperty("color_hex", color_hex)
            
            self.predefined_colors_layout.addWidget(button, row, col)
            self.color_buttons[color_name] = button
            self.bg_color_group.addButton(button)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Custom color picker
        self.custom_color_layout = QHBoxLayout()
        self.custom_color_radio = QRadioButton("Custom:")
        self.bg_color_group.addButton(self.custom_color_radio)
        
        self.custom_color_button = QPushButton("Choose...")
        self.custom_color_button.clicked.connect(self._choose_custom_bg_color)
        
        self.custom_color_preview = QFrame()
        self.custom_color_preview.setFixedSize(20, 20)
        self.custom_color_preview.setFrameShape(QFrame.StyledPanel)
        self.custom_color_preview.setStyleSheet("background-color: #D2B48C; border: 1px solid gray;")
        
        self.custom_color_layout.addWidget(self.custom_color_radio)
        self.custom_color_layout.addWidget(self.custom_color_button)
        self.custom_color_layout.addWidget(self.custom_color_preview)
        self.custom_color_layout.addStretch()
        
        # Add layouts to output bg group
        self.output_bg_layout.addLayout(self.predefined_colors_layout)
        self.output_bg_layout.addLayout(self.custom_color_layout)
        
        # System message color
        self.system_msg_group = QGroupBox("System Message Color")
        self.system_msg_layout = QVBoxLayout(self.system_msg_group)
        
        # Predefined system colors
        self.sys_colors_layout = QGridLayout()
        self.sys_colors_layout.setSpacing(5)
        
        # Add predefined system color options
        self.sys_color_buttons = {}
        predefined_sys_colors = [
            ("Red", "#FF0000"),
            ("Orange", "#FFA500"),
            ("Yellow", "#FFFF00"),
            ("Green", "#00FF00"),
            ("Blue", "#0000FF"),
            ("Purple", "#800080"),
            ("Pink", "#FFC0CB"),
            ("Black", "#000000"),
        ]
        
        # Create a button group for system color selection
        self.sys_color_group = QButtonGroup(self)
        self.sys_color_group.setExclusive(True)
        
        # Add system color buttons to grid
        row, col = 0, 0
        for i, (color_name, color_hex) in enumerate(predefined_sys_colors):
            button = QRadioButton(color_name)
            # Set a foreground color style for the button
            button.setStyleSheet(f"QRadioButton {{ color: {color_hex}; font-weight: bold; }}")
            button.setProperty("color_hex", color_hex)
            
            self.sys_colors_layout.addWidget(button, row, col)
            self.sys_color_buttons[color_name] = button
            self.sys_color_group.addButton(button)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Custom system color picker
        self.custom_sys_color_layout = QHBoxLayout()
        self.custom_sys_color_radio = QRadioButton("Custom:")
        self.sys_color_group.addButton(self.custom_sys_color_radio)
        
        self.custom_sys_color_button = QPushButton("Choose...")
        self.custom_sys_color_button.clicked.connect(self._choose_custom_sys_color)
        
        self.custom_sys_color_preview = QFrame()
        self.custom_sys_color_preview.setFixedSize(20, 20)
        self.custom_sys_color_preview.setFrameShape(QFrame.StyledPanel)
        self.custom_sys_color_preview.setStyleSheet("background-color: #FF0000; border: 1px solid gray;")
        
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_radio)
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_button)
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_preview)
        self.custom_sys_color_layout.addStretch()
        
        # Add layouts to system msg group
        self.system_msg_layout.addLayout(self.sys_colors_layout)
        self.system_msg_layout.addLayout(self.custom_sys_color_layout)
        
        # Output Text Font settings
        self.font_group = QGroupBox("Output Text Font")
        self.font_layout = QVBoxLayout(self.font_group)
        
        self.font_button = QPushButton("Choose Font...")
        self.font_button.clicked.connect(self._choose_font)
        
        self.font_preview = QLabel("AaBbCcDdEe 12345")
        self.font_preview.setAlignment(Qt.AlignCenter)
        self.font_preview.setFrameShape(QFrame.StyledPanel)
        self.font_preview.setMinimumHeight(40)
        
        self.font_layout.addWidget(self.font_button)
        self.font_layout.addWidget(self.font_preview)
        
        # Font color
        self.font_color_layout = QHBoxLayout()
        self.font_color_label = QLabel("Font Color:")
        self.font_color_button = QPushButton("Choose...")
        self.font_color_button.clicked.connect(self._choose_font_color)
        
        self.font_color_preview = QFrame()
        self.font_color_preview.setFixedSize(20, 20)
        self.font_color_preview.setFrameShape(QFrame.StyledPanel)
        self.font_color_preview.setStyleSheet("background-color: #000000; border: 1px solid gray;")
        
        self.font_color_layout.addWidget(self.font_color_label)
        self.font_color_layout.addWidget(self.font_color_button)
        self.font_color_layout.addWidget(self.font_color_preview)
        self.font_color_layout.addStretch()
        
        self.font_layout.addLayout(self.font_color_layout)
        
        # User Input Text Font settings
        self.user_input_font_group = QGroupBox("User Input Text Font")
        self.user_input_font_layout = QVBoxLayout(self.user_input_font_group)
        
        self.user_input_font_button = QPushButton("Choose Font...")
        self.user_input_font_button.clicked.connect(self._choose_user_input_font)
        
        self.user_input_font_preview = QLabel("AaBbCcDdEe 12345")
        self.user_input_font_preview.setAlignment(Qt.AlignCenter)
        self.user_input_font_preview.setFrameShape(QFrame.StyledPanel)
        self.user_input_font_preview.setMinimumHeight(40)
        
        self.user_input_font_layout.addWidget(self.user_input_font_button)
        self.user_input_font_layout.addWidget(self.user_input_font_preview)
        
        # User input font color
        self.user_input_font_color_layout = QHBoxLayout()
        self.user_input_font_color_label = QLabel("Font Color:")
        self.user_input_font_color_button = QPushButton("Choose...")
        self.user_input_font_color_button.clicked.connect(self._choose_user_input_font_color)
        
        self.user_input_font_color_preview = QFrame()
        self.user_input_font_color_preview.setFixedSize(20, 20)
        self.user_input_font_color_preview.setFrameShape(QFrame.StyledPanel)
        self.user_input_font_color_preview.setStyleSheet("background-color: #0d47a1; border: 1px solid gray;")
        
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_label)
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_button)
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_preview)
        self.user_input_font_color_layout.addStretch()
        
        self.user_input_font_layout.addLayout(self.user_input_font_color_layout)
        
        # Add all settings to the form layout
        layout.addWidget(self.output_bg_group)
        layout.addWidget(self.system_msg_group)
        layout.addWidget(self.font_group)
        layout.addWidget(self.user_input_font_group)
        
        # Add texture and transparency settings
        self._setup_texture_settings(layout)
        self._setup_transparency_settings(layout)
        
        layout.addStretch()
    
    def _setup_texture_settings(self, parent_layout):
        """Set up texture settings."""
        # Create a group box for texture settings
        self.texture_group = QGroupBox("Background Texture")
        texture_layout = QVBoxLayout(self.texture_group)
        
        # Create radio buttons for texture selection
        self.texture_radio_group = QButtonGroup(self)
        self.texture_radio_group.setExclusive(True)
        
        # Define available textures
        textures = [
            ("None", "none"),
            ("Subtle Noise", "subtle_noise"),
            ("Parchment", "parchment"),
            ("Leather", "leather"),
            ("Stone", "stone")
        ]
        
        # Create a grid layout for texture options
        texture_grid = QGridLayout()
        texture_grid.setSpacing(10)
        
        # Create radio buttons for each texture
        self.texture_buttons = {}
        row, col = 0, 0
        for i, (display_name, texture_name) in enumerate(textures):
            button = QRadioButton(display_name)
            button.setProperty("texture_name", texture_name)
            self.texture_buttons[texture_name] = button
            self.texture_radio_group.addButton(button)
            
            texture_grid.addWidget(button, row, col)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Add grid to layout
        texture_layout.addLayout(texture_grid)
        
        # Add group to parent layout
        parent_layout.addWidget(self.texture_group)
    
    def _setup_transparency_settings(self, parent_layout):
        """Set up transparency settings."""
        # Create group box
        self.transparency_group = QGroupBox("Transparency Settings")
        transparency_layout = QFormLayout(self.transparency_group)
        
        # Create output transparency slider
        self.output_transparency_slider = QSlider(Qt.Horizontal)
        self.output_transparency_slider.setRange(0, 100)
        self.output_transparency_slider.setValue(100)  # Default to fully opaque
        self.output_transparency_slider.setTickPosition(QSlider.TicksBelow)
        self.output_transparency_slider.setTickInterval(10)
        
        # Create input transparency slider
        self.input_transparency_slider = QSlider(Qt.Horizontal)
        self.input_transparency_slider.setRange(0, 100)
        self.input_transparency_slider.setValue(100)  # Default to fully opaque
        self.input_transparency_slider.setTickPosition(QSlider.TicksBelow)
        self.input_transparency_slider.setTickInterval(10)
        
        # Add sliders to layout
        transparency_layout.addRow("Output Area Opacity:", self.output_transparency_slider)
        transparency_layout.addRow("Command Input Opacity:", self.input_transparency_slider)
        
        # Add value labels
        self.output_transparency_value = QLabel("100%")
        self.input_transparency_value = QLabel("100%")
        
        transparency_layout.addRow("", self.output_transparency_value)
        transparency_layout.addRow("", self.input_transparency_value)
        
        # Connect sliders to update value labels
        self.output_transparency_slider.valueChanged.connect(
            lambda v: self.output_transparency_value.setText(f"{v}%")
        )
        self.input_transparency_slider.valueChanged.connect(
            lambda v: self.input_transparency_value.setText(f"{v}%")
        )
        
        # Add group to parent layout
        parent_layout.addWidget(self.transparency_group)
    
    def _choose_custom_bg_color(self):
        """Open color dialog for custom background color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/output_bg_color", "#D2B48C"))
        
        color = QColorDialog.getColor(current_color, self, "Select Background Color")
        if color.isValid():
            # Update preview
            self.custom_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Select custom radio button
            self.custom_color_radio.setChecked(True)
            # Store color hex
            self.custom_color_radio.setProperty("color_hex", color.name())
    
    def _choose_custom_sys_color(self):
        """Open color dialog for custom system message color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/system_msg_color", "#FF0000"))
        
        color = QColorDialog.getColor(current_color, self, "Select System Message Color")
        if color.isValid():
            # Update preview
            self.custom_sys_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Select custom radio button
            self.custom_sys_color_radio.setChecked(True)
            # Store color hex
            self.custom_sys_color_radio.setProperty("color_hex", color.name())
    
    def _choose_font(self):
        """Open font dialog."""
        settings = QSettings("RPGGame", "Settings")
        current_font = QFont()
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        current_font.setFamily(font_family)
        current_font.setPointSize(font_size)
        
        ok, font = QFontDialog.getFont(current_font, self, "Select Font")
        if ok:
            # Update preview
            self.font_preview.setFont(font)
            # Store font
            self.font_preview.setProperty("selected_font", font)
    
    def _choose_user_input_font(self):
        """Open font dialog for user input text."""
        settings = QSettings("RPGGame", "Settings")
        current_font = QFont()
        font_family = settings.value("style/user_input_font_family", "Garamond")
        font_size = int(settings.value("style/user_input_font_size", 14))
        current_font.setFamily(font_family)
        current_font.setPointSize(font_size)
        
        ok, font = QFontDialog.getFont(current_font, self, "Select User Input Font")
        if ok:
            # Update preview
            self.user_input_font_preview.setFont(font)
            # Store font
            self.user_input_font_preview.setProperty("selected_font", font)
    
    def _choose_user_input_font_color(self):
        """Open color dialog for user input font color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/user_input_font_color", "#0d47a1"))
        
        color = QColorDialog.getColor(current_color, self, "Select User Input Font Color")
        if color.isValid():
            # Update preview
            self.user_input_font_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Update font preview
            self.user_input_font_preview.setStyleSheet(f"color: {color.name()};")
            # Store color
            self.user_input_font_color_preview.setProperty("color_hex", color.name())
    
    def _choose_font_color(self):
        """Open color dialog for font color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/font_color", "#000000"))
        
        color = QColorDialog.getColor(current_color, self, "Select Font Color")
        if color.isValid():
            # Update preview
            self.font_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Update font preview
            self.font_preview.setStyleSheet(f"color: {color.name()};")
            # Store color
            self.font_color_preview.setProperty("color_hex", color.name())
    
    def _load_settings(self):
        """Load settings from QSettings to the UI."""
        settings = QSettings("RPGGame", "Settings")
        
        # Load output background color
        bg_color = settings.value("style/output_bg_color", "#D2B48C")
        
        # Check if it's one of the predefined colors
        found_predefined = False
        for button in self.color_buttons.values():
            if button.property("color_hex") == bg_color:
                button.setChecked(True)
                found_predefined = True
                break
        
        # If not found, use custom color
        if not found_predefined:
            self.custom_color_radio.setChecked(True)
            self.custom_color_preview.setStyleSheet(f"background-color: {bg_color}; border: 1px solid gray;")
            self.custom_color_radio.setProperty("color_hex", bg_color)
        
        # Load system message color
        sys_color = settings.value("style/system_msg_color", "#FF0000")
        
        # Check if it's one of the predefined colors
        found_predefined = False
        for button in self.sys_color_buttons.values():
            if button.property("color_hex") == sys_color:
                button.setChecked(True)
                found_predefined = True
                break
        
        # If not found, use custom color
        if not found_predefined:
            self.custom_sys_color_radio.setChecked(True)
            self.custom_sys_color_preview.setStyleSheet(f"background-color: {sys_color}; border: 1px solid gray;")
            self.custom_sys_color_radio.setProperty("color_hex", sys_color)
        
        # Load output font settings
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        font = QFont(font_family, font_size)
        self.font_preview.setFont(font)
        self.font_preview.setProperty("selected_font", font)
        
        # Load output font color
        font_color = settings.value("style/font_color", "#000000")
        self.font_color_preview.setStyleSheet(f"background-color: {font_color}; border: 1px solid gray;")
        self.font_preview.setStyleSheet(f"color: {font_color};")
        self.font_color_preview.setProperty("color_hex", font_color)
        
        # Load user input font settings
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font = QFont(user_input_font_family, user_input_font_size)
        self.user_input_font_preview.setFont(user_input_font)
        self.user_input_font_preview.setProperty("selected_font", user_input_font)
        
        # Load user input font color
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")
        self.user_input_font_color_preview.setStyleSheet(f"background-color: {user_input_font_color}; border: 1px solid gray;")
        self.user_input_font_preview.setStyleSheet(f"color: {user_input_font_color};")
        self.user_input_font_color_preview.setProperty("color_hex", user_input_font_color)
        
        # Load texture setting
        texture_name = settings.value("style/texture_name", "subtle_noise")
        if texture_name in self.texture_buttons:
            self.texture_buttons[texture_name].setChecked(True)
        else:
            # Default to subtle noise
            self.texture_buttons["subtle_noise"].setChecked(True)
        
        # Load transparency settings
        output_opacity = int(settings.value("style/output_opacity", 100))
        input_opacity = int(settings.value("style/input_opacity", 100))
        
        self.output_transparency_slider.setValue(output_opacity)
        self.input_transparency_slider.setValue(input_opacity)
        self.output_transparency_value.setText(f"{output_opacity}%")
        self.input_transparency_value.setText(f"{input_opacity}%")
    
    def save_settings(self):
        """Save settings from the UI to QSettings."""
        settings = QSettings("RPGGame", "Settings")
        
        # Save output background color
        if self.custom_color_radio.isChecked():
            bg_color = self.custom_color_radio.property("color_hex")
        else:
            # Get selected button
            for button in self.color_buttons.values():
                if button.isChecked():
                    bg_color = button.property("color_hex")
                    break
            else:
                # Default if none selected
                bg_color = "#D2B48C"
        
        settings.setValue("style/output_bg_color", bg_color)
        
        # Save system message color
        if self.custom_sys_color_radio.isChecked():
            sys_color = self.custom_sys_color_radio.property("color_hex")
        else:
            # Get selected button
            for button in self.sys_color_buttons.values():
                if button.isChecked():
                    sys_color = button.property("color_hex")
                    break
            else:
                # Default if none selected
                sys_color = "#FF0000"
        
        settings.setValue("style/system_msg_color", sys_color)
        
        # Save output font settings
        font = self.font_preview.property("selected_font")
        if font:
            settings.setValue("style/font_family", font.family())
            settings.setValue("style/font_size", font.pointSize())
        
        # Save output font color
        font_color = self.font_color_preview.property("color_hex")
        if font_color:
            settings.setValue("style/font_color", font_color)
            
        # Save user input font settings
        user_input_font = self.user_input_font_preview.property("selected_font")
        if user_input_font:
            settings.setValue("style/user_input_font_family", user_input_font.family())
            settings.setValue("style/user_input_font_size", user_input_font.pointSize())
        
        # Save user input font color
        user_input_font_color = self.user_input_font_color_preview.property("color_hex")
        if user_input_font_color:
            settings.setValue("style/user_input_font_color", user_input_font_color)
        
        # Save texture setting
        for button in self.texture_buttons.values():
            if button.isChecked():
                texture_name = button.property("texture_name")
                settings.setValue("style/texture_name", texture_name)
                break
        
        # Save transparency settings
        output_opacity = self.output_transparency_slider.value()
        input_opacity = self.input_transparency_slider.value()
        
        settings.setValue("style/output_opacity", output_opacity)
        settings.setValue("style/input_opacity", input_opacity)

```

### File: core\stats\enums\__init__.py

```python
#!/usr/bin/env python3
"""
Enumeration types for the stats system.

This module re-exports the enum types from stats_base.py for better organization
and maintains backward compatibility with existing imports.
"""

from core.stats.stats_base import StatCategory, StatType, DerivedStatType, Skill

# Re-export all enum types for backward compatibility
__all__ = ['StatCategory', 'StatType', 'DerivedStatType', 'Skill']

```

### File: core\base\state\__init__.py

```python
"""
State management module for the RPG game.

This module provides classes for managing the game state,
including player state, world state, and game session information.
"""

from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from core.base.state.game_state import GameState
from core.base.state.state_manager import StateManager, get_state_manager

```

### File: core\base\state\game_state.py

```python
"""
Game state for the RPG game.

This module provides the GameState class for managing the overall game state.
"""

import uuid
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any

from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from core.utils.logging_config import get_logger
from core.interaction.enums import InteractionMode


# Import here but use type hints with string to avoid circular imports
# This import is only used for type checking
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.combat.combat_manager import CombatManager

# Get the module logger
logger = get_logger("GAME")

@dataclass
class GameState:
    """
    Overall game state.
    
    This dataclass contains all state information for a game session,
    including player and world state.
    """
    # Session information
    session_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: float = field(default_factory=time.time)
    last_saved_at: Optional[float] = None
    
    # Game version
    game_version: str = "0.1.0"
    
    # States
    player: PlayerState = field(default_factory=lambda: PlayerState(name="Player"))
    world: WorldState = field(default_factory=WorldState)
    
    # Combat manager (optional, only present during combat)
    combat_manager: Optional['CombatManager'] = None
    
    # Conversation history (simple for now, will be expanded)
    conversation_history: List[Dict[str, Any]] = field(default_factory=list)
    
    # Event log (game-time receipts of what happened in this session)
    event_log: List[Dict[str, Any]] = field(default_factory=list)
    
    # Last command (for context)
    last_command: Optional[str] = None
    
    
    # Interaction Mode
    current_mode: InteractionMode = field(default=InteractionMode.NARRATIVE)
    
    # Mode-specific state
    current_combatants: List[str] = field(default_factory=list)  # IDs of entities in combat/social conflict
    current_trade_partner_id: Optional[str] = None             # ID of the NPC being traded with
    
    # Cooldowns for mode transitions (target_mode: timestamp_expires)
    mode_transition_cooldowns: Dict[str, float] = field(default_factory=dict)
    
    # Transition state flags
    is_transitioning_to_combat: bool = False  # Flag for narrative->combat transition
    combat_narrative_buffer: List[str] = field(default_factory=list)  # Buffer for combat intro narrative

    @property
    def game_time(self):
        """
        Compatibility property for web server to access game time.
        
        Returns:
            A GameTime object representing the game time from world state.
        """
        from core.base.game_loop import GameTime
        return GameTime(game_time=self.world.game_time)
    
    def add_conversation_entry(self, role: str, content: str) -> None:
        """
        Add an entry to the conversation history.
        
        Args:
            role: The role of the speaker (e.g., "player", "gm").
            content: The content of the message.
        """
        entry = {
            "role": role,
            "content": content,
            "timestamp": time.time(),
        }
        self.conversation_history.append(entry)
        
        # Limit history size (keep last 100 entries)
        if len(self.conversation_history) > 100:
            self.conversation_history = self.conversation_history[-100:]
    

    def get_interaction_mode(self) -> InteractionMode:
        """Return the current interaction mode."""
        return self.current_mode

    def set_interaction_mode(self, new_mode: InteractionMode) -> None:
        """
        Set the interaction mode and reset mode-specific state if necessary.

        Args:
            new_mode: The InteractionMode to switch to.
        """
        if new_mode == self.current_mode:
            return  # No change

        old_mode = self.current_mode
        logger.info(f"Changing interaction mode from {old_mode.name} to {new_mode.name}")

        # --- ECFA Change: is_transitioning_to_combat flag management ---
        # This flag is primarily set to True by mode_transitions.py *before* this method is called.
        # This method mainly handles cleanup and ensures the flag is reset appropriately.

        if old_mode == InteractionMode.NARRATIVE and new_mode == InteractionMode.COMBAT:
            # If is_transitioning_to_combat is not already True, it means this is a direct
            # call to set COMBAT mode (e.g., dev command, or unexpected flow).
            # Set it True to ensure UI buffers any initial narrative if it comes *after* this call.
            if not self.is_transitioning_to_combat:
                logger.warning("set_interaction_mode called directly to COMBAT without transition prep. Setting is_transitioning_to_combat=True.")
                self.is_transitioning_to_combat = True
            # The flag (is_transitioning_to_combat) will be reset by MainWindow after
            # it processes the buffered narrative and switches the UI view.
        
        elif old_mode == InteractionMode.COMBAT and new_mode != InteractionMode.COMBAT:
            # Leaving combat mode
            logger.debug(f"Leaving COMBAT mode for {new_mode.name}. Resetting combat transition flags.")
            self.is_transitioning_to_combat = False # Explicitly reset
            self.combat_narrative_buffer = [] # Clear any residual buffer
            # CombatManager itself is cleared by GameEngine or mode_transitions logic
            # when combat actually ends (e.g., PLAYER_DEFEAT, VICTORY).
            # This method simply reacts to the mode having been changed.
            if self.combat_manager:
                 logger.info(f"Combat mode ended. Last CombatManager state: {self.combat_manager.state.name if self.combat_manager.state else 'N/A'}")
            # self.combat_manager = None # This is typically done by the Engine when combat fully resolves.

        elif self.is_transitioning_to_combat and new_mode != InteractionMode.COMBAT:
            # If we were in the process of transitioning TO combat, but are now
            # being set to a different mode (e.g., error, or immediate override),
            # then cancel the combat transition state.
            logger.warning(f"Combat transition was in progress, but now switching to {new_mode.name}. Resetting transition flags.")
            self.is_transitioning_to_combat = False
            self.combat_narrative_buffer = []

        # Reset mode-specific state based on the mode we are *leaving*
        if old_mode in [InteractionMode.COMBAT, InteractionMode.SOCIAL_CONFLICT]:
            if new_mode not in [InteractionMode.COMBAT, InteractionMode.SOCIAL_CONFLICT]:
                logger.debug(f"Clearing current_combatants list when leaving {old_mode.name} for {new_mode.name}.")
                self.current_combatants = []
        
        if old_mode == InteractionMode.TRADE:
            if new_mode != InteractionMode.TRADE:
                logger.debug(f"Clearing current_trade_partner_id when leaving TRADE for {new_mode.name}.")
                self.current_trade_partner_id = None

        # Set the new mode
        self.current_mode = new_mode
        logger.info(f"Interaction mode is now set to {self.current_mode.name}")

    def to_dict(self) -> Dict[str, Any]:
        """Convert GameState to a dictionary for serialization."""
        result = {
            "session_id": self.session_id,
            "created_at": self.created_at,
            "last_saved_at": self.last_saved_at or time.time(),
            "game_version": self.game_version,
            "player": self.player.to_dict(),
            "world": self.world.to_dict(),
            "conversation_history": self.conversation_history,
            "event_log": self.event_log,
            "last_command": self.last_command,
            # Interaction Mode State
            "current_mode": self.current_mode.name,  # Store enum name as string
            "current_combatants": self.current_combatants,
            "current_trade_partner_id": self.current_trade_partner_id,
            "mode_transition_cooldowns": self.mode_transition_cooldowns,
            "is_transitioning_to_combat": self.is_transitioning_to_combat,
            "combat_narrative_buffer": self.combat_narrative_buffer,
        }
        
        # Include journal if present
        if hasattr(self, 'journal') and isinstance(self.journal, dict):
            result["journal"] = self.journal
        
        # Add combat_manager if it exists
        if self.combat_manager is not None:
            result["combat_manager"] = self.combat_manager.to_dict()
            
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GameState':
        """Create a GameState from a dictionary."""
        player_data = data.get("player", {})
        world_data = data.get("world", {})
        
        game_state = cls(
            session_id=data.get("session_id", str(uuid.uuid4())),
            created_at=data.get("created_at", time.time()),
            last_saved_at=data.get("last_saved_at"),
            game_version=data.get("game_version", "0.1.0"),
            player=PlayerState.from_dict(player_data),
            world=WorldState.from_dict(world_data),
            conversation_history=data.get("conversation_history", []),
            last_command=data.get("last_command"),
            # Load Interaction Mode State
            current_combatants=data.get("current_combatants", []),
            current_trade_partner_id=data.get("current_trade_partner_id"),
            mode_transition_cooldowns=data.get("mode_transition_cooldowns", {}),
            is_transitioning_to_combat=data.get("is_transitioning_to_combat", False),
            combat_narrative_buffer=data.get("combat_narrative_buffer", []),
        )

        # Convert stored mode name back to enum
        mode_name = data.get("current_mode", InteractionMode.NARRATIVE.name)
        try:
            game_state.current_mode = InteractionMode[mode_name]
        except KeyError:
            logger.warning(f"Unknown interaction mode '{mode_name}' found in save data. Defaulting to NARRATIVE.")
            game_state.current_mode = InteractionMode.NARRATIVE
        
        # Restore journal if present
        if "journal" in data and isinstance(data["journal"], dict):
            game_state.journal = data["journal"]
        
        # Restore event log if present
        if "event_log" in data and isinstance(data["event_log"], list):
            game_state.event_log = data["event_log"]
        else:
            game_state.event_log = []
        
        # Load combat_manager if it exists in data
        if "combat_manager" in data:
            from core.combat.combat_manager import CombatManager
            game_state.combat_manager = CombatManager.from_dict(data["combat_manager"])
            
        return game_state

```

### File: core\base\state\player_state.py

```python
"""
Player state for the RPG game.

This module provides the PlayerState class for managing player information.
"""

import uuid
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, TYPE_CHECKING

from core.utils.logging_config import get_logger
from core.interaction.social_effects import StatusEffectData # Import StatusEffectData

# Get the module logger
logger = get_logger("PLAYER")

@dataclass
class PlayerState:
    """
    Player state information.

    This dataclass contains all persistent information about the player,
    including basic attributes, location, and derived stats.
    """
    # Basic player information
    name: str
    race: str = "Human"  # Default race
    path: str = "Wanderer"  # Default path/class
    background: str = "Commoner"  # Default background
    sex: str = "Male"  # Default sex/gender
    origin_id: Optional[str] = None # Added origin_id

    # Player attributes
    level: int = 1
    experience: int = 0

    # Stats manager ID - reference to the stats manager for this player
    stats_manager_id: Optional[str] = None

    # Location
    current_location: str = ""
    current_district: str = ""

    # Inventory (to be properly integrated later)
    inventory_id: Optional[str] = None
    equipped_items: Dict[str, str] = field(default_factory=dict)  # slot -> item_id

    # Active quests (to be properly integrated later)
    active_quests: List[str] = field(default_factory=list)  # quest_ids
    completed_quests: List[str] = field(default_factory=list)  # quest_ids

    # Dynamic state related to social/combat
    current_resolve: float = 0.0 # Current social 'health'
    active_social_effects: List[StatusEffectData] = field(default_factory=list)

    # Character appearance
    character_image: Optional[str] = None

    @property
    def experience_to_next_level(self) -> int:
        """
        Calculate the experience required to reach the next level.

        This is a simple formula: 100 * current level
        Can be adjusted for different game progression rates.

        Returns:
            The experience points needed to level up.
        """
        return 100 * self.level

    def to_dict(self) -> Dict[str, Any]:
        """Convert PlayerState to a dictionary for serialization."""
        return {
            "name": self.name,
            "race": self.race,
            "path": self.path,
            "background": self.background,
            "sex": self.sex,
            "origin_id": self.origin_id, # Added
            "level": self.level,
            "experience": self.experience,
            "stats_manager_id": self.stats_manager_id,
            "current_location": self.current_location,
            "current_district": self.current_district,
            "inventory_id": self.inventory_id,
            "equipped_items": self.equipped_items,
            "active_quests": self.active_quests,
            "completed_quests": self.completed_quests,
            "character_image": self.character_image,
            "current_resolve": self.current_resolve,
            "active_social_effects": [effect.to_dict() for effect in self.active_social_effects],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PlayerState':
        """Create a PlayerState from a dictionary."""
        return cls(
            name=data.get("name", "Unknown"),
            race=data.get("race", "Human"),
            path=data.get("path", "Wanderer"),
            background=data.get("background", "Commoner"),
            sex=data.get("sex", "Male"),
            origin_id=data.get("origin_id"), # Added
            level=data.get("level", 1),
            experience=data.get("experience", 0),
            stats_manager_id=data.get("stats_manager_id"),
            current_location=data.get("current_location", ""),
            current_district=data.get("current_district", ""),
            inventory_id=data.get("inventory_id"),
            equipped_items=data.get("equipped_items", {}),
            active_quests=data.get("active_quests", []),
            completed_quests=data.get("completed_quests", []),
            character_image=data.get("character_image"),
            current_resolve=data.get("current_resolve", 0.0),
            active_social_effects=[
                StatusEffectData.from_dict(effect_data)
                for effect_data in data.get("active_social_effects", [])
            ]
        )
```

### File: core\base\state\state_manager.py

```python
"""
State manager for the RPG game.

This module provides the StateManager class for managing game state.
"""

import os
import uuid
import datetime
import json
from typing import Dict, List, Optional, Any
from core.stats.stats_base import StatType
from PySide6.QtCore import QTimer
from core.base.state.game_state import GameState
from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.character.npc_system import NPCSystem
from core.character.npc_base import NPCInteractionType
from core.stats.modifier import ModifierSource, StatModifier, ModifierType
from core.stats.stats_base import StatType
from core.utils.logging_config import get_logger
from core.utils.json_utils import save_json, load_json
from core.base.config import get_config

# Get the module logger
logger = get_logger("STATE")

class StateManager:
    """
    Manager for game state.
    
    This class handles creating, loading, and saving game states.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(StateManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self, saves_dir: Optional[str] = None):
        """Initialize the state manager."""
        if self._initialized:
            return
        
        # Get configuration
        config = get_config()
        self._saves_dir = saves_dir or config.get("system.save_dir", "saves")
        
        # Create saves directory if it doesn't exist
        os.makedirs(self._saves_dir, exist_ok=True)
        
        # Current game state
        self._current_state: Optional[GameState] = None
        
        # Last deleted save (for undo)
        self._last_deleted_save: Optional[Dict[str, Any]] = None
        
        # Stats manager instance (set when creating or loading a game)
        self._stats_manager = None
        
        self._initialized = True
    
    @property
    def current_state(self) -> Optional[GameState]:
        """Get the current game state."""
        return self._current_state
    
    # Compatibility property for web server
    @property
    def state(self) -> Optional[GameState]:
        """Compatibility property for web server to access the current state."""
        return self._current_state
    
    @property
    def stats_manager(self):
        """Get the stats manager for the current player."""
        if self._stats_manager is None and self._current_state is not None:
            # Get stats manager singleton
            try:
                from core.stats.stats_manager import get_stats_manager
                self._stats_manager = get_stats_manager()
                
                # Link stats manager ID with player
                if self._current_state.player.stats_manager_id is None:
                    self._current_state.player.stats_manager_id = str(uuid.uuid4())
                
                # Do not emit signals automatically here - UI components will request stats when needed
                # This prevents duplicate updates and reduces unnecessary processing
                # UI components like CharacterSheetWidget will directly request stats when needed
            except Exception as e:
                logger.error(f"Failed to initialize stats manager: {e}")
        
        return self._stats_manager
                
    def ensure_stats_manager_initialized(self):
        """Ensure the stats manager is initialized."""
        # Simply access the property to ensure initialization
        return self.stats_manager
        
    def get_npc_system(self) -> Optional['NPCSystem']:
        """Get the NPC system instance."""
        if self._npc_system is None:
            # Try to initialize NPC system if needed
            try:
                from core.character.npc_system import NPCSystem
                self._npc_system = NPCSystem()
                logger.info("NPC system initialized")
            except Exception as e:
                logger.error(f"Failed to initialize NPC system: {e}")
        
        return self._npc_system
        
    def set_npc_system(self, npc_system: 'NPCSystem') -> None:
        """Set the NPC system instance."""
        self._npc_system = npc_system
    
    def create_new_game(self, player_name: str, race: str = "Human", 
                       path: str = "Wanderer", background: str = "Commoner",
                       sex: str = "Male", character_image: Optional[str] = None,
                       stats: Optional[Dict[str, int]] = None,
                       origin_id: Optional[str] = None) -> GameState: # Added origin_id parameter
        """
        Create a new game state.
        
        Args:
            player_name: The name of the player character.
            race: The race of the player character.
            path: The class/path of the player character.
            background: The background of the player character.
            sex: The sex/gender of the player character.
            character_image: Path to the character's portrait image.
            stats: Optional dictionary of starting stats.
            origin_id: The ID of the player's chosen origin.
        
        Returns:
            The new game state.
        """
        logger.info(f"Creating new game for player {player_name}, origin: {origin_id}")
        
        # Create player state
        player = PlayerState(
            name=player_name,
            race=race,
            path=path,
            background=background,
            sex=sex,
            character_image=character_image,
            stats_manager_id=str(uuid.uuid4()),
            origin_id=origin_id # Set origin_id
        )
        
        # Create world state (default values)
        world = WorldState()
        
        # Create game state
        self._current_state = GameState(
            player=player,
            world=world,
        )
        
        # Initialize stats manager - use singleton instance
        try:
            from core.stats.stats_manager import get_stats_manager
            self._stats_manager = get_stats_manager()
            
            # Ensure the singleton StatsManager starts from a clean slate for the new game
            try:
                if hasattr(self._stats_manager, 'reset_for_new_game'):
                    self._stats_manager.reset_for_new_game()
                    logger.info("StatsManager reset to a clean state for new game.")
            except Exception as e_reset:
                logger.warning(f"Failed to fully reset StatsManager for new game: {e_reset}")
            
            # Add comprehensive logging
            logger.info(f"Stats manager initialized for player {player_name}")
            
            # Log whether custom stats were provided
            if stats:
                logger.info(f"Custom stats provided for player {player_name}: {stats}")
            else:
                logger.info(f"No custom stats provided for player {player_name}, using defaults")
            
            # First clear any existing race/class modifiers if stats are being set manually
            # This helps ensure clean application of custom stats
            if stats:

                self._stats_manager.remove_modifiers_by_source(ModifierSource.RACIAL)
                self._stats_manager.remove_modifiers_by_source(ModifierSource.CLASS)
                logger.debug("Cleared existing race and class modifiers before applying custom stats")
            
            # Apply custom stats if provided
            if stats:
                for stat_name, value in stats.items():
                    try:
                        stat_type = StatType.from_string(stat_name.upper())
                        self._stats_manager.set_base_stat(stat_type, value)
                        logger.info(f"Set {stat_name} to {value} from custom stats")
                    except Exception as e:
                        logger.warning(f"Failed to set custom stat {stat_name}: {e}")
                
                # Make sure all stats are recalculated properly
                self._stats_manager._recalculate_derived_stats()
                logger.info("Recalculated derived stats after setting custom stats")
            
            # Apply race modifiers from config file
            try:
                # Load race configuration 
                import os, json
                project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
                race_config_path = os.path.join(project_root, "config", "character", "races.json")
                
                if os.path.exists(race_config_path):
                    with open(race_config_path, 'r') as f:
                        race_data = json.load(f)
                        
                    if race in race_data.get("races", {}):
                        race_modifiers = race_data["races"][race].get("stat_modifiers", {})
                        for stat_name, modifier in race_modifiers.items():
                            try:
                                stat_type = StatType.from_string(stat_name.upper())
                                # Create and add the modifier instead of changing base stat
                                race_modifier = StatModifier(
                                    stat=stat_type,
                                    value=modifier,
                                    source_type=ModifierSource.RACIAL,
                                    source_name=f"{race} Racial Bonus",
                                    modifier_type=ModifierType.PERMANENT,
                                    is_percentage=False,
                                    duration=None
                                )
                                self._stats_manager.add_modifier(race_modifier)
                                logger.info(f"Applied race modifier {stat_name}: {modifier}")
                            except Exception as e:
                                logger.warning(f"Failed to apply race modifier for {stat_name}: {e}")
            except Exception as e:
                logger.warning(f"Failed to apply race modifiers: {e}")
            
            # Apply class modifiers from config file
            try:
                class_config_path = os.path.join(project_root, "config", "character", "classes.json")
                
                if os.path.exists(class_config_path):
                    with open(class_config_path, 'r') as f:
                        class_data = json.load(f)
                        
                    if path in class_data.get("classes", {}):
                        class_modifiers = class_data["classes"][path].get("stat_modifiers", {})
                        for stat_name, modifier in class_modifiers.items():
                            try:
                                stat_type = StatType.from_string(stat_name.upper())
                                # Create and add the modifier instead of changing base stat
                                class_modifier = StatModifier(
                                    stat=stat_type,
                                    value=modifier,
                                    source_type=ModifierSource.CLASS,
                                    source_name=f"{path} Class Bonus",
                                    modifier_type=ModifierType.PERMANENT,
                                    is_percentage=False,
                                    duration=None
                                )
                                self._stats_manager.add_modifier(class_modifier)
                                logger.info(f"Applied class modifier {stat_name}: {modifier}")
                            except Exception as e:
                                logger.warning(f"Failed to apply class modifier for {stat_name}: {e}")
            except Exception as e:
                logger.warning(f"Failed to apply class modifiers: {e}")
            
            # Log final stats after all modifications
            try:
                all_stats = self._stats_manager.get_all_stats()
                logger.info(f"Final character stats after creation:")
                
                # Log primary stats
                if "primary" in all_stats:
                    primary_stats_list = []
                    for stat_key, stat_data_val in all_stats['primary'].items():
                        if isinstance(stat_data_val, dict): # New structure
                            primary_stats_list.append(f"{stat_key}={stat_data_val.get('value')}")
                        else: # Old structure (direct value)
                            primary_stats_list.append(f"{stat_key}={stat_data_val}")
                    logger.info(f"Primary stats: {', '.join(primary_stats_list)}")

                # Log derived stats
                for category in ["combat", "resources", "social", "other"]:
                    if category in all_stats and all_stats[category]:
                        cat_stats_list = []
                        for stat_key, stat_data_val in all_stats[category].items():
                            if isinstance(stat_data_val, dict): # New structure
                                cat_stats_list.append(f"{stat_key}={stat_data_val.get('value')}")
                            else: # Old structure
                                 cat_stats_list.append(f"{stat_key}={stat_data_val}")
                        logger.info(f"{category.capitalize()} stats: {', '.join(cat_stats_list)}")
            except Exception as e:
                logger.error(f"Error logging final character stats: {e}")
            
        except Exception as e:
            logger.error(f"Failed to initialize stats manager: {e}")
        
        # Initialize inventory manager and connect to stats manager
        self._connect_inventory_and_stats_managers()
        
        # Initialize memory/context system
        self.initialize_memory_context(self._current_state)
        
        # Explicitly ensure stats manager is initialized and signal is emitted
        self.ensure_stats_manager_initialized()
        
        logger.info(f"New game created with session ID {self._current_state.session_id}")
        return self._current_state
    
    def save_game(self, filename: Optional[str] = None, 
                 auto_save: bool = False) -> Optional[str]:
        """
        Save the current game state.
        
        This method saves the full game state including stats, memory/context information,
        equipment, and quest data if those systems are implemented.
        
        Args:
            filename: The name of the save file. If None, uses a default name.
            auto_save: Whether this is an auto-save.
        
        Returns:
            The path to the save file, or None if the save failed.
        """
        if self._current_state is None:
            logger.error("Cannot save: No current game state")
            return None
        
        # Update last saved time
        self._current_state.last_saved_at = datetime.datetime.now().timestamp()
        
        # Generate filename if not provided
        if filename is None:
            player_name = self._current_state.player.name
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            prefix = "auto_" if auto_save else ""
            filename = f"{prefix}{player_name}_{timestamp}.json"
        
        # Ensure filename has .json extension
        if not filename.endswith(".json"):
            filename += ".json"
        
        # Prepare full state dict with enhanced data
        state_dict = self._current_state.to_dict()
        
        # Add stats data if available
        try:
            if self.stats_manager is not None:
                stats_data = self.stats_manager.to_dict()
                state_dict['character_stats'] = stats_data
                logger.info("Including character stats data in save")
        except Exception as e:
            logger.warning(f"Error including stats data in save: {e}")
        
        # Add memory/context data if available
        try:
            # This will be expanded when memory/context modules are implemented
            if hasattr(self, 'get_memory_context_data'):
                memory_data = self.get_memory_context_data()
                if memory_data:
                    state_dict['memory_context'] = memory_data
                    logger.info("Including memory/context data in save")
        except Exception as e:
            logger.warning(f"Error including memory/context data in save: {e}")
        
        # Add enhanced inventory/equipment data if available
        try:
            if self._current_state.player.inventory_id:
                from core.inventory.item_manager import get_inventory_manager
                inv_manager = get_inventory_manager()
                if inv_manager:
                    inventory_data = inv_manager.to_dict()
                    state_dict['detailed_inventory'] = inventory_data
                    logger.info("Including detailed inventory data in save")
        except Exception as e:
            logger.warning(f"Error including detailed inventory data in save: {e}")
        
        # Add quest data if available (future implementation)
        try:
            if hasattr(self._current_state, 'quests') and self._current_state.quests:
                state_dict['detailed_quests'] = self._current_state.quests
                logger.info("Including detailed quest data in save")
        except Exception as e:
            logger.warning(f"Error including quest data in save: {e}")
        
        # Save state
        try:
            save_path = os.path.join(self._saves_dir, filename)
            save_json(state_dict, save_path)
            
            logger.info(f"Game saved to {save_path}")
            return save_path
        except Exception as e:
            logger.error(f"Error saving game: {e}")
            return None
    
    def load_game(self, filename: str) -> Optional[GameState]:
        """
        Load a game state from a file.
        
        This method loads the full game state including stats, memory/context information,
        equipment, and quest data if those were included in the save.
        
        Args:
            filename: The name of the save file.
        
        Returns:
            The loaded game state, or None if the load failed.
        """
        # Ensure filename has .json extension
        if not filename.endswith(".json"):
            filename += ".json"
        
        # Load state
        try:
            load_path = os.path.join(self._saves_dir, filename)
            if not os.path.exists(load_path):
                logger.error(f"Save file not found: {load_path}")
                return None
            
            data = load_json(load_path)
            self._current_state = GameState.from_dict(data)
            
            # Restore stats data if available
            if 'character_stats' in data:
                try:
                    from core.stats.stats_manager import get_stats_manager
                    self._stats_manager = get_stats_manager()
                    # Load saved stats into the singleton instance
                    if isinstance(data['character_stats'], dict):
                        for stat_type, stat_dict in data['character_stats'].get('stats', {}).items():
                            if 'base_value' in stat_dict:
                                try:
                                    self._stats_manager.set_base_stat(stat_type, stat_dict['base_value'])
                                except Exception as e:
                                    logger.warning(f"Failed to restore stat {stat_type}: {e}")
                    # Make sure to recalculate derived stats and emit signal
                    self._stats_manager._recalculate_derived_stats()
                    logger.info("Recalculated derived stats and emitted stats_changed signal")
                    logger.info("Restored character stats data from save")
                except Exception as e:
                    logger.warning(f"Error restoring character stats data: {e}")
                    
            # Restore memory/context data if available
            if 'memory_context' in data:
                try:
                    # This will be expanded when memory/context modules are implemented
                    if hasattr(self, 'restore_memory_context_data'):
                        self.restore_memory_context_data(data['memory_context'])
                        logger.info("Restored memory/context data from save")
                except Exception as e:
                    logger.warning(f"Error restoring memory/context data: {e}")
            
            # Restore detailed inventory/equipment data if available
            if 'detailed_inventory' in data:
                try:
                    from core.inventory.item_manager import get_inventory_manager
                    inv_manager = get_inventory_manager()
                    if inv_manager:
                        inv_manager.load_from_dict(data['detailed_inventory'])
                        logger.info("Restored detailed inventory data from save")
                        
                        # Update inventory ID in player state if needed
                        if not self._current_state.player.inventory_id and inv_manager.inventory_id:
                            self._current_state.player.inventory_id = inv_manager.inventory_id
                except Exception as e:
                    logger.warning(f"Error restoring detailed inventory data: {e}")
            
            # Restore quest data if available (future implementation)
            if 'detailed_quests' in data:
                try:
                    # This would set up the quest manager when implemented
                    if hasattr(self._current_state, 'quests'):
                        self._current_state.quests = data['detailed_quests']
                        logger.info("Restored detailed quest data from save")
                except Exception as e:
                    logger.warning(f"Error restoring quest data: {e}")
            
            # Connect inventory and stats managers for equipment modifier synchronization
            self._connect_inventory_and_stats_managers()
            
            # Explicitly ensure stats manager is initialized and signal is emitted
            self.ensure_stats_manager_initialized()

            # If we loaded during combat, rehydrate the combat UI and sync stats
            try:
                if self._current_state and getattr(self._current_state, 'current_mode', None) and \
                   self._current_state.current_mode.name == 'COMBAT' and \
                   getattr(self._current_state, 'combat_manager', None):
                    cm = self._current_state.combat_manager
                    # Ensure NPC StatsManagers are available/linked by loading NPC system state and prepping NPCs
                    try:
                        npc_system = self.get_npc_system()
                        if npc_system:
                            # Load NPCs from persistence if available (best effort)
                            try:
                                npc_system.load_state()
                            except Exception as e_load_npcs:
                                logger.warning(f"NPCSystem.load_state failed during load_game: {e_load_npcs}")
                            # Prepare each non-player entity for combat to guarantee StatsManagers exist (fallback by name)
                            try:
                                player_id = getattr(self._current_state.player, 'id', None) or getattr(self._current_state.player, 'stats_manager_id', None)
                                for entity_id, entity in getattr(cm, 'entities', {}).items():
                                    if entity_id != player_id:
                                        try:
                                            npc_system.prepare_npc_for_interaction(
                                                getattr(entity, 'name', None) or getattr(entity, 'combat_name', ''),
                                                NPCInteractionType.COMBAT
                                            )
                                        except Exception:
                                            # Best-effort per-entity; continue on errors
                                            continue
                            except Exception as e_prep:
                                logger.warning(f"Error preparing NPCs for combat after load: {e_prep}")
                    except Exception as e_link:
                        logger.warning(f"NPC StatsManager linkage step failed: {e_link}")
                    # Sync StatsManagers to saved CombatEntity values
                    try:
                        cm.sync_stats_with_managers_from_entities()
                    except Exception as e:
                        logger.warning(f"Failed to sync stats from combat entities after load: {e}")

                    # Queue a BUFFER_FLUSH to repopulate the Combat Log from display_log
                    try:
                        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                        from core.base.engine import get_game_engine
                        engine = get_game_engine()
                        # Bind orchestrator to the loaded CombatManager so resume signals work
                        try:
                            if hasattr(engine, '_combat_orchestrator') and cm is not None:
                                engine._combat_orchestrator.set_combat_manager(cm)
                                logger.info("Bound loaded CombatManager to CombatOutputOrchestrator.")
                        except Exception as bind_err:
                            logger.warning(f"Failed to bind CombatManager to orchestrator after load: {bind_err}")
                        html_snapshot = getattr(cm, 'display_log_html', "")
                        if html_snapshot:
                            set_event = DisplayEvent(
                                type=DisplayEventType.COMBAT_LOG_SET_HTML,
                                content=html_snapshot,
                                role='system',
                                target_display=DisplayTarget.COMBAT_LOG,
                                gradual_visual_display=False,
                                tts_eligible=False,
                                source_step='REHYDRATE_FROM_SAVE',
                                metadata={"session_id": self._current_state.session_id if self._current_state else None}
                            )
                            # Option A: enqueue synchronously to avoid cross-session leakage/race
                            try:
                                engine._combat_orchestrator.add_event_to_queue(set_event)
                            except Exception as e_enq:
                                logger.warning(f"Failed to enqueue COMBAT_LOG_SET_HTML synchronously: {e_enq}")
                        # Additionally, sync the player's resource bars (HP/MP/Stamina) via Phase 2 UI events
                        try:
                            from core.stats.stats_base import DerivedStatType
                            from core.combat.combat_entity import EntityType
                            player_entity_id = None
                            for eid, e in getattr(cm, 'entities', {}).items():
                                if getattr(e, 'entity_type', None) == EntityType.PLAYER:
                                    player_entity_id = eid
                                    break
                            sm_local = self.stats_manager
                            if player_entity_id and sm_local and hasattr(engine, '_combat_orchestrator'):
                                # Build and enqueue Phase 2 events for HP, Stamina, and Mana
                                try:
                                    hp_cur = sm_local.get_current_stat_value(DerivedStatType.HEALTH)
                                    hp_max = sm_local.get_stat_value(DerivedStatType.MAX_HEALTH)
                                    ev_hp = DisplayEvent(
                                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                        content={},
                                        metadata={"entity_id": player_entity_id, "bar_type": "hp", "final_new_value": hp_cur, "max_value": hp_max, "session_id": self._current_state.session_id if self._current_state else None},
                                        target_display=DisplayTarget.COMBAT_LOG,
                                        source_step='REHYDRATE_FROM_SAVE'
                                    )
                                    # Option A: enqueue synchronously
                                    try:
                                        engine._combat_orchestrator.add_event_to_queue(ev_hp)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                                try:
                                    stam_cur = sm_local.get_current_stat_value(DerivedStatType.STAMINA)
                                    stam_max = sm_local.get_stat_value(DerivedStatType.MAX_STAMINA)
                                    ev_st = DisplayEvent(
                                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                        content={},
                                        metadata={"entity_id": player_entity_id, "bar_type": "stamina", "final_new_value": stam_cur, "max_value": stam_max, "session_id": self._current_state.session_id if self._current_state else None},
                                        target_display=DisplayTarget.COMBAT_LOG,
                                        source_step='REHYDRATE_FROM_SAVE'
                                    )
                                    # Option A: enqueue synchronously
                                    try:
                                        engine._combat_orchestrator.add_event_to_queue(ev_st)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                                try:
                                    mana_cur = sm_local.get_current_stat_value(DerivedStatType.MANA)
                                    mana_max = sm_local.get_stat_value(DerivedStatType.MAX_MANA)
                                    ev_mp = DisplayEvent(
                                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                        content={},
                                        metadata={"entity_id": player_entity_id, "bar_type": "mana", "final_new_value": mana_cur, "max_value": mana_max, "session_id": self._current_state.session_id if self._current_state else None},
                                        target_display=DisplayTarget.COMBAT_LOG,
                                        source_step='REHYDRATE_FROM_SAVE'
                                    )
                                    # Option A: enqueue synchronously
                                    try:
                                        engine._combat_orchestrator.add_event_to_queue(ev_mp)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                        except Exception as e_syncbars:
                            logger.warning(f"Failed to enqueue player resource bar sync events after load: {e_syncbars}")
                    except Exception as e:
                        logger.warning(f"Failed to queue combat log rehydrate event: {e}")
            except Exception as e:
                logger.warning(f"Combat rehydrate block failed: {e}")
            
            logger.info(f"Game loaded from {load_path}")
            return self._current_state
        except Exception as e:
            logger.error(f"Error loading game: {e}")
            return None
    
    def get_available_saves(self) -> List[Dict[str, Any]]:
        """
        Get a list of available save files.
        
        Returns:
            A list of dictionaries with information about each save file.
        """
        saves = []
        
        try:
            for filename in os.listdir(self._saves_dir):
                if filename.endswith(".json"):
                    file_path = os.path.join(self._saves_dir, filename)
                    try:
                        # Get file info
                        stat = os.stat(file_path)
                        
                        # Try to read basic save info without loading the whole state
                        with open(file_path, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                            
                            # Extract basic info
                            save_info = {
                                "filename": filename,
                                "player_name": data.get("player", {}).get("name", "Unknown"),
                                "level": data.get("player", {}).get("level", 1),
                                "created_at": data.get("created_at", 0),
                                "last_saved_at": data.get("last_saved_at", 0),
                                "location": data.get("player", {}).get("current_location", "Unknown"),
                                "file_size": stat.st_size,
                                "mod_time": stat.st_mtime,
                                "is_auto_save": filename.startswith("auto_"),
                            }
                            
                            saves.append(save_info)
                    except Exception as e:
                        logger.warning(f"Error reading save file {filename}: {e}")
                        # Include basic file info even if we couldn't read the full save
                        saves.append({
                            "filename": filename,
                            "mod_time": os.path.getmtime(file_path),
                            "file_size": os.path.getsize(file_path),
                            "error": str(e),
                        })
        except Exception as e:
            logger.error(f"Error listing save files: {e}")
        
        # Sort by last modified time, newest first
        saves.sort(key=lambda x: x.get("mod_time", 0), reverse=True)
        
        return saves
    
    def delete_save(self, filename: str) -> bool:
        """
        Delete a save file.
        
        Args:
            filename: The name of the save file.
        
        Returns:
            True if the file was deleted, False otherwise.
        """
        # Ensure filename has .json extension
        if not filename.endswith(".json"):
            filename += ".json"
        
        # Delete the file
        try:
            file_path = os.path.join(self._saves_dir, filename)
            
            # Store file info for undo
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    self._last_deleted_save = {
                        "filename": filename,
                        "content": f.read(),
                    }
            
            # Delete the file
            os.remove(file_path)
            
            logger.info(f"Save file deleted: {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error deleting save file: {e}")
            return False
    
    def undo_delete(self) -> bool:
        """
        Undo the last save file deletion.
        
        Returns:
            True if the deletion was undone, False otherwise.
        """
        if self._last_deleted_save is None:
            logger.warning("No save file deletion to undo")
            return False
        
        try:
            filename = self._last_deleted_save["filename"]
            content = self._last_deleted_save["content"]
            
            file_path = os.path.join(self._saves_dir, filename)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.info(f"Restored deleted save file: {file_path}")
            
            # Clear the stored deleted save
            self._last_deleted_save = None
            
            return True
        except Exception as e:
            logger.error(f"Error restoring deleted save file: {e}")
            return False

    def initialize_memory_context(self, game_state: GameState) -> None:
        """
        Initialize memory and context system for a new game state.
        
        This is a stub method that will be implemented when the memory/context
        system is fully developed. For now, it does nothing but log the call.
        
        Args:
            game_state: The game state to initialize memory/context for.
        """
        logger.info("Memory/context initialization stub called (not fully implemented)")
        # Will be implemented when memory/context modules are added
    
    def get_memory_context_data(self) -> Optional[Dict[str, Any]]:
        """
        Get memory and context data for saving.
        
        This is a stub method that will be implemented when the memory/context
        system is fully developed. For now, it returns minimal placeholder data.
        
        Returns:
            A dictionary of memory/context data, or None if not available.
        """
        logger.info("Memory/context data retrieval stub called (not fully implemented)")
        # Placeholder for future implementation
        return {
            "version": "0.1.0",
            "memory_entries": [],
            "context_state": {}
        }
    
    def restore_memory_context_data(self, data: Dict[str, Any]) -> None:
        """
        Restore memory and context data from a save.
        
        This is a stub method that will be implemented when the memory/context
        system is fully developed. For now, it does nothing but log the call.
        
        Args:
            data: The memory/context data to restore.
        """
        logger.info("Memory/context restoration stub called (not fully implemented)")
        # Will be implemented when memory/context modules are added
    
    def _connect_inventory_and_stats_managers(self) -> None:
        """
        Connect the inventory manager and stats manager for equipment modifier synchronization.
        
        This establishes the bidirectional connection so that equipment changes
        automatically update stat modifiers.
        """
        try:
            # Get both managers
            stats_manager = self.stats_manager  # This property handles initialization
            
            if not stats_manager:
                logger.warning("Stats manager not available for inventory connection")
                return
            
            # Get inventory manager singleton
            from core.inventory.item_manager import get_inventory_manager
            inventory_manager = get_inventory_manager()
            
            if not inventory_manager:
                logger.warning("Inventory manager not available for stats connection")
                return
            
            # Establish bidirectional connection
            stats_manager.set_inventory_manager(inventory_manager)
            inventory_manager.set_stats_manager(stats_manager)
            
            # Trigger initial equipment modifier synchronization
            if hasattr(inventory_manager, '_equipment_modifiers') and inventory_manager._equipment_modifiers:
                stats_manager.sync_equipment_modifiers()
                logger.info("Initial equipment modifier synchronization completed")
            
            logger.info("Successfully connected inventory and stats managers")
            
        except Exception as e:
            logger.error(f"Error connecting inventory and stats managers: {e}", exc_info=True)


# Convenience function
def get_state_manager() -> StateManager:
    """Get the state manager instance."""
    return StateManager()

```

### File: core\base\state\stats_integration.py

```python
"""
Stats integration module for connecting the stats system to the GUI.

This module provides functionality to integrate the stats system with the GUI,
ensuring that the stats tab in the GUI is always up to date.
"""

import logging
from typing import Dict, Any, Optional, Callable
from PySide6.QtCore import QObject, Signal, Slot

from core.base.state.state_manager import StateManager, get_state_manager
from core.stats.stats_base import StatType, DerivedStatType, Stat

# Get module logger
logger = logging.getLogger("STATS_INTEGRATION")

class StatsIntegration(QObject):
    """
    Class for integrating stats with the GUI.
    
    This class provides signals for stats changes and methods for updating the GUI.
    It acts as a bridge between the stats system and the GUI.
    """
    
    # Signal emitted when stats change
    stats_changed = Signal(dict)
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(StatsIntegration, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the stats integration."""
        if self._initialized:
            return
            
        super().__init__()
        
        # State manager reference
        self._state_manager = get_state_manager()
        
        # Last known stats state
        self._last_stats = {}
        
        # Callbacks for specific stat changes
        self._stat_callbacks = {}
        
        self._initialized = True
        
        logger.info("Stats integration initialized")
    
    def update_gui(self):
        """
        Update the GUI with the current stats.
        
        This method retrieves the current stats from the stats manager
        and emits the stats_changed signal if they have changed.
        """
        if not self._state_manager or not self._state_manager.stats_manager:
            logger.debug("Stats manager not available")
            return
        
        try:
            # Get all stats
            current_stats = self._state_manager.stats_manager.get_all_stats()
            
            # Check if stats have changed
            if current_stats != self._last_stats:
                # Store the new stats
                self._last_stats = current_stats
                
                # Emit signal with the stats
                self.stats_changed.emit(current_stats)
                
                # Call any registered callbacks
                self._call_stat_callbacks(current_stats)
                
                logger.debug("Stats updated in GUI")
        except Exception as e:
            logger.error(f"Error updating stats in GUI: {e}")
    
    def register_stat_callback(self, stat_name: str, callback: Callable[[Any], None]):
        """
        Register a callback for a specific stat.
        
        Args:
            stat_name: The name of the stat (e.g., "strength", "health").
            callback: The callback function to call when the stat changes.
                     The function should take a single argument, which is the stat value.
        """
        if stat_name not in self._stat_callbacks:
            self._stat_callbacks[stat_name] = []
        
        self._stat_callbacks[stat_name].append(callback)
        logger.debug(f"Registered callback for stat: {stat_name}")
    
    def unregister_stat_callback(self, stat_name: str, callback: Callable[[Any], None]):
        """
        Unregister a callback for a specific stat.
        
        Args:
            stat_name: The name of the stat.
            callback: The callback function to unregister.
        """
        if stat_name in self._stat_callbacks:
            if callback in self._stat_callbacks[stat_name]:
                self._stat_callbacks[stat_name].remove(callback)
                logger.debug(f"Unregistered callback for stat: {stat_name}")
    
    def _call_stat_callbacks(self, stats: Dict[str, Dict[str, Dict[str, Any]]]):
        """
        Call registered callbacks for stats that have changed.
        
        Args:
            stats: The current stats dictionary.
        """
        # Iterate through all stat categories and stats
        for category, category_stats in stats.items():
            for stat_name, stat_info in category_stats.items():
                # Check if there are callbacks for this stat
                callbacks = self._stat_callbacks.get(stat_name.lower(), [])
                
                # Call each callback with the stat value
                for callback in callbacks:
                    try:
                        callback(stat_info)
                    except Exception as e:
                        logger.error(f"Error calling callback for stat {stat_name}: {e}")
    
    def attach_to_stat_manager(self):
        """
        Attach to the stats manager to receive updates.
        
        This method should be called after the stats manager is initialized.
        """
        try:
            from core.stats.stats_manager import StatsManager
            
            # Get stats manager instance
            stats_manager = self._state_manager.stats_manager
            
            if stats_manager:
                # Add this as an observer or hook into the stats manager's update methods
                # This will depend on how the stats manager is implemented
                
                # For now, we'll need to poll regularly or integrate with the stats manager
                # when it's fully implemented
                
                logger.info("Attached to stats manager")
                return True
            else:
                logger.warning("Stats manager not available")
                return False
        except Exception as e:
            logger.error(f"Error attaching to stats manager: {e}")
            return False


# Convenience function
def get_stats_integration() -> StatsIntegration:
    """Get the stats integration instance."""
    return StatsIntegration()

```

### File: core\base\state\world_state.py

```python
"""
World state for the RPG game.

This module provides the WorldState class for managing the game world.
"""

import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any

from core.utils.logging_config import get_logger
from core.utils.enhanced_time_manager import get_enhanced_time_manager

# Get the module logger
logger = get_logger("WORLD")

@dataclass
class WorldState:
    """
    World state information.
    
    This dataclass contains information about the game world,
    including time, weather, and global variables.
    """
    # Game time
    game_time: float = field(default_factory=time.time)  # Seconds since epoch
    game_date: str = "Day 1"  # In-game calendar date
    
    # World conditions
    weather: str = "Clear"
    is_day: bool = True
    
    # Special conditions
    magical_conditions: Dict[str, Any] = field(default_factory=dict)
    
    # Global variables (for quest states, world events, etc.)
    global_vars: Dict[str, Any] = field(default_factory=dict)
    
    # Active world events
    active_events: List[str] = field(default_factory=list)
    
    # For web server compatibility - will be updated by engine
    _current_location: str = ""
    
    @property
    def current_location(self) -> str:
        """
        Compatibility property for web server - returns the current location.
        This should be kept in sync with player.current_location.
        """
        return self._current_location
    
    @current_location.setter
    def current_location(self, value: str) -> None:
        """Set the current location."""
        self._current_location = value
    
    def advance_time(self, seconds: float) -> None:
        """
        Advance game time by the specified number of seconds.
        
        Args:
            seconds: Number of seconds to advance.
        """
        self.game_time += seconds
        
        # Update day/night cycle using enhanced time manager
        time_manager = get_enhanced_time_manager()
        self.is_day = time_manager.is_daylight_period(self.game_time)
    
    @property
    def time_of_day(self) -> str:
        """
        Get the current time of day as a narrative description.
        
        This replaces the old clock-based time display with rich narrative descriptions.
        
        Returns:
            A narrative description of the current time (e.g., "morning", "sunset", "deep night")
        """
        time_manager = get_enhanced_time_manager()
        season = self.get_global_var("current_season")
        return time_manager.get_time_description(self.game_time, "primary", season)
    
    @property 
    def atmospheric_time(self) -> str:
        """
        Get an atmospheric description of the current time for narrative contexts.
        
        Returns:
            An atmospheric time description (e.g., "as the first rays pierce the darkness")
        """
        time_manager = get_enhanced_time_manager()
        season = self.get_global_var("current_season")
        return time_manager.get_contextual_time(self.game_time, "narrative", season)
    
    @property
    def time_period_info(self) -> Dict[str, Any]:
        """
        Get comprehensive information about the current time period.
        
        Returns:
            Dictionary with detailed time period information
        """
        time_manager = get_enhanced_time_manager()
        return time_manager.get_period_info(self.game_time)
    
    def get_time_of_day(self) -> str:
        """
        Legacy method for backward compatibility.
        
        DEPRECATED: Use time_of_day property instead.
        This method now returns narrative time instead of clock time.
        """
        logger.warning("get_time_of_day() is deprecated, use time_of_day property instead")
        return self.time_of_day
    
    def update_weather(self, new_weather: str) -> None:
        """
        Update the current weather.
        
        Args:
            new_weather: The new weather condition.
        """
        self.weather = new_weather
        logger.info(f"Weather changed to {new_weather}")
    
    def set_global_var(self, key: str, value: Any) -> None:
        """
        Set a global variable.
        
        Args:
            key: The variable name.
            value: The variable value.
        """
        self.global_vars[key] = value
        logger.debug(f"Global variable {key} set to {value}")
    
    def get_global_var(self, key: str, default: Any = None) -> Any:
        """
        Get a global variable.
        
        Args:
            key: The variable name.
            default: The default value if the variable doesn't exist.
        
        Returns:
            The variable value, or the default if not found.
        """
        return self.global_vars.get(key, default)
    
    def add_event(self, event_id: str) -> None:
        """
        Add an active world event.
        
        Args:
            event_id: The ID of the event to add.
        """
        if event_id not in self.active_events:
            self.active_events.append(event_id)
            logger.info(f"World event added: {event_id}")
    
    def remove_event(self, event_id: str) -> None:
        """
        Remove an active world event.
        
        Args:
            event_id: The ID of the event to remove.
        """
        if event_id in self.active_events:
            self.active_events.remove(event_id)
            logger.info(f"World event removed: {event_id}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert WorldState to a dictionary for serialization."""
        return {
            "game_time": self.game_time,
            "game_date": self.game_date,
            "weather": self.weather,
            "is_day": self.is_day,
            "magical_conditions": self.magical_conditions,
            "global_vars": self.global_vars,
            "active_events": self.active_events,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldState':
        """Create a WorldState from a dictionary."""
        return cls(
            game_time=data.get("game_time", time.time()),
            game_date=data.get("game_date", "Day 1"),
            weather=data.get("weather", "Clear"),
            is_day=data.get("is_day", True),
            magical_conditions=data.get("magical_conditions", {}),
            global_vars=data.get("global_vars", {}),
            active_events=data.get("active_events", []),
        )

```

### File: world_configurator\config\skills.json

```json
{
  "skills": {
    "skills": {}
  }
}
```

### File: world_configurator\ui\editors\__init__.py

```python
"""
Editor components for the World Configurator Tool.
"""

```

### File: world_configurator\ui\editors\class_editor.py

```python
# world_configurator/ui/editors/class_editor.py
"""
Character Class editor component for the World Configurator Tool.
"""

import logging
import copy
from typing import Dict, List, Optional, Any

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QTabWidget,
    QGridLayout, QInputDialog
)

from ui.dialogs.base_dialog import BaseDialog
from models.base_models import CharacterClass, ClassArchetype
from models.world_data import ClassManager

logger = logging.getLogger("world_configurator.ui.class_editor")

# --- Helper Dialogs ---

class ArchetypeDialog(BaseDialog):
    """Dialog for editing a ClassArchetype."""
    def __init__(self, parent=None, archetype: Optional[ClassArchetype] = None):
        super().__init__(parent)
        self.setWindowTitle("Class Archetype")
        self.setMinimumWidth(450)

        self.archetype = archetype or ClassArchetype(name="New Archetype", description="", stat_distribution={})
        self.possible_stats = ["STR", "DEX", "CON", "INT", "WIS", "CHA"]

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.name_edit = QLineEdit(self.archetype.name)
        form.addRow("Name:", self.name_edit)

        self.desc_edit = QTextEdit(self.archetype.description)
        self.desc_edit.setMinimumHeight(80)
        form.addRow("Description:", self.desc_edit)

        # Stat Distribution
        form.addRow(QLabel("<b>Stat Distribution Preset:</b>"))
        stats_grid = QGridLayout()
        self.stat_spins: Dict[str, QSpinBox] = {}
        for i, stat in enumerate(self.possible_stats):
            label = QLabel(f"{stat}:")
            spin = QSpinBox()
            spin.setRange(0, 20) # Example range for stats
            spin.setValue(self.archetype.stat_distribution.get(stat, 8)) # Default 8?
            self.stat_spins[stat] = spin
            row, col = divmod(i, 3)
            stats_grid.addWidget(label, row, col * 2)
            stats_grid.addWidget(spin, row, col * 2 + 1)
        form.addRow(stats_grid)

        layout.addLayout(form)

        btn_layout = QHBoxLayout()
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        layout.addLayout(btn_layout)

    def get_archetype(self) -> ClassArchetype:
        self.archetype.name = self.name_edit.text()
        self.archetype.description = self.desc_edit.toPlainText()
        self.archetype.stat_distribution = {stat: spin.value() for stat, spin in self.stat_spins.items()}
        return self.archetype

# --- Main Class Dialog ---

class ClassDialog(QDialog):
    """Dialog for editing a CharacterClass."""
    def __init__(self, parent=None, char_class: Optional[CharacterClass] = None):
        super().__init__(parent)
        self.setWindowTitle("Class Editor")
        self.setMinimumWidth(650)
        self.setMinimumHeight(600)

        self.char_class = copy.deepcopy(char_class) if char_class else CharacterClass.create_new("New Class", "")
        self.possible_stats = ["STR", "DEX", "CON", "INT", "WIS", "CHA"]

        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Basic Info Tab
        basic_tab = QWidget()
        self.tabs.addTab(basic_tab, "Basic Info")
        basic_layout = QFormLayout(basic_tab)
        self.name_edit = QLineEdit(self.char_class.name)
        basic_layout.addRow("Name:", self.name_edit)
        self.desc_edit = QTextEdit(self.char_class.description)
        self.desc_edit.setMinimumHeight(100)
        basic_layout.addRow("Description:", self.desc_edit)

        # Stats Tab
        stats_tab = QWidget()
        self.tabs.addTab(stats_tab, "Stats")
        stats_layout = QVBoxLayout(stats_tab)
        stats_form = QFormLayout()
        # Stat Modifiers
        stats_form.addRow(QLabel("<b>Stat Modifiers:</b>"))
        mod_grid = QGridLayout()
        self.stat_mod_spins: Dict[str, QSpinBox] = {}
        for i, stat in enumerate(self.possible_stats):
            label = QLabel(f"{stat}:")
            spin = QSpinBox()
            spin.setRange(-5, 5)
            spin.setValue(self.char_class.stat_modifiers.get(stat, 0))
            self.stat_mod_spins[stat] = spin
            row, col = divmod(i, 3)
            mod_grid.addWidget(label, row, col * 2)
            mod_grid.addWidget(spin, row, col * 2 + 1)
        stats_form.addRow(mod_grid)
        # Minimum Stats
        stats_form.addRow(QLabel("<b>Minimum Stats:</b>"))
        min_grid = QGridLayout()
        self.min_stat_spins: Dict[str, QSpinBox] = {}
        for i, stat in enumerate(self.possible_stats):
            label = QLabel(f"{stat}:")
            spin = QSpinBox()
            spin.setRange(0, 20)
            spin.setValue(self.char_class.minimum_stats.get(stat, 0))
            spin.setSpecialValueText("None") # Show 0 as None
            self.min_stat_spins[stat] = spin
            row, col = divmod(i, 3)
            min_grid.addWidget(label, row, col * 2)
            min_grid.addWidget(spin, row, col * 2 + 1)
        stats_form.addRow(min_grid)
        stats_layout.addLayout(stats_form)

        # Recommendations Tab
        rec_tab = QWidget()
        self.tabs.addTab(rec_tab, "Recommendations")
        rec_layout = QFormLayout(rec_tab)
        rec_layout.addRow(QLabel("<b>Recommended Stats (comma-separated):</b>"))
        self.rec_primary_edit = QLineEdit(", ".join(self.char_class.recommended_stats.get("primary", [])))
        rec_layout.addRow("Primary:", self.rec_primary_edit)
        self.rec_secondary_edit = QLineEdit(", ".join(self.char_class.recommended_stats.get("secondary", [])))
        rec_layout.addRow("Secondary:", self.rec_secondary_edit)
        self.rec_tertiary_edit = QLineEdit(", ".join(self.char_class.recommended_stats.get("tertiary", [])))
        rec_layout.addRow("Tertiary:", self.rec_tertiary_edit)

        # Archetypes Tab
        arch_tab = QWidget()
        self.tabs.addTab(arch_tab, "Archetypes")
        arch_layout = QVBoxLayout(arch_tab)
        arch_layout.addWidget(QLabel("Class Archetypes:"))
        self.arch_list = QListWidget()
        self.arch_list.itemDoubleClicked.connect(self._edit_archetype)
        arch_layout.addWidget(self.arch_list)
        for arch_name, archetype in self.char_class.archetypes.items():
            self._add_archetype_to_list(archetype)
        arch_btns = QHBoxLayout()
        add_arch_btn = QPushButton("Add Archetype")
        add_arch_btn.clicked.connect(self._add_archetype)
        edit_arch_btn = QPushButton("Edit Archetype")
        edit_arch_btn.clicked.connect(lambda: self._edit_archetype(self.arch_list.currentItem()))
        remove_arch_btn = QPushButton("Remove Archetype")
        remove_arch_btn.clicked.connect(self._remove_archetype)
        arch_btns.addWidget(add_arch_btn)
        arch_btns.addWidget(edit_arch_btn)
        arch_btns.addWidget(remove_arch_btn)
        arch_layout.addLayout(arch_btns)

        # Proficiencies Tab
        prof_tab = QWidget()
        self.tabs.addTab(prof_tab, "Proficiencies")
        prof_layout = QFormLayout(prof_tab)
        prof_layout.addRow(QLabel("<b>Proficiencies (comma-separated):</b>"))
        self.weapon_prof_edit = QLineEdit(", ".join(self.char_class.weapon_proficiencies))
        prof_layout.addRow("Weapons:", self.weapon_prof_edit)
        self.armor_prof_edit = QLineEdit(", ".join(self.char_class.armor_proficiencies))
        prof_layout.addRow("Armor:", self.armor_prof_edit)

        # Dialog Buttons
        btn_layout = QHBoxLayout()
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        layout.addLayout(btn_layout)

    def _add_archetype_to_list(self, archetype: ClassArchetype):
        item = QListWidgetItem(f"{archetype.name}")
        item.setToolTip(archetype.description)
        item.setData(Qt.UserRole, archetype)
        self.arch_list.addItem(item)
        self.arch_list.sortItems()

    def _add_archetype(self):
        dialog = ArchetypeDialog(self)
        if dialog.exec() == QDialog.Accepted:
            new_arch = dialog.get_archetype()
            if new_arch.name in self.char_class.archetypes: # Check internal dict
                 QMessageBox.warning(self, "Duplicate Archetype", f"An archetype named '{new_arch.name}' already exists.")
                 return
            self._add_archetype_to_list(new_arch)
            self.char_class.archetypes[new_arch.name] = new_arch # Add to internal dict

    def _edit_archetype(self, item: Optional[QListWidgetItem]):
        if not item: item = self.arch_list.currentItem()
        if not item: return

        original_arch = item.data(Qt.UserRole)
        dialog = ArchetypeDialog(self, copy.deepcopy(original_arch))
        if dialog.exec() == QDialog.Accepted:
            updated_arch = dialog.get_archetype()

            # Check if name changed and conflicts
            if original_arch.name != updated_arch.name:
                if updated_arch.name in self.char_class.archetypes:
                    QMessageBox.warning(self, "Duplicate Archetype", f"An archetype named '{updated_arch.name}' already exists.")
                    return
                # Remove old name from internal dict
                if original_arch.name in self.char_class.archetypes:
                    del self.char_class.archetypes[original_arch.name]

            # Update item and internal dict
            item.setText(updated_arch.name)
            item.setToolTip(updated_arch.description)
            item.setData(Qt.UserRole, updated_arch)
            self.char_class.archetypes[updated_arch.name] = updated_arch
            self.arch_list.sortItems()

    def _remove_archetype(self):
        item = self.arch_list.currentItem()
        if not item: return
        archetype = item.data(Qt.UserRole)
        result = QMessageBox.question(self, "Confirm Removal", f"Remove archetype '{archetype.name}'?", QMessageBox.Yes | QMessageBox.No)
        if result == QMessageBox.Yes:
            if archetype.name in self.char_class.archetypes:
                del self.char_class.archetypes[archetype.name] # Remove from internal dict
            self.arch_list.takeItem(self.arch_list.row(item))

    def _parse_comma_list(self, text: str) -> List[str]:
        return [s.strip() for s in text.split(',') if s.strip()]

    def get_class(self) -> CharacterClass:
        self.char_class.name = self.name_edit.text()
        self.char_class.description = self.desc_edit.toPlainText()

        self.char_class.stat_modifiers = {stat: spin.value() for stat, spin in self.stat_mod_spins.items()}
        self.char_class.minimum_stats = {stat: spin.value() for stat, spin in self.min_stat_spins.items() if spin.value() > 0} # Only store non-zero minimums

        self.char_class.recommended_stats = {
            "primary": self._parse_comma_list(self.rec_primary_edit.text()),
            "secondary": self._parse_comma_list(self.rec_secondary_edit.text()),
            "tertiary": self._parse_comma_list(self.rec_tertiary_edit.text()),
        }

        # Archetypes are updated directly in the internal dict by add/edit/remove methods
        # self.char_class.archetypes = {}
        # for i in range(self.arch_list.count()):
        #     arch = self.arch_list.item(i).data(Qt.UserRole)
        #     self.char_class.archetypes[arch.name] = arch

        self.char_class.weapon_proficiencies = self._parse_comma_list(self.weapon_prof_edit.text())
        self.char_class.armor_proficiencies = self._parse_comma_list(self.armor_prof_edit.text())

        return self.char_class

# --- Main Editor Widget ---

class ClassEditor(QWidget):
    """Editor component for Character Classes."""
    class_modified = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.class_manager = ClassManager()
        self.current_class: Optional[CharacterClass] = None
        self._setup_ui()

    # Assistant integration
    def get_assistant_context(self):
        from assistant.context import AssistantContext
        allowed = [
            "/stat_modifiers",
            "/minimum_stats",
            "/recommended_stats",
            "/weapon_proficiencies",
            "/armor_proficiencies",
            "/description",
            "/archetypes",
        ]
        content = self.current_class.to_dict() if self.current_class else None
        return AssistantContext(
            domain="classes",
            selection_id=self.current_class.id if self.current_class else None,
            content=content,
            schema=None,
            allowed_paths=allowed,
        )

    def get_domain_examples(self):
        # Return first available class as exemplar
        if self.class_manager.classes:
            first = next(iter(self.class_manager.classes.values()))
            return [first.to_dict()]
        return []

    def get_reference_catalogs(self):
        # Provide known stat keys and possibly known prof lists from current data
        stat_keys = ["STR","DEX","CON","INT","WIS","CHA","WIL","INS"]
        known_weapons = sorted({w for c in self.class_manager.classes.values() for w in c.weapon_proficiencies})
        known_armors = sorted({a for c in self.class_manager.classes.values() for a in c.armor_proficiencies})
        existing_names = sorted({c.name for c in self.class_manager.classes.values() if c and c.name})
        existing_summaries = {c.name: c.description for c in self.class_manager.classes.values() if c and c.name}
        return {
            "stats": stat_keys,
            "weapon_proficiencies": known_weapons,
            "armor_proficiencies": known_armors,
            "existing_names": existing_names,
            "existing_summaries": existing_summaries,
        }

    def _sanitize_class_payload(self, payload: dict) -> dict:
        """Sanitize incoming class payload to fit CharacterClass schema.
        - For archetypes, drop unknown keys (e.g., 'abilities').
        - If 'abilities' provided, append them to description as text for preservation.
        """
        if not isinstance(payload, dict):
            return payload
        sanitized = dict(payload)
        arches = sanitized.get("archetypes")
        if isinstance(arches, dict):
            new_arches = {}
            for arch_name, arch_data in arches.items():
                if not isinstance(arch_data, dict):
                    new_arches[arch_name] = arch_data
                    continue
                desc = arch_data.get("description", "")
                # Preserve abilities by appending to description
                abilities = arch_data.get("abilities")
                if abilities:
                    if isinstance(abilities, list):
                        bullets = "\n".join(f"- {a}" for a in abilities if isinstance(a, str) and a.strip())
                    elif isinstance(abilities, str) and abilities.strip():
                        bullets = f"- {abilities.strip()}"
                    else:
                        bullets = ""
                    if bullets:
                        desc = (desc + ("\n\nAbilities:\n" if desc else "Abilities:\n") + bullets).strip()
                cleaned = {
                    "name": arch_data.get("name", arch_name),
                    "description": desc,
                    "stat_distribution": arch_data.get("stat_distribution", {}),
                }
                new_arches[arch_name] = cleaned
            sanitized["archetypes"] = new_arches
        return sanitized

    def apply_assistant_patch(self, patch_ops):
        from assistant.patching import apply_patch_with_validation
        from assistant.context import PatchOp
        ctx = self.get_assistant_context()
        if not ctx.content:
            return False, "No class selected."
        ok, msg, new_content = apply_patch_with_validation(ctx, ctx.content, patch_ops)
        if not ok:
            return False, msg
        try:
            new_content = self._sanitize_class_payload(new_content)
            # Map back to CharacterClass
            updated = CharacterClass.from_dict(new_content)
            updated.id = self.current_class.id  # preserve id
            self.class_manager.add_class(updated)
            # refresh UI
            self._load_class_display(updated)
            self.class_modified.emit()
            return True, "OK"
        except Exception as e:
            return False, f"Failed to apply: {e}"

    def create_entry_from_llm(self, entry: dict):
        try:
            # Ensure minimal required fields and unique name
            proposed_name = (entry.get("name") or "New Class").strip()
            existing_names = {c.name for c in self.class_manager.classes.values()}
            name = proposed_name
            suffix = 1
            while name in existing_names:
                name = f"{proposed_name} ({suffix})"
                suffix += 1
            desc = entry.get("description", "")
            new_cls = CharacterClass.create_new(name, desc)
            # Merge remaining fields
            tmp = new_cls.to_dict()
            tmp.update({k: v for k, v in entry.items() if k != "id" and k != "name"})
            tmp["name"] = name
            tmp = self._sanitize_class_payload(tmp)
            new_obj = CharacterClass.from_dict(tmp)
            new_obj.id = new_cls.id  # keep generated id
            self.class_manager.add_class(new_obj)
            self._refresh_class_list()
            # select new
            for i in range(self.class_list.count()):
                it = self.class_list.item(i)
                if self.class_manager.get_class(it.data(Qt.UserRole)).id == new_obj.id:
                    self.class_list.setCurrentItem(it)
                    break
            self.class_modified.emit()
            return True, "Created", new_obj.id
        except Exception as e:
            return False, f"Failed to create: {e}", None

    def _setup_ui(self):
        main_layout = QHBoxLayout(self)
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)

        # Left panel (List)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel("Classes", styleSheet="font-weight: bold; font-size: 14px;"))
        self.class_list = QListWidget()
        self.class_list.setMinimumWidth(200)
        self.class_list.currentItemChanged.connect(self._on_class_selected)
        left_layout.addWidget(self.class_list)
        list_btns = QHBoxLayout()
        self.add_btn = QPushButton("Add")
        self.add_btn.clicked.connect(self._add_class)
        self.edit_btn = QPushButton("Edit")
        self.edit_btn.clicked.connect(self._edit_class)
        self.edit_btn.setEnabled(False)
        self.remove_btn = QPushButton("Remove")
        self.remove_btn.clicked.connect(self._remove_class)
        self.remove_btn.setEnabled(False)
        list_btns.addWidget(self.add_btn)
        list_btns.addWidget(self.edit_btn)
        list_btns.addWidget(self.remove_btn)
        left_layout.addLayout(list_btns)
        splitter.addWidget(left_panel)

        # Right panel (Details - Read Only)
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)
        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)
        self.details_layout = QVBoxLayout(self.details_widget)

        self.details_form = QFormLayout()
        self.name_label = QLabel()
        self.name_label.setWordWrap(True)
        self.details_form.addRow("<b>Name:</b>", self.name_label)
        self.desc_label = QLabel()
        self.desc_label.setWordWrap(True)
        self.details_form.addRow("<b>Description:</b>", self.desc_label)
        self.details_layout.addLayout(self.details_form)

        self.details_layout.addWidget(QLabel("<b>Stat Modifiers:</b>", styleSheet="margin-top: 10px;"))
        self.stats_mod_display_list = QListWidget()
        self.stats_mod_display_list.setEnabled(False)
        self.details_layout.addWidget(self.stats_mod_display_list)

        self.details_layout.addWidget(QLabel("<b>Minimum Stats:</b>", styleSheet="margin-top: 5px;"))
        self.min_stats_display_list = QListWidget()
        self.min_stats_display_list.setEnabled(False)
        self.details_layout.addWidget(self.min_stats_display_list)

        self.details_layout.addWidget(QLabel("<b>Archetypes:</b>", styleSheet="margin-top: 10px;"))
        self.arch_display_list = QListWidget()
        self.arch_display_list.setEnabled(False)
        self.details_layout.addWidget(self.arch_display_list)

        self.details_layout.addWidget(QLabel("<b>Proficiencies:</b>", styleSheet="margin-top: 10px;"))
        self.prof_display_list = QListWidget()
        self.prof_display_list.setEnabled(False)
        self.details_layout.addWidget(self.prof_display_list)

        self.details_layout.addStretch()
        splitter.addWidget(right_panel)

        self._disable_details_display()
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)

    def set_class_manager(self, manager: ClassManager):
        self.class_manager = manager
        self._refresh_class_list()

    def _refresh_class_list(self):
        current_id = self.class_list.currentItem().data(Qt.UserRole) if self.class_list.currentItem() else None
        self.class_list.clear()
        items_to_add = []
        for class_id, char_class in self.class_manager.classes.items():
            item = QListWidgetItem(char_class.name)
            item.setData(Qt.UserRole, class_id)
            items_to_add.append(item)
        items_to_add.sort(key=lambda x: x.text())
        new_selection = None
        for item in items_to_add:
            self.class_list.addItem(item)
            if item.data(Qt.UserRole) == current_id:
                new_selection = item

        if new_selection:
            self.class_list.setCurrentItem(new_selection)
        elif self.class_list.count() > 0:
            self.class_list.setCurrentRow(0)
        else:
            self._disable_details_display()
            self.edit_btn.setEnabled(False)
            self.remove_btn.setEnabled(False)

    def _on_class_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]):
        if current:
            class_id = current.data(Qt.UserRole)
            char_class = self.class_manager.get_class(class_id)
            if char_class:
                self._load_class_display(char_class)
                self.edit_btn.setEnabled(True)
                self.remove_btn.setEnabled(True)
                return
        self._disable_details_display()
        self.edit_btn.setEnabled(False)
        self.remove_btn.setEnabled(False)

    def _load_class_display(self, char_class: CharacterClass):
        self.current_class = char_class
        self.name_label.setText(char_class.name or "N/A")
        self.desc_label.setText(char_class.description or "N/A")

        self.stats_mod_display_list.clear()
        for stat, mod in char_class.stat_modifiers.items():
            if mod != 0:
                sign = "+" if mod > 0 else ""
                self.stats_mod_display_list.addItem(f"{stat}: {sign}{mod}")

        self.min_stats_display_list.clear()
        for stat, val in char_class.minimum_stats.items():
             if val > 0:
                self.min_stats_display_list.addItem(f"{stat}: {val}")

        self.arch_display_list.clear()
        for arch_name, archetype in char_class.archetypes.items():
            item = QListWidgetItem(arch_name)
            item.setToolTip(archetype.description)
            self.arch_display_list.addItem(item)

        self.prof_display_list.clear()
        if char_class.weapon_proficiencies:
            self.prof_display_list.addItem(f"Weapons: {', '.join(char_class.weapon_proficiencies)}")
        if char_class.armor_proficiencies:
            self.prof_display_list.addItem(f"Armor: {', '.join(char_class.armor_proficiencies)}")

        self.details_widget.setEnabled(True)

    def _disable_details_display(self):
        self.current_class = None
        self.name_label.clear()
        self.desc_label.clear()
        self.stats_mod_display_list.clear()
        self.min_stats_display_list.clear()
        self.arch_display_list.clear()
        self.prof_display_list.clear()
        self.details_widget.setEnabled(False)

    def _add_class(self):
        dialog = ClassDialog(self)
        if dialog.exec() == QDialog.Accepted:
            new_class = dialog.get_class()
            if not new_class.id: new_class.id = CharacterClass.generate_id() # Should be handled by create_new
            self.class_manager.add_class(new_class)
            self._refresh_class_list()
            items = self.class_list.findItems(new_class.name, Qt.MatchExactly)
            if items: self.class_list.setCurrentItem(items[0])
            self.class_modified.emit()
            logger.info(f"Added class: {new_class.name}")

    def _edit_class(self):
        if not self.current_class: return
        dialog = ClassDialog(self, self.current_class)
        if dialog.exec() == QDialog.Accepted:
            edited_class = dialog.get_class()
            edited_class.id = self.current_class.id
            self.class_manager.add_class(edited_class)
            self._refresh_class_list()
            self.class_modified.emit()
            logger.info(f"Edited class: {edited_class.name}")

    def _remove_class(self):
        if not self.current_class: return
        result = QMessageBox.question(self, "Confirm Deletion", f"Delete class '{self.current_class.name}'?", QMessageBox.Yes | QMessageBox.No)
        if result == QMessageBox.Yes:
            removed = self.class_manager.remove_class(self.current_class.id)
            if removed:
                self._refresh_class_list()
                self.class_modified.emit()
                logger.info(f"Removed class: {self.current_class.name}")
            else:
                 QMessageBox.critical(self, "Error", "Failed to remove class.")


```

### File: world_configurator\ui\editors\culture_editor.py

```python
"""
Culture editor component for the World Configurator Tool.
"""

import logging
from typing import Dict, List, Optional, Callable

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame
)

from models.base_models import Culture, CultureValue, Tradition
from models.world_data import CultureManager

logger = logging.getLogger("world_configurator.ui.culture_editor")

class ValueDialog(QDialog):
    """Dialog for editing a cultural value."""
    
    def __init__(self, parent=None, value: Optional[CultureValue] = None):
        """
        Initialize the value edit dialog.
        
        Args:
            parent: The parent widget.
            value: Optional existing value to edit.
        """
        super().__init__(parent)
        self.setWindowTitle("Cultural Value")
        self.setMinimumWidth(400)
        
        # Value to edit
        self.value = value or CultureValue("", "")
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for fields
        form = QFormLayout()
        
        # Name field
        self.name_edit = QLineEdit(self.value.name)
        form.addRow("Name:", self.name_edit)
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.value.description)
        self.desc_edit.setMinimumHeight(100)
        form.addRow("Description:", self.desc_edit)
        
        # Importance field
        self.importance_spin = QSpinBox()
        self.importance_spin.setRange(1, 10)
        self.importance_spin.setValue(self.value.importance)
        self.importance_spin.setToolTip("1 = Least important, 10 = Most important")
        form.addRow("Importance:", self.importance_spin)
        
        layout.addLayout(form)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def get_value(self) -> CultureValue:
        """Get the edited value."""
        self.value.name = self.name_edit.text()
        self.value.description = self.desc_edit.toPlainText()
        self.value.importance = self.importance_spin.value()
        return self.value

class TraditionDialog(QDialog):
    """Dialog for editing a cultural tradition."""
    
    def __init__(self, parent=None, tradition: Optional[Tradition] = None):
        """
        Initialize the tradition edit dialog.
        
        Args:
            parent: The parent widget.
            tradition: Optional existing tradition to edit.
        """
        super().__init__(parent)
        self.setWindowTitle("Cultural Tradition")
        self.setMinimumWidth(400)
        
        # Tradition to edit
        self.tradition = tradition or Tradition("", "", "", "")
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for fields
        form = QFormLayout()
        
        # Name field
        self.name_edit = QLineEdit(self.tradition.name)
        form.addRow("Name:", self.name_edit)
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.tradition.description)
        self.desc_edit.setMinimumHeight(80)
        form.addRow("Description:", self.desc_edit)
        
        # Occasion field
        self.occasion_edit = QLineEdit(self.tradition.occasion)
        form.addRow("Occasion:", self.occasion_edit)
        
        # Significance field
        self.significance_edit = QTextEdit()
        self.significance_edit.setPlainText(self.tradition.significance)
        self.significance_edit.setMinimumHeight(80)
        form.addRow("Significance:", self.significance_edit)
        
        layout.addLayout(form)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def get_tradition(self) -> Tradition:
        """Get the edited tradition."""
        self.tradition.name = self.name_edit.text()
        self.tradition.description = self.desc_edit.toPlainText()
        self.tradition.occasion = self.occasion_edit.text()
        self.tradition.significance = self.significance_edit.toPlainText()
        return self.tradition

class CultureEditor(QWidget):
    """Culture editor component."""
    
    # Signals
    culture_modified = Signal()
    
    def __init__(self, parent=None):
        """
        Initialize the culture editor.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        # Internal state
        self.culture_manager = CultureManager()
        self.current_culture: Optional[Culture] = None
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the editor UI."""
        main_layout = QHBoxLayout(self)
        
        # Create a splitter for resizable panels
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)
        
        # Left panel (culture list)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        list_label = QLabel("Cultures")
        list_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        left_layout.addWidget(list_label)
        
        self.culture_list = QListWidget()
        self.culture_list.setMinimumWidth(200)
        self.culture_list.currentItemChanged.connect(self._on_culture_selected)
        left_layout.addWidget(self.culture_list)
        
        list_buttons = QHBoxLayout()
        
        self.add_culture_btn = QPushButton("Add")
        self.add_culture_btn.clicked.connect(self._add_culture)
        list_buttons.addWidget(self.add_culture_btn)
        
        self.remove_culture_btn = QPushButton("Remove")
        self.remove_culture_btn.clicked.connect(self._remove_culture)
        self.remove_culture_btn.setEnabled(False)
        list_buttons.addWidget(self.remove_culture_btn)
        
        left_layout.addLayout(list_buttons)
        
        # Add left panel to splitter
        splitter.addWidget(left_panel)
        
        # Right panel (culture details)
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)
        
        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)
        
        self.details_layout = QVBoxLayout(self.details_widget)
        
        # Culture details form
        self.form_layout = QFormLayout()
        
        # Culture name
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Enter culture name")
        self.name_edit.textChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Name:", self.name_edit)
        
        # Culture description
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlaceholderText("Enter culture description")
        self.desc_edit.textChanged.connect(self._on_field_changed)
        self.desc_edit.setMinimumHeight(100)
        self.form_layout.addRow("Description:", self.desc_edit)
        
        # Language style
        self.language_edit = QLineEdit()
        self.language_edit.setPlaceholderText("Describe the language style")
        self.language_edit.textChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Language Style:", self.language_edit)
        
        self.details_layout.addLayout(self.form_layout)
        
        # Values section
        values_label = QLabel("Cultural Values")
        values_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(values_label)
        
        self.values_list = QListWidget()
        self.values_list.setMinimumHeight(150)
        self.values_list.itemDoubleClicked.connect(self._edit_value)
        self.details_layout.addWidget(self.values_list)
        
        values_buttons = QHBoxLayout()
        
        self.add_value_btn = QPushButton("Add Value")
        self.add_value_btn.clicked.connect(self._add_value)
        values_buttons.addWidget(self.add_value_btn)
        
        self.edit_value_btn = QPushButton("Edit Value")
        self.edit_value_btn.clicked.connect(lambda: self._edit_value(self.values_list.currentItem()))
        values_buttons.addWidget(self.edit_value_btn)
        
        self.remove_value_btn = QPushButton("Remove Value")
        self.remove_value_btn.clicked.connect(self._remove_value)
        values_buttons.addWidget(self.remove_value_btn)
        
        self.details_layout.addLayout(values_buttons)
        
        # Traditions section
        traditions_label = QLabel("Cultural Traditions")
        traditions_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(traditions_label)
        
        self.traditions_list = QListWidget()
        self.traditions_list.setMinimumHeight(150)
        self.traditions_list.itemDoubleClicked.connect(self._edit_tradition)
        self.details_layout.addWidget(self.traditions_list)
        
        traditions_buttons = QHBoxLayout()
        
        self.add_tradition_btn = QPushButton("Add Tradition")
        self.add_tradition_btn.clicked.connect(self._add_tradition)
        traditions_buttons.addWidget(self.add_tradition_btn)
        
        self.edit_tradition_btn = QPushButton("Edit Tradition")
        self.edit_tradition_btn.clicked.connect(lambda: self._edit_tradition(self.traditions_list.currentItem()))
        traditions_buttons.addWidget(self.edit_tradition_btn)
        
        self.remove_tradition_btn = QPushButton("Remove Tradition")
        self.remove_tradition_btn.clicked.connect(self._remove_tradition)
        traditions_buttons.addWidget(self.remove_tradition_btn)
        
        self.details_layout.addLayout(traditions_buttons)
        
        # Save button
        save_layout = QHBoxLayout()
        save_layout.addStretch()
        
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self._save_current_culture)
        self.save_btn.setEnabled(False)
        save_layout.addWidget(self.save_btn)
        
        self.details_layout.addLayout(save_layout)
        
        # Add right panel to splitter
        splitter.addWidget(right_panel)
        
        # Set up initial state
        self._disable_details()
        
        # Prioritize the details panel for resizing
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
    
    def set_culture_manager(self, manager: CultureManager) -> None:
        """
        Set the culture manager to use.
        
        Args:
            manager: The culture manager.
        """
        self.culture_manager = manager
        self._refresh_culture_list()
    
    def _refresh_culture_list(self) -> None:
        """Refresh the culture list from the manager."""
        # Clear list
        self.culture_list.clear()
        
        # Add all cultures
        for culture_id, culture in self.culture_manager.cultures.items():
            item = QListWidgetItem(culture.name)
            item.setData(Qt.UserRole, culture_id)
            self.culture_list.addItem(item)
        
        # Sort alphabetically
        self.culture_list.sortItems()
        
        # Select the first item if available
        if self.culture_list.count() > 0:
            self.culture_list.setCurrentRow(0)
    
    def _on_culture_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]) -> None:
        """
        Handle culture selection change.
        
        Args:
            current: The current selected item, or None.
            previous: The previously selected item, or None.
        """
        if current:
            culture_id = current.data(Qt.UserRole)
            culture = self.culture_manager.get_culture(culture_id)
            
            if culture:
                self._load_culture(culture)
                self.remove_culture_btn.setEnabled(True)
                return
        
        # No valid selection
        self._disable_details()
        self.remove_culture_btn.setEnabled(False)
    
    def _load_culture(self, culture: Culture) -> None:
        """
        Load a culture into the editor.
        
        Args:
            culture: The culture to load.
        """
        try:
            self.current_culture = culture
            
            # Set form values
            self.name_edit.setText(culture.name)
            self.desc_edit.setPlainText(culture.description)
            self.language_edit.setText(culture.language_style)
            
            # Load values
            self.values_list.clear()
            for value in culture.values:
                # Ensure value is a CultureValue object
                if hasattr(value, 'name') and hasattr(value, 'importance'):
                    value_name = value.name
                    importance = value.importance
                elif isinstance(value, dict) and 'name' in value:
                    # Convert dict to CultureValue if needed
                    from world_configurator.models.base_models import CultureValue
                    value = CultureValue(
                        name=value.get('name', ''),
                        description=value.get('description', ''),
                        importance=value.get('importance', 5)
                    )
                    value_name = value.get('name', 'Unknown Value')
                    importance = value.get('importance', 5)
                else:
                    logger.warning(f"Skipping invalid value in culture {culture.name}: {value}")
                    continue
                    
                item = QListWidgetItem(f"{value_name} (Importance: {importance})")
                item.setData(Qt.UserRole, value)
                self.values_list.addItem(item)
            
            # Load traditions
            self.traditions_list.clear()
            for tradition in culture.traditions:
                # Ensure tradition is a Tradition object
                if hasattr(tradition, 'name'):
                    tradition_name = tradition.name
                elif isinstance(tradition, dict) and 'name' in tradition:
                    # Convert dict to Tradition if needed
                    from world_configurator.models.base_models import Tradition
                    tradition = Tradition(
                        name=tradition.get('name', ''),
                        description=tradition.get('description', ''),
                        occasion=tradition.get('occasion', ''),
                        significance=tradition.get('significance', '')
                    )
                    tradition_name = tradition.get('name', 'Unknown Tradition')
                else:
                    logger.warning(f"Skipping invalid tradition in culture {culture.name}: {tradition}")
                    continue
                    
                item = QListWidgetItem(tradition_name)
                item.setData(Qt.UserRole, tradition)
                self.traditions_list.addItem(item)
            
            # Enable controls
            self._enable_details()
            self.save_btn.setEnabled(False)  # Initially not modified
            
        except Exception as e:
            logger.error(f"Error loading culture {culture.name}: {str(e)}")
            QMessageBox.warning(
                self,
                "Error Loading Culture",
                f"There was an error loading the culture '{culture.name}':\n\n{str(e)}\n\nSome data may not be displayed correctly."
            )
            # Still enable the editor to allow fixing the issue
            self._enable_details()
            self.save_btn.setEnabled(True)  # Enable saving to fix issues
    
    def _disable_details(self) -> None:
        """Disable all detail controls."""
        self.current_culture = None
        
        self.name_edit.clear()
        self.desc_edit.clear()
        self.language_edit.clear()
        
        self.values_list.clear()
        self.traditions_list.clear()
        
        self.name_edit.setEnabled(False)
        self.desc_edit.setEnabled(False)
        self.language_edit.setEnabled(False)
        
        self.values_list.setEnabled(False)
        self.traditions_list.setEnabled(False)
        
        self.add_value_btn.setEnabled(False)
        self.edit_value_btn.setEnabled(False)
        self.remove_value_btn.setEnabled(False)
        
        self.add_tradition_btn.setEnabled(False)
        self.edit_tradition_btn.setEnabled(False)
        self.remove_tradition_btn.setEnabled(False)
        
        self.save_btn.setEnabled(False)
    
    def _enable_details(self) -> None:
        """Enable all detail controls."""
        self.name_edit.setEnabled(True)
        self.desc_edit.setEnabled(True)
        self.language_edit.setEnabled(True)
        
        self.values_list.setEnabled(True)
        self.traditions_list.setEnabled(True)
        
        self.add_value_btn.setEnabled(True)
        self.edit_value_btn.setEnabled(True)
        self.remove_value_btn.setEnabled(True)
        
        self.add_tradition_btn.setEnabled(True)
        self.edit_tradition_btn.setEnabled(True)
        self.remove_tradition_btn.setEnabled(True)
    
    def _on_field_changed(self) -> None:
        """Handle field value changes."""
        if self.current_culture:
            self.save_btn.setEnabled(True)
    
    def _save_current_culture(self) -> None:
        """Save the current culture to the manager."""
        if not self.current_culture:
            return
        
        # Update culture from form
        self.current_culture.name = self.name_edit.text()
        self.current_culture.description = self.desc_edit.toPlainText()
        self.current_culture.language_style = self.language_edit.text()
        
        # Update values
        self.current_culture.values = []
        for i in range(self.values_list.count()):
            item = self.values_list.item(i)
            value = item.data(Qt.UserRole)
            self.current_culture.values.append(value)
        
        # Update traditions
        self.current_culture.traditions = []
        for i in range(self.traditions_list.count()):
            item = self.traditions_list.item(i)
            tradition = item.data(Qt.UserRole)
            self.current_culture.traditions.append(tradition)
        
        # Update culture in manager
        self.culture_manager.add_culture(self.current_culture)
        
        # Mark as saved
        self.save_btn.setEnabled(False)
        
        # Update culture list
        self._refresh_culture_list()
        
        # Find and select the current culture in the list
        for i in range(self.culture_list.count()):
            item = self.culture_list.item(i)
            if item.data(Qt.UserRole) == self.current_culture.id:
                self.culture_list.setCurrentItem(item)
                break
        
        # Emit modified signal
        self.culture_modified.emit()
        
        # Log
        logger.info(f"Saved culture: {self.current_culture.name} ({self.current_culture.id})")
    
    def _add_culture(self) -> None:
        """Add a new culture."""
        # Create new culture
        culture = Culture.create_new("New Culture", "Description of the culture")
        
        # Add to manager
        self.culture_manager.add_culture(culture)
        
        # Refresh list
        self._refresh_culture_list()
        
        # Find and select the new culture
        for i in range(self.culture_list.count()):
            item = self.culture_list.item(i)
            if item.data(Qt.UserRole) == culture.id:
                self.culture_list.setCurrentItem(item)
                break
        
        # Set focus to name for immediate editing
        self.name_edit.setFocus()
        self.name_edit.selectAll()
        
        # Emit modified signal
        self.culture_modified.emit()
        
        # Log
        logger.info(f"Added new culture: {culture.id}")
    
    def _remove_culture(self) -> None:
        """Remove the selected culture."""
        current_item = self.culture_list.currentItem()
        if not current_item:
            return
        
        culture_id = current_item.data(Qt.UserRole)
        culture = self.culture_manager.get_culture(culture_id)
        
        if not culture:
            return
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the culture '{culture.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove from manager
        self.culture_manager.remove_culture(culture_id)
        
        # Refresh list
        self._refresh_culture_list()
        
        # Emit modified signal
        self.culture_modified.emit()
        
        # Log
        logger.info(f"Removed culture: {culture_id}")
    
    def _add_value(self) -> None:
        """Add a new cultural value."""
        if not self.current_culture:
            return
        
        # Create dialog
        dialog = ValueDialog(self)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get value from dialog
            value = dialog.get_value()
            
            # Add to list
            item = QListWidgetItem(f"{value.name} (Importance: {value.importance})")
            item.setData(Qt.UserRole, value)
            self.values_list.addItem(item)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Added value: {value.name}")
    
    def _edit_value(self, item: Optional[QListWidgetItem]) -> None:
        """
        Edit a cultural value.
        
        Args:
            item: The list item to edit, or None.
        """
        if not item:
            return
        
        # Get value from item
        value = item.data(Qt.UserRole)
        
        # Create dialog
        dialog = ValueDialog(self, value)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get updated value from dialog
            updated_value = dialog.get_value()
            
            # Update item
            item.setText(f"{updated_value.name} (Importance: {updated_value.importance})")
            item.setData(Qt.UserRole, updated_value)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Edited value: {updated_value.name}")
    
    def _remove_value(self) -> None:
        """Remove the selected cultural value."""
        item = self.values_list.currentItem()
        if not item:
            return
        
        # Get value from item
        value = item.data(Qt.UserRole)
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the value '{value.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove item
        self.values_list.takeItem(self.values_list.row(item))
        
        # Mark as modified
        self.save_btn.setEnabled(True)
        
        # Log
        logger.debug(f"Removed value: {value.name}")
    
    def _add_tradition(self) -> None:
        """Add a new cultural tradition."""
        if not self.current_culture:
            return
        
        # Create dialog
        dialog = TraditionDialog(self)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get tradition from dialog
            tradition = dialog.get_tradition()
            
            # Add to list
            item = QListWidgetItem(tradition.name)
            item.setData(Qt.UserRole, tradition)
            self.traditions_list.addItem(item)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Added tradition: {tradition.name}")
    
    def _edit_tradition(self, item: Optional[QListWidgetItem]) -> None:
        """
        Edit a cultural tradition.
        
        Args:
            item: The list item to edit, or None.
        """
        if not item:
            return
        
        # Get tradition from item
        tradition = item.data(Qt.UserRole)
        
        # Create dialog
        dialog = TraditionDialog(self, tradition)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get updated tradition from dialog
            updated_tradition = dialog.get_tradition()
            
            # Update item
            item.setText(updated_tradition.name)
            item.setData(Qt.UserRole, updated_tradition)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Edited tradition: {updated_tradition.name}")
    
    def _remove_tradition(self) -> None:
        """Remove the selected cultural tradition."""
        item = self.traditions_list.currentItem()
        if not item:
            return
        
        # Get tradition from item
        tradition = item.data(Qt.UserRole)
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the tradition '{tradition.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove item
        self.traditions_list.takeItem(self.traditions_list.row(item))
        
        # Mark as modified
        self.save_btn.setEnabled(True)
        
        # Log
        logger.debug(f"Removed tradition: {tradition.name}")

```

### File: world_configurator\ui\editors\history_editor.py

```python
"""
History editor component for the World Configurator Tool.
"""

import logging
from typing import Dict, List, Optional, Callable, Union

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QComboBox,
    QTableWidget, QTableWidgetItem, QHeaderView, QTabWidget, QGroupBox
)

from ui.dialogs.base_dialog import BaseDialog
from models.base_models import WorldHistory, Era, HistoricalEvent
from models.world_data import WorldHistoryManager

logger = logging.getLogger("world_configurator.ui.history_editor")

class EventDialog(BaseDialog):
    """Dialog for editing a historical event."""
    
    def __init__(self, parent=None, event: Optional[HistoricalEvent] = None,
                 affected_cultures: Optional[Dict[str, str]] = None,
                 affected_locations: Optional[Dict[str, str]] = None):
        """
        Initialize the event edit dialog.
        
        Args:
            parent: The parent widget.
            event: Optional existing event to edit.
            affected_cultures: Dictionary of culture IDs to names.
            affected_locations: Dictionary of location IDs to names.
        """
        super().__init__(parent)
        self.setWindowTitle("Historical Event")
        self.setMinimumWidth(500)
        
        # Event to edit
        self.event = event or HistoricalEvent(0, "", "")
        
        # Available selections
        self.affected_cultures = affected_cultures or {}
        self.affected_locations = affected_locations or {}
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for fields
        form = QFormLayout()
        
        # Year field
        self.year_spin = QSpinBox()
        self.year_spin.setRange(-10000, 10000)
        self.year_spin.setValue(self.event.year)
        form.addRow("Year:", self.year_spin)
        
        # Title field
        self.title_edit = QLineEdit(self.event.title)
        form.addRow("Title:", self.title_edit)
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.event.description)
        self.desc_edit.setMinimumHeight(100)
        form.addRow("Description:", self.desc_edit)
        
        # Significance field
        self.significance_edit = QTextEdit()
        self.significance_edit.setPlainText(self.event.significance)
        self.significance_edit.setMaximumHeight(60)
        form.addRow("Significance:", self.significance_edit)
        
        layout.addLayout(form)
        
        # Affected cultures
        cultures_group = QGroupBox("Affected Cultures")
        cultures_layout = QVBoxLayout(cultures_group)
        
        self.cultures_list = QListWidget()
        self.cultures_list.setSelectionMode(QListWidget.MultiSelection)
        cultures_layout.addWidget(self.cultures_list)
        
        # Add cultures to the list
        for culture_id, culture_name in self.affected_cultures.items():
            item = QListWidgetItem(culture_name)
            item.setData(Qt.UserRole, culture_id)
            self.cultures_list.addItem(item)
            
            # Select the item if it's in the event's affected cultures
            if culture_id in self.event.affected_cultures:
                item.setSelected(True)
        
        layout.addWidget(cultures_group)
        
        # Affected locations
        locations_group = QGroupBox("Affected Locations")
        locations_layout = QVBoxLayout(locations_group)
        
        self.locations_list = QListWidget()
        self.locations_list.setSelectionMode(QListWidget.MultiSelection)
        locations_layout.addWidget(self.locations_list)
        
        # Add locations to the list
        for location_id, location_name in self.affected_locations.items():
            item = QListWidgetItem(location_name)
            item.setData(Qt.UserRole, location_id)
            self.locations_list.addItem(item)
            
            # Select the item if it's in the event's affected locations
            if location_id in self.event.affected_locations:
                item.setSelected(True)
        
        layout.addWidget(locations_group)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def get_event(self) -> HistoricalEvent:
        """Get the edited event."""
        self.event.year = self.year_spin.value()
        self.event.title = self.title_edit.text()
        self.event.description = self.desc_edit.toPlainText()
        self.event.significance = self.significance_edit.toPlainText()
        
        # Update affected cultures
        self.event.affected_cultures = []
        for i in range(self.cultures_list.count()):
            item = self.cultures_list.item(i)
            if item.isSelected():
                self.event.affected_cultures.append(item.data(Qt.UserRole))
        
        # Update affected locations
        self.event.affected_locations = []
        for i in range(self.locations_list.count()):
            item = self.locations_list.item(i)
            if item.isSelected():
                self.event.affected_locations.append(item.data(Qt.UserRole))
        
        return self.event

class EraDialog(QDialog):
    """Dialog for editing a historical era."""
    
    def __init__(self, parent=None, era: Optional[Era] = None, event_dialog_factory=None):
        """
        Initialize the era edit dialog.
        
        Args:
            parent: The parent widget.
            era: Optional existing era to edit.
            event_dialog_factory: Function to create an event dialog.
        """
        super().__init__(parent)
        self.setWindowTitle("Historical Era")
        self.setMinimumWidth(600)
        self.setMinimumHeight(500)
        
        # Era to edit
        self.era = era or Era("", 0, 0, "")
        
        # Event dialog factory
        self.event_dialog_factory = event_dialog_factory or (lambda event: EventDialog(self, event))
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for basic fields
        form = QFormLayout()
        
        # Name field
        self.name_edit = QLineEdit(self.era.name)
        form.addRow("Name:", self.name_edit)
        
        # Year fields
        years_layout = QHBoxLayout()
        
        self.start_year_spin = QSpinBox()
        self.start_year_spin.setRange(-10000, 10000)
        self.start_year_spin.setValue(self.era.start_year)
        years_layout.addWidget(QLabel("Start Year:"))
        years_layout.addWidget(self.start_year_spin)
        
        self.end_year_spin = QSpinBox()
        self.end_year_spin.setRange(-10000, 10000)
        self.end_year_spin.setValue(self.era.end_year)
        years_layout.addWidget(QLabel("End Year:"))
        years_layout.addWidget(self.end_year_spin)
        
        form.addRow("Years:", years_layout)
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.era.description)
        self.desc_edit.setMinimumHeight(80)
        form.addRow("Description:", self.desc_edit)
        
        layout.addLayout(form)
        
        # Events section
        events_group = QGroupBox("Historical Events")
        events_layout = QVBoxLayout(events_group)
        
        # Events table
        self.events_table = QTableWidget(0, 2)  # 2 columns: Year and Title
        self.events_table.setHorizontalHeaderLabels(["Year", "Title"])
        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.events_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.events_table.setSelectionMode(QTableWidget.SingleSelection)
        self.events_table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.events_table.doubleClicked.connect(self._edit_event)
        
        # Add events to the table
        self._refresh_events_table()
        
        events_layout.addWidget(self.events_table)
        
        # Event buttons
        event_buttons = QHBoxLayout()
        
        self.add_event_btn = QPushButton("Add Event")
        self.add_event_btn.clicked.connect(self._add_event)
        event_buttons.addWidget(self.add_event_btn)
        
        self.edit_event_btn = QPushButton("Edit Event")
        self.edit_event_btn.clicked.connect(lambda: self._edit_event(None))
        event_buttons.addWidget(self.edit_event_btn)
        
        self.remove_event_btn = QPushButton("Remove Event")
        self.remove_event_btn.clicked.connect(self._remove_event)
        event_buttons.addWidget(self.remove_event_btn)
        
        events_layout.addLayout(event_buttons)
        
        layout.addWidget(events_group)
        
        # Dialog buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def _refresh_events_table(self):
        """Refresh the events table."""
        self.events_table.setRowCount(0)
        
        for i, event in enumerate(sorted(self.era.events, key=lambda e: e.year)):
            self.events_table.insertRow(i)
            
            year_item = QTableWidgetItem(str(event.year))
            year_item.setData(Qt.UserRole, event)
            self.events_table.setItem(i, 0, year_item)
            
            title_item = QTableWidgetItem(event.title)
            self.events_table.setItem(i, 1, title_item)
    
    def _add_event(self):
        """Add a new event to the era."""
        # Create a new event with the era's start year as default
        event = HistoricalEvent(self.start_year_spin.value(), "New Event", "")
        
        # Show the event dialog
        dialog = self.event_dialog_factory(event)
        
        if dialog.exec() == QDialog.Accepted:
            # Get the event from the dialog
            event = dialog.get_event()
            
            # Add to era's events
            self.era.events.append(event)
            
            # Refresh the table
            self._refresh_events_table()
    
    def _edit_event(self, index=None):
        """Edit an event in the era."""
        # Get the selected event
        if index and index.isValid():
            row = index.row()
        else:
            rows = self.events_table.selectionModel().selectedRows()
            if not rows:
                return
            row = rows[0].row()
        
        # Get the event from the first column
        event = self.events_table.item(row, 0).data(Qt.UserRole)
        
        # Show the event dialog
        dialog = self.event_dialog_factory(event)
        
        if dialog.exec() == QDialog.Accepted:
            # Get the updated event
            updated_event = dialog.get_event()
            
            # Find and update the event in the era
            for i, e in enumerate(self.era.events):
                if e is event:  # Check identity, not just equality
                    self.era.events[i] = updated_event
                    break
            
            # Refresh the table
            self._refresh_events_table()
    
    def _remove_event(self):
        """Remove an event from the era."""
        # Get the selected event
        rows = self.events_table.selectionModel().selectedRows()
        if not rows:
            return
        
        row = rows[0].row()
        event = self.events_table.item(row, 0).data(Qt.UserRole)
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the event '{event.title}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove from era's events
        self.era.events.remove(event)
        
        # Refresh the table
        self._refresh_events_table()
    
    def get_era(self) -> Era:
        """Get the edited era."""
        self.era.name = self.name_edit.text()
        self.era.start_year = self.start_year_spin.value()
        self.era.end_year = self.end_year_spin.value()
        self.era.description = self.desc_edit.toPlainText()
        
        return self.era

class HistoryEditor(QWidget):
    """History editor component."""
    
    # Signals
    history_modified = Signal()
    
    def __init__(self, parent=None):
        """
        Initialize the history editor.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        # Internal state
        self.history_manager = WorldHistoryManager()
        self.culture_manager = None
        self.location_manager = None
        self.current_history: Optional[WorldHistory] = None
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the editor UI."""
        main_layout = QVBoxLayout(self)
        
        # World history details section
        details_group = QGroupBox("World History Details")
        details_layout = QFormLayout(details_group)
        
        # World name
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Enter world name")
        self.name_edit.textChanged.connect(self._on_field_changed)
        details_layout.addRow("World Name:", self.name_edit)
        
        # Description
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlaceholderText("Enter world description")
        self.desc_edit.textChanged.connect(self._on_field_changed)
        self.desc_edit.setMaximumHeight(80)
        details_layout.addRow("Description:", self.desc_edit)
        
        # Current year
        self.year_spin = QSpinBox()
        self.year_spin.setRange(-10000, 10000)
        self.year_spin.valueChanged.connect(self._on_field_changed)
        details_layout.addRow("Current Year:", self.year_spin)
        
        main_layout.addWidget(details_group)
        
        # Eras section
        eras_group = QGroupBox("Historical Eras")
        eras_layout = QVBoxLayout(eras_group)
        
        # Eras table
        self.eras_table = QTableWidget(0, 3)  # 3 columns: Name, Period, Description
        self.eras_table.setHorizontalHeaderLabels(["Name", "Period", "Description"])
        self.eras_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.eras_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.eras_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)
        self.eras_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.eras_table.setSelectionMode(QTableWidget.SingleSelection)
        self.eras_table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.eras_table.doubleClicked.connect(self._edit_era)
        eras_layout.addWidget(self.eras_table)
        
        # Eras buttons
        era_buttons = QHBoxLayout()
        
        self.add_era_btn = QPushButton("Add Era")
        self.add_era_btn.clicked.connect(self._add_era)
        era_buttons.addWidget(self.add_era_btn)
        
        self.edit_era_btn = QPushButton("Edit Era")
        self.edit_era_btn.clicked.connect(lambda: self._edit_era(None))
        era_buttons.addWidget(self.edit_era_btn)
        
        self.remove_era_btn = QPushButton("Remove Era")
        self.remove_era_btn.clicked.connect(self._remove_era)
        era_buttons.addWidget(self.remove_era_btn)
        
        eras_layout.addLayout(era_buttons)
        
        main_layout.addWidget(eras_group)
        
        # Save button
        save_layout = QHBoxLayout()
        save_layout.addStretch()
        
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self._save_current_history)
        self.save_btn.setEnabled(False)
        save_layout.addWidget(self.save_btn)
        
        main_layout.addLayout(save_layout)
        
        # Set up initial state
        self._disable_details()
    
    def set_managers(self, history_manager: WorldHistoryManager, 
                    culture_manager=None, location_manager=None) -> None:
        """
        Set the managers to use.
        
        Args:
            history_manager: The history manager.
            culture_manager: Optional culture manager for references.
            location_manager: Optional location manager for references.
        """
        self.history_manager = history_manager
        self.culture_manager = culture_manager
        self.location_manager = location_manager
        self.refresh()
    
    def refresh(self) -> None:
        """Refresh the editor from the manager."""
        # Check if there's a history to load
        if self.history_manager.history:
            self._load_history(self.history_manager.history)
        else:
            # Create a default history if none exists
            if QMessageBox.question(
                self,
                "No World History",
                "No world history found. Would you like to create a new one?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            ) == QMessageBox.Yes:
                self.history_manager.create_new_history("New World", "Description of your world", 1000)
                self._load_history(self.history_manager.history)
            else:
                self._disable_details()
    
    def _load_history(self, history: WorldHistory) -> None:
        """
        Load a world history into the editor.
        
        Args:
            history: The world history to load.
        """
        try:
            self.current_history = history
            
            # Set form values
            self.name_edit.setText(history.name)
            self.desc_edit.setPlainText(history.description)
            self.year_spin.setValue(history.current_year)
            
            # Load eras
            self._refresh_eras_table()
            
            # Enable controls
            self._enable_details()
            self.save_btn.setEnabled(False)  # Initially not modified
            
        except Exception as e:
            logger.error(f"Error loading history: {str(e)}")
            QMessageBox.warning(
                self,
                "Error Loading History",
                f"There was an error loading the world history:\n\n{str(e)}\n\nSome data may not be displayed correctly."
            )
            # Still enable the editor to allow fixing the issue
            self._enable_details()
            self.save_btn.setEnabled(True)  # Enable saving to fix issues
    
    def _refresh_eras_table(self):
        """Refresh the eras table."""
        self.eras_table.setRowCount(0)
        
        if not self.current_history:
            return
        
        for i, era in enumerate(sorted(self.current_history.eras, key=lambda e: e.start_year)):
            self.eras_table.insertRow(i)
            
            name_item = QTableWidgetItem(era.name)
            name_item.setData(Qt.UserRole, era)
            self.eras_table.setItem(i, 0, name_item)
            
            period_item = QTableWidgetItem(f"{era.start_year} to {era.end_year}")
            self.eras_table.setItem(i, 1, period_item)
            
            desc_item = QTableWidgetItem(era.description[:100] + ("..." if len(era.description) > 100 else ""))
            self.eras_table.setItem(i, 2, desc_item)
    
    def _disable_details(self) -> None:
        """Disable all detail controls."""
        self.current_history = None
        
        self.name_edit.clear()
        self.desc_edit.clear()
        self.year_spin.setValue(0)
        
        self.eras_table.setRowCount(0)
        
        self.name_edit.setEnabled(False)
        self.desc_edit.setEnabled(False)
        self.year_spin.setEnabled(False)
        
        self.eras_table.setEnabled(False)
        
        self.add_era_btn.setEnabled(False)
        self.edit_era_btn.setEnabled(False)
        self.remove_era_btn.setEnabled(False)
        
        self.save_btn.setEnabled(False)
    
    def _enable_details(self) -> None:
        """Enable all detail controls."""
        self.name_edit.setEnabled(True)
        self.desc_edit.setEnabled(True)
        self.year_spin.setEnabled(True)
        
        self.eras_table.setEnabled(True)
        
        self.add_era_btn.setEnabled(True)
        self.edit_era_btn.setEnabled(True)
        self.remove_era_btn.setEnabled(True)
    
    def _on_field_changed(self) -> None:
        """Handle field value changes."""
        if self.current_history:
            self.save_btn.setEnabled(True)
    
    def _save_current_history(self) -> None:
        """Save the current history to the manager."""
        if not self.current_history:
            return
        
        # Update history from form
        self.current_history.name = self.name_edit.text()
        self.current_history.description = self.desc_edit.toPlainText()
        self.current_history.current_year = self.year_spin.value()
        
        # Update history in manager
        self.history_manager.history = self.current_history
        self.history_manager.state.modified = True
        
        # Mark as saved
        self.save_btn.setEnabled(False)
        
        # Emit modified signal
        self.history_modified.emit()
        
        # Log
        logger.info(f"Saved world history: {self.current_history.name}")
    
    def _create_event_dialog(self, event: Optional[HistoricalEvent] = None) -> EventDialog:
        """
        Create an event dialog with the current cultures and locations.
        
        Args:
            event: Optional event to edit.
        
        Returns:
            The event dialog.
        """
        cultures = {}
        locations = {}
        
        # Add cultures if available
        if self.culture_manager:
            for culture_id, culture in self.culture_manager.cultures.items():
                cultures[culture_id] = culture.name
        
        # Add locations if available
        if self.location_manager:
            for location_id, location in self.location_manager.locations.items():
                locations[location_id] = location.name
        
        # Create and return the dialog
        return EventDialog(self, event, cultures, locations)
    
    def _add_era(self) -> None:
        """Add a new era to the history."""
        if not self.current_history:
            return
        
        # Create a new era
        era = Era("New Era", 0, 100, "Description of the era")
        
        # Show the era dialog
        dialog = EraDialog(self, era, self._create_event_dialog)
        
        if dialog.exec() == QDialog.Accepted:
            # Get the era from the dialog
            era = dialog.get_era()
            
            # Add to history's eras
            self.current_history.eras.append(era)
            
            # Refresh the table
            self._refresh_eras_table()
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Added era: {era.name}")
    
    def _edit_era(self, index=None) -> None:
        """
        Edit an era in the history.
        
        Args:
            index: The model index of the item to edit, or None.
        """
        if not self.current_history:
            return
        
        # Get the selected era
        if index and index.isValid():
            row = index.row()
        else:
            rows = self.eras_table.selectionModel().selectedRows()
            if not rows:
                return
            row = rows[0].row()
        
        # Get the era from the first column
        era = self.eras_table.item(row, 0).data(Qt.UserRole)
        
        # Show the era dialog
        dialog = EraDialog(self, era, self._create_event_dialog)
        
        if dialog.exec() == QDialog.Accepted:
            # Get the updated era
            updated_era = dialog.get_era()
            
            # Find and update the era in the history
            for i, e in enumerate(self.current_history.eras):
                if e is era:  # Check identity, not just equality
                    self.current_history.eras[i] = updated_era
                    break
            
            # Refresh the table
            self._refresh_eras_table()
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Edited era: {updated_era.name}")
    
    def _remove_era(self) -> None:
        """Remove an era from the history."""
        if not self.current_history:
            return
        
        # Get the selected era
        rows = self.eras_table.selectionModel().selectedRows()
        if not rows:
            return
        
        row = rows[0].row()
        era = self.eras_table.item(row, 0).data(Qt.UserRole)
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the era '{era.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove from history's eras
        self.current_history.eras.remove(era)
        
        # Refresh the table
        self._refresh_eras_table()
        
        # Mark as modified
        self.save_btn.setEnabled(True)
        
        # Log
        logger.debug(f"Removed era: {era.name}")

```

### File: world_configurator\ui\editors\item_editor_panel.py

```python
# world_configurator/ui/editors/item_editor_panel.py
"""
Main panel for managing different types of items.
"""

import logging
import os
from typing import Dict, Optional, Any

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QListWidget,
    QListWidgetItem, QSplitter, QFrame, QStackedWidget, QMessageBox
)

# Placeholder for individual item category editors
# from .specific_item_editor import SpecificItemEditor # Example, will be created later

logger = logging.getLogger("world_configurator.ui.item_editor_panel")

ITEM_CATEGORIES = {
    "Starting Items": "config/items/origin_items.json",
    "Weapon Templates": "config/items/base_weapons.json",
    "Armor Templates": "config/items/base_armor.json",
    "Consumable Templates": "config/items/consumables.json",
    "Miscellaneous Templates": "config/items/miscellaneous.json"
}

class ItemEditorPanel(QWidget):
    """
    Main panel for editing various item categories.
    It features a list of item categories on the left and a
    stacked widget on the right to display the editor for the selected category.
    Also acts as an assistant provider by delegating to the active SpecificItemEditor.
    """
    item_data_modified = Signal(str) # Emits category name on modification

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.current_category_key: Optional[str] = None
        self.category_editors: Dict[str, QWidget] = {} # To store instances of specific editors

        self._setup_ui()
        self._populate_category_list()

    # ===== Assistant provider delegation =====
    def _active_editor(self) -> Optional[QWidget]:
        try:
            # Current widget in the stack might be the placeholder or a SpecificItemEditor
            w = self.editor_stack.currentWidget()
            # Verify it's the editor instance we created for the current category
            if self.current_category_key and self.current_category_key in self.category_editors:
                return self.category_editors.get(self.current_category_key)
            return w
        except Exception:
            return None

    def get_assistant_context(self):
        """Return the active editor's assistant context, or a default items context."""
        ed = self._active_editor()
        if ed and hasattr(ed, "get_assistant_context"):
            return ed.get_assistant_context()
        # Default fallback when no editor is active yet
        try:
            from assistant.context import AssistantContext
        except Exception:
            from ..assistant.context import AssistantContext  # type: ignore
        allowed = [
            "/name", "/description", "/item_type", "/rarity", "/weight", "/value",
            "/is_equippable", "/is_consumable", "/is_stackable", "/is_quest_item",
            "/equip_slots", "/stack_limit", "/durability", "/current_durability",
            "/stats", "/dice_roll_effects", "/tags", "/custom_properties",
        ]
        return AssistantContext(
            domain=f"items:{self.current_category_key or 'unknown'}",
            selection_id=None,
            content=None,
            schema=None,
            allowed_paths=allowed,
        )

    def get_reference_catalogs(self) -> Dict[str, Any]:
        ed = self._active_editor()
        if ed and hasattr(ed, "get_reference_catalogs"):
            try:
                return ed.get_reference_catalogs()
            except Exception:
                return {}
        return {}

    def get_domain_examples(self) -> list:
        """Provide one example item from the active editor, if available."""
        ed = self._active_editor()
        try:
            if ed and hasattr(ed, "items_data") and isinstance(ed.items_data, list) and ed.items_data:
                first = ed.items_data[0]
                if isinstance(first, dict):
                    return [first]
        except Exception:
            pass
        return []

    def apply_assistant_patch(self, patch_ops):
        ed = self._active_editor()
        if ed and hasattr(ed, "apply_assistant_patch"):
            return ed.apply_assistant_patch(patch_ops)
        return False, "No active item editor."

    def create_entry_from_llm(self, entry: dict):
        ed = self._active_editor()
        if ed and hasattr(ed, "create_entry_from_llm"):
            return ed.create_entry_from_llm(entry)
        return False, "No active item editor.", None

    # Optional delegation for targeted search hooks used by AssistantDock
    def search_for_entries(self, term: str, limit: int = 10):
        ed = self._active_editor()
        if ed and hasattr(ed, "search_for_entries"):
            return ed.search_for_entries(term, limit)
        return []

    def focus_entry(self, item_id: str) -> bool:
        ed = self._active_editor()
        if ed and hasattr(ed, "focus_entry"):
            return ed.focus_entry(item_id)
        return False

    def _setup_ui(self):
        main_layout = QHBoxLayout(self)
        splitter = QSplitter(Qt.Horizontal)

        # Left panel: Category list
        left_panel = QFrame()
        left_panel.setFrameShape(QFrame.StyledPanel)
        left_layout = QVBoxLayout(left_panel)
        left_layout.addWidget(QLabel("Item Categories"))
        self.category_list_widget = QListWidget()
        self.category_list_widget.currentItemChanged.connect(self._on_category_selected)
        left_layout.addWidget(self.category_list_widget)
        splitter.addWidget(left_panel)

        # Right panel: Stacked widget for editors
        self.editor_stack = QStackedWidget()
        # Add a default placeholder widget
        placeholder_widget = QWidget()
        placeholder_layout = QVBoxLayout(placeholder_widget)
        placeholder_label = QLabel("Select an item category to edit.")
        placeholder_label.setAlignment(Qt.AlignCenter)
        placeholder_layout.addWidget(placeholder_label)
        self.editor_stack.addWidget(placeholder_widget)

        splitter.addWidget(self.editor_stack)
        splitter.setSizes([200, 600]) # Initial sizes for panels

        main_layout.addWidget(splitter)

    def _populate_category_list(self):
        self.category_list_widget.clear()
        for category_name in ITEM_CATEGORIES.keys():
            item = QListWidgetItem(category_name)
            item.setData(Qt.UserRole, category_name) # Store category name as data
            self.category_list_widget.addItem(item)

        if self.category_list_widget.count() > 0:
            self.category_list_widget.setCurrentRow(0)

    @Slot(QListWidgetItem, QListWidgetItem)
    def _on_category_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]):
        if not current:
            self.editor_stack.setCurrentIndex(0) # Show placeholder
            self.current_category_key = None
            return

        category_key = current.data(Qt.UserRole) # This is the display name like "Starting Items"
        self.current_category_key = category_key

        if category_key in self.category_editors:
            self.editor_stack.setCurrentWidget(self.category_editors[category_key])
            # Optionally refresh data if needed when switching back to an existing editor
            # editor_instance = self.category_editors[category_key]
            # if hasattr(editor_instance, 'refresh_data'):
            #     editor_instance.refresh_data()
        else:
            editor_widget = self._create_editor_for_category(category_key)
            if editor_widget:
                self.category_editors[category_key] = editor_widget
                self.editor_stack.addWidget(editor_widget)
                self.editor_stack.setCurrentWidget(editor_widget)
                # Connect the specific editor's data_modified signal
                if hasattr(editor_widget, 'data_modified') and isinstance(editor_widget.data_modified, Signal):
                    # Use a lambda to pass the category_key along with the signal
                    editor_widget.data_modified.connect(
                        lambda cat_key=category_key: self.item_data_modified.emit(cat_key)
                    )
            else:
                self.editor_stack.setCurrentIndex(0)
                logger.error(f"Failed to create editor for category: {category_key}")

    def _create_editor_for_category(self, category_key: str) -> Optional[QWidget]:
        """
        Creates the appropriate editor widget for the given item category.
        This will now instantiate SpecificItemEditor for all categories.
        """
        file_path_relative = ITEM_CATEGORIES.get(category_key)
        if not file_path_relative:
            logger.error(f"No file path defined for item category: {category_key}")
            # Fallback to a placeholder if a category key is somehow unknown
            editor = QWidget()
            layout = QVBoxLayout(editor)
            label = QLabel(f"Error: No file path configured for category: {category_key}")
            label.setAlignment(Qt.AlignCenter)
            layout.addWidget(label)
            return editor

        # Import SpecificItemEditor here to avoid potential circular dependencies if it were at module level
        from .SpecificItemEditor import SpecificItemEditor # Assuming it's in the same directory

        try:
            # Pass the category_key (display name from ITEM_CATEGORIES) and the relative file path
            editor = SpecificItemEditor(item_file_key=category_key, # This is the display name like "Starting Items"
                                        item_file_path_relative=file_path_relative,
                                        parent=self)
            logger.info(f"Created SpecificItemEditor for category '{category_key}' with file '{file_path_relative}'")
            
            # Connect the specific editor's data_modified signal
            if hasattr(editor, 'data_modified') and isinstance(editor.data_modified, Signal):
                # Use a lambda to pass the category_key along with the signal
                # This allows the main panel to know which category's data was modified.
                editor.data_modified.connect(
                    lambda cat_key=category_key: self.item_data_modified.emit(cat_key)
                )
            else:
                logger.warning(f"SpecificItemEditor for '{category_key}' does not have a 'data_modified' signal.")

            return editor
        except ImportError:
            logger.error(f"Could not import SpecificItemEditor. Ensure it's in the correct location.", exc_info=True)
            editor_placeholder = QWidget()
            layout_placeholder = QVBoxLayout(editor_placeholder)
            label_placeholder = QLabel(f"Error: Could not load editor for {category_key}.\nSpecificItemEditor not found.")
            label_placeholder.setAlignment(Qt.AlignCenter)
            layout_placeholder.addWidget(label_placeholder)
            return editor_placeholder
        except Exception as e:
            logger.error(f"Error creating SpecificItemEditor for {category_key}: {e}", exc_info=True)
            QMessageBox.critical(self, "Editor Creation Error",
                                 f"Could not create editor for {category_key}.\nError: {e}")
            # Return a placeholder on error
            editor_placeholder_err = QWidget()
            layout_placeholder_err = QVBoxLayout(editor_placeholder_err)
            label_placeholder_err = QLabel(f"Error creating editor for {category_key}:\n{e}")
            label_placeholder_err.setAlignment(Qt.AlignCenter)
            layout_placeholder_err.addWidget(label_placeholder_err)
            return editor_placeholder_err
 
    def refresh_current_editor(self):
        """Refreshes the data in the currently active editor."""
        if self.current_category_key and self.current_category_key in self.category_editors:
            editor = self.category_editors[self.current_category_key]
            if hasattr(editor, 'refresh_data'): # Assuming editors will have a refresh_data method
                editor.refresh_data()
            else:
                logger.warning(f"Editor for {self.current_category_key} does not have a refresh_data method.")
        elif self.current_category_key: # Editor not yet created, but category selected
            # This might happen if data is loaded before UI fully interacts
            # Triggering selection again might recreate/load it
             current_item = self.category_list_widget.currentItem()
             if current_item:
                 self._on_category_selected(current_item, None)


    def save_all_item_editors(self) -> bool:
        """Iterates through all instantiated editors and calls their save_data method."""
        all_saved = True
        if not self.category_editors:
            logger.info("No item editors have been instantiated. Nothing to save.")
            return True # No editors, so technically all (zero) saved.

        for category_key, editor_instance in self.category_editors.items():
            if hasattr(editor_instance, 'save_data') and callable(editor_instance.save_data):
                try:
                    if not editor_instance.save_data():
                        all_saved = False
                        logger.error(f"Failed to save data for item category: {category_key} via its editor.")
                    else:
                        logger.info(f"Successfully saved item category: {category_key}")
                except Exception as e:
                    all_saved = False
                    logger.error(f"Exception while saving item category {category_key}: {e}", exc_info=True)
            else:
                logger.warning(f"Editor for {category_key} does not have a callable save_data method.")
        
        if all_saved:
            logger.info("All active item editors saved successfully.")
        else:
            QMessageBox.warning(self, "Save Error", "Some item categories could not be saved. Check logs for details.")
        return all_saved

    def get_active_editor_file_path(self) -> Optional[str]:
        """Returns the file path associated with the currently active item editor."""
        if self.current_category_key:
            return ITEM_CATEGORIES.get(self.current_category_key)
        return None
```

### File: world_configurator\ui\editors\location_editor.py

```python
"""
Location editor component for the World Configurator Tool.
"""

import logging
import os
from typing import Dict, List, Optional, Callable

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QComboBox, QDoubleSpinBox
)

from models.base_models import Location, LocationConnection, LocationFeature
from models.location_data import LocationManager
from models.world_data import CultureManager
from models.location_defaults_manager import LocationDefaultsManager

logger = logging.getLogger("world_configurator.ui.location_editor")

class FeatureDialog(QDialog):
    """Dialog for editing a location feature."""
    
    def __init__(self, parent=None, feature: Optional[LocationFeature] = None):
        """
        Initialize the feature edit dialog.
        
        Args:
            parent: The parent widget.
            feature: Optional existing feature to edit.
        """
        super().__init__(parent)
        self.setWindowTitle("Location Feature")
        self.setMinimumWidth(400)
        
        # Feature to edit
        self.feature = feature or LocationFeature("", "")
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for fields
        form = QFormLayout()
        
        # Name field
        self.name_edit = QLineEdit(self.feature.name)
        form.addRow("Name:", self.name_edit)
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.feature.description)
        self.desc_edit.setMinimumHeight(100)
        form.addRow("Description:", self.desc_edit)
        
        # Interaction type field
        self.interaction_combo = QComboBox()
        self.interaction_combo.addItems(["none", "examine", "use", "interact", "collect"])
        current_index = self.interaction_combo.findText(self.feature.interaction_type)
        if current_index >= 0:
            self.interaction_combo.setCurrentIndex(current_index)
        form.addRow("Interaction Type:", self.interaction_combo)
        
        layout.addLayout(form)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def get_feature(self) -> LocationFeature:
        """Get the edited feature."""
        self.feature.name = self.name_edit.text()
        self.feature.description = self.desc_edit.toPlainText()
        self.feature.interaction_type = self.interaction_combo.currentText()
        return self.feature

class ConnectionDialog(QDialog):
    """Dialog for editing a location connection."""
    
    def __init__(self, parent=None, connection: Optional[LocationConnection] = None, 
                 available_locations: Optional[Dict[str, str]] = None):
        """
        Initialize the connection edit dialog.
        
        Args:
            parent: The parent widget.
            connection: Optional existing connection to edit.
            available_locations: Dictionary of location IDs to names.
        """
        super().__init__(parent)
        self.setWindowTitle("Location Connection")
        self.setMinimumWidth(400)
        
        # Connection to edit
        self.connection = connection or LocationConnection("", "", 0)
        
        # Available locations
        self.available_locations = available_locations or {}
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for fields
        form = QFormLayout()
        
        # Target location field
        self.target_combo = QComboBox()
        for loc_id, loc_name in self.available_locations.items():
            self.target_combo.addItem(loc_name, loc_id)
        
        # Set current target if it exists
        if self.connection.target in self.available_locations:
            index = self.target_combo.findData(self.connection.target)
            if index >= 0:
                self.target_combo.setCurrentIndex(index)
        
        form.addRow("Target Location:", self.target_combo)
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.connection.description)
        self.desc_edit.setMinimumHeight(80)
        form.addRow("Description:", self.desc_edit)
        
        # Travel time field
        self.time_spin = QSpinBox()
        self.time_spin.setRange(1, 10000)  # 1 minute to ~7 days
        self.time_spin.setValue(self.connection.travel_time)
        self.time_spin.setSuffix(" minutes")
        form.addRow("Travel Time:", self.time_spin)
        
        layout.addLayout(form)
        
        # Requirements section
        req_label = QLabel("Requirements")
        req_label.setStyleSheet("font-weight: bold; margin-top: 5px;")
        layout.addWidget(req_label)
        
        self.req_list = QListWidget()
        self.req_list.setMaximumHeight(80)
        layout.addWidget(self.req_list)
        
        # Add existing requirements
        for req in self.connection.requirements:
            self.req_list.addItem(req)
        
        # Requirement controls
        req_controls = QHBoxLayout()
        
        self.req_edit = QLineEdit()
        self.req_edit.setPlaceholderText("Enter requirement (e.g., 'key', 'quest_completed')")
        req_controls.addWidget(self.req_edit)
        
        self.add_req_btn = QPushButton("Add")
        self.add_req_btn.clicked.connect(self._add_requirement)
        req_controls.addWidget(self.add_req_btn)
        
        self.remove_req_btn = QPushButton("Remove")
        self.remove_req_btn.clicked.connect(self._remove_requirement)
        req_controls.addWidget(self.remove_req_btn)
        
        layout.addLayout(req_controls)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def _add_requirement(self):
        """Add a requirement to the list."""
        req_text = self.req_edit.text().strip()
        if req_text:
            self.req_list.addItem(req_text)
            self.req_edit.clear()
    
    def _remove_requirement(self):
        """Remove the selected requirement from the list."""
        current_item = self.req_list.currentItem()
        if current_item:
            self.req_list.takeItem(self.req_list.row(current_item))
    
    def get_connection(self) -> LocationConnection:
        """Get the edited connection."""
        # Get selected target
        target_id = self.target_combo.currentData()
        
        # Get requirements
        requirements = []
        for i in range(self.req_list.count()):
            requirements.append(self.req_list.item(i).text())
        
        # Update connection
        self.connection.target = target_id
        self.connection.description = self.desc_edit.toPlainText()
        self.connection.travel_time = self.time_spin.value()
        self.connection.requirements = requirements
        
        return self.connection

class LocationEditor(QWidget):
    """Location editor component."""
    
    # Signals
    location_modified = Signal()
    
    def __init__(self, parent=None):
        """
        Initialize the location editor.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        # Internal state
        self.location_manager = LocationManager()
        self.culture_manager = CultureManager()
        self.location_defaults_manager: Optional[LocationDefaultsManager] = None
        self.current_location: Optional[Location] = None
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the editor UI."""
        main_layout = QHBoxLayout(self)
        
        # Create a splitter for resizable panels
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)
        
        # Left panel (location list)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        list_label = QLabel("Locations")
        list_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        left_layout.addWidget(list_label)
        
        self.location_list = QListWidget()
        self.location_list.setMinimumWidth(200)
        self.location_list.currentItemChanged.connect(self._on_location_selected)
        left_layout.addWidget(self.location_list)
        
        list_buttons = QHBoxLayout()
        
        self.add_location_btn = QPushButton("Add")
        self.add_location_btn.clicked.connect(self._add_location)
        list_buttons.addWidget(self.add_location_btn)
        
        self.remove_location_btn = QPushButton("Remove")
        self.remove_location_btn.clicked.connect(self._remove_location)
        self.remove_location_btn.setEnabled(False)
        list_buttons.addWidget(self.remove_location_btn)
        
        left_layout.addLayout(list_buttons)
        
        # Add left panel to splitter
        splitter.addWidget(left_panel)
        
        # Right panel (location details)
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)
        
        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)
        
        self.details_layout = QVBoxLayout(self.details_widget)
        
        # Location details form
        self.form_layout = QFormLayout()
        
        # Location name
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Enter location name")
        self.name_edit.textChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Name:", self.name_edit)
        
        # Location description
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlaceholderText("Enter location description")
        self.desc_edit.textChanged.connect(self._on_field_changed)
        self.desc_edit.setMinimumHeight(100)
        self.form_layout.addRow("Description:", self.desc_edit)
        
        # Location type
        self.type_combo = QComboBox()
        self.type_combo.addItems(["village", "city", "dungeon", "forest", "mountain", "cave", "ruins", "castle", "other"])
        self.type_combo.currentTextChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Type:", self.type_combo)
        
        # Region
        self.region_edit = QLineEdit()
        self.region_edit.setPlaceholderText("Enter region name")
        self.region_edit.textChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Region:", self.region_edit)
        
        # Culture
        self.culture_combo = QComboBox()
        self.culture_combo.currentIndexChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Culture:", self.culture_combo)
        
        # Population
        self.population_spin = QSpinBox()
        self.population_spin.setRange(0, 1000000)
        self.population_spin.setSingleStep(10)
        self.population_spin.valueChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Population:", self.population_spin)
        
        self.details_layout.addLayout(self.form_layout)
        
        # Features section
        features_label = QLabel("Location Features")
        features_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(features_label)
        
        self.features_list = QListWidget()
        self.features_list.setMinimumHeight(120)
        self.features_list.itemDoubleClicked.connect(self._edit_feature)
        self.details_layout.addWidget(self.features_list)
        
        features_buttons = QHBoxLayout()
        
        self.add_feature_btn = QPushButton("Add Feature")
        self.add_feature_btn.clicked.connect(self._add_feature)
        features_buttons.addWidget(self.add_feature_btn)
        
        self.edit_feature_btn = QPushButton("Edit Feature")
        self.edit_feature_btn.clicked.connect(lambda: self._edit_feature(self.features_list.currentItem()))
        features_buttons.addWidget(self.edit_feature_btn)
        
        self.remove_feature_btn = QPushButton("Remove Feature")
        self.remove_feature_btn.clicked.connect(self._remove_feature)
        features_buttons.addWidget(self.remove_feature_btn)
        
        self.details_layout.addLayout(features_buttons)
        
        # Connections section
        connections_label = QLabel("Location Connections")
        connections_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(connections_label)
        
        self.connections_list = QListWidget()
        self.connections_list.setMinimumHeight(120)
        self.connections_list.itemDoubleClicked.connect(self._edit_connection)
        self.details_layout.addWidget(self.connections_list)
        
        connections_buttons = QHBoxLayout()
        
        self.add_connection_btn = QPushButton("Add Connection")
        self.add_connection_btn.clicked.connect(self._add_connection)
        connections_buttons.addWidget(self.add_connection_btn)
        
        self.edit_connection_btn = QPushButton("Edit Connection")
        self.edit_connection_btn.clicked.connect(lambda: self._edit_connection(self.connections_list.currentItem()))
        connections_buttons.addWidget(self.edit_connection_btn)
        
        self.remove_connection_btn = QPushButton("Remove Connection")
        self.remove_connection_btn.clicked.connect(self._remove_connection)
        connections_buttons.addWidget(self.remove_connection_btn)
        
        self.details_layout.addLayout(connections_buttons)
        
        # Culture Mix Override Section
        cm_label = QLabel("Culture Mix (Override for this Location)")
        cm_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(cm_label)
        
        cm_controls = QHBoxLayout()
        self.cm_culture_combo = QComboBox()
        self.cm_weight_spin = QDoubleSpinBox()
        self.cm_weight_spin.setRange(0.0, 1.0)
        self.cm_weight_spin.setSingleStep(0.05)
        self.cm_add_btn = QPushButton("Add/Update")
        self.cm_add_btn.clicked.connect(self._cm_add_update)
        cm_controls.addWidget(QLabel("Culture:"))
        cm_controls.addWidget(self.cm_culture_combo)
        cm_controls.addWidget(QLabel("Weight:"))
        cm_controls.addWidget(self.cm_weight_spin)
        cm_controls.addWidget(self.cm_add_btn)
        self.details_layout.addLayout(cm_controls)
        
        self.cm_list = QListWidget()
        self.cm_list.setMinimumHeight(100)
        self.details_layout.addWidget(self.cm_list)
        cm_buttons = QHBoxLayout()
        self.cm_remove_btn = QPushButton("Remove")
        self.cm_remove_btn.clicked.connect(self._cm_remove)
        self.cm_clear_btn = QPushButton("Clear Override")
        self.cm_clear_btn.clicked.connect(self._cm_clear)
        cm_buttons.addWidget(self.cm_remove_btn)
        cm_buttons.addWidget(self.cm_clear_btn)
        self.details_layout.addLayout(cm_buttons)
        
        # Global Culture Mix Defaults Section
        gcm_label = QLabel("Global Culture Mix Defaults")
        gcm_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(gcm_label)
        
        gcm_controls = QHBoxLayout()
        self.gcm_culture_edit = QLineEdit()
        self.gcm_culture_edit.setPlaceholderText("culture id (e.g., concordant)")
        self.gcm_weight_spin = QDoubleSpinBox()
        self.gcm_weight_spin.setRange(0.0, 1.0)
        self.gcm_weight_spin.setSingleStep(0.05)
        self.gcm_add_btn = QPushButton("Add/Update Default")
        self.gcm_add_btn.clicked.connect(self._gcm_add_update)
        gcm_controls.addWidget(self.gcm_culture_edit)
        gcm_controls.addWidget(QLabel("Weight:"))
        gcm_controls.addWidget(self.gcm_weight_spin)
        gcm_controls.addWidget(self.gcm_add_btn)
        self.details_layout.addLayout(gcm_controls)
        
        self.gcm_list = QListWidget()
        self.gcm_list.setMinimumHeight(100)
        self.details_layout.addWidget(self.gcm_list)
        gcm_buttons = QHBoxLayout()
        self.gcm_remove_btn = QPushButton("Remove Default")
        self.gcm_remove_btn.clicked.connect(self._gcm_remove)
        self.gcm_load_btn = QPushButton("Load Defaults File")
        self.gcm_load_btn.clicked.connect(self._gcm_load)
        self.gcm_save_btn = QPushButton("Save Defaults File")
        self.gcm_save_btn.clicked.connect(self._gcm_save)
        gcm_buttons.addWidget(self.gcm_remove_btn)
        gcm_buttons.addWidget(self.gcm_load_btn)
        gcm_buttons.addWidget(self.gcm_save_btn)
        self.details_layout.addLayout(gcm_buttons)
        
        # Save button
        save_layout = QHBoxLayout()
        save_layout.addStretch()
        
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self._save_current_location)
        self.save_btn.setEnabled(False)
        save_layout.addWidget(self.save_btn)
        
        self.details_layout.addLayout(save_layout)
        
        # Add right panel to splitter
        splitter.addWidget(right_panel)
        
        # Set up initial state
        self._disable_details()
        
        # Prioritize the details panel for resizing
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
    
    def set_managers(self, location_manager: LocationManager, culture_manager: CultureManager, defaults_manager: Optional[LocationDefaultsManager] = None) -> None:
        """
        Set the managers to use.
        
        Args:
            location_manager: The location manager.
            culture_manager: The culture manager for culture selection.
            defaults_manager: Optional manager for global culture mix defaults.
        """
        self.location_manager = location_manager
        self.culture_manager = culture_manager
        self.location_defaults_manager = defaults_manager
        self._refresh_location_list()
        self._populate_culture_combo()
        # Populate culture combo for culture mix editor
        self.cm_culture_combo.clear()
        for culture_id, culture in self.culture_manager.cultures.items():
            self.cm_culture_combo.addItem(culture.name, culture_id)
        # Load global defaults
        self._gcm_load()
    
    def _populate_culture_combo(self) -> None:
        """Populate the culture combo box from the culture manager."""
        self.culture_combo.clear()
        
        # Add empty option
        self.culture_combo.addItem("<None>", "")
        
        # Add all cultures
        for culture_id, culture in self.culture_manager.cultures.items():
            self.culture_combo.addItem(culture.name, culture_id)
    
    def _refresh_location_list(self) -> None:
        """Refresh the location list from the manager."""
        # Clear list
        self.location_list.clear()
        
        # Add all locations
        for location_id, location in self.location_manager.locations.items():
            item = QListWidgetItem(location.name)
            item.setData(Qt.UserRole, location_id)
            self.location_list.addItem(item)
        
        # Sort alphabetically
        self.location_list.sortItems()
        
        # Select the first item if available
        if self.location_list.count() > 0:
            self.location_list.setCurrentRow(0)
    
    def _on_location_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]) -> None:
        """
        Handle location selection change.
        
        Args:
            current: The current selected item, or None.
            previous: The previously selected item, or None.
        """
        if current:
            location_id = current.data(Qt.UserRole)
            location = self.location_manager.get_location(location_id)
            
            if location:
                self._load_location(location)
                self.remove_location_btn.setEnabled(True)
                return
        
        # No valid selection
        self._disable_details()
        self.remove_location_btn.setEnabled(False)
    
    def _load_location(self, location: Location) -> None:
        """
        Load a location into the editor.
        
        Args:
            location: The location to load.
        """
        try:
            self.current_location = location
            
            # Set form values
            self.name_edit.setText(location.name)
            self.desc_edit.setPlainText(location.description)
            
            # Set type
            index = self.type_combo.findText(location.type)
            if index >= 0:
                self.type_combo.setCurrentIndex(index)
            
            self.region_edit.setText(location.region)
            
            # Set culture
            index = self.culture_combo.findData(location.culture_id)
            if index >= 0:
                self.culture_combo.setCurrentIndex(index)
            else:
                self.culture_combo.setCurrentIndex(0)  # None
            
            self.population_spin.setValue(location.population)
            
            # Load features
            self.features_list.clear()
            for feature in location.features:
                # Ensure feature is a LocationFeature object
                if hasattr(feature, 'name'):
                    feature_name = feature.name
                elif isinstance(feature, dict) and 'name' in feature:
                    # Convert dict to LocationFeature if needed
                    from world_configurator.models.base_models import LocationFeature
                    feature = LocationFeature(
                        name=feature.get('name', ''),
                        description=feature.get('description', ''),
                        interaction_type=feature.get('interaction_type', 'none')
                    )
                    feature_name = feature.get('name', 'Unknown Feature')
                else:
                    logger.warning(f"Skipping invalid feature in location {location.name}: {feature}")
                    continue
                    
                item = QListWidgetItem(feature_name)
                item.setData(Qt.UserRole, feature)
                self.features_list.addItem(item)
            
            # Load connections
            self.connections_list.clear()
            for connection in location.connections:
                # Ensure connection is a LocationConnection object
                if hasattr(connection, 'target') and hasattr(connection, 'travel_time'):
                    target_id = connection.target
                    travel_time = connection.travel_time
                elif isinstance(connection, dict) and 'target' in connection:
                    # Convert dict to LocationConnection if needed
                    from world_configurator.models.base_models import LocationConnection
                    connection = LocationConnection(
                        target=connection.get('target', ''),
                        description=connection.get('description', ''),
                        travel_time=connection.get('travel_time', 0),
                        requirements=connection.get('requirements', [])
                    )
                    target_id = connection.target
                    travel_time = connection.travel_time
                else:
                    logger.warning(f"Skipping invalid connection in location {location.name}: {connection}")
                    continue
                
                target_name = "Unknown"
                target_loc = self.location_manager.get_location(target_id)
                if target_loc:
                    target_name = target_loc.name
                
                item = QListWidgetItem(f"{target_name} ({travel_time} mins)")
                item.setData(Qt.UserRole, connection)
                self.connections_list.addItem(item)
            
            # Load culture mix override
            self._cm_refresh_list()
            # Enable controls
            self._enable_details()
            self.save_btn.setEnabled(False)  # Initially not modified
            
        except Exception as e:
            logger.error(f"Error loading location {location.name}: {str(e)}")
            QMessageBox.warning(
                self,
                "Error Loading Location",
                f"There was an error loading the location '{location.name}':\n\n{str(e)}\n\nSome data may not be displayed correctly."
            )
            # Still enable the editor to allow fixing the issue
            self._enable_details()
            self.save_btn.setEnabled(True)  # Enable saving to fix issues
    
    def _disable_details(self) -> None:
        """Disable all detail controls."""
        self.current_location = None
        
        self.name_edit.clear()
        self.desc_edit.clear()
        self.region_edit.clear()
        self.population_spin.setValue(0)
        
        self.features_list.clear()
        self.connections_list.clear()
        
        self.name_edit.setEnabled(False)
        self.desc_edit.setEnabled(False)
        self.type_combo.setEnabled(False)
        self.region_edit.setEnabled(False)
        self.culture_combo.setEnabled(False)
        self.population_spin.setEnabled(False)
        
        self.features_list.setEnabled(False)
        self.connections_list.setEnabled(False)
        
        self.add_feature_btn.setEnabled(False)
        self.edit_feature_btn.setEnabled(False)
        self.remove_feature_btn.setEnabled(False)
        
        self.add_connection_btn.setEnabled(False)
        self.edit_connection_btn.setEnabled(False)
        self.remove_connection_btn.setEnabled(False)
        
        self.save_btn.setEnabled(False)
    
    def _enable_details(self) -> None:
        """Enable all detail controls."""
        self.name_edit.setEnabled(True)
        self.desc_edit.setEnabled(True)
        self.type_combo.setEnabled(True)
        self.region_edit.setEnabled(True)
        self.culture_combo.setEnabled(True)
        self.population_spin.setEnabled(True)
        
        self.features_list.setEnabled(True)
        self.connections_list.setEnabled(True)
        
        self.add_feature_btn.setEnabled(True)
        self.edit_feature_btn.setEnabled(True)
        self.remove_feature_btn.setEnabled(True)
        
        self.add_connection_btn.setEnabled(True)
        self.edit_connection_btn.setEnabled(True)
        self.remove_connection_btn.setEnabled(True)
    
    def _on_field_changed(self) -> None:
        """Handle field value changes."""
        if self.current_location:
            self.save_btn.setEnabled(True)
    
    def _save_current_location(self) -> None:
        """Save the current location to the manager."""
        if not self.current_location:
            return
        
        # Update location from form
        self.current_location.name = self.name_edit.text()
        self.current_location.description = self.desc_edit.toPlainText()
        self.current_location.type = self.type_combo.currentText()
        self.current_location.region = self.region_edit.text()
        self.current_location.culture_id = self.culture_combo.currentData()
        self.current_location.population = self.population_spin.value()
        
        # Update features
        self.current_location.features = []
        for i in range(self.features_list.count()):
            item = self.features_list.item(i)
            feature = item.data(Qt.UserRole)
            self.current_location.features.append(feature)
        
        # Update connections
        self.current_location.connections = []
        for i in range(self.connections_list.count()):
            item = self.connections_list.item(i)
            connection = item.data(Qt.UserRole)
            self.current_location.connections.append(connection)
        
        # Save culture mix from UI to model
        self._cm_save_from_list()
        # Update location in manager
        self.location_manager.add_location(self.current_location)
        
        # Mark as saved
        self.save_btn.setEnabled(False)
        
        # Update location list
        self._refresh_location_list()
        
        # Find and select the current location in the list
        for i in range(self.location_list.count()):
            item = self.location_list.item(i)
            if item.data(Qt.UserRole) == self.current_location.id:
                self.location_list.setCurrentItem(item)
                break
        
        # Emit modified signal
        self.location_modified.emit()
        
        # Log
        logger.info(f"Saved location: {self.current_location.name} ({self.current_location.id})")
    
    def _add_location(self) -> None:
        """Add a new location."""
        # Create new location
        location = Location.create_new("New Location", "Description of the location", "other")
        
        # Add to manager
        self.location_manager.add_location(location)
        
        # Refresh list
        self._refresh_location_list()
        
        # Find and select the new location
        for i in range(self.location_list.count()):
            item = self.location_list.item(i)
            if item.data(Qt.UserRole) == location.id:
                self.location_list.setCurrentItem(item)
                break
        
        # Set focus to name for immediate editing
        self.name_edit.setFocus()
        self.name_edit.selectAll()
        
        # Emit modified signal
        self.location_modified.emit()
        
        # Log
        logger.info(f"Added new location: {location.id}")
    
    def _remove_location(self) -> None:
        """Remove the selected location."""
        current_item = self.location_list.currentItem()
        if not current_item:
            return
        
        location_id = current_item.data(Qt.UserRole)
        location = self.location_manager.get_location(location_id)
        
        if not location:
            return
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the location '{location.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Check for connections to this location
        connected_locations = []
        for other_id, other_loc in self.location_manager.locations.items():
            if other_id == location_id:
                continue
            
            for conn in other_loc.connections:
                if conn.target == location_id:
                    connected_locations.append(other_loc.name)
                    break
        
        if connected_locations:
            # Warn about connected locations
            conn_warn = QMessageBox.warning(
                self,
                "Connected Locations",
                f"The following locations have connections to '{location.name}':\n\n" +
                "\n".join(connected_locations) +
                "\n\nDeleting this location will leave invalid connections. Continue?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if conn_warn != QMessageBox.Yes:
                return
        
        # Remove from manager
        self.location_manager.remove_location(location_id)
        
        # Refresh list
        self._refresh_location_list()
        
        # Emit modified signal
        self.location_modified.emit()
        
        # Log
        logger.info(f"Removed location: {location_id}")
    
    def _add_feature(self) -> None:
        """Add a new location feature."""
        if not self.current_location:
            return
        
        # Create dialog
        dialog = FeatureDialog(self)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get feature from dialog
            feature = dialog.get_feature()
            
            # Add to list
            item = QListWidgetItem(feature.name)
            item.setData(Qt.UserRole, feature)
            self.features_list.addItem(item)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Added feature: {feature.name}")
    
    def _edit_feature(self, item: Optional[QListWidgetItem]) -> None:
        """
        Edit a location feature.
        
        Args:
            item: The list item to edit, or None.
        """
        if not item:
            return
        
        # Get feature from item
        feature = item.data(Qt.UserRole)
        
        # Create dialog
        dialog = FeatureDialog(self, feature)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get updated feature from dialog
            updated_feature = dialog.get_feature()
            
            # Update item
            item.setText(updated_feature.name)
            item.setData(Qt.UserRole, updated_feature)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Edited feature: {updated_feature.name}")
    
    def _remove_feature(self) -> None:
        """Remove the selected location feature."""
        item = self.features_list.currentItem()
        if not item:
            return
        
        # Get feature from item
        feature = item.data(Qt.UserRole)
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the feature '{feature.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove item
        self.features_list.takeItem(self.features_list.row(item))
        
        # Mark as modified
        self.save_btn.setEnabled(True)
        
        # Log
        logger.debug(f"Removed feature: {feature.name}")
    
    def _cm_refresh_list(self) -> None:
        self.cm_list.clear()
        if not self.current_location:
            return
        mix = getattr(self.current_location, 'culture_mix', {}) or {}
        for cid, weight in mix.items():
            item = QListWidgetItem(f"{cid}: {weight:.2f}")
            item.setData(Qt.UserRole, (cid, weight))
            self.cm_list.addItem(item)
    
    def _cm_add_update(self) -> None:
        if not self.current_location:
            return
        cid = self.cm_culture_combo.currentData()
        weight = float(self.cm_weight_spin.value())
        # Update or add in the list
        # Find existing
        found_row = -1
        for i in range(self.cm_list.count()):
            c, _ = self.cm_list.item(i).data(Qt.UserRole)
            if c == cid:
                found_row = i
                break
        item_text = f"{cid}: {weight:.2f}"
        if found_row >= 0:
            self.cm_list.item(found_row).setText(item_text)
            self.cm_list.item(found_row).setData(Qt.UserRole, (cid, weight))
        else:
            item = QListWidgetItem(item_text)
            item.setData(Qt.UserRole, (cid, weight))
            self.cm_list.addItem(item)
        self.save_btn.setEnabled(True)
    
    def _cm_remove(self) -> None:
        row = self.cm_list.currentRow()
        if row >= 0:
            self.cm_list.takeItem(row)
            self.save_btn.setEnabled(True)
    
    def _cm_clear(self) -> None:
        self.cm_list.clear()
        self.save_btn.setEnabled(True)
    
    def _cm_save_from_list(self) -> None:
        if not self.current_location:
            return
        mix: Dict[str, float] = {}
        for i in range(self.cm_list.count()):
            cid, weight = self.cm_list.item(i).data(Qt.UserRole)
            mix[cid] = float(weight)
        # Normalize weights if they don't sum to ~1.0
        total = sum(mix.values())
        if total > 0 and abs(total - 1.0) > 1e-6:
            for k in list(mix.keys()):
                mix[k] = mix[k] / total
            # Reflect normalized values in UI list
            self.cm_list.clear()
            for cid, weight in mix.items():
                item = QListWidgetItem(f"{cid}: {weight:.2f}")
                item.setData(Qt.UserRole, (cid, weight))
                self.cm_list.addItem(item)
            QMessageBox.information(self, "Normalized", "Per-location culture mix weights were normalized to sum to 1.0.")
        self.current_location.culture_mix = mix
    
    def _get_available_locations(self) -> Dict[str, str]:
        """Get a dictionary of available target locations."""
        locations = {}
        
        # Include all locations except the current one
        for loc_id, location in self.location_manager.locations.items():
            if self.current_location and loc_id == self.current_location.id:
                continue
            
            locations[loc_id] = location.name
        
        return locations
    
    def _add_connection(self) -> None:
        """Add a new location connection."""
        if not self.current_location:
            return
        
        # Get available target locations
        available_locations = self._get_available_locations()
        
        if not available_locations:
            QMessageBox.information(
                self,
                "No Available Locations",
                "There are no other locations available to connect to.\n\nPlease create more locations first."
            )
            return
        
        # Create dialog
        dialog = ConnectionDialog(self, None, available_locations)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get connection from dialog
            connection = dialog.get_connection()
            
            # Get target location name
            target_name = available_locations.get(connection.target, "Unknown")
            
            # Add to list
            item = QListWidgetItem(f"{target_name} ({connection.travel_time} mins)")
            item.setData(Qt.UserRole, connection)
            self.connections_list.addItem(item)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Added connection to: {target_name}")
    
    def _edit_connection(self, item: Optional[QListWidgetItem]) -> None:
        """
        Edit a location connection.
        
        Args:
            item: The list item to edit, or None.
        """
        if not item:
            return
        
        # Get connection from item
        connection = item.data(Qt.UserRole)
        
        # Get available target locations
        available_locations = self._get_available_locations()
        
        # Add the current target if it's not in the list (might have been removed)
        if connection.target not in available_locations:
            target_loc = self.location_manager.get_location(connection.target)
            if target_loc:
                available_locations[connection.target] = target_loc.name
            else:
                available_locations[connection.target] = "Unknown Location"
        
        # Create dialog
        dialog = ConnectionDialog(self, connection, available_locations)
        
        # Show dialog
        result = dialog.exec()
        
        if result == QDialog.Accepted:
            # Get updated connection from dialog
            updated_connection = dialog.get_connection()
            
            # Get target location name
            target_name = available_locations.get(updated_connection.target, "Unknown")
            
            # Update item
            item.setText(f"{target_name} ({updated_connection.travel_time} mins)")
            item.setData(Qt.UserRole, updated_connection)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Edited connection to: {target_name}")
    
    def _gcm_load(self) -> None:
        # Load defaults from manager if available; otherwise from config/world/locations/defaults.json
        from utils.file_manager import get_world_config_dir, load_json
        try:
            mix = {}
            if self.location_defaults_manager and isinstance(self.location_defaults_manager.data, dict):
                mix = (self.location_defaults_manager.data.get("culture_mix") or {})
            else:
                path = os.path.join(get_world_config_dir(), "locations", "defaults.json")
                data = load_json(path) or {}
                mix = (data.get("culture_mix") or {})
            self.gcm_list.clear()
            for cid, weight in mix.items():
                item = QListWidgetItem(f"{cid}: {float(weight):.2f}")
                item.setData(Qt.UserRole, (cid, float(weight)))
                self.gcm_list.addItem(item)
        except Exception:
            self.gcm_list.clear()
    
    def _gcm_save(self) -> None:
        from utils.file_manager import get_world_config_dir
        mix: Dict[str, float] = {}
        for i in range(self.gcm_list.count()):
            cid, weight = self.gcm_list.item(i).data(Qt.UserRole)
            mix[cid] = float(weight)
        # Normalize weights if needed
        total = sum(mix.values())
        if total > 0 and abs(total - 1.0) > 1e-6:
            for k in list(mix.keys()):
                mix[k] = mix[k] / total
            # Reflect normalized values in UI list
            self.gcm_list.clear()
            for cid, weight in mix.items():
                item = QListWidgetItem(f"{cid}: {weight:.2f}")
                item.setData(Qt.UserRole, (cid, weight))
                self.gcm_list.addItem(item)
            QMessageBox.information(self, "Normalized", "Global culture mix defaults were normalized to sum to 1.0.")
        # Save via manager if available
        if self.location_defaults_manager is not None:
            if not isinstance(self.location_defaults_manager.data, dict):
                self.location_defaults_manager.data = {"culture_mix": {}, "metadata": {"version": "1.0.0"}}
            self.location_defaults_manager.data["culture_mix"] = mix
            # Ensure we have a path
            target_path = self.location_defaults_manager.state.path
            if not target_path:
                # Fallback to game's config path
                target_path = os.path.join(get_world_config_dir(), "locations", "defaults.json")
            if self.location_defaults_manager.save_to_file(target_path):
                QMessageBox.information(self, "Saved", "Global culture mix defaults saved.")
            else:
                QMessageBox.critical(self, "Error", "Failed to save culture mix defaults.")
        else:
            # Fallback: write directly to game's defaults.json
            from utils.file_manager import save_json
            path = os.path.join(get_world_config_dir(), "locations", "defaults.json")
            data = {"culture_mix": mix, "metadata": {"version": "1.0.0", "description": "Default cultural mixture"}}
            if save_json(data, path):
                QMessageBox.information(self, "Saved", "Global culture mix defaults saved.")
            else:
                QMessageBox.critical(self, "Error", "Failed to save culture mix defaults.")
    
    def _gcm_add_update(self) -> None:
        cid = self.gcm_culture_edit.text().strip()
        weight = float(self.gcm_weight_spin.value())
        if not cid:
            return
        # Update or add
        found = -1
        for i in range(self.gcm_list.count()):
            c, _ = self.gcm_list.item(i).data(Qt.UserRole)
            if c == cid:
                found = i
                break
        item_text = f"{cid}: {weight:.2f}"
        if found >= 0:
            self.gcm_list.item(found).setText(item_text)
            self.gcm_list.item(found).setData(Qt.UserRole, (cid, weight))
        else:
            item = QListWidgetItem(item_text)
            item.setData(Qt.UserRole, (cid, weight))
            self.gcm_list.addItem(item)
    
    def _gcm_remove(self) -> None:
        row = self.gcm_list.currentRow()
        if row >= 0:
            self.gcm_list.takeItem(row)
    
    def _remove_connection(self) -> None:
        """Remove the selected location connection."""
        item = self.connections_list.currentItem()
        if not item:
            return
        
        # Get connection from item
        connection = item.data(Qt.UserRole)
        
        # Get target location name
        target_name = "Unknown"
        target_loc = self.location_manager.get_location(connection.target)
        if target_loc:
            target_name = target_loc.name
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the connection to '{target_name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove item
        self.connections_list.takeItem(self.connections_list.row(item))
        
        # Mark as modified
        self.save_btn.setEnabled(True)
        
        # Log
        logger.debug(f"Removed connection to: {target_name}")

```

### File: world_configurator\ui\editors\magic_systems_editor.py

```python
"""
Magic Systems editor component for the World Configurator Tool.
"""

import logging
from typing import Dict, List, Optional, Callable, Any

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QComboBox,
    QTabWidget, QGridLayout, QCheckBox, QInputDialog  # Added QInputDialog
)

# Assuming these models are correctly defined in base_models
from ui.dialogs.base_dialog import BaseDialog
from models.base_models import MagicalSystem, Spell, SpellEffect, RacialAffinity, ClassAffinity
from models.world_data import MagicSystemManager

logger = logging.getLogger("world_configurator.ui.magic_systems_editor")

class SpellEffectDialog(BaseDialog):
    """Dialog for editing a spell effect."""

    def __init__(self, parent=None, effect: Optional[SpellEffect] = None):
        """
        Initialize the spell effect edit dialog.

        Args:
            parent: The parent widget.
            effect: Optional existing effect to edit.
        """
        super().__init__(parent)
        self.setWindowTitle("Spell Effect")
        self.setMinimumWidth(450)

        # Effect to edit
        self.effect = effect or SpellEffect()

        # Setup UI
        self._setup_ui()

    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)

        # Form layout for fields
        form = QFormLayout()

        # Target type combo
        self.target_type_combo = QComboBox()
        self.target_type_combo.addItems(["target", "caster"])
        if self.effect.target_type == "caster":
            self.target_type_combo.setCurrentIndex(1)
        form.addRow("Target:", self.target_type_combo)

        # Effect type combo
        self.effect_type_combo = QComboBox()
        self.effect_type_combo.addItems(["damage", "healing", "stat_modification", "status_effect"])
        if self.effect.effect_type in ["healing", "stat_modification", "status_effect"]:
            self.effect_type_combo.setCurrentText(self.effect.effect_type)
        self.effect_type_combo.currentTextChanged.connect(self._update_form_visibility)
        form.addRow("Effect Type:", self.effect_type_combo)

        # Value field
        self.value_spin = QSpinBox()
        self.value_spin.setRange(-1000, 1000)
        self.value_spin.setValue(int(self.effect.value))
        form.addRow("Value:", self.value_spin)

        # Dice notation field
        self.dice_edit = QLineEdit(self.effect.dice_notation)
        self.dice_edit.setPlaceholderText("e.g., 2d6+3")
        form.addRow("Dice Notation:", self.dice_edit)

        # Stat affected field (for stat modifications)
        self.stat_combo = QComboBox()
        self.stat_combo.addItems(["", "STR", "DEX", "CON", "INT", "WIS", "CHA",
                                 "HP", "MP", "Stamina", "Initiative", "Defense",
                                 "Magic Resistance", "Melee Attack", "Ranged Attack", "Magic Attack"])
        if self.effect.stat_affected:
            self.stat_combo.setCurrentText(self.effect.stat_affected)
        form.addRow("Stat Affected:", self.stat_combo)

        # Status effect field (for status effects)
        self.status_combo = QComboBox()
        self.status_combo.addItems(["", "Burning", "Poisoned", "Stunned", "Bleeding", "Frozen", "Weakened", "Blinded"])
        if self.effect.status_effect:
            self.status_combo.setCurrentText(self.effect.status_effect)
        form.addRow("Status Effect:", self.status_combo)

        # Duration field
        self.duration_spin = QSpinBox()
        self.duration_spin.setRange(0, 100)
        self.duration_spin.setValue(self.effect.duration)
        self.duration_spin.setSpecialValueText("Instant")
        form.addRow("Duration (turns):", self.duration_spin)

        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.effect.description)
        self.desc_edit.setMinimumHeight(80)
        form.addRow("Description:", self.desc_edit)

        layout.addLayout(form)

        # Buttons
        btn_layout = QHBoxLayout()

        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)

        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)

        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)

        layout.addLayout(btn_layout)

        # Update visibility of fields based on initial effect type
        self._update_form_visibility(self.effect_type_combo.currentText())

    def _update_form_visibility(self, effect_type: str):
        """
        Update the visibility of form fields based on the effect type.

        Args:
            effect_type: The type of effect.
        """
        # Get the form layout
        form_layout = self.layout().itemAt(0).layout()

        # Show/hide stat affected field
        stat_visible = effect_type == "stat_modification"
        self.stat_combo.setVisible(stat_visible)
        stat_label = form_layout.labelForField(self.stat_combo)
        if stat_label: stat_label.setVisible(stat_visible)

        # Show/hide status effect field
        status_visible = effect_type == "status_effect"
        self.status_combo.setVisible(status_visible)
        status_label = form_layout.labelForField(self.status_combo)
        if status_label: status_label.setVisible(status_visible)

        # Show/hide duration field (only for non-instant effects)
        duration_visible = effect_type in ["stat_modification", "status_effect"]
        self.duration_spin.setVisible(duration_visible)
        duration_label = form_layout.labelForField(self.duration_spin)
        if duration_label: duration_label.setVisible(duration_visible)

    def get_effect(self) -> SpellEffect:
        """Get the edited effect."""
        self.effect.target_type = self.target_type_combo.currentText()
        self.effect.effect_type = self.effect_type_combo.currentText()
        self.effect.value = float(self.value_spin.value())
        self.effect.dice_notation = self.dice_edit.text()
        self.effect.stat_affected = self.stat_combo.currentText() if self.stat_combo.isVisible() else ""
        self.effect.status_effect = self.status_combo.currentText() if self.status_combo.isVisible() else ""
        self.effect.duration = self.duration_spin.value() if self.duration_spin.isVisible() else 0
        self.effect.description = self.desc_edit.toPlainText()
        return self.effect

class SpellDialog(QDialog):
    """Dialog for editing a spell."""

    def __init__(self, parent=None, spell: Optional[Spell] = None):
        """
        Initialize the spell edit dialog.

        Args:
            parent: The parent widget.
            spell: Optional existing spell to edit.
        """
        super().__init__(parent)
        self.setWindowTitle("Spell")
        self.setMinimumWidth(600)
        self.setMinimumHeight(600)

        # Spell to edit
        self.spell = spell or Spell.create_new("New Spell", "")

        # Setup UI
        self._setup_ui()

    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)

        # Create tabs
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Basic info tab
        basic_tab = QWidget()
        self.tabs.addTab(basic_tab, "Basic Info")

        basic_layout = QFormLayout(basic_tab)

        # Name field
        self.name_edit = QLineEdit(self.spell.name)
        basic_layout.addRow("Name:", self.name_edit)

        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.spell.description)
        self.desc_edit.setMinimumHeight(100)
        basic_layout.addRow("Description:", self.desc_edit)

        # Level field
        self.level_spin = QSpinBox()
        self.level_spin.setRange(1, 10)
        self.level_spin.setValue(self.spell.level)
        basic_layout.addRow("Level:", self.level_spin)

        # Mana cost field
        self.mana_spin = QSpinBox()
        self.mana_spin.setRange(0, 1000)
        self.mana_spin.setValue(self.spell.mana_cost)
        basic_layout.addRow("Mana Cost:", self.mana_spin)

        # Casting time field
        self.cast_time_edit = QLineEdit(self.spell.casting_time)
        basic_layout.addRow("Casting Time:", self.cast_time_edit)

        # Range field
        self.range_edit = QLineEdit(self.spell.range)
        basic_layout.addRow("Range:", self.range_edit)

        # Target field
        self.target_combo = QComboBox()
        self.target_combo.addItems(["single", "area", "self", "multiple", "all_enemies", "all_allies"])
        if self.spell.target in ["area", "self", "multiple", "all_enemies", "all_allies"]:
            self.target_combo.setCurrentText(self.spell.target)
        basic_layout.addRow("Target:", self.target_combo)

        # Components field
        self.components_edit = QLineEdit(", ".join(self.spell.components))
        self.components_edit.setPlaceholderText("component1, component2, ...")
        basic_layout.addRow("Components:", self.components_edit)

        # Tags field
        self.tags_edit = QLineEdit(", ".join(self.spell.tags))
        self.tags_edit.setPlaceholderText("tag1, tag2, ...")
        basic_layout.addRow("Tags:", self.tags_edit)

        # Effects tab
        effects_tab = QWidget()
        self.tabs.addTab(effects_tab, "Effects")

        effects_layout = QVBoxLayout(effects_tab)

        # Effects list
        effects_label = QLabel("Spell Effects:")
        effects_label.setStyleSheet("font-weight: bold;")
        effects_layout.addWidget(effects_label)

        self.effects_list = QListWidget()
        self.effects_list.setMinimumHeight(200)
        self.effects_list.itemDoubleClicked.connect(self._edit_effect)
        effects_layout.addWidget(self.effects_list)

        # Load existing effects
        for effect in self.spell.effects:
            self._add_effect_to_list(effect)

        # Effect buttons
        effect_btn_layout = QHBoxLayout()

        self.add_effect_btn = QPushButton("Add Effect")
        self.add_effect_btn.clicked.connect(self._add_effect)
        effect_btn_layout.addWidget(self.add_effect_btn)

        self.edit_effect_btn = QPushButton("Edit Effect")
        self.edit_effect_btn.clicked.connect(lambda: self._edit_effect(self.effects_list.currentItem()))
        effect_btn_layout.addWidget(self.edit_effect_btn)

        self.remove_effect_btn = QPushButton("Remove Effect")
        self.remove_effect_btn.clicked.connect(self._remove_effect)
        effect_btn_layout.addWidget(self.remove_effect_btn)

        effects_layout.addLayout(effect_btn_layout)

        # Dialog buttons
        btn_layout = QHBoxLayout()

        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)

        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)

        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)

        layout.addLayout(btn_layout)

    def _add_effect_to_list(self, effect: SpellEffect):
        """
        Add an effect to the effects list.

        Args:
            effect: The effect to add.
        """
        # Create an effect description for the list
        effect_text = f"{effect.target_type.capitalize()} - {effect.effect_type.capitalize()}"

        if effect.effect_type == "damage" or effect.effect_type == "healing":
            if effect.dice_notation:
                effect_text += f": {effect.dice_notation}"
            else:
                effect_text += f": {int(effect.value)}"

        elif effect.effect_type == "stat_modification":
            effect_text += f": {effect.stat_affected} {'+' if effect.value >= 0 else ''}{int(effect.value)}"
            if effect.duration > 0:
                effect_text += f" for {effect.duration} turns"

        elif effect.effect_type == "status_effect":
            effect_text += f": {effect.status_effect}"
            if effect.duration > 0:
                effect_text += f" for {effect.duration} turns"

        item = QListWidgetItem(effect_text)
        item.setData(Qt.UserRole, effect)
        self.effects_list.addItem(item)

    def _add_effect(self):
        """Add a new spell effect."""
        dialog = SpellEffectDialog(self)

        if dialog.exec() == QDialog.Accepted:
            effect = dialog.get_effect()
            self._add_effect_to_list(effect)

    def _edit_effect(self, item: Optional[QListWidgetItem]):
        """
        Edit a spell effect.

        Args:
            item: The list item to edit, or None.
        """
        if not item:
            return

        effect = item.data(Qt.UserRole)
        dialog = SpellEffectDialog(self, effect)

        if dialog.exec() == QDialog.Accepted:
            updated_effect = dialog.get_effect()

            # Update the effect in the list item's data
            item.setData(Qt.UserRole, updated_effect)

            # Re-render the list item text
            row = self.effects_list.row(item)
            self.effects_list.takeItem(row) # Remove temporarily
            self._add_effect_to_list(updated_effect) # Re-add with new text/data

            # Optionally, re-select the item
            # self.effects_list.setCurrentRow(row) # Might change order if sorting is applied

    def _remove_effect(self):
        """Remove the selected spell effect."""
        item = self.effects_list.currentItem()
        if not item:
            return

        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            "Are you sure you want to delete this effect?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if result == QMessageBox.Yes:
            self.effects_list.takeItem(self.effects_list.row(item))

    def get_spell(self) -> Spell:
        """Get the edited spell."""
        # Update basic info
        self.spell.name = self.name_edit.text()
        self.spell.description = self.desc_edit.toPlainText()
        self.spell.level = self.level_spin.value()
        self.spell.mana_cost = self.mana_spin.value()
        self.spell.casting_time = self.cast_time_edit.text()
        self.spell.range = self.range_edit.text()
        self.spell.target = self.target_combo.currentText()

        # Update components and tags (split by comma)
        self.spell.components = [s.strip() for s in self.components_edit.text().split(',') if s.strip()]
        self.spell.tags = [s.strip() for s in self.tags_edit.text().split(',') if s.strip()]

        # Update effects
        self.spell.effects = []
        for i in range(self.effects_list.count()):
            effect = self.effects_list.item(i).data(Qt.UserRole)
            self.spell.effects.append(effect)

        return self.spell

class RacialAffinityDialog(QDialog):
    """
    Dialog for editing racial affinity for a magic system.
    """

    def __init__(self, parent=None, race_name: str = "", affinity: Optional[RacialAffinity] = None):
        """
        Initialize the racial affinity edit dialog.

        Args:
            parent: The parent widget.
            race_name: The name of the race.
            affinity: Optional existing affinity to edit.
        """
        super().__init__(parent)
        self.setWindowTitle(f"Racial Affinity: {race_name}")
        self.setMinimumWidth(400)

        self.race_name = race_name
        self.affinity = affinity or RacialAffinity()

        # Setup UI
        self._setup_ui()

    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)

        # Form layout for fields
        form = QFormLayout()

        # Affinity level combo
        self.affinity_combo = QComboBox()
        self.affinity_combo.addItems(["Very High", "High", "Medium", "Low", "Very Low"])
        self.affinity_combo.setCurrentText(self.affinity.affinity_level)
        form.addRow("Affinity Level:", self.affinity_combo)

        # Learning difficulty combo
        self.difficulty_combo = QComboBox()
        self.difficulty_combo.addItems(["Very Easy", "Easy", "Moderate", "Hard", "Very Hard", "Extremely Hard"])
        self.difficulty_combo.setCurrentText(self.affinity.learning_difficulty)
        form.addRow("Learning Difficulty:", self.difficulty_combo)

        # Natural talent checkbox
        self.natural_talent_check = QCheckBox("Has Natural Talent")
        self.natural_talent_check.setChecked(self.affinity.natural_talent)
        form.addRow("", self.natural_talent_check)

        # Bonus effects field
        self.bonus_edit = QLineEdit(self.affinity.bonus_effects or "")
        self.bonus_edit.setPlaceholderText("e.g., 20% reduced mana cost for all spells")
        form.addRow("Bonus Effects:", self.bonus_edit)

        layout.addLayout(form)

        # Buttons
        btn_layout = QHBoxLayout()

        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)

        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)

        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)

        layout.addLayout(btn_layout)

    def get_affinity(self) -> RacialAffinity:
        """Get the edited racial affinity."""
        self.affinity.affinity_level = self.affinity_combo.currentText()
        self.affinity.learning_difficulty = self.difficulty_combo.currentText()
        self.affinity.natural_talent = self.natural_talent_check.isChecked()

        bonus_text = self.bonus_edit.text().strip()
        self.affinity.bonus_effects = bonus_text if bonus_text else None

        return self.affinity

class ClassAffinityDialog(QDialog):
    """
    Dialog for editing class affinity for a magic system.
    """

    def __init__(self, parent=None, class_name: str = "", affinity: Optional[ClassAffinity] = None):
        """
        Initialize the class affinity edit dialog.

        Args:
            parent: The parent widget.
            class_name: The name of the class.
            affinity: Optional existing affinity to edit.
        """
        super().__init__(parent)
        self.setWindowTitle(f"Class Affinity: {class_name}")
        self.setMinimumWidth(400)

        self.class_name = class_name
        self.affinity = affinity or ClassAffinity()

        # Setup UI
        self._setup_ui()

    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)

        # Form layout for fields
        form = QFormLayout()

        # Affinity level combo
        self.affinity_combo = QComboBox()
        self.affinity_combo.addItems(["Very High", "High", "Medium", "Low", "Very Low"])
        self.affinity_combo.setCurrentText(self.affinity.affinity_level)
        form.addRow("Affinity Level:", self.affinity_combo)

        # Learning difficulty combo
        self.difficulty_combo = QComboBox()
        self.difficulty_combo.addItems(["Very Easy", "Easy", "Moderate", "Hard", "Very Hard", "Extremely Hard"])
        self.difficulty_combo.setCurrentText(self.affinity.learning_difficulty)
        form.addRow("Learning Difficulty:", self.difficulty_combo)

        # Required stats section
        stats_label = QLabel("Required Stats:")
        stats_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        form.addRow(stats_label)

        # Create a grid for stat inputs
        stats_grid = QGridLayout()

        # Define possible stats
        self.stat_edits = {}
        stats = ["STR", "DEX", "CON", "INT", "WIS", "CHA"]

        # Create spinboxes for each stat
        for i, stat in enumerate(stats):
            label = QLabel(f"{stat}:")
            spinbox = QSpinBox()
            spinbox.setRange(0, 20)  # Assuming max stat is 20
            spinbox.setValue(self.affinity.required_stats.get(stat, 0))
            spinbox.setSpecialValueText("None")  # Display "None" for 0

            self.stat_edits[stat] = spinbox

            # Position in a 3x2 grid
            row = i // 2
            col = i % 2 * 2  # Use column 0 and 2

            stats_grid.addWidget(label, row, col)
            stats_grid.addWidget(spinbox, row, col + 1)

        form.addRow("", stats_grid) # Add the grid layout to the form

        layout.addLayout(form)

        # Buttons
        btn_layout = QHBoxLayout()

        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)

        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)

        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)

        layout.addLayout(btn_layout)

    def get_affinity(self) -> ClassAffinity:
        """Get the edited class affinity."""
        self.affinity.affinity_level = self.affinity_combo.currentText()
        self.affinity.learning_difficulty = self.difficulty_combo.currentText()

        # Update required stats
        required_stats = {}
        for stat, spinbox in self.stat_edits.items():
            value = spinbox.value()
            if value > 0:
                required_stats[stat] = value

        self.affinity.required_stats = required_stats

        return self.affinity

class MagicSystemDialog(QDialog):
    """
    Dialog for editing a magic system.
    """

    def __init__(self, parent=None, magic_system: Optional[MagicalSystem] = None):
        """
        Initialize the magic system edit dialog.

        Args:
            parent: The parent widget.
            magic_system: Optional existing magic system to edit.
        """
        super().__init__(parent)
        self.setWindowTitle("Magic System")
        self.setMinimumWidth(650) # Increased width slightly for tabs
        self.setMinimumHeight(600) # Increased height slightly

        # Magic system to edit
        # Make a deep copy to avoid modifying the original if cancelled
        import copy
        self.magic_system = copy.deepcopy(magic_system) if magic_system else MagicalSystem.create_new("New Magic System", "")
        # Ensure spells dict exists if it's a new system or loaded without it
        if not hasattr(self.magic_system, 'spells') or self.magic_system.spells is None:
             self.magic_system.spells = {}
        if not hasattr(self.magic_system, 'racial_affinities') or self.magic_system.racial_affinities is None:
             self.magic_system.racial_affinities = {}
        if not hasattr(self.magic_system, 'class_affinities') or self.magic_system.class_affinities is None:
             self.magic_system.class_affinities = {}


        # Setup UI
        self._setup_ui()

    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)

        # Create tabs
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # --- Basic info tab ---
        basic_tab = QWidget()
        self.tabs.addTab(basic_tab, "Basic Info")
        basic_layout = QFormLayout(basic_tab)
        # (Keep all existing fields for Name, Description, Origin, etc. here)
        self.name_edit = QLineEdit(self.magic_system.name)
        basic_layout.addRow("Name:", self.name_edit)
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.magic_system.description)
        self.desc_edit.setMinimumHeight(80)
        basic_layout.addRow("Description:", self.desc_edit)
        self.origin_edit = QTextEdit()
        self.origin_edit.setPlainText(self.magic_system.origin)
        self.origin_edit.setMinimumHeight(50)
        basic_layout.addRow("Origin:", self.origin_edit)
        self.limitations_edit = QTextEdit()
        self.limitations_edit.setPlainText(self.magic_system.limitations)
        self.limitations_edit.setMinimumHeight(50)
        basic_layout.addRow("Limitations:", self.limitations_edit)
        self.practitioners_edit = QTextEdit()
        self.practitioners_edit.setPlainText(self.magic_system.practitioners)
        self.practitioners_edit.setMinimumHeight(50)
        basic_layout.addRow("Practitioners:", self.practitioners_edit)
        self.cultural_edit = QTextEdit()
        self.cultural_edit.setPlainText(self.magic_system.cultural_significance)
        self.cultural_edit.setMinimumHeight(50)
        basic_layout.addRow("Cultural Significance:", self.cultural_edit)
        basic_layout.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)


        # --- Spells Tab (NEW) ---
        spells_tab = QWidget()
        self.tabs.addTab(spells_tab, "Spells")
        spells_layout = QVBoxLayout(spells_tab)

        spells_label = QLabel("Spells:")
        spells_label.setStyleSheet("font-weight: bold;")
        spells_layout.addWidget(spells_label)

        self.spells_list = QListWidget()
        self.spells_list.setMinimumHeight(250)
        self.spells_list.itemDoubleClicked.connect(self._edit_spell)
        spells_layout.addWidget(self.spells_list)

        # Load existing spells
        if self.magic_system.spells: # Check if spells dict exists and is not None
            for spell_id, spell in self.magic_system.spells.items():
                self._add_spell_to_list(spell)

        # Spell buttons
        spell_btn_layout = QHBoxLayout()
        self.add_spell_btn = QPushButton("Add Spell")
        self.add_spell_btn.clicked.connect(self._add_spell)
        spell_btn_layout.addWidget(self.add_spell_btn)

        self.edit_spell_btn = QPushButton("Edit Spell")
        self.edit_spell_btn.clicked.connect(lambda: self._edit_spell(self.spells_list.currentItem()))
        spell_btn_layout.addWidget(self.edit_spell_btn)

        self.remove_spell_btn = QPushButton("Remove Spell")
        self.remove_spell_btn.clicked.connect(self._remove_spell)
        spell_btn_layout.addWidget(self.remove_spell_btn)

        spells_layout.addLayout(spell_btn_layout)


        # --- Racial Affinities tab ---
        racial_tab = QWidget()
        self.tabs.addTab(racial_tab, "Race Affinities")
        racial_layout = QVBoxLayout(racial_tab)
        # (Keep existing Race Affinities list and buttons here)
        race_label = QLabel("Race Affinities:")
        race_label.setStyleSheet("font-weight: bold;")
        racial_layout.addWidget(race_label)
        self.races_list = QListWidget()
        self.races_list.setMinimumHeight(250)
        self.races_list.itemDoubleClicked.connect(self._edit_race_affinity)
        racial_layout.addWidget(self.races_list)
        # Load existing racial affinities
        if self.magic_system.racial_affinities:
            for race_name, affinity in self.magic_system.racial_affinities.items():
                self._add_race_affinity_to_list(race_name, affinity)
        # Race affinity buttons
        race_btn_layout = QHBoxLayout()
        self.add_race_btn = QPushButton("Add Race")
        self.add_race_btn.clicked.connect(self._add_race_affinity)
        race_btn_layout.addWidget(self.add_race_btn)
        self.edit_race_btn = QPushButton("Edit Race")
        self.edit_race_btn.clicked.connect(lambda: self._edit_race_affinity(self.races_list.currentItem()))
        race_btn_layout.addWidget(self.edit_race_btn)
        self.remove_race_btn = QPushButton("Remove Race")
        self.remove_race_btn.clicked.connect(self._remove_race_affinity)
        race_btn_layout.addWidget(self.remove_race_btn)
        racial_layout.addLayout(race_btn_layout)


        # --- Class Affinities tab ---
        class_tab = QWidget()
        self.tabs.addTab(class_tab, "Class Affinities")
        class_layout = QVBoxLayout(class_tab)
        # (Keep existing Class Affinities list and buttons here)
        class_label = QLabel("Class Affinities:")
        class_label.setStyleSheet("font-weight: bold;")
        class_layout.addWidget(class_label)
        self.classes_list = QListWidget()
        self.classes_list.setMinimumHeight(250)
        self.classes_list.itemDoubleClicked.connect(self._edit_class_affinity)
        class_layout.addWidget(self.classes_list)
        # Load existing class affinities
        if self.magic_system.class_affinities:
            for class_name, affinity in self.magic_system.class_affinities.items():
                self._add_class_affinity_to_list(class_name, affinity)
        # Class affinity buttons
        class_btn_layout = QHBoxLayout()
        self.add_class_btn = QPushButton("Add Class")
        self.add_class_btn.clicked.connect(self._add_class_affinity)
        class_btn_layout.addWidget(self.add_class_btn)
        self.edit_class_btn = QPushButton("Edit Class")
        self.edit_class_btn.clicked.connect(lambda: self._edit_class_affinity(self.classes_list.currentItem()))
        class_btn_layout.addWidget(self.edit_class_btn)
        self.remove_class_btn = QPushButton("Remove Class")
        self.remove_class_btn.clicked.connect(self._remove_class_affinity)
        class_btn_layout.addWidget(self.remove_class_btn)
        class_layout.addLayout(class_btn_layout)


        # --- Dialog Buttons ---
        btn_layout = QHBoxLayout()
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        layout.addLayout(btn_layout)

    # --- Spell Methods (NEW) ---

    def _add_spell_to_list(self, spell: Spell):
        """Add a spell to the spells list widget."""
        item_text = f"{spell.name}"
        if spell.level > 0: # Show level if > 0
            item_text += f" (Level {spell.level})"
        if spell.mana_cost > 0:
             item_text += f" [{spell.mana_cost} Mana]"

        item = QListWidgetItem(item_text)
        item.setData(Qt.UserRole, spell) # Store the whole spell object
        self.spells_list.addItem(item)
        # Sort list by name after adding
        self.spells_list.sortItems(Qt.AscendingOrder)


    def _add_spell(self):
        """Add a new spell using the SpellDialog."""
        dialog = SpellDialog(self) # Create a dialog for a new spell

        if dialog.exec() == QDialog.Accepted:
            new_spell = dialog.get_spell()

            # Ensure the new spell has a unique ID within this system
            if not new_spell.id or new_spell.id in self.magic_system.spells:
                new_spell.id = Spell.generate_id()
                while new_spell.id in self.magic_system.spells: # Ensure uniqueness
                    new_spell.id = Spell.generate_id()

            # Add to the internal magic system object
            self.magic_system.spells[new_spell.id] = new_spell

            # Add to the list widget
            self._add_spell_to_list(new_spell)
            logger.info(f"Added spell '{new_spell.name}' to magic system '{self.magic_system.name}' (in dialog).")

    def _edit_spell(self, item: Optional[QListWidgetItem]):
        """Edit the selected spell using the SpellDialog."""
        if not item:
            current_item = self.spells_list.currentItem()
            if not current_item:
                 QMessageBox.information(self, "Edit Spell", "Please select a spell to edit.")
                 return
            item = current_item # Use current selection if item not passed (e.g., from button)

        original_spell = item.data(Qt.UserRole)
        if not original_spell or not isinstance(original_spell, Spell):
            logger.error("Could not retrieve spell data from list item for editing.")
            QMessageBox.critical(self, "Error", "Could not retrieve spell data for editing.")
            return

        # Pass a copy to the dialog, so cancelling doesn't affect the list item's data yet
        import copy
        spell_copy = copy.deepcopy(original_spell)
        dialog = SpellDialog(self, spell_copy)

        if dialog.exec() == QDialog.Accepted:
            updated_spell = dialog.get_spell()
            updated_spell.id = original_spell.id # Ensure ID remains the same

            # Update the spell in the internal magic system object
            self.magic_system.spells[updated_spell.id] = updated_spell

            # Update the list widget: Remove old, add new
            row = self.spells_list.row(item)
            self.spells_list.takeItem(row)
            self._add_spell_to_list(updated_spell)

            # Try to reselect (list might be sorted differently now)
            items = self.spells_list.findItems(updated_spell.name, Qt.MatchExactly)
            if items:
                # Find the one with the correct ID if names aren't unique (though they should be)
                for found_item in items:
                    if found_item.data(Qt.UserRole).id == updated_spell.id:
                        self.spells_list.setCurrentItem(found_item)
                        break

            logger.info(f"Edited spell '{updated_spell.name}' in magic system '{self.magic_system.name}' (in dialog).")


    def _remove_spell(self):
        """Remove the selected spell."""
        item = self.spells_list.currentItem()
        if not item:
            QMessageBox.information(self, "Remove Spell", "Please select a spell to remove.")
            return

        spell_to_remove = item.data(Qt.UserRole)
        if not spell_to_remove or not isinstance(spell_to_remove, Spell):
            logger.error("Could not retrieve spell data from list item for removal.")
            QMessageBox.critical(self, "Error", "Could not retrieve spell data for removal.")
            return

        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the spell '{spell_to_remove.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if result == QMessageBox.Yes:
            # Remove from the internal magic system object
            if spell_to_remove.id in self.magic_system.spells:
                del self.magic_system.spells[spell_to_remove.id]
                logger.info(f"Removed spell '{spell_to_remove.name}' (ID: {spell_to_remove.id}) from magic system '{self.magic_system.name}' (in dialog).")
            else:
                 logger.warning(f"Spell ID '{spell_to_remove.id}' not found in internal dictionary for removal.")

            # Remove from the list widget
            self.spells_list.takeItem(self.spells_list.row(item))

    def _add_race_affinity_to_list(self, race_name: str, affinity: RacialAffinity):
        """Add a race affinity to the list widget."""
        item_text = f"{race_name}: {affinity.affinity_level} Affinity ({affinity.learning_difficulty})"
        if affinity.natural_talent: item_text += " - Natural Talent"
        if affinity.bonus_effects: item_text += f" ({affinity.bonus_effects})" # Show bonus effects

        item = QListWidgetItem(item_text)
        item.setData(Qt.UserRole, race_name) # Store race name as data
        item.setData(Qt.UserRole + 1, affinity) # Store affinity object as well
        self.races_list.addItem(item)
        self.races_list.sortItems(Qt.AscendingOrder) # Sort

    def _add_race_affinity(self):
        """Add a new race affinity."""
        race_name, ok = QInputDialog.getText(self, "Add Race Affinity", "Race name:")
        if ok and race_name:
            race_name = race_name.strip()
            if not race_name:
                QMessageBox.warning(self, "Invalid Name", "Race name cannot be empty.")
                return
            if race_name in self.magic_system.racial_affinities:
                QMessageBox.warning(self, "Duplicate Race", f"Race '{race_name}' already has an affinity defined.")
                return

            dialog = RacialAffinityDialog(self, race_name)
            if dialog.exec() == QDialog.Accepted:
                affinity = dialog.get_affinity()
                self.magic_system.racial_affinities[race_name] = affinity
                self._add_race_affinity_to_list(race_name, affinity)

    def _edit_race_affinity(self, item: Optional[QListWidgetItem]):
        """Edit a race affinity."""
        if not item:
            current_item = self.races_list.currentItem()
            if not current_item:
                 QMessageBox.information(self, "Edit Race Affinity", "Please select a race affinity to edit.")
                 return
            item = current_item

        race_name = item.data(Qt.UserRole)
        affinity = item.data(Qt.UserRole + 1)
        if not affinity: # Fallback
             if race_name in self.magic_system.racial_affinities:
                 affinity = self.magic_system.racial_affinities[race_name]
             else:
                 logger.warning(f"Affinity data mismatch for race '{race_name}' in list.")
                 QMessageBox.critical(self, "Error", f"Could not retrieve affinity data for race '{race_name}'.")
                 return

        import copy
        affinity_copy = copy.deepcopy(affinity)
        dialog = RacialAffinityDialog(self, race_name, affinity_copy)
        if dialog.exec() == QDialog.Accepted:
            updated_affinity = dialog.get_affinity()
            self.magic_system.racial_affinities[race_name] = updated_affinity
            row = self.races_list.row(item)
            self.races_list.takeItem(row)
            self._add_race_affinity_to_list(race_name, updated_affinity)
            # Try re-select
            items = self.races_list.findItems(race_name + ":", Qt.MatchStartsWith)
            if items: self.races_list.setCurrentItem(items[0])


    def _remove_race_affinity(self):
        """Remove a race affinity."""
        item = self.races_list.currentItem()
        if not item:
            QMessageBox.information(self, "Remove Race Affinity", "Please select a race affinity to remove.")
            return

        race_name = item.data(Qt.UserRole)
        result = QMessageBox.question(
            self, "Confirm Deletion",
            f"Are you sure you want to remove the affinity for race '{race_name}'?",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )
        if result == QMessageBox.Yes:
            if race_name in self.magic_system.racial_affinities:
                del self.magic_system.racial_affinities[race_name]
            self.races_list.takeItem(self.races_list.row(item))

    # --- Class Affinity Methods ---

    def _add_class_affinity_to_list(self, class_name: str, affinity: ClassAffinity):
        """Add a class affinity to the list widget."""
        item_text = f"{class_name}: {affinity.affinity_level} Affinity ({affinity.learning_difficulty})"
        req_stats = ", ".join([f"{k}={v}" for k, v in affinity.required_stats.items()])
        if req_stats: item_text += f" - Requires: {req_stats}"

        item = QListWidgetItem(item_text)
        item.setData(Qt.UserRole, class_name) # Store class name as data
        item.setData(Qt.UserRole + 1, affinity) # Store affinity object
        self.classes_list.addItem(item)
        self.classes_list.sortItems(Qt.AscendingOrder) # Sort

    def _add_class_affinity(self):
        """Add a new class affinity."""
        class_name, ok = QInputDialog.getText(self, "Add Class Affinity", "Class name:")
        if ok and class_name:
            class_name = class_name.strip()
            if not class_name:
                QMessageBox.warning(self, "Invalid Name", "Class name cannot be empty.")
                return
            if class_name in self.magic_system.class_affinities:
                QMessageBox.warning(self, "Duplicate Class", f"Class '{class_name}' already has an affinity defined.")
                return

            dialog = ClassAffinityDialog(self, class_name)
            if dialog.exec() == QDialog.Accepted:
                affinity = dialog.get_affinity()
                self.magic_system.class_affinities[class_name] = affinity
                self._add_class_affinity_to_list(class_name, affinity)

    def _edit_class_affinity(self, item: Optional[QListWidgetItem]):
        """Edit a class affinity."""
        if not item:
            current_item = self.classes_list.currentItem()
            if not current_item:
                 QMessageBox.information(self, "Edit Class Affinity", "Please select a class affinity to edit.")
                 return
            item = current_item

        class_name = item.data(Qt.UserRole)
        affinity = item.data(Qt.UserRole + 1)
        if not affinity: # Fallback
            if class_name in self.magic_system.class_affinities:
                affinity = self.magic_system.class_affinities[class_name]
            else:
                logger.warning(f"Affinity data mismatch for class '{class_name}' in list.")
                QMessageBox.critical(self, "Error", f"Could not retrieve affinity data for class '{class_name}'.")
                return

        import copy
        affinity_copy = copy.deepcopy(affinity)
        dialog = ClassAffinityDialog(self, class_name, affinity_copy)
        if dialog.exec() == QDialog.Accepted:
            updated_affinity = dialog.get_affinity()
            self.magic_system.class_affinities[class_name] = updated_affinity
            row = self.classes_list.row(item)
            self.classes_list.takeItem(row)
            self._add_class_affinity_to_list(class_name, updated_affinity)
             # Try re-select
            items = self.classes_list.findItems(class_name + ":", Qt.MatchStartsWith)
            if items: self.classes_list.setCurrentItem(items[0])

    def _remove_class_affinity(self):
        """Remove a class affinity."""
        item = self.classes_list.currentItem()
        if not item:
             QMessageBox.information(self, "Remove Class Affinity", "Please select a class affinity to remove.")
             return

        class_name = item.data(Qt.UserRole)
        result = QMessageBox.question(
            self, "Confirm Deletion",
            f"Are you sure you want to remove the affinity for class '{class_name}'?",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )
        if result == QMessageBox.Yes:
            if class_name in self.magic_system.class_affinities:
                del self.magic_system.class_affinities[class_name]
            self.classes_list.takeItem(self.classes_list.row(item))

    def get_magic_system(self) -> MagicalSystem:
        """Get the edited magic system."""
        # Update basic info from the edits
        self.magic_system.name = self.name_edit.text()
        self.magic_system.description = self.desc_edit.toPlainText()
        self.magic_system.origin = self.origin_edit.toPlainText()
        self.magic_system.limitations = self.limitations_edit.toPlainText()
        self.magic_system.practitioners = self.practitioners_edit.toPlainText()
        self.magic_system.cultural_significance = self.cultural_edit.toPlainText()

        return self.magic_system


class MagicSystemsEditor(QWidget):
    """
    Magic systems editor component.
    """

    # Signals
    magic_system_modified = Signal()

    def __init__(self, parent=None):
        """
        Initialize the magic systems editor.

        Args:
            parent: The parent widget.
        """
        super().__init__(parent)

        # Internal state
        self.magic_system_manager = MagicSystemManager()
        self.current_system: Optional[MagicalSystem] = None

        # Setup UI
        self._setup_ui()

    def _setup_ui(self):
        """Setup the editor UI."""
        main_layout = QHBoxLayout(self)

        # Create a splitter for resizable panels
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)

        # Left panel (magic system list)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)

        list_label = QLabel("Magic Systems")
        list_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        left_layout.addWidget(list_label)

        self.system_list = QListWidget()
        self.system_list.setMinimumWidth(200)
        self.system_list.currentItemChanged.connect(self._on_system_selected)
        left_layout.addWidget(self.system_list)

        list_buttons = QHBoxLayout()

        self.add_system_btn = QPushButton("Add")
        self.add_system_btn.clicked.connect(self._add_system)
        list_buttons.addWidget(self.add_system_btn)

        self.edit_system_btn = QPushButton("Edit") # Added Edit button
        self.edit_system_btn.clicked.connect(self._edit_system)
        self.edit_system_btn.setEnabled(False)
        list_buttons.addWidget(self.edit_system_btn)

        self.remove_system_btn = QPushButton("Remove")
        self.remove_system_btn.clicked.connect(self._remove_system)
        self.remove_system_btn.setEnabled(False)
        list_buttons.addWidget(self.remove_system_btn)

        left_layout.addLayout(list_buttons)

        # Add left panel to splitter
        splitter.addWidget(left_panel)

        # Right panel (magic system details - simplified view)
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)

        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)

        self.details_layout = QVBoxLayout(self.details_widget)

        # Display fields (read-only in this view)
        self.details_form_layout = QFormLayout()

        self.name_label = QLabel()
        self.name_label.setWordWrap(True)
        self.details_form_layout.addRow("<b>Name:</b>", self.name_label)

        self.desc_label = QLabel()
        self.desc_label.setWordWrap(True)
        self.details_form_layout.addRow("<b>Description:</b>", self.desc_label)

        self.origin_label = QLabel()
        self.origin_label.setWordWrap(True)
        self.details_form_layout.addRow("<b>Origin:</b>", self.origin_label)

        self.limitations_label = QLabel()
        self.limitations_label.setWordWrap(True)
        self.details_form_layout.addRow("<b>Limitations:</b>", self.limitations_label)

        self.practitioners_label = QLabel()
        self.practitioners_label.setWordWrap(True)
        self.details_form_layout.addRow("<b>Practitioners:</b>", self.practitioners_label)

        self.cultural_label = QLabel()
        self.cultural_label.setWordWrap(True)
        self.details_form_layout.addRow("<b>Cultural Significance:</b>", self.cultural_label)

        self.details_layout.addLayout(self.details_form_layout)

        # Spells section (read-only list in this view)
        spells_label = QLabel("Spells")
        spells_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(spells_label)

        self.spells_list_display = QListWidget()
        self.spells_list_display.setMinimumHeight(150)
        self.spells_list_display.setEnabled(False) # Read-only display
        self.details_layout.addWidget(self.spells_list_display)

        # Affinities display (read-only)
        affinities_label = QLabel("Affinities")
        affinities_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(affinities_label)

        self.affinities_list_display = QListWidget()
        self.affinities_list_display.setMinimumHeight(150)
        self.affinities_list_display.setEnabled(False) # Read-only display
        self.details_layout.addWidget(self.affinities_list_display)


        self.details_layout.addStretch() # Push content up

        # Add right panel to splitter
        splitter.addWidget(right_panel)

        # Set up initial state
        self._disable_details_display()

        # Prioritize the details panel for resizing
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)

    def set_magic_system_manager(self, manager: MagicSystemManager) -> None:
        """
        Set the magic system manager to use.

        Args:
            manager: The magic system manager.
        """
        self.magic_system_manager = manager
        self._refresh_system_list()

    def _refresh_system_list(self) -> None:
        """Refresh the magic system list from the manager."""
        current_id = None
        if self.system_list.currentItem():
            current_id = self.system_list.currentItem().data(Qt.UserRole)

        # Clear list
        self.system_list.clear()

        # Add all magic systems
        items_to_add = []
        for system_id, system in self.magic_system_manager.magic_systems.items():
            item = QListWidgetItem(system.name)
            item.setData(Qt.UserRole, system_id)
            items_to_add.append(item)

        # Sort alphabetically by name before adding
        items_to_add.sort(key=lambda x: x.text())
        for item in items_to_add:
            self.system_list.addItem(item)

        # Reselect previous item if possible
        new_selection = None
        if current_id:
            for i in range(self.system_list.count()):
                if self.system_list.item(i).data(Qt.UserRole) == current_id:
                    new_selection = self.system_list.item(i)
                    break

        if new_selection:
            self.system_list.setCurrentItem(new_selection)
        elif self.system_list.count() > 0:
            self.system_list.setCurrentRow(0)
        else:
             # No items left, disable details
            self._disable_details_display()
            self.edit_system_btn.setEnabled(False)
            self.remove_system_btn.setEnabled(False)


    def _on_system_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]) -> None:
        """
        Handle magic system selection change.

        Args:
            current: The current selected item, or None.
            previous: The previously selected item, or None.
        """
        if current:
            system_id = current.data(Qt.UserRole)
            magic_system = self.magic_system_manager.get_magic_system(system_id)

            if magic_system:
                self._load_system_display(magic_system)
                self.edit_system_btn.setEnabled(True)
                self.remove_system_btn.setEnabled(True)
                return

        # No valid selection
        self._disable_details_display()
        self.edit_system_btn.setEnabled(False)
        self.remove_system_btn.setEnabled(False)

    def _load_system_display(self, magic_system: MagicalSystem) -> None:
        """
        Load a magic system into the read-only display area.

        Args:
            magic_system: The magic system to load.
        """
        try:
            self.current_system = magic_system # Keep track of the current system object

            # Set display labels
            self.name_label.setText(magic_system.name or "N/A")
            self.desc_label.setText(magic_system.description or "N/A")
            self.origin_label.setText(magic_system.origin or "N/A")
            self.limitations_label.setText(magic_system.limitations or "N/A")
            self.practitioners_label.setText(magic_system.practitioners or "N/A")
            self.cultural_label.setText(magic_system.cultural_significance or "N/A")

            # Load spells display
            self.spells_list_display.clear()
            for spell_id, spell in magic_system.spells.items():
                item_text = f"{spell.name}"
                if spell.level > 1:
                    item_text += f" (Level {spell.level})"
                self.spells_list_display.addItem(item_text)

            # Load affinities display
            self.affinities_list_display.clear()
            # Races
            for race_name, affinity in magic_system.racial_affinities.items():
                 item_text = f"Race - {race_name}: {affinity.affinity_level} ({affinity.learning_difficulty})"
                 if affinity.natural_talent: item_text += " [Natural Talent]"
                 if affinity.bonus_effects: item_text += f" ({affinity.bonus_effects})"
                 self.affinities_list_display.addItem(item_text)
            # Classes
            for class_name, affinity in magic_system.class_affinities.items():
                item_text = f"Class - {class_name}: {affinity.affinity_level} ({affinity.learning_difficulty})"
                req_stats = ", ".join([f"{k}={v}" for k, v in affinity.required_stats.items()])
                if req_stats: item_text += f" [Req: {req_stats}]"
                self.affinities_list_display.addItem(item_text)


            # Enable display area (conceptually, it's always visible)
            self.details_widget.setEnabled(True)

        except Exception as e:
            logger.error(f"Error loading display for magic system {magic_system.name}: {str(e)}")
            QMessageBox.warning(
                self,
                "Error Loading Magic System Display",
                f"There was an error displaying the magic system '{magic_system.name}':\n\n{str(e)}"
            )
            self._disable_details_display()

    def _disable_details_display(self) -> None:
        """Disable/clear the detail display controls."""
        self.current_system = None

        self.name_label.clear()
        self.desc_label.clear()
        self.origin_label.clear()
        self.limitations_label.clear()
        self.practitioners_label.clear()
        self.cultural_label.clear()

        self.spells_list_display.clear()
        self.affinities_list_display.clear()

        self.details_widget.setEnabled(False)


    def _add_system(self) -> None:
        """Add a new magic system using the dialog."""
        # Create a new blank system to pass to the dialog
        new_system = MagicalSystem.create_new("New Magic System", "")
        dialog = MagicSystemDialog(self, new_system) # Pass the new system

        if dialog.exec() == QDialog.Accepted:
            # Get the potentially modified system from the dialog
            magic_system = dialog.get_magic_system()

            # Ensure it has a unique ID if it's truly new
            if not magic_system.id:
                 magic_system.id = MagicalSystem.generate_id()

            # Add to manager
            self.magic_system_manager.add_magic_system(magic_system)

            # Refresh list
            self._refresh_system_list()

            # Find and select the new magic system
            for i in range(self.system_list.count()):
                item = self.system_list.item(i)
                if item.data(Qt.UserRole) == magic_system.id:
                    self.system_list.setCurrentItem(item)
                    break

            # Emit modified signal
            self.magic_system_modified.emit()

            # Log
            logger.info(f"Added new magic system: {magic_system.name} ({magic_system.id})")

    def _edit_system(self) -> None:
        """Edit the selected magic system using the dialog."""
        current_item = self.system_list.currentItem()
        if not current_item:
            return

        system_id = current_item.data(Qt.UserRole)
        magic_system = self.magic_system_manager.get_magic_system(system_id)

        if not magic_system:
            logger.error(f"Could not find magic system with ID {system_id} for editing.")
            return

        # Pass a deep copy to the dialog to avoid modifying the original if cancelled
        import copy
        system_copy = copy.deepcopy(magic_system)
        dialog = MagicSystemDialog(self, system_copy)

        if dialog.exec() == QDialog.Accepted:
            # Get the edited system from the dialog
            edited_system = dialog.get_magic_system()

            # Update the manager with the edited system (using the original ID)
            edited_system.id = system_id # Ensure ID remains the same
            self.magic_system_manager.add_magic_system(edited_system) # Overwrites existing

            # Refresh the list (might update name) and details display
            self._refresh_system_list() # This will re-select and trigger _load_system_display

            # Emit modified signal
            self.magic_system_modified.emit()

            # Log
            logger.info(f"Edited magic system: {edited_system.name} ({edited_system.id})")


    def _remove_system(self) -> None:
        """Remove the selected magic system."""
        current_item = self.system_list.currentItem()
        if not current_item:
            return

        system_id = current_item.data(Qt.UserRole)
        magic_system = self.magic_system_manager.get_magic_system(system_id)

        if not magic_system:
            logger.error(f"Could not find magic system with ID {system_id} for removal.")
            return

        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the magic system '{magic_system.name}'?\n\nThis action cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if result != QMessageBox.Yes:
            return

        # Remove from manager
        removed = self.magic_system_manager.remove_magic_system(system_id)

        if removed:
            # Refresh list
            self._refresh_system_list() # Will select next/first or disable details

            # Emit modified signal
            self.magic_system_modified.emit()

            # Log
            logger.info(f"Removed magic system: {magic_system.name} ({system_id})")
        else:
             logger.error(f"Failed to remove magic system: {magic_system.name} ({system_id})")
             QMessageBox.critical(self, "Error", f"Could not remove magic system '{magic_system.name}'.")
```

### File: world_configurator\ui\editors\names_editor.py

```python
"""
Names editor for config/npc/names.json.
"""
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QDoubleSpinBox,
    QComboBox, QMessageBox, QSpinBox
)
import os
import json
import random
import re
from utils.file_manager import get_config_dir

class NamesEditor(QWidget):
    names_modified = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._data = {"cultures": {}}
        self._current_culture = None
        self._manager = None
        self._setup_ui()
        # Do not auto-load; main window will call refresh after managers sync

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        top = QHBoxLayout()
        self.culture_combo = QComboBox()
        self.culture_combo.currentIndexChanged.connect(self._on_culture_changed)
        self.add_culture_edit = QLineEdit(); self.add_culture_edit.setPlaceholderText("new culture id")
        self.add_culture_btn = QPushButton("Add Culture")
        self.add_culture_btn.clicked.connect(self._add_culture)
        top.addWidget(QLabel("Culture:")); top.addWidget(self.culture_combo); top.addWidget(self.add_culture_edit); top.addWidget(self.add_culture_btn)
        layout.addLayout(top)

        form = QFormLayout()
        self.patterns_edit = QTextEdit(); self.patterns_edit.setPlaceholderText("One per line. Tokens: FN, FN2, MI, LN, LN2. Examples: 'FN MI LN', 'FN LN-LN2', 'FN FN2 LN'")
        form.addRow("Patterns:", self.patterns_edit)
        self.first_syllables_edit = QTextEdit(); self.first_syllables_edit.setPlaceholderText("Comma-separated syllables")
        form.addRow("First syllables:", self.first_syllables_edit)
        self.last_prefixes_edit = QTextEdit(); self.last_prefixes_edit.setPlaceholderText("Comma-separated prefixes")
        form.addRow("Last prefixes:", self.last_prefixes_edit)
        self.last_cores_edit = QTextEdit(); self.last_cores_edit.setPlaceholderText("Comma-separated cores")
        form.addRow("Last cores:", self.last_cores_edit)
        self.last_suffixes_edit = QTextEdit(); self.last_suffixes_edit.setPlaceholderText("Comma-separated suffixes")
        form.addRow("Last suffixes:", self.last_suffixes_edit)
        self.allowed_chars_edit = QLineEdit(); self.allowed_chars_edit.setPlaceholderText("Regex for allowed characters, e.g., ^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$")
        form.addRow("Allowed chars:", self.allowed_chars_edit)
        layout.addLayout(form)

        btns = QHBoxLayout()
        self.load_btn = QPushButton("Load from Game")
        self.load_btn.clicked.connect(self.load_from_game)
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self.save_changes)
        btns.addWidget(self.load_btn); btns.addWidget(self.save_btn)
        layout.addLayout(btns)

        # Preview controls
        preview_ctrls = QHBoxLayout()
        preview_ctrls.addWidget(QLabel("Preview count:"))
        self.preview_count = QSpinBox()
        self.preview_count.setRange(1, 100)
        self.preview_count.setValue(10)
        preview_ctrls.addWidget(self.preview_count)
        self.preview_btn = QPushButton("Generate Preview")
        self.preview_btn.clicked.connect(self._on_generate_preview)
        preview_ctrls.addWidget(self.preview_btn)
        preview_ctrls.addStretch()
        layout.addLayout(preview_ctrls)

        self.preview_list = QListWidget()
        self.preview_list.setMinimumHeight(140)
        layout.addWidget(self.preview_list)

    def set_manager(self, names_manager) -> None:
        """Attach a NamesManager to this editor."""
        self._manager = names_manager

    def refresh(self):
        """Refresh UI from the manager if available; otherwise load from game file."""
        try:
            if self._manager and getattr(self._manager, 'data', None):
                # Manager stores full JSON structure
                self._data = json.loads(json.dumps(self._manager.data))  # deep copy
                self._refresh_cultures()
            else:
                self.load_from_game(show_message=False)
        except Exception as e:
            QMessageBox.warning(self, "Names", f"Failed to refresh names: {e}")

    def load_from_game(self, show_message: bool = True):
        path = os.path.join(get_config_dir(), "npc", "names.json")
        try:
            if os.path.exists(path):
                with open(path, 'r', encoding='utf-8') as f:
                    self._data = json.load(f)
            else:
                # Prepopulate sensible defaults if missing
                self._data = {
                        "cultures": {
                            "generic": {
                                "patterns": ["FN LN", "FN MI LN", "FN LN-LN2", "FN FN2 LN"],
                                "first_syllables": ["al","an","ar","el","ia","ro","li","ma","tha","dor","gal","vin","mi","ál","éla","íra","óth","úri","åke","æla","öri","ça","ñor"],
                                "last_prefixes": ["", "bel", "wood", "stone", "fair", "silver", "gold"],
                                "last_cores": ["river", "brook", "storm", "light", "helm", "wright", "smith", "walker", "binder", "seeker", "björn", "gård", "ström"],
                                "last_suffixes": ["son", "ton", "ford", "field", "ward", "shire", "mont", "sson", "sen", "dóttir"],
                                "allowed_chars": "^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$"
                            }
                        },
                        "metadata": {
                            "version": "1.0.0",
                            "description": "Culture-aware name generation guidance"
                        }
                    }
            self._refresh_cultures()
            if show_message:
                QMessageBox.information(self, "Loaded", f"Loaded names from {path}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load names.json: {e}")

    def save_changes(self):
        """Save current UI state into manager or directly to game file if no manager."""
        # Update current culture entry from UI first
        self._save_current_culture()
        # Validate current culture spec before saving
        if not self._validate_current_culture():
            return
        try:
            if self._manager is not None:
                # Push into manager and save to its path or keep in-memory; export uses export dialog
                self._manager.data = json.loads(json.dumps(self._data))  # deep copy
                # If manager has a state path (project mode), save to that file
                if getattr(self._manager, 'state', None) and getattr(self._manager.state, 'path', None):
                    self._manager.save_to_file(self._manager.state.path)
            else:
                # Fallback: write directly to game
                path = os.path.join(get_config_dir(), "npc", "names.json")
                os.makedirs(os.path.dirname(path), exist_ok=True)
                with open(path, 'w', encoding='utf-8') as f:
                    json.dump(self._data, f, indent=2, ensure_ascii=False)
            self.names_modified.emit()
            QMessageBox.information(self, "Saved", "Names data saved.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save names: {e}")

    def _refresh_cultures(self):
        self.culture_combo.blockSignals(True)
        self.culture_combo.clear()
        for cid in sorted(self._data.get("cultures", {}).keys()):
            self.culture_combo.addItem(cid, cid)
        self.culture_combo.blockSignals(False)
        if self.culture_combo.count() > 0:
            self.culture_combo.setCurrentIndex(0)
            self._on_culture_changed(0)

    def _on_culture_changed(self, idx: int):
        # Save previous culture edits
        self._save_current_culture()
        cid = self.culture_combo.currentData()
        self._current_culture = cid
        spec = self._data.get("cultures", {}).get(cid, {}) if cid else {}
        self.patterns_edit.setPlainText("\n".join(spec.get("patterns", [])))
        self.first_syllables_edit.setPlainText(",".join(spec.get("first_syllables", [])))
        self.last_prefixes_edit.setPlainText(",".join(spec.get("last_prefixes", [])))
        self.last_cores_edit.setPlainText(",".join(spec.get("last_cores", [])))
        self.last_suffixes_edit.setPlainText(",".join(spec.get("last_suffixes", [])))
        self.allowed_chars_edit.setText(spec.get("allowed_chars", "^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$"))

    def _add_culture(self):
        cid = self.add_culture_edit.text().strip()
        if not cid:
            return
        self._data.setdefault("cultures", {})
        if cid not in self._data["cultures"]:
            self._data["cultures"][cid] = {"patterns": ["FN LN"], "first_syllables": [], "last_prefixes": [], "last_cores": [], "last_suffixes": [], "allowed_chars": "^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$"}
            self._refresh_cultures()
            # Select the new culture
            idx = self.culture_combo.findData(cid)
            if idx >= 0:
                self.culture_combo.setCurrentIndex(idx)

    def _save_current_culture(self):
        cid = self._current_culture
        if not cid:
            return
        # Build lists and deduplicate while preserving order
        def _dedup(seq):
            seen = set()
            out = []
            for s in seq:
                if s not in seen:
                    seen.add(s)
                    out.append(s)
            return out
        patterns = [p.strip() for p in self.patterns_edit.toPlainText().splitlines() if p.strip()]
        first_syllables = [s.strip() for s in self.first_syllables_edit.toPlainText().split(',') if s.strip()]
        last_prefixes = [s.strip() for s in self.last_prefixes_edit.toPlainText().split(',') if s.strip()]
        last_cores = [s.strip() for s in self.last_cores_edit.toPlainText().split(',') if s.strip()]
        last_suffixes = [s.strip() for s in self.last_suffixes_edit.toPlainText().split(',') if s.strip()]
        spec = {
            "patterns": _dedup(patterns),
            "first_syllables": _dedup(first_syllables),
            "last_prefixes": _dedup(last_prefixes),
            "last_cores": _dedup(last_cores),
            "last_suffixes": _dedup(last_suffixes),
            "allowed_chars": self.allowed_chars_edit.text().strip() or "^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$"
        }
        self._data.setdefault("cultures", {})
        self._data["cultures"][cid] = spec

    def _on_generate_preview(self):
        # Ensure current edits are reflected
        self._save_current_culture()
        cid = self._current_culture
        if not cid:
            QMessageBox.information(self, "Preview", "Please select or add a culture first.")
            return
        spec = self._data.get("cultures", {}).get(cid, {})
        count = int(self.preview_count.value())
        names = [self._generate_name(spec) for _ in range(count)]
        self.preview_list.clear()
        for n in names:
            self.preview_list.addItem(n)

    def _generate_name(self, spec: dict) -> str:
        pattern = random.choice(spec.get("patterns", ["FN LN"])) if spec.get("patterns") else "FN LN"
        # Generate base components
        fn = self._generate_first(spec)
        fn2 = self._generate_first(spec)
        # Try to avoid FN=FN2
        if fn2 == fn:
            for _ in range(2):
                alt = self._generate_first(spec)
                if alt != fn:
                    fn2 = alt
                    break
        ln = self._generate_last(spec)
        ln2 = self._generate_last(spec)
        if ln2 == ln:
            for _ in range(2):
                alt = self._generate_last(spec)
                if alt != ln:
                    ln2 = alt
                    break
        mi = (fn2[0:1].upper() + ".") if fn2 else "X."

        # Token substitution using regex with word boundaries
        token_map = {"FN2": fn2, "FN": fn, "LN2": ln2, "LN": ln, "MI": mi}
        def _repl(m: re.Match) -> str:
            return token_map.get(m.group(0), m.group(0))
        name = re.sub(r"\b(FN2|FN|LN2|LN|MI)\b", _repl, pattern).strip()
        # Normalize spaces
        name = " ".join(part for part in name.split(" ") if part)
        # Validate against allowed_chars if provided
        allowed = spec.get("allowed_chars", "^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$")
        # Anchorize if needed
        if not allowed.startswith("^"):
            allowed = "^" + allowed
        if not allowed.endswith("$"):
            allowed = allowed + "$"
        try:
            if not re.fullmatch(allowed, name):
                # Conservative fallback: strip characters not in our extended Latin + space, hyphen, apostrophe
                name = re.sub(r"[^A-Za-zÀ-ÖØ-öø-ÿ' -]", "", name)
        except re.error:
            # Invalid regex; ignore and return as-is
            pass
        return name

    def _generate_first(self, spec: dict) -> str:
        syllables = spec.get("first_syllables") or ["al","an","ar","el","ia","ro","li","ma","tha"]
        # Prefer 2 syllables, sometimes 3
        k = 2 if random.random() < 0.75 else 3
        parts = [random.choice(syllables) for _ in range(k)]
        s = "".join(parts)
        return s.capitalize()

    def _generate_last(self, spec: dict) -> str:
        prefixes = spec.get("last_prefixes") or ["stone", "silver", "gold", "fair", "wood"]
        cores = spec.get("last_cores") or ["smith", "walker", "binder", "seeker", "wright"]
        suffixes = spec.get("last_suffixes") or ["", "son", "ton", "ford", "field"]
        p = random.choice(prefixes) if prefixes else ""
        c = random.choice(cores) if cores else ""
        s = random.choice(suffixes) if suffixes else ""
        ln = f"{p}{c}{s}" if (p or c or s) else "Name"
        # If last name ended up empty, fallback
        if not ln:
            ln = "River"
        return ln[:1].upper() + ln[1:]

    def _validate_current_culture(self) -> bool:
        """Validate the current culture spec: patterns tokens and allowed_chars regex."""
        cid = self._current_culture
        if not cid:
            return True
        spec = self._data.get("cultures", {}).get(cid, {})
        # Validate allowed_chars regex
        try:
            _ = re.compile(spec.get("allowed_chars", "^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$"))
        except re.error as e:
            QMessageBox.critical(self, "Invalid Regex", f"Allowed chars regex is invalid for culture '{cid}':\n{e}")
            return False
        # Validate tokens in patterns
        valid_tokens = {"FN", "FN2", "MI", "LN", "LN2"}
        bad_patterns = []
        for p in spec.get("patterns", []):
            tokens = set(re.findall(r"\b([A-Z]{2}\d?)\b", p))
            unknown = [t for t in tokens if t not in valid_tokens]
            if unknown:
                bad_patterns.append(f"{p} (unknown: {', '.join(unknown)})")
        if bad_patterns:
            QMessageBox.critical(self, "Invalid Patterns", "Some patterns contain unknown tokens:\n\n" + "\n".join(bad_patterns))
            return False
        return True


```

### File: world_configurator\ui\editors\origin_editor.py

```python
# world_configurator/ui/editors/origin_editor.py
"""
Origin editor component for the World Configurator Tool.
(Formerly Scenario Editor)
"""

import logging
import copy
from typing import Dict, List, Optional, Callable, Any

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QComboBox,
    QInputDialog, QTableWidget, QTableWidgetItem, QHeaderView
)

from ui.dialogs.base_dialog import BaseDialog
from models.base_models import Origin, OriginTrait
from models.origin_data import OriginManager # Renamed import
from models.location_data import LocationManager
from models.origin_data import QuestManager

logger = logging.getLogger("world_configurator.ui.origin_editor") # Updated logger name


class OriginTraitDialog(BaseDialog):
    """Dialog for editing an OriginTrait."""
    def __init__(self, parent=None, trait: Optional[OriginTrait] = None):
        super().__init__(parent)
        self.setWindowTitle("Edit Origin Trait")
        self.setMinimumWidth(400)

        self.trait = copy.deepcopy(trait) if trait else OriginTrait(name="New Trait", description="")

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.name_edit = QLineEdit(self.trait.name)
        form.addRow("Trait Name:", self.name_edit)

        self.desc_edit = QTextEdit(self.trait.description)
        self.desc_edit.setMinimumHeight(80)
        form.addRow("Description:", self.desc_edit)

        layout.addLayout(form)

        btn_layout = QHBoxLayout()
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        save_btn.setDefault(True)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)

    def get_trait(self) -> OriginTrait:
        self.trait.name = self.name_edit.text().strip()
        self.trait.description = self.desc_edit.toPlainText().strip()
        return self.trait

class OriginEditor(QWidget): # Renamed class
    """Origin editor component."""

    # Signals
    origin_modified = Signal() # Renamed signal

    def __init__(self, parent=None):
        """
        Initialize the origin editor.

        Args:
            parent: The parent widget.
        """
        super().__init__(parent)

        # Internal state
        self.origin_manager = OriginManager() # Renamed manager
        self.location_manager = LocationManager()
        self.quest_manager: Optional[QuestManager] = None
        self.current_origin: Optional[Origin] = None # Renamed variable

        # Setup UI
        self._setup_ui()

    def _setup_ui(self):
        """Setup the editor UI."""
        main_layout = QHBoxLayout(self)

        # Create a splitter for resizable panels
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)

        # Left panel (origin list)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)

        list_label = QLabel("Starting Origins")
        list_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        left_layout.addWidget(list_label)

        self.origin_list = QListWidget()
        self.origin_list.setMinimumWidth(200)
        self.origin_list.currentItemChanged.connect(self._on_origin_selected)
        left_layout.addWidget(self.origin_list)

        list_buttons = QHBoxLayout()

        self.add_origin_btn = QPushButton("Add")
        self.add_origin_btn.clicked.connect(self._add_origin)
        list_buttons.addWidget(self.add_origin_btn)

        self.remove_origin_btn = QPushButton("Remove")
        self.remove_origin_btn.clicked.connect(self._remove_origin)
        self.remove_origin_btn.setEnabled(False)
        list_buttons.addWidget(self.remove_origin_btn)

        left_layout.addLayout(list_buttons)
        splitter.addWidget(left_panel)

        # Right panel (origin details)
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)

        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)
        self.details_layout = QVBoxLayout(self.details_widget)

        self.form_layout = QFormLayout()
        self.name_label = QLabel("")
        self.form_layout.addRow("Name:", self.name_label)
        self.desc_label = QLabel("")
        self.desc_label.setWordWrap(True); self.desc_label.setMinimumHeight(60)
        self.form_layout.addRow("Description:", self.desc_label)
        self.location_label = QLabel("")
        self.form_layout.addRow("Starting Location:", self.location_label)
        self.culture_label = QLabel("")
        self.form_layout.addRow("Starting Culture (Optional):", self.culture_label)
        self.intro_label = QLabel("")
        self.intro_label.setWordWrap(True); self.intro_label.setMinimumHeight(100)
        self.form_layout.addRow("Introduction Text:", self.intro_label)

        self.name_label.mouseDoubleClickEvent = self._edit_name
        self.desc_label.mouseDoubleClickEvent = self._edit_description
        self.location_label.mouseDoubleClickEvent = self._edit_location
        self.culture_label.mouseDoubleClickEvent = self._edit_culture
        self.intro_label.mouseDoubleClickEvent = self._edit_introduction
        self.details_layout.addLayout(self.form_layout)

        skills_label = QLabel("Skill Proficiencies")
        skills_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(skills_label)
        self.skills_list = QListWidget()
        self.skills_list.setMinimumHeight(60)
        self.skills_list.itemDoubleClicked.connect(self._edit_skill_proficiency) # Changed from _edit_skill
        self.details_layout.addWidget(self.skills_list)
        skills_buttons = QHBoxLayout()
        self.add_skill_btn = QPushButton("Manage Skills") # Changed button text
        self.add_skill_btn.clicked.connect(self._manage_skill_proficiencies) # Changed slot
        skills_buttons.addWidget(self.add_skill_btn)
        # Remove skill button is no longer needed here as management is via dialog
        # self.remove_skill_btn = QPushButton("Remove Skill")
        # self.remove_skill_btn.clicked.connect(self._remove_skill_proficiency)
        # skills_buttons.addWidget(self.remove_skill_btn)
        self.details_layout.addLayout(skills_buttons)

        traits_label = QLabel("Origin Traits")
        traits_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(traits_label)
        self.traits_table = QTableWidget()
        self.traits_table.setColumnCount(2)
        self.traits_table.setHorizontalHeaderLabels(["Trait Name", "Description"])
        self.traits_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.traits_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.traits_table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.traits_table.itemDoubleClicked.connect(self._edit_trait_row)
        self.traits_table.setMinimumHeight(100)
        self.details_layout.addWidget(self.traits_table)
        traits_buttons = QHBoxLayout()
        self.add_trait_btn = QPushButton("Add Trait")
        self.add_trait_btn.clicked.connect(self._add_trait)
        traits_buttons.addWidget(self.add_trait_btn)
        self.edit_trait_btn = QPushButton("Edit Trait")
        self.edit_trait_btn.clicked.connect(self._edit_selected_trait)
        traits_buttons.addWidget(self.edit_trait_btn)
        self.remove_trait_btn = QPushButton("Remove Trait")
        self.remove_trait_btn.clicked.connect(self._remove_trait)
        traits_buttons.addWidget(self.remove_trait_btn)
        self.details_layout.addLayout(traits_buttons)

        items_label = QLabel("Starting Items")
        items_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(items_label)
        self.items_list = QListWidget()
        self.items_list.setMinimumHeight(60)
        self.items_list.itemDoubleClicked.connect(self._edit_starting_item)
        self.details_layout.addWidget(self.items_list)
        items_buttons = QHBoxLayout()
        self.add_item_btn = QPushButton("Manage Items") # Changed button text
        self.add_item_btn.clicked.connect(self._manage_starting_items) # Changed slot
        items_buttons.addWidget(self.add_item_btn)
        self.details_layout.addLayout(items_buttons)

        quests_label = QLabel("Initial Quests")
        quests_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(quests_label)
        self.quests_list = QListWidget()
        self.quests_list.setMinimumHeight(60)
        self.quests_list.itemDoubleClicked.connect(self._edit_quest)
        self.details_layout.addWidget(self.quests_list)
        quests_buttons = QHBoxLayout()
        self.manage_quests_btn = QPushButton("Manage Quests")
        self.manage_quests_btn.clicked.connect(self._manage_initial_quests)
        quests_buttons.addWidget(self.manage_quests_btn)
        self.remove_quest_btn = QPushButton("Remove Selected")
        self.remove_quest_btn.clicked.connect(self._remove_quest)
        quests_buttons.addWidget(self.remove_quest_btn)
        self.details_layout.addLayout(quests_buttons)

        races_label = QLabel("Suitable Races")
        races_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(races_label)
        self.races_list = QListWidget()
        self.races_list.setMinimumHeight(60)
        self.races_list.itemDoubleClicked.connect(self._edit_race)
        self.details_layout.addWidget(self.races_list)
        races_buttons = QHBoxLayout()
        self.add_race_btn = QPushButton("Add Race")
        self.add_race_btn.clicked.connect(self._add_race)
        races_buttons.addWidget(self.add_race_btn)
        self.remove_race_btn = QPushButton("Remove Race")
        self.remove_race_btn.clicked.connect(self._remove_race)
        races_buttons.addWidget(self.remove_race_btn)
        self.details_layout.addLayout(races_buttons)

        classes_label = QLabel("Suitable Classes")
        classes_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(classes_label)
        self.classes_list = QListWidget()
        self.classes_list.setMinimumHeight(60)
        self.classes_list.itemDoubleClicked.connect(self._edit_class)
        self.details_layout.addWidget(self.classes_list)
        classes_buttons = QHBoxLayout()
        self.add_class_btn = QPushButton("Add Class")
        self.add_class_btn.clicked.connect(self._add_class)
        classes_buttons.addWidget(self.add_class_btn)
        self.remove_class_btn = QPushButton("Remove Class")
        self.remove_class_btn.clicked.connect(self._remove_class)
        classes_buttons.addWidget(self.remove_class_btn)
        self.details_layout.addLayout(classes_buttons)

        save_layout = QHBoxLayout()
        save_layout.addStretch()
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self._save_current_origin)
        self.save_btn.setEnabled(False)
        save_layout.addWidget(self.save_btn)
        self.details_layout.addLayout(save_layout)

        splitter.addWidget(right_panel)
        self._disable_details()
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)

        # Assistant integration methods added at end of class

        # Add imports for new dialogs
        from ..dialogs.skill_selection_dialog import SkillSelectionDialog
        from ..dialogs.item_selection_dialog import ItemSelectionDialog
        self.SkillSelectionDialog = SkillSelectionDialog
        self.ItemSelectionDialog = ItemSelectionDialog

    # Renamed method to accept OriginManager
    def set_managers(self, origin_manager: OriginManager, location_manager: LocationManager, quest_manager: Optional[QuestManager] = None) -> None:
        """
        Set the origin, location and quest managers to use.

        Args:
            origin_manager: The origin manager.
            location_manager: The location manager.
            quest_manager: Optional quest manager to provide quest references.
        """
        self.origin_manager = origin_manager
        self.location_manager = location_manager
        self.quest_manager = quest_manager

        # Refresh origin list
        self._refresh_origin_list() # Renamed method

    def _refresh_origin_list(self) -> None: # Renamed method
        """Refresh the origin list from the manager."""
        # Clear list
        self.origin_list.clear()

        # Add all origins
        for origin_id, origin in self.origin_manager.origins.items(): # Use origin_manager.origins
            item = QListWidgetItem(origin.name)
            item.setData(Qt.UserRole, origin_id)
            self.origin_list.addItem(item)

        # Sort alphabetically
        self.origin_list.sortItems()

        # Select the first item if available
        if self.origin_list.count() > 0:
            self.origin_list.setCurrentRow(0)
        else: # Ensure details are disabled if list is empty
             self._disable_details()
             self.remove_origin_btn.setEnabled(False)

    # Renamed method
    def _on_origin_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]) -> None:
        """
        Handle origin selection change.

        Args:
            current: The current selected item, or None.
            previous: The previously selected item, or None.
        """
        if current:
            origin_id = current.data(Qt.UserRole)
            origin = self.origin_manager.get_origin(origin_id) # Use origin_manager

            if origin:
                self._load_origin(origin) # Renamed method
                self.remove_origin_btn.setEnabled(True)
                return

        # No valid selection
        self._disable_details()
        self.remove_origin_btn.setEnabled(False)

    def _load_origin(self, origin: Origin) -> None:
        """
        Load an origin into the editor.

        Args:
            origin: The origin to load.
        """
        try:
            self.current_origin = origin

            self.name_label.setText(origin.name)
            self.desc_label.setText(origin.description)

            if origin.starting_location_id and self.location_manager and self.location_manager.locations:
                location = self.location_manager.locations.get(origin.starting_location_id)
                self.location_label.setText(f"{location.name} ({location.type})" if location else f"(Unknown: {origin.starting_location_id})")
            else:
                self.location_label.setText("(None)")

            if hasattr(self, 'culture_label'):
                self.culture_label.setText(origin.starting_culture_id if origin.starting_culture_id else "(None - uses location default)")

            self.intro_label.setText(origin.introduction_text)

            self.skills_list.clear()
            if hasattr(origin, 'skill_proficiencies'):
                for skill_name in origin.skill_proficiencies: # skill_proficiencies stores names
                    # Use helper to potentially get a more descriptive display if needed in future
                    display_text = self._get_skill_display_name(skill_name)
                    item = QListWidgetItem(display_text)
                    item.setData(Qt.UserRole, skill_name) # Store the name as data for removal
                    self.skills_list.addItem(item)

            self.traits_table.setRowCount(0)
            if hasattr(origin, 'origin_traits'):
                self.traits_table.setRowCount(len(origin.origin_traits))
                for row, trait in enumerate(origin.origin_traits):
                    name_item = QTableWidgetItem(trait.name)
                    desc_item = QTableWidgetItem(trait.description)
                    self.traits_table.setItem(row, 0, name_item)
                    self.traits_table.setItem(row, 1, desc_item)
                    name_item.setData(Qt.UserRole, row)

            self.items_list.clear()
            if hasattr(origin, 'starting_items'): # Check if attribute exists
                for item_id in origin.starting_items:
                    # Use helper to potentially get item name if available in future
                    display_text = self._get_item_display_name(item_id)
                    item = QListWidgetItem(display_text)
                    item.setData(Qt.UserRole, item_id) # Store the ID for removal
                    self.items_list.addItem(item)

            self.quests_list.clear()
            for quest_id in origin.initial_quests:
                display_text = self._get_quest_display_name(quest_id)
                item = QListWidgetItem(display_text)
                item.setData(Qt.UserRole, quest_id)
                self.quests_list.addItem(item)

            self.races_list.clear()
            for race_name in origin.suitable_races:
                item = QListWidgetItem(race_name)
                self.races_list.addItem(item)

            self.classes_list.clear()
            for class_name in origin.suitable_classes:
                item = QListWidgetItem(class_name)
                self.classes_list.addItem(item)

            self._enable_details()
            self.save_btn.setEnabled(False)

        except Exception as e:
            logger.error(f"Error loading origin {origin.name}: {str(e)}", exc_info=True)
            QMessageBox.warning(
                self,
                "Error Loading Origin",
                f"There was an error loading the origin '{origin.name}':\n\n{str(e)}\n\nSome data may not be displayed correctly."
            )
            self._enable_details()
            self.save_btn.setEnabled(True)

    def _disable_details(self) -> None:
        """Disable all detail controls."""
        self.current_origin = None

        self.name_label.clear()
        self.desc_label.clear()
        self.location_label.clear()
        if hasattr(self, 'culture_label'): self.culture_label.clear()
        self.intro_label.clear()

        self.skills_list.clear()
        self.traits_table.setRowCount(0)
        self.items_list.clear()
        self.quests_list.clear()
        self.races_list.clear()
        self.classes_list.clear()

        self.skills_list.setEnabled(False)
        self.traits_table.setEnabled(False)
        self.items_list.setEnabled(False)
        self.quests_list.setEnabled(False)
        self.races_list.setEnabled(False)
        self.classes_list.setEnabled(False)

        self.add_skill_btn.setEnabled(False)
        # self.remove_skill_btn.setEnabled(False) # Removed this line
        self.add_trait_btn.setEnabled(False)
        self.edit_trait_btn.setEnabled(False)
        self.remove_trait_btn.setEnabled(False)
        self.add_item_btn.setEnabled(False)
        # self.remove_item_btn.setEnabled(False) # Removed this line
        self.manage_quests_btn.setEnabled(False)
        self.remove_quest_btn.setEnabled(False)
        self.add_race_btn.setEnabled(False)
        self.remove_race_btn.setEnabled(False)
        self.add_class_btn.setEnabled(False)
        self.remove_class_btn.setEnabled(False)

        self.save_btn.setEnabled(False)

    def _enable_details(self) -> None:
        """Enable all detail controls."""
        self.skills_list.setEnabled(True)
        self.traits_table.setEnabled(True)
        self.items_list.setEnabled(True)
        self.quests_list.setEnabled(True)
        self.races_list.setEnabled(True)
        self.classes_list.setEnabled(True)

        self.add_skill_btn.setEnabled(True)
        # self.remove_skill_btn.setEnabled(True) # Removed this line
        self.add_trait_btn.setEnabled(True)
        self.edit_trait_btn.setEnabled(True)
        self.remove_trait_btn.setEnabled(True)
        self.add_item_btn.setEnabled(True)
        # self.remove_item_btn.setEnabled(True) # Removed this line
        self.manage_quests_btn.setEnabled(True)
        self.remove_quest_btn.setEnabled(True)
        self.add_race_btn.setEnabled(True)
        self.remove_race_btn.setEnabled(True)
        self.add_class_btn.setEnabled(True)
        self.remove_class_btn.setEnabled(True)
        # Save button enabled separately when changes occur

    def _save_current_origin(self) -> None:
        """Save the current origin to the manager."""
        if not self.current_origin:
            return

        # Basic fields (name, desc, location_id, culture_id, intro_text) are updated via their respective edit dialogs/methods
        # which directly modify self.current_origin and set self.save_btn.setEnabled(True).

        # Update skill proficiencies (skill names are stored)
        new_skill_proficiencies = []
        for i in range(self.skills_list.count()):
            item = self.skills_list.item(i)
            # The text of the item IS the skill name
            new_skill_proficiencies.append(item.text())
        self.current_origin.skill_proficiencies = sorted(list(set(new_skill_proficiencies))) # Ensure unique and sorted

        # Update origin traits
        new_origin_traits = []
        for row in range(self.traits_table.rowCount()):
            name_item = self.traits_table.item(row, 0)
            desc_item = self.traits_table.item(row, 1)
            if name_item and desc_item and name_item.text().strip(): # Ensure name is not empty
                new_origin_traits.append(
                    OriginTrait(name=name_item.text().strip(), description=desc_item.text().strip())
                )
        self.current_origin.origin_traits = new_origin_traits


        # Update starting items (item IDs are stored)
        new_starting_items = []
        for i in range(self.items_list.count()):
            item = self.items_list.item(i)
            # The data role Qt.UserRole stores the item_id
            item_id = item.data(Qt.UserRole)
            if item_id: # Make sure we have an ID
                new_starting_items.append(item_id)
        self.current_origin.starting_items = sorted(list(set(new_starting_items))) # Ensure unique and sorted

        # Update initial quests
        new_initial_quests = []
        for i in range(self.quests_list.count()):
            item = self.quests_list.item(i)
            qid = item.data(Qt.UserRole) or item.text()
            if isinstance(qid, str) and qid.strip():
                new_initial_quests.append(qid.strip())
        self.current_origin.initial_quests = sorted(list(set(new_initial_quests)))

        # Update suitable races
        new_suitable_races = []
        for i in range(self.races_list.count()):
            item = self.races_list.item(i)
            new_suitable_races.append(item.text())
        self.current_origin.suitable_races = sorted(list(set(new_suitable_races)))

        # Update suitable classes
        new_suitable_classes = []
        for i in range(self.classes_list.count()):
            item = self.classes_list.item(i)
            new_suitable_classes.append(item.text())
        self.current_origin.suitable_classes = sorted(list(set(new_suitable_classes)))

        self.origin_manager.add_origin(self.current_origin)
        self.save_btn.setEnabled(False)
        self._refresh_origin_list()

        for i in range(self.origin_list.count()):
            item = self.origin_list.item(i)
            if item.data(Qt.UserRole) == self.current_origin.id:
                self.origin_list.setCurrentItem(item)
                break
        self.origin_modified.emit()
        logger.info(f"Saved origin: {self.current_origin.name} ({self.current_origin.id})")

    # ===== Assistant integration =====
    def get_assistant_context(self):
        from assistant.context import AssistantContext
        allowed = [
            "/skill_proficiencies",
            "/origin_traits",
            "/starting_items",
            "/initial_quests",
            "/suitable_races",
            "/suitable_classes",
            "/introduction_text",
            "/starting_location_id",
            "/starting_culture_id",
            "/description",
            "/name",
        ]
        content = self.current_origin.to_dict() if self.current_origin else None
        return AssistantContext(
            domain="origins",
            selection_id=self.current_origin.id if self.current_origin else None,
            content=content,
            schema=None,
            allowed_paths=allowed,
        )

    def get_domain_examples(self):
        if self.origin_manager.origins:
            first = next(iter(self.origin_manager.origins.values()))
            return [first.to_dict()]
        return []

    def get_reference_catalogs(self):
        # Provide references to reduce hallucinations and enforce valid IDs
        quests = []
        quest_titles = {}
        try:
            if self.quest_manager and getattr(self.quest_manager, 'quests', None):
                quests = list(self.quest_manager.quests.keys())
                # Build id->title mapping for better LLM grounding
                for qid, q in self.quest_manager.quests.items():
                    quest_titles[qid] = getattr(q, 'title', '')
        except Exception:
            quests = []
            quest_titles = {}
        locations = []
        try:
            if self.location_manager and getattr(self.location_manager, 'locations', None):
                locations = list(self.location_manager.locations.keys())
        except Exception:
            locations = []
        existing_names = []
        try:
            if self.origin_manager and getattr(self.origin_manager, 'origins', None):
                existing_names = sorted({o.name for o in self.origin_manager.origins.values() if o and o.name})
        except Exception:
            existing_names = []
        return {
            "quest_ids": quests,
            "quest_titles": quest_titles,
            "location_ids": locations,
            "existing_names": existing_names,
            # Guidance to LLMs consuming this: initial_quests MUST be array of quest IDs (strings)
            "constraints": {"initial_quests_format": "array_of_ids"},
        }

    def apply_assistant_patch(self, patch_ops):
        from assistant.patching import apply_patch_with_validation
        ctx = self.get_assistant_context()
        if not ctx.content:
            return False, "No origin selected."
        ok, msg, new_content = apply_patch_with_validation(ctx, ctx.content, patch_ops)
        if not ok:
            return False, msg
        try:
            new_content = self._sanitize_origin_payload(new_content)
            updated = Origin.from_dict(new_content)
            updated.id = self.current_origin.id
            self.origin_manager.add_origin(updated)
            self._load_origin(updated)
            self.origin_modified.emit()
            return True, "OK"
        except Exception as e:
            return False, f"Failed to apply: {e}"

    def create_entry_from_llm(self, entry: dict):
        try:
            proposed_name = (entry.get("name") or "New Origin").strip()
            existing_names = {o.name for o in self.origin_manager.origins.values()}
            name = proposed_name
            suffix = 1
            while name in existing_names:
                name = f"{proposed_name} ({suffix})"
                suffix += 1
            desc = entry.get("description", "")
            location_id = entry.get("starting_location_id", "")
            new_origin = Origin.create_new(name, desc, location_id)
            tmp = new_origin.to_dict()
            tmp.update({k: v for k, v in entry.items() if k != "id" and k != "name"})
            tmp["name"] = name
            tmp = self._sanitize_origin_payload(tmp)
            new_obj = Origin.from_dict(tmp)
            new_obj.id = new_origin.id
            self.origin_manager.add_origin(new_obj)
            self._refresh_origin_list()
            # select
            for i in range(self.origin_list.count()):
                it = self.origin_list.item(i)
                if self.origin_manager.get_origin(it.data(Qt.UserRole)).id == new_obj.id:
                    self.origin_list.setCurrentItem(it)
                    break
            self.origin_modified.emit()
            return True, "Created", new_obj.id
        except Exception as e:
            return False, f"Failed to create: {e}", None

    def _manage_skill_proficiencies(self):
        if not self.current_origin:
            return

        current_skill_names = [self.skills_list.item(i).text() for i in range(self.skills_list.count())]

        dialog = self.SkillSelectionDialog(self, existing_skills=current_skill_names)
        if dialog.exec() == QDialog.Accepted:
            selected_skills = dialog.get_selected_skills() # Returns list of skill names

            # Update the QListWidget
            self.skills_list.clear()
            for skill_name in sorted(selected_skills):
                item = QListWidgetItem(skill_name)
                item.setData(Qt.UserRole, skill_name) # Store name as data for consistency
                self.skills_list.addItem(item)

            self.save_btn.setEnabled(True)
            logger.debug(f"Updated skill proficiencies for origin {self.current_origin.id} to: {selected_skills}")

    def _manage_starting_items(self):
        if not self.current_origin:
            return

        current_item_ids = [self.items_list.item(i).data(Qt.UserRole) for i in range(self.items_list.count())]

        # Path to origin_items.json relative to project root
        origin_items_path = "config/items/origin_items.json"
        dialog = self.ItemSelectionDialog(self, existing_item_ids=current_item_ids, item_file_path=origin_items_path)

        if dialog.exec() == QDialog.Accepted:
            selected_item_ids = dialog.get_selected_item_ids() # Returns list of item IDs

            # Update the QListWidget
            self.items_list.clear()
            for item_id in sorted(selected_item_ids):
                display_text = self._get_item_display_name(item_id) # Use helper for display
                list_item = QListWidgetItem(display_text)
                list_item.setData(Qt.UserRole, item_id) # Store actual ID
                self.items_list.addItem(list_item)

            self.save_btn.setEnabled(True)
            # Persist immediately to the model for convenience (parity with Manage Quests)
            self._save_current_origin()
            logger.debug(f"Updated starting items for origin {self.current_origin.id} to: {selected_item_ids} and auto-saved.")

    def _edit_starting_item(self, item: QListWidgetItem):
        """Handles double-click on a starting item: opens manage dialog."""
        if not self.current_origin or not item:
            return
        # Re-purpose the "Manage Items" dialog for editing
        self._manage_starting_items()

    def _edit_skill_proficiency(self, item: QListWidgetItem):
        """Handles double-click on a skill proficiency: opens manage dialog."""
        if not self.current_origin or not item:
            return
        # Re-purpose the "Manage Skills" dialog for editing (which essentially is managing the list)
        self._manage_skill_proficiencies()

    def _add_origin(self) -> None: # Renamed method
        """Add a new origin."""
        # Create new origin (use a default location if available)
        default_location_id = ""
        if self.location_manager and self.location_manager.locations:
            default_location_id = next(iter(self.location_manager.locations.keys()), "")

        # Assume Origin.create_new takes name, description, location_id
        # Need to update Origin model later
        origin = Origin.create_new("New Origin", "Description of the origin", default_location_id)

        # Add to manager
        self.origin_manager.add_origin(origin) # Use origin_manager

        # Refresh list
        self._refresh_origin_list() # Renamed method

        # Find and select the new origin
        for i in range(self.origin_list.count()):
            item = self.origin_list.item(i)
            if item.data(Qt.UserRole) == origin.id:
                self.origin_list.setCurrentItem(item)
                break

        # Trigger name edit dialog for immediate editing
        self._edit_name(None)

        # Emit modified signal
        self.origin_modified.emit() # Renamed signal

        # Log
        logger.info(f"Added new origin: {origin.id}")

    def _remove_origin(self) -> None: # Renamed method
        """Remove the selected origin."""
        current_item = self.origin_list.currentItem()
        if not current_item:
            return

        origin_id = current_item.data(Qt.UserRole)
        origin = self.origin_manager.get_origin(origin_id) # Use origin_manager

        if not origin:
            return

        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the origin '{origin.name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if result != QMessageBox.Yes:
            return

        # Remove from manager
        self.origin_manager.remove_origin(origin_id) # Use origin_manager

        # Refresh list
        self._refresh_origin_list() # Renamed method

        # Emit modified signal
        self.origin_modified.emit() # Renamed signal

        # Log
        logger.info(f"Removed origin: {origin_id}")

    def _add_trait(self):
        if not self.current_origin: return
        dialog = OriginTraitDialog(self)
        if dialog.exec() == QDialog.Accepted:
            new_trait = dialog.get_trait()
            row = self.traits_table.rowCount()
            self.traits_table.insertRow(row)
            name_item = QTableWidgetItem(new_trait.name)
            desc_item = QTableWidgetItem(new_trait.description)
            self.traits_table.setItem(row, 0, name_item)
            self.traits_table.setItem(row, 1, desc_item)
            name_item.setData(Qt.UserRole, row) # Store index for editing
            self.save_btn.setEnabled(True)
            logger.debug(f"Added origin trait: {new_trait.name}")

    def _edit_selected_trait(self):
         current_row = self.traits_table.currentRow()
         if current_row >= 0:
             self._edit_trait_row(self.traits_table.item(current_row, 0)) # Pass the name item

    def _edit_trait_row(self, item):
        if not self.current_origin or not item: return
        row = item.row()
        name_item = self.traits_table.item(row, 0)
        desc_item = self.traits_table.item(row, 1)

        if not name_item or not desc_item: return # Should not happen

        # Create a temporary trait object to pass to dialog
        current_trait = OriginTrait(name=name_item.text(), description=desc_item.text())

        dialog = OriginTraitDialog(self, current_trait)
        if dialog.exec() == QDialog.Accepted:
            edited_trait = dialog.get_trait()
            name_item.setText(edited_trait.name)
            desc_item.setText(edited_trait.description)
            self.save_btn.setEnabled(True)
            logger.debug(f"Edited origin trait at row {row} to: {edited_trait.name}")


    def _remove_trait(self):
        current_row = self.traits_table.currentRow()
        if current_row >= 0:
            removed_name = self.traits_table.item(current_row, 0).text() if self.traits_table.item(current_row, 0) else "Unknown"
            self.traits_table.removeRow(current_row)
            self.save_btn.setEnabled(True)
            logger.debug(f"Removed origin trait: {removed_name}")

    def _add_quest(self) -> None:
        # Deprecated in favor of _manage_initial_quests
        self._manage_initial_quests()

    def _remove_quest(self) -> None:
        """Remove the selected initial quest."""
        item = self.quests_list.currentItem()
        if not item:
            return

        # Remove item
        self.quests_list.takeItem(self.quests_list.row(item))

        # Mark as modified
        self.save_btn.setEnabled(True)

        # Log
        logger.debug(f"Removed initial quest: {item.text()}")

    def _manage_initial_quests(self) -> None:
        """Open selection dialog to manage initial quests from QuestManager."""
        if not self.current_origin:
            return
        # Collect available quests
        available: list[tuple[str, str]] = []
        if self.quest_manager and getattr(self.quest_manager, 'quests', None):
            for qid, q in self.quest_manager.quests.items():
                title = getattr(q, 'title', '')
                available.append((qid, title))
        # Existing selections: use quest IDs from item data if available
        existing = []
        for i in range(self.quests_list.count()):
            it = self.quests_list.item(i)
            qid = it.data(Qt.UserRole)
            if isinstance(qid, str) and qid:
                existing.append(qid)

        # Lazy import dialog
        try:
            from ..dialogs.quest_selection_dialog import QuestSelectionDialog
        except Exception:
            from ui.dialogs.quest_selection_dialog import QuestSelectionDialog  # fallback absolute

        dlg = QuestSelectionDialog(self, available_quests=available, existing_ids=existing)
        if dlg.exec() == QDialog.Accepted:
            selected_ids = dlg.get_selected_ids()
            # Update list with display names and store IDs
            self.quests_list.clear()
            for qid in sorted(set(selected_ids)):
                text = self._get_quest_display_name(qid)
                it = QListWidgetItem(text)
                it.setData(Qt.UserRole, qid)
                self.quests_list.addItem(it)
            self.save_btn.setEnabled(True)
            # Persist immediately to the model for convenience
            self._save_current_origin()
            logger.debug("Updated initial quests for origin %s to: %s and auto-saved.", self.current_origin.id, selected_ids)

    def _add_race(self) -> None:
        """Add a suitable race."""
        if not self.current_origin:
            return

        # Create simple input dialog
        race_name, ok = QInputDialog.getText(
            self,
            "Add Suitable Race",
            "Enter race name:"
        )

        if ok and race_name.strip():
            # Add to list
            self.races_list.addItem(race_name.strip())

            # Mark as modified
            self.save_btn.setEnabled(True)

            # Log
            logger.debug(f"Added suitable race: {race_name}")

    def _remove_race(self) -> None:
        """Remove the selected suitable race."""
        item = self.races_list.currentItem()
        if not item:
            return

        # Remove item
        self.races_list.takeItem(self.races_list.row(item))

        # Mark as modified
        self.save_btn.setEnabled(True)

        # Log
        logger.debug(f"Removed suitable race: {item.text()}")

    def _add_class(self) -> None:
        """Add a suitable class."""
        if not self.current_origin:
            return

        # Create simple input dialog
        class_name, ok = QInputDialog.getText(
            self,
            "Add Suitable Class",
            "Enter class name:"
        )

        if ok and class_name.strip():
            # Add to list
            self.classes_list.addItem(class_name.strip())

            # Mark as modified
            self.save_btn.setEnabled(True)

            # Log
            logger.debug(f"Added suitable class: {class_name}")

    def _remove_class(self) -> None:
        """Remove the selected suitable class."""
        item = self.classes_list.currentItem()
        if not item:
            return

        # Remove item
        self.classes_list.takeItem(self.classes_list.row(item))

        # Mark as modified
        self.save_btn.setEnabled(True)

        # Log
        logger.debug(f"Removed suitable class: {item.text()}")

    # --- Editing Methods (Double-Click Handlers) ---

    def _edit_name(self, event):
        """Edit origin name on double-click."""
        if not self.current_origin:
            return

        name, ok = QInputDialog.getText(
            self,
            "Edit Origin Name",
            "Enter origin name:",
            QLineEdit.Normal,
            self.current_origin.name
        )

        if ok and name.strip():
            self.current_origin.name = name.strip()
            self.name_label.setText(name.strip())
            self.save_btn.setEnabled(True)
            # Also update the list widget item text
            current_item = self.origin_list.currentItem()
            if current_item:
                current_item.setText(name.strip())
                self.origin_list.sortItems() # Re-sort after name change
            logger.debug(f"Updated origin name to: {name}")

    def _edit_description(self, event):
        """Edit origin description on double-click."""
        if not self.current_origin:
            return

        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Origin Description")
        dialog.setMinimumWidth(400)
        dialog.setMinimumHeight(200) # Adjusted height

        layout = QVBoxLayout(dialog)

        text_edit = QTextEdit()
        text_edit.setPlainText(self.current_origin.description)
        layout.addWidget(text_edit)

        btn_layout = QHBoxLayout()
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(dialog.accept)
        save_btn.setDefault(True)

        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)

        if dialog.exec() == QDialog.Accepted:
            description = text_edit.toPlainText().strip()
            self.current_origin.description = description
            self.desc_label.setText(description)
            self.save_btn.setEnabled(True)
            logger.debug("Updated origin description")

    def _edit_location(self, event):
        """Edit starting location on double-click."""
        if not self.current_origin or not self.location_manager or not self.location_manager.locations:
            return

        dialog = QDialog(self)
        dialog.setWindowTitle("Select Starting Location")
        dialog.setMinimumWidth(300)

        layout = QVBoxLayout(dialog)

        combo = QComboBox()
        # Add a "(None)" option
        combo.addItem("(None)", "")
        for location_id, location in self.location_manager.locations.items():
            combo.addItem(f"{location.name} ({location.type})", location_id)
            if location_id == self.current_origin.starting_location_id:
                combo.setCurrentIndex(combo.count() - 1)

        layout.addWidget(combo)

        btn_layout = QHBoxLayout()
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(dialog.accept)
        save_btn.setDefault(True)

        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)

        if dialog.exec() == QDialog.Accepted:
            location_id = combo.currentData()
            location = self.location_manager.locations.get(location_id) if location_id else None
            location_display = f"{location.name} ({location.type})" if location else "(None)"

            self.current_origin.starting_location_id = location_id
            self.location_label.setText(location_display)
            self.save_btn.setEnabled(True)
            logger.debug(f"Updated starting location to: {location_display} (ID: {location_id})")


    def _edit_culture(self, event): # NEW METHOD
        """Edit starting culture on double-click."""
        # TODO: Implement this - Requires access to CultureManager
        # Similar logic to _edit_location, using culture data
        # Add a "(None)" option to allow clearing the culture ID
        if not self.current_origin: return
        QMessageBox.information(self, "Edit Culture", "Culture editing not yet implemented.")
        logger.warning("Attempted to edit starting culture - functionality not implemented.")


    def _edit_introduction(self, event):
        """Edit introduction text on double-click."""
        if not self.current_origin:
            return

        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Introduction Text")
        dialog.setMinimumWidth(500)
        dialog.setMinimumHeight(300) # Adjusted height

        layout = QVBoxLayout(dialog)

        text_edit = QTextEdit()
        text_edit.setPlainText(self.current_origin.introduction_text)
        text_edit.setPlaceholderText("Enter introduction text that will be shown to the player at the start of the game...")
        layout.addWidget(text_edit)

        btn_layout = QHBoxLayout()
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(dialog.accept)
        save_btn.setDefault(True)

        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)

        if dialog.exec() == QDialog.Accepted:
            intro_text = text_edit.toPlainText().strip()
            self.current_origin.introduction_text = intro_text
            self.intro_label.setText(intro_text)
            self.save_btn.setEnabled(True)
            logger.debug("Updated introduction text")

    def _edit_quest(self, item):
        """Edit initial quests via the Manage dialog on double-click."""
        if not self.current_origin:
            return
        self._manage_initial_quests()

    def _edit_race(self, item):
        """Edit a suitable race on double-click."""
        if not self.current_origin:
            return

        current_text = item.text()
        new_text, ok = QInputDialog.getText(
            self,
            "Edit Suitable Race",
            "Enter race name:",
            QLineEdit.Normal,
            current_text
        )

        if ok and new_text.strip():
            item.setText(new_text.strip())
            self.save_btn.setEnabled(True)
            logger.debug(f"Updated race from '{current_text}' to '{new_text}'")

    def _edit_class(self, item):
        """Edit a suitable class on double-click."""
        if not self.current_origin:
            return

        current_text = item.text()
        new_text, ok = QInputDialog.getText(
            self,
            "Edit Suitable Class",
            "Enter class name:",
            QLineEdit.Normal,
            current_text
        )

        if ok and new_text.strip():
            item.setText(new_text.strip())
            self.save_btn.setEnabled(True)
            logger.debug(f"Updated class from '{current_text}' to '{new_text}'")

    def refresh(self):
        """Refresh the editor data."""
        self._refresh_origin_list()

    def _get_skill_display_name(self, skill_id_or_name: str) -> str:
        """
        Attempts to find a display name for a skill.
        If skills.json is loaded and contains the ID, use its name.
        Otherwise, return the input string itself (which might already be a name).
        This is a helper for consistent display if skills are sometimes stored by ID
        and sometimes by name. For this task, skill_proficiencies store names.
        """
        # This method is more of a placeholder if skill_ids were stored.
        # Since skill_proficiencies store names directly, this might not be strictly needed
        # but can be useful if a future refactor stores IDs.
        # For now, it will mostly just return the input name.
        # A more robust version would involve loading skills.json here if not already globally available.
        return skill_id_or_name
    
    def _get_item_display_name(self, item_id: str) -> str:
        """
        Attempts to find a display name for an item ID.
        For simplicity, this currently returns the ID itself.
        A more complete implementation would load item data (e.g., from origin_items.json)
        and look up the item's actual name.
        """
        # TODO: Enhance this to load item data and return actual item name.
        # This would require loading the relevant item file.
        # For now, just return the ID. The ItemSelectionDialog shows names.
        return item_id

    def _get_quest_display_name(self, quest_id: str) -> str:
        """Resolve a quest's display name as 'Title (id)' if available."""
        try:
            if self.quest_manager and getattr(self.quest_manager, 'quests', None):
                q = self.quest_manager.quests.get(quest_id)
                if q and getattr(q, 'title', None):
                    return f"{q.title} ({quest_id})"
        except Exception:
            pass
        return quest_id

    # ---- Assistant sanitizers ----
    def _sanitize_origin_payload(self, payload: dict) -> dict:
        if not isinstance(payload, dict):
            return payload
        sanitized = dict(payload)

        def _to_str_list(value):
            out = []
            if isinstance(value, list):
                for el in value:
                    if isinstance(el, str):
                        s = el.strip()
                        if s:
                            out.append(s)
                    elif isinstance(el, dict):
                        v = el.get("id")
                        if isinstance(v, str) and v.strip():
                            out.append(v.strip())
            return out

        # Coerce list-like fields to list[str]
        for key in ("initial_quests", "starting_items", "suitable_races", "suitable_classes", "skill_proficiencies"):
            if key in sanitized:
                sanitized[key] = _to_str_list(sanitized.get(key))

        # For initial_quests: dedupe, preserve order, and filter to known IDs
        if "initial_quests" in sanitized:
            seen = set()
            filtered: List[str] = []
            allowed_ids = set(self.quest_manager.quests.keys()) if (self.quest_manager and getattr(self.quest_manager, 'quests', None)) else None
            for qid in sanitized["initial_quests"]:
                if not isinstance(qid, str) or not qid.strip():
                    continue
                qid = qid.strip()
                if allowed_ids is not None and qid not in allowed_ids:
                    # Skip unknown quest IDs
                    continue
                if qid not in seen:
                    seen.add(qid)
                    filtered.append(qid)
            sanitized["initial_quests"] = filtered

        # Normalize simple strings
        for key in ("starting_location_id", "starting_culture_id", "name", "description", "introduction_text"):
            if key in sanitized and sanitized[key] is not None:
                sanitized[key] = str(sanitized[key])

        return sanitized

```

### File: world_configurator\ui\editors\quest_editor.py

```python
"""
Quest editor component for the World Configurator Tool.
"""

import logging
import uuid
from typing import Dict, List, Optional, Callable, Any

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QComboBox,
    QInputDialog, QTabWidget
)

from ui.dialogs.base_dialog import BaseDialog
from models.base_models import Quest, QuestObjective
from models.origin_data import QuestManager
from models.location_data import LocationManager

logger = logging.getLogger("world_configurator.ui.quest_editor")

class QuestObjectiveDialog(BaseDialog):
    """Dialog for editing a quest objective."""
    
    def __init__(self, parent=None, objective: Optional[QuestObjective] = None, location_manager=None):
        """
        Initialize the objective edit dialog.
        
        Args:
            parent: The parent widget.
            objective: Optional existing objective to edit.
            location_manager: Manager with location data for dropdown.
        """
        super().__init__(parent)
        self.setWindowTitle("Quest Objective")
        self.setMinimumWidth(500)
        self.setMinimumHeight(400)
        
        # Objective to edit
        self.objective = objective or QuestObjective(
            id=str(uuid.uuid4()),
            description="",
            type="fetch"
        )
        self.location_manager = location_manager
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for fields
        form = QFormLayout()
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.objective.description)
        self.desc_edit.setMinimumHeight(100)
        form.addRow("Description:", self.desc_edit)
        
        # Type field
        self.type_combo = QComboBox()
        self.type_combo.addItems(["fetch", "kill", "escort", "explore", "interact", "deliver", "other"])
        # Set current type if exists
        if self.objective.type:
            index = self.type_combo.findText(self.objective.type)
            if index >= 0:
                self.type_combo.setCurrentIndex(index)
        form.addRow("Type:", self.type_combo)
        
        # Target ID field
        self.target_edit = QLineEdit(self.objective.target_id)
        form.addRow("Target ID:", self.target_edit)
        
        # Location field
        self.location_combo = QComboBox()
        if self.location_manager:
            self._populate_location_combo()
            
            # Set current location if exists
            if self.objective.location_id:
                index = self.location_combo.findData(self.objective.location_id)
                if index >= 0:
                    self.location_combo.setCurrentIndex(index)
        
        form.addRow("Location:", self.location_combo)
        
        # Mandatory toggle
        from PySide6.QtWidgets import QCheckBox
        self.mandatory_check = QCheckBox("Mandatory objective")
        current_mandatory = getattr(self.objective, 'mandatory', None)
        self.mandatory_check.setChecked(True if current_mandatory is None else bool(current_mandatory))
        form.addRow("Requirement:", self.mandatory_check)
        
        # Completion criteria field
        self.criteria_edit = QTextEdit()
        self.criteria_edit.setPlainText(self.objective.completion_criteria)
        self.criteria_edit.setMinimumHeight(80)
        form.addRow("Completion Criteria:", self.criteria_edit)
        
        # Rewards field
        self.rewards_edit = QTextEdit()
        rewards_text = ""
        if self.objective.rewards:
            for reward_type, value in self.objective.rewards.items():
                rewards_text += f"{reward_type}: {value}\n"
        self.rewards_edit.setPlainText(rewards_text)
        self.rewards_edit.setMinimumHeight(80)
        self.rewards_edit.setPlaceholderText("Format: reward_type: value\nExamples:\nxp: 100\ngold: 50\nitem: sword_01")
        form.addRow("Rewards:", self.rewards_edit)
        
        layout.addLayout(form)
        
        # Buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def _populate_location_combo(self):
        """Populate the location dropdown with available locations."""
        self.location_combo.clear()
        
        if not self.location_manager or not self.location_manager.locations:
            self.location_combo.addItem("No locations available", "")
            return
        
        # Add each location to the combo box
        for location_id, location in self.location_manager.locations.items():
            self.location_combo.addItem(f"{location.name} ({location.type})", location_id)
    
    def get_objective(self) -> QuestObjective:
        """Get the edited objective."""
        self.objective.description = self.desc_edit.toPlainText()
        self.objective.type = self.type_combo.currentText()
        self.objective.target_id = self.target_edit.text()
        self.objective.location_id = self.location_combo.currentData()
        self.objective.completion_criteria = self.criteria_edit.toPlainText()
        # Save mandatory flag
        try:
            setattr(self.objective, 'mandatory', bool(self.mandatory_check.isChecked()))
        except Exception:
            pass
        
        # Parse rewards text to dict
        rewards = {}
        rewards_text = self.rewards_edit.toPlainText().strip()
        if rewards_text:
            for line in rewards_text.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()
                    # Try to convert value to int if possible
                    try:
                        value = int(value)
                    except ValueError:
                        pass
                    rewards[key] = value
                    
        self.objective.rewards = rewards
        
        return self.objective


class QuestEditor(QWidget):
    """Quest editor component."""
    
    # Signals
    quest_modified = Signal()
    
    def __init__(self, parent=None):
        """
        Initialize the quest editor.
        
        Args:
            parent: The parent widget.
        """
        super().__init__(parent)
        
        # Internal state
        self.quest_manager = QuestManager()
        self.location_manager = LocationManager()
        self.current_quest: Optional[Quest] = None
        
        # Setup UI
        self._setup_ui()

    # ===== Assistant integration =====
    def get_assistant_context(self):
        from assistant.context import AssistantContext
        allowed = [
            "/title",
            "/description",
            "/giver_id",
            "/level",
            "/rewards",
            "/prerequisites",
            "/objectives",
        ]
        content = self.current_quest.to_dict() if self.current_quest else None
        return AssistantContext(
            domain="quests",
            selection_id=self.current_quest.id if self.current_quest else None,
            content=content,
            schema=None,
            allowed_paths=allowed,
        )

    def get_domain_examples(self):
        if self.quest_manager.quests:
            first = next(iter(self.quest_manager.quests.values()))
            return [first.to_dict()]
        return []

    def get_reference_catalogs(self):
        # Provide location IDs and existing quest titles/ids
        location_ids = []
        try:
            if self.location_manager and getattr(self.location_manager, 'locations', None):
                location_ids = list(self.location_manager.locations.keys())
        except Exception:
            location_ids = []
        existing_titles = {}
        try:
            for q in self.quest_manager.quests.values():
                existing_titles[q.id] = q.title
        except Exception:
            existing_titles = {}
        return {
            "location_ids": location_ids,
            "existing_ids": list(existing_titles.keys()),
            "existing_titles": existing_titles,
        }

    def _sanitize_quest_payload(self, payload: dict) -> dict:
        if not isinstance(payload, dict):
            return payload
        sanitized = dict(payload)
        # Ensure level is int
        if "level" in sanitized:
            try:
                sanitized["level"] = int(sanitized["level"])
            except Exception:
                pass
        # Ensure prerequisites is list[str]
        if "prerequisites" in sanitized and isinstance(sanitized["prerequisites"], list):
            sanitized["prerequisites"] = [p for p in sanitized["prerequisites"] if isinstance(p, str) and p.strip()]
        # Objectives: allow replacing the whole list or editing fields. Coerce dicts to proper shape where obvious.
        if "objectives" in sanitized and isinstance(sanitized["objectives"], list):
            new_objs = []
            for obj in sanitized["objectives"]:
                if isinstance(obj, dict):
                    # ensure id
                    oid = obj.get("id")
                    if not isinstance(oid, str) or not oid:
                        import uuid
                        obj["id"] = str(uuid.uuid4())
                    # Coerce rewards to dict
                    if "rewards" in obj and not isinstance(obj["rewards"], dict):
                        obj["rewards"] = {}
                    new_objs.append(obj)
            sanitized["objectives"] = new_objs
        # Ensure id is slug-like if present
        if "id" in sanitized and isinstance(sanitized["id"], str):
            sanitized["id"] = self._slugify(sanitized["id"]) or sanitized["id"]
        return sanitized

    def _slugify(self, text: str) -> str:
        """Create a lowercase slug id from text (letters, numbers, hyphens)."""
        import re
        t = (text or "").strip().lower()
        t = re.sub(r"[^a-z0-9\s_-]", "", t)
        t = re.sub(r"[\s_-]+", "-", t)
        return t.strip("-")

    def apply_assistant_patch(self, patch_ops):
        from assistant.patching import apply_patch_with_validation
        ctx = self.get_assistant_context()
        if not ctx.content:
            return False, "No quest selected."
        ok, msg, new_content = apply_patch_with_validation(ctx, ctx.content, patch_ops)
        if not ok:
            return False, msg
        try:
            new_content = self._sanitize_quest_payload(new_content)
            updated = Quest.from_dict(new_content)
            updated.id = self.current_quest.id
            self.quest_manager.add_quest(updated)
            self._load_quest(updated)
            self.quest_modified.emit()
            return True, "OK"
        except Exception as e:
            return False, f"Failed to apply: {e}"

    def create_entry_from_llm(self, entry: dict):
        try:
            # Ensure unique, human-friendly title
            proposed_title = (entry.get("title") or "New Quest").strip()
            existing_titles = {q.title for q in self.quest_manager.quests.values()}
            title = proposed_title
            suffix = 1
            while title in existing_titles:
                title = f"{proposed_title} ({suffix})"
                suffix += 1

            # Derive a slug id from the title and ensure uniqueness among quest ids
            base_slug = self._slugify(title)
            quest_ids = set(self.quest_manager.quests.keys())
            slug = base_slug
            i = 1
            while slug in quest_ids:
                i += 1
                slug = f"{base_slug}-{i}"

            desc = entry.get("description", "")
            # Build quest dict using the slug as id
            tmp = {
                "id": slug,
                "title": title,
                "description": desc,
                "giver_id": entry.get("giver_id", ""),
                "level": entry.get("level", 1),
                "objectives": entry.get("objectives", []),
                "rewards": entry.get("rewards", {}),
                "prerequisites": entry.get("prerequisites", []),
            }
            # Merge any extra fields from entry (excluding id/title which we control)
            for k, v in entry.items():
                if k not in ("id", "title"):
                    tmp[k] = v if k not in tmp else tmp[k]

            tmp = self._sanitize_quest_payload(tmp)
            new_obj = Quest.from_dict(tmp)
            new_obj.id = slug  # Ensure id is the slug
            self.quest_manager.add_quest(new_obj)
            self._refresh_quest_list()
            # select new
            for i in range(self.quest_list.count()):
                it = self.quest_list.item(i)
                if self.quest_manager.get_quest(it.data(Qt.UserRole)).id == new_obj.id:
                    self.quest_list.setCurrentItem(it)
                    break
            self.quest_modified.emit()
            return True, "Created", new_obj.id
        except Exception as e:
            return False, f"Failed to create: {e}", None
    
    def _setup_ui(self):
        """Setup the editor UI."""
        main_layout = QHBoxLayout(self)
        
        # Create a splitter for resizable panels
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)
        
        # Left panel (quest list)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        list_label = QLabel("Quests")
        list_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        left_layout.addWidget(list_label)
        
        self.quest_list = QListWidget()
        self.quest_list.setMinimumWidth(200)
        self.quest_list.currentItemChanged.connect(self._on_quest_selected)
        left_layout.addWidget(self.quest_list)
        
        list_buttons = QHBoxLayout()
        
        self.add_quest_btn = QPushButton("Add")
        self.add_quest_btn.clicked.connect(self._add_quest)
        list_buttons.addWidget(self.add_quest_btn)
        
        self.remove_quest_btn = QPushButton("Remove")
        self.remove_quest_btn.clicked.connect(self._remove_quest)
        self.remove_quest_btn.setEnabled(False)
        list_buttons.addWidget(self.remove_quest_btn)
        
        left_layout.addLayout(list_buttons)
        
        # Add left panel to splitter
        splitter.addWidget(left_panel)
        
        # Right panel (quest details)
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)
        
        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)
        
        self.details_layout = QVBoxLayout(self.details_widget)
        
        # Quest details form
        self.form_layout = QFormLayout()
        
        # Quest title
        self.title_edit = QLineEdit()
        self.title_edit.setPlaceholderText("Enter quest title")
        self.title_edit.textChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Title:", self.title_edit)
        
        # Quest description
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlaceholderText("Enter quest description")
        self.desc_edit.textChanged.connect(self._on_field_changed)
        self.desc_edit.setMinimumHeight(100)
        self.form_layout.addRow("Description:", self.desc_edit)
        
        # Quest giver
        self.giver_edit = QLineEdit()
        self.giver_edit.setPlaceholderText("Enter NPC ID of quest giver")
        self.giver_edit.textChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Quest Giver ID:", self.giver_edit)
        
        # Quest level
        self.level_spin = QSpinBox()
        self.level_spin.setRange(1, 50)
        self.level_spin.setValue(1)
        self.level_spin.valueChanged.connect(self._on_field_changed)
        self.form_layout.addRow("Level:", self.level_spin)
        
        self.details_layout.addLayout(self.form_layout)
        
        # Objectives section
        objectives_label = QLabel("Objectives")
        objectives_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(objectives_label)
        
        self.objectives_list = QListWidget()
        self.objectives_list.setMinimumHeight(150)
        self.details_layout.addWidget(self.objectives_list)
        
        objectives_buttons = QHBoxLayout()
        
        self.add_objective_btn = QPushButton("Add Objective")
        self.add_objective_btn.clicked.connect(self._add_objective)
        objectives_buttons.addWidget(self.add_objective_btn)
        
        self.edit_objective_btn = QPushButton("Edit Objective")
        self.edit_objective_btn.clicked.connect(self._edit_objective)
        objectives_buttons.addWidget(self.edit_objective_btn)
        
        self.remove_objective_btn = QPushButton("Remove Objective")
        self.remove_objective_btn.clicked.connect(self._remove_objective)
        objectives_buttons.addWidget(self.remove_objective_btn)
        
        self.details_layout.addLayout(objectives_buttons)
        
        # Rewards section
        rewards_label = QLabel("Rewards")
        rewards_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(rewards_label)
        
        self.rewards_edit = QTextEdit()
        self.rewards_edit.setPlaceholderText("Format: reward_type: value\nExamples:\nxp: 500\ngold: 100\nitem: legendary_sword")
        self.rewards_edit.setMaximumHeight(100)
        self.rewards_edit.textChanged.connect(self._on_field_changed)
        self.details_layout.addWidget(self.rewards_edit)
        
        # Prerequisites section
        prereq_label = QLabel("Prerequisites")
        prereq_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        self.details_layout.addWidget(prereq_label)
        
        self.prereq_edit = QTextEdit()
        self.prereq_edit.setPlaceholderText("Enter one quest ID per line...")
        self.prereq_edit.setMaximumHeight(100)
        self.prereq_edit.textChanged.connect(self._on_field_changed)
        self.details_layout.addWidget(self.prereq_edit)
        
        # Save button
        save_layout = QHBoxLayout()
        save_layout.addStretch()
        
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self._save_current_quest)
        self.save_btn.setEnabled(False)
        save_layout.addWidget(self.save_btn)
        
        self.details_layout.addLayout(save_layout)
        
        # Add right panel to splitter
        splitter.addWidget(right_panel)
        
        # Set up initial state
        self._disable_details()
        
        # Prioritize the details panel for resizing
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
    
    def set_managers(self, quest_manager: QuestManager, location_manager: LocationManager) -> None:
        """
        Set the quest and location managers to use.
        
        Args:
            quest_manager: The quest manager.
            location_manager: The location manager.
        """
        self.quest_manager = quest_manager
        self.location_manager = location_manager
        
        # Refresh quest list
        self._refresh_quest_list()
    
    def _refresh_quest_list(self) -> None:
        """Refresh the quest list from the manager."""
        # Clear list
        self.quest_list.clear()
        
        # Add all quests
        for quest_id, quest in self.quest_manager.quests.items():
            item = QListWidgetItem(quest.title)
            item.setData(Qt.UserRole, quest_id)
            self.quest_list.addItem(item)
        
        # Sort alphabetically
        self.quest_list.sortItems()
        
        # Select the first item if available
        if self.quest_list.count() > 0:
            self.quest_list.setCurrentRow(0)
    
    def _on_quest_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]) -> None:
        """
        Handle quest selection change.
        
        Args:
            current: The current selected item, or None.
            previous: The previously selected item, or None.
        """
        if current:
            quest_id = current.data(Qt.UserRole)
            quest = self.quest_manager.get_quest(quest_id)
            
            if quest:
                self._load_quest(quest)
                self.remove_quest_btn.setEnabled(True)
                return
        
        # No valid selection
        self._disable_details()
        self.remove_quest_btn.setEnabled(False)
    
    def _load_quest(self, quest) -> None:
        """
        Load a quest into the editor.
        
        Args:
            quest: The quest to load (Quest object or dictionary).
        """
        try:
            # Ensure quest is a Quest object
            if isinstance(quest, dict):
                logger.info(f"Converting dictionary to Quest object for {quest.get('title', 'Unknown Quest')}")
                quest = Quest.from_dict(quest)
            
            self.current_quest = quest
            
            # Set form values
            self.title_edit.setText(quest.title)
            self.desc_edit.setPlainText(quest.description)
            self.giver_edit.setText(quest.giver_id)
            self.level_spin.setValue(quest.level)
            
            # Load rewards
            rewards_text = ""
            if quest.rewards:
                for reward_type, value in quest.rewards.items():
                    rewards_text += f"{reward_type}: {value}\n"
            self.rewards_edit.setPlainText(rewards_text)
            
            # Load prerequisites
            self.prereq_edit.setPlainText("\n".join(quest.prerequisites))
            
            # Load objectives
            self.objectives_list.clear()
            for objective in quest.objectives:
                item = QListWidgetItem(objective.description)
                item.setData(Qt.UserRole, objective)
                self.objectives_list.addItem(item)
            
            # Enable controls
            self._enable_details()
            self.save_btn.setEnabled(False)  # Initially not modified
            
        except Exception as e:
            logger.error(f"Error loading quest {quest.title}: {str(e)}")
            QMessageBox.warning(
                self,
                "Error Loading Quest",
                f"There was an error loading the quest '{quest.title}':\n\n{str(e)}\n\nSome data may not be displayed correctly."
            )
            # Still enable the editor to allow fixing the issue
            self._enable_details()
            self.save_btn.setEnabled(True)  # Enable saving to fix issues
    
    def _disable_details(self) -> None:
        """Disable all detail controls."""
        self.current_quest = None
        
        self.title_edit.clear()
        self.desc_edit.clear()
        self.giver_edit.clear()
        self.level_spin.setValue(1)
        self.rewards_edit.clear()
        self.prereq_edit.clear()
        
        self.objectives_list.clear()
        
        self.title_edit.setEnabled(False)
        self.desc_edit.setEnabled(False)
        self.giver_edit.setEnabled(False)
        self.level_spin.setEnabled(False)
        self.rewards_edit.setEnabled(False)
        self.prereq_edit.setEnabled(False)
        
        self.objectives_list.setEnabled(False)
        
        self.add_objective_btn.setEnabled(False)
        self.edit_objective_btn.setEnabled(False)
        self.remove_objective_btn.setEnabled(False)
        
        self.save_btn.setEnabled(False)
    
    def _enable_details(self) -> None:
        """Enable all detail controls."""
        self.title_edit.setEnabled(True)
        self.desc_edit.setEnabled(True)
        self.giver_edit.setEnabled(True)
        self.level_spin.setEnabled(True)
        self.rewards_edit.setEnabled(True)
        self.prereq_edit.setEnabled(True)
        
        self.objectives_list.setEnabled(True)
        
        self.add_objective_btn.setEnabled(True)
        self.edit_objective_btn.setEnabled(True)
        self.remove_objective_btn.setEnabled(True)
    
    def _on_field_changed(self) -> None:
        """Handle field value changes."""
        if self.current_quest:
            self.save_btn.setEnabled(True)
    
    def _save_current_quest(self) -> None:
        """Save the current quest to the manager."""
        if not self.current_quest:
            return
        
        # Update quest from form
        self.current_quest.title = self.title_edit.text()
        self.current_quest.description = self.desc_edit.toPlainText()
        self.current_quest.giver_id = self.giver_edit.text()
        self.current_quest.level = self.level_spin.value()
        
        # Parse rewards text to dict
        rewards = {}
        rewards_text = self.rewards_edit.toPlainText().strip()
        if rewards_text:
            for line in rewards_text.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()
                    # Try to convert value to int if possible
                    try:
                        value = int(value)
                    except ValueError:
                        pass
                    rewards[key] = value
        
        self.current_quest.rewards = rewards
        
        # Parse prerequisites
        self.current_quest.prerequisites = [prereq.strip() for prereq in self.prereq_edit.toPlainText().split('\n') if prereq.strip()]
        
        # Update quest in manager
        self.quest_manager.add_quest(self.current_quest)
        
        # Mark as saved
        self.save_btn.setEnabled(False)
        
        # Update quest list
        self._refresh_quest_list()
        
        # Find and select the current quest in the list
        for i in range(self.quest_list.count()):
            item = self.quest_list.item(i)
            if item.data(Qt.UserRole) == self.current_quest.id:
                self.quest_list.setCurrentItem(item)
                break
        
        # Emit modified signal
        self.quest_modified.emit()
        
        # Log
        logger.info(f"Saved quest: {self.current_quest.title} ({self.current_quest.id})")
    
    def _add_quest(self) -> None:
        """Add a new quest."""
        # Create new quest
        quest = Quest.create_new("New Quest", "Description of the quest")
        
        # Add to manager
        self.quest_manager.add_quest(quest)
        
        # Refresh list
        self._refresh_quest_list()
        
        # Find and select the new quest
        for i in range(self.quest_list.count()):
            item = self.quest_list.item(i)
            if item.data(Qt.UserRole) == quest.id:
                self.quest_list.setCurrentItem(item)
                break
        
        # Set focus to title for immediate editing
        self.title_edit.setFocus()
        self.title_edit.selectAll()
        
        # Emit modified signal
        self.quest_modified.emit()
        
        # Log
        logger.info(f"Added new quest: {quest.id}")
    
    def _remove_quest(self) -> None:
        """Remove the selected quest."""
        current_item = self.quest_list.currentItem()
        if not current_item:
            return
        
        quest_id = current_item.data(Qt.UserRole)
        quest = self.quest_manager.get_quest(quest_id)
        
        if not quest:
            return
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete the quest '{quest.title}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove from manager
        self.quest_manager.remove_quest(quest_id)
        
        # Refresh list
        self._refresh_quest_list()
        
        # Emit modified signal
        self.quest_modified.emit()
        
        # Log
        logger.info(f"Removed quest: {quest_id}")
    
    def _add_objective(self) -> None:
        """Add a new objective to the current quest."""
        if not self.current_quest:
            return
        
        dialog = QuestObjectiveDialog(self, location_manager=self.location_manager)
        
        if dialog.exec() == QDialog.Accepted:
            objective = dialog.get_objective()
            
            # Add to quest
            self.current_quest.objectives.append(objective)
            
            # Add to list
            item = QListWidgetItem(objective.description)
            item.setData(Qt.UserRole, objective)
            self.objectives_list.addItem(item)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Added objective to quest {self.current_quest.id}: {objective.description}")
    
    def _edit_objective(self) -> None:
        """Edit the selected objective."""
        if not self.current_quest:
            return
        
        current_item = self.objectives_list.currentItem()
        if not current_item:
            return
        
        objective = current_item.data(Qt.UserRole)
        dialog = QuestObjectiveDialog(self, objective, self.location_manager)
        
        if dialog.exec() == QDialog.Accepted:
            updated_obj = dialog.get_objective()
            
            # Find and update the objective in the quest
            for i, obj in enumerate(self.current_quest.objectives):
                if obj.id == updated_obj.id:
                    self.current_quest.objectives[i] = updated_obj
                    break
            
            # Update item
            current_item.setText(updated_obj.description)
            current_item.setData(Qt.UserRole, updated_obj)
            
            # Mark as modified
            self.save_btn.setEnabled(True)
            
            # Log
            logger.debug(f"Edited objective in quest {self.current_quest.id}: {updated_obj.description}")
    
    def _remove_objective(self) -> None:
        """Remove the selected objective."""
        if not self.current_quest:
            return
        
        current_item = self.objectives_list.currentItem()
        if not current_item:
            return
        
        objective = current_item.data(Qt.UserRole)
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Removal",
            f"Are you sure you want to remove this objective?\n\n{objective.description}",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Remove from quest
        self.current_quest.objectives = [obj for obj in self.current_quest.objectives if obj.id != objective.id]
        
        # Remove from list
        self.objectives_list.takeItem(self.objectives_list.row(current_item))
        
        # Mark as modified
        self.save_btn.setEnabled(True)
        
        # Log
        logger.debug(f"Removed objective from quest {self.current_quest.id}: {objective.description}")
    
    def refresh(self):
        """Refresh the editor data."""
        self._refresh_quest_list()
    
class QuestDialog(QDialog):
    
    def __init__(self, parent=None, quest: Optional[Quest] = None, location_manager=None):
        """
        Initialize the quest edit dialog.
        
        Args:
            parent: The parent widget.
            quest: Optional existing quest to edit.
            location_manager: Manager with location data for dropdown.
        """
        super().__init__(parent)
        self.setWindowTitle("Quest")
        self.setMinimumWidth(600)
        self.setMinimumHeight(600)
        
        # Quest to edit
        self.quest = quest or Quest.create_new("", "")
        self.location_manager = location_manager
        
        # Setup UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Form layout for fields
        form = QFormLayout()
        
        # Title field
        self.title_edit = QLineEdit(self.quest.title)
        form.addRow("Title:", self.title_edit)
        
        # Description field
        self.desc_edit = QTextEdit()
        self.desc_edit.setPlainText(self.quest.description)
        self.desc_edit.setMinimumHeight(100)
        form.addRow("Description:", self.desc_edit)
        
        # Quest giver field
        self.giver_edit = QLineEdit(self.quest.giver_id)
        form.addRow("Quest Giver ID:", self.giver_edit)
        
        # Level field
        self.level_spin = QSpinBox()
        self.level_spin.setRange(1, 50)
        self.level_spin.setValue(self.quest.level)
        form.addRow("Level:", self.level_spin)
        
        # Add form to layout
        layout.addLayout(form)
        
        # Objectives section
        objectives_label = QLabel("Objectives")
        objectives_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        layout.addWidget(objectives_label)
        
        # Objectives list
        self.objectives_list = QListWidget()
        self.objectives_list.setMinimumHeight(150)
        self._populate_objectives_list()
        layout.addWidget(self.objectives_list)
        
        # Objectives buttons
        obj_buttons = QHBoxLayout()
        
        self.add_obj_btn = QPushButton("Add Objective")
        self.add_obj_btn.clicked.connect(self._add_objective)
        obj_buttons.addWidget(self.add_obj_btn)
        
        self.edit_obj_btn = QPushButton("Edit Objective")
        self.edit_obj_btn.clicked.connect(self._edit_objective)
        obj_buttons.addWidget(self.edit_obj_btn)
        
        self.remove_obj_btn = QPushButton("Remove Objective")
        self.remove_obj_btn.clicked.connect(self._remove_objective)
        obj_buttons.addWidget(self.remove_obj_btn)
        
        layout.addLayout(obj_buttons)
        
        # Rewards section
        rewards_label = QLabel("Rewards")
        rewards_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        layout.addWidget(rewards_label)
        
        # Rewards edit
        self.rewards_edit = QTextEdit()
        rewards_text = ""
        if self.quest.rewards:
            for reward_type, value in self.quest.rewards.items():
                rewards_text += f"{reward_type}: {value}\n"
        self.rewards_edit.setPlainText(rewards_text)
        self.rewards_edit.setMinimumHeight(80)
        self.rewards_edit.setPlaceholderText("Format: reward_type: value\nExamples:\nxp: 500\ngold: 100\nitem: legendary_sword")
        layout.addWidget(self.rewards_edit)
        
        # Prerequisites section
        prereq_label = QLabel("Prerequisites")
        prereq_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        layout.addWidget(prereq_label)
        
        # Prerequisites edit
        self.prereq_edit = QTextEdit()
        self.prereq_edit.setPlainText("\n".join(self.quest.prerequisites))
        self.prereq_edit.setMinimumHeight(80)
        self.prereq_edit.setPlaceholderText("One quest ID per line...")
        layout.addWidget(self.prereq_edit)
        
        # Dialog buttons
        btn_layout = QHBoxLayout()
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        
        layout.addLayout(btn_layout)
    
    def _populate_objectives_list(self):
        """Populate the objectives list."""
        self.objectives_list.clear()
        
        for objective in self.quest.objectives:
            item = QListWidgetItem(objective.description)
            item.setData(Qt.UserRole, objective)
            self.objectives_list.addItem(item)
    
    def _add_objective(self):
        """Add a new objective."""
        dialog = QuestObjectiveDialog(self, location_manager=self.location_manager)
        
        if dialog.exec() == QDialog.Accepted:
            objective = dialog.get_objective()
            self.quest.objectives.append(objective)
            
            # Update list
            self._populate_objectives_list()
    
    def _edit_objective(self):
        """Edit the selected objective."""
        current_item = self.objectives_list.currentItem()
        if not current_item:
            return
        
        objective = current_item.data(Qt.UserRole)
        dialog = QuestObjectiveDialog(self, objective, self.location_manager)
        
        if dialog.exec() == QDialog.Accepted:
            updated_obj = dialog.get_objective()
            
            # Find and update the objective in the quest
            for i, obj in enumerate(self.quest.objectives):
                if obj.id == updated_obj.id:
                    self.quest.objectives[i] = updated_obj
                    break
            
            # Update list
            self._populate_objectives_list()
    
    def _remove_objective(self):
        """Remove the selected objective."""
        current_item = self.objectives_list.currentItem()
        if not current_item:
            return
        
        objective = current_item.data(Qt.UserRole)
        
        # Confirm deletion
        result = QMessageBox.question(
            self,
            "Confirm Removal",
            f"Are you sure you want to remove this objective?\n\n{objective.description}",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result == QMessageBox.Yes:
            # Remove objective from quest
            self.quest.objectives = [obj for obj in self.quest.objectives if obj.id != objective.id]
            
            # Update list
            self._populate_objectives_list()
    
    def get_quest(self) -> Quest:
        """Get the edited quest."""
        self.quest.title = self.title_edit.text()
        self.quest.description = self.desc_edit.toPlainText()
        self.quest.giver_id = self.giver_edit.text()
        self.quest.level = self.level_spin.value()
        
        # Parse rewards text to dict
        rewards = {}
        rewards_text = self.rewards_edit.toPlainText().strip()
        if rewards_text:
            for line in rewards_text.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()
                    # Try to convert value to int if possible
                    try:
                        value = int(value)
                    except ValueError:
                        pass
                    rewards[key] = value
        
        self.quest.rewards = rewards
        
        # Parse prerequisites
        self.quest.prerequisites = [prereq.strip() for prereq in self.prereq_edit.toPlainText().split('\n') if prereq.strip()]
        
        return self.quest

```

### File: world_configurator\ui\editors\race_editor.py

```python
# world_configurator/ui/editors/race_editor.py
"""
Race editor component for the World Configurator Tool.
"""

import logging
import copy
from typing import Dict, List, Optional, Any

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QSpinBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QTabWidget,
    QGridLayout, QInputDialog
)

from ui.dialogs.base_dialog import BaseDialog
from models.base_models import Race, RaceTrait
from models.world_data import RaceManager

logger = logging.getLogger("world_configurator.ui.race_editor")

# --- Helper Dialogs ---

class TraitDialog(BaseDialog):
    """Dialog for editing a RaceTrait."""
    def __init__(self, parent=None, trait: Optional[RaceTrait] = None):
        super().__init__(parent)
        self.setWindowTitle("Race Trait")
        self.setMinimumWidth(400)

        self.trait = trait or RaceTrait(name="New Trait", description="")

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.name_edit = QLineEdit(self.trait.name)
        form.addRow("Name:", self.name_edit)

        self.desc_edit = QTextEdit(self.trait.description)
        self.desc_edit.setMinimumHeight(80)
        form.addRow("Description:", self.desc_edit)

        layout.addLayout(form)

        btn_layout = QHBoxLayout()
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        layout.addLayout(btn_layout)

    def get_trait(self) -> RaceTrait:
        self.trait.name = self.name_edit.text()
        self.trait.description = self.desc_edit.toPlainText()
        return self.trait

# --- Main Race Dialog ---

class RaceDialog(QDialog):
    """Dialog for editing a Race."""
    def __init__(self, parent=None, race: Optional[Race] = None):
        super().__init__(parent)
        self.setWindowTitle("Race Editor")
        self.setMinimumWidth(600)
        self.setMinimumHeight(550)

        self.race = copy.deepcopy(race) if race else Race.create_new("New Race", "")
        self.possible_stats = ["STR", "DEX", "CON", "INT", "WIS", "CHA"]

        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Basic Info Tab
        basic_tab = QWidget()
        self.tabs.addTab(basic_tab, "Basic Info")
        basic_layout = QFormLayout(basic_tab)
        self.name_edit = QLineEdit(self.race.name)
        basic_layout.addRow("Name:", self.name_edit)
        self.desc_edit = QTextEdit(self.race.description)
        self.desc_edit.setMinimumHeight(100)
        basic_layout.addRow("Description:", self.desc_edit)

        # Stat Modifiers Tab
        stats_tab = QWidget()
        self.tabs.addTab(stats_tab, "Stat Modifiers")
        stats_layout = QGridLayout(stats_tab)
        self.stat_spins: Dict[str, QSpinBox] = {}
        for i, stat in enumerate(self.possible_stats):
            label = QLabel(f"{stat}:")
            spin = QSpinBox()
            spin.setRange(-5, 5) # Example range
            spin.setValue(self.race.stat_modifiers.get(stat, 0))
            self.stat_spins[stat] = spin
            row, col = divmod(i, 3) # Arrange in 2 rows
            stats_layout.addWidget(label, row, col * 2)
            stats_layout.addWidget(spin, row, col * 2 + 1)
        stats_layout.setColumnStretch(1, 1)
        stats_layout.setColumnStretch(3, 1)
        stats_layout.setColumnStretch(5, 1)

        # Traits Tab
        traits_tab = QWidget()
        self.tabs.addTab(traits_tab, "Traits")
        traits_layout = QVBoxLayout(traits_tab)
        traits_layout.addWidget(QLabel("Racial Traits:"))
        self.traits_list = QListWidget()
        self.traits_list.itemDoubleClicked.connect(self._edit_trait)
        traits_layout.addWidget(self.traits_list)
        for trait in self.race.traits:
            self._add_trait_to_list(trait)
        trait_btns = QHBoxLayout()
        add_trait_btn = QPushButton("Add Trait")
        add_trait_btn.clicked.connect(self._add_trait)
        edit_trait_btn = QPushButton("Edit Trait")
        edit_trait_btn.clicked.connect(lambda: self._edit_trait(self.traits_list.currentItem()))
        remove_trait_btn = QPushButton("Remove Trait")
        remove_trait_btn.clicked.connect(self._remove_trait)
        trait_btns.addWidget(add_trait_btn)
        trait_btns.addWidget(edit_trait_btn)
        trait_btns.addWidget(remove_trait_btn)
        traits_layout.addLayout(trait_btns)

        # Recommended Classes Tab
        rec_class_tab = QWidget()
        self.tabs.addTab(rec_class_tab, "Recommended Classes")
        rec_class_layout = QVBoxLayout(rec_class_tab)
        rec_class_layout.addWidget(QLabel("Recommended Classes:"))
        self.rec_class_list = QListWidget()
        rec_class_layout.addWidget(self.rec_class_list)
        for class_name in self.race.recommended_classes:
            self.rec_class_list.addItem(QListWidgetItem(class_name))
        rec_class_btns = QHBoxLayout()
        add_rec_btn = QPushButton("Add Class")
        add_rec_btn.clicked.connect(self._add_rec_class)
        remove_rec_btn = QPushButton("Remove Class")
        remove_rec_btn.clicked.connect(self._remove_rec_class)
        rec_class_btns.addWidget(add_rec_btn)
        rec_class_btns.addWidget(remove_rec_btn)
        rec_class_layout.addLayout(rec_class_btns)

        # Dialog Buttons
        btn_layout = QHBoxLayout()
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        self.save_btn = QPushButton("Save")
        self.save_btn.clicked.connect(self.accept)
        self.save_btn.setDefault(True)
        btn_layout.addWidget(self.cancel_btn)
        btn_layout.addWidget(self.save_btn)
        layout.addLayout(btn_layout)

    def _add_trait_to_list(self, trait: RaceTrait):
        item = QListWidgetItem(f"{trait.name}")
        item.setToolTip(trait.description)
        item.setData(Qt.UserRole, trait)
        self.traits_list.addItem(item)
        self.traits_list.sortItems()

    def _add_trait(self):
        dialog = TraitDialog(self)
        if dialog.exec() == QDialog.Accepted:
            new_trait = dialog.get_trait()
            # Check for duplicate names
            for i in range(self.traits_list.count()):
                if self.traits_list.item(i).data(Qt.UserRole).name == new_trait.name:
                    QMessageBox.warning(self, "Duplicate Trait", f"A trait named '{new_trait.name}' already exists.")
                    return
            self._add_trait_to_list(new_trait)

    def _edit_trait(self, item: Optional[QListWidgetItem]):
        if not item:
            item = self.traits_list.currentItem()
        if not item: return

        original_trait = item.data(Qt.UserRole)
        dialog = TraitDialog(self, copy.deepcopy(original_trait))
        if dialog.exec() == QDialog.Accepted:
            updated_trait = dialog.get_trait()
            # Check if name changed and conflicts
            if original_trait.name != updated_trait.name:
                 for i in range(self.traits_list.count()):
                    existing_trait = self.traits_list.item(i).data(Qt.UserRole)
                    if self.traits_list.item(i) != item and existing_trait.name == updated_trait.name:
                        QMessageBox.warning(self, "Duplicate Trait", f"A trait named '{updated_trait.name}' already exists.")
                        return

            item.setText(updated_trait.name)
            item.setToolTip(updated_trait.description)
            item.setData(Qt.UserRole, updated_trait)
            self.traits_list.sortItems()

    def _remove_trait(self):
        item = self.traits_list.currentItem()
        if not item: return
        result = QMessageBox.question(self, "Confirm Removal", "Remove this trait?", QMessageBox.Yes | QMessageBox.No)
        if result == QMessageBox.Yes:
            self.traits_list.takeItem(self.traits_list.row(item))

    def _add_rec_class(self):
        class_name, ok = QInputDialog.getText(self, "Add Recommended Class", "Class Name:")
        if ok and class_name:
            class_name = class_name.strip()
            if class_name and not self.rec_class_list.findItems(class_name, Qt.MatchExactly):
                self.rec_class_list.addItem(QListWidgetItem(class_name))
                self.rec_class_list.sortItems()

    def _remove_rec_class(self):
        item = self.rec_class_list.currentItem()
        if not item: return
        result = QMessageBox.question(self, "Confirm Removal", "Remove this recommended class?", QMessageBox.Yes | QMessageBox.No)
        if result == QMessageBox.Yes:
            self.rec_class_list.takeItem(self.rec_class_list.row(item))

    def get_race(self) -> Race:
        self.race.name = self.name_edit.text()
        self.race.description = self.desc_edit.toPlainText()

        self.race.stat_modifiers = {stat: spin.value() for stat, spin in self.stat_spins.items()}

        self.race.traits = []
        for i in range(self.traits_list.count()):
            self.race.traits.append(self.traits_list.item(i).data(Qt.UserRole))

        self.race.recommended_classes = []
        for i in range(self.rec_class_list.count()):
            self.race.recommended_classes.append(self.rec_class_list.item(i).text())

        return self.race

# --- Main Editor Widget ---

class RaceEditor(QWidget):
    """Editor component for Races."""
    race_modified = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.race_manager = RaceManager()
        self.current_race: Optional[Race] = None
        self._setup_ui()

    def _setup_ui(self):
        main_layout = QHBoxLayout(self)
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)

        # Left panel (List)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel("Races", styleSheet="font-weight: bold; font-size: 14px;"))
        self.race_list = QListWidget()
        self.race_list.setMinimumWidth(200)
        self.race_list.currentItemChanged.connect(self._on_race_selected)
        left_layout.addWidget(self.race_list)
        list_btns = QHBoxLayout()
        self.add_btn = QPushButton("Add")
        self.add_btn.clicked.connect(self._add_race)
        self.edit_btn = QPushButton("Edit")
        self.edit_btn.clicked.connect(self._edit_race)
        self.edit_btn.setEnabled(False)
        self.remove_btn = QPushButton("Remove")
        self.remove_btn.clicked.connect(self._remove_race)
        self.remove_btn.setEnabled(False)
        list_btns.addWidget(self.add_btn)
        list_btns.addWidget(self.edit_btn)
        list_btns.addWidget(self.remove_btn)
        left_layout.addLayout(list_btns)
        splitter.addWidget(left_panel)

        # Right panel (Details - Read Only)
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)
        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)
        self.details_layout = QVBoxLayout(self.details_widget)

        self.details_form = QFormLayout()
        self.name_label = QLabel()
        self.name_label.setWordWrap(True)
        self.details_form.addRow("<b>Name:</b>", self.name_label)
        self.desc_label = QLabel()
        self.desc_label.setWordWrap(True)
        self.details_form.addRow("<b>Description:</b>", self.desc_label)
        self.details_layout.addLayout(self.details_form)

        self.details_layout.addWidget(QLabel("<b>Stat Modifiers:</b>", styleSheet="margin-top: 10px;"))
        self.stats_display_list = QListWidget()
        self.stats_display_list.setEnabled(False)
        self.details_layout.addWidget(self.stats_display_list)

        self.details_layout.addWidget(QLabel("<b>Traits:</b>", styleSheet="margin-top: 10px;"))
        self.traits_display_list = QListWidget()
        self.traits_display_list.setEnabled(False)
        self.details_layout.addWidget(self.traits_display_list)

        self.details_layout.addWidget(QLabel("<b>Recommended Classes:</b>", styleSheet="margin-top: 10px;"))
        self.rec_class_display_list = QListWidget()
        self.rec_class_display_list.setEnabled(False)
        self.details_layout.addWidget(self.rec_class_display_list)

        self.details_layout.addStretch()
        splitter.addWidget(right_panel)

        self._disable_details_display()
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)

    def set_race_manager(self, manager: RaceManager):
        self.race_manager = manager
        self._refresh_race_list()

    def _refresh_race_list(self):
        current_name = self.race_list.currentItem().data(Qt.UserRole) if self.race_list.currentItem() else None # Store name
        self.race_list.clear()
        items_to_add = []
        # 'race_name' here is the key from the manager's dict
        for race_name, race in self.race_manager.races.items():
            item = QListWidgetItem(race.name)
            item.setData(Qt.UserRole, race_name) # Store the name
            items_to_add.append(item)
        items_to_add.sort(key=lambda x: x.text())
        new_selection = None
        for item in items_to_add:
            self.race_list.addItem(item)
            if item.data(Qt.UserRole) == current_name: # Compare names
                new_selection = item

        if new_selection:
            self.race_list.setCurrentItem(new_selection)
        elif self.race_list.count() > 0:
            self.race_list.setCurrentRow(0)
        else:
            self._disable_details_display()
            self.edit_btn.setEnabled(False)
            self.remove_btn.setEnabled(False)

    def _on_race_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]):
        if current:
            race_name = current.data(Qt.UserRole) # Retrieve the name
            race = self.race_manager.get_race(race_name) # Use name to get race
            if race:
                self._load_race_display(race)
                self.edit_btn.setEnabled(True)
                self.remove_btn.setEnabled(True)
                return
        self._disable_details_display()
        self.edit_btn.setEnabled(False)
        self.remove_btn.setEnabled(False)

    def _load_race_display(self, race: Race):
        self.current_race = race
        self.name_label.setText(race.name or "N/A")
        self.desc_label.setText(race.description or "N/A")

        self.stats_display_list.clear()
        for stat, mod in race.stat_modifiers.items():
            if mod != 0:
                sign = "+" if mod > 0 else ""
                self.stats_display_list.addItem(f"{stat}: {sign}{mod}")

        self.traits_display_list.clear()
        for trait in race.traits:
            item = QListWidgetItem(trait.name)
            item.setToolTip(trait.description)
            self.traits_display_list.addItem(item)

        self.rec_class_display_list.clear()
        for class_name in race.recommended_classes:
            self.rec_class_display_list.addItem(class_name)

        self.details_widget.setEnabled(True)

    def _disable_details_display(self):
        self.current_race = None
        self.name_label.clear()
        self.desc_label.clear()
        self.stats_display_list.clear()
        self.traits_display_list.clear()
        self.rec_class_display_list.clear()
        self.details_widget.setEnabled(False)

    def _add_race(self):
        dialog = RaceDialog(self)
        if dialog.exec() == QDialog.Accepted:
            new_race = dialog.get_race()
            new_race.id = new_race.name
            if not new_race.id: new_race.id = Race.generate_id() # Should be handled by create_new
            self.race_manager.add_race(new_race)
            self._refresh_race_list()
            # Select the new item
            items = self.race_list.findItems(new_race.name, Qt.MatchExactly)
            if items: self.race_list.setCurrentItem(items[0])
            self.race_modified.emit()
            logger.info(f"Added race: {new_race.name}")

    def _edit_race(self):
        if not self.current_race: return

        original_name = self.current_race.name # Store original name

        dialog = RaceDialog(self, self.current_race) # Pass current race (dialog makes copy)
        if dialog.exec() == QDialog.Accepted:
            edited_race = dialog.get_race()

            edited_race.id = edited_race.name
            # Check if the name was changed and if the new name conflicts
            if original_name != edited_race.name:
                if self.race_manager.get_race(edited_race.name):
                    QMessageBox.warning(self, "Duplicate Race", f"A race named '{edited_race.name}' already exists.")
                    return
                # Remove the entry with the old name if name changed
                self.race_manager.remove_race(original_name)

            # Add/Update using the (potentially new) name as the key
            self.race_manager.add_race(edited_race)
            self._refresh_race_list() # Will re-select and update display
            self.race_modified.emit()
            logger.info(f"Edited race: {edited_race.name}")

    def _remove_race(self):
        if not self.current_race: return
        result = QMessageBox.question(self, "Confirm Deletion", f"Delete race '{self.current_race.name}'?", QMessageBox.Yes | QMessageBox.No)
        if result == QMessageBox.Yes:
            removed = self.race_manager.remove_race(self.current_race.name) # Use name
            if removed:
                self._refresh_race_list()
                self.race_modified.emit()
                logger.info(f"Removed race: {self.current_race.name}") # Use name
            else:
                 QMessageBox.critical(self, "Error", "Failed to remove race.")


```

### File: world_configurator\ui\editors\skills_editor.py

```python
# world_configurator/ui/editors/skills_editor.py
"""
Skills editor component for the World Configurator Tool.
"""

import logging
import os
import json
from typing import Dict, List, Optional, Any, Tuple

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QComboBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QDialogButtonBox
)

from ui.dialogs.base_dialog import BaseDialog # Assuming base_dialog.py is in gui.dialogs
from utils.file_manager import get_project_root, load_json, save_json

logger = logging.getLogger("world_configurator.ui.skills_editor")

# Define typical RPG stats and categories for dropdowns
PRIMARY_STATS = ["STRENGTH", "DEXTERITY", "CONSTITUTION", "INTELLIGENCE", "WISDOM", "CHARISMA", "WILLPOWER", "INSIGHT", "NONE"]
SKILL_CATEGORIES = ["COMBAT", "PHYSICAL", "MENTAL", "SOCIAL", "KNOWLEDGE", "EXPLORATION", "COVERT", "UTILITY", "MISCELLANEOUS"]


class SkillEditDialog(BaseDialog):
    """Dialog for adding or editing a skill."""
    def __init__(self, parent: Optional[QWidget] = None, skill_id: Optional[str] = None, skill_data: Optional[Dict[str, Any]] = None):
        super().__init__(parent)
        self.is_new_skill = skill_id is None
        self.skill_id = skill_id if skill_id else ""
        self.skill_data = skill_data if skill_data else {}

        self.setWindowTitle("Add New Skill" if self.is_new_skill else f"Edit Skill: {self.skill_data.get('name', self.skill_id)}")
        self.setMinimumWidth(450)

        layout = QVBoxLayout(self)
        form = QFormLayout()

        self.id_edit = QLineEdit(self.skill_id)
        self.id_edit.setPlaceholderText("Unique skill ID (e.g., stealth_forest)")
        if not self.is_new_skill:
            self.id_edit.setReadOnly(True) # ID cannot be changed once created
        form.addRow("Skill ID:", self.id_edit)

        self.name_edit = QLineEdit(self.skill_data.get("name", ""))
        self.name_edit.setPlaceholderText("Display name (e.g., Forest Stealth)")
        form.addRow("Display Name:", self.name_edit)

        self.primary_stat_combo = QComboBox()
        self.primary_stat_combo.addItems(PRIMARY_STATS)
        current_primary_stat = self.skill_data.get("primary_stat", "NONE")
        if current_primary_stat in PRIMARY_STATS:
            self.primary_stat_combo.setCurrentText(current_primary_stat)
        else:
            self.primary_stat_combo.setCurrentIndex(self.primary_stat_combo.findText("NONE"))
        form.addRow("Primary Stat:", self.primary_stat_combo)

        self.category_combo = QComboBox()
        self.category_combo.addItems(SKILL_CATEGORIES)
        current_category = self.skill_data.get("category", "MISCELLANEOUS")
        if current_category in SKILL_CATEGORIES:
            self.category_combo.setCurrentText(current_category)
        else:
            self.category_combo.setCurrentIndex(self.category_combo.findText("MISCELLANEOUS"))
        form.addRow("Category:", self.category_combo)

        self.description_edit = QTextEdit(self.skill_data.get("description", ""))
        self.description_edit.setPlaceholderText("Detailed description of the skill and its effects.")
        self.description_edit.setMinimumHeight(100)
        form.addRow("Description:", self.description_edit)

        layout.addLayout(form)

        # Buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self._on_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def _on_accept(self):
        if not self.id_edit.text().strip():
            QMessageBox.warning(self, "Missing ID", "Skill ID cannot be empty.")
            return
        if not self.name_edit.text().strip():
            QMessageBox.warning(self, "Missing Name", "Skill Name cannot be empty.")
            return
        self.accept()

    def get_skill_data(self) -> Optional[Tuple[str, Dict[str, Any]]]:
        skill_id = self.id_edit.text().strip()
        skill_details = {
            "name": self.name_edit.text().strip(),
            "primary_stat": self.primary_stat_combo.currentText(),
            "category": self.category_combo.currentText(),
            "description": self.description_edit.toPlainText().strip()
        }
        return skill_id, skill_details


class SkillsEditor(QWidget):
    """Editor for managing skills from skills.json."""
    skills_modified = Signal()

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.skills_data: Dict[str, Dict[str, Any]] = {} # skill_id: {name, desc,...}
        self.current_skill_id: Optional[str] = None
        self.skills_file_path: Optional[str] = None
        self._setup_ui()
        self._load_skills() # Load skills on initialization

    def _get_skills_file_path(self) -> str:
        """Constructs the absolute path to skills.json."""
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        return os.path.join(project_root, "config", "skills.json")

    def _load_skills(self):
        """Load skills from skills.json."""
        self.skills_file_path = self._get_skills_file_path()
        if not os.path.exists(self.skills_file_path):
            logger.warning(f"Skills file not found at {self.skills_file_path}. Creating a default one.")
            self.skills_data = {"skills": {}} # Start with an empty skills dict
            self._save_skills() # Create the file
        else:
            loaded_data = load_json(self.skills_file_path)
            if loaded_data and "skills" in loaded_data and isinstance(loaded_data["skills"], dict):
                self.skills_data = loaded_data["skills"]
            else:
                logger.error(f"Invalid format in skills.json or file is empty. Initializing with empty skills list.")
                self.skills_data = {} # Fallback to empty dict
                # Ensure self.skills_data is a dict for skills, not the root "skills": {} structure
        self._refresh_skill_list()

    def _save_skills(self):
        """Save the current skills data to skills.json."""
        if self.skills_file_path:
            # The data to save should be in the format {"skills": {skill_id: data, ...}}
            data_to_save = {"skills": self.skills_data}
            if save_json(data_to_save, self.skills_file_path):
                logger.info(f"Skills saved to {self.skills_file_path}")
                self.skills_modified.emit()
            else:
                QMessageBox.critical(self, "Save Error", f"Failed to save skills to {self.skills_file_path}")
        else:
            QMessageBox.critical(self, "Save Error", "Skills file path is not set. Cannot save.")


    def _setup_ui(self):
        main_layout = QHBoxLayout(self)
        splitter = QSplitter(Qt.Horizontal)

        # Left panel: Skill list
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.addWidget(QLabel("Skills List"))
        self.skill_list_widget = QListWidget()
        self.skill_list_widget.currentItemChanged.connect(self._on_skill_selected)
        left_layout.addWidget(self.skill_list_widget)
        list_buttons_layout = QHBoxLayout()
        self.add_skill_button = QPushButton("Add Skill")
        self.add_skill_button.clicked.connect(self._add_skill)
        list_buttons_layout.addWidget(self.add_skill_button)
        self.remove_skill_button = QPushButton("Remove Skill")
        self.remove_skill_button.clicked.connect(self._remove_skill)
        self.remove_skill_button.setEnabled(False)
        list_buttons_layout.addWidget(self.remove_skill_button)
        left_layout.addLayout(list_buttons_layout)
        splitter.addWidget(left_panel)

        # Right panel: Skill details
        right_panel_scroll = QScrollArea()
        right_panel_scroll.setWidgetResizable(True)
        right_panel_scroll.setFrameShape(QFrame.NoFrame)
        details_widget = QWidget()
        right_panel_scroll.setWidget(details_widget)
        self.details_layout = QFormLayout(details_widget)
        self.details_layout.setContentsMargins(10, 10, 10, 10)

        self.skill_id_label = QLabel()
        self.details_layout.addRow("Skill ID:", self.skill_id_label)
        self.skill_name_label = QLabel()
        self.details_layout.addRow("Name:", self.skill_name_label)
        self.primary_stat_label = QLabel()
        self.details_layout.addRow("Primary Stat:", self.primary_stat_label)
        self.category_label = QLabel()
        self.details_layout.addRow("Category:", self.category_label)
        self.description_text = QTextEdit()
        self.description_text.setReadOnly(True)
        self.description_text.setMinimumHeight(100)
        self.details_layout.addRow("Description:", self.description_text)

        self.edit_skill_button = QPushButton("Edit Selected Skill")
        self.edit_skill_button.clicked.connect(self._edit_skill)
        self.edit_skill_button.setEnabled(False)
        self.details_layout.addRow(self.edit_skill_button)

        details_widget.setLayout(self.details_layout)
        splitter.addWidget(right_panel_scroll)
        splitter.setSizes([250, 550])
        main_layout.addWidget(splitter)

        self._disable_details_view()

    def _refresh_skill_list(self):
        self.skill_list_widget.clear()
        # Sort skills by name for display
        sorted_skill_ids = sorted(self.skills_data.keys(), key=lambda skill_id: self.skills_data[skill_id].get("name", skill_id))
        for skill_id in sorted_skill_ids:
            skill_entry = self.skills_data.get(skill_id, {})
            display_name = skill_entry.get("name", skill_id) # Fallback to ID if name is missing
            item = QListWidgetItem(f"{display_name} ({skill_id})")
            item.setData(Qt.UserRole, skill_id)
            self.skill_list_widget.addItem(item)
        self.remove_skill_button.setEnabled(False)
        self.edit_skill_button.setEnabled(False)

    def _on_skill_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]):
        if current:
            self.current_skill_id = current.data(Qt.UserRole)
            skill_data = self.skills_data.get(self.current_skill_id)
            if skill_data:
                self._populate_details_view(skill_data)
                self.remove_skill_button.setEnabled(True)
                self.edit_skill_button.setEnabled(True)
            else:
                self._disable_details_view()
        else:
            self.current_skill_id = None
            self._disable_details_view()
            self.remove_skill_button.setEnabled(False)
            self.edit_skill_button.setEnabled(False)

    def _populate_details_view(self, skill_data: Dict[str, Any]):
        self.skill_id_label.setText(self.current_skill_id or "N/A")
        self.skill_name_label.setText(skill_data.get("name", "N/A"))
        self.primary_stat_label.setText(skill_data.get("primary_stat", "N/A"))
        self.category_label.setText(skill_data.get("category", "N/A"))
        self.description_text.setPlainText(skill_data.get("description", "N/A"))

    def _disable_details_view(self):
        self.skill_id_label.setText("N/A")
        self.skill_name_label.setText("N/A")
        self.primary_stat_label.setText("N/A")
        self.category_label.setText("N/A")
        self.description_text.setPlainText("Select a skill to view details.")
        self.edit_skill_button.setEnabled(False)

    def _add_skill(self):
        dialog = SkillEditDialog(self)
        if dialog.exec() == QDialog.Accepted:
            skill_id, skill_data = dialog.get_skill_data()
            if skill_id in self.skills_data:
                QMessageBox.warning(self, "Duplicate ID", f"Skill ID '{skill_id}' already exists.")
                return
            self.skills_data[skill_id] = skill_data
            self._save_skills()
            self._refresh_skill_list()
            # Try to select the newly added skill
            for i in range(self.skill_list_widget.count()):
                if self.skill_list_widget.item(i).data(Qt.UserRole) == skill_id:
                    self.skill_list_widget.setCurrentRow(i)
                    break

    def _edit_skill(self):
        if not self.current_skill_id or self.current_skill_id not in self.skills_data:
            return
        current_data = self.skills_data[self.current_skill_id]
        dialog = SkillEditDialog(self, skill_id=self.current_skill_id, skill_data=current_data)
        if dialog.exec() == QDialog.Accepted:
            _, updated_skill_data = dialog.get_skill_data() # ID cannot change
            self.skills_data[self.current_skill_id] = updated_skill_data
            self._save_skills()
            self._refresh_skill_list()
             # Re-select the edited skill
            for i in range(self.skill_list_widget.count()):
                if self.skill_list_widget.item(i).data(Qt.UserRole) == self.current_skill_id:
                    self.skill_list_widget.setCurrentRow(i)
                    break


    def _remove_skill(self):
        if not self.current_skill_id or self.current_skill_id not in self.skills_data:
            return
        skill_name = self.skills_data[self.current_skill_id].get("name", self.current_skill_id)
        reply = QMessageBox.question(self, "Remove Skill",
                                     f"Are you sure you want to remove '{skill_name}'?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            del self.skills_data[self.current_skill_id]
            self._save_skills()
            self._refresh_skill_list()
            self._disable_details_view() # Clear details after deletion

    def refresh_data(self):
        """Public method to reload skills, e.g., if file changed externally."""
        self._load_skills()
```

### File: world_configurator\ui\editors\SpecificItemEditor.py

```python
# world_configurator/ui/editors/specific_item_editor.py
"""
Editor for a specific category of items (e.g., origin_items.json).
"""

import logging
import os
import json
from typing import Dict, List, Optional, Any, Union

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (QDialogButtonBox,
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QComboBox,
    QDialog, QMessageBox, QSplitter, QScrollArea, QFrame, QCheckBox,
    QDoubleSpinBox, QSpinBox, QTableWidget, QTableWidgetItem, QHeaderView,
    QInputDialog
)
# Safe import of core stats enums even when world_configurator runs standalone
try:
    from core.stats.stats_base import StatType, DerivedStatType
except ModuleNotFoundError:
    import sys
    try:
        # Use helper to get project root if available
        from utils.file_manager import get_project_root as _wcfg_get_root
        _pr = _wcfg_get_root()
    except Exception:
        _pr = None
    if not _pr:
        import os as _os
        # Compute project root relative to this file: .../latest version
        _pr = _os.path.normpath(_os.path.join(_os.path.dirname(_os.path.abspath(__file__)), '..', '..', '..'))
    if _pr and _pr not in sys.path:
        sys.path.insert(0, _pr)
    from core.stats.stats_base import StatType, DerivedStatType

from ui.dialogs.base_dialog import BaseDialog
from ui.widgets.typed_resistances_editor import TypedResistancesEditor
from ui.widgets.multiselect_combo import MultiSelectCombo
from utils.file_manager import load_json, save_json, get_project_root

logger = logging.getLogger("world_configurator.ui.specific_item_editor")

# --- Stat Entry Dialog (for item stats) ---
class ItemStatDialog(BaseDialog):
    """Dialog for adding/editing an item stat with validated choices."""
    def __init__(self, parent=None, stat_data: Optional[Dict[str, Any]] = None):
        super().__init__(parent)
        self.setWindowTitle("Edit Item Stat")
        self.stat_data = stat_data if stat_data else {}

        layout = QFormLayout(self)

        # Build validated stat choices from core enums
        self._stat_choices: List[Dict[str, str]] = []  # {'id': 'strength', 'display': 'Strength (STR)', 'category': 'Primary'}
        # Primary stats
        for s in StatType:
            stat_id = s.name.lower()  # e.g., 'strength'
            friendly = s.name.title()  # 'Strength'
            shown = f"[Primary] {friendly} ({str(s)})"  # 'STR' as value
            self._stat_choices.append({'id': stat_id, 'display': shown, 'category': 'Primary'})
        # Derived stats
        for d in DerivedStatType:
            stat_id = d.name.lower()  # e.g., 'melee_attack'
            shown = f"[Derived] {str(d)}"  # str(d) is human-friendly like 'Melee Attack'
            self._stat_choices.append({'id': stat_id, 'display': shown, 'category': 'Derived'})

        # Stat selector
        self.stat_combo = QComboBox()
        for opt in self._stat_choices:
            self.stat_combo.addItem(opt['display'], userData=opt['id'])

        # Preselect if editing existing
        existing_name = str(self.stat_data.get("name", "")).strip()
        selected_index = -1
        if existing_name:
            # Normalize existing to canonical id using enums
            canonical = None
            try:
                st = StatType.from_string(existing_name)
                canonical = st.name.lower()
            except Exception:
                try:
                    dt = DerivedStatType.from_string(existing_name)
                    canonical = dt.name.lower()
                except Exception:
                    # Fallback: attempt lower/underscore
                    canonical = existing_name.lower().replace(' ', '_')
            for i in range(self.stat_combo.count()):
                if self.stat_combo.itemData(i) == canonical:
                    selected_index = i
                    break
        if selected_index >= 0:
            self.stat_combo.setCurrentIndex(selected_index)
        else:
            self.stat_combo.setCurrentIndex(0)

        self.value_edit = QLineEdit(str(self.stat_data.get("value", "0")))  # keep text edit for flexible input
        self.value_edit.setPlaceholderText("Value (numeric or boolean)")

        # Default display name suggestion based on selected stat
        suggested_display = self._suggest_display_name(self.stat_combo.currentData())
        self.display_name_edit = QLineEdit(self.stat_data.get("display_name", suggested_display))
        self.display_name_edit.setPlaceholderText("Auto display name for selected stat")
        # Lock display name to canonical stat name to avoid typos
        try:
            self.display_name_edit.setReadOnly(True)
        except Exception:
            pass
        self.is_percentage_check = QCheckBox("Is Percentage?")
        self.is_percentage_check.setChecked(self.stat_data.get("is_percentage", False))

        # Always update display name to match current selection
        def _on_stat_changed():
            self.display_name_edit.setText(self._suggest_display_name(self.stat_combo.currentData()))
        self.stat_combo.currentIndexChanged.connect(_on_stat_changed)
        # Ensure initial sync
        _on_stat_changed()

        layout.addRow("Stat:", self.stat_combo)
        layout.addRow("Value:", self.value_edit)
        layout.addRow("Display Name:", self.display_name_edit)
        layout.addRow(self.is_percentage_check)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

    def _suggest_display_name(self, stat_id: Optional[str]) -> str:
        if not stat_id:
            return ""
        # For primary stats, use Title case of enum name; for derived, use enum value (human-friendly)
        try:
            st = StatType[stat_id.upper()]
            return st.name.title()
        except Exception:
            try:
                dt = DerivedStatType[stat_id.upper()]
                return str(dt)
            except Exception:
                # Fallback: prettify
                return stat_id.replace('_', ' ').title()

    def get_stat_data(self) -> Optional[Dict[str, Any]]:
        name = self.stat_combo.currentData()
        value_str = self.value_edit.text().strip()
        display_name = self.display_name_edit.text().strip()
        is_percentage = self.is_percentage_check.isChecked()

        if not name or not value_str:
            QMessageBox.warning(self, "Input Error", "Stat and Value are required.")
            return None

        # Attempt to parse value as float, int, or bool
        parsed_value: Any
        try:
            if '.' in value_str:
                parsed_value = float(value_str)
            else:
                parsed_value = int(value_str)
        except ValueError:
            if value_str.lower() == 'true':
                parsed_value = True
            elif value_str.lower() == 'false':
                parsed_value = False
            else:
                parsed_value = value_str

        data = {"name": name, "value": parsed_value}
        if display_name:
            data["display_name"] = display_name
        if is_percentage:
            data["is_percentage"] = True
        return data

    def get_stat_data(self) -> Optional[Dict[str, Any]]:
        name = self.name_edit.text().strip()
        value_str = self.value_edit.text().strip()
        display_name = self.display_name_edit.text().strip()
        is_percentage = self.is_percentage_check.isChecked()

        if not name or not value_str:
            QMessageBox.warning(self, "Input Error", "Stat ID and Value are required.")
            return None

        # Attempt to parse value as float, int, or bool
        parsed_value: Any
        try:
            if '.' in value_str:
                parsed_value = float(value_str)
            else:
                parsed_value = int(value_str)
        except ValueError:
            if value_str.lower() == 'true':
                parsed_value = True
            elif value_str.lower() == 'false':
                parsed_value = False
            else: # Treat as string if not parsable as number/bool
                parsed_value = value_str


        data = {"name": name, "value": parsed_value}
        if display_name:
            data["display_name"] = display_name
        if is_percentage:
            data["is_percentage"] = True
        return data

# --- Dice Roll Effect Dialog ---
class DiceRollEffectDialog(BaseDialog):
    """Dialog for adding/editing a dice roll effect with constrained dice notation."""
    def __init__(self, parent=None, effect_data: Optional[Dict[str, str]] = None, effect_types: Optional[List[str]] = None):
        super().__init__(parent)
        self.setWindowTitle("Edit Dice Roll Effect")
        self.effect_data = effect_data if effect_data else {}
        self._effect_types = effect_types or [
            "slashing","piercing","bludgeoning","fire","cold","lightning","poison","acid","arcane"
        ]

        layout = QFormLayout(self)
        # Effect type dropdown
        self.effect_type_combo = QComboBox()
        for et in self._effect_types:
            self.effect_type_combo.addItem(et)
        # Preselect existing if provided
        existing_et = str(self.effect_data.get("effect_type", "")).strip().lower()
        if existing_et:
            idx = self.effect_type_combo.findText(existing_et)
            if idx >= 0:
                self.effect_type_combo.setCurrentIndex(idx)

        # Dice notation builder: base NdS from dropdown + optional modifier
        self.dice_base_combo = QComboBox()
        base_notations: List[str] = []
        for n in (1, 2, 3, 4):
            for s in (4, 6, 8, 10, 12, 20):
                base_notations.append(f"{n}d{s}")
        for bn in base_notations:
            self.dice_base_combo.addItem(bn)
        # Modifier
        self.mod_sign_combo = QComboBox(); self.mod_sign_combo.addItems(["+", "-"])
        self.mod_value_spin = QSpinBox(); self.mod_value_spin.setRange(0, 100); self.mod_value_spin.setValue(0)
        self.mod_value_spin.setSpecialValueText("0")
        # Preselect from existing notation if provided
        import re
        existing_dn = str(self.effect_data.get("dice_notation", "")).strip().lower()
        m = re.match(r"(\d+d\d+)([+\-])(\d+)$", existing_dn)
        if m:
            base, sign, mv = m.group(1), m.group(2), int(m.group(3))
            idx = self.dice_base_combo.findText(base)
            if idx >= 0:
                self.dice_base_combo.setCurrentIndex(idx)
            self.mod_sign_combo.setCurrentText(sign)
            self.mod_value_spin.setValue(mv)
        elif existing_dn:
            idx = self.dice_base_combo.findText(existing_dn)
            if idx >= 0:
                self.dice_base_combo.setCurrentIndex(idx)

        self.description_edit = QLineEdit(self.effect_data.get("description", ""))
        self.description_edit.setPlaceholderText("Optional description of the effect")

        layout.addRow("Effect Type:", self.effect_type_combo)
        layout.addRow("Dice Base (NdS):", self.dice_base_combo)
        layout.addRow("Modifier Sign:", self.mod_sign_combo)
        layout.addRow("Modifier Value:", self.mod_value_spin)
        layout.addRow("Description:", self.description_edit)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

    def get_effect_data(self) -> Optional[Dict[str, str]]:
        effect_type = self.effect_type_combo.currentText().strip()
        base = self.dice_base_combo.currentText().strip()
        sign = self.mod_sign_combo.currentText().strip()
        mv = int(self.mod_value_spin.value())
        description = self.description_edit.text().strip()

        dice_notation = base if mv == 0 else f"{base}{sign}{mv}"

        if not effect_type or not dice_notation:
            QMessageBox.warning(self, "Input Error", "Effect Type and Dice Notation are required.")
            return None
        return {"effect_type": effect_type, "dice_notation": dice_notation, "description": description}


class SpecificItemEditor(QWidget):
    """
    Editor for a list of items from a specific JSON file.
    """
    data_modified = Signal()

    def __init__(self, item_file_key: str, item_file_path_relative: str, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.item_file_key = item_file_key # e.g., "Starting Items"
        self.item_file_path_relative = item_file_path_relative
        self.items_data: List[Dict[str, Any]] = [] # List of item dictionaries
        self.current_item_index: Optional[int] = None
        # When True, save_data() will not pull values from the current UI form before saving.
        # This is used for programmatic updates (e.g., assistant patches) to avoid overwriting
        # freshly-applied data with stale UI values.
        self._programmatic_save_in_progress: bool = False

        self.project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
        self.full_item_file_path = os.path.join(self.project_root, self.item_file_path_relative)

        # Load effect types from combat config BEFORE building UI so widgets can use them
        try:
            combat_cfg_path = os.path.join(self.project_root, "config", "combat", "combat_config.json")
            combat_cfg = load_json(combat_cfg_path) or {}
            dmg = combat_cfg.get("damage", {}) if isinstance(combat_cfg, dict) else {}
            ets = dmg.get("types", []) if isinstance(dmg, dict) else []
            if isinstance(ets, list) and ets:
                self._effect_types: List[str] = [str(x).strip().lower() for x in ets if isinstance(x, str)]
            else:
                self._effect_types = ["slashing","piercing","bludgeoning","fire","cold","lightning","poison","acid","arcane"]
        except Exception:
            self._effect_types = ["slashing","piercing","bludgeoning","fire","cold","lightning","poison","acid","arcane"]

        self._setup_ui()
        
        self.load_data()

    # ===== Assistant integration (provider methods) =====
    def get_assistant_context(self):
        """Provide selection context for the assistant."""
        try:
            from assistant.context import AssistantContext
        except Exception:
            # Lazy import path fallback if packaging differs
            from ..assistant.context import AssistantContext  # type: ignore
        item = self._current_item_dict()
        allowed = [
            "/name",
            "/description",
            "/item_type",
            "/rarity",
            "/weight",
            "/value",
            "/is_equippable",
            "/is_consumable",
            "/is_stackable",
            "/is_quest_item",
            "/equip_slots",
            "/stack_limit",
            "/durability",
            "/current_durability",
            "/stats",
            "/dice_roll_effects",
            "/tags",
            "/custom_properties",
        ]
        selection_id = (item.get("id") if isinstance(item, dict) else None)
        return AssistantContext(
            domain=f"items:{self.item_file_key}",
            selection_id=selection_id,
            content=item if isinstance(item, dict) else None,
            schema=None,
            allowed_paths=allowed,
        )

    def get_reference_catalogs(self) -> Dict[str, Any]:
        """Return minimal catalogs and constraints to ground LLM responses."""
        try:
            item_types = ["armor","weapon","shield","accessory","consumable","tool","container","document","key","material","treasure","miscellaneous"]
            rarities = ["common","uncommon","rare","epic","legendary","quest"]
            equip_slots = [
                "main_hand","off_hand","two_hand","head","chest","legs","hands","feet",
                "neck","ring","belt","cloak","quiver","pouch"
            ]
            primary_stats = [s.name.lower() for s in StatType]
            derived_stats = [d.name.lower() for d in DerivedStatType]
            names = sorted({i.get("name","") for i in self.items_data if isinstance(i, dict) and i.get("name")})
            ids = sorted({i.get("id","") for i in self.items_data if isinstance(i, dict) and i.get("id")})
            return {
                "constraints": {
                    "item_types": item_types,
                    "rarities": rarities,
                    "equip_slots": equip_slots,
                    "stat_ids_primary": primary_stats,
                    "stat_ids_derived": derived_stats,
                },
                "effect_types": getattr(self, "_effect_types", []),
                "typed_resistances": {
                    "allowed_types": getattr(self, "_effect_types", []),
                    "percent_range": [-100, 100],
                    "omit_zero": True
                },
                "existing_names": names,
                "existing_ids": ids,
            }
        except Exception:
            return {}

    def apply_assistant_patch(self, patch_ops):
        """Apply RFC6902 patch ops to the current selection, with validation and sanitization."""
        try:
            from assistant.patching import apply_patch_with_validation
        except Exception:
            from ..assistant.patching import apply_patch_with_validation  # type: ignore
        ctx = self.get_assistant_context()
        if not ctx.content or self.current_item_index is None:
            return False, "No item selected."
        ok, msg, new_content = apply_patch_with_validation(ctx, ctx.content, patch_ops)
        if not ok:
            return False, msg
        try:
            sanitized = self._sanitize_item_payload(new_content)
            self._replace_current_item(sanitized)
            # Update UI first so form reflects patched values
            self._populate_details_from_item_data(sanitized)
            # Persist without pulling values back from the (previous) UI state
            self._programmatic_save_in_progress = True
            try:
                self.save_data()
            finally:
                self._programmatic_save_in_progress = False
            return True, "OK"
        except Exception as e:
            logger.error("Failed to apply assistant patch: %s", e, exc_info=True)
            return False, f"Failed to apply: {e}"

    def create_entry_from_llm(self, entry: dict):
        """Create a new item from LLM proposal, ensuring uniqueness and sanitization."""
        try:
            payload = self._sanitize_item_payload(entry, for_create=True)
            proposed_id = payload.get("id") or self._generate_id_from_name(payload.get("name", "New Item"))
            new_id = self._ensure_unique_id(proposed_id)
            new_name = self._ensure_unique_name(payload.get("name") or "New Item")
            payload["id"] = new_id
            payload["name"] = new_name
            self.items_data.append(payload)
            if not self.save_data():
                return False, "Failed to save", None
            self._refresh_item_list_widget()
            self._select_item_by_id(new_id)
            return True, "Created", new_id
        except Exception as e:
            logger.error("Failed to create entry from LLM: %s", e, exc_info=True)
            return False, f"Failed to create: {e}", None

    # ===== Search helpers for targeted visibility =====
    def search_for_entries(self, term: str, limit: int = 10) -> List[tuple]:
        """Fuzzy-match items by id/name/tags and return list of (id, name, score)."""
        import difflib, unicodedata
        def _norm(s: str) -> str:
            try:
                s2 = unicodedata.normalize("NFKD", s or "").encode("ascii", "ignore").decode("ascii")
            except Exception:
                s2 = s or ""
            return s2.lower()
        q = _norm(term)
        results: List[tuple] = []
        for it in self.items_data:
            if not isinstance(it, dict):
                continue
            iid = str(it.get("id", ""))
            nm = str(it.get("name", ""))
            tags = ",".join(it.get("tags", [])) if isinstance(it.get("tags"), list) else ""
            hay = " | ".join([iid, nm, tags])
            score = difflib.SequenceMatcher(None, q, _norm(hay)).ratio()
            if score >= 0.4:
                results.append((iid, nm or iid, float(score)))
        results.sort(key=lambda t: (-t[2], t[1], t[0]))
        return results[:limit]

    def focus_entry(self, item_id: str) -> bool:
        """Focus/select the item with given id in the UI and internal state."""
        try:
            # update current index to item id's index in items_data
            idx = None
            for i, it in enumerate(self.items_data):
                if isinstance(it, dict) and it.get("id") == item_id:
                    idx = i
                    break
            if idx is None:
                return False
            self.current_item_index = idx
            # refresh list to ensure rows/indices align, then select by id
            self._refresh_item_list_widget()
            self._select_item_by_id(item_id)
            return True
        except Exception:
            return False

    # ===== Internal helpers =====
    def _current_item_dict(self) -> Optional[Dict[str, Any]]:
        if self.current_item_index is None:
            return None
        if 0 <= self.current_item_index < len(self.items_data):
            it = self.items_data[self.current_item_index]
            return it if isinstance(it, dict) else None
        return None

    def _replace_current_item(self, new_dict: Dict[str, Any]) -> None:
        if self.current_item_index is None:
            return
        if 0 <= self.current_item_index < len(self.items_data):
            self.items_data[self.current_item_index] = new_dict

    def _select_item_by_id(self, item_id: str) -> None:
        # Find new index and select in list widget
        target_index = None
        for i, it in enumerate(self.items_data):
            if isinstance(it, dict) and it.get("id") == item_id:
                target_index = i
                break
        if target_index is None:
            return
        # Find the row in the QListWidget whose UserRole matches target_index
        for row in range(self.item_list_widget.count()):
            it = self.item_list_widget.item(row)
            if it and it.data(Qt.UserRole) == target_index:
                self.item_list_widget.setCurrentRow(row)
                break

    def _ensure_unique_id(self, proposed_id: str) -> str:
        existing = {str(it.get("id")) for it in self.items_data if isinstance(it, dict) and it.get("id")}
        pid = (proposed_id or "item").strip()
        if pid not in existing:
            return pid
        base = pid
        suffix = 2
        nid = f"{base}_{suffix}"
        while nid in existing:
            suffix += 1
            nid = f"{base}_{suffix}"
        return nid

    def _ensure_unique_name(self, proposed_name: str) -> str:
        existing = {str(it.get("name")) for it in self.items_data if isinstance(it, dict) and it.get("name")}
        name = (proposed_name or "New Item").strip()
        if name not in existing:
            return name
        base = name
        suffix = 2
        nn = f"{base} ({suffix})"
        while nn in existing:
            suffix += 1
            nn = f"{base} ({suffix})"
        return nn

    def _generate_id_from_name(self, name: str) -> str:
        import re
        slug = re.sub(r"[^a-zA-Z0-9]+", "_", (name or "item").strip().lower()).strip("_")
        if not slug:
            slug = "item"
        return slug

    def _sanitize_item_payload(self, payload: Dict[str, Any], for_create: bool = False) -> Dict[str, Any]:
        """Normalize and validate item payload before persisting."""
        out: Dict[str, Any] = dict(payload or {})
        def as_float(x, default=0.0):
            try:
                return float(x)
            except Exception:
                return default
        def as_int(x, default=0):
            try:
                return int(x)
            except Exception:
                return default
        def as_bool(x):
            if isinstance(x, bool):
                return x
            s = str(x).strip().lower()
            return s in ("1","true","yes","y","on")
        def as_list_str(v):
            vals: List[str] = []
            if isinstance(v, list):
                for el in v:
                    if isinstance(el, str) and el.strip():
                        vals.append(el.strip())
                    elif isinstance(el, dict):
                        vid = el.get("id")
                        if isinstance(vid, str) and vid.strip():
                            vals.append(vid.strip())
            # dedupe preserve order
            seen = set(); res: List[str] = []
            for s in vals:
                if s not in seen:
                    seen.add(s)
                    res.append(s)
            return res

        if for_create:
            out["name"] = (out.get("name") or "New Item").strip()
            out["item_type"] = str(out.get("item_type") or "miscellaneous").lower()
            out["rarity"] = str(out.get("rarity") or "common").lower()

        # Scalars
        if "name" in out: out["name"] = str(out["name"]).strip()
        if "description" in out: out["description"] = str(out["description"]).strip()
        if "item_type" in out: out["item_type"] = str(out["item_type"]).lower()
        if "rarity" in out: out["rarity"] = str(out["rarity"]).lower()
        if "weight" in out: out["weight"] = max(0.0, as_float(out["weight"]))
        if "value" in out: out["value"] = max(0, as_int(out["value"]))
        for k in ("is_equippable","is_consumable","is_stackable","is_quest_item"):
            if k in out: out[k] = as_bool(out[k])

        # Equip slots and tags
        if "equip_slots" in out: out["equip_slots"] = as_list_str(out["equip_slots"]) or out.pop("equip_slots", None) or []
        if "tags" in out: out["tags"] = as_list_str(out["tags"]) or out.pop("tags", None) or []

        # Stack/durability
        if out.get("is_stackable"):
            out["stack_limit"] = max(1, as_int(out.get("stack_limit", 1), 1))
        else:
            out.pop("stack_limit", None)
        if "durability" in out:
            out["durability"] = max(0, as_int(out["durability"]))
        # Templates should not carry current_durability
        out.pop("current_durability", None)

        # Stats normalization
        stats = out.get("stats")
        if isinstance(stats, list):
            norm_stats: List[Dict[str, Any]] = []
            valid_names = {s.name.lower() for s in StatType} | {d.name.lower() for d in DerivedStatType}
            for st in stats:
                if not isinstance(st, dict):
                    continue
                name = str(st.get("name", "")).lower().replace(" ", "_")
                if name not in valid_names:
                    continue
                val = st.get("value")
                # parse numeric/bool if string
                if isinstance(val, str):
                    vstr = val.strip()
                    try:
                        val = float(vstr) if "." in vstr else int(vstr)
                    except Exception:
                        if vstr.lower() in ("true","false"):
                            val = (vstr.lower() == "true")
                entry = {"name": name, "value": val}
                if st.get("display_name"): entry["display_name"] = str(st["display_name"]).strip()
                if st.get("is_percentage"): entry["is_percentage"] = bool(st["is_percentage"])
                norm_stats.append(entry)
            out["stats"] = norm_stats

        # Dice roll effects
        dre = out.get("dice_roll_effects")
        if isinstance(dre, list):
            norm_dre: List[Dict[str, Any]] = []
            for e in dre:
                if not isinstance(e, dict):
                    continue
                et = str(e.get("effect_type", "")).strip()
                dn = str(e.get("dice_notation", "")).strip()
                if not et or not dn:
                    continue
                entry = {"effect_type": et, "dice_notation": dn}
                if e.get("description"): entry["description"] = str(e["description"]).strip()
                norm_dre.append(entry)
            out["dice_roll_effects"] = norm_dre

        # Custom properties must be a dict if present
        if "custom_properties" in out and not isinstance(out["custom_properties"], dict):
            out.pop("custom_properties", None)
        # Normalize typed_resistances under custom_properties (LLM/create/patch path)
        if isinstance(out.get("custom_properties"), dict):
            cp = dict(out.get("custom_properties") or {})
            tr = cp.get("typed_resistances")
            if isinstance(tr, dict):
                allowed = set(getattr(self, "_effect_types", []) or [])
                norm: Dict[str, int] = {}
                for k, v in tr.items():
                    try:
                        key = str(k).strip().lower()
                        if key and (not allowed or key in allowed):
                            vi = int(float(v))
                            if vi != 0:
                                if vi < -100: vi = -100
                                if vi > 100: vi = 100
                                norm[key] = vi
                    except Exception:
                        continue
                if norm:
                    cp["typed_resistances"] = norm
                else:
                    cp.pop("typed_resistances", None)
                # write back
                out["custom_properties"] = cp if cp else out.pop("custom_properties", None) or {}
            # Drop empty custom_properties entirely
            if isinstance(out.get("custom_properties"), dict) and not out["custom_properties"]:
                out.pop("custom_properties", None)

        # Clamp enums
        if out.get("item_type") not in {"armor","weapon","shield","accessory","consumable","tool","container","document","key","material","treasure","miscellaneous"}:
            out["item_type"] = "miscellaneous"
        if out.get("rarity") not in {"common","uncommon","rare","epic","legendary","quest"}:
            out["rarity"] = "common"

        return out

    def _setup_ui(self):
        main_layout = QHBoxLayout(self)
        splitter = QSplitter(Qt.Horizontal)

        # Left Panel: Item List
        left_panel = QFrame()
        left_panel.setFrameShape(QFrame.StyledPanel)
        left_layout = QVBoxLayout(left_panel)
        left_layout.addWidget(QLabel(f"{self.item_file_key} List"))
        self.item_list_widget = QListWidget()
        self.item_list_widget.currentItemChanged.connect(self._on_item_selected)
        left_layout.addWidget(self.item_list_widget)
        list_buttons_layout = QHBoxLayout()
        self.add_item_button = QPushButton("Add Item")
        self.add_item_button.clicked.connect(self._add_item)
        list_buttons_layout.addWidget(self.add_item_button)
        self.remove_item_button = QPushButton("Remove Item")
        self.remove_item_button.clicked.connect(self._remove_item)
        self.remove_item_button.setEnabled(False)
        list_buttons_layout.addWidget(self.remove_item_button)
        left_layout.addLayout(list_buttons_layout)
        splitter.addWidget(left_panel)

        # Right Panel: Item Details Editor
        right_panel_scroll = QScrollArea()
        right_panel_scroll.setWidgetResizable(True)
        details_widget_container = QWidget() # Container for the form layout
        right_panel_scroll.setWidget(details_widget_container)

        self.details_form_layout = QFormLayout()
        self.details_form_layout.setContentsMargins(10,10,10,10)
        details_widget_container.setLayout(self.details_form_layout) # Set layout on container


        # Common Fields (ID, Name, Description, Item Type, Rarity, Weight, Value)
        self.id_edit = QLineEdit()
        self.id_edit.setPlaceholderText("Unique item ID")
        self.details_form_layout.addRow("ID*:", self.id_edit)

        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Display name of the item")
        self.details_form_layout.addRow("Name*:", self.name_edit)

        self.description_edit = QTextEdit()
        self.description_edit.setPlaceholderText("Detailed description")
        self.description_edit.setFixedHeight(80)
        self.details_form_layout.addRow("Description:", self.description_edit)

        self.item_type_combo = QComboBox()
        item_types = ["armor", "weapon", "shield", "accessory", "consumable", "tool", "container", "document", "key", "material", "treasure", "miscellaneous"]
        self.item_type_combo.addItems(sorted(item_types))
        self.details_form_layout.addRow("Item Type:", self.item_type_combo)

        self.rarity_combo = QComboBox()
        rarities = ["common", "uncommon", "rare", "epic", "legendary", "quest"]
        self.rarity_combo.addItems(sorted(rarities))
        self.details_form_layout.addRow("Rarity:", self.rarity_combo)

        self.weight_spin = QDoubleSpinBox()
        self.weight_spin.setRange(0.0, 1000.0); self.weight_spin.setDecimals(2); self.weight_spin.setSingleStep(0.1)
        self.details_form_layout.addRow("Weight:", self.weight_spin)

        self.value_spin = QSpinBox()
        self.value_spin.setRange(0, 1000000); self.value_spin.setSingleStep(10)
        self.details_form_layout.addRow("Value (base copper):", self.value_spin)

        # Boolean Flags
        flags_layout = QHBoxLayout()
        self.is_equippable_check = QCheckBox("Equippable")
        self.is_consumable_check = QCheckBox("Consumable")
        self.is_stackable_check = QCheckBox("Stackable")
        self.is_quest_item_check = QCheckBox("Quest Item")
        flags_layout.addWidget(self.is_equippable_check)
        flags_layout.addWidget(self.is_consumable_check)
        flags_layout.addWidget(self.is_stackable_check)
        flags_layout.addWidget(self.is_quest_item_check)
        self.details_form_layout.addRow("Flags:", flags_layout)

        # Conditional Fields
        # Equip Slots: multi-select dropdown
        self.equip_slots_combo = MultiSelectCombo()
        # Allowed slots (align with references in get_reference_catalogs)
        _equip_slot_opts = [
            "main_hand","off_hand","two_hand","head","chest","legs","hands","feet",
            "neck","ring","belt","cloak","quiver","pouch"
        ]
        self.equip_slots_combo.set_options(_equip_slot_opts)
        self.details_form_layout.addRow("Equip Slots:", self.equip_slots_combo)

        self.stack_limit_spin = QSpinBox()
        self.stack_limit_spin.setRange(1, 9999)
        self.details_form_layout.addRow("Stack Limit:", self.stack_limit_spin)

        self.durability_spin = QSpinBox()
        self.durability_spin.setRange(0, 1000)
        self.details_form_layout.addRow("Durability (Max):", self.durability_spin)

        # Current Durability removed for templates (instances track this at runtime)


        # Stats Table
        self.details_form_layout.addRow(QLabel("<b>Item Stats:</b>"))
        self.stats_table = QTableWidget(0, 3)
        self.stats_table.setHorizontalHeaderLabels(["Stat ID", "Value", "Display Name"])
        self.stats_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.stats_table.setFixedHeight(100)
        self.details_form_layout.addRow(self.stats_table)
        stats_buttons_layout = QHBoxLayout()
        self.add_stat_button = QPushButton("Add Stat")
        self.add_stat_button.clicked.connect(self._add_item_stat)
        stats_buttons_layout.addWidget(self.add_stat_button)
        self.remove_stat_button = QPushButton("Remove Stat")
        self.remove_stat_button.clicked.connect(self._remove_item_stat)
        stats_buttons_layout.addWidget(self.remove_stat_button)
        self.details_form_layout.addRow(stats_buttons_layout)

        # Dice Roll Effects Table (for weapons primarily)
        self.details_form_layout.addRow(QLabel("<b>Dice Roll Effects:</b>"))
        self.dice_effects_table = QTableWidget(0, 3)
        self.dice_effects_table.setHorizontalHeaderLabels(["Effect Type", "Dice Notation", "Description"])
        self.dice_effects_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.dice_effects_table.setFixedHeight(100)
        self.details_form_layout.addRow(self.dice_effects_table)
        dice_buttons_layout = QHBoxLayout()
        self.add_dice_effect_button = QPushButton("Add Dice Effect")
        self.add_dice_effect_button.clicked.connect(self._add_dice_effect)
        dice_buttons_layout.addWidget(self.add_dice_effect_button)
        self.remove_dice_effect_button = QPushButton("Remove Dice Effect")
        self.remove_dice_effect_button.clicked.connect(self._remove_dice_effect)
        dice_buttons_layout.addWidget(self.remove_dice_effect_button)
        self.details_form_layout.addRow(dice_buttons_layout)


        # Tags
        self.tags_edit = QLineEdit()
        self.tags_edit.setPlaceholderText("Comma-separated tags (e.g., magic, fire, potion)")
        self.details_form_layout.addRow("Tags:", self.tags_edit)

        # Typed Resistances (structured editor)
        self.typed_res_editor = TypedResistancesEditor(effect_types=getattr(self, "_effect_types", []))
        self.details_form_layout.addRow("Typed Resistances:", self.typed_res_editor)

        # Custom Properties (simple JSON string for now)
        self.custom_props_edit = QTextEdit()
        self.custom_props_edit.setPlaceholderText("JSON string for custom properties, e.g., {\"charge_cost\": 5}")
        self.custom_props_edit.setFixedHeight(60)
        self.details_form_layout.addRow("Custom Properties (JSON):", self.custom_props_edit)


        self.save_item_button = QPushButton("Save Item Changes")
        self.save_item_button.clicked.connect(self._save_current_item_details)
        self.details_form_layout.addRow(self.save_item_button)

        splitter.addWidget(right_panel_scroll)
        splitter.setSizes([250, 550])
        main_layout.addWidget(splitter)

        self._set_details_enabled(False)

    # --- Data Loading and Saving ---
    def load_data(self):
        """Loads item data from the JSON file."""
        if os.path.exists(self.full_item_file_path):
            loaded_data = load_json(self.full_item_file_path)
            if isinstance(loaded_data, list):
                self.items_data = loaded_data
            else:
                logger.error(f"Data in {self.item_file_key} file is not a list. Initializing as empty.")
                self.items_data = []
        else:
            logger.warning(f"{self.item_file_key} file not found at {self.full_item_file_path}. Starting with empty list.")
            self.items_data = []
        self._refresh_item_list_widget()

    def save_data(self) -> bool:
        """Saves all items data to the JSON file."""
        # Ensure current item details are applied to self.items_data if an item is selected,
        # unless a programmatic save is in progress (assistant patch path).
        if (not self._programmatic_save_in_progress) and self.current_item_index is not None and self.current_item_index < len(self.items_data):
            self._apply_details_to_current_item_data()

        if save_json(self.items_data, self.full_item_file_path):
            logger.info(f"Saved {self.item_file_key} data to {self.full_item_file_path}")
            self.data_modified.emit()
            return True
        else:
            QMessageBox.critical(self, "Save Error", f"Failed to save {self.item_file_key} data.")
            return False

    def _refresh_item_list_widget(self):
        self.item_list_widget.clear()
        self.items_data.sort(key=lambda x: x.get("name", x.get("id", ""))) # Sort by name, then ID
        for index, item_dict in enumerate(self.items_data):
            display_name = f"{item_dict.get('name', 'Unnamed Item')} ({item_dict.get('id', 'No ID')})"
            list_item = QListWidgetItem(display_name)
            list_item.setData(Qt.UserRole, index) # Store index in the list
            self.item_list_widget.addItem(list_item)
        self._set_details_enabled(False)
        self.remove_item_button.setEnabled(False)

    # --- UI Callbacks ---
    @Slot(QListWidgetItem, QListWidgetItem)
    def _on_item_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]):
        if current:
            # Save previous item's details before loading new one if it was modified
            if previous and self.current_item_index is not None:
                 # This check is tricky without a dedicated "modified" flag for the form.
                 # Forcing apply could overwrite unintended changes if user just clicked around.
                 # A simpler approach is to rely on the explicit "Save Item Changes" button.
                 pass


            self.current_item_index = current.data(Qt.UserRole)
            if self.current_item_index is not None and self.current_item_index < len(self.items_data):
                self._populate_details_from_item_data(self.items_data[self.current_item_index])
                self._set_details_enabled(True)
                self.remove_item_button.setEnabled(True)
            else:
                self._clear_details()
                self._set_details_enabled(False)
                self.remove_item_button.setEnabled(False)
        else:
            self.current_item_index = None
            self._clear_details()
            self._set_details_enabled(False)
            self.remove_item_button.setEnabled(False)

    @Slot()
    def _add_item(self):
        new_item_id_prefix = self.item_file_key.lower().replace(" ", "_").replace("_templates","")
        # Generate a unique enough ID
        new_id_base = f"new_{new_item_id_prefix}_item"
        new_id_suffix = 1
        new_id = f"{new_id_base}_{new_id_suffix}"
        existing_ids = {item.get("id") for item in self.items_data}
        while new_id in existing_ids:
            new_id_suffix += 1
            new_id = f"{new_id_base}_{new_id_suffix}"

        new_item = {"id": new_id, "name": "New Item", "item_type": "miscellaneous"}
        self.items_data.append(new_item)
        self._refresh_item_list_widget()
        # Select the new item
        for i in range(self.item_list_widget.count()):
            if self.item_list_widget.item(i).data(Qt.UserRole) == len(self.items_data) - 1:
                self.item_list_widget.setCurrentRow(i)
                break
        self.id_edit.setFocus() # Focus on ID for editing
        self.data_modified.emit()


    @Slot()
    def _remove_item(self):
        if self.current_item_index is None or not (0 <= self.current_item_index < len(self.items_data)):
            return

        item_to_remove = self.items_data[self.current_item_index]
        reply = QMessageBox.question(self, "Remove Item",
                                     f"Are you sure you want to remove '{item_to_remove.get('name', item_to_remove.get('id'))}'?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            del self.items_data[self.current_item_index]
            self.current_item_index = None
            self._refresh_item_list_widget()
            self._clear_details()
            self._set_details_enabled(False)
            self.data_modified.emit()
            self.save_data() # Auto-save after removal

    @Slot()
    def _save_current_item_details(self):
        if self.current_item_index is None or not (0 <= self.current_item_index < len(self.items_data)):
            QMessageBox.warning(self, "No Item Selected", "Please select an item to save.")
            return
        
        item_id = self.id_edit.text().strip()
        item_name = self.name_edit.text().strip()

        if not item_id:
            QMessageBox.warning(self, "Validation Error", "Item ID cannot be empty.")
            self.id_edit.setFocus()
            return
        if not item_name:
            QMessageBox.warning(self, "Validation Error", "Item Name cannot be empty.")
            self.name_edit.setFocus()
            return

        # Check for ID uniqueness if ID was changed
        original_id = self.items_data[self.current_item_index].get("id")
        if item_id != original_id:
            for idx, item_data_iter in enumerate(self.items_data):
                if idx != self.current_item_index and item_data_iter.get("id") == item_id:
                    QMessageBox.warning(self, "Validation Error", f"Item ID '{item_id}' already exists. Please choose a unique ID.")
                    self.id_edit.setFocus()
                    return

        self._apply_details_to_current_item_data()
        self.save_data() # This will save the whole list to file
        # Refresh the list item text in case name/ID changed
        self._refresh_item_list_widget()
        # Reselect the item
        for i in range(self.item_list_widget.count()):
            if self.item_list_widget.item(i).data(Qt.UserRole) == self.current_item_index: # index might shift if sorted by name
                # find by new ID instead if ID changed
                if item_id != original_id:
                    found_by_new_id = False
                    for new_idx, item_in_list_data in enumerate(self.items_data):
                        if item_in_list_data.get("id") == item_id:
                            self.current_item_index = new_idx # update current_item_index
                            self.item_list_widget.setCurrentRow(new_idx)
                            found_by_new_id = True
                            break
                    if not found_by_new_id:
                        self.current_item_index = None # Should not happen if ID is unique
                else: # ID didn't change, reselect by old index (if still valid after sort)
                    # Re-find by ID to be safe after sort
                    found_by_id_after_sort = False
                    for new_idx_after_sort, item_in_list_data_after_sort in enumerate(self.items_data):
                        if item_in_list_data_after_sort.get("id") == original_id:
                            self.current_item_index = new_idx_after_sort
                            self.item_list_widget.setCurrentRow(new_idx_after_sort)
                            found_by_id_after_sort = True
                            break
                    if not found_by_id_after_sort:
                        self.current_item_index = None


    # --- Helper Methods for Detail Management ---
    def _populate_details_from_item_data(self, item_data: Dict[str, Any]):
        self.id_edit.setText(item_data.get("id", ""))
        self.name_edit.setText(item_data.get("name", ""))
        self.description_edit.setPlainText(item_data.get("description", ""))
        self.item_type_combo.setCurrentText(item_data.get("item_type", "miscellaneous"))
        self.rarity_combo.setCurrentText(item_data.get("rarity", "common"))
        self.weight_spin.setValue(float(item_data.get("weight", 0.0)))
        self.value_spin.setValue(int(item_data.get("value", 0)))

        self.is_equippable_check.setChecked(bool(item_data.get("is_equippable", False)))
        self.is_consumable_check.setChecked(bool(item_data.get("is_consumable", False)))
        self.is_stackable_check.setChecked(bool(item_data.get("is_stackable", False)))
        self.is_quest_item_check.setChecked(bool(item_data.get("is_quest_item", False)))

        # Equip slots via multi-select
        self.equip_slots_combo.set_selected(item_data.get("equip_slots", []))
        self.stack_limit_spin.setValue(int(item_data.get("stack_limit", 1)))
        self.durability_spin.setValue(int(item_data.get("durability", 0)))


        # Populate stats table
        self.stats_table.setRowCount(0)
        stats_list = item_data.get("stats", [])
        if isinstance(stats_list, list):
            for stat_entry in stats_list:
                if isinstance(stat_entry, dict):
                    row_pos = self.stats_table.rowCount()
                    self.stats_table.insertRow(row_pos)
                    self.stats_table.setItem(row_pos, 0, QTableWidgetItem(stat_entry.get("name", "")))
                    self.stats_table.setItem(row_pos, 1, QTableWidgetItem(str(stat_entry.get("value", ""))))
                    self.stats_table.setItem(row_pos, 2, QTableWidgetItem(stat_entry.get("display_name", "")))
                    # Store full stat dict in first item for editing
                    self.stats_table.item(row_pos, 0).setData(Qt.UserRole, stat_entry)


        # Populate dice effects table
        self.dice_effects_table.setRowCount(0)
        dice_effects_list = item_data.get("dice_roll_effects", [])
        if isinstance(dice_effects_list, list):
            for effect_entry in dice_effects_list:
                if isinstance(effect_entry, dict):
                    row_pos = self.dice_effects_table.rowCount()
                    self.dice_effects_table.insertRow(row_pos)
                    self.dice_effects_table.setItem(row_pos, 0, QTableWidgetItem(effect_entry.get("effect_type", "")))
                    self.dice_effects_table.setItem(row_pos, 1, QTableWidgetItem(effect_entry.get("dice_notation", "")))
                    self.dice_effects_table.setItem(row_pos, 2, QTableWidgetItem(effect_entry.get("description", "")))
                    # Store full effect dict in first item for editing
                    self.dice_effects_table.item(row_pos, 0).setData(Qt.UserRole, effect_entry)


        self.tags_edit.setText(", ".join(item_data.get("tags", [])))

        custom_props = item_data.get("custom_properties", {})
        try:
            self.custom_props_edit.setPlainText(json.dumps(custom_props, indent=2) if custom_props else "")
        except TypeError:
            self.custom_props_edit.setPlainText("") # Clear if not serializable

        # Populate typed resistances editor from custom_properties
        typed_res = {}
        if isinstance(custom_props, dict):
            tr = custom_props.get("typed_resistances")
            if isinstance(tr, dict):
                typed_res = {str(k).strip().lower(): int(v) for k, v in tr.items() if isinstance(k, str) and isinstance(v, (int, float))}
        self.typed_res_editor.set_values(typed_res)

        self._update_conditional_field_visibility()


    def _apply_details_to_current_item_data(self):
        if self.current_item_index is None or not (0 <= self.current_item_index < len(self.items_data)):
            return

        item_data = self.items_data[self.current_item_index]

        item_data["id"] = self.id_edit.text().strip()
        item_data["name"] = self.name_edit.text().strip()
        item_data["description"] = self.description_edit.toPlainText().strip()
        item_data["item_type"] = self.item_type_combo.currentText()
        item_data["rarity"] = self.rarity_combo.currentText()
        item_data["weight"] = self.weight_spin.value()
        item_data["value"] = self.value_spin.value()

        item_data["is_equippable"] = self.is_equippable_check.isChecked()
        item_data["is_consumable"] = self.is_consumable_check.isChecked()
        item_data["is_stackable"] = self.is_stackable_check.isChecked()
        item_data["is_quest_item"] = self.is_quest_item_check.isChecked()

        if item_data["is_equippable"]:
            item_data["equip_slots"] = self.equip_slots_combo.get_selected()
        else:
            item_data.pop("equip_slots", None)

        if item_data["is_stackable"]:
            item_data["stack_limit"] = self.stack_limit_spin.value()
        else:
            item_data.pop("stack_limit", None)

        item_data["durability"] = self.durability_spin.value()
        # In templates, do not persist current_durability; runtime items track this.
        item_data.pop("current_durability", None)


        # Stats
        new_stats = []
        for r in range(self.stats_table.rowCount()):
            name = self.stats_table.item(r, 0).text()
            value_str = self.stats_table.item(r,1).text()
            display_name = self.stats_table.item(r,2).text()
            
            parsed_value: Any
            try: # Try to parse as number or bool
                if '.' in value_str: parsed_value = float(value_str)
                else: parsed_value = int(value_str)
            except ValueError:
                if value_str.lower() == 'true': parsed_value = True
                elif value_str.lower() == 'false': parsed_value = False
                else: parsed_value = value_str # Keep as string if not number/bool

            stat_entry = {"name": name, "value": parsed_value}
            if display_name: stat_entry["display_name"] = display_name
            # Check for is_percentage from original data if editing, or default to false
            original_stat_data = self.stats_table.item(r,0).data(Qt.UserRole)
            if isinstance(original_stat_data, dict) and original_stat_data.get("is_percentage"):
                stat_entry["is_percentage"] = True
            new_stats.append(stat_entry)
        item_data["stats"] = new_stats


        # Dice Roll Effects
        new_dice_effects = []
        for r in range(self.dice_effects_table.rowCount()):
            effect_type = self.dice_effects_table.item(r,0).text()
            dice_notation = self.dice_effects_table.item(r,1).text()
            description = self.dice_effects_table.item(r,2).text()
            effect_entry = {"effect_type": effect_type, "dice_notation": dice_notation}
            if description: effect_entry["description"] = description
            new_dice_effects.append(effect_entry)
        item_data["dice_roll_effects"] = new_dice_effects


        item_data["tags"] = [t.strip() for t in self.tags_edit.text().split(',') if t.strip()]

        # Merge Custom Properties JSON with structured Typed Resistances
        parsed_cp = None
        try:
            custom_props_str = self.custom_props_edit.toPlainText().strip()
            if custom_props_str:
                parsed_cp = json.loads(custom_props_str)
                if not isinstance(parsed_cp, dict):
                    parsed_cp = {}
        except json.JSONDecodeError:
            QMessageBox.warning(self, "JSON Error", "Invalid JSON in Custom Properties. Keeping previous custom_properties where possible.")
            parsed_cp = None
        # Start from existing dict if JSON parse failed, else from parsed cp or empty
        cp = parsed_cp if isinstance(parsed_cp, dict) else (item_data.get("custom_properties") if isinstance(item_data.get("custom_properties"), dict) else {})
        # Apply typed resistances from the structured editor
        typed_res = self.typed_res_editor.get_values()
        if typed_res:
            cp["typed_resistances"] = typed_res
        else:
            if isinstance(cp, dict):
                cp.pop("typed_resistances", None)
        # Persist or remove custom_properties key
        if isinstance(cp, dict) and cp:
            item_data["custom_properties"] = cp
            try:
                self.custom_props_edit.setPlainText(json.dumps(cp, indent=2))
            except Exception:
                pass
        else:
            item_data.pop("custom_properties", None)
            self.custom_props_edit.clear()

    def _clear_details(self):
        self.id_edit.clear()
        self.name_edit.clear()
        self.description_edit.clear()
        self.item_type_combo.setCurrentIndex(0)
        self.rarity_combo.setCurrentIndex(0)
        self.weight_spin.setValue(0.0)
        self.value_spin.setValue(0)
        self.is_equippable_check.setChecked(False)
        self.is_consumable_check.setChecked(False)
        self.is_stackable_check.setChecked(False)
        self.is_quest_item_check.setChecked(False)
        self.equip_slots_combo.clear_selection()
        self.stack_limit_spin.setValue(1)
        self.durability_spin.setValue(0)
        self.stats_table.setRowCount(0)
        self.dice_effects_table.setRowCount(0)
        self.tags_edit.clear()
        self.custom_props_edit.clear()
        # Reset typed resistances editor
        try:
            self.typed_res_editor.set_values({})
        except Exception:
            pass
        self._update_conditional_field_visibility()


    def _set_details_enabled(self, enabled: bool):
        for i in range(self.details_form_layout.rowCount()):
            widget_item = self.details_form_layout.itemAt(i, QFormLayout.FieldRole)
            if widget_item and widget_item.widget():
                widget_item.widget().setEnabled(enabled)
            # Also enable labels if needed, though usually they are just for display
            # label_item = self.details_form_layout.itemAt(i, QFormLayout.LabelRole)
            # if label_item and label_item.widget():
            #     label_item.widget().setEnabled(enabled)
        self.id_edit.setEnabled(enabled) # Ensure ID can be edited when an item is selected
        if not enabled:
            self.id_edit.setReadOnly(True) # Read-only if no item selected
        else:
            self.id_edit.setReadOnly(False) # Editable if item selected

        self.save_item_button.setEnabled(enabled)
        if enabled:
            self._update_conditional_field_visibility()
        else: # Hide conditional fields if no item is selected
            self.details_form_layout.labelForField(self.equip_slots_combo).setVisible(False)
            self.equip_slots_combo.setVisible(False)
            self.details_form_layout.labelForField(self.stack_limit_spin).setVisible(False)
            self.stack_limit_spin.setVisible(False)
            # Hide typed resistances section
            try:
                self.details_form_layout.labelForField(self.typed_res_editor).setVisible(False)
                self.typed_res_editor.setVisible(False)
            except Exception:
                pass


    def _update_conditional_field_visibility(self):
        """Show/hide fields based on checkbox states."""
        is_equippable = self.is_equippable_check.isChecked()
        self.details_form_layout.labelForField(self.equip_slots_combo).setVisible(is_equippable)
        self.equip_slots_combo.setVisible(is_equippable)
        self.equip_slots_combo.setEnabled(is_equippable)
        if not is_equippable:
            try:
                self.equip_slots_combo.clear_selection()
            except Exception:
                pass

        is_stackable = self.is_stackable_check.isChecked()
        self.details_form_layout.labelForField(self.stack_limit_spin).setVisible(is_stackable)
        self.stack_limit_spin.setVisible(is_stackable)

        # Typed resistances visible only for equippable items
        try:
            lbl = self.details_form_layout.labelForField(self.typed_res_editor)
            if lbl:
                lbl.setVisible(is_equippable)
            self.typed_res_editor.setVisible(is_equippable)
            self.typed_res_editor.setEnabled(is_equippable)
        except Exception:
            pass

    @Slot()
    def _add_item_stat(self):
        dialog = ItemStatDialog(self)
        if dialog.exec() == QDialog.Accepted:
            stat_data = dialog.get_stat_data()
            if stat_data:
                row_pos = self.stats_table.rowCount()
                self.stats_table.insertRow(row_pos)
                self.stats_table.setItem(row_pos, 0, QTableWidgetItem(stat_data["name"]))
                self.stats_table.setItem(row_pos, 1, QTableWidgetItem(str(stat_data["value"])))
                self.stats_table.setItem(row_pos, 2, QTableWidgetItem(stat_data.get("display_name", "")))
                self.stats_table.item(row_pos,0).setData(Qt.UserRole, stat_data) # Store for editing
                self.data_modified.emit()


    @Slot()
    def _remove_item_stat(self):
        current_row = self.stats_table.currentRow()
        if current_row >= 0:
            self.stats_table.removeRow(current_row)
            self.data_modified.emit()

    @Slot()
    def _add_dice_effect(self):
        dialog = DiceRollEffectDialog(self, effect_types=getattr(self, "_effect_types", None))
        if dialog.exec() == QDialog.Accepted:
            effect_data = dialog.get_effect_data()
            if effect_data:
                row_pos = self.dice_effects_table.rowCount()
                self.dice_effects_table.insertRow(row_pos)
                self.dice_effects_table.setItem(row_pos, 0, QTableWidgetItem(effect_data["effect_type"]))
                self.dice_effects_table.setItem(row_pos, 1, QTableWidgetItem(effect_data["dice_notation"]))
                self.dice_effects_table.setItem(row_pos, 2, QTableWidgetItem(effect_data.get("description", "")))
                self.dice_effects_table.item(row_pos,0).setData(Qt.UserRole, effect_data)
                self.data_modified.emit()

    @Slot()
    def _remove_dice_effect(self):
        current_row = self.dice_effects_table.currentRow()
        if current_row >= 0:
            self.dice_effects_table.removeRow(current_row)
            self.data_modified.emit()

    def refresh_data(self):
        """Public method to reload data from file."""
        self.load_data()
        # If an item was selected, try to reselect it or select first.
        if self.current_item_index is not None and self.current_item_index < self.item_list_widget.count():
            self.item_list_widget.setCurrentRow(self.current_item_index)
        elif self.item_list_widget.count() > 0:
            self.item_list_widget.setCurrentRow(0)
        else:
            self._clear_details()
            self._set_details_enabled(False)
```

### File: world_configurator\ui\editors\variants_editor.py

```python
"""
Variants editor for config/npc/variants.json.
"""
import logging
import os
from typing import Dict, Any, Optional, List

from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTextEdit,
    QPushButton, QListWidget, QListWidgetItem, QFormLayout, QDoubleSpinBox,
    QComboBox, QMessageBox, QSplitter, QFrame, QCheckBox, QSpinBox,
    QGroupBox, QScrollArea, QTabWidget
)

from models.variants_manager import VariantsManager
from utils.file_manager import get_config_dir

logger = logging.getLogger("world_configurator.ui.variants_editor")

class StatModifierWidget(QWidget):
    """Widget for editing stat modifiers."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self.data = {}
    
    def _setup_ui(self):
        layout = QVBoxLayout(self)
        
        # HP Modifier
        hp_group = QGroupBox("HP Modifier")
        hp_layout = QFormLayout(hp_group)
        self.hp_add_spin = QDoubleSpinBox()
        self.hp_add_spin.setRange(-100, 100)
        self.hp_add_spin.setValue(0)
        self.hp_mul_spin = QDoubleSpinBox()
        self.hp_mul_spin.setRange(0.1, 5.0)
        self.hp_mul_spin.setSingleStep(0.1)
        self.hp_mul_spin.setValue(1.0)
        hp_layout.addRow("Add:", self.hp_add_spin)
        hp_layout.addRow("Multiply:", self.hp_mul_spin)
        layout.addWidget(hp_group)
        
        # Damage Modifier
        damage_group = QGroupBox("Damage Modifier")
        damage_layout = QFormLayout(damage_group)
        self.damage_add_spin = QDoubleSpinBox()
        self.damage_add_spin.setRange(-100, 100)
        self.damage_add_spin.setValue(0)
        self.damage_mul_spin = QDoubleSpinBox()
        self.damage_mul_spin.setRange(0.1, 5.0)
        self.damage_mul_spin.setSingleStep(0.1)
        self.damage_mul_spin.setValue(1.0)
        damage_layout.addRow("Add:", self.damage_add_spin)
        damage_layout.addRow("Multiply:", self.damage_mul_spin)
        layout.addWidget(damage_group)
        
        # Defense Modifier
        defense_group = QGroupBox("Defense Modifier")
        defense_layout = QFormLayout(defense_group)
        self.defense_add_spin = QDoubleSpinBox()
        self.defense_add_spin.setRange(-100, 100)
        self.defense_add_spin.setValue(0)
        self.defense_mul_spin = QDoubleSpinBox()
        self.defense_mul_spin.setRange(0.1, 5.0)
        self.defense_mul_spin.setSingleStep(0.1)
        self.defense_mul_spin.setValue(1.0)
        defense_layout.addRow("Add:", self.defense_add_spin)
        defense_layout.addRow("Multiply:", self.defense_mul_spin)
        layout.addWidget(defense_group)
        
        # Initiative Modifier
        initiative_group = QGroupBox("Initiative Modifier")
        initiative_layout = QFormLayout(initiative_group)
        self.initiative_add_spin = QDoubleSpinBox()
        self.initiative_add_spin.setRange(-100, 100)
        self.initiative_add_spin.setValue(0)
        self.initiative_mul_spin = QDoubleSpinBox()
        self.initiative_mul_spin.setRange(0.1, 5.0)
        self.initiative_mul_spin.setSingleStep(0.1)
        self.initiative_mul_spin.setValue(1.0)
        initiative_layout.addRow("Add:", self.initiative_add_spin)
        initiative_layout.addRow("Multiply:", self.initiative_mul_spin)
        layout.addWidget(initiative_group)
    
    def set_data(self, data: Dict[str, Dict[str, float]]):
        """Set the stat modifier data."""
        self.data = data or {}
        
        # HP
        hp_data = self.data.get("hp", {})
        self.hp_add_spin.setValue(hp_data.get("add", 0))
        self.hp_mul_spin.setValue(hp_data.get("mul", 1.0))
        
        # Damage
        damage_data = self.data.get("damage", {})
        self.damage_add_spin.setValue(damage_data.get("add", 0))
        self.damage_mul_spin.setValue(damage_data.get("mul", 1.0))
        
        # Defense
        defense_data = self.data.get("defense", {})
        self.defense_add_spin.setValue(defense_data.get("add", 0))
        self.defense_mul_spin.setValue(defense_data.get("mul", 1.0))
        
        # Initiative
        initiative_data = self.data.get("initiative", {})
        self.initiative_add_spin.setValue(initiative_data.get("add", 0))
        self.initiative_mul_spin.setValue(initiative_data.get("mul", 1.0))
    
    def get_data(self) -> Dict[str, Dict[str, float]]:
        """Get the stat modifier data."""
        data = {}
        
        # Only include non-default values
        if self.hp_add_spin.value() != 0 or self.hp_mul_spin.value() != 1.0:
            hp_mod = {}
            if self.hp_add_spin.value() != 0:
                hp_mod["add"] = self.hp_add_spin.value()
            if self.hp_mul_spin.value() != 1.0:
                hp_mod["mul"] = self.hp_mul_spin.value()
            if hp_mod:
                data["hp"] = hp_mod
        
        if self.damage_add_spin.value() != 0 or self.damage_mul_spin.value() != 1.0:
            damage_mod = {}
            if self.damage_add_spin.value() != 0:
                damage_mod["add"] = self.damage_add_spin.value()
            if self.damage_mul_spin.value() != 1.0:
                damage_mod["mul"] = self.damage_mul_spin.value()
            if damage_mod:
                data["damage"] = damage_mod
        
        if self.defense_add_spin.value() != 0 or self.defense_mul_spin.value() != 1.0:
            defense_mod = {}
            if self.defense_add_spin.value() != 0:
                defense_mod["add"] = self.defense_add_spin.value()
            if self.defense_mul_spin.value() != 1.0:
                defense_mod["mul"] = self.defense_mul_spin.value()
            if defense_mod:
                data["defense"] = defense_mod
        
        if self.initiative_add_spin.value() != 0 or self.initiative_mul_spin.value() != 1.0:
            initiative_mod = {}
            if self.initiative_add_spin.value() != 0:
                initiative_mod["add"] = self.initiative_add_spin.value()
            if self.initiative_mul_spin.value() != 1.0:
                initiative_mod["mul"] = self.initiative_mul_spin.value()
            if initiative_mod:
                data["initiative"] = initiative_mod
        
        return data

class VariantsEditor(QWidget):
    variants_modified = Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._manager: Optional[VariantsManager] = None
        self._current_variant: Optional[str] = None
        self._setup_ui()
    
    def _setup_ui(self):
        main_layout = QHBoxLayout(self)
        
        # Create splitter
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)
        
        # Left panel: Variant list and filter controls
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        # Filter controls
        filter_group = QGroupBox("Filter")
        filter_layout = QVBoxLayout(filter_group)
        
        # Role filter
        role_filter_layout = QHBoxLayout()
        role_filter_layout.addWidget(QLabel("Role:"))
        self.role_filter_combo = QComboBox()
        self.role_filter_combo.addItems(["All", "guard", "official", "scholar"])
        self.role_filter_combo.currentTextChanged.connect(self._on_filter_changed)
        role_filter_layout.addWidget(self.role_filter_combo)
        filter_layout.addLayout(role_filter_layout)
        
        # Culture filter
        culture_filter_layout = QHBoxLayout()
        culture_filter_layout.addWidget(QLabel("Culture:"))
        self.culture_filter_combo = QComboBox()
        self.culture_filter_combo.addItems(["All", "concordant", "verdant", "crystalline", "ashen", "tempest"])
        self.culture_filter_combo.currentTextChanged.connect(self._on_filter_changed)
        culture_filter_layout.addWidget(self.culture_filter_combo)
        filter_layout.addLayout(culture_filter_layout)
        
        left_layout.addWidget(filter_group)
        
        # Variant list
        variants_label = QLabel("Variants")
        variants_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        left_layout.addWidget(variants_label)
        
        self.variants_list = QListWidget()
        self.variants_list.setMinimumWidth(250)
        self.variants_list.currentItemChanged.connect(self._on_variant_selected)
        left_layout.addWidget(self.variants_list)
        
        # List controls
        list_controls = QHBoxLayout()
        self.add_variant_btn = QPushButton("Add")
        self.add_variant_btn.clicked.connect(self._on_add_variant)
        list_controls.addWidget(self.add_variant_btn)
        
        self.remove_variant_btn = QPushButton("Remove")
        self.remove_variant_btn.clicked.connect(self._on_remove_variant)
        self.remove_variant_btn.setEnabled(False)
        list_controls.addWidget(self.remove_variant_btn)
        
        left_layout.addLayout(list_controls)
        
        # Actions
        actions_layout = QHBoxLayout()
        self.load_btn = QPushButton("Load from Game")
        self.load_btn.clicked.connect(self.load_from_game)
        actions_layout.addWidget(self.load_btn)
        
        self.save_btn = QPushButton("Save Changes")
        self.save_btn.clicked.connect(self.save_changes)
        actions_layout.addWidget(self.save_btn)
        
        left_layout.addLayout(actions_layout)
        
        splitter.addWidget(left_panel)
        
        # Right panel: Variant details
        right_panel = QScrollArea()
        right_panel.setWidgetResizable(True)
        right_panel.setFrameShape(QFrame.NoFrame)
        
        self.details_widget = QWidget()
        right_panel.setWidget(self.details_widget)
        self.details_layout = QVBoxLayout(self.details_widget)
        
        # Basic info
        basic_group = QGroupBox("Basic Information")
        basic_layout = QFormLayout(basic_group)
        
        self.id_edit = QLineEdit()
        self.id_edit.textChanged.connect(self._on_field_changed)
        basic_layout.addRow("ID:", self.id_edit)
        
        self.name_edit = QLineEdit()
        self.name_edit.textChanged.connect(self._on_field_changed)
        basic_layout.addRow("Name:", self.name_edit)
        
        self.family_id_edit = QLineEdit()
        self.family_id_edit.setPlaceholderText("e.g., concordant_citizen, verdant_wanderer")
        self.family_id_edit.textChanged.connect(self._on_field_changed)
        basic_layout.addRow("Family ID:", self.family_id_edit)
        
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(100)
        self.description_edit.textChanged.connect(self._on_field_changed)
        basic_layout.addRow("Description:", self.description_edit)
        
        self.details_layout.addWidget(basic_group)
        
        # Stat modifiers
        stat_group = QGroupBox("Stat Modifiers")
        stat_layout = QVBoxLayout(stat_group)
        self.stat_modifier_widget = StatModifierWidget()
        stat_layout.addWidget(self.stat_modifier_widget)
        self.details_layout.addWidget(stat_group)
        
        # Lists section
        lists_group = QGroupBox("Roles, Abilities, and Tags")
        lists_layout = QVBoxLayout(lists_group)
        
        # Roles
        roles_layout = QHBoxLayout()
        roles_layout.addWidget(QLabel("Roles Add:"))
        self.roles_edit = QLineEdit()
        self.roles_edit.setPlaceholderText("Comma-separated: striker, tank, controller, support, skirmisher")
        self.roles_edit.textChanged.connect(self._on_field_changed)
        roles_layout.addWidget(self.roles_edit)
        lists_layout.addLayout(roles_layout)
        
        # Abilities
        abilities_layout = QHBoxLayout()
        abilities_layout.addWidget(QLabel("Abilities Add:"))
        self.abilities_edit = QLineEdit()
        self.abilities_edit.setPlaceholderText("Comma-separated ability IDs")
        self.abilities_edit.textChanged.connect(self._on_field_changed)
        abilities_layout.addWidget(self.abilities_edit)
        lists_layout.addLayout(abilities_layout)
        
        # Tags
        tags_layout = QHBoxLayout()
        tags_layout.addWidget(QLabel("Tags Add:"))
        self.tags_edit = QLineEdit()
        self.tags_edit.setPlaceholderText("Comma-separated: role:guard, duty:watch, etc.")
        self.tags_edit.textChanged.connect(self._on_field_changed)
        tags_layout.addWidget(self.tags_edit)
        lists_layout.addLayout(tags_layout)
        
        self.details_layout.addWidget(lists_group)
        
        # Quick social role creation
        quick_group = QGroupBox("Quick Social Role Creation")
        quick_layout = QFormLayout(quick_group)
        
        self.quick_culture_combo = QComboBox()
        self.quick_culture_combo.addItems(["concordant", "verdant", "crystalline", "ashen", "tempest"])
        quick_layout.addRow("Culture:", self.quick_culture_combo)
        
        self.quick_role_combo = QComboBox()
        self.quick_role_combo.addItems(["guard", "official", "scholar"])
        quick_layout.addRow("Role:", self.quick_role_combo)
        
        self.quick_family_edit = QLineEdit()
        self.quick_family_edit.setPlaceholderText("Leave blank to auto-determine")
        quick_layout.addRow("Family ID:", self.quick_family_edit)
        
        self.create_social_role_btn = QPushButton("Create Social Role Variant")
        self.create_social_role_btn.clicked.connect(self._on_create_social_role)
        quick_layout.addRow(self.create_social_role_btn)
        
        self.details_layout.addWidget(quick_group)
        
        # Validation and preview
        validation_group = QGroupBox("Validation & Preview")
        validation_layout = QVBoxLayout(validation_group)
        
        self.validate_btn = QPushButton("Validate Current Variant")
        self.validate_btn.clicked.connect(self._on_validate_current)
        validation_layout.addWidget(self.validate_btn)
        
        self.preview_text = QTextEdit()
        self.preview_text.setReadOnly(True)
        self.preview_text.setMaximumHeight(150)
        validation_layout.addWidget(self.preview_text)
        
        self.details_layout.addWidget(validation_group)
        
        splitter.addWidget(right_panel)
        
        # Initially disable details
        self._disable_details()
        
        # Set splitter proportions
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 2)
    
    def set_manager(self, manager: VariantsManager):
        """Set the variants manager."""
        self._manager = manager
        self.refresh()
    
    def refresh(self):
        """Refresh the UI from the manager."""
        if not self._manager:
            return
        self._refresh_variants_list()
        self._disable_details()
        self._current_variant = None
    
    def load_from_game(self):
        """Load variants from the game's config file."""
        path = os.path.join(get_config_dir(), "npc", "variants.json")
        if self._manager and self._manager.load_from_file(path):
            self.refresh()
            QMessageBox.information(self, "Loaded", f"Loaded variants from {path}")
        else:
            QMessageBox.critical(self, "Error", f"Failed to load variants from {path}")
    
    def save_changes(self):
        """Save changes to the manager."""
        if not self._manager:
            return
        
        # Save current variant first
        if self._current_variant:
            self._save_current_variant()
        
        # Validate all variants
        errors = []
        for variant_id, variant_data in self._manager.data.get("variants", {}).items():
            variant_errors = self._manager.validate_variant(variant_data)
            if variant_errors:
                errors.extend([f"{variant_id}: {err}" for err in variant_errors])
        
        if errors:
            QMessageBox.warning(self, "Validation Errors", "Some variants have validation errors:\\n\\n" + "\\n".join(errors))
            return
        
        # Save to manager's current path or show save dialog
        try:
            if self._manager.state.path:
                success = self._manager.save_to_file()
            else:
                # Fallback to game file
                path = os.path.join(get_config_dir(), "npc", "variants.json")
                success = self._manager.save_to_file(path)
            
            if success:
                self.variants_modified.emit()
                QMessageBox.information(self, "Saved", "Variants saved successfully.")
            else:
                QMessageBox.critical(self, "Error", "Failed to save variants.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save variants: {e}")
    
    def _refresh_variants_list(self):
        """Refresh the variants list."""
        if not self._manager:
            return
        
        self.variants_list.clear()
        
        variants = self._manager.data.get("variants", {})
        role_filter = self.role_filter_combo.currentText()
        culture_filter = self.culture_filter_combo.currentText()
        
        for variant_id, variant_data in variants.items():
            # Apply filters
            if role_filter != "All":
                tags = variant_data.get("tags_add", [])
                role_tag = f"role:{role_filter}"
                if role_tag not in tags:
                    continue
            
            if culture_filter != "All":
                if not variant_id.startswith(f"{culture_filter}_"):
                    continue
            
            item = QListWidgetItem(f"{variant_data.get('name', variant_id)}")
            item.setData(Qt.UserRole, variant_id)
            self.variants_list.addItem(item)
        
        # Sort alphabetically
        self.variants_list.sortItems()
    
    def _on_filter_changed(self):
        """Handle filter changes."""
        self._refresh_variants_list()
    
    def _on_variant_selected(self, current: Optional[QListWidgetItem], previous: Optional[QListWidgetItem]):
        """Handle variant selection."""
        if previous and self._current_variant:
            # Save previous variant
            self._save_current_variant()
        
        if current:
            variant_id = current.data(Qt.UserRole)
            self._load_variant(variant_id)
            self.remove_variant_btn.setEnabled(True)
        else:
            self._disable_details()
            self.remove_variant_btn.setEnabled(False)
            self._current_variant = None
    
    def _load_variant(self, variant_id: str):
        """Load a variant into the editor."""
        if not self._manager:
            return
        
        variant_data = self._manager.get_variant(variant_id)
        if not variant_data:
            return
        
        self._current_variant = variant_id
        
        # Load basic info
        self.id_edit.setText(variant_data.get("id", variant_id))
        self.name_edit.setText(variant_data.get("name", ""))
        self.family_id_edit.setText(variant_data.get("family_id", ""))
        self.description_edit.setPlainText(variant_data.get("description", ""))
        
        # Load stat modifiers
        self.stat_modifier_widget.set_data(variant_data.get("stat_modifiers", {}))
        
        # Load lists
        self.roles_edit.setText(", ".join(variant_data.get("roles_add", [])))
        self.abilities_edit.setText(", ".join(variant_data.get("abilities_add", [])))
        self.tags_edit.setText(", ".join(variant_data.get("tags_add", [])))
        
        self._enable_details()
        self._update_preview()
    
    def _save_current_variant(self):
        """Save the current variant from UI."""
        if not self._manager or not self._current_variant:
            return
        
        variant_data = {
            "id": self.id_edit.text().strip(),
            "family_id": self.family_id_edit.text().strip(),
            "name": self.name_edit.text().strip(),
            "description": self.description_edit.toPlainText().strip()
        }
        
        # Add stat modifiers if any
        stat_mods = self.stat_modifier_widget.get_data()
        if stat_mods:
            variant_data["stat_modifiers"] = stat_mods
        
        # Add lists if not empty
        roles = [r.strip() for r in self.roles_edit.text().split(",") if r.strip()]
        if roles:
            variant_data["roles_add"] = roles
        
        abilities = [a.strip() for a in self.abilities_edit.text().split(",") if a.strip()]
        if abilities:
            variant_data["abilities_add"] = abilities
        
        tags = [t.strip() for t in self.tags_edit.text().split(",") if t.strip()]
        if tags:
            variant_data["tags_add"] = tags
        
        self._manager.add_variant(self._current_variant, variant_data)
    
    def _enable_details(self):
        """Enable detail editing controls."""
        self.details_widget.setEnabled(True)
    
    def _disable_details(self):
        """Disable detail editing controls."""
        self.details_widget.setEnabled(False)
        self.id_edit.clear()
        self.name_edit.clear()
        self.family_id_edit.clear()
        self.description_edit.clear()
        self.stat_modifier_widget.set_data({})
        self.roles_edit.clear()
        self.abilities_edit.clear()
        self.tags_edit.clear()
        self.preview_text.clear()
    
    def _on_field_changed(self):
        """Handle field changes to update preview."""
        if self._current_variant:
            self._update_preview()
    
    def _update_preview(self):
        """Update the preview text."""
        if not self._current_variant:
            return
        
        # Build preview text
        preview = f"ID: {self.id_edit.text()}\n"
        preview += f"Name: {self.name_edit.text()}\n"
        preview += f"Family: {self.family_id_edit.text()}\n"
        preview += f"Description: {self.description_edit.toPlainText()}\n\n"
        
        stat_mods = self.stat_modifier_widget.get_data()
        if stat_mods:
            preview += "Stat Modifiers:\n"
            for stat, mods in stat_mods.items():
                preview += f"  {stat}: {mods}\n"
            preview += "\n"
        
        roles = [r.strip() for r in self.roles_edit.text().split(",") if r.strip()]
        if roles:
            preview += f"Roles: {', '.join(roles)}\n"
        
        abilities = [a.strip() for a in self.abilities_edit.text().split(",") if a.strip()]
        if abilities:
            preview += f"Abilities: {', '.join(abilities)}\n"
        
        tags = [t.strip() for t in self.tags_edit.text().split(",") if t.strip()]
        if tags:
            preview += f"Tags: {', '.join(tags)}\n"
        
        self.preview_text.setPlainText(preview)
    
    def _on_add_variant(self):
        """Handle adding a new variant."""
        if not self._manager:
            return
        
        # Simple dialog to get variant ID
        from PySide6.QtWidgets import QInputDialog
        variant_id, ok = QInputDialog.getText(self, "New Variant", "Variant ID:")
        
        if ok and variant_id.strip():
            variant_id = variant_id.strip()
            
            # Check if already exists
            if self._manager.get_variant(variant_id):
                QMessageBox.warning(self, "Exists", f"Variant '{variant_id}' already exists.")
                return
            
            # Create empty variant
            variant_data = {
                "id": variant_id,
                "family_id": "",
                "name": variant_id.replace("_", " ").title(),
                "description": f"A {variant_id} variant."
            }
            
            self._manager.add_variant(variant_id, variant_data)
            self._refresh_variants_list()
            
            # Select the new variant
            for i in range(self.variants_list.count()):
                item = self.variants_list.item(i)
                if item.data(Qt.UserRole) == variant_id:
                    self.variants_list.setCurrentItem(item)
                    break
    
    def _on_remove_variant(self):
        """Handle removing a variant."""
        if not self._manager or not self._current_variant:
            return
        
        result = QMessageBox.question(
            self,
            "Confirm Removal",
            f"Are you sure you want to remove variant '{self._current_variant}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result == QMessageBox.Yes:
            self._manager.remove_variant(self._current_variant)
            self._refresh_variants_list()
            self._disable_details()
            self._current_variant = None
    
    def _on_create_social_role(self):
        """Handle creating a social role variant."""
        if not self._manager:
            return
        
        culture = self.quick_culture_combo.currentText()
        role = self.quick_role_combo.currentText()
        family_id = self.quick_family_edit.text().strip()
        
        if not family_id:
            # Auto-determine family based on culture
            family_mapping = {
                "concordant": "concordant_citizen",
                "verdant": "verdant_wanderer",
                "crystalline": "crystalline_adept",
                "ashen": "ashen_nomad",
                "tempest": "tempest_swashbuckler"
            }
            family_id = family_mapping.get(culture, "humanoid_normal_base")
        
        # Generate names
        role_names = {
            "guard": {"concordant": "Concordant Guard", "verdant": "Verdant Warden", "crystalline": "Crystalline Sentinel", "ashen": "Ashen Guardian", "tempest": "Tempest Harbor Guard"},
            "official": {"concordant": "Concordant Official", "verdant": "Verdant Envoy", "crystalline": "Crystalline Official", "ashen": "Ashen Elder", "tempest": "Tempest Quartermaster"},
            "scholar": {"concordant": "Concordant Scholar", "verdant": "Verdant Scholar", "crystalline": "Crystalline Scholar", "ashen": "Ashen Scholar", "tempest": "Tempest Scholar"}
        }
        
        name = role_names.get(role, {}).get(culture, f"{culture.title()} {role.title()}")
        description = f"A {name.lower()} serving their community."
        
        try:
            variant_id = self._manager.create_social_role_variant(
                culture=culture,
                role=role,
                family_id=family_id,
                name=name,
                description=description
            )
            
            self._refresh_variants_list()
            
            # Select the new variant
            for i in range(self.variants_list.count()):
                item = self.variants_list.item(i)
                if item.data(Qt.UserRole) == variant_id:
                    self.variants_list.setCurrentItem(item)
                    break
            
            QMessageBox.information(self, "Created", f"Created social role variant: {variant_id}")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to create social role variant: {e}")
    
    def _on_validate_current(self):
        """Validate the current variant."""
        if not self._manager or not self._current_variant:
            return
        
        # First save current changes
        self._save_current_variant()
        
        variant_data = self._manager.get_variant(self._current_variant)
        if not variant_data:
            return
        
        errors = self._manager.validate_variant(variant_data)
        
        if errors:
            QMessageBox.warning(self, "Validation Errors", "\\n".join(errors))
        else:
            QMessageBox.information(self, "Valid", "Current variant is valid!")
    
    # AI Assistant integration methods
    def get_assistant_context(self):
        """Get context for the AI assistant."""
        from assistant.context import AssistantContext
        
        # Define allowed paths that the AI can modify
        allowed = [
            "/name",
            "/description", 
            "/family_id",
            "/stat_modifiers",
            "/roles_add",
            "/abilities_add",
            "/tags_add"
        ]
        
        content = None
        if self._manager and self._current_variant:
            # Save current UI state first
            self._save_current_variant()
            variant_data = self._manager.get_variant(self._current_variant)
            if variant_data:
                content = dict(variant_data)  # Make a copy
        
        # Get current UI filter context for better AI suggestions
        ui_context = {
            "current_culture_filter": self.culture_filter_combo.currentText(),
            "current_role_filter": self.role_filter_combo.currentText(),
            "quick_culture_setting": self.quick_culture_combo.currentText(),
            "quick_role_setting": self.quick_role_combo.currentText()
        }
        
        # Get reference catalogs with UI context included
        references = self.get_reference_catalogs()
        references["ui_context"] = ui_context
        
        return AssistantContext(
            domain="variants",
            selection_id=self._current_variant,
            content=content,
            schema=None,
            allowed_paths=allowed,
            exemplars=self.get_domain_examples(),
            references=references
        )
    
    def apply_assistant_patch(self, patch_ops):
        """Apply AI assistant patch to the current variant."""
        from assistant.patching import apply_patch_with_validation
        
        if not self._manager or not self._current_variant:
            return False, "No variant selected."
        
        ctx = self.get_assistant_context()
        if not ctx.content:
            return False, "No variant data available."
        
        ok, msg, new_content = apply_patch_with_validation(ctx, ctx.content, patch_ops)
        if not ok:
            return False, msg
        
        try:
            # Sanitize and validate the new content
            new_content = self._sanitize_variant_payload(new_content)
            
            # Update the manager
            self._manager.add_variant(self._current_variant, new_content)
            
            # Refresh the UI to reflect changes
            self._load_variant(self._current_variant)
            
            self.variants_modified.emit()
            return True, "Successfully applied changes."
        
        except Exception as e:
            logger.error(f"Failed to apply assistant patch: {e}", exc_info=True)
            return False, f"Failed to apply changes: {e}"
    
    def create_entry_from_llm(self, entry: dict):
        """Create a new variant from AI assistant suggestion."""
        if not self._manager:
            return False, "No manager available.", None
        
        try:
            # Ensure minimal required fields and generate unique ID
            proposed_name = (entry.get("name") or "New Variant").strip()
            
            # Generate variant ID from name or use provided ID
            if "id" in entry and entry["id"].strip():
                variant_id = entry["id"].strip()
            else:
                # Generate ID from name
                variant_id = proposed_name.lower().replace(" ", "_").replace("-", "_")
                # Remove special characters
                import re
                variant_id = re.sub(r'[^a-z0-9_]', '', variant_id)
            
            # Ensure uniqueness
            existing_variants = self._manager.data.get("variants", {})
            original_id = variant_id
            suffix = 1
            while variant_id in existing_variants:
                variant_id = f"{original_id}_{suffix}"
                suffix += 1
            
            # Sanitize and prepare variant data
            variant_data = self._sanitize_variant_payload(entry)
            variant_data["id"] = variant_id
            variant_data["name"] = proposed_name
            
            # Ensure required fields have defaults
            if "family_id" not in variant_data:
                variant_data["family_id"] = "humanoid_normal_base"
            if "description" not in variant_data:
                variant_data["description"] = f"A {proposed_name.lower()} variant."
            
            # Add to manager
            self._manager.add_variant(variant_id, variant_data)
            
            # Refresh UI
            self._refresh_variants_list()
            
            # Select the new variant
            for i in range(self.variants_list.count()):
                item = self.variants_list.item(i)
                if item.data(Qt.UserRole) == variant_id:
                    self.variants_list.setCurrentItem(item)
                    break
            
            # Sync UI controls to match the newly created variant
            self._sync_ui_to_variant(variant_data)
            
            self.variants_modified.emit()
            return True, "Successfully created variant.", variant_id
        
        except Exception as e:
            logger.error(f"Failed to create variant from LLM: {e}", exc_info=True)
            return False, f"Failed to create variant: {e}", None
    
    def get_domain_examples(self):
        """Get example variants for the AI assistant."""
        if not self._manager:
            return []
        
        variants = self._manager.data.get("variants", {})
        if not variants:
            return []
        
        # Return the first few variants as examples
        examples = []
        for variant_id, variant_data in list(variants.items())[:3]:
            example = dict(variant_data)
            example["_example_id"] = variant_id
            examples.append(example)
        
        return examples
    
    def get_reference_catalogs(self):
        """Get reference data for the AI assistant."""
        if not self._manager:
            return {}
        
        variants = self._manager.data.get("variants", {})
        
        # Collect existing names and IDs
        existing_names = []
        existing_ids = []
        existing_families = set()
        existing_roles = set()
        existing_abilities = set()
        existing_tags = set()
        
        for variant_id, variant_data in variants.items():
            existing_ids.append(variant_id)
            if "name" in variant_data:
                existing_names.append(variant_data["name"])
            if "family_id" in variant_data:
                existing_families.add(variant_data["family_id"])
            
            # Collect roles, abilities, and tags
            for role in variant_data.get("roles_add", []):
                existing_roles.add(role)
            for ability in variant_data.get("abilities_add", []):
                existing_abilities.add(ability)
            for tag in variant_data.get("tags_add", []):
                existing_tags.add(tag)
        
        # Common stat modifier fields
        stat_fields = ["hp", "damage", "defense", "initiative"]
        modifier_ops = ["add", "mul"]
        
        # Common role types
        common_roles = ["striker", "tank", "controller", "support", "skirmisher", "scout"]
        
        # Common culture prefixes
        cultures = ["concordant", "verdant", "crystalline", "ashen", "tempest"]
        
        # Common family patterns
        common_families = [
            "concordant_citizen", "verdant_wanderer", "crystalline_adept", 
            "ashen_nomad", "tempest_swashbuckler", "humanoid_normal_base",
            "beast_normal_base", "beast_easy_base", "beast_hard_base"
        ]
        
        
        return {
            "existing_names": sorted(existing_names),
            "existing_ids": sorted(existing_ids),
            "existing_families": sorted(existing_families),
            "common_families": common_families,
            "existing_roles": sorted(existing_roles),
            "common_roles": common_roles,
            "existing_abilities": sorted(existing_abilities),
            "existing_tags": sorted(existing_tags),
            "stat_fields": stat_fields,
            "modifier_operations": modifier_ops,
            "cultures": cultures,
            "stat_modifiers_structure": {
                "description": "Stat modifiers have 'add' and 'mul' operations applied in that order",
                "example": {"hp": {"add": 5, "mul": 1.2}, "damage": {"mul": 0.9}}
            },
            "social_role_patterns": {
                "description": "Standard social roles and their typical attributes",
                "guard": {"typical_roles": ["tank", "controller"], "typical_abilities": ["resonant_shield", "guard_breaker"], "typical_tags": ["duty:watch", "role:guard"]},
                "official": {"typical_roles": ["support", "controller"], "typical_abilities": ["rally_shout", "chorus_of_clarity"], "typical_tags": ["role:official"]},
                "scholar": {"typical_roles": ["controller", "support"], "typical_abilities": ["calculation_contest", "planar_harmonization"], "typical_tags": ["role:scholar"]}
            },
            "culture_family_mapping": {
                "concordant": "concordant_citizen",
                "verdant": "verdant_wanderer", 
                "crystalline": "crystalline_adept",
                "ashen": "ashen_nomad",
                "tempest": "tempest_swashbuckler"
            }
        }
    
    def _sanitize_variant_payload(self, payload: dict) -> dict:
        """Sanitize incoming variant payload to fit the expected schema."""
        if not isinstance(payload, dict):
            raise ValueError("Payload must be a dictionary")
        
        sanitized = {}
        
        # Copy basic string fields
        for field in ["id", "name", "description", "family_id"]:
            if field in payload and isinstance(payload[field], str):
                sanitized[field] = payload[field].strip()
        
        # Handle stat modifiers
        if "stat_modifiers" in payload and isinstance(payload["stat_modifiers"], dict):
            stat_mods = {}
            for stat, mods in payload["stat_modifiers"].items():
                if isinstance(mods, dict):
                    clean_mods = {}
                    for op in ["add", "mul"]:
                        if op in mods and isinstance(mods[op], (int, float)):
                            clean_mods[op] = float(mods[op])
                    if clean_mods:
                        stat_mods[stat] = clean_mods
            if stat_mods:
                sanitized["stat_modifiers"] = stat_mods
        
        # Handle list fields
        for list_field in ["roles_add", "abilities_add", "tags_add"]:
            if list_field in payload:
                if isinstance(payload[list_field], list):
                    clean_list = [str(item).strip() for item in payload[list_field] if str(item).strip()]
                elif isinstance(payload[list_field], str):
                    # Handle comma-separated strings
                    clean_list = [item.strip() for item in payload[list_field].split(",") if item.strip()]
                else:
                    continue
                
                if clean_list:
                    sanitized[list_field] = clean_list
        
        return sanitized
    
    def _sync_ui_to_variant(self, variant_data: dict):
        """Sync UI controls to match the attributes of the given variant."""
        if not isinstance(variant_data, dict):
            return
        
        # Try to infer culture from family_id or variant name/id
        family_id = variant_data.get("family_id", "")
        variant_name = variant_data.get("name", "")
        variant_id = variant_data.get("id", "")
        
        # Extract culture from family_id or name patterns
        cultures = ["concordant", "verdant", "crystalline", "ashen", "tempest"]
        detected_culture = None
        
        for culture in cultures:
            if (culture in family_id.lower() or 
                culture in variant_name.lower() or 
                culture in variant_id.lower()):
                detected_culture = culture
                break
        
        # Update quick creation culture combo if we detected a culture
        if detected_culture:
            culture_index = -1
            for i in range(self.quick_culture_combo.count()):
                if self.quick_culture_combo.itemText(i) == detected_culture:
                    culture_index = i
                    break
            
            if culture_index >= 0:
                self.quick_culture_combo.setCurrentIndex(culture_index)
        
        # Try to detect role from roles_add or variant name/id
        roles_add = variant_data.get("roles_add", [])
        social_roles = ["guard", "official", "scholar"]
        detected_role = None
        
        # Check roles_add first
        for role in social_roles:
            if role in roles_add:
                detected_role = role
                break
        
        # Fallback: check name/id patterns
        if not detected_role:
            for role in social_roles:
                if (role in variant_name.lower() or 
                    role in variant_id.lower()):
                    detected_role = role
                    break
        
        # Update quick creation role combo if we detected a role
        if detected_role:
            role_index = -1
            for i in range(self.quick_role_combo.count()):
                if self.quick_role_combo.itemText(i) == detected_role:
                    role_index = i
                    break
            
            if role_index >= 0:
                self.quick_role_combo.setCurrentIndex(role_index)

```

### File: core\base\__init__.py

```python
"""
Base package for the RPG game core.

This package contains the foundational classes for the game engine,
including state management, command processing, and configuration.
"""
```

### File: core\base\commands.py

```python
#!/usr/bin/env python3
"""
Command processing for the RPG game.

This module provides a framework for registering, parsing, and executing
player commands. It includes a CommandProcessor class for handling commands
and a CommandResult dataclass for representing command execution results.
"""

import re
import inspect
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple, Callable, Union
import logging
from enum import Enum, auto

from core.utils.logging_config import get_logger
from core.base.state import GameState

# Get the module logger
logger = get_logger("GAME")

class CommandStatus(Enum):
    """Status of a command execution."""
    SUCCESS = auto()
    FAILURE = auto()
    ERROR = auto()
    INVALID = auto()
    # Special statuses
    EXIT = auto()  # Command requests program exit
    HELP = auto()  # Command requests help


@dataclass
class CommandResult:
    """
    Result of a command execution.
    
    This dataclass contains information about the result of executing
    a command, including status, message, and any data produced.
    """
    status: CommandStatus
    message: str
    data: Optional[Dict[str, Any]] = None
    
    @classmethod
    def success(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create a success result."""
        return cls(CommandStatus.SUCCESS, message, data)
    
    @classmethod
    def failure(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create a failure result."""
        return cls(CommandStatus.FAILURE, message, data)
    
    @classmethod
    def error(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create an error result."""
        return cls(CommandStatus.ERROR, message, data)
    
    @classmethod
    def invalid(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create an invalid command result."""
        return cls(CommandStatus.INVALID, message, data)
    
    @classmethod
    def exit(cls, message: str = "Exiting the game.", data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create an exit result."""
        return cls(CommandStatus.EXIT, message, data)
    
    @classmethod
    def help(cls, message: str, data: Optional[Dict[str, Any]] = None) -> 'CommandResult':
        """Create a help result."""
        return cls(CommandStatus.HELP, message, data)
    
    @property
    def is_success(self) -> bool:
        """Check if the result is a success."""
        return self.status == CommandStatus.SUCCESS
    
    @property
    def is_failure(self) -> bool:
        """Check if the result is a failure."""
        return self.status in [CommandStatus.FAILURE, CommandStatus.ERROR, CommandStatus.INVALID]
    
    @property
    def is_exit(self) -> bool:
        """Check if the result requests an exit."""
        return self.status == CommandStatus.EXIT
    
    @property
    def is_help(self) -> bool:
        """Check if the result requests help."""
        return self.status == CommandStatus.HELP


class CommandProcessor:
    """
    Processor for parsing and executing commands.
    
    This class manages the registration of command handlers and the
    processing of player input into commands. It handles both built-in
    commands and commands extracted from LLM responses.
    """
    
    # Singleton instance
    _instance = None
    
    # Command handler type
    CommandHandler = Callable[[GameState, List[str]], CommandResult]
    
    # Command help data
    @dataclass
    class CommandHelp:
        """Help information for a command."""
        command: str
        syntax: str
        description: str
        examples: List[str] = field(default_factory=list)
        aliases: List[str] = field(default_factory=list)
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(CommandProcessor, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the command processor."""
        if self._initialized:
            return
        
        # Command handlers by name
        self._handlers: Dict[str, CommandProcessor.CommandHandler] = {}
        
        # Developer command handlers by name
        self._dev_handlers: Dict[str, CommandProcessor.CommandHandler] = {}
        
        # Command aliases (pointing to main command names)
        self._aliases: Dict[str, str] = {}
        
        # Help information by command name
        self._help_data: Dict[str, CommandProcessor.CommandHelp] = {}
        
        # LLM command extraction pattern
        self._llm_command_pattern = re.compile(r'\{([A-Z_]+)(?:\s+(.+?))?\}')
        
        # Register built-in meta commands (help, quit)
        self._register_meta_commands()
        
        self._initialized = True
    
    def _register_meta_commands(self):
        """Register meta commands like help and quit."""
        # Register the help command
        self.register_command(
            name="help",
            handler=self._help_command,
            syntax="help [command]",
            description="Display help information for commands.",
            examples=["help", "help save", "help inventory"],
            aliases=["?", "commands"]
        )
        
        # Register the quit command
        self.register_command(
            name="quit",
            handler=self._quit_command,
            syntax="quit",
            description="Exit the game.",
            examples=["quit"],
            aliases=["exit", "bye"]
        )
        
        # Register the save command
        self.register_command(
            name="save",
            handler=self._save_command,
            syntax="save [name]",
            description="Save the current game state.",
            examples=["save", "save my_adventure"],
            aliases=[]
        )
        
        # Register the load command
        self.register_command(
            name="load",
            handler=self._load_command,
            syntax="load <save_id_or_name>",
            description="Load a saved game state.",
            examples=["load 1", "load my_adventure"],
            aliases=[]
        )
        
        # Register the list_saves command
        self.register_command(
            name="list_saves",
            handler=self._list_saves_command,
            syntax="list_saves",
            description="List all available saved games.",
            examples=["list_saves"],
            aliases=["saves", "ls"]
        )
        
        # Register the look command
        self.register_command(
            name="look",
            handler=self._look_command,
            syntax="look [target]",
            description="Look around or examine something specific.",
            examples=["look", "look chest", "look north"],
            aliases=["examine", "inspect"]
        )
        
        # Register the llm command to toggle/check LLM status
        self.register_command(
            name="llm",
            handler=self._llm_command,
            syntax="llm [on|off|status]",
            description="Toggle or check the status of the LLM system.",
            examples=["llm on", "llm off", "llm status"],
            aliases=[]
        )
    
    def _help_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Display help information for commands.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional command name to get help for.
            
        Returns:
            CommandResult with help information.
        """
        # If a command was specified, check if it's a developer command
        if args and args[0]:
            command = args[0].lower()
            
            # Handle //help as a special case
            if command.startswith("//"):
                dev_command = command[2:]
                help_data = None
                
                # Check if it's in dev_handlers
                if dev_command in self._dev_handlers:
                    help_data = self.get_command_help(f"//dev:{dev_command}")
                
                if help_data:
                    # Build help text for specific command
                    help_text = [
                        f"Developer Command: {help_data.command}",
                        f"Syntax: {help_data.syntax}",
                        f"Description: {help_data.description[6:]}"  # Remove [DEV] prefix
                    ]
                    
                    if help_data.examples:
                        help_text.append("Examples:")
                        for example in help_data.examples:
                            help_text.append(f"  {example}")
                    
                    return CommandResult.success("\n".join(help_text))
                else:
                    return CommandResult.failure(f"No help available for developer command '{dev_command}'.")
            
            # If args[0] is "dev", show all developer commands
            if command == "dev":
                dev_commands = self.get_all_dev_commands()
                if not dev_commands:
                    return CommandResult.success("No developer commands are currently registered.")
                
                dev_commands.sort()  # Alphabetical order
                
                help_text = ["Available Developer Commands:"]
                
                for cmd in dev_commands:
                    help_data = self.get_command_help(f"//dev:{cmd}")
                    if help_data:
                        # Add a short description for each command
                        description = help_data.description.split('.')[0][6:] + '.'  # First sentence, remove [DEV] prefix
                        help_text.append(f"  //{cmd}: {description}")
                
                help_text.append("\nType '//<command>' to use a developer command.")
                help_text.append("Type 'help //command' for more information on a specific developer command.")
                
                return CommandResult.success("\n".join(help_text))
            
            # For regular commands
            help_data = self.get_command_help(command)
            
            if not help_data:
                return CommandResult.failure(f"No help available for '{command}'. Type 'help' for a list of commands.")
            
            # Build help text for specific command
            help_text = [
                f"Command: {help_data.command}",
                f"Syntax: {help_data.syntax}",
                f"Description: {help_data.description}"
            ]
            
            if help_data.aliases:
                help_text.append(f"Aliases: {', '.join(help_data.aliases)}")
            
            if help_data.examples:
                help_text.append("Examples:")
                for example in help_data.examples:
                    help_text.append(f"  {example}")
            
            return CommandResult.success("\n".join(help_text))
        
        # Otherwise, show a list of all commands
        commands = self.get_all_commands()
        commands.sort()  # Alphabetical order
        
        help_text = ["Available commands:"]
        
        for cmd in commands:
            help_data = self.get_command_help(cmd)
            if help_data:
                # Add a short description for each command
                description = help_data.description.split('.')[0] + '.'  # First sentence
                help_text.append(f"  {cmd}: {description}")
        
        help_text.append("\nType 'help <command>' for more information on a specific command.")
        
        # Add information about developer commands
        dev_commands = self.get_all_dev_commands()
        if dev_commands:
            help_text.append("\nDeveloper Commands:")
            help_text.append("Use '/help dev' to see available developer commands.")
        
        return CommandResult.success("\n".join(help_text))
    
    def _quit_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Exit the game.
        
        Args:
            game_state: The current game state.
            args: Command arguments (ignored).
            
        Returns:
            CommandResult with EXIT status.
        """
        return CommandResult.exit("Exiting the game. Thank you for playing!")
    
    def _save_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Save the current game state.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional save name.
            
        Returns:
            CommandResult indicating success or failure.
        """
        import uuid
        from core.utils.save_manager import SaveManager
        
        # Get save name if provided
        save_name = args[0] if args else f"Save_{game_state.player.name}_{game_state.game_time.get_formatted_time()}"
        
        try:
            # Generate a unique ID for the save
            save_id = str(uuid.uuid4())
            
            # Create the save using the StateManager
            game_state.state_manager.save_game(save_id)
            
            # Update metadata with the SaveManager
            save_manager = SaveManager()
            save_manager.update_metadata(
                save_id=save_id,
                updates={
                    "save_name": save_name,
                    "player_name": game_state.player.name,
                    "player_level": game_state.player.level,
                    "world_time": game_state.game_time.get_formatted_time(),
                    "location": game_state.world.current_location,
                    "playtime": game_state.playtime
                }
            )
            
            return CommandResult.success(f"Game saved as '{save_name}'.")
        except Exception as e:
            logger.error(f"Error saving game: {e}", exc_info=True)
            return CommandResult.error(f"Failed to save game: {str(e)}")
    
    def _load_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Load a saved game state.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Required save ID or name.
            
        Returns:
            CommandResult indicating success or failure.
        """
        from core.utils.save_manager import SaveManager
        
        if not args:
            return CommandResult.invalid("Please specify a save ID or name to load.")
        
        save_id_or_name = args[0]
        save_manager = SaveManager()
        
        try:
            # First, try to interpret the argument as a save ID
            save_id = save_id_or_name
            
            # If it's not a UUID, try to find a save with the given name
            if not self._is_valid_uuid(save_id):
                # Get all saves and look for a name match
                saves = save_manager.get_save_list()
                for save in saves:
                    if save.save_name.lower() == save_id_or_name.lower():
                        save_id = save.save_id
                        break
                else:
                    return CommandResult.failure(f"No save found with ID or name '{save_id_or_name}'.")
            
            # Now load the game
            success = game_state.state_manager.load_game(save_id)
            
            if success:
                return CommandResult.success(f"Game loaded successfully.")
            else:
                return CommandResult.failure(f"Failed to load game with ID '{save_id}'.")
                
        except Exception as e:
            logger.error(f"Error loading game: {e}", exc_info=True)
            return CommandResult.error(f"Failed to load game: {str(e)}")
    
    def _look_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Look around or examine something specific.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional target to examine.
            
        Returns:
            CommandResult with description.
        """
        # Process the look command directly if LLM is disabled
        # Otherwise, it should be handled by the LLM
        from core.base.engine import get_game_engine
        engine = get_game_engine()
        
        # If LLM is enabled, this command should not be directly processed
        # The engine should route it to the LLM system
        if engine._use_llm:
            return CommandResult.success("This command should be processed by the LLM system. If you're seeing this message, there might be an issue with LLM integration.")
        
        # Basic fallback implementation for when LLM is disabled
        location = game_state.player.current_location
        target = " ".join(args) if args else None
        
        if not target:
            # Look around the current location
            return CommandResult.success(
                f"You are in {location}. This is a simple placeholder description since the LLM system is disabled."
                f"\nUse '/llm on' command to enable the LLM system for rich descriptions."
            )
        else:
            # Look at a specific target
            return CommandResult.success(
                f"You examine the {target}. This is a simple placeholder description since the LLM system is disabled."
                f"\nUse '/llm on' command to enable the LLM system for rich descriptions."
            )

    def _llm_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        Toggle or check the status of the LLM system.
        
        Args:
            game_state: The current game state.
            args: Command arguments. Optional subcommand (on, off, status).
            
        Returns:
            CommandResult indicating success or failure.
        """
        # Get the game engine (needed to toggle LLM)
        from core.base.engine import get_game_engine
        engine = get_game_engine()
        
        # Check if any arguments were provided
        if not args:
            # No arguments, just show status
            status = "enabled" if engine._use_llm else "disabled"
            return CommandResult.success(f"LLM system is currently {status}.")
        
        # Process the subcommand
        subcommand = args[0].lower()
        
        if subcommand == "on" or subcommand == "enable":
            engine.set_llm_enabled(True)
            return CommandResult.success("LLM system enabled.")
        
        elif subcommand == "off" or subcommand == "disable":
            engine.set_llm_enabled(False)
            return CommandResult.success("LLM system disabled.")
        
        elif subcommand == "status":
            status = "enabled" if engine._use_llm else "disabled"
            return CommandResult.success(f"LLM system is currently {status}.")
        
        else:
            return CommandResult.invalid(f"Unknown subcommand: {subcommand}. Use 'on', 'off', or 'status'.")
    
    def _list_saves_command(self, game_state: GameState, args: List[str]) -> CommandResult:
        """
        List all available saved games.
        
        Args:
            game_state: The current game state.
            args: Command arguments (ignored).
            
        Returns:
            CommandResult with list of saves.
        """
        from core.utils.save_manager import SaveManager
        
        try:
            save_manager = SaveManager()
            saves = save_manager.get_save_list()
            
            if not saves:
                return CommandResult.success("No saved games found.")
            
            result_lines = ["Available saved games:"]
            
            for i, save in enumerate(saves, 1):
                # Format: 1. Save Name (Player Name, Level X) - 2023-04-15 14:30
                result_lines.append(
                    f"{i}. {save.save_name} ({save.player_name}, Level {save.player_level}) - {save.formatted_save_time}"
                )
            
            result_lines.append("\nUse 'load <save_name>' to load a saved game.")
            
            return CommandResult.success("\n".join(result_lines))
        except Exception as e:
            logger.error(f"Error listing saves: {e}", exc_info=True)
            return CommandResult.error(f"Failed to list saves: {str(e)}")
    
    def _is_valid_uuid(self, uuid_str: str) -> bool:
        """Check if a string is a valid UUID."""
        try:
            import uuid
            uuid.UUID(uuid_str)
            return True
        except (ValueError, AttributeError):
            return False
    
    def register_command(self, 
                         name: str, 
                         handler: CommandHandler,
                         syntax: str = "",
                         description: str = "",
                         examples: List[str] = None,
                         aliases: List[str] = None) -> None:
        """
        Register a command handler.
        
        Args:
            name: The name of the command.
            handler: The function to handle the command.
            syntax: The command syntax.
            description: A description of the command.
            examples: Example usages of the command.
            aliases: Alternative names for the command.
        """
        # Register the handler
        self._handlers[name.lower()] = handler
        
        # Register help information
        self._help_data[name.lower()] = CommandProcessor.CommandHelp(
            command=name.lower(),
            syntax=syntax or f"{name} [args...]",
            description=description or "No description available.",
            examples=examples or [],
            aliases=aliases or []
        )
        
        # Register aliases
        if aliases:
            for alias in aliases:
                self._aliases[alias.lower()] = name.lower()
        
        logger.debug(f"Registered command: {name}")
        
    def register_dev_command(self, 
                           name: str, 
                           handler: CommandHandler,
                           syntax: str = "",
                           description: str = "",
                           examples: List[str] = None) -> None:
        """
        Register a developer command handler.
        
        Args:
            name: The name of the command (without // prefix).
            handler: The function to handle the command.
            syntax: The command syntax.
            description: A description of the command.
            examples: Example usages of the command.
        """
        if examples is None:
            examples = []
            
        # Add the handler to dev_handlers
        self._dev_handlers[name.lower()] = handler
        
        # Add help information (reusing the same help system)
        self._help_data[f"//dev:{name.lower()}"] = CommandProcessor.CommandHelp(
            command=f"//{name.lower()}",
            syntax=syntax or f"//{name} [args...]",
            description=f"[DEV] {description or 'No description available.'}",
            examples=[f"//{ex}" for ex in examples] if examples else [],
            aliases=[]
        )
        
        logger.debug(f"Registered developer command: //{name}")
    
    def get_command_handler(self, command: str) -> Optional[CommandHandler]:
        """
        Get the handler for a command.
        
        Args:
            command: The command name.
        
        Returns:
            The command handler, or None if not found.
        """
        command = command.lower()
        
        # Check for direct command
        if command in self._handlers:
            return self._handlers[command]
        
        # Check for alias
        if command in self._aliases:
            return self._handlers[self._aliases[command]]
        
        return None
    
    def get_all_commands(self) -> List[str]:
        """
        Get a list of all registered commands.
        
        Returns:
            A list of command names.
        """
        return list(self._handlers.keys())
        
    def get_all_dev_commands(self) -> List[str]:
        """
        Get a list of all registered developer commands.
        
        Returns:
            A list of command names.
        """
        return list(self._dev_handlers.keys())
    
    def get_command_help(self, command: str) -> Optional[CommandHelp]:
        """
        Get help information for a command.
        
        Args:
            command: The command name.
        
        Returns:
            The command help, or None if not found.
        """
        command = command.lower()
        
        # Check for direct command
        if command in self._help_data:
            return self._help_data[command]
        
        # Check for alias
        if command in self._aliases:
            return self._help_data[self._aliases[command]]
        
        return None
    
    def process_command(self, game_state: GameState, command_text: str) -> CommandResult:
        """
        Process a command.
        
        Args:
            game_state: The current game state.
            command_text: The command text to process.
        
        Returns:
            The result of executing the command.
        """
        if not command_text:
            return CommandResult.invalid("Please enter a command.")
        
        # Update last command in game state
        game_state.last_command = command_text
        
        # Check if it's a developer command (starts with //)
        if command_text.startswith("//"):
            # Extract the command name (without //)
            parts = command_text[2:].split(maxsplit=1)
            command_name = parts[0].lower()
            args = parts[1] if len(parts) > 1 else ""
            
            # Get the developer command handler
            handler = self._dev_handlers.get(command_name)
            if handler is None:
                return CommandResult.invalid(f"Unknown developer command: {command_name}")
            
            try:
                # Execute the command
                logger.debug(f"Executing developer command: {command_name} with args: {args}")
                
                # Parse args
                arg_list = []
                if args:
                    # This regex splits by spaces except within quoted strings
                    arg_pattern = re.compile(r'(?:[^\s,"]|"(?:\\.|[^"])*")++') 
                    arg_list = arg_pattern.findall(args)
                    
                    # Remove quotes from quoted arguments
                    arg_list = [
                        arg[1:-1] if (arg.startswith('"') and arg.endswith('"')) else arg 
                        for arg in arg_list
                    ]
                
                # Call the handler
                result = handler(game_state, arg_list)
                
                # Log the result
                if result.is_success:
                    logger.debug(f"Developer command {command_name} succeeded: {result.message}")
                else:
                    logger.debug(f"Developer command {command_name} failed: {result.message}")
                
                return result
            except Exception as e:
                logger.error(f"Error executing developer command {command_name}: {e}", exc_info=True)
                return CommandResult.error(f"Error executing developer command: {e}")
        
        # Add to conversation history (if not a system command) - moved here after developer command check
        if not command_text.startswith("/"):
            game_state.add_conversation_entry("player", command_text)
            
            # In a full implementation, this would be sent to an LLM agent for natural
            # language processing. For now, we'll just treat it as a direct command.
            # We'll still parse as a command for the basic framework.
        
        # Parse the command (strip leading / if present)
        command_text = command_text.lstrip("/")
        parts = command_text.split(maxsplit=1)
        command_name = parts[0].lower()
        args = parts[1] if len(parts) > 1 else ""
        
        # Get the command handler
        handler = self.get_command_handler(command_name)
        if handler is None:
            return CommandResult.invalid(f"Unknown command: {command_name}")
        
        try:
            # Execute the command
            logger.debug(f"Executing command: {command_name} with args: {args}")
            
            # Split args by whitespace, but respect quoted strings
            arg_list = []
            if args:
                # This regex splits by spaces except within quoted strings
                arg_pattern = re.compile(r'(?:[^\s,"]|"(?:\\.|[^"])*")++') 
                arg_list = arg_pattern.findall(args)
                
                # Remove quotes from quoted arguments
                arg_list = [
                    arg[1:-1] if (arg.startswith('"') and arg.endswith('"')) else arg 
                    for arg in arg_list
                ]
            
            # Call the handler
            result = handler(game_state, arg_list)
            
            # Log the result
            if result.is_success:
                logger.debug(f"Command {command_name} succeeded: {result.message}")
            else:
                logger.debug(f"Command {command_name} failed: {result.message}")
            
            return result
        except Exception as e:
            logger.error(f"Error executing command {command_name}: {e}", exc_info=True)
            return CommandResult.error(f"Error executing command: {e}")
    
    def extract_llm_commands(self, text: str) -> List[Tuple[str, str]]:
        """
        Extract LLM commands from text.
        
        Args:
            text: The text to extract commands from.
        
        Returns:
            A list of (command, args) tuples.
        """
        matches = self._llm_command_pattern.findall(text)
        return [(command, args or "") for command, args in matches]
    
    def process_llm_commands(self, game_state: GameState, text: str) -> Tuple[str, List[CommandResult]]:
        """
        Process LLM commands embedded in text.
        
        Args:
            game_state: The current game state.
            text: The text containing LLM commands.
        
        Returns:
            A tuple of (processed_text, command_results).
        """
        # Extract commands
        commands = self.extract_llm_commands(text)
        
        # Store results
        results = []
        
        # Process each command and replace in the text
        processed_text = text
        
        for cmd, args in commands:
            # Check if command is registered
            handler = self.get_command_handler(cmd)
            
            if handler:
                # Split args
                arg_list = args.split() if args else []
                
                # Execute the command
                try:
                    result = handler(game_state, arg_list)
                    results.append(result)
                    
                    # Replace the command in the text with its result
                    pattern = rf'\{{{cmd}(?:\s+{re.escape(args)})?\}}'
                    replacement = result.message if result.is_success else f"[Command Error: {result.message}]"
                    processed_text = re.sub(pattern, replacement, processed_text)
                except Exception as e:
                    logger.error(f"Error executing LLM command {cmd}: {e}", exc_info=True)
                    pattern = rf'\{{{cmd}(?:\s+{re.escape(args)})?\}}'
                    processed_text = re.sub(pattern, f"[Command Error: {e}]", processed_text)
            else:
                # Unknown command
                logger.warning(f"Unknown LLM command: {cmd}")
                pattern = rf'\{{{cmd}(?:\s+{re.escape(args)})?\}}'
                processed_text = re.sub(pattern, f"[Unknown Command: {cmd}]", processed_text)
        
        return processed_text, results


# Convenience function
def get_command_processor() -> CommandProcessor:
    """Get the command processor instance."""
    return CommandProcessor()


# Example usage (this would be filled in during the Command Handlers phase)
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.DEBUG)
    
    # Get the command processor - commands are now registered automatically
    processor = get_command_processor()
    
    print("Command registration example")
    print("Commands:", processor.get_all_commands())
    
    # Example of command processing
    from core.base.state import GameState, PlayerState, WorldState
    game_state = GameState(player=PlayerState(name="Test Player"))
    
    result = processor.process_command(game_state, "help")
    print(f"Result: {result.message}")
    
    # Test a few basic commands
    print("\nTesting more commands:")
    commands = ["quit", "help save", "list_saves"]
    
    for cmd in commands:
        print(f"\nExecuting: {cmd}")
        result = processor.process_command(game_state, cmd)
        print(f"Status: {result.status}")
        print(f"Result: {result.message}")
    
    # Example of LLM command processing
    text = "You find a chest. {ITEM_CREATE chest common container}"
    processed_text, results = processor.process_llm_commands(game_state, text)
    print(f"\nProcessed text: {processed_text}")
```

### File: core\base\config.py

```python
#!/usr/bin/env python3
"""
Configuration management for the RPG game.

This module provides a GameConfig class for loading, managing, and accessing
configuration data from JSON files.
"""

import os
import logging
from typing import Any, Dict, List, Optional, Tuple, Union
import json

from core.utils.json_utils import load_json, save_json
from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

class GameConfig:
    """
    Game configuration manager.

    This class handles loading configuration from JSON files,
    providing access to configuration values, and saving
    updated configurations.

    It supports dot notation for accessing nested configuration values
    (e.g., config.get("gui.window.width")).
    """

    # Singleton instance
    _instance = None

    # Default configuration directory relative to project root
    _CONFIG_DIR = "config"

    # Default configuration files, mapping domain to relative path within _CONFIG_DIR
    _DEFAULT_CONFIG_FILES = {
        "game": "game_config.json",
        "system": "system_config.json",
        "gui": "gui_config.json",
        "llm": "llm/base_config.json", # Added LLM config
        "combat_display_settings": "combat_display_settings.json",
        "combat": os.path.join("combat", "combat_config.json"),
        "classes": os.path.join("character", "classes.json"),
        "races": os.path.join("character", "races.json"),
        "origins": os.path.join("world", "scenarios", "origins.json"),
        "quests": os.path.join("world", "scenarios", "quests.json"),
        "locations": os.path.join("world", "locations", "locations.json"),
        "aliases": os.path.join("world", "aliases.json"),
        # New NPC configuration domains (families system)
        "npc_families": os.path.join("npc", "families.json"),
        "npc_families_factions": os.path.join("npc", "families_factions.json"),
        "npc_variants": os.path.join("npc", "variants.json"),
        "npc_tags": os.path.join("npc", "tags.json"),
        "npc_roles": os.path.join("npc", "roles.json"),
        "npc_abilities": os.path.join("npc", "abilities.json"),
        "npc_boss_overlays": os.path.join("npc", "boss_overlays.json"),
        "npc_generation_rules": os.path.join("npc", "generation_rules.json"),
        "npc_entity_aliases": os.path.join("aliases", "entities.json"),
        # Legacy NPC templates for name pools (read-only, temporary during migration)
        "npc_legacy_templates": os.path.join("character", "npc_templates.json"),
        # Names guidance for LLM and generator
        "npc_names": os.path.join("npc", "names.json"),
        # World location defaults (e.g., culture mix)
        "location_defaults": os.path.join("world", "locations", "defaults.json"),
    }

    # Configurations loaded from files
    _config_data: Dict[str, Dict[str, Any]] = {}

    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(GameConfig, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self, config_dir: str = None):
        """Initialize the configuration."""
        # Prevent re-initialization
        if hasattr(self, '_initialized') and self._initialized:
            return

        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        self._config_dir_abs = os.path.join(project_root, config_dir or self._CONFIG_DIR)

        self._config_data = {}

        os.makedirs(self._config_dir_abs, exist_ok=True)

        for domain in self._DEFAULT_CONFIG_FILES:
            self._config_data[domain] = {}

        # Load configurations
        self._load_all_configs()

        self._initialized = True

    def _load_all_configs(self):
        """Load all configuration files."""
        for domain, filename_rel in self._DEFAULT_CONFIG_FILES.items():
            self._load_config(domain, filename_rel)

    def _load_config(self, domain: str, filename_rel: str):
        """
        Load a configuration file for the specified domain.

        Args:
            domain: The configuration domain name (e.g., "game", "classes").
            filename_rel: The relative path of the file within the config directory
                          (e.g., "game_config.json", "character/classes.json").
        """
        # Construct the absolute file path
        file_path = os.path.join(self._config_dir_abs, filename_rel)

        # Log the attempt
        logger.info(f"Attempting to load configuration for domain '{domain}' from: {file_path}")

        # If the file doesn't exist, handle defaults or warnings
        if not os.path.exists(file_path):
            # Only create defaults for the original base configs
            if domain in ["game", "system", "gui", "llm"]: # Add llm here if it needs defaults
                logger.warning(f"Config file for '{domain}' not found. Creating default: {file_path}")
                self._create_default_config(domain, file_path) # Pass absolute path
            else:
                # For other configs like classes, races, origins just warn and set empty data
                logger.warning(f"Configuration file for domain '{domain}' not found at {file_path}. Skipping load.")
                self._config_data[domain] = {} # Ensure domain exists but is empty
            return # Stop processing if file doesn't exist (and wasn't created)

        try:
            loaded_data = load_json(file_path)
            if loaded_data is None: # Check if load_json returned None
                 logger.error(f"Failed to load or parse JSON for domain '{domain}' from {file_path}")
                 self._config_data[domain] = {} # Ensure domain exists but is empty
                 return

            # --- Specific Handling for files with top-level keys ---
            # Check if the domain is 'classes' and the loaded data has a top-level 'classes' key
            if domain == "classes" and isinstance(loaded_data, dict) and "classes" in loaded_data:
                self._config_data[domain] = loaded_data["classes"]
                logger.debug(f"Extracted 'classes' key content for domain '{domain}'.")
            # Check if the domain is 'races' and the loaded data has a top-level 'races' key
            elif domain == "races" and isinstance(loaded_data, dict) and "races" in loaded_data:
                self._config_data[domain] = loaded_data["races"]
                logger.debug(f"Extracted 'races' key content for domain '{domain}'.")
            # Check if the domain is 'origins' and the loaded data has a top-level 'origins' key
            elif domain == "origins" and isinstance(loaded_data, dict) and "origins" in loaded_data:
                 self._config_data[domain] = loaded_data["origins"]
                 logger.info(f"Extracted 'origins' key content for domain '{domain}'.")
                 # Add a check for the structure - expecting a dict of origins
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'origins' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {} # Reset if structure is wrong
            # Check if the domain is 'quests' and the loaded data has a top-level 'quests' key
            elif domain == "quests" and isinstance(loaded_data, dict) and "quests" in loaded_data:
                 self._config_data[domain] = loaded_data["quests"]
                 logger.info(f"Extracted 'quests' key content for domain '{domain}'.")
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'quests' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {}
            # Check if the domain is 'locations' and the loaded data has a top-level 'locations' key
            elif domain == "locations" and isinstance(loaded_data, dict) and "locations" in loaded_data:
                 self._config_data[domain] = loaded_data["locations"]
                 logger.debug(f"Extracted 'locations' key content for domain '{domain}'.")
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'locations' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {}
            # Aliases domain may or may not have top-level 'aliases' key; accept either
            elif domain == "aliases" and isinstance(loaded_data, dict):
                 self._config_data[domain] = loaded_data.get("aliases", loaded_data)
                 if not isinstance(self._config_data[domain], dict):
                      logger.warning(f"Loaded 'aliases' data for domain '{domain}' is not a dictionary. Check file structure.")
                      self._config_data[domain] = {}
            else:
                # Default behavior: store the entire loaded data
                self._config_data[domain] = loaded_data

            logger.info(f"Successfully loaded configuration for domain '{domain}'.")


        except Exception as e:
            logger.exception(f"Error loading configuration for domain '{domain}' from {file_path}: {e}")
            # Ensure domain exists even on error, maybe with empty data
            if domain not in self._config_data:
                self._config_data[domain] = {}

    def _create_default_config(self, domain: str, file_path: str):
        """
        Create a default configuration file for the specified domain.

        Args:
            domain: The configuration domain name.
            file_path: The absolute path where the file should be created.
        """
        # Define default configurations
        default_configs = {
            "game": {
                "version": "0.1.0",
                "title": "RPG Game",
                "default_save_slot": "auto",
                "auto_save_interval": 300,  # seconds
                "max_save_slots": 10,
            },
            "system": {
                "log_level": "INFO",
                "log_to_file": True,
                "log_to_console": True,
                "debug_mode": False,
                "save_dir": "saves", # Relative to project root
                "log_dir": "logs",   # Relative to project root
            },
            "gui": {
                "resolution": {
                    "width": 1280,
                    "height": 720,
                },
                "fullscreen": False,
                "theme": "default",
                "font_size": 12,
                "show_fps": False,
            },
            "llm": {
                 "default_provider_type": "GOOGLE", # Changed default
                 "default_temperature": 0.7,
                 "max_tokens": 1500, # Increased default
                 "timeout_seconds": 45, # Increased default
                 "retry_attempts": 2,
                 "retry_delay_seconds": 3,
                 "run_diagnostics_on_start": False,
                 "log_prompts": False, # Changed default
                 "log_completions": False, # Changed default
                 "cost_tracking_enabled": True,
                 "enabled": True # Explicitly add enabled flag
            }
            # No defaults needed for classes/races/origins here, as they should exist
        }

        default_config = default_configs.get(domain, {})
        if not default_config:
             logger.warning(f"No default configuration defined for domain '{domain}'")
             return # Don't create empty files for non-base domains

        self._config_data[domain] = default_config # Update in-memory config too

        try:
            # Create directory if it doesn't exist (handles nested paths)
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            # Save default configuration
            save_json(default_config, file_path)
            logger.info(f"Created default configuration for {domain} at {file_path}")
        except Exception as e:
            logger.error(f"Error creating default configuration for {domain} at {file_path}: {e}")

    def get(self, key_path: str, default: Any = None) -> Any:
        """
        Get a configuration value using dot notation.

        Args:
            key_path: The path to the configuration value (e.g., "gui.resolution.width", "origins.harmonia_initiate.description").
            default: The default value to return if the key is not found.

        Returns:
            The configuration value, or the default if not found.
        """
        # Split the key path into parts
        parts = key_path.split(".")

        # The first part is the domain (e.g., "gui", "origins")
        domain = parts[0]

        # If the domain doesn't exist in our loaded data, return the default
        if domain not in self._config_data:
            return default

        # Start with the domain's configuration data
        current = self._config_data[domain]

        # Traverse the configuration hierarchy using the remaining parts
        for part in parts[1:]:
            # Check if current level is a dictionary and the key exists
            if isinstance(current, dict):
                if part in current:
                    current = current[part]
                else:
                    # Key not found at this level
                    return default
            # Check if current level is a list and the key is an integer index
            elif isinstance(current, list):
                 try:
                      index = int(part)
                      if 0 <= index < len(current):
                           current = current[index]
                      else:
                           # Index out of bounds
                           return default
                 except ValueError:
                      # Key is not a valid integer index for the list
                      return default
            else:
                 # Current level is not a dict or list, cannot traverse further
                 return default


        return current

    def set(self, key_path: str, value: Any) -> bool:
        """
        Set a configuration value using dot notation and save the corresponding file.

        Args:
            key_path: The path to the configuration value (e.g., "gui.resolution.width").
            value: The value to set.

        Returns:
            True if the value was set and saved successfully, False otherwise.
        """
        # Split the key path into parts
        parts = key_path.split(".")

        # The first part is the domain (e.g., "gui")
        domain = parts[0]

        # Check if the domain is known (has a default file mapping)
        if domain not in self._DEFAULT_CONFIG_FILES:
             logger.error(f"Cannot set configuration for unknown domain '{domain}'. Add it to _DEFAULT_CONFIG_FILES.")
             return False

        # If the domain doesn't exist in data, create it
        if domain not in self._config_data:
            logger.warning(f"Domain '{domain}' not found in configuration data, creating it.")
            self._config_data[domain] = {}

        # Start with the domain's configuration
        current = self._config_data[domain]

        # Traverse the configuration hierarchy, creating nodes as needed
        for part in parts[1:-1]:
            if part not in current or not isinstance(current[part], dict):
                 # If key doesn't exist or is not a dict, create/overwrite with a dict
                current[part] = {}
            current = current[part]

        # Set the final value
        final_key = parts[-1]
        # Ensure the final level is a dictionary before setting
        if not isinstance(current, dict):
             logger.error(f"Cannot set '{key_path}': Intermediate path does not lead to a dictionary.")
             return False

        current[final_key] = value
        logger.info(f"Set configuration '{key_path}' to: {value}")

        # --- Save the updated configuration file ---
        try:
            filename_rel = self._DEFAULT_CONFIG_FILES[domain]
            file_path = os.path.join(self._config_dir_abs, filename_rel)

            # Prepare data to save - handle potential top-level keys for specific domains
            data_to_save = self._config_data[domain]
            if domain == "classes":
                data_to_save = {"classes": self._config_data[domain]}
            elif domain == "races":
                 data_to_save = {"races": self._config_data[domain]}
            elif domain == "origins": # Added origins handler
                 data_to_save = {"origins": self._config_data[domain]}
            elif domain == "quests": # Added quests handler
                 data_to_save = {"quests": self._config_data[domain]}
            elif domain == "locations": # Added locations handler
                 data_to_save = {"locations": self._config_data[domain]}

            # Ensure the directory exists before saving
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            save_json(data_to_save, file_path)
            logger.info(f"Saved updated configuration for domain '{domain}' to {file_path}")
            return True
        except Exception as e:
            logger.exception(f"Error saving configuration for domain '{domain}' to {file_path}: {e}")
            return False

    def get_all(self, domain: str = None) -> Dict[str, Any]:
        """
        Get all configuration values for a domain, or all domains.

        Args:
            domain: The domain to get (e.g., "gui", "origins"). If None, return all domains.

        Returns:
            A dictionary of configuration values. Returns an empty dict if domain not found.
        """
        if domain is None:
            # Return a copy to prevent external modification
            return self._config_data.copy()

        if domain not in self._config_data:
            logger.warning(f"Domain '{domain}' not found in configuration")
            return {}

        # Return a copy
        return self._config_data[domain].copy()

    def reload(self, domain: str = None) -> bool:
        """
        Reload configuration from files.

        Args:
            domain: The domain to reload (e.g., "gui", "origins"). If None, reload all domains.

        Returns:
            True if the configuration was reloaded successfully, False otherwise.
        """
        logger.info(f"Reloading configuration for domain: {'ALL' if domain is None else domain}")
        try:
            if domain is None:
                self._load_all_configs()
                logger.info("Reloaded all configurations.")
                return True

            if domain not in self._DEFAULT_CONFIG_FILES:
                logger.warning(f"Cannot reload unknown domain '{domain}'.")
                return False

            filename_rel = self._DEFAULT_CONFIG_FILES[domain]
            self._load_config(domain, filename_rel)
            logger.info(f"Reloaded configuration for domain '{domain}'.")
            return True
        except Exception as e:
            logger.exception(f"Error reloading configuration: {e}")
            return False

    def validate(self) -> Tuple[bool, List[str]]:
        """
        Validate the configuration. (Basic validation for now)

        Returns:
            A tuple of (is_valid, error_messages).
        """
        is_valid = True
        errors = []

        # Updated required domains list
        required_domains = ["game", "system", "gui", "llm", "classes", "races", "origins"]
        for domain in required_domains:
            if domain not in self._config_data or not self._config_data[domain]:
                # Allow empty if the file genuinely didn't exist and wasn't required to have defaults
                filename_rel = self._DEFAULT_CONFIG_FILES.get(domain)
                if filename_rel:
                    file_path = os.path.join(self._config_dir_abs, filename_rel)
                    # Check if the file exists OR if it's a base config that should have defaults
                    if os.path.exists(file_path) or domain in ["game", "system", "gui", "llm"]:
                         is_valid = False
                         error = f"Configuration for domain '{domain}' is missing or empty."
                         errors.append(error)
                         logger.error(error)
                else: # Domain not even in default files - should not happen with current logic
                     is_valid = False
                     error = f"Configuration for domain '{domain}' is missing entirely."
                     errors.append(error)
                     logger.error(error)


        if is_valid:
            logger.info("Configuration validation passed.")
        else:
            logger.warning(f"Configuration validation failed: {errors}")

        return is_valid, errors


# Convenience functions

def get_config() -> GameConfig:
    """Get the game configuration singleton instance."""
    return GameConfig()


# Example usage
if __name__ == "__main__":
    # Set up basic logging for example run
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    print("--- Initializing Config ---")
    config = get_config()
    print("\n--- Config Initialized ---")

    # Validate after load
    config.validate()

    # Get some values
    print("\n--- Getting Values ---")
    resolution_width = config.get("gui.resolution.width")
    print(f"GUI Resolution width: {resolution_width}")

    log_level = config.get("system.log_level", "DEBUG") # Example with default
    print(f"System Log Level: {log_level}")

    # Try getting a class description
    warrior_desc = config.get("classes.Warrior.description")
    if warrior_desc:
        print(f"Warrior Description: {warrior_desc}")
    else:
        print("Warrior class description not found (or classes.json missing/empty).")

    # Try getting an origin description
    harmonia_initiate_desc = config.get("origins.harmonia_initiate.description")
    if harmonia_initiate_desc:
         print(f"Harmonia Initiate Description: {harmonia_initiate_desc}")
    else:
         print("Harmonia Initiate origin not found (or origins.json missing/empty).")


    # Try getting a non-existent value
    non_existent = config.get("game.some_new_setting.value", "DefaultValue")
    print(f"Non-existent setting: {non_existent}")

    # Get all config for a domain
    print("\n--- Getting All GUI Config ---")
    gui_config = config.get_all("gui")
    print(json.dumps(gui_config, indent=2))

    print("\n--- Getting All Origins Config ---")
    origins_config = config.get_all("origins")
    if origins_config:
         print(f"Number of origins loaded: {len(origins_config)}")
         # print(json.dumps(origins_config, indent=2)) # Might be large
    else:
        print("No origins configuration loaded.")


    # Set a value (will save gui_config.json)
    print("\n--- Setting Value ---")
    success = config.set("gui.font_size", 14)
    print(f"Set gui.font_size success: {success}")
    print(f"New gui.font_size: {config.get('gui.font_size')}")

    # Reload config
    print("\n--- Reloading Config ---")
    config.reload("gui")
    print(f"Reloaded gui.font_size: {config.get('gui.font_size')}") # Should be 14 if save worked

    print("\n--- Example Finished ---")
```

### File: core\base\engine.py

```python
#!/usr/bin/env python3
"""
Game engine for the RPG game.

This module provides the central GameEngine class that coordinates
between state management, command processing, and game loop components.
"""


import time
from typing import Any, Dict, Optional
from PySide6.QtCore import QObject, Signal, Slot
from core.combat.enums import CombatStep, CombatState
from core.interaction.enums import InteractionMode
from core.orchestration.events import DisplayEventType
from core.utils.logging_config import get_logger
from core.base.state import StateManager, GameState
from core.base.commands import CommandProcessor, CommandResult
from core.base.game_loop import GameLoop, GameSpeed
from core.base.config import get_config
from core.agents.agent_manager import get_agent_manager 
from core.agents.rule_checker import RuleCheckerAgent
from core.agents.combat_narrator import get_combat_narrator_agent 
from core.stats.stats_manager import get_stats_manager 
from core.character.npc_manager import get_npc_manager as get_entity_manager 
from core.inventory.item_manager import get_inventory_manager as get_item_manager 
from core.inventory import register_inventory_commands 

# Import the new game flow modules
from core.game_flow import lifecycle
from core.game_flow import command_router
from core.game_flow.input_router import get_input_router

logger = get_logger("GAME_ENGINE") 

class GameEngine(QObject): 
    """
    Central game engine.
    
    This class coordinates between the state manager, command processor,
    and game loop. It provides a high-level API for controlling the game.
    """
    output_generated = Signal(str, str) 
    
    _instance = None
    orchestrated_event_to_ui = Signal(object)

    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(GameEngine, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the game engine."""
        if hasattr(self, '_initialized') and self._initialized:
            return
        
        super().__init__()
        logger.info("Initializing GameEngine")
        
        self._config = get_config()
        self._state_manager = StateManager()
        self._command_processor = CommandProcessor()
        self._game_loop = GameLoop()

        try:
            from core.character.npc_system import NPCSystem
            self._npc_system = NPCSystem() 
            self._state_manager.set_npc_system(self._npc_system) 
            logger.info("NPCSystem initialized and set in StateManager.")
        except Exception as e:
            logger.error(f"Failed to initialize or set NPCSystem in StateManager: {e}", exc_info=True)
            self._npc_system = None 

        self._agent_manager = get_agent_manager()
        self._entity_manager = get_entity_manager() 
        self._item_manager = get_item_manager() 
        self._stats_manager = get_stats_manager() 
        
        self._rule_checker = RuleCheckerAgent(
            entity_manager=self._entity_manager,
            item_manager=self._item_manager,
            stats_manager=self._stats_manager,
        )
        
        self._running = False
        self._auto_save_timer = 0

        self._combat_narrator_agent = get_combat_narrator_agent()
        logger.info(f"Combat narrator agent initialized: {self._combat_narrator_agent is not None}")
        logger.info(f"Combat narrator has narrate_outcome: {hasattr(self._combat_narrator_agent, 'narrate_outcome')}")

        from core.orchestration.combat_orchestrator import CombatOutputOrchestrator
        from core.audio.tts_manager import TTSManager 
        self._combat_orchestrator = CombatOutputOrchestrator(self) 
        self._tts_manager = TTSManager(self) 
        self._combat_orchestrator.set_references(self, self._tts_manager)
        self._combat_orchestrator.load_config() 

        self._game_loop.add_tick_callback(self._handle_tick_callback)
        
        self._auto_save_interval = self._config.get("game.auto_save_interval", 300)  

        # Apply QSettings gameplay values (difficulty, encounter_size) into config if present
        try:
            from PySide6.QtCore import QSettings
            s = QSettings("RPGGame", "Settings")
            diff_ui = s.value("gameplay/difficulty", None)
            enc_ui = s.value("gameplay/encounter_size", None)
            # Map UI values to tokens used by generator
            diff_map = {"Story": "story", "Normal": "normal", "Hard": "hard", "Expert": "expert"}
            enc_map = {"Solo": "solo", "Pack": "pack", "Mixed": "mixed"}
            if diff_ui:
                self._config._config_data.setdefault("game", {})
                self._config._config_data["game"]["difficulty"] = diff_map.get(diff_ui, "normal")
            if enc_ui:
                self._config._config_data.setdefault("game", {})
                self._config._config_data["game"]["encounter_size"] = enc_map.get(enc_ui, "solo")
        except Exception:
            pass
        
        register_inventory_commands()
        
        self._input_router = get_input_router()
        
        self._use_llm = True  
        self._waiting_for_closing_narrative_display: bool = False # New flag for ECFA
        self._post_combat_finalization_in_progress: bool = False  # Prevent duplicate auto-finalization
        
        self._initialized = True
        logger.info("GameEngine initialized")
    
    # Compatibility properties and methods for web server integration
    @property
    def state_manager(self):
        """Compatibility property for web server."""
        return self._state_manager
    
    @property
    def game_loop(self):
        """Compatibility property for web server."""
        return self._game_loop
    
    def initialize(self, new_game=True, player_name="Player", race="Human", 
                   path="Wanderer", background="Commoner", sex="Male",
                   character_image=None, use_llm=True, 
                   origin_id: Optional[str] = None): # Added origin_id
        """
        Initialize the game engine with a new or loaded game.
        
        This is a compatibility method for the web server integration.
        
        Args:
            new_game: Whether to start a new game or not.
            player_name: The name of the player character (for new games).
            race: The race of the player character (for new games).
            path: The class/path of the player character (for new games).
            background: The background of the player character (for new games).
            sex: The sex/gender of the player character (for new games).
            character_image: Path to character image (for new games).
            use_llm: Whether to enable LLM functionality.
            origin_id: The ID of the player's chosen origin (for new games).
        
        Returns:
            The game state.
        """
        # First, handle game initialization
        game_state = None
        if new_game:
            game_state = self.start_new_game(
                player_name=player_name, 
                race=race,
                path=path, 
                background=background,
                sex=sex,
                character_image=character_image,
                origin_id=origin_id # Pass origin_id
            )
        else:
            game_state = self._state_manager.current_state
        
        # Then, configure LLM as requested
        if use_llm != self._use_llm:
            self.set_llm_enabled(use_llm)
        
        return game_state
    
    def start_new_game(self, player_name: str, race: str = "Human", 
                        path: str = "Wanderer", background: str = "Commoner",
                        sex: str = "Male", character_image: Optional[str] = None,
                        stats: Optional[Dict[str, int]] = None, 
                        origin_id: Optional[str] = None) -> GameState:
        """
        Start a new game.
        
        This method properly handles starting a new game regardless of the current state.
        If there's an ongoing game, it will be properly cleaned up first.
        
        Args:
            player_name: The name of the player character.
            race: The race of the player character.
            path: The class/path of the player character.
            background: The background of the player character.
            sex: The sex/gender of the player character.
            character_image: Path to character image.
        
        Returns:
            The new game state.
        """
        logger.info(f"Starting new game for player {player_name}")
        
        # Clean up existing game if present
        if self._state_manager.current_state is not None:
            logger.info("Cleaning up existing game before starting new one")
            # Stop the game loop if it's running
            if self._game_loop.is_running:
                self._game_loop.pause()
                
            # Reset agent state if LLM is enabled
            if self._agent_manager is not None and self._use_llm:
                try:
                    self._agent_manager.reset_state()
                except Exception as e:
                    logger.warning(f"Error resetting agent state: {e}")
        
        # Reset any lingering post-combat flags and orchestrator state prior to creating the new game state
        try:
            self._waiting_for_closing_narrative_display = False
            self._post_combat_finalization_in_progress = False
            if hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                try:
                    self._combat_orchestrator.set_combat_manager(None)
                except Exception:
                    pass
                self._combat_orchestrator.clear_queue_and_reset_flags()
                # Explicitly clear Combat Log UI to avoid any stale content from prior session
                try:
                    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                    clear_event = DisplayEvent(
                        type=DisplayEventType.COMBAT_LOG_SET_HTML,
                        content="",
                        role='system',
                        target_display=DisplayTarget.COMBAT_LOG,
                        gradual_visual_display=False,
                        tts_eligible=False,
                        source_step='NEW_GAME_RESET'
                    )
                    self._combat_orchestrator.add_event_to_queue(clear_event)
                except Exception:
                    pass
            # Clear NPCSystem memory so name-based lookups (e.g., 'wolf_1') do not reuse stale NPCs from previous session
            try:
                if hasattr(self, '_npc_system') and self._npc_system:
                    self._npc_system.clear_all_npcs()
                    logger.info("NPCSystem cleared for new game session.")
            except Exception as npce:
                logger.warning(f"Failed to clear NPCSystem for new game: {npce}")
        except Exception as e:
            logger.warning(f"Error resetting orchestrator/flags before new game: {e}")

        # Create new game state - this will be passed to lifecycle.start_new_game
        # We don't want to create a new one there as well
        game_state = self._state_manager.create_new_game(
            player_name=player_name,
            race=race,
            path=path,
            background=background,
            sex=sex,
            character_image=character_image,
            stats=stats,
            origin_id=origin_id # Pass origin_id
        )
        if background: # background from params is the origin description
            game_state.player.background = background # Ensure it's set if not already set by StateManager

        return lifecycle.start_new_game_with_state(
            self, game_state
        )
    
    def load_game(self, filename: str) -> Optional[GameState]:
        """
        Load a game from a save file.
        
        This method handles loading a game state with proper initialization of
        all systems, including LLM integration if enabled.
        
        Args:
            filename: The name of the save file.
        
        Returns:
            The loaded game state, or None if the load failed.
        """
        # Delegate to the lifecycle module
        return lifecycle.load_game(self, filename)

    
    def save_game(self, filename: Optional[str] = None, 
                 auto_save: bool = False) -> Optional[str]:
        """
        Save the current game.
        
        Args:
            filename: The name of the save file. If None, generates a name.
            auto_save: Whether this is an auto-save.
        
        Returns:
            The path to the save file, or None if the save failed.
        """
        # Delegate to the lifecycle module
        return lifecycle.save_game(self, filename, auto_save)

    
    def process_command(self, command_text: str) -> CommandResult:
        """
        Process a command.
        
        This method delegates to the CommandProcessor or AgentManager to handle the command,
        then processes any side effects (like exiting the game).
        
        Args:
            command_text: The command text to process.
        
        Returns:
            The result of executing the command.
        """
        # Delegate command processing to the command router module
        return command_router.route_command(self, command_text)
        
    def process_input(self, command_text: str) -> CommandResult:
        """
        Process player input. Checks for combat end state first.

        Args:
            command_text: The text input from the player.

        Returns:
            The result of processing the input.
        """
        game_state = self._state_manager.current_state
        if not game_state:
            logger.warning("Cannot process input: No current game state")
            return CommandResult.error("No game in progress.")

        # If waiting for closing narrative, don't process new input
        if self._waiting_for_closing_narrative_display:
            logger.info("Input received while waiting for closing narrative display. Ignoring.")
            return CommandResult.error("Please wait for the current action to complete.")

        # --- Check for Combat End State First ---
        if game_state.current_mode == InteractionMode.COMBAT:
            combat_manager = game_state.combat_manager
            if combat_manager and combat_manager.current_step == CombatStep.COMBAT_ENDED:
                logger.info("CombatManager step is COMBAT_ENDED. Transitioning to NARRATIVE mode.")
                
                game_state.set_interaction_mode(InteractionMode.NARRATIVE)
                final_combat_outcome = combat_manager.state.name if combat_manager.state else "Unknown"
                
                # Clear combat manager from game state and orchestrator
                game_state.combat_manager = None 
                if hasattr(self, '_combat_orchestrator'):
                    self._combat_orchestrator.set_combat_manager(None)
                    self._combat_orchestrator.clear_queue_and_reset_flags() # Clear any pending combat events

                # Queue system message for "Combat has concluded" via orchestrator for MAIN_GAME_OUTPUT
                # This assumes the orchestrator might be used for NARRATIVE mode outputs too, or a similar one exists.
                # For now, we'll make the orchestrator handle this specific post-combat sequence.
                from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                
                system_end_event = DisplayEvent(
                    type=DisplayEventType.SYSTEM_MESSAGE,
                    content=f"Combat has concluded. Outcome: {final_combat_outcome}.",
                    target_display=DisplayTarget.MAIN_GAME_OUTPUT, # Important: To GameOutputWidget
                    gradual_visual_display=False,
                    tts_eligible=False 
                )
                self._combat_orchestrator.add_event_to_queue(system_end_event)

                if self._use_llm:
                    closing_prompt = f"The combat has just ended. The outcome was: {final_combat_outcome}. Provide a brief, immersive closing narrative (1-2 sentences) describing the aftermath for the player."
                    
                    # This needs to be handled carefully. We need the LLM call to happen,
                    # then its result queued with the orchestrator.
                    # The actual input processing (command_text) should wait until this whole sequence is done.
                    
                    # For now, let's set a flag and the orchestrator will handle the LLM call after the system message.
                    # This is complex. Simpler: GameEngine makes LLM call, then queues result.
                    self._waiting_for_closing_narrative_display = True # Block further input

                    # Perform LLM call for closing narrative (can be async or in a separate thread later)
                    try:
                        from core.game_flow.interaction_core import process_with_llm # Local import
                        logger.info(f"Requesting closing combat narrative with prompt: {closing_prompt}")
                        closing_result = process_with_llm(game_state, closing_prompt) # Pass GameState to LLM
                        
                        if closing_result.is_success and closing_result.message:
                            closing_narrative_event = DisplayEvent(
                                type=DisplayEventType.NARRATIVE_GENERAL,
                                content=closing_result.message,
                                role="gm",
                                target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                                gradual_visual_display=True,
                                tts_eligible=True
                            )
                            self._combat_orchestrator.add_event_to_queue(closing_narrative_event)
                            logger.info(f"Queued closing combat narrative. Waiting for display.")
                        else:
                            logger.warning("Failed to generate closing combat narrative from LLM.")
                            self._waiting_for_closing_narrative_display = False # Allow input if LLM fails
                            
                    except Exception as e:
                        logger.error(f"Error generating closing combat narrative: {e}", exc_info=True)
                        self._waiting_for_closing_narrative_display = False # Allow input on error

                else: # LLM disabled, just log conclusion
                    logger.info(f"LLM disabled. Combat concluded ({final_combat_outcome}).")

                # If not waiting for LLM narrative (or it failed), allow new input.
                # Otherwise, return "processing" to block further input until narrative displays.
                if not self._waiting_for_closing_narrative_display:
                    logger.info(f"Mode transitioned to NARRATIVE. Now processing initial input: '{command_text}'")
                    # Fall through to process the current command_text in NARRATIVE mode
                else:
                    logger.info("Waiting for closing combat narrative to display before processing new input.")
                    return CommandResult.success("Concluding combat...") # Indicate processing

            elif not combat_manager and game_state.current_mode == InteractionMode.COMBAT:
                logger.error("In COMBAT mode but CombatManager is None. Resetting to NARRATIVE.")
                game_state.set_interaction_mode(InteractionMode.NARRATIVE)
                if hasattr(self, '_combat_orchestrator'):
                    self._combat_orchestrator.set_combat_manager(None)


        # --- Proceed with Input Routing (using the potentially updated mode) ---
        return self._input_router.route_input(self, command_text)

    def _finalize_combat_transition_if_needed(self) -> None:
        """Automatically transition to NARRATIVE and queue post-combat output when combat ends successfully.
        This is invoked by the Orchestrator when it becomes idle after the final combat event.
        It intentionally does nothing for PLAYER_DEFEAT because Game Over is handled elsewhere in the GUI.
        """
        try:
            game_state = self._state_manager.current_state
            if not game_state:
                return
            # Only react if currently in COMBAT mode
            if game_state.current_mode != InteractionMode.COMBAT:
                return
            combat_manager = getattr(game_state, 'combat_manager', None)
            if not combat_manager:
                return
            # Only proceed when CombatManager signaled the end of combat
            if combat_manager.current_step != CombatStep.COMBAT_ENDED:
                return
            # Skip auto-transition on player defeat (Game Over flow handles this)
            if getattr(combat_manager, 'state', None) == CombatState.PLAYER_DEFEAT:
                logger.info("Auto finalize skipped: PLAYER_DEFEAT handled by Game Over flow.")
                return

            if self._post_combat_finalization_in_progress:
                # Avoid duplicate invocations
                return
            self._post_combat_finalization_in_progress = True

            # Transition mode and detach combat manager
            game_state.set_interaction_mode(InteractionMode.NARRATIVE)
            final_combat_outcome = combat_manager.state.name if getattr(combat_manager, 'state', None) else "Unknown"
            game_state.combat_manager = None

            # Reset orchestrator for post-combat messages
            if hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                self._combat_orchestrator.set_combat_manager(None)
                self._combat_orchestrator.clear_queue_and_reset_flags()

            # Ensure UI reflects the mode change promptly
            try:
                from PySide6.QtCore import QTimer
                if hasattr(self, 'main_window_ref') and self.main_window_ref:
                    main_window = self.main_window_ref()
                    if main_window and hasattr(main_window, '_update_ui'):
                        QTimer.singleShot(0, main_window._update_ui)
            except Exception:
                pass

            # Queue post-combat system message and closing narrative via orchestrator
            try:
                from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                system_end_event = DisplayEvent(
                    type=DisplayEventType.SYSTEM_MESSAGE,
                    content=f"Combat has concluded. Outcome: {final_combat_outcome}.",
                    target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                    gradual_visual_display=False,
                    tts_eligible=False
                )
                if hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                    self._combat_orchestrator.add_event_to_queue(system_end_event)

                if self._use_llm and hasattr(self, '_combat_orchestrator') and self._combat_orchestrator:
                    # Request a short closing narrative
                    self._waiting_for_closing_narrative_display = True
                    try:
                        from core.game_flow.interaction_core import process_with_llm
                        closing_prompt = (
                            f"The combat has just ended. The outcome was: {final_combat_outcome}. "
                            f"Provide a brief, immersive closing narrative (1-2 sentences) describing the aftermath for the player."
                        )
                        logger.info(f"Requesting closing combat narrative with prompt: {closing_prompt}")
                        closing_result = process_with_llm(game_state, closing_prompt)
                        if closing_result.is_success and closing_result.message:
                            closing_narrative_event = DisplayEvent(
                                type=DisplayEventType.NARRATIVE_GENERAL,
                                content=closing_result.message,
                                role="gm",
                                target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                                gradual_visual_display=True,
                                tts_eligible=True
                            )
                            self._combat_orchestrator.add_event_to_queue(closing_narrative_event)
                            logger.info("Queued closing combat narrative after auto-finalize.")
                        else:
                            logger.warning("Failed to generate closing combat narrative after auto-finalize.")
                            self._waiting_for_closing_narrative_display = False
                    except Exception as e:
                        logger.error(f"Error generating closing combat narrative after auto-finalize: {e}", exc_info=True)
                        self._waiting_for_closing_narrative_display = False
            except Exception as e:
                logger.error(f"Error queuing post-combat messages during auto-finalize: {e}", exc_info=True)
        finally:
            self._post_combat_finalization_in_progress = False

    def set_llm_enabled(self, enabled: bool) -> None:
        """
        Enable or disable the LLM system.

        Args:
            enabled: Whether to enable the LLM system.
        """
        self._use_llm = enabled
        logger.info(f"LLM system {'enabled' if enabled else 'disabled'}")
        if hasattr(self, '_initialized') and self._initialized and not enabled:
            self._output("system", f"LLM system disabled")

    def reload_llm_settings(self) -> None:
        """
        Reload LLM-related agent settings at runtime so provider/model changes
        take effect immediately (including during ongoing combat).
        """
        # Reload AgentManager-managed agents
        try:
            if hasattr(self, '_agent_manager') and self._agent_manager is not None:
                self._agent_manager.reload_settings()
                # After reloading settings, fully reset agent state to reinitialize any cached clients/models
                try:
                    self._agent_manager.reset_state()
                except Exception as e_reset:
                    logger.warning(f"Error resetting AgentManager state after reload: {e_reset}")
                logger.info("AgentManager settings reloaded.")
        except Exception as e:
            logger.warning(f"Error reloading AgentManager settings: {e}")
        
        # Reload Combat Narrator agent (owned by GameEngine)
        try:
            if hasattr(self, '_combat_narrator_agent') and self._combat_narrator_agent is not None:
                self._combat_narrator_agent.reload_settings()
                logger.info("CombatNarratorAgent settings reloaded.")
        except Exception as e:
            logger.warning(f"Error reloading CombatNarratorAgent settings: {e}")
        
        # Optional: Provide user feedback in UI
        try:
            self._output("system", "LLM settings reloaded.")
        except Exception:
            # Avoid failing if UI is not connected yet
            pass

    def _output(self, role: str, content: str) -> None:
        """
        Output a message by emitting the output_generated signal.
        This method is now simplified. The primary responsibility is to add to
        conversation history (if applicable) and emit the signal.
        Buffering and complex routing are handled by MainWindow and Orchestrator
        based on DisplayEvents.
        Args:
            role: The role of the speaker (e.g., "system", "gm", "player").
            content: The content of the message.
        """
        logger.info(f"ENGINE._output called with role='{role}', content='{content[:50]}...'")
        
        # Special logging for reintroductory narrative debugging
        if role == "gm" and ("night air" in content or "find yourself" in content):
            logger.info(f"LIFECYCLE_DEBUG: ENGINE._output - This appears to be reintroductory narrative")
            logger.info(f"LIFECYCLE_DEBUG: Full content length: {len(content)}")
            logger.info(f"LIFECYCLE_DEBUG: Content preview: '{content[:300]}...'")
        
        if self._state_manager.current_state is not None and role != "system":
            self._state_manager.current_state.add_conversation_entry(role, content)
            logger.debug(f"Added to conversation history: role='{role}'")

        try:
            logger.debug(f"Emitting output_generated signal with role='{role}', content (type: {type(content).__name__})")
            logger.info(f"LIFECYCLE_DEBUG: About to emit output_generated signal to GUI")
            self.output_generated.emit(role, content) # MainWindow will handle DisplayEvent objects if content is one
            logger.debug("Signal emission successful")
            logger.info(f"LIFECYCLE_DEBUG: output_generated signal emitted successfully")
        except RuntimeError as e:
            logger.error(f"RuntimeError emitting output_generated signal: {e}", exc_info=True)
        except Exception as e:
            logger.error(f"Error emitting output_generated signal: {e}", exc_info=True)

    def _handle_tick_callback(self, elapsed_game_time: float) -> None:
        """Callback for game loop tick, delegates to lifecycle module."""
        lifecycle.handle_tick(self, elapsed_game_time)

    def run(self, target_fps: int = 30) -> None:
        """
        Run the game loop.
        (Kept in Engine as it manages the loop state)
        Args:
            target_fps: The target frames per second.
        """
        logger.info(f"Starting game engine with target FPS: {target_fps}")
        self._running = True
        self._game_loop.unpause()
        try:
            while self._running:
                self._game_loop.tick()
                time.sleep(1.0 / target_fps)
        except KeyboardInterrupt:
            logger.info("Game engine interrupted")
        except Exception as e:
            logger.error(f"Error in game engine: {e}", exc_info=True)
        finally:
            self._game_loop.pause()
            logger.info("Game engine stopped")

    def stop(self) -> None:
        """Stop the game engine."""
        logger.info("Stopping game engine")
        self._running = False
        self._game_loop.pause()

    def set_game_speed(self, speed: GameSpeed) -> None:
        """
        Set the game speed.
        (Kept in Engine as it controls the game loop)
        Args:
            speed: The new game speed.
        """
        self._game_loop.speed = speed
        logger.info(f"Game speed set to {speed.name}")
        self._output("system", f"Game speed set to {speed.name.lower()}")

    def toggle_pause(self) -> bool:
        """
        Toggle the game pause state.
        (Kept in Engine as it controls the game loop)
        Returns:
            The new pause state (True if paused, False if unpaused).
        """
        paused = self._game_loop.toggle_pause()
        if paused:
            self._output("system", "Game paused")
        else:
            self._output("system", "Game unpaused")
        return paused
    
    # --- ECFA Change: New method for MainWindow to call ---
    @Slot(object) # Use object for DisplayEvent type hint if DisplayEvent is complex
    def main_window_handle_orchestrated_event(self, display_event): # game_state is implicit via self._state_manager
        """
        Called by the CombatOutputOrchestrator to route a DisplayEvent's
        content to the MainWindow's _handle_game_output method.
        This decouples Orchestrator from directly knowing MainWindow.
        """
        from core.orchestration.events import DisplayEvent # Local import for type check
        if not isinstance(display_event, DisplayEvent):
            logger.error(f"Engine received non-DisplayEvent object: {type(display_event)}")
            return

        logger.debug(f"Engine routing orchestrated event to MainWindow: {display_event}")
        
        # MainWindow's _handle_game_output will now need to understand DisplayEvent or its parts
        # It's better if _handle_game_output is adapted or a new method is called.
        # For now, we pass DisplayEvent directly and expect MainWindow to adapt.
        
        # We emit a new signal or call a direct method on MainWindow.
        # Let's assume MainWindow has a slot `handle_orchestrated_display_event(DisplayEvent)`
        
        # To avoid direct MainWindow dependency here, GameEngine can emit a specific signal
        # that MainWindow listens to, or MainWindow can connect to a slot on the engine.
        # For simplicity with current structure, assuming GameEngine's output_generated
        # is caught by MainWindow which then checks if the content is a DisplayEvent.
        # This is not ideal. A more direct call/signal is better.

        # Alternative: Add a new signal on GameEngine for orchestrated events
        # class GameEngine(QObject):
        #     orchestrated_event_for_main_window = Signal(DisplayEvent) # Define this signal

        # Then emit it:
        # self.orchestrated_event_for_main_window.emit(display_event)

        # For now, re-using _output with a special role or by passing the event itself.
        # Let's modify _output slightly or add a new way for MainWindow to get this.

        # The simplest for now is to call MainWindow's handler directly if MainWindow ref is stored.
        # Assuming MainWindow is accessible via engine for this example, though this creates coupling.
        # A better way is a new signal from engine that MainWindow connects to.
        if hasattr(self, 'main_window_ref') and self.main_window_ref: # Assuming MainWindow registers itself
            main_window = self.main_window_ref()
            if main_window:
                # MainWindow needs a method to handle this, e.g., process_display_event_from_orchestrator
                if hasattr(main_window, 'process_orchestrated_display_event'):
                    main_window.process_orchestrated_display_event(display_event)
                else:
                    # Fallback: use existing _output, MainWindow's _handle_game_output must adapt
                    if isinstance(display_event.content, str):
                        self._output(display_event.role or "system", display_event.content)
                    elif isinstance(display_event.content, list) and display_event.type == DisplayEventType.BUFFER_FLUSH:
                        for line in display_event.content:
                             self._output(display_event.role or "gm", line) # Assume buffer is GM narrative
                    else:
                        logger.warning(f"Orchestrated event content type not directly printable: {type(display_event.content)}")
            else:
                logger.error("MainWindow reference lost in GameEngine.")
        else:
            logger.error("GameEngine does not have a reference to MainWindow to send orchestrated event.")    

    @Slot()
    def on_orchestrator_idle_and_combat_manager_resumed(self):
        """
        Called by the orchestrator when it's idle AND after it has signaled
        CombatManager to resume (if CM was waiting).
        This specifically handles the post-combat closing narrative.
        """
        if self._waiting_for_closing_narrative_display:
            logger.info("Orchestrator idle and CM resumed (or was not waiting). Closing narrative display should be complete.")
            self._waiting_for_closing_narrative_display = False
            # Potentially trigger UI re-enable or next game prompt if needed here.
            # For now, just unblocks further input in process_input.

# Convenience function (remains the same)
def get_game_engine() -> GameEngine:
    """Get the game engine instance."""
    return GameEngine()
```

### File: world_configurator\ui\widgets\__init__.py

```python
# world_configurator/ui/widgets/__init__.py
"""
Widgets for the World Configurator UI.
"""

```

### File: world_configurator\ui\widgets\multiselect_combo.py

```python
# world_configurator/ui/widgets/multiselect_combo.py
"""
MultiSelectCombo: A QComboBox that supports multi-select via checkable items.

API:
- set_options(list[str])
- set_selected(list[str])
- get_selected() -> list[str]
- clear_selection()

Shows a comma-separated summary of selected items as the display text.
"""
from __future__ import annotations

from typing import List, Optional

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QStandardItemModel, QStandardItem
from PySide6.QtWidgets import QComboBox


class MultiSelectCombo(QComboBox):
    selectionChanged = Signal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setEditable(True)  # to show joined text
        self.lineEdit().setReadOnly(True)
        self._model = QStandardItemModel(self)
        self.setModel(self._model)
        # Prevent popup closing on single click
        self.view().pressed.connect(self._on_index_pressed)
        self._options: List[str] = []

    def set_options(self, options: List[str]) -> None:
        self._options = [str(o).strip() for o in options if isinstance(o, str) and o.strip()]
        self._model.clear()
        for opt in self._options:
            item = QStandardItem(opt)
            item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable)
            item.setData(Qt.Unchecked, Qt.CheckStateRole)
            self._model.appendRow(item)
        self._refresh_text()

    def set_selected(self, values: Optional[List[str]]) -> None:
        vals = {str(v).strip() for v in (values or [])}
        for row in range(self._model.rowCount()):
            item = self._model.item(row)
            if not item: continue
            state = Qt.Checked if item.text() in vals else Qt.Unchecked
            item.setData(state, Qt.CheckStateRole)
        self._refresh_text()
        self.selectionChanged.emit(self.get_selected())

    def get_selected(self) -> List[str]:
        out: List[str] = []
        for row in range(self._model.rowCount()):
            item = self._model.item(row)
            if item and item.checkState() == Qt.Checked:
                out.append(item.text())
        return out

    def clear_selection(self) -> None:
        for row in range(self._model.rowCount()):
            item = self._model.item(row)
            if item:
                item.setData(Qt.Unchecked, Qt.CheckStateRole)
        self._refresh_text()
        self.selectionChanged.emit([])

    def _on_index_pressed(self, index) -> None:
        item = self._model.itemFromIndex(index)
        if not item:
            return
        # Toggle check state
        new_state = Qt.Unchecked if item.checkState() == Qt.Checked else Qt.Checked
        item.setData(new_state, Qt.CheckStateRole)
        self._refresh_text()
        # Keep popup open for multi-select
        self.showPopup()
        self.selectionChanged.emit(self.get_selected())

    def _refresh_text(self) -> None:
        selected = self.get_selected()
        self.lineEdit().setText(
            ", ".join(selected) if selected else ""
        )

```

### File: world_configurator\ui\widgets\typed_resistances_editor.py

```python
# world_configurator/ui/widgets/typed_resistances_editor.py
"""
TypedResistancesEditor: A structured editor widget for item custom_properties.typed_resistances.

- Presents one numeric spin box per allowed combat damage type.
- Values are integer percentages in range [-100, 100].
- get_values() returns only non-zero entries to keep JSON compact.
- set_values() populates from an existing dict.

Usage:
    editor = TypedResistancesEditor(effect_types=["slashing", "fire", ...])
    editor.set_values({"fire": 25, "cold": -10})
    values = editor.get_values()  # {"fire": 25, "cold": -10}
"""
from __future__ import annotations

from typing import Dict, List, Optional

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QWidget, QFormLayout, QHBoxLayout, QLabel, QSpinBox, QPushButton, QVBoxLayout
)


class TypedResistancesEditor(QWidget):
    """
    A QWidget that renders per-damage-type resistance percentage inputs.

    Args:
        effect_types: Allowed damage types (e.g., from config/combat/combat_config.json damage.types)
        parent: Optional parent widget
    """

    def __init__(self, effect_types: Optional[List[str]] = None, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self._effect_types: List[str] = [str(t).strip().lower() for t in (effect_types or []) if isinstance(t, str)]
        # Map damage_type -> QSpinBox
        self._spins: Dict[str, QSpinBox] = {}

        self._build_ui()

    def _build_ui(self) -> None:
        outer_layout = QVBoxLayout(self)
        outer_layout.setContentsMargins(0, 0, 0, 0)

        form = QFormLayout()
        form.setContentsMargins(0, 0, 0, 0)

        for dmg_type in self._effect_types:
            row = QHBoxLayout()

            label = QLabel(dmg_type)
            label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)

            spin = QSpinBox()
            spin.setRange(-100, 100)
            spin.setSingleStep(5)
            spin.setSuffix(" %")
            spin.setValue(0)
            spin.setToolTip("Percentage resistance modifier. Negative means vulnerability.")
            self._spins[dmg_type] = spin

            row.addWidget(label)
            row.addWidget(spin, 1)
            container = QWidget()
            container.setLayout(row)
            form.addRow(container)

        outer_layout.addLayout(form)

        # Controls
        controls = QHBoxLayout()
        self.clear_btn = QPushButton("Clear All")
        self.clear_btn.setToolTip("Reset all typed resistances to 0% (removes them on save).")
        self.clear_btn.clicked.connect(self.clear_all)
        controls.addStretch(1)
        controls.addWidget(self.clear_btn)
        outer_layout.addLayout(controls)

    # Public API
    def set_values(self, values: Optional[Dict[str, int]]) -> None:
        """
        Populate the inputs from a dict of {damage_type: percent}.
        Missing types default to 0. Extra keys are ignored.
        """
        vals = values or {}
        for dmg_type, spin in self._spins.items():
            try:
                v = int(vals.get(dmg_type, 0))
            except Exception:
                v = 0
            v = max(-100, min(100, v))
            spin.setValue(v)

    def get_values(self) -> Dict[str, int]:
        """
        Return only non-zero values as {damage_type: percent}.
        """
        out: Dict[str, int] = {}
        for dmg_type, spin in self._spins.items():
            v = int(spin.value())
            if v != 0:
                out[dmg_type] = v
        return out

    def clear_all(self) -> None:
        """Reset all spinboxes to 0 (no entries will be saved)."""
        for spin in self._spins.values():
            spin.setValue(0)

```

### File: gui\utils\__init__.py

```python
"""Utils package for the GUI module."""

```

### File: gui\utils\init_settings.py

```python
#!/usr/bin/env python3
"""
Initialize application settings with default values if they don't exist.
"""

import logging
from PySide6.QtCore import QSettings

def init_default_settings():
    """Initialize default settings if they don't exist."""

    settings = QSettings("RPGGame", "Settings")

    # Check if style settings exist and create defaults if not
    if not settings.contains("style/output_bg_color"):
        settings.setValue("style/output_bg_color", "#D2B48C")  # Light brown

    if not settings.contains("style/system_msg_color"):
        settings.setValue("style/system_msg_color", "#FF0000")  # Red

    if not settings.contains("style/font_family"):
        settings.setValue("style/font_family", "Garamond")

    if not settings.contains("style/font_size"):
        settings.setValue("style/font_size", 14)

    if not settings.contains("style/font_color"):
        settings.setValue("style/font_color", "#000000")  # Black

    # Initialize texture and transparency settings
    if not settings.contains("style/texture_name"):
        settings.setValue("style/texture_name", "subtle_noise")

    if not settings.contains("style/output_opacity"):
        settings.setValue("style/output_opacity", 100)

    if not settings.contains("style/input_opacity"):
        settings.setValue("style/input_opacity", 100)

    # Initialize display settings if they don't exist
    if not settings.contains("display/resolution"):
        settings.setValue("display/resolution", (1280, 720))

    if not settings.contains("display/mode"):
        settings.setValue("display/mode", "windowed")

    if not settings.contains("display/ui_scale"):
        settings.setValue("display/ui_scale", 1.0)
    # Initialize text speed setting
    if not settings.contains("display/text_speed_delay"):
        settings.setValue("display/text_speed_delay", 30) # Default delay in ms per character

    # Initialize sound settings if they don't exist
    if not settings.contains("sound/master_volume"):
        settings.setValue("sound/master_volume", 100)

    if not settings.contains("sound/music_volume"):
        settings.setValue("sound/music_volume", 100)

    if not settings.contains("sound/effects_volume"):
        settings.setValue("sound/effects_volume", 100)

    if not settings.contains("sound/enabled"):
        settings.setValue("sound/enabled", True)

    # Initialize gameplay settings if they don't exist
    if not settings.contains("gameplay/difficulty"):
        settings.setValue("gameplay/difficulty", "Normal")
    if not settings.contains("gameplay/encounter_size"):
        settings.setValue("gameplay/encounter_size", "Solo")

    if not settings.contains("gameplay/autosave_interval"):
        settings.setValue("gameplay/autosave_interval", 0)

    if not settings.contains("gameplay/tutorial_enabled"):
        settings.setValue("gameplay/tutorial_enabled", True)

    # Sync settings to disk
    settings.sync()

    logging.info("Default settings initialized")

```

### File: gui\utils\resource_manager.py

```python
#!/usr/bin/env python3
"""
Resource manager for the RPG game GUI.
This module provides a centralized system for loading and managing GUI resources.
"""

import os
import logging
from typing import Dict, Optional, List, Tuple

from PySide6.QtGui import QPixmap, QIcon, QMovie # Added QMovie
from PySide6.QtCore import QSize, QByteArray # Added QByteArray for QMovie

class ResourceManager:
    """Manages the loading and caching of GUI resources."""
    
    _instance = None
    
    def __new__(cls):
        """Singleton pattern implementation."""
        if cls._instance is None:
            cls._instance = super(ResourceManager, cls).__new__(cls)
            cls._instance._initialize()
        return cls._instance
    
    def _initialize(self):
        """Initialize the resource manager."""
        # Cache for loaded resources
        self._pixmap_cache: Dict[str, QPixmap] = {}
        self._icon_cache: Dict[str, QIcon] = {}
        self._movie_cache: Dict[str, QMovie] = {} # Added movie cache

        # Base paths
        self.gui_path = os.path.join("images", "gui")
        self.background_path = os.path.join(self.gui_path, "background") # --- ADDED ---
        
    def get_pixmap(self, name: str, default_size: Optional[QSize] = None) -> QPixmap:
        """
        Get a pixmap resource.
        
        Args:
            name: The resource name (without path or extension)
            default_size: Optional default size for the pixmap
            
        Returns:
            The loaded pixmap
        """
        # Check cache first
        if name in self._pixmap_cache:
            pixmap = self._pixmap_cache[name]
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
            return pixmap
        
        # Try to load the resource
        full_path = os.path.join(self.gui_path, f"{name}.png")
        
        try:
            pixmap = QPixmap(full_path)
            
            if pixmap.isNull():
                logging.warning(f"Failed to load pixmap: {full_path}")
                # Return an empty pixmap
                pixmap = QPixmap()
            else:
                # Cache the resource
                self._pixmap_cache[name] = pixmap
                
            # Scale if needed
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
                
            return pixmap
            
        except Exception as e:
            logging.error(f"Error loading pixmap {full_path}: {e}")
            return QPixmap()
    
    def get_icon(self, name: str) -> QIcon:
        """
        Get an icon resource.
        
        Args:
            name: The resource name (without path or extension)
            
        Returns:
            The loaded icon
        """
        # Check cache first
        if name in self._icon_cache:
            return self._icon_cache[name]
        
        # Try to load the resource
        try:
            # For button states, check for specific state images
            states = {
                "normal": f"{name}.png",
                "hover": f"{name}_hover.png",
                "pressed": f"{name}_pressed.png",
                "disabled": f"{name}_disabled.png"
            }
            
            # Create icon
            icon = QIcon()
            
            # Add states if they exist
            for state_name, filename in states.items():
                full_path = os.path.join(self.gui_path, filename)
                if os.path.exists(full_path):
                    pixmap = QPixmap(full_path)
                    if not pixmap.isNull():
                        if state_name == "normal":
                            icon.addPixmap(pixmap, QIcon.Normal, QIcon.Off)
                        elif state_name == "hover":
                            icon.addPixmap(pixmap, QIcon.Active, QIcon.Off)
                        elif state_name == "pressed":
                            icon.addPixmap(pixmap, QIcon.Selected, QIcon.Off)
                        elif state_name == "disabled":
                            icon.addPixmap(pixmap, QIcon.Disabled, QIcon.Off)
            
            # If no states were added, try to add the base name
            if icon.isNull():
                pixmap = self.get_pixmap(name)
                if not pixmap.isNull():
                    icon.addPixmap(pixmap)
            
            # Cache the icon
            self._icon_cache[name] = icon
            
            return icon
            
        except Exception as e:
            logging.error(f"Error loading icon {name}: {e}")
            return QIcon()
    

    def list_background_names(self) -> List[Tuple[str, str]]:
        """List available background image/animation names and their extensions."""
        backgrounds = []
        if not os.path.isdir(self.background_path):
            logging.warning(f"Background directory not found: {self.background_path}")
            return backgrounds
        try:
            for filename in os.listdir(self.background_path):
                name, ext = os.path.splitext(filename)
                ext_lower = ext.lower()
                if ext_lower in [".png", ".gif"]:
                    backgrounds.append((name, ext)) # Store name and extension
        except Exception as e:
            logging.error(f"Error listing backgrounds in {self.background_path}: {e}")
        return sorted(backgrounds, key=lambda x: x[0]) # Sort by name

    def get_background_pixmap(self, name: str) -> QPixmap:
        """
        Get a pixmap resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded pixmap
        """
        cache_key = f"background_{name}"
        # Check cache first
        if cache_key in self._pixmap_cache:
            return self._pixmap_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.png")

        try:
            pixmap = QPixmap(full_path)

            if pixmap.isNull():
                logging.warning(f"Failed to load background pixmap: {full_path}")
                pixmap = QPixmap() # Return an empty pixmap
            else:
                # Cache the resource
                self._pixmap_cache[cache_key] = pixmap

            return pixmap

        except Exception as e:
            logging.error(f"Error loading background pixmap {full_path}: {e}")
            return QPixmap()

    def get_background_movie(self, name: str) -> QMovie:
        """
        Get a QMovie resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded QMovie
        """
        cache_key = f"background_movie_{name}"
        # Check cache first
        if cache_key in self._movie_cache:
            # Return a new QMovie instance pointing to the same data if needed,
            # but for simplicity, let's assume sharing the instance is okay for now.
            # If issues arise, create new QMovie(self._movie_cache[cache_key].fileName())
            return self._movie_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.gif")

        try:
            # QMovie needs the path, not raw data like QPixmap sometimes uses
            movie = QMovie(full_path)

            if not movie.isValid():
                logging.warning(f"Failed to load or invalid background movie: {full_path}")
                # Return an empty/invalid movie
                return QMovie()
            else:
                # Cache the resource
                self._movie_cache[cache_key] = movie
                return movie

        except Exception as e:
            logging.error(f"Error loading background movie {full_path}: {e}")
            return QMovie()

    def clear_cache(self):
        """Clear the resource cache."""
        self._pixmap_cache.clear()
        self._icon_cache.clear()
        self._movie_cache.clear() # Clear movie cache

# Global instance for easy access
def get_resource_manager() -> ResourceManager:
    """Get the singleton resource manager instance."""
    return ResourceManager()

```

### File: core\character\__init__.py

```python
"""
Character-related modules for the RPG game.
"""

from typing import TYPE_CHECKING
from core.character.npc_base import NPC, NPCType, NPCRelationship, NPCInteractionType, NPCMemory

if TYPE_CHECKING:
    from core.character.npc_system import NPCSystem  # type: ignore

# Create alias for Character to NPC to fix import issues
Character = NPC

# Singleton instance for global access
_npc_system = None

def get_npc_system() -> 'NPCSystem':
    """
    Get the global NPC system instance.
    
    Returns:
        The global NPCSystem instance
    """
    global _npc_system
    if _npc_system is None:
        from core.character.npc_system import NPCSystem  # Local import to avoid circulars
        _npc_system = NPCSystem()
    return _npc_system

```

### File: core\character\background_generator.py

```python
#!/usr/bin/env python3
"""
Character background generation and enhancement module.

This module provides functionality for generating and enhancing character backgrounds
using LLM technology based on character attributes.
"""

import logging
from typing import Dict, Any, Optional, List

from core.utils.logging_config import get_logger, LogCategory
from core.llm.llm_manager import get_llm_manager, LLMRole

logger = get_logger(LogCategory.AGENT)

class BackgroundGenerator:
    """
    Handles character background generation and enhancement using LLM technology.
    """
    
    def __init__(self):
        """Initialize the background generator."""
        self.llm_manager = get_llm_manager()
        logger.info("Initialized BackgroundGenerator")
    
    def improve_background(self, background_text: str, character_data: Dict[str, Any]) -> Optional[str]:
        """
        Improve an existing character background.
        
        Args:
            background_text: The original background text to improve.
            character_data: Character data including race, class, etc.
            
        Returns:
            An improved version of the background text, or None if the request failed.
        """
        if not background_text.strip():
            logger.warning("Cannot improve empty background")
            return None
        
        try:
            logger.info("Improving character background")
            
            # Extract character info
            name = character_data.get('name', 'Character')
            race = character_data.get('race', 'Unknown')
            character_class = character_data.get('path', 'Unknown')
            background = character_data.get('background', 'Unknown')
            sex = character_data.get('sex', 'Unknown')
            
            # Create prompt for LLM
            messages = [
                {
                    "role": LLMRole.SYSTEM,
                    "content": f"""You are a creative writer specializing in fantasy RPG character backgrounds. 
                    You will be provided with a character background that needs improvement.
                    Your task is to enhance this background, making it more engaging, detailed, and aligned with fantasy RPG tropes.
                    Maintain the core elements and intentions of the original text, but improve the writing style, add depth,
                    and ensure it aligns well with the character's race, class, background, and sex.
                    
                    Your response should ONLY include the improved background text, with no additional commentary, explanations, or meta-text.
                    Keep the length reasonable - between 150-300 words is ideal."""
                },
                {
                    "role": LLMRole.USER,
                    "content": f"""Here's a character background that needs improvement:
                    
                    Character Info:
                    - Name: {name}
                    - Race: {race}
                    - Class: {character_class}
                    - Background: {background}
                    - Sex: {sex}
                    
                    Original background text:
                    "{background_text}"
                    
                    Please improve this background, making it more engaging and aligned with fantasy RPG conventions.
                    Remember to maintain the core elements while enhancing the writing style and depth.
                    Return ONLY the improved background text with no additional commentary.
                    """
                }
            ]
            
            # Get completion from LLM
            response = self.llm_manager.get_completion(messages)
            
            if response:
                improved_text = response.content.strip()
                logger.info(f"Successfully improved background (tokens: {response.total_tokens})")
                return improved_text
            else:
                logger.error("Failed to improve background: No response from LLM")
                return None
            
        except Exception as e:
            logger.error(f"Error improving background: {e}")
            return None
    
    def generate_background(self, character_data: Dict[str, Any]) -> Optional[str]:
        """
        Generate a new character background.
        
        Args:
            character_data: Character data including race, class, etc.
            
        Returns:
            A generated background text, or None if the request failed.
        """
        try:
            logger.info("Generating new character background")
            
            # Extract character info
            name = character_data.get('name', 'Character')
            race = character_data.get('race', 'Unknown')
            character_class = character_data.get('path', 'Unknown')
            background = character_data.get('background', 'Unknown')
            sex = character_data.get('sex', 'Unknown')
            
            # Extract stats if available
            stats_text = ""
            if 'stats' in character_data:
                stats = character_data['stats']
                stats_list = []
                for stat_name, stat_info in stats.items():
                    value = stat_info.get('value', 10)
                    stats_list.append(f"{stat_name}: {value}")
                stats_text = "\n".join(stats_list)
            
            # Create prompt for LLM
            messages = [
                {
                    "role": LLMRole.SYSTEM,
                    "content": f"""You are a creative writer specializing in fantasy RPG character backgrounds. 
                    You will be provided with details about a character, and your task is to create an engaging,
                    immersive background story for them.
                    
                    Create a background that:
                    1. Fits the character's race, class, background origin, and sex
                    2. Includes formative experiences that led them to their current class/profession
                    3. Incorporates appropriate fantasy RPG tropes without being cliché
                    4. Has some interesting hook or unique aspect to make the character memorable
                    5. Could serve as the beginning of an adventure
                    
                    Your response should ONLY include the background story, with no additional commentary, explanations, or meta-text.
                    The background should be between 200-350 words."""
                },
                {
                    "role": LLMRole.USER,
                    "content": f"""Please create an interesting character background for:
                    
                    Character Info:
                    - Name: {name}
                    - Race: {race}
                    - Class: {character_class}
                    - Background Origin: {background}
                    - Sex: {sex}
                    {f"- Stats:\n{stats_text}" if stats_text else ""}
                    
                    Generate a background story for this character that fits their attributes and would be engaging in a fantasy RPG setting.
                    The character's background origin is '{background}', which should inform their upbringing and formative experiences.
                    Return ONLY the background text with no additional commentary.
                    """
                }
            ]
            
            # Get completion from LLM
            response = self.llm_manager.get_completion(messages)
            
            if response:
                background_text = response.content.strip()
                logger.info(f"Successfully generated background (tokens: {response.total_tokens})")
                return background_text
            else:
                logger.error("Failed to generate background: No response from LLM")
                return None
            
        except Exception as e:
            logger.error(f"Error generating background: {e}")
            return None

# Convenience function
def get_background_generator() -> BackgroundGenerator:
    """Get a background generator instance."""
    return BackgroundGenerator()


# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    generator = get_background_generator()
    
    # Example character data
    character_data = {
        'name': 'Tordek',
        'race': 'Dwarf',
        'path': 'Warrior',
        'background': 'Soldier',
        'sex': 'Male'
    }
    
    # Example of improving a background
    original_background = "Tordek was born in the mountains and became a warrior. He fought in many battles and is now seeking adventure."
    improved = generator.improve_background(original_background, character_data)
    
    if improved:
        print("Original background:")
        print(original_background)
        print("\nImproved background:")
        print(improved)
    
    # Example of generating a new background
    generated = generator.generate_background(character_data)
    
    if generated:
        print("\nGenerated background:")
        print(generated)

```

### File: core\character\npc_base.py

```python
#!/usr/bin/env python3
"""
Base classes for NPC data structures and types.
"""

from enum import Enum, auto
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Set, Union
import uuid
import logging
from datetime import datetime

from core.stats.stats_base import StatType, DerivedStatType
from core.stats.stats_manager import StatsManager
from core.interaction.social_effects import StatusEffectData # Import StatusEffectData

logger = logging.getLogger(__name__)


class NPCType(Enum):
    """Types of NPCs in the game world."""
    MERCHANT = auto()        # Shop owners, traders
    QUEST_GIVER = auto()     # NPCs who give quests
    ALLY = auto()            # Friendly NPCs who may aid the player
    ENEMY = auto()           # Hostile NPCs
    NEUTRAL = auto()         # NPCs with no particular alignment
    SERVICE = auto()         # Service providers (innkeepers, etc.)
    BACKGROUND = auto()      # Background NPCs with minimal interaction


class NPCRelationship(Enum):
    """Relationship states between NPCs and the player."""
    HOSTILE = auto()         # Attacks on sight
    UNFRIENDLY = auto()      # Dislikes player but won't attack
    NEUTRAL = auto()         # No particular feelings
    FRIENDLY = auto()        # Likes the player
    ALLY = auto()            # Will help the player
    FEAR = auto()            # Afraid of the player
    RESPECT = auto()         # Respects the player
    FAMILY = auto()          # Family relationship
    ROMANTIC = auto()        # Romantic interest
    UNKNOWN = auto()         # Relationship not yet established


class NPCInteractionType(Enum):
    """Types of interactions that require different NPC stats."""
    COMBAT = auto()          # Combat interactions (need full stats)
    SOCIAL = auto()          # Social interactions (focus on CHA, WIS)
    COMMERCE = auto()        # Trading interactions (focus on CHA)
    QUEST = auto()           # Quest-related interactions
    INFORMATION = auto()     # Information-gathering (focus on INT, WIS)
    SERVICE = auto()         # Service providing (focus on relevant skills)
    MINIMAL = auto()         # Minimal interaction (background characters)


@dataclass
class NPCMemory:
    """A memory of an interaction with an NPC."""
    npc_id: str
    timestamp: datetime = field(default_factory=datetime.now)
    interaction_type: NPCInteractionType = NPCInteractionType.MINIMAL
    description: str = ""
    importance: int = 1  # 1-10 scale, higher is more important
    location: Optional[str] = None
    player_action: Optional[str] = None
    npc_reaction: Optional[str] = None
    relationship_change: Optional[NPCRelationship] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "npc_id": self.npc_id,
            "timestamp": self.timestamp.isoformat(),
            "interaction_type": self.interaction_type.name,
            "description": self.description,
            "importance": self.importance,
            "location": self.location,
            "player_action": self.player_action,
            "npc_reaction": self.npc_reaction,
            "relationship_change": self.relationship_change.name if self.relationship_change else None
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NPCMemory':
        """Create from dictionary after deserialization."""
        return cls(
            npc_id=data["npc_id"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            interaction_type=NPCInteractionType[data["interaction_type"]],
            description=data["description"],
            importance=data["importance"],
            location=data.get("location"),
            player_action=data.get("player_action"),
            npc_reaction=data.get("npc_reaction"),
            relationship_change=NPCRelationship[data["relationship_change"]] if data.get("relationship_change") else None
        )


@dataclass
class NPC:
    """Class representing an NPC in the game world."""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = "Unknown NPC"
    npc_type: NPCType = NPCType.NEUTRAL
    relationship: NPCRelationship = NPCRelationship.NEUTRAL
    location: Optional[str] = None
    description: str = ""
    occupation: Optional[str] = None
    race: Optional[str] = None
    gender: Optional[str] = None
    age: Optional[str] = None
    is_persistent: bool = False  # Should this NPC persist between sessions?
    last_interaction: Optional[datetime] = None
    interaction_count: int = 0
    stats_generated: bool = False
    stats_manager: Optional[StatsManager] = None
    equipment_manager: Optional['EquipmentManager'] = None
    appearance: Optional[str] = None
    personality: Optional[str] = None
    goals: Optional[str] = None
    secrets: Optional[str] = None
    inventory: Optional[List[Dict[str, Any]]] = None
    known_information: Optional[Dict[str, Any]] = None
    dialog_history: List[Dict[str, Any]] = field(default_factory=list)
    memories: List[NPCMemory] = field(default_factory=list)
    current_resolve: float = 0.0 # Current social 'health'
    active_social_effects: List[StatusEffectData] = field(default_factory=list)

    def __post_init__(self):
        """Initialize any empty fields."""
        if self.inventory is None:
            self.inventory = []
        if self.known_information is None:
            self.known_information = {}

    def update_relationship(self, new_relationship: NPCRelationship) -> None:
        """Update the relationship between the NPC and the player."""
        old_relationship = self.relationship
        self.relationship = new_relationship
        logger.info(f"NPC {self.name}: Relationship changed from {old_relationship.name} to {new_relationship.name}")

    def record_interaction(self, memory: NPCMemory) -> None:
        """Record a new interaction with this NPC."""
        self.memories.append(memory)
        self.last_interaction = memory.timestamp
        self.interaction_count += 1
        logger.debug(f"Recorded interaction with NPC {self.name}: {memory.description}")

    def has_stats(self) -> bool:
        """Check if this NPC has stats generated."""
        return self.stats_generated and self.stats_manager is not None

    def get_stat(self, stat_type: Union[StatType, DerivedStatType, str]) -> Optional[float]:
        """Get a specific stat value if stats have been generated."""
        if not self.has_stats():
            return None

        try:
            return self.stats_manager.get_stat_value(stat_type)
        except ValueError:
            return None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "npc_type": self.npc_type.name,
            "relationship": self.relationship.name,
            "location": self.location,
            "description": self.description,
            "occupation": self.occupation,
            "race": self.race,
            "gender": self.gender,
            "age": self.age,
            "is_persistent": self.is_persistent,
            "last_interaction": self.last_interaction.isoformat() if self.last_interaction else None,
            "interaction_count": self.interaction_count,
            "stats_generated": self.stats_generated,
            "stats": self.stats_manager.to_dict() if self.has_stats() else None,
            "equipment": self.equipment_manager.to_dict() if hasattr(self, 'equipment_manager') and self.equipment_manager else None,
            "appearance": self.appearance,
            "personality": self.personality,
            "goals": self.goals,
            "secrets": self.secrets,
            "inventory": self.inventory,
            "known_information": self.known_information,
            "dialog_history": self.dialog_history,
            "memories": [memory.to_dict() for memory in self.memories],
            "current_resolve": self.current_resolve,
            "active_social_effects": [effect.to_dict() for effect in self.active_social_effects],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NPC':
        """Create from dictionary after deserialization."""
        npc = cls(
            id=data.get("id", str(uuid.uuid4())),
            name=data.get("name", "Unknown NPC"),
            npc_type=NPCType[data.get("npc_type", "NEUTRAL")],
            relationship=NPCRelationship[data.get("relationship", "NEUTRAL")],
            location=data.get("location"),
            description=data.get("description", ""),
            occupation=data.get("occupation"),
            race=data.get("race"),
            gender=data.get("gender"),
            age=data.get("age"),
            is_persistent=data.get("is_persistent", False),
            interaction_count=data.get("interaction_count", 0),
            stats_generated=data.get("stats_generated", False),
            appearance=data.get("appearance"),
            personality=data.get("personality"),
            goals=data.get("goals"),
            secrets=data.get("secrets"),
            inventory=data.get("inventory", []),
            known_information=data.get("known_information", {}),
            dialog_history=data.get("dialog_history", [])
            # current_resolve and active_social_effects will be loaded below
        )

        # Load last_interaction
        if data.get("last_interaction"):
            npc.last_interaction = datetime.fromisoformat(data["last_interaction"])

        # Load stats if they exist
        if npc.stats_generated and data.get("stats"):
            npc.stats_manager = StatsManager.from_dict(data["stats"])

        # Load equipment if it exists
        if data.get("equipment"):
            from core.inventory.equipment_manager import EquipmentManager
            npc.equipment_manager = EquipmentManager.from_dict(data["equipment"])

        # Load memories
        if "memories" in data:
            npc.memories = [NPCMemory.from_dict(memory_data) for memory_data in data["memories"]]

        # Load current resolve and social effects
        npc.current_resolve = data.get("current_resolve", 0.0)
        if "active_social_effects" in data:
            npc.active_social_effects = [
                StatusEffectData.from_dict(effect_data)
                for effect_data in data["active_social_effects"]
            ]

        return npc

```

### File: core\character\npc_creator.py

```python
#!/usr/bin/env python3
"""
NPC Creator module focused on creating and generating NPCs for various interactions.
"""

import logging
from typing import Dict, List, Any, Optional, Union, Tuple
from datetime import datetime

from core.character.npc_base import NPC, NPCType, NPCRelationship, NPCInteractionType, NPCMemory
from core.character.npc_generator import NPCGenerator
from core.character.npc_manager import NPCManager
from core.base.config import get_config

logger = logging.getLogger(__name__)


class NPCCreator:
    """
    Class for handling NPC creation operations.
    Contains methods for creating different types of NPCs and enhancing existing ones.
    """
    
    def __init__(self, npc_manager: NPCManager):
        """
        Initialize the NPC creator.
        
        Args:
            npc_manager: The NPCManager instance to use
        """
        self.npc_manager = npc_manager
        self.npc_generator = npc_manager.npc_generator
    
    def create_npc(self, 
                  interaction_type: NPCInteractionType,
                  name: Optional[str] = None,
                  npc_type: Optional[NPCType] = None,
                  npc_subtype: Optional[str] = None,
                  relationship: NPCRelationship = NPCRelationship.NEUTRAL,
                  location: Optional[str] = None,
                  description: Optional[str] = None,
                  occupation: Optional[str] = None,
                  is_persistent: bool = False) -> NPC:
        """
        Create a new NPC and add it to the manager.
        
        Args:
            interaction_type: The type of interaction this NPC is for
            name: Optional name for the NPC (generated if None)
            npc_type: Type of NPC (determined from interaction if None)
            relationship: Initial relationship with the player
            location: Where the NPC is located
            description: Optional description of the NPC
            occupation: Optional occupation
            is_persistent: Whether this NPC should be saved persistently
            
        Returns:
            The newly created NPC
        """
        # Check if NPC with this name already exists
        if name and self.npc_manager.get_npc_by_name(name):
            logger.warning(f"NPC with name '{name}' already exists, checking compatibility")
            existing_npc = self.npc_manager.get_npc_by_name(name)
            
            # If it exists but has minimal stats and we need more, enhance it
            if existing_npc and not existing_npc.has_stats():
                self.enhance_npc_for_interaction(existing_npc, interaction_type)
                return existing_npc
            
            # Otherwise, append a number to make the name unique
            i = 2
            while self.npc_manager.get_npc_by_name(f"{name} {i}"):
                i += 1
            name = f"{name} {i}"
        
        # Generate the NPC
        npc = self.npc_generator.generate_npc_for_interaction(
            interaction_type=interaction_type,
            name=name,
            npc_type=npc_type,
            npc_subtype=npc_subtype,
            relationship=relationship,
            location=location,
            description=description,
            occupation=occupation,
            is_persistent=is_persistent
        )
        
        # Add to manager
        self.npc_manager.add_npc(npc)
        
        return npc
    
    def create_enemy(self, 
                    name: Optional[str] = None,
                    enemy_type: str = "generic",
                    level: int = 1,
                    location: Optional[str] = None) -> NPC:
        """
        Create a new enemy NPC for combat and add it to the manager.
        
        Args:
            name: Optional name for the enemy
            enemy_type: Type of enemy (e.g., "bandit", "wolf", "guard")
            level: Level of the enemy, affects stats
            location: Where the enemy is located
            
        Returns:
            The newly created enemy NPC
        """
        # Families-mode path
        try:
            cfg = get_config()
            mode = (cfg.get("system.npc_generation_mode", "legacy") or "legacy").lower()
        except Exception:
            mode = "legacy"

        if mode == "families":
            from core.character.npc_family_generator import NPCFamilyGenerator
            fam_gen = NPCFamilyGenerator()
            # Parse overlay syntax: id::overlay_id or id+boss
            raw = enemy_type
            overlay_id = None
            target_id = raw
            if isinstance(raw, str) and "::" in raw:
                parts = raw.split("::", 1)
                target_id, overlay_id = parts[0], parts[1] or None
            elif isinstance(raw, str) and raw.endswith("+boss"):
                target_id = raw[:-5]
                overlay_id = overlay_id or "default_boss"

            # Pull difficulty/encounter_size from config if available
            try:
                difficulty = (cfg.get("game.difficulty", "normal") or "normal")
                encounter_size = (cfg.get("game.encounter_size", "solo") or "solo")
            except Exception:
                difficulty = "normal"
                encounter_size = "solo"

            # Use variant if exists, else family
            used_variant = False
            if callable(getattr(fam_gen, "get_variant", None)) and fam_gen.get_variant(target_id):
                npc = fam_gen.generate_npc_from_variant(
                    variant_id=target_id,
                    name=name,
                    location=location,
                    level=level,
                    overlay_id=overlay_id,
                    difficulty=difficulty,
                    encounter_size=encounter_size,
                )
                used_variant = True
            else:
                npc = fam_gen.generate_npc_from_family(
                    family_id=target_id,
                    name=name,
                    location=location,
                    level=level,
                    overlay_id=overlay_id,
                    difficulty=difficulty,
                    encounter_size=encounter_size,
                )
            # Add to manager and return
            self.npc_manager.add_npc(npc)
            return npc

        # Legacy path fallback
        npc = self.npc_generator.generate_enemy_npc(
            name=name,
            enemy_type=enemy_type,
            level=level,
            location=location
        )
        # Add to manager
        self.npc_manager.add_npc(npc)
        return npc
    
    def create_merchant(self,
                       name: Optional[str] = None,
                       shop_type: str = "general",
                       location: Optional[str] = None,
                       description: Optional[str] = None) -> NPC:
        """
        Create a merchant NPC specialized for commerce interactions.
        
        Args:
            name: Optional name for the merchant
            shop_type: Type of shop (e.g., "general", "weapons", "potions")
            location: Where the merchant is located
            description: Optional description of the merchant
            
        Returns:
            The newly created merchant NPC
        """
        # Generate a merchant-focused description if none provided
        if not description and name:
            description = f"{name} is a {shop_type} merchant offering goods for sale."
        elif not description:
            description = f"A {shop_type} merchant offering goods for sale."
        
        # Families-mode path for non-combat NPCs
        try:
            cfg = get_config()
            mode = (cfg.get("system.npc_generation_mode", "legacy") or "legacy").lower()
        except Exception:
            mode = "legacy"

        if mode == "families":
            from core.character.npc_family_generator import NPCFamilyGenerator
            fam_gen = NPCFamilyGenerator()
            # Determine culture hint from location (optional)
            culture_hint = None
            try:
                seed = f"merchant|{location or ''}|{shop_type}|{name or ''}"
                if location:
                    # Prefer culture_mix if present
                    mix = cfg.get(f"locations.{location}.culture_mix")
                    if isinstance(mix, dict) and mix:
                        culture_hint = self._choose_from_weighted_map(mix, seed)
                    else:
                        culture_hint = cfg.get(f"locations.{location}.culture")
                if not culture_hint:
                    # Global default mix if available
                    mix_def = cfg.get("location_defaults.culture_mix")
                    if isinstance(mix_def, dict) and mix_def:
                        culture_hint = self._choose_from_weighted_map(mix_def, seed)
            except Exception:
                pass
            family_id = fam_gen.choose_humanoid_family(culture_hint=culture_hint, location=location, seed=seed) or "humanoid_normal_base"

            # Difficulty/encounter from config
            difficulty = (cfg.get("game.difficulty", "normal") or "normal")
            encounter_size = (cfg.get("game.encounter_size", "solo") or "solo")

            npc = fam_gen.generate_npc_from_family(
                family_id=family_id,
                name=name,
                location=location,
                level=1,
                overlay_id=None,
                difficulty=difficulty,
                encounter_size=encounter_size,
            )
            # Adjust for commerce context
            npc.npc_type = NPCType.MERCHANT
            npc.relationship = NPCRelationship.NEUTRAL
            if not npc.description:
                npc.description = description or (f"A {shop_type} merchant.")
            # Ensure communicative tag and record commerce metadata
            if npc.known_information is None:
                npc.known_information = {}
            tags = list(npc.known_information.get("tags", []) or [])
            if "communicative:true" not in tags:
                tags.append("communicative:true")
            npc.known_information["tags"] = tags
            npc.known_information["service"] = {"type": "merchant", "shop_type": shop_type}

            # Semi-deterministic naming if not provided
            if not name:
                npc.name = self._generate_semideterministic_name(culture_hint=culture_hint, role_hint="merchant", seed=seed)

            # Mark for LLM flavor (description/backstory) to be enriched later by orchestrated flow
            npc.known_information["needs_llm_flavor"] = True
            npc.known_information["flavor_context"] = {
                "kind": "commerce",
                "shop_type": shop_type,
                "culture": culture_hint,
                "location": location,
                "family_id": family_id,
            }
            # Attempt LLM flavor enrichment (graceful on failure)
            try:
                from core.character.npc_flavor import attempt_enrich_npc_flavor
                attempt_enrich_npc_flavor(npc)
            except Exception:
                pass
            # Persist merchants
            npc.is_persistent = True
            self.npc_manager.add_npc(npc)
            return npc

        # Legacy path fallback
        return self.create_npc(
            interaction_type=NPCInteractionType.COMMERCE,
            name=name,
            npc_type=NPCType.MERCHANT,
            relationship=NPCRelationship.NEUTRAL,
            location=location,
            description=description,
            occupation=f"{shop_type}.capitalize() Merchant",
            is_persistent=True  # Merchants are typically persistent
        )
    
    def create_quest_giver(self,
                          name: Optional[str] = None,
                          quest_type: str = "general",
                          location: Optional[str] = None,
                          description: Optional[str] = None) -> NPC:
        """
        Create a quest giver NPC specialized for quest interactions.
        
        Args:
            name: Optional name for the quest giver
            quest_type: Type of quest (e.g., "fetch", "kill", "escort")
            location: Where the quest giver is located
            description: Optional description of the quest giver
            
        Returns:
            The newly created quest giver NPC
        """
        # Generate a quest-focused description if none provided
        if not description and name:
            description = f"{name} is looking for someone to help with a {quest_type} task."
        elif not description:
            description = f"Someone looking for help with a {quest_type} task."
        
        # Families-mode path
        try:
            cfg = get_config()
            mode = (cfg.get("system.npc_generation_mode", "legacy") or "legacy").lower()
        except Exception:
            mode = "legacy"

        if mode == "families":
            from core.character.npc_family_generator import NPCFamilyGenerator
            fam_gen = NPCFamilyGenerator()
            culture_hint = None
            try:
                seed = f"quest_giver|{location or ''}|{quest_type}|{name or ''}"
                if location:
                    mix = cfg.get(f"locations.{location}.culture_mix")
                    if isinstance(mix, dict) and mix:
                        culture_hint = self._choose_from_weighted_map(mix, seed)
                    else:
                        culture_hint = cfg.get(f"locations.{location}.culture")
                if not culture_hint:
                    mix_def = cfg.get("location_defaults.culture_mix")
                    if isinstance(mix_def, dict) and mix_def:
                        culture_hint = self._choose_from_weighted_map(mix_def, seed)
            except Exception:
                pass
            family_id = fam_gen.choose_humanoid_family(culture_hint=culture_hint, location=location, seed=seed) or "humanoid_normal_base"

            difficulty = (cfg.get("game.difficulty", "normal") or "normal")
            encounter_size = (cfg.get("game.encounter_size", "solo") or "solo")

            npc = fam_gen.generate_npc_from_family(
                family_id=family_id,
                name=name,
                location=location,
                level=1,
                overlay_id=None,
                difficulty=difficulty,
                encounter_size=encounter_size,
            )
            npc.npc_type = NPCType.QUEST_GIVER
            npc.relationship = NPCRelationship.NEUTRAL
            if not npc.description:
                npc.description = description or ("A potential quest giver.")
            if npc.known_information is None:
                npc.known_information = {}
            tags = list(npc.known_information.get("tags", []) or [])
            if "communicative:true" not in tags:
                tags.append("communicative:true")
            if "quest_giver:true" not in tags:
                tags.append("quest_giver:true")
            npc.known_information["tags"] = tags
            npc.known_information["quest"] = {"role": "giver", "type": quest_type}
            if not name:
                npc.name = self._generate_semideterministic_name(culture_hint=culture_hint, role_hint="quest_giver", seed=seed)
            npc.known_information["needs_llm_flavor"] = True
            npc.known_information["flavor_context"] = {
                "kind": "quest",
                "quest_type": quest_type,
                "culture": culture_hint,
                "location": location,
                "family_id": family_id,
            }
            try:
                from core.character.npc_flavor import attempt_enrich_npc_flavor
                attempt_enrich_npc_flavor(npc)
            except Exception:
                pass
            npc.is_persistent = True
            self.npc_manager.add_npc(npc)
            return npc

        # Legacy fallback
        return self.create_npc(
            interaction_type=NPCInteractionType.QUEST,
            name=name,
            npc_type=NPCType.QUEST_GIVER,
            relationship=NPCRelationship.NEUTRAL,
            location=location,
            description=description,
            is_persistent=True  # Quest givers are typically persistent
        )
    
    def create_service_npc(self,
                          name: Optional[str] = None,
                          service_type: str = "innkeeper",
                          location: Optional[str] = None,
                          description: Optional[str] = None) -> NPC:
        """
        Create a service NPC specialized for service interactions.
        
        Args:
            name: Optional name for the service provider
            service_type: Type of service (e.g., "innkeeper", "blacksmith", "healer")
            location: Where the service provider is located
            description: Optional description of the service provider
            
        Returns:
            The newly created service NPC
        """
        # Generate a service-focused description if none provided
        if not description and name:
            description = f"{name} is a {service_type} offering services."
        elif not description:
            description = f"A {service_type} offering services."
        
        # Families-mode path
        try:
            cfg = get_config()
            mode = (cfg.get("system.npc_generation_mode", "legacy") or "legacy").lower()
        except Exception:
            mode = "legacy"

        if mode == "families":
            from core.character.npc_family_generator import NPCFamilyGenerator
            fam_gen = NPCFamilyGenerator()
            culture_hint = None
            try:
                seed = f"service|{location or ''}|{service_type}|{name or ''}"
                if location:
                    mix = cfg.get(f"locations.{location}.culture_mix")
                    if isinstance(mix, dict) and mix:
                        culture_hint = self._choose_from_weighted_map(mix, seed)
                    else:
                        culture_hint = cfg.get(f"locations.{location}.culture")
                if not culture_hint:
                    mix_def = cfg.get("location_defaults.culture_mix")
                    if isinstance(mix_def, dict) and mix_def:
                        culture_hint = self._choose_from_weighted_map(mix_def, seed)
            except Exception:
                pass
            # Determine if we should use a social role variant
            variant_id = None
            social_role_types = ["guard", "official", "scholar"]
            
            if service_type in social_role_types and culture_hint:
                # Try to use a specific social role variant
                variant_id = f"{culture_hint}_{service_type}"
                logger.debug(f"Attempting to use social role variant: {variant_id}")
                
                # Check if the variant exists in the family generator
                if fam_gen.get_variant(variant_id):
                    logger.info(f"Using social role variant {variant_id}")
                else:
                    logger.debug(f"Social role variant {variant_id} not found, using base family")
                    variant_id = None

            difficulty = (cfg.get("game.difficulty", "normal") or "normal")
            encounter_size = (cfg.get("game.encounter_size", "solo") or "solo")

            # Generate NPC using variant path or family path based on availability
            if variant_id:
                # Use the variant generation path for consistent scaling and metadata
                npc = fam_gen.generate_npc_from_variant(
                    variant_id=variant_id,
                    name=name,
                    location=location,
                    level=1,
                    overlay_id=None,
                    difficulty=difficulty,
                    encounter_size=encounter_size,
                )
                logger.info(f"Generated service NPC using variant {variant_id}: {npc.name}")
            else:
                # Standard family selection and generation
                family_id = fam_gen.choose_humanoid_family(culture_hint=culture_hint, location=location, seed=seed) or "humanoid_normal_base"
                npc = fam_gen.generate_npc_from_family(
                    family_id=family_id,
                    name=name,
                    location=location,
                    level=1,
                    overlay_id=None,
                    difficulty=difficulty,
                    encounter_size=encounter_size,
                )
                logger.info(f"Generated service NPC using family {family_id}: {npc.name}")
            npc.npc_type = NPCType.SERVICE
            npc.relationship = NPCRelationship.NEUTRAL
            if not npc.description:
                npc.description = description or (f"A {service_type} offering services.")
            if npc.known_information is None:
                npc.known_information = {}
            tags = list(npc.known_information.get("tags", []) or [])
            if "communicative:true" not in tags:
                tags.append("communicative:true")
            npc.known_information["tags"] = tags
            npc.known_information["service"] = {"type": "service", "service_type": service_type}
            
            # If we used a variant, it should have already applied role tags
            # But add fallback social role tags if variant wasn't used
            if not variant_id and service_type in social_role_types:
                social_roles = {
                    "guard": ["role:guard", "duty:watch"],
                    "official": ["role:official"],
                    "scholar": ["role:scholar"],
                }
                if service_type in social_roles:
                    role_tags = social_roles[service_type]
                    for tag in role_tags:
                        if tag not in tags:
                            tags.append(tag)
                    npc.known_information["tags"] = tags
                    logger.debug(f"Applied fallback role tags for {service_type}: {role_tags}")
            if not name:
                npc.name = self._generate_semideterministic_name(culture_hint=culture_hint, role_hint=service_type, seed=seed)
            npc.known_information["needs_llm_flavor"] = True
            
            # Build flavor context - get family_id from NPC metadata
            family_id_for_flavor = None
            if variant_id:
                # Get family_id from the variant that was used
                variant_data = fam_gen.get_variant(variant_id)
                family_id_for_flavor = variant_data.get("family_id") if variant_data else None
            else:
                # Use the family_id from the standard generation path above
                family_id_for_flavor = family_id
            
            npc.known_information["flavor_context"] = {
                "kind": "service",
                "service_type": service_type,
                "culture": culture_hint,
                "location": location,
                "family_id": family_id_for_flavor,
                "variant_id": variant_id,
            }
            try:
                from core.character.npc_flavor import attempt_enrich_npc_flavor
                attempt_enrich_npc_flavor(npc)
            except Exception:
                pass
            npc.is_persistent = True
            self.npc_manager.add_npc(npc)
            return npc

        # Legacy fallback
        return self.create_npc(
            interaction_type=NPCInteractionType.SERVICE,
            name=name,
            npc_type=NPCType.SERVICE,
            relationship=NPCRelationship.NEUTRAL,
            location=location,
            description=description,
            occupation=service_type.capitalize(),
            is_persistent=True  # Service NPCs are typically persistent
        )
    
    def enhance_npc_for_interaction(self, npc: NPC, interaction_type: NPCInteractionType) -> None:
        """
        Enhance an existing NPC with additional details for a new type of interaction.
        This implements the just-in-time generation approach for NPC stats.
        
        Args:
            npc: The NPC to enhance
            interaction_type: The interaction type to prepare for
        """
        # No need to enhance if the NPC already has stats
        if npc.has_stats() and interaction_type == NPCInteractionType.MINIMAL:
            return
        
        # Generate stats if needed
        if not npc.has_stats():
            logger.info(f"Generating stats for NPC {npc.name} for {interaction_type.name} interaction")
            self.npc_generator.enhance_npc_for_new_interaction(npc, interaction_type)
            return
        
        # For existing NPCs with stats, enhance them for the new interaction
        self.npc_generator.enhance_npc_for_new_interaction(npc, interaction_type)
        
        # Record this enhancement in NPC's logs
        if not npc.known_information:
            npc.known_information = {}
        
        if "interaction_history" not in npc.known_information:
            npc.known_information["interaction_history"] = []
        
        npc.known_information["interaction_history"].append({
            "type": interaction_type.name,
            "timestamp": str(datetime.now())
        })
        
        logger.info(f"Enhanced NPC {npc.name} for {interaction_type.name} interaction")
    
    def get_or_create_npc(self,
                         name: str,
                         interaction_type: NPCInteractionType,
                         location: Optional[str] = None,
                         description: Optional[str] = None,
                         npc_type: Optional[NPCType] = None,
                         npc_subtype: Optional[str] = None) -> Tuple[NPC, bool]:
        """
        Get an existing NPC by name or create a new one if not found.
        This is the primary method for implementing just-in-time NPC generation.
        
        Args:
            name: Name of the NPC to get or create
            interaction_type: The interaction type needed
            location: Optional location for new NPCs
            description: Optional description for new NPCs
            npc_type: Optional NPC type for new NPCs
            npc_subtype: Optional subtype (e.g., 'boss_dragon', 'merchant')
            
        Returns:
            Tuple of (NPC, was_created) where was_created is True if a new NPC was created
        """
        # Check if the NPC already exists
        existing_npc = self.npc_manager.get_npc_by_name(name)
        
        if existing_npc:
            # Enhance the NPC if necessary for the current interaction
            self.enhance_npc_for_interaction(existing_npc, interaction_type)
            return existing_npc, False
        
        # Create a new NPC
        new_npc = self.create_npc(
            interaction_type=interaction_type,
            name=name,
            npc_type=npc_type,
            npc_subtype=npc_subtype,
            location=location,
            description=description
        )
        
        return new_npc, True

    # ---- Helpers ----
    def _apply_variant_to_npc(self, npc: NPC, variant_id: str) -> None:
        """Apply variant modifications to an existing NPC."""
        try:
            cfg = get_config()
            variant_data = cfg.get(f"npc.variants.{variant_id}")
            if not variant_data or not isinstance(variant_data, dict):
                logger.warning(f"Variant {variant_id} not found or invalid")
                return
            
            # Apply stat modifiers to the NPC's stats manager
            if npc.stats_manager and "stat_modifiers" in variant_data:
                stat_mods = variant_data["stat_modifiers"]
                if isinstance(stat_mods, dict):
                    for stat_name, mod_dict in stat_mods.items():
                        if not isinstance(mod_dict, dict):
                            continue
                        
                        # Get current derived stat value
                        try:
                            if stat_name == "hp":
                                current_max = npc.stats_manager.get_stat_value(DerivedStatType.MAX_HEALTH)
                                current_cur = npc.stats_manager.get_stat_value(DerivedStatType.HEALTH)
                                # Apply modifiers
                                if "add" in mod_dict:
                                    current_max += float(mod_dict["add"])
                                    current_cur += float(mod_dict["add"])
                                if "mul" in mod_dict:
                                    current_max *= float(mod_dict["mul"])
                                    current_cur *= float(mod_dict["mul"])
                                # Update stats (note: can't directly set MAX_HEALTH in most systems)
                                # For now, adjust current health proportionally
                                npc.stats_manager.set_current_stat(DerivedStatType.HEALTH, max(1.0, current_cur))
                                logger.debug(f"Applied HP modifier to {npc.name}: {mod_dict}")
                            elif stat_name in ["damage", "defense", "initiative"]:
                                # These are derived stats that depend on primary stats
                                # For now, log that we would apply them but can't easily modify derived stats
                                logger.debug(f"Would apply {stat_name} modifier to {npc.name}: {mod_dict} (derived stat modification not implemented)")
                        except Exception as e:
                            logger.warning(f"Failed to apply stat modifier {stat_name} to {npc.name}: {e}")
            
            # Apply additional roles
            if npc.known_information is None:
                npc.known_information = {}
            
            roles_add = variant_data.get("roles_add", [])
            if roles_add and isinstance(roles_add, list):
                current_roles = npc.known_information.get("roles", [])
                if not isinstance(current_roles, list):
                    current_roles = []
                for role in roles_add:
                    if role not in current_roles:
                        current_roles.append(role)
                npc.known_information["roles"] = current_roles
                logger.debug(f"Added roles to {npc.name}: {roles_add}")
            
            # Apply additional abilities  
            abilities_add = variant_data.get("abilities_add", [])
            if abilities_add and isinstance(abilities_add, list):
                current_abilities = npc.known_information.get("abilities", [])
                if not isinstance(current_abilities, list):
                    current_abilities = []
                for ability in abilities_add:
                    if ability not in current_abilities:
                        current_abilities.append(ability)
                npc.known_information["abilities"] = current_abilities
                logger.debug(f"Added abilities to {npc.name}: {abilities_add}")
            
            # Apply additional tags
            tags_add = variant_data.get("tags_add", [])
            if tags_add and isinstance(tags_add, list):
                current_tags = npc.known_information.get("tags", [])
                if not isinstance(current_tags, list):
                    current_tags = []
                for tag in tags_add:
                    if tag not in current_tags:
                        current_tags.append(tag)
                npc.known_information["tags"] = current_tags
                logger.debug(f"Added tags to {npc.name}: {tags_add}")
            
            # Store variant info
            npc.known_information["variant_id"] = variant_id
            logger.info(f"Successfully applied variant {variant_id} to {npc.name}")
            
        except Exception as e:
            logger.error(f"Error applying variant {variant_id} to NPC {npc.name}: {e}")

    def _choose_from_weighted_map(self, weights: dict, seed: str) -> Optional[str]:
        """Deterministically choose a key from a {key: weight} mapping."""
        import hashlib, random as _random
        if not isinstance(weights, dict) or not weights:
            return None
        items = [(k, float(v)) for k, v in weights.items() if isinstance(v, (int, float)) and float(v) > 0]
        if not items:
            return None
        rng = _random.Random()
        h = hashlib.md5(seed.encode("utf-8")).digest()
        rng.seed(int.from_bytes(h, byteorder="big", signed=False))
        total = sum(w for _, w in items)
        pick = rng.random() * total
        acc = 0.0
        for k, w in items:
            acc += w
            if pick <= acc:
                return k
        return items[-1][0]

    def _generate_semideterministic_name(self, culture_hint: Optional[str], role_hint: Optional[str], seed: str) -> str:
        """Generate a semi-deterministic name using legacy pools as guidance.
        Combines culture/role hints to pick a pool, then selects name parts using a seeded RNG.
        """
        import hashlib, random as _random
        from typing import List
        rng = _random.Random()
        h = hashlib.md5(seed.encode("utf-8")).digest()
        rng.seed(int.from_bytes(h, byteorder="big", signed=False))

        # Try culture-aware names.json first
        try:
            cfg = get_config()
            names = cfg.get("npc_names.cultures") or {}
            culture = culture_hint or "generic"
            spec = names.get(culture) or names.get("generic")
            if spec:
                # Build first and last name from syllables and patterns
                import re
                def build_from_spec(spec_local):
                    pats = spec_local.get("patterns") or ["FN LN"]
                    pat = pats[min(len(pats)-1, rng.randrange(len(pats)))]
                    def gen_first():
                        s = spec_local.get("first_syllables", ["al","an","ar","el","ia"])    
                        n = max(1, min(3, int(rng.random()*3)+1))
                        return "".join(rng.choice(s) for _ in range(n)).capitalize()
                    def gen_last():
                        pref = spec_local.get("last_prefixes", [""])
                        suff = spec_local.get("last_suffixes", ["son","wood","wright","smith"]) 
                        core = spec_local.get("last_cores", ["stone","light","river","storm"]) 
                        form = rng.randrange(3)
                        if form == 0:
                            return (rng.choice(core)+rng.choice(suff)).capitalize()
                        elif form == 1:
                            return (rng.choice(pref)+rng.choice(core)).capitalize()
                        else:
                            return (rng.choice(core)).capitalize()
                    fn = gen_first()
                    ln = gen_last()
                    return pat.replace("FN", fn).replace("LN", ln)
                name = build_from_spec(spec)
                # Ensure simple validation
                allowed = spec.get("allowed_chars", "^[A-Za-z' -]+$")
                if re.match(allowed, name):
                    return name
        except Exception:
            pass
        # Fallback to legacy name pools
        pools = {}
        try:
            cfg = get_config()
            pools = cfg.get("npc_legacy_templates.name_pools") or {}
        except Exception:
            pools = {}
        candidates: List[str] = []
        if role_hint == "merchant" and "merchant" in pools:
            candidates.append("merchant")
        if culture_hint == "concordant" and "generic" in pools:
            candidates.append("generic")
        if "fantasy" in pools:
            candidates.append("fantasy")
        if not candidates and pools:
            candidates = list(pools.keys())
        pool_key = rng.choice(candidates) if candidates else None
        pool = pools.get(pool_key, {}) if pool_key else {}
        gender_key = rng.choice(["male", "female"]) if pool else None
        first_list = list(pool.get(gender_key, []) or []) if gender_key else []
        last_list = list(pool.get("surname", []) or []) if pool else []
        def pick(lst: List[str], fallback: str) -> str:
            return lst[rng.randrange(len(lst))] if lst else fallback
        first = pick(first_list, "Alex")
        last = pick(last_list, "Smith")
        suffixes = ["an", "el", "is", "on", "ar", "ia"]
        if rng.random() < 0.3:
            first = first + rng.choice(suffixes)
        return f"{first} {last}"

```

### File: core\character\npc_family_generator.py

```python
#!/usr/bin/env python3
"""
NPCFamilyGenerator: Generate NPCs from families/variants configs (Phase 1).

Phase 1 goals:
- Load and merge NPC family definitions from config via GameConfig (no direct file reads)
- Generate a basic combat-ready NPC from a given family_id
- Map family stat_budgets (hp/damage/defense/initiative) to StatsManager primary/derived stats
- No equipment/ability generation yet

Note: This is a minimal generator to enable switching from legacy npc_templates
in a controlled manner (via system.npc_generation_mode = "families").
"""
from __future__ import annotations

import logging
import random
import re
from typing import Any, Dict, Optional, Tuple

from core.base.config import get_config
from core.character.npc_base import NPC, NPCType, NPCRelationship
from core.stats.stats_manager import StatsManager
from core.stats.stats_base import StatType, DerivedStatType
from core.stats.derived_stats import get_modifier_from_stat

logger = logging.getLogger(__name__)


class NPCFamilyGenerator:
    """Generate NPCs using the new families config (Phase 1).

    This generator:
    - Merges families from npc_families and npc_families_factions
    - Ignores variants in Phase 1 (added later)
    - Maps family stat_budgets to StatsManager values in a simple, reproducible way
    """

    def __init__(self) -> None:
        self._config = get_config()
        self._families: Dict[str, Dict[str, Any]] = self._load_and_merge_families()
        self._variants: Dict[str, Dict[str, Any]] = (self._config.get("npc_variants.variants") or {})
        self._tags: Dict[str, Any] = self._config.get("npc_tags.tags", {}) or {}
        self._overlays: Dict[str, Dict[str, Any]] = (self._config.get("npc_boss_overlays.overlays") or {})
        self._rules: Dict[str, Any] = (self._config.get("npc_generation_rules") or {})
        logger.info(
            f"NPCFamilyGenerator initialized. Families loaded: {len(self._families)} Variants loaded: {len(self._variants)} Overlays loaded: {len(self._overlays)}"
        )

    def _load_and_merge_families(self) -> Dict[str, Dict[str, Any]]:
        fams_base = (self._config.get("npc_families.families") or {})
        fams_factions = (self._config.get("npc_families_factions.families") or {})
        merged: Dict[str, Dict[str, Any]] = {}
        # Base first
        for k, v in fams_base.items():
            merged[k] = v
        # Faction overwrites if duplicated keys
        for k, v in fams_factions.items():
            merged[k] = v
        return merged

    def get_family(self, family_id: str) -> Optional[Dict[str, Any]]:
        return self._families.get(family_id)

    def get_variant(self, variant_id: str) -> Optional[Dict[str, Any]]:
        return self._variants.get(variant_id)

    def get_overlay(self, overlay_id: str) -> Optional[Dict[str, Any]]:
        return self._overlays.get(overlay_id)

    def choose_humanoid_family(self, culture_hint: Optional[str] = None, location: Optional[str] = None, seed: Optional[str] = None) -> Optional[str]:
        """Choose a humanoid family deterministically using a weighted distribution.

        Rules:
        - If culture_hint provided: 80% weight distributed evenly among humanoid families whose
          cultural_bias includes culture_hint; 20% weight among other humanoid families.
        - If no culture_hint: uniform among all humanoid families.
        - Deterministic selection using the provided seed (string); if None, random.
        """
        import hashlib, random as _random
        # Collect humanoid families
        humanoids: Dict[str, Dict[str, Any]] = {
            fid: fam for fid, fam in self._families.items()
            if (fam.get("actor_type") == "humanoid")
        }
        if not humanoids:
            return None
        favored: Dict[str, Dict[str, Any]] = {}
        others: Dict[str, Dict[str, Any]] = {}
        if culture_hint:
            for fid, fam in humanoids.items():
                cb = fam.get("cultural_bias") or []
                if isinstance(cb, list) and culture_hint in cb:
                    favored[fid] = fam
                else:
                    others[fid] = fam
        else:
            others = humanoids

        # Build weighted list
        weights: Dict[str, float] = {}
        if favored:
            w_fav_each = 0.8 / max(1, len(favored))
            for fid in favored:
                weights[fid] = weights.get(fid, 0.0) + w_fav_each
            w_oth_each = 0.2 / max(1, len(others))
            for fid in others:
                weights[fid] = weights.get(fid, 0.0) + w_oth_each
        else:
            # Uniform among all humanoids
            w_each = 1.0 / max(1, len(others))
            for fid in others:
                weights[fid] = w_each

        # Deterministic RNG
        rnd = _random.Random()
        if seed is not None:
            h = hashlib.md5(seed.encode("utf-8")).digest()
            rnd.seed(int.from_bytes(h, byteorder="big", signed=False))
        # Weighted choice
        fids = list(weights.keys())
        cumulative = []
        total = 0.0
        for fid in fids:
            total += float(weights[fid])
            cumulative.append(total)
        pick = rnd.random() * total
        for idx, cutoff in enumerate(cumulative):
            if pick <= cutoff:
                return fids[idx]
        return fids[-1] if fids else None

    def _apply_scaling(self, values: Tuple[float, float, float, float], level: int, encounter_size: str = "solo", difficulty: str = "normal") -> Tuple[float, float, float, float]:
        """Apply generation rules scaling (difficulty, level curves, encounter size) to (hp, dmg, def, init)."""
        hp, dmg, df, ini = values
        scaling = self._rules.get("scaling", {}) or {}
        # Difficulty
        dmap = (scaling.get("difficulty", {}) or {})
        dkey = (difficulty or "normal").lower()
        if dmap and dkey not in dmap:
            logger.warning(f"Unknown difficulty '{difficulty}', defaulting to 'normal'")
            dkey = "normal" if "normal" in dmap else next(iter(dmap.keys()), "normal")
        diff = dmap.get(dkey, {})
        hp *= float(diff.get("hp", 1.0) or 1.0)
        dmg *= float(diff.get("damage", 1.0) or 1.0)
        df *= float(diff.get("defense", 1.0) or 1.0)
        ini *= float(diff.get("initiative", 1.0) or 1.0)
        # Encounter size
        emap = (scaling.get("encounter_size", {}) or {})
        ekey = (encounter_size or "solo").lower()
        if emap and ekey not in emap:
            logger.warning(f"Unknown encounter_size '{encounter_size}', defaulting to 'solo'")
            ekey = "solo" if "solo" in emap else next(iter(emap.keys()), "solo")
        enc = emap.get(ekey, {})
        hp *= float(enc.get("hp", 1.0) or 1.0)
        dmg *= float(enc.get("damage", 1.0) or 1.0)
        df *= float(enc.get("defense", 1.0) or 1.0)
        ini *= float(enc.get("initiative", 1.0) or 1.0)
        # Level curve (with interpolation)
        plc = scaling.get("player_level_curve", {}) or {}
        def curve_mul(key: str) -> float:
            seg = plc.get(key, {})
            if not seg:
                return 1.0
            
            try:
                # Extract curve parameters
                start_level = int(seg.get("start_level", 1) or 1)
                end_level = int(seg.get("end_level", 20) or 20)
                curve_type = str(seg.get("curve", "linear") or "linear")
                base_multiplier = float(seg.get("multiplier", 1.0) or 1.0)
                
                # Clamp level to valid range
                effective_level = max(start_level, min(level, end_level))
                
                # No interpolation needed at endpoints
                if effective_level == start_level:
                    return base_multiplier
                if effective_level == end_level:
                    return base_multiplier
                
                # Normalize level to 0-1 range for interpolation
                t = (effective_level - start_level) / (end_level - start_level)
                
                # Apply curve function
                interpolated_t = t  # Default linear interpolation
                if curve_type == "log":
                    # Logarithmic: faster at start, slower at end
                    import math
                    interpolated_t = math.log(1 + t * 9) / math.log(10)  # log10(1+9t) maps 0->0, 1->1
                elif curve_type == "exp":
                    # Exponential: slower at start, faster at end
                    interpolated_t = (pow(10, t) - 1) / 9  # (10^t - 1)/9 maps 0->0, 1->1
                elif curve_type == "ease_in":
                    # Ease in: cubic - slow start, accelerated end
                    interpolated_t = t * t * t
                elif curve_type == "ease_out":
                    # Ease out: cubic - fast start, decelerated end
                    interpolated_t = 1 - pow(1 - t, 3)
                
                # Scale multiplier using interpolated value
                # A multiplier of 1.0 means no change, so we interpret base_multiplier as:
                # - If base_multiplier > 1.0, it's the maximum scaling factor at end_level
                # - If base_multiplier < 1.0, it's the minimum scaling factor at end_level
                if base_multiplier >= 1.0:
                    return 1.0 + (base_multiplier - 1.0) * interpolated_t
                else:
                    return 1.0 - (1.0 - base_multiplier) * interpolated_t
            except Exception as e:
                logger.warning(f"Error applying level curve for {key}: {e}")
                return 1.0
                
        hp *= curve_mul("hp")
        dmg *= curve_mul("damage")
        df *= curve_mul("defense")
        ini *= curve_mul("initiative")
        return hp, dmg, df, ini

    def _pick_within_budget(self, budget: Dict[str, Any]) -> float:
        try:
            vmin = float(budget.get("min", 0))
            vmax = float(budget.get("max", vmin))
        except Exception:
            vmin, vmax = 0.0, 0.0
        if vmax < vmin:
            vmax = vmin
        return random.uniform(vmin, vmax)

    def _mod_to_stat(self, mod: int) -> int:
        """Convert a D&D-like modifier back to a base stat value producing that mod.
        Example: mod=0 -> 10, mod=+2 -> 14, mod=-1 -> 8
        """
        return 10 + 2 * mod

    def _select_role_and_abilities(self, fam: Dict[str, Any], variant: Optional[Dict[str, Any]] = None, overlay: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Select a role from allowed_roles and compile abilities list.
        Phase 1: simple deterministic pick (first allowed role),
        abilities = family.global + role_overrides[role] + variant.abilities_add (if any),
        truncated by rules.max_abilities if present.
        """
        allowed_roles = list(fam.get("allowed_roles", []) or [])
        selected_role = allowed_roles[0] if allowed_roles else None
        pools = fam.get("ability_pools", {}) or {}
        abilities: list[str] = []
        abilities += list(pools.get("global", []) or [])
        if selected_role and isinstance(pools.get("role_overrides"), dict):
            abilities += list(pools.get("role_overrides", {}).get(selected_role, []) or [])
        if variant:
            abilities += list((variant.get("abilities_add") or []))
        if overlay:
            abilities += list((overlay.get("bonus_abilities") or []))
        # Deduplicate while preserving order
        seen = set()
        deduped = []
        for a in abilities:
            if a not in seen:
                seen.add(a)
                deduped.append(a)
        # Truncate by max_abilities
        max_abilities = None
        rules = fam.get("rules", {}) or {}
        if isinstance(rules.get("max_abilities"), int):
            max_abilities = int(rules.get("max_abilities"))
        if max_abilities is not None and max_abilities >= 0:
            deduped = deduped[:max_abilities]
        return {"role": selected_role, "abilities": deduped}

    def generate_npc_from_family(
        self,
        family_id: str,
        name: Optional[str] = None,
        location: Optional[str] = None,
        level: int = 1,
        overlay_id: Optional[str] = None,
        difficulty: str = "normal",
        encounter_size: str = "solo",
    ) -> NPC:
        """Generate an NPC with combat-ready stats from a family definition.

        Args:
            family_id: ID of the family (key in families maps)
            name: Optional explicit NPC name; if None uses family name
            location: Optional location string
            level: NPC level (Phase 1 uses level minimally)
        """
        fam = self.get_family(family_id)
        if not fam:
            raise ValueError(f"Family '{family_id}' not found")

        fam_name = fam.get("name", family_id.replace("_", " ").title())
        npc_name = name or self._maybe_generate_name_from_culture(fam, location) or fam_name

        # Budgets
        # Enforce overlay allowance
        if overlay_id:
            if not fam.get("is_boss_allowed", True):
                raise ValueError(f"Overlay '{overlay_id}' not allowed: family '{family_id}' disallows bosses")
            allowed = (fam.get("rules", {}) or {}).get("allowed_overlays")
            if isinstance(allowed, list) and allowed and overlay_id not in allowed:
                raise ValueError(f"Overlay '{overlay_id}' not in allowed_overlays for family '{family_id}'")
        budgets = fam.get("stat_budgets", {}) or {}
        target_hp = self._pick_within_budget(budgets.get("hp", {}))
        target_damage = self._pick_within_budget(budgets.get("damage", {}))
        target_defense = self._pick_within_budget(budgets.get("defense", {}))
        target_initiative = self._pick_within_budget(budgets.get("initiative", {}))

        # Apply overlay multipliers if provided
        overlay = None
        if overlay_id:
            overlay = self.get_overlay(overlay_id)
            if overlay:
                mult = overlay.get("multipliers", {}) or {}
                try:
                    target_hp *= float(mult.get("hp", 1.0))
                    target_damage *= float(mult.get("damage", 1.0))
                    target_defense *= float(mult.get("defense", 1.0))
                    target_initiative *= float(mult.get("initiative", 1.0))
                except Exception:
                    pass

        # Apply global scaling from rules (difficulty/encounter/level)
        # For Phase 1, assume difficulty=normal, encounter=solo; level is passed in
        target_hp, target_damage, target_defense, target_initiative = self._apply_scaling(
            (target_hp, target_damage, target_defense, target_initiative), level=level, encounter_size=encounter_size, difficulty=difficulty
        )

        # Map budgets -> primary stats (simple heuristics)
        # Initiative = DEX_mod + floor(WIS_mod/2). Phase 1: set WIS_mod=0, so INIT ~ DEX_mod.
        dex_mod_target = int(round(target_initiative))
        dex_mod_target = max(-2, min(6, dex_mod_target))  # Clamp

        # Defense = base_defense(10) + CON_mod + min(DEX_mod, 5)
        needed_mod_sum = int(round(target_defense)) - 10
        con_mod_target = needed_mod_sum - min(dex_mod_target, 5)
        con_mod_target = max(-2, min(6, con_mod_target))

        # Damage ~ base_dice_avg(≈3 for 1d4) + STR_mod. Use 3 as rough average.
        str_mod_target = int(round(target_damage - 3))
        str_mod_target = max(-2, min(6, str_mod_target))

        # Derive base stat scores from modifiers
        str_score = self._mod_to_stat(str_mod_target)
        dex_score = self._mod_to_stat(dex_mod_target)
        con_score = self._mod_to_stat(con_mod_target)
        int_score = 10
        wis_score = 10  # Keep 0 WIS_mod for Phase 1 simplicity
        cha_score = 10

        # Create StatsManager and apply primary stats
        sm = StatsManager()
        sm.set_level(max(1, int(level)))
        sm.set_base_stat(StatType.STRENGTH, float(str_score))
        sm.set_base_stat(StatType.DEXTERITY, float(dex_score))
        sm.set_base_stat(StatType.CONSTITUTION, float(con_score))
        sm.set_base_stat(StatType.INTELLIGENCE, float(int_score))
        sm.set_base_stat(StatType.WISDOM, float(wis_score))
        sm.set_base_stat(StatType.CHARISMA, float(cha_score))

        # After derived stats computed, adjust current resources
        # Set current HP to min(target_hp, MAX_HEALTH). Keep at least 1.
        try:
            max_hp = sm.get_stat_value(DerivedStatType.MAX_HEALTH)
        except Exception:
            max_hp = 1.0
        desired_hp = max(1.0, min(float(target_hp), float(max_hp)))
        sm.set_current_stat(DerivedStatType.HEALTH, desired_hp)
        # Start stamina/mana at max/zero for Phase 1 simplicity
        try:
            max_stamina = sm.get_stat_value(DerivedStatType.MAX_STAMINA)
            sm.set_current_stat(DerivedStatType.STAMINA, max_stamina)
        except Exception:
            pass
        try:
            max_mana = sm.get_stat_value(DerivedStatType.MAX_MANA)
            sm.set_current_stat(DerivedStatType.MANA, 0.0 if max_mana > 0 else 0.0)
        except Exception:
            pass

        # Build NPC
        npc = NPC(
            name=npc_name,
            npc_type=NPCType.ENEMY,
            relationship=NPCRelationship.HOSTILE,
            location=location,
            description=fam.get("description", f"A {fam_name}"),
            is_persistent=False,
        )
        npc.stats_manager = sm
        npc.stats_generated = True

        # Remember family used
        if npc.known_information is None:
            npc.known_information = {}
        npc.known_information["family_id"] = family_id
        npc.known_information["generator"] = "families_phase1"
        if overlay and overlay.get("is_boss"):
            # Append a boss tag and overlay id
            tags = npc.known_information.get("tags", [])
            if isinstance(tags, list):
                tags = list(tags)
                tags.append("is_boss:true")
                npc.known_information["tags"] = tags
            npc.known_information["boss_overlay_id"] = overlay_id

        # Attach tags from family
        default_tags = fam.get("default_tags", []) or []
        npc.known_information["tags"] = list(default_tags)
        # Attach selected role and abilities (metadata for now)
        ra = self._select_role_and_abilities(fam, overlay=overlay)
        if ra.get("role"):
            npc.known_information["role"] = ra["role"]
        if ra.get("abilities"):
            npc.known_information["abilities"] = ra["abilities"]

        logger.info(
            f"Generated NPC from family='{family_id}' name='{npc.name}' STR={str_score} DEX={dex_score} CON={con_score} "
            f"HP={desired_hp:.0f}/{max_hp:.0f} DEF~{sm.get_stat_value(DerivedStatType.DEFENSE):.0f} INIT~{sm.get_stat_value(DerivedStatType.INITIATIVE):.0f}"
        )
        return npc

    # ---- Name generation helpers ----
    def _maybe_generate_name_from_culture(self, fam: Dict[str, Any], location: Optional[str]) -> Optional[str]:
        """Generate a culture-aware name for humanoids if possible.
        Uses config/npc/names.json and location culture or defaults. Returns None if not applicable.
        """
        try:
            if (fam.get("actor_type") or "").lower() != "humanoid":
                return None
            # Determine culture hint
            culture = None
            try:
                loc_id = (location or "").strip()
                if loc_id:
                    mix = self._config.get(f"locations.{loc_id}.culture_mix") or {}
                    if isinstance(mix, dict) and mix:
                        culture = self._choose_from_weighted_map(mix, seed=f"name|{loc_id}|{fam.get('id','')}|{fam.get('name','')}")
                    else:
                        culture = self._config.get(f"locations.{loc_id}.culture")
                if not culture:
                    mix_def = self._config.get("location_defaults.culture_mix") or {}
                    if isinstance(mix_def, dict) and mix_def:
                        culture = self._choose_from_weighted_map(mix_def, seed=f"name|default|{fam.get('id','')}")
            except Exception:
                culture = None
            names = self._config.get("npc_names.cultures") or {}
            spec = names.get(culture) or names.get("generic") or {}
            if not spec:
                return None
            # Build name using tokens (FN, FN2, MI, LN, LN2)
            pats = spec.get("patterns") or ["FN LN"]
            pattern = random.choice(pats)
            fn = self._gen_first(spec)
            fn2 = self._gen_first(spec)
            if fn2 == fn:
                for _ in range(2):
                    alt = self._gen_first(spec)
                    if alt != fn:
                        fn2 = alt
                        break
            ln = self._gen_last(spec)
            ln2 = self._gen_last(spec)
            if ln2 == ln:
                for _ in range(2):
                    alt = self._gen_last(spec)
                    if alt != ln:
                        ln2 = alt
                        break
            mi = (fn2[0:1].upper() + ".") if fn2 else "X."
            token_map = {"FN2": fn2, "FN": fn, "LN2": ln2, "LN": ln, "MI": mi}
            name = re.sub(r"\b(FN2|FN|LN2|LN|MI)\b", lambda m: token_map.get(m.group(0), m.group(0)), pattern).strip()
            name = " ".join(p for p in name.split(" ") if p)
            allowed = spec.get("allowed_chars", "^[A-Za-zÀ-ÖØ-öø-ÿ' -]+$")
            if not allowed.startswith("^"):
                allowed = "^" + allowed
            if not allowed.endswith("$"):
                allowed = allowed + "$"
            try:
                if not re.fullmatch(allowed, name):
                    name = re.sub(r"[^A-Za-zÀ-ÖØ-öø-ÿ' -]", "", name)
            except re.error:
                pass
            return name
        except Exception:
            return None

    def _gen_first(self, spec: Dict[str, Any]) -> str:
        syllables = spec.get("first_syllables") or ["al","an","ar","el","ia","ro","li","ma","tha"]
        k = 2 if random.random() < 0.75 else 3
        parts = [random.choice(syllables) for _ in range(k)]
        s = "".join(parts)
        return s.capitalize()

    def _gen_last(self, spec: Dict[str, Any]) -> str:
        prefixes = spec.get("last_prefixes") or ["stone", "silver", "gold", "fair", "wood"]
        cores = spec.get("last_cores") or ["smith", "walker", "binder", "seeker", "wright"]
        suffixes = spec.get("last_suffixes") or ["", "son", "ton", "ford", "field"]
        p = random.choice(prefixes) if prefixes else ""
        c = random.choice(cores) if cores else ""
        s = random.choice(suffixes) if suffixes else ""
        ln = f"{p}{c}{s}" if (p or c or s) else "Name"
        return ln[:1].upper() + ln[1:]

    def _choose_from_weighted_map(self, weights: dict, seed: str) -> Optional[str]:
        import hashlib
        rnd = random.Random()
        h = hashlib.md5(seed.encode("utf-8")).digest()
        rnd.seed(int.from_bytes(h, byteorder="big", signed=False))
        items = [(k, float(v)) for k, v in weights.items() if isinstance(v, (int, float)) and float(v) > 0]
        if not items:
            return None
        total = sum(w for _, w in items)
        pick = rnd.random() * total
        acc = 0.0
        for k, w in items:
            acc += w
            if pick <= acc:
                return k
        return items[-1][0] if items else None

    def generate_npc_from_variant(
        self,
        variant_id: str,
        name: Optional[str] = None,
        location: Optional[str] = None,
        level: int = 1,
        overlay_id: Optional[str] = None,
        difficulty: str = "normal",
        encounter_size: str = "solo",
    ) -> NPC:
        """Generate an NPC using a variant layered on top of a family (Phase 1).

        This applies variant stat_modifiers to the family's stat budgets before
        mapping to StatsManager stats. Order of application per stat:
          1) multiply (mul), 2) add (add) if present.
        """
        var = self.get_variant(variant_id)
        if not var:
            raise ValueError(f"Variant '{variant_id}' not found")
        family_id = var.get("family_id")
        fam = self.get_family(family_id)
        if not fam:
            raise ValueError(f"Family '{family_id}' (from variant '{variant_id}') not found")

        fam_name = fam.get("name", family_id.replace("_", " ").title())
        npc_name = name or var.get("name") or fam_name

        # Base budgets from family
        budgets = fam.get("stat_budgets", {}) or {}
        target_hp = self._pick_within_budget(budgets.get("hp", {}))
        target_damage = self._pick_within_budget(budgets.get("damage", {}))
        target_defense = self._pick_within_budget(budgets.get("defense", {}))
        target_initiative = self._pick_within_budget(budgets.get("initiative", {}))

        # Apply variant modifiers
        mods = (var.get("stat_modifiers") or {})

        # Apply overlay multipliers if provided
        overlay = None
        if overlay_id:
            overlay = self.get_overlay(overlay_id)
            if overlay:
                mult = overlay.get("multipliers", {}) or {}
                try:
                    target_hp *= float(mult.get("hp", 1.0))
                    target_damage *= float(mult.get("damage", 1.0))
                    target_defense *= float(mult.get("defense", 1.0))
                    target_initiative *= float(mult.get("initiative", 1.0))
                except Exception:
                    pass

        # Apply global scaling from rules (difficulty/encounter/level)
        target_hp, target_damage, target_defense, target_initiative = self._apply_scaling(
            (target_hp, target_damage, target_defense, target_initiative), level=level, encounter_size=encounter_size, difficulty=difficulty
        )
        def apply_mod(val: float, spec: Optional[Dict[str, Any]]) -> float:
            if not spec:
                return val
            try:
                if "mul" in spec and spec["mul"] is not None:
                    val = float(val) * float(spec["mul"])
                if "add" in spec and spec["add"] is not None:
                    val = float(val) + float(spec["add"])
            except Exception:
                # Ignore malformed modifiers; keep original val
                pass
            return val

        target_hp = apply_mod(target_hp, mods.get("hp"))
        target_damage = apply_mod(target_damage, mods.get("damage"))
        target_defense = apply_mod(target_defense, mods.get("defense"))
        target_initiative = apply_mod(target_initiative, mods.get("initiative"))

        # Map budgets -> primary stats using same heuristics as family-only path
        dex_mod_target = int(round(target_initiative))
        dex_mod_target = max(-2, min(6, dex_mod_target))

        needed_mod_sum = int(round(target_defense)) - 10
        con_mod_target = needed_mod_sum - min(dex_mod_target, 5)
        con_mod_target = max(-2, min(6, con_mod_target))

        str_mod_target = int(round(target_damage - 3))
        str_mod_target = max(-2, min(6, str_mod_target))

        str_score = self._mod_to_stat(str_mod_target)
        dex_score = self._mod_to_stat(dex_mod_target)
        con_score = self._mod_to_stat(con_mod_target)
        int_score = 10
        wis_score = 10
        cha_score = 10

        sm = StatsManager()
        sm.set_level(max(1, int(level)))
        sm.set_base_stat(StatType.STRENGTH, float(str_score))
        sm.set_base_stat(StatType.DEXTERITY, float(dex_score))
        sm.set_base_stat(StatType.CONSTITUTION, float(con_score))
        sm.set_base_stat(StatType.INTELLIGENCE, float(int_score))
        sm.set_base_stat(StatType.WISDOM, float(wis_score))
        sm.set_base_stat(StatType.CHARISMA, float(cha_score))

        try:
            max_hp = sm.get_stat_value(DerivedStatType.MAX_HEALTH)
        except Exception:
            max_hp = 1.0
        desired_hp = max(1.0, min(float(target_hp), float(max_hp)))
        sm.set_current_stat(DerivedStatType.HEALTH, desired_hp)
        try:
            max_stamina = sm.get_stat_value(DerivedStatType.MAX_STAMINA)
            sm.set_current_stat(DerivedStatType.STAMINA, max_stamina)
        except Exception:
            pass
        try:
            max_mana = sm.get_stat_value(DerivedStatType.MAX_MANA)
            sm.set_current_stat(DerivedStatType.MANA, 0.0 if max_mana > 0 else 0.0)
        except Exception:
            pass

        npc = NPC(
            name=npc_name,
            npc_type=NPCType.ENEMY,
            relationship=NPCRelationship.HOSTILE,
            location=location,
            description=var.get("description") or fam.get("description", f"A {fam_name}"),
            is_persistent=False,
        )
        npc.stats_manager = sm
        npc.stats_generated = True

        if npc.known_information is None:
            npc.known_information = {}
        npc.known_information["family_id"] = family_id
        npc.known_information["variant_id"] = variant_id
        npc.known_information["generator"] = "families_phase1"
        if overlay and overlay.get("is_boss"):
            tags = npc.known_information.get("tags", [])
            if isinstance(tags, list):
                tags = list(tags)
                tags.append("is_boss:true")
                npc.known_information["tags"] = tags
            npc.known_information["boss_overlay_id"] = overlay_id

        # Attach tags: family defaults + variant tags_add (if present)
        default_tags = fam.get("default_tags", []) or []
        tags_add = (var.get("tags_add") or [])
        npc.known_information["tags"] = list(default_tags) + list(tags_add)

        # Select role and abilities including variant adds and overlay bonuses
        ra = self._select_role_and_abilities(fam, variant=var, overlay=overlay)
        if ra.get("role"):
            npc.known_information["role"] = ra["role"]
        if ra.get("abilities"):
            npc.known_information["abilities"] = ra["abilities"]
        # Also record roles_add explicitly for traceability
        if var.get("roles_add"):
            npc.known_information["roles_add"] = list(var.get("roles_add") or [])

        logger.info(
            f"Generated NPC from variant='{variant_id}' (family='{family_id}') name='{npc.name}'"
            f" HP={desired_hp:.0f}/{max_hp:.0f} DEF~{sm.get_stat_value(DerivedStatType.DEFENSE):.0f}"
            f" INIT~{sm.get_stat_value(DerivedStatType.INITIATIVE):.0f}"
        )
        return npc


```

### File: core\character\npc_flavor.py

```python
#!/usr/bin/env python3
"""
Attempt to enrich NPC flavor (short description and short backstory) using the LLM system.
This function is safe to call: it catches exceptions and only updates fields if LLM returns
usable content. It respects existing description if provided and only fills what's missing
or appends a short backstory if absent.
"""
from __future__ import annotations

from typing import Optional
from core.utils.logging_config import get_logger
from core.base.config import get_config

logger = get_logger("NPC_FLAVOR")


def attempt_enrich_npc_flavor(npc) -> None:
    try:
        cfg = get_config()
        llm_enabled = bool(cfg.get("llm.enabled", False))
    except Exception:
        llm_enabled = False

    if not llm_enabled:
        return

    # Prefer using the existing engine AgentManager pipeline
    try:
        from core.base.engine import get_game_engine
        engine = get_game_engine()
        game_state = engine.state_manager.current_state if engine and hasattr(engine, 'state_manager') else None
        if not engine or not engine._agent_manager or not game_state:
            return
    except Exception as e:
        logger.warning(f"LLM engine/manager unavailable: {e}")
        return

    # Build a compact structured prompt reflecting rules and context
    ki = getattr(npc, "known_information", None) or {}
    tags = ki.get("tags", [])
    flavor_ctx = ki.get("flavor_context", {})
    family_id = flavor_ctx.get("family_id") or ki.get("family_id")
    culture = flavor_ctx.get("culture")
    location = flavor_ctx.get("location")
    kind = flavor_ctx.get("kind")

    # Construct a user prompt text; engine will pass it to AgentManager
    policy = (
        "Rules: concise, lore-consistent; no meta; do not provide hints or spoilers; respect cultural tone.\n"
    )
    need_desc = not bool(getattr(npc, "description", None))
    need_back = not bool(ki.get("backstory"))
    if not need_desc and not need_back:
        return

    prompt = (
        f"Enrich NPC flavor. {policy}"
        f"DATA: name={npc.name!r} family_id={family_id!r} tags={tags} culture={culture!r} location={location!r} kind={kind!r}.\n"
        f"Please return a short description and a short backstory."
    )

    try:
        text, commands = engine._agent_manager.process_input(game_state=game_state, player_input=prompt)
        text = (text or "").strip()
        if not text:
            return
        parts = [p.strip() for p in text.split("\n\n") if p.strip()]
        if need_desc and parts:
            npc.description = parts[0][:240]
        if need_back:
            backstory = parts[1] if len(parts) > 1 else (parts[0] if parts else "")
            if backstory:
                ki["backstory"] = backstory[:480]
                npc.known_information = ki
    except Exception as e:
        logger.warning(f"Flavor enrichment failed: {e}")


```

### File: core\character\npc_generator.py

```python
#!/usr/bin/env python3
"""
NPC generator for creating NPCs with appropriate stats based on interaction needs.
"""

import random
import logging
import os
import json
from typing import Dict, List, Any, Optional, Tuple, Union

from core.character.npc_base import NPC, NPCType, NPCRelationship, NPCInteractionType
from core.stats.stats_manager import StatsManager
from core.stats.stats_base import StatType, DerivedStatType, Stat
from core.stats.combat_effects import StatusEffect, StatusEffectType
from core.inventory.item_factory import ItemFactory
from core.inventory.item_template_loader import get_item_template_loader
from core.inventory.item_variation_generator import ItemVariationGenerator
from core.inventory.item_enums import ItemType, ItemRarity, EquipmentSlot
from core.inventory.equipment_manager import EquipmentManager

logger = logging.getLogger(__name__)


class NPCGenerator:
    """
    Generator for creating NPCs with appropriate attributes and stats.
    Handles generation of NPCs based on context and interaction needs.
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Initialize the NPC generator.
        
        Args:
            config_path: Path to configuration file with NPC templates and generation rules.
        """
        self.config = {}
        self.templates = {}
        self.name_pools = {}
        
        # Default config path
        if config_path is None:
            config_path = os.path.join("config", "character", "npc_templates.json")
        
        # Load configuration if it exists
        if os.path.exists(config_path):
            self._load_config(config_path)
        else:
            logger.warning(f"NPC templates configuration not found at: {config_path}")
            self._initialize_default_config()
    
    def _load_config(self, config_path: str) -> None:
        """
        Load NPC generation configuration from a JSON file.
        
        Args:
            config_path: Path to the configuration file.
        """
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                self.config = json.load(f)
            
            # Extract templates and name pools
            self.templates = self.config.get("templates", {})
            self.name_pools = self.config.get("name_pools", {})
            
            logger.info(f"Loaded NPC generation config from {config_path}")
        except Exception as e:
            logger.error(f"Error loading NPC config: {e}")
            self._initialize_default_config()
    
    def _initialize_default_config(self) -> None:
        """Initialize with default configuration if no file is found."""
        self.config = {
            "templates": {
                "merchant": {
                    "npc_type": "MERCHANT",
                    "stat_distributions": {
                        "STR": {"min": 8, "max": 12},
                        "DEX": {"min": 8, "max": 14},
                        "CON": {"min": 8, "max": 12},
                        "INT": {"min": 10, "max": 16},
                        "WIS": {"min": 10, "max": 16},
                        "CHA": {"min": 12, "max": 18}
                    },
                    "personality_traits": [
                        "Shrewd", "Calculating", "Friendly", "Talkative",
                        "Suspicious", "Generous", "Greedy"
                    ]
                },
                "guard": {
                    "npc_type": "NEUTRAL",
                    "stat_distributions": {
                        "STR": {"min": 12, "max": 16},
                        "DEX": {"min": 10, "max": 14},
                        "CON": {"min": 12, "max": 16},
                        "INT": {"min": 8, "max": 12},
                        "WIS": {"min": 10, "max": 14},
                        "CHA": {"min": 8, "max": 12}
                    },
                    "personality_traits": [
                        "Dutiful", "Vigilant", "Stern", "Authoritative",
                        "Lazy", "Corrupt", "Honorable"
                    ]
                },
                "commoner": {
                    "npc_type": "BACKGROUND",
                    "stat_distributions": {
                        "STR": {"min": 8, "max": 12},
                        "DEX": {"min": 8, "max": 12},
                        "CON": {"min": 8, "max": 12},
                        "INT": {"min": 8, "max": 12},
                        "WIS": {"min": 8, "max": 12},
                        "CHA": {"min": 8, "max": 12}
                    },
                    "personality_traits": [
                        "Hardworking", "Simple", "Curious", "Suspicious",
                        "Friendly", "Reserved", "Gossipy"
                    ]
                }
            },
            "name_pools": {
                "generic": {
                    "male": ["John", "William", "Thomas", "James", "George", "Robert"],
                    "female": ["Mary", "Elizabeth", "Sarah", "Anne", "Margaret", "Jane"],
                    "surname": ["Smith", "Jones", "Brown", "Williams", "Taylor", "Davies"]
                }
            }
        }
        
        self.templates = self.config["templates"]
        self.name_pools = self.config["name_pools"]
        
        logger.info("Initialized default NPC generation config")
    
    def generate_random_name(self, gender: Optional[str] = None, name_pool: str = "generic") -> str:
        """
        Generate a random name for an NPC.
        
        Args:
            gender: Optional gender ('male', 'female', None for random)
            name_pool: Name pool to use from config
            
        Returns:
            A random name
        """
        if name_pool not in self.name_pools:
            name_pool = "generic"
            
        if name_pool not in self.name_pools:
            # Fallback if no pools are available
            return f"NPC-{random.randint(1000, 9999)}"
        
        # Select gender if not specified
        if gender is None:
            gender = random.choice(["male", "female"])
        
        # Ensure pools exist
        if gender not in self.name_pools[name_pool]:
            gender = list(self.name_pools[name_pool].keys())[0]
        
        if "surname" not in self.name_pools[name_pool]:
            return random.choice(self.name_pools[name_pool][gender])
        
        # Generate full name
        first_name = random.choice(self.name_pools[name_pool][gender])
        surname = random.choice(self.name_pools[name_pool]["surname"])
        
        return f"{first_name} {surname}"
    
    def generate_minimal_npc(self, name: Optional[str] = None, npc_type: NPCType = NPCType.BACKGROUND) -> NPC:
        """
        Generate a minimal NPC with just basic information.
        
        Args:
            name: Optional name for the NPC (generated if None)
            npc_type: Type of NPC to generate
            
        Returns:
            An NPC object with minimal details
        """
        # Generate name if not provided
        if name is None:
            name = self.generate_random_name()
        
        # Create basic NPC
        npc = NPC(
            name=name,
            npc_type=npc_type,
            description=f"A {npc_type.name.lower()} named {name}."
        )
        
        logger.debug(f"Generated minimal NPC: {npc.name}")
        return npc
    
    def _select_template(self, npc_type: NPCType, npc_subtype: Optional[str] = None) -> Dict[str, Any]:
        """
        Select an appropriate template for the NPC type.
        
        Args:
            npc_type: The type of NPC to generate
            npc_subtype: Optional subtype (e.g., 'boss_dragon', 'merchant')
            
        Returns:
            A template dictionary
        """
        # If a subtype is provided, check if it exists as a template
        if npc_subtype and npc_subtype in self.templates:
            logger.debug(f"Using specific template for subtype: {npc_subtype}")
            return self.templates[npc_subtype]
            
        # Try to find a direct match for the type
        type_name = npc_type.name.lower()
        if type_name in self.templates:
            return self.templates[type_name]
        
        # Check for boss-type NPCs
        if npc_subtype and "boss" in npc_subtype.lower():
            # Look for boss templates in specialized_types
            if "specialized_types" in self.config and "boss" in self.config["specialized_types"]:
                boss_templates = self.config["specialized_types"]["boss"].get("templates", [])
                if boss_templates:
                    boss_template = random.choice(boss_templates)
                    if boss_template in self.templates:
                        logger.info(f"Using boss template for subtype: {npc_subtype}")
                        return self.templates[boss_template]
            
            # If we still need a boss template, look for any template starting with "boss_"
            boss_templates = [t for t in self.templates.keys() if t.startswith("boss_")]
            if boss_templates:
                boss_template = random.choice(boss_templates)
                logger.info(f"Using random boss template: {boss_template}")
                return self.templates[boss_template]
        
        # Fallback templates based on NPC type
        fallbacks = {
            NPCType.MERCHANT: "merchant",
            NPCType.QUEST_GIVER: "quest_giver",
            NPCType.ALLY: "ally",
            NPCType.ENEMY: "bandit",  # Changed from generic "enemy" to "bandit"
            NPCType.NEUTRAL: "commoner",
            NPCType.SERVICE: "merchant",
            NPCType.BACKGROUND: "commoner"
        }
        
        # Try to use the fallback template for this NPC type
        if npc_type in fallbacks and fallbacks[npc_type] in self.templates:
            return self.templates[fallbacks[npc_type]]
        
        # Check for "blank_template" for unexpected NPC types
        if "blank_template" in self.templates:
            logger.info(f"Using blank template for unexpected NPC type: {npc_type} (subtype: {npc_subtype})")
            return self.templates["blank_template"]
        
        # Last resort - use commoner template
        if "commoner" in self.templates:
            logger.warning(f"Using commoner template as fallback for unexpected NPC type: {npc_type}")
            return self.templates["commoner"]
        
        # Absolute fallback - just return a basic template
        logger.warning(f"No suitable template found for NPC type: {npc_type}, using basic stats")
        return {
            "npc_type": npc_type.name,
            "stat_distributions": {
                "STR": {"min": 8, "max": 14},
                "DEX": {"min": 8, "max": 14},
                "CON": {"min": 8, "max": 14},
                "INT": {"min": 8, "max": 14},
                "WIS": {"min": 8, "max": 14},
                "CHA": {"min": 8, "max": 14}
            },
            "personality_traits": ["Unique", "Distinctive", "Individual"]
        }
    
    def _generate_stats(self, 
                       npc: NPC, 
                       interaction_type: NPCInteractionType,
                       template: Dict[str, Any]) -> None:
        """
        Generate stats for an NPC based on the interaction type and template.
        
        Args:
            npc: The NPC to generate stats for
            interaction_type: The type of interaction (determines which stats to focus on)
            template: The template to use for generation
        """
        # Create stats manager
        stats_manager = StatsManager()
        
        # Generate primary stats based on template distributions
        stat_distributions = template.get("stat_distributions", {})
        
        for stat_type in StatType:
            stat_name = stat_type.name
            if stat_name in stat_distributions:
                min_val = stat_distributions[stat_name].get("min", 8)
                max_val = stat_distributions[stat_name].get("max", 14)
                value = random.randint(min_val, max_val)
            else:
                # Default range if not specified
                value = random.randint(8, 14)
            
            # Adjust stats based on interaction type
            if interaction_type == NPCInteractionType.COMBAT:
                # For combat, boost combat-relevant stats
                if stat_type in [StatType.STRENGTH, StatType.DEXTERITY, StatType.CONSTITUTION]:
                    value = max(value, random.randint(12, 16))
            
            elif interaction_type == NPCInteractionType.SOCIAL:
                # For social, boost social stats
                if stat_type in [StatType.CHARISMA, StatType.WISDOM]:
                    value = max(value, random.randint(12, 16))
            
            elif interaction_type == NPCInteractionType.COMMERCE:
                # For commerce, boost charisma and intelligence
                if stat_type in [StatType.CHARISMA, StatType.INTELLIGENCE]:
                    value = max(value, random.randint(12, 16))
            
            elif interaction_type == NPCInteractionType.INFORMATION:
                # For information providers, boost intelligence and wisdom
                if stat_type in [StatType.INTELLIGENCE, StatType.WISDOM]:
                    value = max(value, random.randint(12, 16))
            
            # Set the stat value
            stats_manager.set_base_stat(stat_type, value)
        
        # For combat NPCs, generate some appropriate equipment modifiers
        if interaction_type == NPCInteractionType.COMBAT:
            try:
                logger.info(f"Starting equipment generation for NPC {npc.name}")
                self._generate_equipment(npc, interaction_type, template)
                logger.info(f"Completed equipment generation for NPC {npc.name}")
            except Exception as e:
                logger.error(f"Equipment generation failed for NPC {npc.name}: {e}", exc_info=True)
                # Ensure NPC has at least an empty equipment manager
                if not hasattr(npc, 'equipment_manager'):
                    npc.equipment_manager = EquipmentManager()
                logger.info(f"Created fallback equipment manager for NPC {npc.name}")
        
        # Set the stats manager on the NPC
        npc.stats_manager = stats_manager
        npc.stats_generated = True
    
    def _generate_personality(self, template: Dict[str, Any]) -> str:
        """
        Generate a personality description for an NPC.
        
        Args:
            template: The template to use for generation
            
        Returns:
            A personality description
        """
        traits = template.get("personality_traits", ["Unremarkable"])
        
        # Pick 1-3 traits
        num_traits = min(3, len(traits))
        selected_traits = random.sample(traits, random.randint(1, num_traits))
        
        # Form a simple personality description
        if len(selected_traits) == 1:
            return f"A {selected_traits[0].lower()} individual."
        else:
            traits_text = ", ".join(t.lower() for t in selected_traits[:-1])
            return f"A {traits_text} and {selected_traits[-1].lower()} individual."
    
    def generate_npc_for_interaction(self, 
                                    interaction_type: NPCInteractionType,
                                    name: Optional[str] = None,
                                    npc_type: Optional[NPCType] = None,
                                    npc_subtype: Optional[str] = None,
                                    relationship: NPCRelationship = NPCRelationship.NEUTRAL,
                                    location: Optional[str] = None,
                                    description: Optional[str] = None,
                                    occupation: Optional[str] = None,
                                    is_persistent: bool = False) -> NPC:
        """
        Generate an NPC customized for a specific type of interaction.
        
        Args:
            interaction_type: The type of interaction this NPC is for
            name: Optional name for the NPC (generated if None)
            npc_type: Type of NPC (determined from interaction if None)
            npc_subtype: Optional subtype (e.g., 'boss_dragon', 'merchant')
            relationship: Initial relationship with the player
            location: Where the NPC is located
            description: Optional description of the NPC
            occupation: Optional occupation
            is_persistent: Whether this NPC should be saved persistently
            
        Returns:
            An NPC with appropriate stats for the interaction
        """
        # Determine NPC type if not provided
        if npc_type is None:
            # Default types based on interaction
            type_mapping = {
                NPCInteractionType.COMBAT: NPCType.ENEMY,
                NPCInteractionType.SOCIAL: NPCType.NEUTRAL,
                NPCInteractionType.COMMERCE: NPCType.MERCHANT,
                NPCInteractionType.QUEST: NPCType.QUEST_GIVER,
                NPCInteractionType.INFORMATION: NPCType.NEUTRAL,
                NPCInteractionType.SERVICE: NPCType.SERVICE,
                NPCInteractionType.MINIMAL: NPCType.BACKGROUND
            }
            npc_type = type_mapping.get(interaction_type, NPCType.NEUTRAL)
        
        # Generate name if not provided
        if name is None:
            # Try to use a name pool for the subtype if specified
            if npc_subtype and npc_subtype in self.name_pools:
                name = self.generate_random_name(name_pool=npc_subtype)
            else:
                name = self.generate_random_name()
        
        # Select template based on NPC type and subtype
        template = self._select_template(npc_type, npc_subtype)
        
        # Generate personality
        personality = self._generate_personality(template)
        
        # Create the NPC
        npc = NPC(
            name=name,
            npc_type=npc_type,
            relationship=relationship,
            location=location,
            description=description or f"A {npc_subtype or npc_type.name.lower()} named {name}.",
            occupation=occupation,
            personality=personality,
            is_persistent=is_persistent
        )
        
        # Store the subtype in known_information if provided
        if npc_subtype:
            if not npc.known_information:
                npc.known_information = {}
            npc.known_information["subtype"] = npc_subtype
        
        # Generate stats appropriate for the interaction
        if interaction_type != NPCInteractionType.MINIMAL:
            self._generate_stats(npc, interaction_type, template)
        
        logger.info(f"Generated NPC for {interaction_type.name} interaction: {npc.name}")
        return npc
    
    def enhance_npc_for_new_interaction(self, 
                                       npc: NPC, 
                                       interaction_type: NPCInteractionType) -> None:
        """
        Enhance an existing NPC with additional details for a new type of interaction.
        
        Args:
            npc: The NPC to enhance
            interaction_type: The new interaction type
        """
        # Get subtype if stored in known_information
        npc_subtype = None
        if npc.known_information and "subtype" in npc.known_information:
            npc_subtype = npc.known_information["subtype"]
        
        # If stats haven't been generated yet, generate them
        if not npc.has_stats():
            template = self._select_template(npc.npc_type, npc_subtype)
            self._generate_stats(npc, interaction_type, template)
            logger.info(f"Generated stats for existing NPC {npc.name} for {interaction_type.name} interaction")
        
        # For combat interactions, ensure combat-related stats are suitable
        if (interaction_type == NPCInteractionType.COMBAT and 
            npc.has_stats() and 
            npc.get_stat(StatType.STRENGTH) < 10):
            
            # Check if this NPC should use boss stats
            is_boss = npc_subtype and "boss" in npc_subtype.lower()
            
            # Boost combat stats more significantly for bosses
            for stat_type in [StatType.STRENGTH, StatType.DEXTERITY, StatType.CONSTITUTION]:
                current_val = npc.get_stat(stat_type) or 8
                if current_val < 12:
                    if is_boss:
                        new_val = random.randint(14, 18)  # Higher stats for bosses
                    else:
                        new_val = random.randint(12, 16)
                    npc.stats_manager.set_base_stat(stat_type, new_val)
                    logger.debug(f"Boosted {stat_type.name} for NPC {npc.name} from {current_val} to {new_val}")
        
        # Similar adjustments for other interaction types
        elif (interaction_type == NPCInteractionType.SOCIAL and 
              npc.has_stats() and 
              npc.get_stat(StatType.CHARISMA) < 10):
            
            # Boost social stats
            for stat_type in [StatType.CHARISMA, StatType.WISDOM]:
                current_val = npc.get_stat(stat_type) or 8
                if current_val < 12:
                    new_val = random.randint(12, 16)
                    npc.stats_manager.set_base_stat(stat_type, new_val)
        
        # Add more personality details if needed
        if not npc.personality:
            template = self._select_template(npc.npc_type, npc_subtype)
            npc.personality = self._generate_personality(template)
    
    def generate_enemy_npc(self, 
                          name: Optional[str] = None,
                          enemy_type: str = "generic",
                          level: int = 1,
                          location: Optional[str] = None) -> NPC:
        """
        Generate an enemy NPC for combat.
        
        Args:
            name: Optional name for the enemy
            enemy_type: Type of enemy (e.g., "bandit", "wolf", "guard")
            level: Level of the enemy, affects stats
            location: Where the enemy is located
            
        Returns:
            An NPC ready for combat
        """
        # Check if we have a template for this enemy type
        if enemy_type in self.templates:
            template = self.templates[enemy_type]
        else:
            # Fallback to generic enemy template
            template = self._select_template(NPCType.ENEMY)
        
        # Generate name if not provided
        if name is None:
            if enemy_type in self.name_pools:
                name = self.generate_random_name(name_pool=enemy_type)
            else:
                name = f"{enemy_type.capitalize()} {random.choice(['Minion', 'Warrior', 'Brute', 'Thug'])}"
        
        # Create the enemy NPC
        npc = NPC(
            name=name,
            npc_type=NPCType.ENEMY,
            relationship=NPCRelationship.HOSTILE,
            location=location,
            description=f"A hostile {enemy_type} named {name}."
        )
        
        # Generate combat stats
        stats_manager = StatsManager()
        
        # Scale stats based on level
        level_modifier = max(0, (level - 1) * 2)  # +2 to stats per level
        
        # Generate primary stats based on template and level
        stat_distributions = template.get("stat_distributions", {})
        
        for stat_type in StatType:
            stat_name = stat_type.name
            if stat_name in stat_distributions:
                min_val = stat_distributions[stat_name].get("min", 8) + level_modifier
                max_val = stat_distributions[stat_name].get("max", 14) + level_modifier
                value = random.randint(min_val, max_val)
            else:
                # Default range if not specified
                value = random.randint(8 + level_modifier, 14 + level_modifier)
            
            # Set the stat value
            stats_manager.set_base_stat(stat_type, value)
        
        # Set the stats manager on the NPC
        npc.stats_manager = stats_manager
        npc.stats_generated = True
        
        logger.info(f"Generated enemy NPC: {npc.name} (Level {level})")
        return npc
    
    def _generate_equipment(self, npc: NPC, interaction_type: NPCInteractionType, template: Dict[str, Any]) -> None:
        """
        Generate and equip appropriate equipment for an NPC.
        
        Args:
            npc: The NPC to generate equipment for
            interaction_type: The type of interaction (determines equipment type)
            template: The template used for generation
        """
        logger.debug(f"Initializing equipment manager for NPC {npc.name}")
        
        # Initialize equipment manager for the NPC
        npc.equipment_manager = EquipmentManager()
        
        # For now, skip complex equipment generation to avoid hangs
        # TODO: Implement full equipment generation after fixing core issues
        if interaction_type == NPCInteractionType.COMBAT:
            logger.debug(f"Skipping complex equipment generation for combat NPC {npc.name} (temporary)")
            # Just ensure the NPC has an equipment manager
            return
            
        logger.info(f"Basic equipment manager created for NPC {npc.name}")
        return
    
    def _determine_equipment_rarity(self, npc_type: NPCType, is_boss: bool) -> ItemRarity:
        """Determine the base equipment rarity for an NPC."""
        if is_boss:
            return random.choice([ItemRarity.RARE, ItemRarity.EPIC])
        elif npc_type == NPCType.ENEMY:
            return random.choice([ItemRarity.COMMON, ItemRarity.UNCOMMON])
        elif npc_type == NPCType.NEUTRAL:
            return ItemRarity.COMMON
        else:
            return ItemRarity.COMMON
    
    def _determine_equipment_quality(self, npc_type: NPCType, is_boss: bool) -> float:
        """Determine the quality modifier for NPC equipment."""
        if is_boss:
            return random.uniform(1.1, 1.4)  # 10-40% better than base
        elif npc_type == NPCType.ENEMY:
            return random.uniform(0.9, 1.2)  # -10% to +20%
        else:
            return random.uniform(0.8, 1.1)  # -20% to +10%
    
    def _generate_npc_weapons(self, npc: NPC, template_loader, item_factory, base_rarity: ItemRarity, quality_modifier: float) -> None:
        """Generate weapons for an NPC."""
        # Get weapon templates
        weapon_templates = template_loader.get_templates_by_type(ItemType.WEAPON)
        
        if not weapon_templates:
            logger.warning("No weapon templates available for NPC equipment generation")
            return
        
        # Filter by rarity (allow up to one rarity level higher)
        suitable_templates = {}
        rarity_values = {
            ItemRarity.COMMON: 1,
            ItemRarity.UNCOMMON: 2,
            ItemRarity.RARE: 3,
            ItemRarity.EPIC: 4,
            ItemRarity.LEGENDARY: 5
        }
        
        max_rarity_value = rarity_values.get(base_rarity, 1) + 1  # Allow one level higher
        for template_id, template in weapon_templates.items():
            template_rarity_value = rarity_values.get(template.rarity, 1)
            if template_rarity_value <= max_rarity_value:
                suitable_templates[template_id] = template
        
        if not suitable_templates:
            suitable_templates = weapon_templates  # Fallback to all weapons
        
        # Select a random weapon template
        template = random.choice(list(suitable_templates.values()))
        
        # Create variation with quality modifier
        weapon = ItemVariationGenerator.create_variation(template, quality_modifier)
        
        # Try to equip the weapon
        if npc.equipment_manager.can_equip_item(weapon):
            success = npc.equipment_manager.equip_item(weapon)
            if success:
                logger.debug(f"Equipped {weapon.name} to NPC {npc.name}")
            else:
                logger.warning(f"Failed to equip {weapon.name} to NPC {npc.name}")
        else:
            logger.debug(f"Cannot equip {weapon.name} to NPC {npc.name} - requirements not met")
    
    def _generate_npc_armor(self, npc: NPC, template_loader, item_factory, base_rarity: ItemRarity, quality_modifier: float) -> None:
        """Generate armor for an NPC."""
        # Get armor templates
        armor_templates = template_loader.get_templates_by_type(ItemType.ARMOR)
        
        if not armor_templates:
            logger.warning("No armor templates available for NPC equipment generation")
            return
        
        # Filter by rarity (similar to weapons)
        rarity_values = {
            ItemRarity.COMMON: 1,
            ItemRarity.UNCOMMON: 2,
            ItemRarity.RARE: 3,
            ItemRarity.EPIC: 4,
            ItemRarity.LEGENDARY: 5
        }
        
        max_rarity_value = rarity_values.get(base_rarity, 1) + 1
        suitable_templates = {}
        for template_id, template in armor_templates.items():
            template_rarity_value = rarity_values.get(template.rarity, 1)
            if template_rarity_value <= max_rarity_value:
                suitable_templates[template_id] = template
        
        if not suitable_templates:
            suitable_templates = armor_templates  # Fallback
        
        # Try to equip armor for different slots
        armor_slots = [EquipmentSlot.CHEST, EquipmentSlot.HEAD]  # Focus on main armor pieces
        for slot in armor_slots:
            # Find suitable armor for this slot
            slot_templates = {}
            for template_id, template in suitable_templates.items():
                if hasattr(template, 'equip_slots') and template.equip_slots:
                    if slot.value in template.equip_slots or slot in template.equip_slots:
                        slot_templates[template_id] = template
            
            if not slot_templates:
                continue  # No armor for this slot
            
            # 70% chance to equip armor in each slot (not all NPCs need full armor)
            if random.random() > 0.7:
                continue
            
            # Select and create armor
            template = random.choice(list(slot_templates.values()))
            armor = ItemVariationGenerator.create_variation(template, quality_modifier)
            
            # Try to equip
            if npc.equipment_manager.can_equip_item(armor):
                success = npc.equipment_manager.equip_item(armor)
                if success:
                    logger.debug(f"Equipped {armor.name} to NPC {npc.name}")
    
    def _apply_equipment_to_stats(self, npc: NPC) -> None:
        """Apply equipment stat modifiers to the NPC's stats manager."""
        # Temporarily disabled to prevent performance issues
        # TODO: Implement proper batched modifier application
        logger.debug(f"Skipping equipment stat application for NPC {npc.name} (temporary)")
        return

```

### File: core\character\npc_manager.py

```python
#!/usr/bin/env python3
"""
NPC Manager for tracking and persisting NPCs in the game world.
Implements the just-in-time generation of NPC stats based on context.
"""

import logging
import os
import json
from typing import Dict, List, Any, Optional, Union, Set
from datetime import datetime

from core.character.npc_base import NPC, NPCType, NPCRelationship, NPCInteractionType, NPCMemory
from core.character.npc_generator import NPCGenerator
from core.stats.stats_base import StatType, DerivedStatType
from core.utils.dotdict import DotDict

logger = logging.getLogger(__name__)


class NPCManager:
    """
    Manager for tracking and persisting NPCs in the game world.
    Implements just-in-time generation of NPC stats based on interaction context.
    """
    
    def __init__(self, save_directory: str = "saves/npcs"):
        """
        Initialize the NPC manager.
        
        Args:
            save_directory: Directory to save NPC data
        """
        self.save_directory = save_directory
        self.npcs: Dict[str, NPC] = {}  # Dictionary of NPCs by ID
        self.npcs_by_name: Dict[str, NPC] = {}  # Dictionary of NPCs by name (lowercase)
        self.npcs_by_location: Dict[str, List[NPC]] = {}  # Dictionary of NPCs by location
        self.npc_generator = NPCGenerator()
        
        # Ensure save directory exists
        os.makedirs(save_directory, exist_ok=True)
    
    def add_npc(self, npc: NPC) -> None:
        """
        Add an NPC to the manager.
        
        Args:
            npc: The NPC to add
        """
        # Add to ID index
        self.npcs[npc.id] = npc
        
        # Add to name index
        name_key = npc.name.lower()
        self.npcs_by_name[name_key] = npc
        
        # Add to location index if location is set
        if npc.location:
            location_key = npc.location.lower()
            if location_key not in self.npcs_by_location:
                self.npcs_by_location[location_key] = []
            
            # Avoid duplicates
            if npc not in self.npcs_by_location[location_key]:
                self.npcs_by_location[location_key].append(npc)
        
        logger.debug(f"Added NPC to manager: {npc.name} (ID: {npc.id})")
    
    def remove_npc(self, npc_id: str) -> bool:
        """
        Remove an NPC from the manager.
        
        Args:
            npc_id: ID of the NPC to remove
            
        Returns:
            True if the NPC was found and removed, False otherwise
        """
        if npc_id not in self.npcs:
            return False
        
        npc = self.npcs[npc_id]
        
        # Remove from ID index
        del self.npcs[npc_id]
        
        # Remove from name index
        name_key = npc.name.lower()
        if name_key in self.npcs_by_name and self.npcs_by_name[name_key].id == npc_id:
            del self.npcs_by_name[name_key]
        
        # Remove from location index
        if npc.location:
            location_key = npc.location.lower()
            if location_key in self.npcs_by_location:
                self.npcs_by_location[location_key] = [
                    n for n in self.npcs_by_location[location_key] if n.id != npc_id
                ]
                if not self.npcs_by_location[location_key]:
                    del self.npcs_by_location[location_key]
        
        logger.debug(f"Removed NPC from manager: {npc.name} (ID: {npc_id})")
        return True
    
    def get_npc_by_id(self, npc_id: str) -> Optional[NPC]:
        """
        Get an NPC by ID.
        
        Args:
            npc_id: ID of the NPC to get
            
        Returns:
            The NPC if found, None otherwise
        """
        return self.npcs.get(npc_id)
        
    def get_entity(self, entity_id: str) -> Optional[NPC]:
        """
        Get an entity (NPC) by ID.
        Alias for get_npc_by_id to maintain compatibility with EntityManager interface.
        
        Args:
            entity_id: ID of the entity to get
            
        Returns:
            The entity if found, None otherwise
        """
        return self.get_npc_by_id(entity_id)
    
    def get_npc_by_name(self, name: str) -> Optional[NPC]:
        """
        Get an NPC by name (case-insensitive).
        
        Args:
            name: Name of the NPC to get
            
        Returns:
            The NPC if found, None otherwise
        """
        return self.npcs_by_name.get(name.lower())
    
    def get_npcs_by_location(self, location: str) -> List[NPC]:
        """
        Get all NPCs at a specific location.
        
        Args:
            location: The location to check
            
        Returns:
            List of NPCs at the location (empty if none)
        """
        return self.npcs_by_location.get(location.lower(), [])
    
    def get_npcs_by_type(self, npc_type: NPCType) -> List[NPC]:
        """
        Get all NPCs of a specific type.
        
        Args:
            npc_type: The type of NPCs to get
            
        Returns:
            List of NPCs of the specified type
        """
        return [npc for npc in self.npcs.values() if npc.npc_type == npc_type]
    
    def get_npcs_by_relationship(self, relationship: NPCRelationship) -> List[NPC]:
        """
        Get all NPCs with a specific relationship to the player.
        
        Args:
            relationship: The relationship to filter by
            
        Returns:
            List of NPCs with the specified relationship
        """
        return [npc for npc in self.npcs.values() if npc.relationship == relationship]
    
    def update_npc_location(self, npc_id: str, new_location: str) -> bool:
        """
        Update an NPC's location.
        
        Args:
            npc_id: ID of the NPC to update
            new_location: New location for the NPC
            
        Returns:
            True if the NPC was found and updated, False otherwise
        """
        npc = self.get_npc_by_id(npc_id)
        if not npc:
            return False
        
        # Remove from old location index
        if npc.location:
            old_location_key = npc.location.lower()
            if old_location_key in self.npcs_by_location:
                self.npcs_by_location[old_location_key] = [
                    n for n in self.npcs_by_location[old_location_key] if n.id != npc_id
                ]
                if not self.npcs_by_location[old_location_key]:
                    del self.npcs_by_location[old_location_key]
        
        # Update NPC's location
        npc.location = new_location
        
        # Add to new location index
        if new_location:
            new_location_key = new_location.lower()
            if new_location_key not in self.npcs_by_location:
                self.npcs_by_location[new_location_key] = []
            self.npcs_by_location[new_location_key].append(npc)
        
        logger.debug(f"Updated location for NPC {npc.name} to {new_location}")
        return True
    
    def update_npc_relationship(self, npc_id: str, new_relationship: NPCRelationship) -> bool:
        """
        Update an NPC's relationship with the player.
        
        Args:
            npc_id: ID of the NPC to update
            new_relationship: New relationship for the NPC
            
        Returns:
            True if the NPC was found and updated, False otherwise
        """
        npc = self.get_npc_by_id(npc_id)
        if not npc:
            return False
        
        npc.update_relationship(new_relationship)
        return True
    
    def clear_all(self) -> None:
        """Clear all NPCs from the manager."""
        self.npcs.clear()
        self.npcs_by_name.clear()
        self.npcs_by_location.clear()
        logger.info("Cleared all NPCs from manager")


# Singleton instance for NPC manager
_npc_manager_instance = None

# Convenience function to get the NPC manager
def get_npc_manager() -> NPCManager:
    """Get the NPC manager instance."""
    global _npc_manager_instance
    if _npc_manager_instance is None:
        _npc_manager_instance = NPCManager()
    
    return _npc_manager_instance

```

### File: core\character\npc_memory.py

```python
#!/usr/bin/env python3
"""
NPC Memory module for tracking interactions and NPC memory management.
"""

import logging
from typing import Dict, List, Any, Optional, Set, Tuple
from datetime import datetime, timedelta

from core.character.npc_base import NPC, NPCType, NPCRelationship, NPCInteractionType, NPCMemory
from core.character.npc_manager import NPCManager

logger = logging.getLogger(__name__)


class NPCMemoryManager:
    """
    Manager for tracking NPC memories and interactions.
    Handles recording, retrieving, and managing NPC memories.
    """
    
    def __init__(self, npc_manager: NPCManager):
        """
        Initialize the NPC memory manager.
        
        Args:
            npc_manager: The NPCManager instance to use
        """
        self.npc_manager = npc_manager
    
    def record_interaction(self, 
                          npc_id: str, 
                          interaction_type: NPCInteractionType,
                          description: str,
                          location: Optional[str] = None,
                          player_action: Optional[str] = None,
                          npc_reaction: Optional[str] = None,
                          relationship_change: Optional[NPCRelationship] = None,
                          importance: int = 1) -> Optional[NPCMemory]:
        """
        Record an interaction with an NPC.
        
        Args:
            npc_id: ID of the NPC
            interaction_type: Type of interaction
            description: Brief description of the interaction
            location: Where the interaction took place
            player_action: What the player did
            npc_reaction: How the NPC reacted
            relationship_change: Whether the relationship changed
            importance: Importance of the memory (1-10)
            
        Returns:
            The created memory if successful, None otherwise
        """
        npc = self.npc_manager.get_npc_by_id(npc_id)
        if not npc:
            logger.warning(f"Cannot record interaction: NPC with ID {npc_id} not found")
            return None
        
        # Create the memory
        memory = NPCMemory(
            npc_id=npc_id,
            timestamp=datetime.now(),
            interaction_type=interaction_type,
            description=description,
            location=location,
            player_action=player_action,
            npc_reaction=npc_reaction,
            relationship_change=relationship_change,
            importance=importance
        )
        
        # Add the memory to the NPC
        npc.record_interaction(memory)
        
        # Update NPC information based on the interaction
        if location and not npc.location:
            npc.location = location
        
        if relationship_change:
            npc.update_relationship(relationship_change)
        
        logger.debug(f"Recorded interaction with NPC {npc.name}: {description}")
        return memory
    
    def get_recent_memories(self, 
                           npc_id: str, 
                           count: int = 5, 
                           interaction_type: Optional[NPCInteractionType] = None) -> List[NPCMemory]:
        """
        Get the most recent memories for an NPC.
        
        Args:
            npc_id: ID of the NPC
            count: Maximum number of memories to return
            interaction_type: Optional filter by interaction type
            
        Returns:
            List of recent memories
        """
        npc = self.npc_manager.get_npc_by_id(npc_id)
        if not npc:
            logger.warning(f"Cannot get memories: NPC with ID {npc_id} not found")
            return []
        
        # Filter and sort memories
        if interaction_type:
            filtered_memories = [m for m in npc.memories if m.interaction_type == interaction_type]
        else:
            filtered_memories = npc.memories
        
        # Sort by timestamp (newest first)
        sorted_memories = sorted(filtered_memories, key=lambda m: m.timestamp, reverse=True)
        
        # Return the requested number of memories
        return sorted_memories[:count]
    
    def get_important_memories(self, 
                              npc_id: str, 
                              min_importance: int = 5) -> List[NPCMemory]:
        """
        Get important memories for an NPC.
        
        Args:
            npc_id: ID of the NPC
            min_importance: Minimum importance level (1-10)
            
        Returns:
            List of important memories
        """
        npc = self.npc_manager.get_npc_by_id(npc_id)
        if not npc:
            logger.warning(f"Cannot get memories: NPC with ID {npc_id} not found")
            return []
        
        # Filter by importance
        important_memories = [m for m in npc.memories if m.importance >= min_importance]
        
        # Sort by importance (highest first) and then by recency
        sorted_memories = sorted(
            important_memories, 
            key=lambda m: (m.importance, m.timestamp),
            reverse=True
        )
        
        return sorted_memories
    
    def get_memories_by_location(self, 
                                location: str,
                                max_count: int = 10) -> List[Tuple[NPC, NPCMemory]]:
        """
        Get memories that occurred at a specific location.
        
        Args:
            location: The location to check
            max_count: Maximum number of memories to return
            
        Returns:
            List of (NPC, memory) tuples
        """
        memories_at_location = []
        
        # Check all NPCs
        for npc in self.npc_manager.npcs.values():
            # Find memories at this location
            location_memories = [m for m in npc.memories if m.location and m.location.lower() == location.lower()]
            
            # Add them to the result list
            for memory in location_memories:
                memories_at_location.append((npc, memory))
        
        # Sort by timestamp (newest first)
        sorted_memories = sorted(memories_at_location, key=lambda nm: nm[1].timestamp, reverse=True)
        
        return sorted_memories[:max_count]
    
    def get_relationship_change_memories(self, 
                                        npc_id: str) -> List[NPCMemory]:
        """
        Get memories where the relationship with the player changed.
        
        Args:
            npc_id: ID of the NPC
            
        Returns:
            List of relationship change memories
        """
        npc = self.npc_manager.get_npc_by_id(npc_id)
        if not npc:
            logger.warning(f"Cannot get memories: NPC with ID {npc_id} not found")
            return []
        
        # Filter by relationship change
        return [m for m in npc.memories if m.relationship_change is not None]
    
    def summarize_npc_interactions(self, npc_id: str) -> Dict[str, Any]:
        """
        Create a summary of interactions with an NPC.
        
        Args:
            npc_id: ID of the NPC
            
        Returns:
            Dictionary with interaction summary
        """
        npc = self.npc_manager.get_npc_by_id(npc_id)
        if not npc:
            logger.warning(f"Cannot summarize interactions: NPC with ID {npc_id} not found")
            return {}
        
        # Count interactions by type
        interaction_counts = {}
        for memory in npc.memories:
            interaction_type = memory.interaction_type.name
            if interaction_type not in interaction_counts:
                interaction_counts[interaction_type] = 0
            interaction_counts[interaction_type] += 1
        
        # Find most recent interaction
        most_recent = None
        if npc.memories:
            most_recent = max(npc.memories, key=lambda m: m.timestamp)
        
        # Find most important memory
        most_important = None
        if npc.memories:
            most_important = max(npc.memories, key=lambda m: m.importance)
        
        # Create the summary
        summary = {
            "npc_name": npc.name,
            "npc_id": npc.id,
            "total_interactions": len(npc.memories),
            "interaction_counts": interaction_counts,
            "current_relationship": npc.relationship.name,
            "first_interaction": npc.memories[0].timestamp.isoformat() if npc.memories else None,
            "last_interaction": npc.last_interaction.isoformat() if npc.last_interaction else None,
            "most_recent_interaction": {
                "description": most_recent.description,
                "timestamp": most_recent.timestamp.isoformat(),
                "type": most_recent.interaction_type.name
            } if most_recent else None,
            "most_important_memory": {
                "description": most_important.description,
                "importance": most_important.importance,
                "type": most_important.interaction_type.name
            } if most_important else None
        }
        
        return summary
    
    def get_relevant_context_for_interaction(self, 
                                           npc_id: str, 
                                           interaction_type: NPCInteractionType,
                                           max_memories: int = 3) -> List[Dict[str, Any]]:
        """
        Get relevant memories as context for a new interaction.
        This is the primary method for integrating NPCs with the context system.
        
        Args:
            npc_id: ID of the NPC
            interaction_type: Type of the upcoming interaction
            max_memories: Maximum number of memories to include
            
        Returns:
            List of memory dictionaries formatted for context
        """
        npc = self.npc_manager.get_npc_by_id(npc_id)
        if not npc:
            logger.warning(f"Cannot get context: NPC with ID {npc_id} not found")
            return []
        
        # Start with basic NPC information
        context = []
        
        # First, get the most recent memory of the same interaction type
        same_type_memories = [m for m in npc.memories if m.interaction_type == interaction_type]
        if same_type_memories:
            most_recent_same_type = max(same_type_memories, key=lambda m: m.timestamp)
            context.append({
                "type": "recent_similar_interaction",
                "description": most_recent_same_type.description,
                "when": most_recent_same_type.timestamp.isoformat()
            })
        
        # Next, get the most recent interaction (if different from above)
        if npc.memories:
            most_recent = max(npc.memories, key=lambda m: m.timestamp)
            if not same_type_memories or most_recent.id != most_recent_same_type.id:
                context.append({
                    "type": "most_recent_interaction",
                    "description": most_recent.description,
                    "when": most_recent.timestamp.isoformat()
                })
        
        # Finally, get the most important memories
        important_memories = self.get_important_memories(npc_id, min_importance=7)
        for memory in important_memories[:max(0, max_memories - len(context))]:
            context.append({
                "type": "important_memory",
                "description": memory.description,
                "importance": memory.importance,
                "when": memory.timestamp.isoformat()
            })
        
        return context
    
    def prune_old_memories(self, 
                          npc_id: str, 
                          max_age_days: int = 90, 
                          keep_important: bool = True,
                          min_importance_to_keep: int = 5) -> int:
        """
        Remove old, less important memories to prevent memory bloat.
        
        Args:
            npc_id: ID of the NPC
            max_age_days: Maximum age of memories to keep
            keep_important: Whether to keep important memories regardless of age
            min_importance_to_keep: Minimum importance level to keep regardless of age
            
        Returns:
            Number of memories removed
        """
        npc = self.npc_manager.get_npc_by_id(npc_id)
        if not npc:
            logger.warning(f"Cannot prune memories: NPC with ID {npc_id} not found")
            return 0
        
        cutoff_date = datetime.now() - timedelta(days=max_age_days)
        original_count = len(npc.memories)
        
        # Filter memories
        if keep_important:
            npc.memories = [
                m for m in npc.memories if 
                m.timestamp >= cutoff_date or m.importance >= min_importance_to_keep
            ]
        else:
            npc.memories = [m for m in npc.memories if m.timestamp >= cutoff_date]
        
        removed_count = original_count - len(npc.memories)
        logger.debug(f"Pruned {removed_count} old memories from NPC {npc.name}")
        
        return removed_count

```

### File: core\character\npc_persistence.py

```python
#!/usr/bin/env python3
"""
NPC Persistence module handling saving, loading, and serialization of NPCs.
"""

import os
import json
import logging
from typing import Dict, List, Any, Optional, Tuple, Set
from datetime import datetime

from core.character.npc_base import NPC, NPCType, NPCRelationship, NPCInteractionType, NPCMemory
from core.character.npc_manager import NPCManager

logger = logging.getLogger(__name__)


class NPCPersistence:
    """
    Class for handling NPC persistence operations.
    Manages saving, loading, and serialization of NPCs.
    """
    
    def __init__(self, npc_manager: NPCManager):
        """
        Initialize the NPC persistence handler.
        
        Args:
            npc_manager: The NPCManager instance to use
        """
        self.npc_manager = npc_manager
        self.save_directory = npc_manager.save_directory
    
    def save_npc(self, npc: NPC) -> bool:
        """
        Save an individual NPC to file.
        
        Args:
            npc: The NPC to save
            
        Returns:
            True if successful, False otherwise
        """
        if not npc.is_persistent:
            logger.debug(f"Not saving non-persistent NPC: {npc.name}")
            return False
        
        try:
            os.makedirs(self.save_directory, exist_ok=True)
            
            # Create a filename based on the NPC's ID
            filename = os.path.join(self.save_directory, f"{npc.id}.json")
            
            # Convert NPC to dictionary
            npc_data = npc.to_dict()
            
            # Save to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(npc_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"Saved NPC {npc.name} to {filename}")
            return True
        
        except Exception as e:
            logger.error(f"Error saving NPC {npc.name}: {e}")
            return False
    
    def load_npc(self, npc_id: str) -> Optional[NPC]:
        """
        Load an individual NPC from file.
        
        Args:
            npc_id: ID of the NPC to load
            
        Returns:
            The loaded NPC if successful, None otherwise
        """
        try:
            # Create filename based on NPC ID
            filename = os.path.join(self.save_directory, f"{npc_id}.json")
            
            if not os.path.exists(filename):
                logger.warning(f"NPC file not found: {filename}")
                return None
            
            # Load from file
            with open(filename, 'r', encoding='utf-8') as f:
                npc_data = json.load(f)
            
            # Create NPC from data
            npc = NPC.from_dict(npc_data)
            
            logger.info(f"Loaded NPC {npc.name} from {filename}")
            return npc
        
        except Exception as e:
            logger.error(f"Error loading NPC {npc_id}: {e}")
            return None
    
    def save_all_persistent_npcs(self) -> Tuple[int, int]:
        """
        Save all persistent NPCs to file.
        
        Returns:
            Tuple of (success_count, total_count)
        """
        persistent_npcs = [npc for npc in self.npc_manager.npcs.values() if npc.is_persistent]
        success_count = 0
        
        for npc in persistent_npcs:
            if self.save_npc(npc):
                success_count += 1
        
        logger.info(f"Saved {success_count}/{len(persistent_npcs)} persistent NPCs")
        return success_count, len(persistent_npcs)
    
    def load_all_npcs(self) -> int:
        """
        Load all NPCs from files in the save directory.
        
        Returns:
            Number of NPCs loaded
        """
        try:
            if not os.path.exists(self.save_directory):
                logger.warning(f"NPC save directory not found: {self.save_directory}")
                return 0
            
            # Find all JSON files in the directory
            npc_files = [f for f in os.listdir(self.save_directory) if f.endswith('.json')]
            loaded_count = 0
            
            for file in npc_files:
                try:
                    # Extract NPC ID from filename
                    npc_id = os.path.splitext(file)[0]
                    
                    # Load the NPC
                    npc = self.load_npc(npc_id)
                    if npc:
                        # Add to manager
                        self.npc_manager.add_npc(npc)
                        loaded_count += 1
                
                except Exception as e:
                    logger.error(f"Error loading NPC from {file}: {e}")
            
            logger.info(f"Loaded {loaded_count}/{len(npc_files)} NPCs from {self.save_directory}")
            return loaded_count
        
        except Exception as e:
            logger.error(f"Error loading NPCs: {e}")
            return 0
    
    def delete_npc_file(self, npc_id: str) -> bool:
        """
        Delete an NPC's save file.
        
        Args:
            npc_id: ID of the NPC whose file to delete
            
        Returns:
            True if successful, False otherwise
        """
        try:
            filename = os.path.join(self.save_directory, f"{npc_id}.json")
            
            if not os.path.exists(filename):
                logger.warning(f"NPC file not found: {filename}")
                return False
            
            os.remove(filename)
            logger.info(f"Deleted NPC file: {filename}")
            return True
        
        except Exception as e:
            logger.error(f"Error deleting NPC file for {npc_id}: {e}")
            return False
    
    def cleanup_unused_npcs(self, days_threshold: int = 30) -> int:
        """
        Remove NPCs that haven't been interacted with for a long time.
        
        Args:
            days_threshold: Number of days of inactivity before removal
            
        Returns:
            Number of NPCs removed
        """
        cutoff_date = datetime.now() - datetime.timedelta(days=days_threshold)
        npcs_to_remove = []
        
        for npc_id, npc in self.npc_manager.npcs.items():
            # Skip NPCs without a last interaction date
            if not npc.last_interaction:
                continue
            
            # Check if the NPC is older than the threshold
            if npc.last_interaction < cutoff_date:
                npcs_to_remove.append(npc_id)
        
        # Remove the NPCs
        for npc_id in npcs_to_remove:
            self.delete_npc_file(npc_id)
            self.npc_manager.remove_npc(npc_id)
        
        logger.info(f"Cleaned up {len(npcs_to_remove)} unused NPCs")
        return len(npcs_to_remove)
    
    def export_npcs_to_json(self, filepath: str, include_non_persistent: bool = False) -> bool:
        """
        Export all NPCs to a single JSON file for debugging or external processing.
        
        Args:
            filepath: Path to save the JSON file
            include_non_persistent: Whether to include non-persistent NPCs
            
        Returns:
            True if successful, False otherwise
        """
        try:
            if include_non_persistent:
                npcs_to_export = list(self.npc_manager.npcs.values())
            else:
                npcs_to_export = [npc for npc in self.npc_manager.npcs.values() if npc.is_persistent]
            
            npc_data = {npc.id: npc.to_dict() for npc in npcs_to_export}
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(npc_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"Exported {len(npcs_to_export)} NPCs to {filepath}")
            return True
        
        except Exception as e:
            logger.error(f"Error exporting NPCs to {filepath}: {e}")
            return False
    
    def import_npcs_from_json(self, filepath: str) -> int:
        """
        Import NPCs from a JSON file.
        
        Args:
            filepath: Path to the JSON file
            
        Returns:
            Number of NPCs imported
        """
        try:
            if not os.path.exists(filepath):
                logger.warning(f"NPC import file not found: {filepath}")
                return 0
            
            with open(filepath, 'r', encoding='utf-8') as f:
                npc_data = json.load(f)
            
            imported_count = 0
            
            for npc_id, data in npc_data.items():
                try:
                    npc = NPC.from_dict(data)
                    self.npc_manager.add_npc(npc)
                    imported_count += 1
                
                except Exception as e:
                    logger.error(f"Error importing NPC {npc_id}: {e}")
            
            logger.info(f"Imported {imported_count}/{len(npc_data)} NPCs from {filepath}")
            return imported_count
        
        except Exception as e:
            logger.error(f"Error importing NPCs from {filepath}: {e}")
            return 0

```

### File: core\character\npc_system.py

```python
#!/usr/bin/env python3
"""
NPC System - Main integration module for the NPC subsystem.
Provides a unified interface for NPC management, creation, persistence, and memory.
"""

import logging
from typing import Dict, List, Any, Optional, Union, Tuple, Set
from datetime import datetime

from core.character.npc_base import NPC, NPCType, NPCRelationship, NPCInteractionType, NPCMemory
from core.character.npc_manager import NPCManager
from core.character.npc_creator import NPCCreator
from core.character.npc_persistence import NPCPersistence
from core.character.npc_memory import NPCMemoryManager

logger = logging.getLogger(__name__)


class NPCSystem:
    """
    Main class for the NPC subsystem.
    Integrates NPC management, creation, persistence, and memory into a single interface.
    """
    
    def __init__(self, save_directory: str = "saves/npcs"):
        """
        Initialize the NPC system.
        
        Args:
            save_directory: Directory for saving NPC data
        """
        # Initialize storage for direct access fallbacks
        self.npcs: Dict[str, NPC] = {}
        self.npc_list: List[NPC] = []
        
        # Initialize all the component managers
        self.manager = NPCManager(save_directory)
        self.creator = NPCCreator(self.manager)
        self.persistence = NPCPersistence(self.manager)
        self.memory = NPCMemoryManager(self.manager)
        
        logger.info("NPC system initialized")
    
    def load_all_npcs(self) -> int:
        """
        Load all persisted NPCs.
        
        Returns:
            Number of NPCs loaded
        """
        return self.persistence.load_all_npcs()
    
    def save_all_npcs(self) -> Tuple[int, int]:
        """
        Save all persistent NPCs.
        
        Returns:
            Tuple of (success_count, total_count)
        """
        return self.persistence.save_all_persistent_npcs()
    
    def clear_all_npcs(self) -> None:
        """Clear all NPCs from the system."""
        self.manager.clear_all()
        self.npcs.clear()
        self.npc_list.clear()
    
    def get_npc(self, npc_id: str) -> Optional[NPC]:
        """
        Get an NPC by ID.
        
        Args:
            npc_id: ID of the NPC to get
            
        Returns:
            The NPC if found, None otherwise
        """
        return self.manager.get_npc_by_id(npc_id)
    
    def get_npc_by_name(self, name: str) -> Optional[NPC]:
        """
        Get an NPC by name.
        
        Args:
            name: Name of the NPC to get
            
        Returns:
            The NPC if found, None otherwise
        """
        return self.manager.get_npc_by_name(name)
    
    def get_or_create_npc(self, 
                         name: str, 
                         interaction_type: NPCInteractionType,
                         location: Optional[str] = None,
                         npc_subtype: Optional[str] = None) -> Tuple[NPC, bool]:
        """
        Get an existing NPC by name or create a new one.
        This is the primary method for just-in-time NPC generation.
        
        Args:
            name: Name of the NPC
            interaction_type: Type of interaction
            location: Where the NPC is located
            npc_subtype: Optional subtype (e.g., 'boss_dragon', 'merchant')
            
        Returns:
            Tuple of (npc, is_new) where is_new is True if a new NPC was created
        """
        npc, is_new = self.creator.get_or_create_npc(
            name=name,
            interaction_type=interaction_type,
            location=location,
            npc_subtype=npc_subtype
        )
        # Register in direct storage if newly created
        if npc and is_new:
            self.register_npc(npc)
        return npc, is_new
    
    def prepare_npc_for_interaction(self, 
                                   npc_or_name: Union[NPC, str],
                                   interaction_type: NPCInteractionType,
                                   npc_subtype: Optional[str] = None) -> Optional[NPC]:
        """
        Prepare an NPC for a specific interaction, enhancing it if necessary.
        Implements the just-in-time generation of NPC capabilities.
        
        Args:
            npc_or_name: NPC object or name of the NPC
            interaction_type: Type of interaction to prepare for
            npc_subtype: Optional subtype for new NPCs
            
        Returns:
            The prepared NPC if found or created, None on failure
        """
        # Get or create the NPC
        if isinstance(npc_or_name, str):
            npc, _ = self.get_or_create_npc(npc_or_name, interaction_type, npc_subtype=npc_subtype)
            if not npc:
                return None
        else:
            npc = npc_or_name
            
        # Enhance the NPC for this interaction if needed
        self.creator.enhance_npc_for_interaction(npc, interaction_type)
        
        return npc
    
    def record_interaction(self,
                          npc_or_name: Union[NPC, str],
                          interaction_type: NPCInteractionType,
                          description: str,
                          location: Optional[str] = None,
                          importance: int = 3,
                          npc_subtype: Optional[str] = None) -> Optional[NPCMemory]:
        """
        Record an interaction with an NPC.
        Creates the NPC if it doesn't exist.
        
        Args:
            npc_or_name: NPC object or name of the NPC
            interaction_type: Type of interaction
            description: Description of what happened
            location: Where it happened
            importance: How important this memory is (1-10)
            npc_subtype: Optional subtype for new NPCs
            
        Returns:
            The created memory if successful, None otherwise
        """
        # Get or create the NPC
        if isinstance(npc_or_name, str):
            npc, _ = self.get_or_create_npc(npc_or_name, interaction_type, location, npc_subtype=npc_subtype)
            if not npc:
                return None
        else:
            npc = npc_or_name
        
        # Record the interaction
        return self.memory.record_interaction(
            npc_id=npc.id,
            interaction_type=interaction_type,
            description=description,
            location=location,
            importance=importance
        )
    
    def get_context_for_interaction(self,
                                   npc_or_name: Union[NPC, str],
                                   interaction_type: NPCInteractionType,
                                   npc_subtype: Optional[str] = None) -> Dict[str, Any]:
        """
        Get context for an interaction with an NPC.
        Creates or enhances the NPC as needed.
        
        Args:
            npc_or_name: NPC object or name of the NPC
            interaction_type: Type of interaction
            npc_subtype: Optional subtype for new NPCs
            
        Returns:
            Dictionary with NPC information and relevant memories
        """
        # Prepare the NPC
        npc = self.prepare_npc_for_interaction(npc_or_name, interaction_type, npc_subtype)
        if not npc:
            return {"error": "NPC not found or could not be created"}
        
        # Get relevant memories
        memories = self.memory.get_relevant_context_for_interaction(npc.id, interaction_type)
        
        # Build the context
        context = {
            "npc": {
                "id": npc.id,
                "name": npc.name,
                "type": npc.npc_type.name,
                "relationship": npc.relationship.name,
                "description": npc.description,
                "occupation": npc.occupation,
                "location": npc.location,
                "personality": npc.personality
            },
            "stats": {},
            "memories": memories,
            "interaction_count": npc.interaction_count
        }
        
        # Add stats if available
        if npc.has_stats():
            # Only include stats relevant to this interaction type
            if interaction_type == NPCInteractionType.COMBAT:
                combat_stats = ["STR", "DEX", "CON", "MELEE_ATTACK", "RANGED_ATTACK", "DEFENSE"]
                for stat in combat_stats:
                    value = npc.get_stat(stat)
                    if value is not None:
                        context["stats"][stat] = value
            
            elif interaction_type == NPCInteractionType.SOCIAL:
                social_stats = ["CHA", "WIS"]
                for stat in social_stats:
                    value = npc.get_stat(stat)
                    if value is not None:
                        context["stats"][stat] = value
            
            elif interaction_type == NPCInteractionType.COMMERCE:
                commerce_stats = ["CHA", "INT"]
                for stat in commerce_stats:
                    value = npc.get_stat(stat)
                    if value is not None:
                        context["stats"][stat] = value
        
        return context
    
    def create_enemy_for_combat(self,
                               name: Optional[str] = None,
                               enemy_type: str = "bandit",
                               level: int = 1,
                               location: Optional[str] = None) -> NPC:
        """
        Create an enemy NPC ready for combat.
        
        Args:
            name: Optional name for the enemy
            enemy_type: Type of enemy
            level: Enemy level
            location: Where the enemy is located
            
        Returns:
            The created enemy NPC
        """
        # Phase 1 families integration: if system.npc_generation_mode == 'families',
        # interpret enemy_type as a family_id and generate via the families-based generator.
        try:
            from core.base.config import get_config
            cfg = get_config()
            mode = (cfg.get("system.npc_generation_mode", "legacy") or "legacy").lower()
        except Exception:
            mode = "legacy"

        if mode == "families":
            try:
                from core.character.npc_family_generator import NPCFamilyGenerator
                fam_gen = NPCFamilyGenerator()
                # Parse overlay syntax: id::overlay_id or id+boss (maps to default_boss)
                raw = enemy_type
                overlay_id = None
                target_id = raw
                if isinstance(raw, str) and "::" in raw:
                    parts = raw.split("::", 1)
                    target_id, overlay_id = parts[0], parts[1] or None
                elif isinstance(raw, str) and raw.endswith("+boss"):
                    target_id = raw[:-5]
                    overlay_id = overlay_id or "default_boss"

                # Heuristic resolution: if neither family nor variant match, map common nouns to defaults
                def _heuristic_map_unknown(label: str, lvl: int) -> Optional[str]:
                    if not label:
                        return None
                    key = label.lower().strip()
                    # Beasts
                    if any(w in key for w in ["wolf", "hound", "dog", "boar", "bear", "lion", "beast"]):
                        return "beast_normal_base" if lvl >= 2 else "beast_easy_base"
                    # Humanoids
                    if any(w in key for w in ["bandit", "guard", "soldier", "thug", "brigand", "human"]):
                        return "humanoid_easy_base" if lvl <= 2 else "humanoid_normal_base"
                    return None

                # Resolve: if target_id matches a known variant, use variant; else treat as family
                var = getattr(fam_gen, "get_variant", None)
                fam = getattr(fam_gen, "get_family", None)
                used_variant = False
                # Pull difficulty/encounter_size from config if available
                try:
                    from core.base.config import get_config
                    cfg = get_config()
                    difficulty = (cfg.get("game.difficulty", "normal") or "normal")
                    encounter_size = (cfg.get("game.encounter_size", "solo") or "solo")
                except Exception:
                    difficulty = "normal"
                    encounter_size = "solo"

                # If unknown id, try heuristic mapping before generating
                try:
                    fam_exists = callable(fam) and bool(fam(target_id))
                except Exception:
                    fam_exists = False
                try:
                    var_exists = callable(var) and bool(var(target_id))
                except Exception:
                    var_exists = False
                if not fam_exists and not var_exists:
                    mapped = _heuristic_map_unknown(target_id, level)
                    if mapped:
                        logger.info(f"Heuristic resolution: mapping '{target_id}' -> '{mapped}' for families generation")
                        target_id = mapped

                if callable(var) and var(target_id):
                    npc = fam_gen.generate_npc_from_variant(
                        variant_id=target_id,
                        name=name,
                        location=location,
                        level=level,
                        overlay_id=overlay_id,
                        difficulty=difficulty,
                        encounter_size=encounter_size
                    )
                    used_variant = True
                else:
                    # fallback to family
                    npc = fam_gen.generate_npc_from_family(
                        family_id=target_id,
                        name=name,
                        location=location,
                        level=level,
                        overlay_id=overlay_id,
                        difficulty=difficulty,
                        encounter_size=encounter_size
                    )
                logger.debug(f"Families-based generation succeeded (variant={used_variant}) for id='{target_id}' overlay='{overlay_id}' diff='{difficulty}' enc='{encounter_size}'")
            except Exception as e:
                logger.error(f"Families-based NPC generation failed for id='{enemy_type}': {e}", exc_info=True)
                # Fallback to legacy if families fail
                npc = self.creator.create_enemy(
                    name=name,
                    enemy_type=enemy_type,
                    level=level,
                    location=location
                )
        else:
            # Legacy path
            npc = self.creator.create_enemy(
                name=name,
                enemy_type=enemy_type,
                level=level,
                location=location
            )

        # Register in direct storage for fallback access
        if npc:
            self.register_npc(npc)
        return npc
    
    def create_merchant(self,
                       name: str,
                       shop_type: str = "general",
                       location: Optional[str] = None) -> NPC:
        """
        Create a merchant NPC.
        
        Args:
            name: Name of the merchant
            shop_type: Type of shop
            location: Where the merchant is located
            
        Returns:
            The created merchant NPC
        """
        return self.creator.create_merchant(
            name=name,
            shop_type=shop_type,
            location=location
        )
    
    def update_npc_location(self, npc_id: str, new_location: str) -> bool:
        """
        Update an NPC's location.
        
        Args:
            npc_id: ID of the NPC
            new_location: New location
            
        Returns:
            True if successful, False otherwise
        """
        return self.manager.update_npc_location(npc_id, new_location)
    
    def update_npc_relationship(self, npc_id: str, new_relationship: NPCRelationship) -> bool:
        """
        Update an NPC's relationship with the player.
        
        Args:
            npc_id: ID of the NPC
            new_relationship: New relationship
            
        Returns:
            True if successful, False otherwise
        """
        return self.manager.update_npc_relationship(npc_id, new_relationship)
    
    def save_state(self) -> bool:
        """
        Save the entire NPC system state.
        
        Returns:
            True if successful, False otherwise
        """
        try:
            # Save all persistent NPCs
            self.save_all_npcs()
            return True
        except Exception as e:
            logger.error(f"Error saving NPC system state: {e}")
            return False
    
    def load_state(self) -> bool:
        """
        Load the entire NPC system state.
        
        Returns:
            True if successful, False otherwise
        """
        try:
            # Clear existing NPCs
            self.clear_all_npcs()
            
            # Load all NPCs
            self.load_all_npcs()
            return True
        except Exception as e:
            logger.error(f"Error loading NPC system state: {e}")
            return False

    def register_npc(self, npc: NPC) -> None:
        """Register an NPC in the direct storage for fallback access.
        
        Args:
            npc: The NPC to register
        """
        if npc and hasattr(npc, 'id') and npc.id:
            self.npcs[npc.id] = npc
            if npc not in self.npc_list:
                self.npc_list.append(npc)
            logger.debug(f"Registered NPC {npc.name} (ID: {npc.id}) in direct storage.")
    
    def get_npc_by_id(self, npc_id: str) -> Optional[NPC]:
        """Retrieves an NPC instance by its unique ID.

        Args:
            npc_id: The unique identifier of the NPC to retrieve.

        Returns:
            The NPC object if found, otherwise None.
        """
        # First try the main manager
        npc = self.manager.get_npc_by_id(npc_id)
        if npc:
            return npc
        
        # Fallback to direct storage
        if npc_id in self.npcs:
            return self.npcs[npc_id]
        
        # Fallback to list search
        for npc in self.npc_list:
            if getattr(npc, 'id', None) == npc_id:
                return npc
        
        logger.debug(f"NPC with ID {npc_id} not found in NPCSystem storage.")
        return None
```

### File: world_configurator\llm\__init__.py

```python
# Makes this directory a package.


```

### File: world_configurator\llm\gemini.py

```python
"""
Google Gemini client adapter.
"""
from __future__ import annotations

import json
from typing import Any, Dict, List

import requests

from .settings import LLMSettings


class GeminiClient:
    """Minimal Gemini API client using generateContent endpoint.

    Expects OpenAI-like chat messages (list of {role, content}) and converts to Gemini format.
    """

    def _endpoint(self, model: str) -> str:
        # v1beta remains widely compatible; adjust to v1 if your key is v1-only.
        return f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"

    def _convert_messages(self, messages: List[Dict[str, str]]) -> Dict[str, Any]:
        system_instruction = None
        contents: List[Dict[str, Any]] = []
        for m in messages:
            role = m.get("role", "user")
            text = m.get("content", "")
            if role == "system":
                # Use system_instruction where possible
                system_instruction = {
                    "role": "system",
                    "parts": [{"text": text}]
                }
            else:
                contents.append({
                    "role": "user" if role == "user" else "model",
                    "parts": [{"text": text}]
                })
        payload: Dict[str, Any] = {
            "contents": contents,
            "generationConfig": {
                "temperature": 0.3,
                # Encourage JSON output in the supported field location
                "response_mime_type": "application/json",
            },
        }
        if system_instruction is not None:
            payload["systemInstruction"] = system_instruction
        return payload

    def send(self, messages: List[Dict[str, str]], settings: LLMSettings) -> Dict[str, Any]:
        url = self._endpoint(settings.model)
        params = {"key": settings.api_key}
        headers = {"Content-Type": "application/json"}
        payload = self._convert_messages(messages)
        try:
            resp = requests.post(url, params=params, headers=headers, data=json.dumps(payload), timeout=60)
            resp.raise_for_status()
        except requests.HTTPError as e:
            body = None
            try:
                body = e.response.text
            except Exception:
                pass
            raise Exception(f"Upstream error {e.response.status_code} from {url}: {body}")
        data = resp.json()
        # Parse first candidate's text
        try:
            candidates = data.get("candidates") or []
            if not candidates:
                return {"raw": data}
            parts = candidates[0].get("content", {}).get("parts", [])
            text = "".join(p.get("text", "") for p in parts)
            return json.loads(text) if text else {"raw": data}
        except Exception:
            return {"raw": data}


```

### File: world_configurator\llm\providers_registry.py

```python
"""
Provider registry that reads providers and models from the project's config.
"""
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Optional

from utils.file_manager import get_config_dir

class ProviderRegistry:
    def __init__(self) -> None:
        self.providers: Dict[str, dict] = {}

    def load(self) -> None:
        cfg = Path(get_config_dir())
        prov_path = cfg / "llm" / "providers.json"
        if prov_path.exists():
            self.providers = json.loads(prov_path.read_text(encoding="utf-8"))

    def list_providers(self) -> List[str]:
        return [k for k, v in self.providers.items() if v.get("enabled", True)]

    def provider_info(self, provider: str) -> Optional[dict]:
        return self.providers.get(provider)

    def list_models_for(self, provider: str) -> List[dict]:
        # Source models strictly from providers.json as requested.
        prov = self.providers.get(provider, {})
        ids = prov.get("available_models", [])
        return [{"id": mid, "name": mid, "description": ""} for mid in ids]


```

### File: world_configurator\llm\settings.py

```python
"""
LLM settings persistence using QStandardPaths.
"""
from __future__ import annotations

import json
from dataclasses import dataclass, asdict, field
from pathlib import Path
from typing import Optional, Dict

from PySide6.QtCore import QStandardPaths


@dataclass
class LLMSettings:
    provider: str = ""
    model: str = ""
    api_key: str = ""
    api_base: Optional[str] = None
    provider_keys: Dict[str, str] = field(default_factory=dict)

    def to_dict(self) -> dict:
        d = asdict(self)
        return d

    @classmethod
    def from_dict(cls, d: dict) -> "LLMSettings":
        # Backward compatibility: if provider_keys absent, seed with api_key
        provider = d.get("provider", "")
        provider_keys = d.get("provider_keys") or {}
        if not provider_keys and d.get("api_key") and provider:
            provider_keys = {provider: d.get("api_key")}
        return cls(
            provider=provider,
            model=d.get("model", ""),
            api_key=d.get("api_key", ""),
            api_base=d.get("api_base"),
            provider_keys=provider_keys,
        )


def _settings_dir() -> Path:
    base = Path(QStandardPaths.writableLocation(QStandardPaths.AppDataLocation))
    base.mkdir(parents=True, exist_ok=True)
    return base


def settings_path() -> Path:
    return _settings_dir() / "llm_settings.json"


def save_llm_settings(settings: LLMSettings) -> None:
    p = settings_path()
    p.write_text(json.dumps(settings.to_dict(), indent=2), encoding="utf-8")


def load_llm_settings() -> LLMSettings:
    p = settings_path()
    if p.exists():
        try:
            data = json.loads(p.read_text(encoding="utf-8"))
            return LLMSettings.from_dict(data)
        except Exception:
            pass
    return LLMSettings()


```

### File: core\combat\__init__.py

```python
"""
Combat module for handling turn-based combat mechanics.
"""

from core.combat.combat_manager import CombatManager
from core.combat.combat_entity import CombatEntity, EntityType
from core.combat.combat_action import CombatAction, ActionType


def register_combat_commands():
    """Register combat commands and developer commands."""
    # Import here to avoid circular imports
    from core.base.commands import get_command_processor
    from core.utils.logging_config import get_logger
    from core.combat.dev_commands import register_combat_dev_commands
    
    logger = get_logger("GAME")
    
    # Register developer commands
    processor = get_command_processor()
    register_combat_dev_commands(processor)
    
    logger.info("Combat command system initialized")
    
    # Return the processor for testing purposes
    return processor


# Initialize combat commands when the module is imported
try:
    register_combat_commands()
except Exception as e:
    # Import here to avoid circular imports at module level
    from core.utils.logging_config import get_logger
    logger = get_logger("GAME")
    logger.error(f"Error registering combat commands: {e}", exc_info=True)

```

### File: core\combat\action_handlers.py

```python
import random
import logging
from typing import Dict, List, Tuple, Any, Optional, TYPE_CHECKING

from core.stats.combat_effects import StatusEffect, StatusEffectType
from core.stats.derived_stats import get_modifier_from_stat
from core.stats.stats_base import StatType, DerivedStatType
from core.utils.dice import roll_dice_notation, check_success
from core.combat.combat_entity import CombatEntity, EntityType
from core.combat.combat_action import CombatAction 
from core.base.config import get_config
from core.combat.enums import CombatState, CombatStep

if TYPE_CHECKING:
    from .combat_manager import CombatManager 
    from core.stats.stats_manager import StatsManager
    from core.base.engine import GameEngine

logger = logging.getLogger(__name__)

def _handle_attack_action(manager: 'CombatManager', action: CombatAction, performer: CombatEntity, performer_stats_manager: 'StatsManager', engine: 'GameEngine', current_result_detail: Dict) -> Dict[str, Any]:
    """Handle the mechanics of an attack action. Queues DisplayEvents. Updates current_result_detail."""
    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
    
    queued_events_this_handler = False
    handler_result_summary = {"success": False, "message": "Attack failed or target invalid."} 
    current_result_detail.update(handler_result_summary) 

    if not action.targets:
        current_result_detail["message"] = "No target specified for attack."
        return current_result_detail 

    target_id = action.targets[0]
    target = manager.entities.get(target_id)

    if not target:
        current_result_detail["message"] = f"Target {target_id} not found."
        return current_result_detail
    if not target.is_alive():
        current_result_detail["message"] = f"{target.combat_name} is already defeated."
        return current_result_detail

    target_stats_manager = manager._get_entity_stats_manager(target_id)
    if not target_stats_manager:
        current_result_detail["message"] = f"Internal Error: Stats missing for target {target.combat_name}."
        return current_result_detail

    attack_stat_type = StatType.STRENGTH 
    attack_bonus = 0
    attack_stat_modifier = 0
    try:
        attack_stat_value = performer_stats_manager.get_stat_value(attack_stat_type)
        attack_stat_modifier = get_modifier_from_stat(attack_stat_value)
        attack_bonus = attack_stat_modifier 
    except Exception as e: logger.warning(f"Could not get attack stat modifier for {performer.combat_name}: {e}")

    defense_value = target_stats_manager.get_stat_value(DerivedStatType.DEFENSE)

    adv = performer.has_status_effect("Advantage")
    disadv = performer.has_status_effect("Disadvantage")
    roll1 = random.randint(1, 20)
    roll2 = random.randint(1, 20) if (adv or disadv) else roll1
    
    raw_d20_roll = roll1 
    roll_type_str = ""
    adv_rolls_str_display = f"[{roll1}]"
    if adv and not disadv: raw_d20_roll = max(roll1, roll2); roll_type_str = " (Adv)"; adv_rolls_str_display = f"Adv[{max(roll1,roll2)} from ({roll1},{roll2})]"
    elif disadv and not adv: raw_d20_roll = min(roll1, roll2); roll_type_str = " (Disadv)"; adv_rolls_str_display = f"Disadv[{min(roll1,roll2)} from ({roll1},{roll2})]"
    
    hit_roll_total_modified = raw_d20_roll + attack_bonus 

    _, is_critical, is_fumble = check_success(raw_d20_roll, int(defense_value), is_attack=True)
    
    if is_critical: 
        hit_success = True
    elif is_fumble: 
        hit_success = False
    else:
        hit_success = (hit_roll_total_modified >= defense_value)

    roll_msg_content = (f"{performer.combat_name} attacks {target.combat_name} with {action.name}: "
                        f"Roll {hit_roll_total_modified}{roll_type_str} (Dice:{adv_rolls_str_display} + Bonus:{attack_bonus}) vs Def {int(defense_value)}")
    event_roll_msg = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=roll_msg_content, target_display=DisplayTarget.COMBAT_LOG)
    engine._combat_orchestrator.add_event_to_queue(event_roll_msg)
    manager._add_to_log(roll_msg_content) 
    queued_events_this_handler = True

    # Apply and display resource costs (stamina/mana) after roll line
    try:
        stamina_spent = current_result_detail.get("stamina_spent", 0)
        mana_spent = current_result_detail.get("mana_spent", 0)
        if stamina_spent and stamina_spent > 0:
            prev_stam = performer_stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
            new_stam = max(0, prev_stam - stamina_spent)
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={},
                metadata={"entity_id": performer.id, "bar_type": "stamina", "old_value": prev_stam, "new_value_preview": new_stam, "max_value": performer.max_stamina}
            ))
            performer_stats_manager.set_current_stat(DerivedStatType.STAMINA, new_stam)
            performer.set_current_stamina(new_stam)
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={},
                metadata={"entity_id": performer.id, "bar_type": "stamina", "final_new_value": new_stam, "max_value": performer.max_stamina}
            ))
            manager._add_to_log(f"{performer.combat_name} spent {stamina_spent:.1f} stamina. Rem: {new_stam:.1f}")
        if mana_spent and mana_spent > 0:
            prev_mp = performer_stats_manager.get_current_stat_value(DerivedStatType.MANA)
            new_mp = max(0, prev_mp - mana_spent)
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={},
                metadata={"entity_id": performer.id, "bar_type": "mana", "old_value": prev_mp, "new_value_preview": new_mp, "max_value": performer.max_mp}
            ))
            performer_stats_manager.set_current_stat(DerivedStatType.MANA, new_mp)
            performer.current_mp = new_mp
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={},
                metadata={"entity_id": performer.id, "bar_type": "mana", "final_new_value": new_mp, "max_value": performer.max_mp}
            ))
            manager._add_to_log(f"{performer.combat_name} spent {mana_spent:.1f} mana. Rem: {new_mp:.1f}")
    except Exception as e_cost:
        logger.warning(f"Failed to apply/display resource costs after roll: {e_cost}")

    # Determine typed damage type for melee attacks (default to slashing)
    damage_type = "slashing"
    current_result_detail.update({
        "hit_roll_result": {"success": hit_success, "is_critical": is_critical, "is_fumble": is_fumble,
                            "roll_total": hit_roll_total_modified, "roll_dice": raw_d20_roll, "roll_bonus": attack_bonus,
                            "target_defense": defense_value},
        "damage": 0, "damage_type": damage_type,
        "target_hp_before": target.current_hp if hasattr(target, 'current_hp') else target_stats_manager.get_current_stat_value(DerivedStatType.HEALTH), 
        "target_hp_after": target.current_hp if hasattr(target, 'current_hp') else target_stats_manager.get_current_stat_value(DerivedStatType.HEALTH), 
        "target_max_hp": target.max_hp if hasattr(target, 'max_hp') else target_stats_manager.get_stat_value(DerivedStatType.MAX_HEALTH),
        "target_defeated": not target.is_alive(), "damage_rolls_desc": ""
    })

    if hit_success:
        current_result_detail["success"] = True 
        current_result_detail["message"] = "Attack landed." 
        try:
            damage_dice = action.dice_notation or "1d4"
            damage_rolls_str = ""
            base_damage_from_dice = 0
            
            base_damage_roll_obj = roll_dice_notation(damage_dice)
            base_damage_from_dice = base_damage_roll_obj["total"]
            damage_rolls_str = base_damage_roll_obj['rolls_str']

            if is_critical:
                crit_damage_roll_obj = roll_dice_notation(damage_dice) 
                base_damage_from_dice += crit_damage_roll_obj["total"]
                damage_rolls_str += f" + {crit_damage_roll_obj['rolls_str']} (Crit!)"
                crit_msg_event = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content="  Critical Hit!", target_display=DisplayTarget.COMBAT_LOG)
                engine._combat_orchestrator.add_event_to_queue(crit_msg_event); manager._add_to_log("  Critical Hit!")
                queued_events_this_handler = True
            
            current_result_detail["damage_rolls_desc"] = damage_rolls_str
            damage_stat_mod_value = attack_stat_modifier 
            total_raw_damage = base_damage_from_dice + damage_stat_mod_value
            
            raw_damage_msg = f"  Raw Damage: {total_raw_damage:.0f} ({damage_rolls_str} + {damage_stat_mod_value} mod)"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=raw_damage_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(raw_damage_msg)
            queued_events_this_handler = True
            
            damage_reduction = target_stats_manager.get_stat_value(DerivedStatType.DAMAGE_REDUCTION)
            after_flat = max(0, total_raw_damage - damage_reduction)
            final_damage_dealt = round(after_flat)
            
            mitigation_msg = f"  Mitigation: DR {damage_reduction:.0f}. After DR: {after_flat:.0f}"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=mitigation_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(mitigation_msg)
            queued_events_this_handler = True
            
            # Apply typed resistance
            try:
                typed_resist = float(target_stats_manager.get_resistance_percent(damage_type))
            except Exception:
                typed_resist = 0.0
            if abs(typed_resist) > 0.0001:
                after_type = max(0, after_flat * (1 - typed_resist / 100.0))
                final_damage_dealt = round(after_type)
                type_msg = f"  Type Resistance ({damage_type}): {typed_resist:.0f}% -> Final Damage: {final_damage_dealt}"
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=type_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(type_msg)
                queued_events_this_handler = True

            target_hp_before_actual_deduction = target_stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
            target_hp_after_damage_preview = max(0, target_hp_before_actual_deduction - final_damage_dealt)
            
            # Optional typed rider application (low chance) before announcing damage line
            try:
                cfg = get_config()
                rider = cfg.get(f"combat.typed_riders.{damage_type}")
            except Exception:
                rider = None
            try:
                if rider and isinstance(rider, dict) and rider.get("status"):
                    ch = rider.get("chance", 0.0)
                    dur = rider.get("duration", 1)
                    if random.random() < float(ch) and final_damage_dealt > 0:
                        status_name = str(rider.get("status"))
                        # Apply to stats manager and entity registry for consistency
                        target_stats_manager.add_status_effect(StatusEffect(name=status_name, description=f"From {action.name}", effect_type=StatusEffectType.SPECIAL, duration=int(dur)))
                        target.add_status_effect(status_name, duration=int(dur))
                        status_msg = f"  {target.combat_name} is now {status_name} due to {action.name}!"
                        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=status_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(status_msg)
                        queued_events_this_handler = True
            except Exception as rider_err:
                logger.debug(f"Typed rider application failed or skipped: {rider_err}")
            
            # STRICT ORDER: announce damage before any bar change
            damage_taken_log_msg = f"  {target.combat_name} takes {final_damage_dealt:.0f} {current_result_detail['damage_type']} damage! (HP: {int(target_hp_after_damage_preview)}/{int(target.max_hp)})"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=damage_taken_log_msg, target_display=DisplayTarget.COMBAT_LOG, gradual_visual_display=True)); manager._add_to_log(damage_taken_log_msg)
            queued_events_this_handler = True

            # Apply model update AFTER the outcome text is displayed, then animate
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                type=DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE,
                content={},
                metadata={"entity_id": target.id, "bar_type": "hp", "final_new_value": target_hp_after_damage_preview, "max_value": target.max_hp}
            )); queued_events_this_handler = True

            # Phase 1 preview, then finalize
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={}, metadata={"entity_id": target.id, "bar_type": "hp", "old_value": target_hp_before_actual_deduction, "new_value_preview": target_hp_after_damage_preview, "max_value": target.max_hp})); queued_events_this_handler = True
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={}, metadata={"entity_id": target.id, "bar_type": "hp", "final_new_value": target_hp_after_damage_preview, "max_value": target.max_hp})); queued_events_this_handler = True

            current_result_detail.update({"damage": final_damage_dealt, "target_hp_after": target_hp_after_damage_preview})

            if target_hp_after_damage_preview <= 0:
                defeat_msg = f"{target.combat_name} is defeated!"
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=defeat_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(defeat_msg)
                queued_events_this_handler = True
                current_result_detail["target_defeated"] = True

                # Record defeat event for quest evaluation (Phase 1)
                try:
                    game_state = engine._state_manager.current_state
                    if game_state is not None:
                        from core.game_flow.event_log import record_enemy_defeated
                        # Use target.name as template_id fallback; include combat_name as tag hint
                        template_id = getattr(target, 'name', None) or getattr(target, 'combat_name', None)
                        tags = {"combat_name": getattr(target, 'combat_name', None)}
                        record_enemy_defeated(game_state, entity_id=str(target.id), template_id=str(template_id) if template_id else None, tags=tags, location_id=None)
                except Exception as e_log:
                    logger.debug(f"Failed to record defeat event: {e_log}")

                # Delay removing the entity from active combat until after defeat text using an orchestrated state update
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                    type=DisplayEventType.APPLY_ENTITY_STATE_UPDATE,
                    content={},
                    metadata={"entity_id": target.id, "is_active_in_combat": False}
                ))
                # If defeat ends combat (player down or all enemies down), schedule a 3000ms pause and finalize
                try:
                    from core.combat.combat_entity import EntityType
                    if target.entity_type == EntityType.PLAYER:
                        # Mark immediate end state to prevent any further CM steps
                        manager.state = CombatState.PLAYER_DEFEAT
                        manager.current_step = CombatStep.ENDING_COMBAT
                        manager.waiting_for_display_completion = True
# Removed pause/finalize events; CM will end via state/step change
                    else:
                        remaining_enemies = [e for e in manager.entities.values() if e.entity_type == EntityType.ENEMY and e.is_active_in_combat and e.is_alive()]
                        if len(remaining_enemies) == 0:
                            # Mark immediate end state to prevent any further CM steps
                            manager.state = CombatState.PLAYER_VICTORY
                            manager.current_step = CombatStep.ENDING_COMBAT
                            manager.waiting_for_display_completion = True
# Removed pause/finalize events; CM will end via state/step change
                except Exception:
                    pass
        except Exception as dmg_err:
            logger.error(f"Error during damage calculation for {action.name}: {dmg_err}", exc_info=True)
            current_result_detail["message"] = "Hit landed, but error calculating damage."
            current_result_detail["error_detail"] = f"Damage calc error: {dmg_err}"

    else: 
        miss_log_msg = "  Fumble! Attack misses wildly." if is_fumble else "  Attack misses."
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=miss_log_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(miss_log_msg)
        queued_events_this_handler = True
        current_result_detail["success"] = False 
        current_result_detail["message"] = "Attack missed."
    
    current_result_detail["queued_events"] = queued_events_this_handler
    return current_result_detail

def _handle_spell_action(manager: 'CombatManager', action: CombatAction, performer: CombatEntity, performer_stats_manager: 'StatsManager', engine: 'GameEngine', current_result_detail: Dict) -> Dict[str, Any]:
    """Handle a spell casting action, including damage and effects. Queues DisplayEvents."""
    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
    
    queued_events_this_handler = False
    handler_result_summary = {"success": False, "message": "Spell casting failed or target invalid."} 
    current_result_detail.update(handler_result_summary) 

    if "targets_processed" not in current_result_detail:
        current_result_detail["targets_processed"] = []

    if not action.targets:
        current_result_detail["message"] = "No target specified for spell."
        return current_result_detail 

    at_least_one_target_processed = False
    for target_id in action.targets:
        target = manager.entities.get(target_id)
        target_processing_summary = {"target_id": target_id, "target_name": "Unknown", "effects_applied": [], "damage_done": 0, "healing_done": 0, "defeated": False}

        if not target:
            logger.warning(f"Target {target_id} not found for spell {action.name}")
            target_processing_summary["error"] = "Target not found"
            current_result_detail["targets_processed"].append(target_processing_summary)
            continue
        
        target_processing_summary["target_name"] = target.combat_name

        if not target.is_alive():
            logger.debug(f"Target {target.combat_name} already defeated, skipping spell effect.")
            target_processing_summary["status"] = "Already defeated"
            current_result_detail["targets_processed"].append(target_processing_summary)
            continue

        target_stats_manager = manager._get_entity_stats_manager(target_id)
        if not target_stats_manager:
            logger.error(f"Could not find StatsManager for target {target_id} of spell {action.name}. Skipping target.")
            target_processing_summary["error"] = "Target StatsManager not found"
            current_result_detail["targets_processed"].append(target_processing_summary)
            continue
            
        target_hp_before_spell = target_stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
        
        if action.dice_notation: 
            at_least_one_target_processed = True 
            base_damage_result = roll_dice_notation(action.dice_notation)

            # Apply and display resource costs (stamina/mana) after spell attempt/roll text
            try:
                stamina_spent = current_result_detail.get("stamina_spent", 0)
                mana_spent = current_result_detail.get("mana_spent", 0)
                if stamina_spent and stamina_spent > 0:
                    prev_stam = performer_stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                    new_stam = max(0, prev_stam - stamina_spent)
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                        type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={},
                        metadata={"entity_id": performer.id, "bar_type": "stamina", "old_value": prev_stam, "new_value_preview": new_stam, "max_value": performer.max_stamina}
                    ))
                    # Apply model update as a separate orchestrated event
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                        type=DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE,
                        content={},
                        metadata={"entity_id": performer.id, "bar_type": "stamina", "final_new_value": new_stam, "max_value": performer.max_stamina}
                    ))
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={},
                        metadata={"entity_id": performer.id, "bar_type": "stamina", "final_new_value": new_stam, "max_value": performer.max_stamina}
                    ))
                    manager._add_to_log(f"{performer.combat_name} spent {stamina_spent:.1f} stamina. Rem: {new_stam:.1f}")
                if mana_spent and mana_spent > 0:
                    prev_mp = performer_stats_manager.get_current_stat_value(DerivedStatType.MANA)
                    new_mp = max(0, prev_mp - mana_spent)
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                        type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={},
                        metadata={"entity_id": performer.id, "bar_type": "mana", "old_value": prev_mp, "new_value_preview": new_mp, "max_value": performer.max_mp}
                    ))
                    # Apply model update as a separate orchestrated event
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                        type=DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE,
                        content={},
                        metadata={"entity_id": performer.id, "bar_type": "mana", "final_new_value": new_mp, "max_value": performer.max_mp}
                    ))
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                        type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={},
                        metadata={"entity_id": performer.id, "bar_type": "mana", "final_new_value": new_mp, "max_value": performer.max_mp}
                    ))
                    manager._add_to_log(f"{performer.combat_name} spent {mana_spent:.1f} mana. Rem: {new_mp:.1f}")
            except Exception as e_cost:
                logger.warning(f"Failed to apply/display resource costs after spell roll: {e_cost}")
            base_damage = base_damage_result["total"]
            damage_rolls_str = base_damage_result['rolls_str']
            
            spell_stat_type_str = getattr(action, 'spell_stat_override', 'INTELLIGENCE') 
            spell_stat_type = StatType.from_string(spell_stat_type_str)
            spell_stat_modifier = get_modifier_from_stat(performer_stats_manager.get_stat_value(spell_stat_type))

            total_raw_damage = base_damage + spell_stat_modifier
            raw_dmg_msg = f"  {action.name} raw damage on {target.combat_name}: {total_raw_damage:.0f} ({damage_rolls_str} + {spell_stat_modifier} mod)"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=raw_dmg_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(raw_dmg_msg)
            queued_events_this_handler = True

            magic_defense_val = target_stats_manager.get_stat_value(DerivedStatType.MAGIC_DEFENSE)
            after_flat = max(0, total_raw_damage - magic_defense_val)
            final_damage = round(after_flat)
            
            mitigation_msg = f"  {target.combat_name} resists ({magic_defense_val:.0f} M.Def). After M.Def: {after_flat:.0f}"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=mitigation_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(mitigation_msg)
            queued_events_this_handler = True
            
            # Determine damage type for spell (default arcane)
            dmg_type = "arcane"
            try:
                if isinstance(action.special_effects, dict):
                    cand = action.special_effects.get("damage_type")
                    if isinstance(cand, str) and cand.strip():
                        dmg_type = cand.strip().lower()
            except Exception:
                pass
            
            # Apply typed resistance if defined
            try:
                typed_resist = float(target_stats_manager.get_resistance_percent(dmg_type))
            except Exception:
                typed_resist = 0.0
            if abs(typed_resist) > 0.0001:
                after_type = max(0, after_flat * (1 - typed_resist / 100.0))
                final_damage = round(after_type)
                type_msg = f"  Type Resistance ({dmg_type}): {typed_resist:.0f}% -> Final Damage: {final_damage}"
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=type_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(type_msg)
                queued_events_this_handler = True

            if final_damage > 0:
                target_hp_preview = max(0, target_hp_before_spell - final_damage)

                # Optional typed rider for spells
                try:
                    cfg = get_config()
                    rider = cfg.get(f"combat.typed_riders.{dmg_type}")
                except Exception:
                    rider = None
                try:
                    if rider and isinstance(rider, dict) and rider.get("status"):
                        ch = rider.get("chance", 0.0)
                        dur = rider.get("duration", 1)
                        if random.random() < float(ch) and final_damage > 0:
                            status_name = str(rider.get("status"))
                            target_stats_manager.add_status_effect(StatusEffect(name=status_name, description=f"From {action.name}", effect_type=StatusEffectType.SPECIAL, duration=int(dur)))
                            target.add_status_effect(status_name, duration=int(dur))
                            status_msg = f"  {target.combat_name} is now {status_name} due to {action.name}!"
                            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=status_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(status_msg)
                            queued_events_this_handler = True
                except Exception as rider_err:
                    logger.debug(f"Typed rider (spell) failed or skipped: {rider_err}")
                
                # STRICT ORDER: announce damage before bar changes
                damage_taken_msg = f"  {target.combat_name} takes {final_damage:.0f} {dmg_type} damage from {action.name}! (HP: {int(target_hp_preview)}/{int(target.max_hp)})"
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=damage_taken_msg, target_display=DisplayTarget.COMBAT_LOG, gradual_visual_display=True)); manager._add_to_log(damage_taken_msg)
                queued_events_this_handler = True

                # Apply model update AFTER the outcome text is displayed, then animate
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                    type=DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE,
                    content={},
                    metadata={"entity_id": target.id, "bar_type": "hp", "final_new_value": target_hp_preview, "max_value": target.max_hp}
                )); queued_events_this_handler = True

                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={}, metadata={"entity_id": target.id, "bar_type": "hp", "old_value": target_hp_before_spell, "new_value_preview": target_hp_preview, "max_value": target.max_hp})); queued_events_this_handler = True
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={}, metadata={"entity_id": target.id, "bar_type": "hp", "final_new_value": target_hp_preview, "max_value": target.max_hp})); queued_events_this_handler = True
                target_processing_summary["damage_done"] = final_damage

                if target_hp_preview <= 0:
                    defeat_msg = f"{target.combat_name} is defeated by {action.name}!"
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=defeat_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(defeat_msg)
                    queued_events_this_handler = True
                    target_processing_summary["defeated"] = True
                    # Delay removing the entity from active combat until after defeat text
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                        type=DisplayEventType.APPLY_ENTITY_STATE_UPDATE,
                        content={},
                        metadata={"entity_id": target.id, "is_active_in_combat": False}
                    ))
                    # If defeat ends combat (all enemies down or player down), pause and finalize
                    try:
                        from core.combat.combat_entity import EntityType
                        if target.entity_type == EntityType.PLAYER:
                            # Player defeat -> mark end-state and pause then finalize
                            manager.state = CombatState.PLAYER_DEFEAT
                            manager.current_step = CombatStep.ENDING_COMBAT
                            manager.waiting_for_display_completion = True
# Removed pause/finalize events; CM will end via state/step change
                        else:
                            remaining_enemies = [e for e in manager.entities.values() if e.entity_type == EntityType.ENEMY and e.is_active_in_combat and e.is_alive()]
                            if len(remaining_enemies) == 0:
                                manager.state = CombatState.PLAYER_VICTORY
                                manager.current_step = CombatStep.ENDING_COMBAT
                                manager.waiting_for_display_completion = True
# Removed pause/finalize events; CM will end via state/step change
                    except Exception:
                        pass

        for effect_name_key, effect_params in action.special_effects.items():
            at_least_one_target_processed = True
            if effect_name_key == "apply_status": 
                status_to_apply = effect_params.get("name", "UnknownEffect")
                status_duration = effect_params.get("duration") 
                
                target_stats_manager.add_status_effect(StatusEffect(name=status_to_apply, description=f"From {action.name}", effect_type=StatusEffectType.SPECIAL, duration=status_duration))
                target.add_status_effect(status_to_apply, duration=status_duration)
                
                duration_text = f" for {status_duration} turns" if status_duration is not None else ""
                status_msg = f"  {target.combat_name} is now {status_to_apply}{duration_text} due to {action.name}!"
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=status_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(status_msg)
                queued_events_this_handler = True
                target_processing_summary["effects_applied"].append(status_to_apply)
        
        current_result_detail["targets_processed"].append(target_processing_summary)

    if at_least_one_target_processed :
        current_result_detail["success"] = True
        current_result_detail["message"] = f"{action.name} was cast."
    else: 
        current_result_detail["success"] = False
        current_result_detail["message"] = f"{action.name} had no effect or no valid targets."
        no_effect_msg = f"{action.name} is cast by {performer.combat_name}, but has no discernible effect."
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=no_effect_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(no_effect_msg)
        queued_events_this_handler = True


    current_result_detail["queued_events"] = queued_events_this_handler
    return current_result_detail

def _handle_defend_action(manager: 'CombatManager', action: CombatAction, performer: CombatEntity, performer_stats_manager: 'StatsManager', engine: 'GameEngine', current_result_detail: Dict) -> Dict[str, Any]:
    """Handle the mechanics of a defend action. Queues DisplayEvents."""
    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
    logger.info(f"{performer.combat_name} takes a defensive stance.")
    queued_events_this_handler = False
    
    duration = 1 
    performer_stats_manager.add_status_effect(StatusEffect(name="Defending", description="Taking a defensive stance, improving defense.", effect_type=StatusEffectType.BUFF, duration=duration))
    performer.add_status_effect("Defending", duration=duration) 

    defend_msg = f"  {performer.combat_name} is now Defending."
    # This message is usually covered by the NARRATIVE_IMPACT from CombatNarrator for defend action.
    # If CombatNarrator doesn't provide one, or if a system message is always desired:
    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=defend_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(defend_msg)
    queued_events_this_handler = True
    
    current_result_detail.update({
        "success": True, 
        "message": "Took defensive stance.",
        "effects_applied": [{"type": "status", "name": "Defending", "duration": duration, "target": performer.combat_name}],
        "queued_events": queued_events_this_handler
    })
    return current_result_detail

def _handle_item_action(manager: 'CombatManager', action: CombatAction, performer: CombatEntity, performer_stats_manager: 'StatsManager', engine: 'GameEngine', current_result_detail: Dict) -> Dict[str, Any]:
    """Handle using an item in combat. Queues DisplayEvents."""
    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
    
    item_id_from_action = action.special_effects.get("item_id", "unknown_item") 
    item_name_from_action = action.name.replace("Use ", "") 
    queued_events_this_handler = False

    item_used_msg = f"{performer.combat_name} uses {item_name_from_action}!"
    # After the item usage line (if used), apply costs if any were recorded

    current_result_detail.update({"targets_processed": [], "item_id": item_id_from_action, "item_name": item_name_from_action})
    at_least_one_effect_applied = False

    targets_for_item = action.targets if action.targets else [performer.id]

    for target_id in targets_for_item:
        target = manager.entities.get(target_id)
        target_processing_summary = {"target_id": target_id, "target_name": "Unknown", "effects_applied": [], "damage_done": 0, "healing_done": 0, "defeated": False}

        if not target:
            logger.warning(f"Target {target_id} not found for item {item_name_from_action}")
            target_processing_summary["error"] = "Target not found"
            current_result_detail["targets_processed"].append(target_processing_summary)
            continue
        
        target_processing_summary["target_name"] = target.combat_name

        if not target.is_alive() and "revive" not in action.special_effects: 
            logger.debug(f"Target {target.combat_name} already defeated, skipping item effect for {item_name_from_action}.")
            target_processing_summary["status"] = "Already defeated"
            current_result_detail["targets_processed"].append(target_processing_summary)
            continue

        target_stats_manager = manager._get_entity_stats_manager(target_id)
        if not target_stats_manager:
            logger.error(f"StatsManager for target {target_id} of item {item_name_from_action} not found.")
            target_processing_summary["error"] = "Target StatsManager not found"
            current_result_detail["targets_processed"].append(target_processing_summary)
            continue
            
        target_hp_before_item = target_stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
        item_effects = action.special_effects 
        
        if item_effects.get("effect_type") == "healing_potion": 
            at_least_one_effect_applied = True
            heal_amount = int(item_effects.get("heal_amount", 10)) 
            target_hp_preview = min(target_hp_before_item + heal_amount, target.max_hp)
            actual_healed = target_hp_preview - target_hp_before_item

            if actual_healed > 0:
                # STRICT ORDER: announce heal before bar changes
                heal_msg = f"  {target.combat_name} is healed for {actual_healed:.0f} HP by {item_name_from_action}! (HP: {int(target_hp_preview)}/{int(target.max_hp)})"
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=heal_msg, target_display=DisplayTarget.COMBAT_LOG, gradual_visual_display=True)); manager._add_to_log(heal_msg)
                queued_events_this_handler = True
                
                # Apply model update AFTER heal message is displayed
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(
                    type=DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE,
                    content={},
                    metadata={"entity_id": target.id, "bar_type": "hp", "final_new_value": target_hp_preview, "max_value": target.max_hp}
                )); queued_events_this_handler = True

                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={}, metadata={"entity_id": target.id, "bar_type": "hp", "old_value": target_hp_before_item, "new_value_preview": target_hp_preview, "max_value": target.max_hp})); queued_events_this_handler = True
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={}, metadata={"entity_id": target.id, "bar_type": "hp", "final_new_value": target_hp_preview, "max_value": target.max_hp})); queued_events_this_handler = True
                target_processing_summary["healing_done"] = actual_healed
            else:
                no_heal_msg = f"  {item_name_from_action} has no further healing effect on {target.combat_name} (already at/near full health)."
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=no_heal_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(no_heal_msg)
                queued_events_this_handler = True
        
        if item_effects.get("apply_status"):
            at_least_one_effect_applied = True
            status_to_apply = item_effects["apply_status"].get("name", "UnknownEffect")
            status_duration = item_effects["apply_status"].get("duration")
            
            target_stats_manager.add_status_effect(StatusEffect(name=status_to_apply, description=f"From item {item_name_from_action}", effect_type=StatusEffectType.SPECIAL, duration=status_duration))
            target.add_status_effect(status_to_apply, duration=status_duration)
            
            duration_text = f" for {status_duration} turns" if status_duration is not None else ""
            status_msg = f"  {target.combat_name} is now {status_to_apply}{duration_text} from {item_name_from_action}!"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=status_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(status_msg)
            queued_events_this_handler = True
            target_processing_summary["effects_applied"].append(status_to_apply)
            
        current_result_detail["targets_processed"].append(target_processing_summary)

    if at_least_one_effect_applied:
        current_result_detail["success"] = True 
        current_result_detail["message"] = f"{item_name_from_action} was used effectively."
    else: 
        current_result_detail["success"] = True 
        current_result_detail["message"] = f"{item_name_from_action} was used, but had no immediate combat effects."
        no_effect_msg = f"{performer.combat_name} uses {item_name_from_action}, but it seems to have no immediate effect."
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=no_effect_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(no_effect_msg)
        queued_events_this_handler = True
        
    current_result_detail["queued_events"] = queued_events_this_handler
    return current_result_detail

def _handle_flee_action_mechanics(manager: 'CombatManager', action: CombatAction, performer: CombatEntity, performer_stats_manager: 'StatsManager', engine: 'GameEngine', current_result_detail: Dict) -> Dict[str, Any]:
    """Handles the mechanics of a flee action attempt. Queues DisplayEvents."""
    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
    from core.game_flow.mode_transitions import _determine_flee_parameters 

    queued_events_this_handler = False
    handler_result_summary = {"success": False, "fled": False, "message": "Flee attempt failed."} 
    current_result_detail.update(handler_result_summary)

    logger.info(f"{performer.combat_name} attempts to flee.")

    if performer.has_status_effect("Immobilized"):
        immobilized_msg = f"  {performer.combat_name} cannot flee, they are immobilized!"
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=immobilized_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(immobilized_msg)
        queued_events_this_handler = True
        current_result_detail["message"] = "Cannot flee while immobilized."
        current_result_detail["queued_events"] = queued_events_this_handler
        return current_result_detail # Return immediately

    enemy_entities = [e for e in manager.entities.values() if e.entity_type == EntityType.ENEMY and e.is_alive() and getattr(e, 'is_active_in_combat', True)]
    if not enemy_entities:
        no_enemies_msg = f"{performer.combat_name} looks around... there are no active enemies to flee from. Combat ends."
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=no_enemies_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(no_enemies_msg)
        queued_events_this_handler = True
        # This signals success, but not "fled from danger".
        # CombatManager's main loop (_advance_turn -> _check_combat_state) will set player victory.
        current_result_detail.update({"success": True, "fled": False, "message": "No enemies to flee from."})
        current_result_detail["queued_events"] = queued_events_this_handler
        return current_result_detail

    try:
        # Pass the actual GameState rather than CombatManager to parameter determination
        flee_dc, situational_modifier, modifier_reasons = _determine_flee_parameters(engine._state_manager.current_state, performer)

        check_result = performer_stats_manager.perform_skill_check(
            stat_type=StatType.DEXTERITY, 
            difficulty=flee_dc,
            situational_modifier=situational_modifier
        )
        
        modifier_str_display = f"{check_result.modifier} (stat)"
        if check_result.situational_modifier != 0:
            modifier_str_display += f" {check_result.situational_modifier:+}"
            if modifier_reasons: modifier_str_display += f" ({', '.join(modifier_reasons)})"
            else: modifier_str_display += " (situational)"

        check_roll_msg = (
            f"{performer.combat_name} attempts to flee ({StatType.DEXTERITY.name} check DC {flee_dc}): "
            f"Roll {check_result.roll} + {modifier_str_display} "
            f"= {check_result.total} -> {check_result.outcome_desc}"
            f"{' (Crit!)' if check_result.critical else ''}"
        )
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=check_roll_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(check_roll_msg)
        queued_events_this_handler = True

        flee_succeeded_mechanically = check_result.success
        current_result_detail["roll_details"] = check_result.to_dict()

        if flee_succeeded_mechanically:
            # The "fled" flag in current_result_detail signals to _step_advancing_turn
            # to end combat for the fleeing entity.
            current_result_detail.update({"success": True, "fled": True, "message": "Escape successful!"})
            performer.is_active_in_combat = False # Mark as no longer active
        else:
            current_result_detail.update({"success": False, "fled": False, "message": "Escape attempt failed."})
            
    except ImportError as ie:
        logger.error(f"ImportError during flee check for {performer.combat_name}: {ie}.")
        err_msg = "System Error performing flee check: Module loading issue."
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=err_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(err_msg)
        queued_events_this_handler = True
        current_result_detail["message"] = err_msg
    except Exception as e:
        logger.exception(f"Error during flee check mechanics for {performer.combat_name}: {e}")
        err_msg = f"System Error performing flee check: {e}"
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=err_msg, target_display=DisplayTarget.COMBAT_LOG)); manager._add_to_log(err_msg)
        queued_events_this_handler = True
        current_result_detail["message"] = err_msg
        
    current_result_detail["queued_events"] = queued_events_this_handler
    return current_result_detail
```

### File: core\combat\combat_action.py

```python
"""
Combat action class for representing actions in combat.
"""

from enum import Enum, auto
from dataclasses import dataclass
from typing import Dict, List, Any, Optional, Union
import uuid


class ActionType(Enum):
    """Types of combat actions."""
    ATTACK = auto()       # Basic melee or ranged attack
    SPELL = auto()        # Magical ability
    SKILL = auto()        # Special physical ability
    DEFEND = auto()       # Defensive stance
    ITEM = auto()         # Use an item
    FLEE = auto()         # Attempt to escape
    MOVE = auto()         # Change position
    OTHER = auto()        # Miscellaneous action


@dataclass
class CombatAction:
    """
    Represents an action taken during combat.
    
    Attributes:
        id: Unique identifier for the action
        name: Display name of the action
        action_type: Type of action
        performer_id: ID of the entity performing the action
        targets: List of target entity IDs
        cost_mp: Mana cost
        cost_stamina: Stamina cost
        dice_notation: Damage/effect formula (e.g., "2d6+3")
        description: Description of the action
        special_effects: Additional effects (dict of effect name to parameters)
    """
    id: str = ""
    name: str = ""
    action_type: ActionType = ActionType.OTHER
    performer_id: str = ""
    targets: List[str] = None
    cost_mp: float = 0
    cost_stamina: float = 0
    dice_notation: str = ""
    description: str = ""
    special_effects: Dict[str, Any] = None
    
    def __post_init__(self):
        """Initialize default values."""
        if not self.id:
            self.id = str(uuid.uuid4())
        if self.targets is None:
            self.targets = []
        if self.special_effects is None:
            self.special_effects = {}
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "action_type": self.action_type.name,
            "performer_id": self.performer_id,
            "targets": self.targets,
            "cost_mp": self.cost_mp,
            "cost_stamina": self.cost_stamina,
            "dice_notation": self.dice_notation,
            "description": self.description,
            "special_effects": self.special_effects
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CombatAction':
        """Create a CombatAction from a dictionary."""
        return cls(
            id=data.get("id", str(uuid.uuid4())),
            name=data["name"],
            action_type=ActionType[data["action_type"]],
            performer_id=data["performer_id"],
            targets=data.get("targets", []),
            cost_mp=data.get("cost_mp", 0),
            cost_stamina=data.get("cost_stamina", 0),
            dice_notation=data.get("dice_notation", ""),
            description=data.get("description", ""),
            special_effects=data.get("special_effects", {})
        )


@dataclass
class AttackAction(CombatAction):
    """Represents a basic attack action."""
    
    def __init__(
            self,
            performer_id: str,
            target_id: str,
            weapon_name: str = "unarmed",
            dice_notation: str = "1d4",
            **kwargs
        ):
            # Calculate the name based on weapon_name
            action_name = f"{weapon_name.capitalize()} Attack"
            
            # Remove 'name' from kwargs if it exists to prevent conflict
            kwargs.pop('name', None) 
            
            super().__init__(
                id=kwargs.get("id", str(uuid.uuid4())),
                name=action_name, # Pass the calculated name explicitly
                action_type=ActionType.ATTACK,
                performer_id=performer_id,
                targets=[target_id],
                dice_notation=dice_notation,
                description=f"Attack with {weapon_name}",
                **kwargs # Pass remaining kwargs
            )

@dataclass
class SpellAction(CombatAction):
    """Represents a spell casting action."""
    
    def __init__(
        self,
        performer_id: str,
        spell_name: str,
        target_ids: List[str],
        cost_mp: float,
        dice_notation: str = "",
        description: str = "",
        special_effects: Dict[str, Any] = None,
        **kwargs
    ):
        if special_effects is None:
            special_effects = {}
            
        super().__init__(
            id=kwargs.get("id", str(uuid.uuid4())),
            name=spell_name,
            action_type=ActionType.SPELL,
            performer_id=performer_id,
            targets=target_ids,
            cost_mp=cost_mp,
            dice_notation=dice_notation,
            description=description or f"Cast {spell_name}",
            special_effects=special_effects,
            **kwargs
        )


@dataclass
class DefendAction(CombatAction):
    """Represents a defensive action."""
    
    def __init__(self, performer_id: str, **kwargs):
        super().__init__(
            id=kwargs.get("id", str(uuid.uuid4())),
            name="Defend",
            action_type=ActionType.DEFEND,
            performer_id=performer_id,
            description="Take a defensive stance, reducing incoming damage",
            special_effects={"damage_reduction": 0.5},  # 50% damage reduction
            **kwargs
        )


@dataclass
class ItemAction(CombatAction):
    """Represents using an item in combat."""
    
    def __init__(
        self,
        performer_id: str,
        item_id: str,
        item_name: str,
        target_ids: List[str],
        dice_notation: str = "",
        description: str = "",
        special_effects: Dict[str, Any] = None,
        **kwargs
    ):
        if special_effects is None:
            special_effects = {"item_id": item_id}
        else:
            special_effects["item_id"] = item_id
            
        super().__init__(
            id=kwargs.get("id", str(uuid.uuid4())),
            name=f"Use {item_name}",
            action_type=ActionType.ITEM,
            performer_id=performer_id,
            targets=target_ids,
            dice_notation=dice_notation,
            description=description or f"Use {item_name}",
            special_effects=special_effects,
            **kwargs
        )


@dataclass
class FleeAction(CombatAction):
    """Represents an attempt to flee from combat."""
    
    def __init__(self, performer_id: str, **kwargs):
        super().__init__(
            id=kwargs.get("id", str(uuid.uuid4())),
            name="Flee",
            action_type=ActionType.FLEE,
            performer_id=performer_id,
            description="Attempt to escape from combat",
            **kwargs
        )

```

### File: core\combat\combat_entity.py

```python
"""
Combat entity class for representing combatants.
"""

from enum import Enum, auto
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Set, Union, Tuple
import logging

logger = logging.getLogger(__name__)

from core.stats.stats_base import StatType, DerivedStatType


class EntityType(Enum):
    """Types of combat entities."""
    PLAYER = auto()
    NPC = auto()
    ALLY = auto()
    ENEMY = auto()
    CREATURE = auto()


@dataclass
class CombatEntity:
    """
    Represents an entity in combat (player, enemy, ally, etc.).

    Attributes:
        id: Unique identifier for the entity
        name: Display name of the entity
        combat_name: Unique name used within this combat encounter (e.g., "Goblin 1") <--- ADDED
        entity_type: Type of entity (player, enemy, etc.)
        stats: Dictionary of stat values
        current_hp: Current hit points
        max_hp: Maximum hit points
        current_mp: Current mana points
        max_mp: Maximum mana points
        current_stamina: Current stamina
        max_stamina: Maximum stamina
        status_effects: Dict of active status effect names to optional durations
        initiative: Initiative value for turn order
        position: Position index in combat (0=front, higher=back)
        description: Flavor text description
        is_active_in_combat: Whether the entity is currently participating (not fled/removed)
    """
    id: str
    name: str
    combat_name: str # <--- ADDED
    entity_type: EntityType
    stats: Dict[Union[StatType, DerivedStatType, str], float]
    current_hp: float
    max_hp: float
    current_mp: float = 0
    max_mp: float = 0
    current_stamina: float = 0
    max_stamina: float = 0
    status_effects: Dict[str, Optional[int]] = field(default_factory=dict)
    initiative: float = 0
    position: int = 0
    description: str = ""
    is_active_in_combat: bool = True

    def is_alive(self) -> bool:
        """Check if the entity is alive."""
        return self.current_hp > 0

    def take_damage(self, amount: float) -> float:
        """
        Apply damage to the entity's current HP.

        Args:
            amount: Amount of damage to apply.

        Returns:
            The actual amount of damage dealt (after mitigation, etc.).
        """
        actual_damage = max(0, amount)
        previous_hp = self.current_hp
        self.current_hp = max(0, self.current_hp - actual_damage)
        damage_taken = previous_hp - self.current_hp
        return damage_taken

    def heal(self, amount: float) -> float:
        """
        Heal the entity's current HP.

        Args:
            amount: Amount of healing to apply.

        Returns:
            The actual amount healed.
        """
        if not self.is_alive():
            return 0

        amount_to_heal = max(0, amount)
        previous_hp = self.current_hp
        self.current_hp = min(self.max_hp, self.current_hp + amount_to_heal)
        amount_healed = self.current_hp - previous_hp
        return amount_healed

    def spend_mp(self, amount: float) -> bool:
        """
        Spend mana points directly on the entity.

        Args:
            amount: Amount of MP to spend.

        Returns:
            True if successful, False if not enough MP.
        """
        amount_to_spend = max(0, amount)
        if self.current_mp < amount_to_spend:
            return False

        self.current_mp -= amount_to_spend
        return True

    def spend_stamina(self, amount: float) -> bool:
        """
        Spend stamina directly on the entity.

        Args:
            amount: Amount of stamina to spend.

        Returns:
            True if successful, False if not enough stamina.
        """
        amount_to_spend = max(0, amount)
        if self.current_stamina < amount_to_spend:
            return False

        self.current_stamina -= amount_to_spend
        return True

    def restore_mp(self, amount: float) -> float:
        """
        Restore mana points directly on the entity.

        Args:
            amount: Amount of MP to restore.

        Returns:
            The actual amount restored.
        """
        amount_to_restore = max(0, amount)
        before = self.current_mp
        self.current_mp = min(self.max_mp, self.current_mp + amount_to_restore)
        amount_restored = self.current_mp - before
        return amount_restored

    def restore_stamina(self, amount: float) -> float:
        """
        Restore stamina directly on the entity.

        Args:
            amount: Amount of stamina to restore.

        Returns:
            The actual amount restored.
        """
        amount_to_restore = max(0, amount)
        before = self.current_stamina
        self.current_stamina = min(self.max_stamina, self.current_stamina + amount_to_restore)
        amount_restored = self.current_stamina - before
        return amount_restored

    def set_current_hp(self, value: float):
        """Sets the current HP, clamped between 0 and max_hp."""
        self.current_hp = max(0.0, min(value, self.max_hp))

    def set_current_stamina(self, value: float):
        """Sets the current Stamina, clamped between 0 and max_stamina."""
        self.current_stamina = max(0.0, min(value, self.max_stamina))

    def add_status_effect(self, effect: str, duration: Optional[int] = None) -> None:
        """
        Add a status effect to the entity.

        Args:
            effect: Name of the effect to add.
            duration: Number of turns the effect lasts, or None for permanent.
        """
        self.status_effects[effect] = duration
        logger.debug(f"Added status effect '{effect}' to {self.name} ({self.combat_name}) with duration: {duration}") # Added combat_name to log

    def remove_status_effect(self, effect: str) -> bool:
        """
        Remove a status effect from the entity.

        Args:
            effect: Name of the effect to remove.

        Returns:
            True if the effect was removed, False if it wasn't present.
        """
        if effect in self.status_effects:
            del self.status_effects[effect]
            logger.debug(f"Removed status effect '{effect}' from {self.name} ({self.combat_name})") # Added combat_name to log
            return True
        return False

    def has_status_effect(self, effect: str) -> bool:
        """
        Check if the entity has a specific status effect.

        Args:
            effect: Name of the effect to check.

        Returns:
            True if the entity has the effect, False otherwise.
        """
        return effect in self.status_effects

    def get_status_effect_duration(self, effect: str) -> Optional[int]:
        """
        Get the remaining duration of a status effect.

        Args:
            effect: Name of the effect to check.

        Returns:
            Remaining duration, None if permanent, or None if effect not present.
        """
        if effect in self.status_effects:
            return self.status_effects[effect]
        return None

    def decrement_status_effect_durations(self) -> List[str]:
        """
        Decrement durations of all timed status effects by 1.

        Returns:
            List of status effects that expired and were removed.
        """
        expired_effects = []

        for effect, duration in list(self.status_effects.items()):
            if duration is not None:
                new_duration = duration - 1
                if new_duration <= 0:
                    del self.status_effects[effect]
                    expired_effects.append(effect)
                    logger.debug(f"Status effect '{effect}' expired for {self.name} ({self.combat_name})") # Added combat_name
                else:
                    self.status_effects[effect] = new_duration
                    logger.debug(f"Status effect '{effect}' has {new_duration} turns remaining for {self.name} ({self.combat_name})") # Added combat_name

        return expired_effects

    def get_stat(self, stat: Union[StatType, DerivedStatType, str]) -> float:
        """
        Get the value of a stat.

        Args:
            stat: The stat to get.

        Returns:
            The stat value, or 0 if not found.
        """
        return self.stats.get(stat, 0)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "combat_name": self.combat_name, # <--- ADDED
            "entity_type": self.entity_type.name,
            "stats": {str(k): v for k, v in self.stats.items()},
            "current_hp": self.current_hp,
            "max_hp": self.max_hp,
            "current_mp": self.current_mp,
            "max_mp": self.max_mp,
            "current_stamina": self.current_stamina,
            "max_stamina": self.max_stamina,
            "status_effects": {k: v for k, v in self.status_effects.items()},
            "initiative": self.initiative,
            "position": self.position,
            "is_active_in_combat": self.is_active_in_combat,
            "description": self.description
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CombatEntity':
        """Create a CombatEntity from a dictionary."""
        stats = {}
        for k, v in data.get("stats", {}).items():
            try:
                stat_key = StatType.from_string(k)
            except ValueError:
                try:
                    stat_key = DerivedStatType.from_string(k)
                except ValueError:
                    stat_key = k
            stats[stat_key] = v

        # Handle potential missing combat_name during deserialization
        combat_name = data.get("combat_name", data.get("name", "Unknown")) # Fallback to name

        return cls(
            id=data["id"],
            name=data["name"],
            combat_name=combat_name, # <--- ADDED
            entity_type=EntityType[data["entity_type"]],
            stats=stats,
            current_hp=data["current_hp"],
            max_hp=data["max_hp"],
            current_mp=data.get("current_mp", 0),
            max_mp=data.get("max_mp", 0),
            current_stamina=data.get("current_stamina", 0),
            max_stamina=data.get("max_stamina", 0),
            status_effects=data.get("status_effects", {}) if isinstance(data.get("status_effects"), dict) else {effect: None for effect in data.get("status_effects", [])},
            initiative=data.get("initiative", 0),
            position=data.get("position", 0),
            description=data.get("description", ""),
            is_active_in_combat=data.get("is_active_in_combat", True) 
        )

```

### File: core\combat\combat_manager.py

```python
import random
import logging
import uuid
from typing import Dict, List, Tuple, Any, Optional, Set, Union, TYPE_CHECKING
from PySide6.QtCore import QTimer
from core.agents.base_agent import AgentContext
from core.base.state.state_manager import get_state_manager
from core.interaction.context_builder import ContextBuilder
from core.interaction.enums import InteractionMode
from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
from core.stats.combat_effects import StatusEffect, StatusEffectType
from core.stats.derived_stats import get_modifier_from_stat
from core.stats.modifier import ModifierSource
from core.stats.stats_base import StatType, DerivedStatType
from core.utils.dice import roll_dice_notation, check_success, roll_critical
from core.combat.combat_entity import CombatEntity, EntityType
from core.combat.combat_action import AttackAction, CombatAction, ActionType, DefendAction, FleeAction, SpellAction
from core.stats.stats_manager import StatsManager, get_stats_manager 
from core.inventory import get_inventory_manager
from .enums import CombatState, CombatStep
from .action_handlers import (
    _handle_attack_action,
    _handle_spell_action,
    _handle_defend_action,
    _handle_item_action,
    _handle_flee_action_mechanics
)

if TYPE_CHECKING:
    from core.base.engine import GameEngine # For process_combat_step

logger = logging.getLogger(__name__)


class CombatManager:
    def __init__(self):
        """Initialize a new combat manager."""
        self.id = str(uuid.uuid4())
        self.entities: Dict[str, CombatEntity] = {}
        self.turn_order: List[str] = []
        self.current_turn_index: int = 0
        self.round_number: int = 0
        self.state: CombatState = CombatState.NOT_STARTED 
        self.current_step: CombatStep = CombatStep.NOT_STARTED 
        self.combat_log: List[str] = [] # Raw chronological log for debugging/internal history
        self.display_log_html: str = "" # HTML snapshot of Combat Log for instant rehydrate
        self.last_action_results: Dict[str, Any] = {} 

        self._player_entity_id: Optional[str] = None
        self._enemy_entity_ids: List[str] = []
        self._surprise_attack: bool = False
        self._is_surprise_round: bool = False # Retained for surprise round logic differentiation
        self._initiating_intent: Optional[str] = None
        self._pending_action: Optional[CombatAction] = None
        self._last_action_result_detail: Optional[Dict] = None 
        self._current_intent: Optional[str] = None
        self._active_entity_id: Optional[str] = None 
        self._surprise_round_entities: List[str] = [] # Retained for surprise round actor selection

        # --- ECFA Change: Flag for orchestrator control ---
        self.waiting_for_display_completion: bool = False
        # --- End ECFA Change ---

    def start_combat(self, player_entity: CombatEntity, enemy_entities: List[CombatEntity]) -> None:
        self.entities = {}
        self.turn_order = []
        self.current_turn_index = 0
        self.round_number = 0
        self.state = CombatState.NOT_STARTED
        self.combat_log = []
        self.last_action_results = {}
        self._surprise_round_entities = []
        self._is_surprise_round = False

        if not hasattr(player_entity, 'combat_name') or not player_entity.combat_name:
            logger.error(f"Player entity missing combat_name: {player_entity.name}")
            player_entity.combat_name = player_entity.name
        self.entities[player_entity.id] = player_entity

        for enemy in enemy_entities:
            if not hasattr(enemy, 'combat_name') or not enemy.combat_name:
                logger.error(f"Enemy entity missing combat_name: {enemy.name}")
                enemy.combat_name = enemy.name
            self.entities[enemy.id] = enemy
            logger.info(f"Added entity to combat: {enemy.name} (Combat Name: {enemy.combat_name}, ID: {enemy.id})")

        self._determine_initiative()

        self.state = CombatState.IN_PROGRESS
        self.round_number = 1

        enemy_combat_names = ", ".join(e.combat_name for e in enemy_entities)
        self._add_to_log(f"Combat started! {player_entity.combat_name} vs {enemy_combat_names}")

        surprised_entity_ids = [eid for eid, entity in self.entities.items() if entity.has_status_effect("Surprised")]

        if surprised_entity_ids:
            self._add_to_log("Surprise Round!")
            logger.info(f"Surprise round initiated. Surprised entities: {surprised_entity_ids}")

            non_surprised_entity_ids = [eid for eid in self.turn_order if eid not in surprised_entity_ids]

            if non_surprised_entity_ids:
                surprise_turn_order = [eid for eid in self.turn_order if eid in non_surprised_entity_ids]
                self._add_to_log("Entities acting in the surprise round:")
                self._add_to_log(", ".join(self.entities[eid].combat_name for eid in surprise_turn_order))
                self._is_surprise_round = True
                self._surprise_round_entities = surprise_turn_order
                self.current_turn_index = 0
                logger.info(f"Surprise round activated with {len(surprise_turn_order)} entities: {surprise_turn_order}")
                self._add_to_log("Processing surprise round actions...")
                logger.debug("Surprise round setup complete. Main loop will process turns.")
            else:
                self._add_to_log("No entities are able to act in the surprise round.")
                self._end_surprise_round()
        else:
            self.round_number = 1
            self.current_turn_index = 0
            self._add_to_log(f"Round {self.round_number} begins!")
            self._log_turn_order()

    def process_combat_step(self, engine): # Engine is received here
        """Processes the current step and triggers the next one if appropriate."""
        # Guard: ignore callbacks on an inactive/old manager (e.g., after New Game)
        try:
            state_manager = getattr(engine, '_state_manager', None)
            current_state = state_manager.current_state if state_manager else None
            active_cm = getattr(current_state, 'combat_manager', None) if current_state else None
            if active_cm is not self:
                logger.info("CombatManager.process_combat_step invoked on inactive manager. Ignoring callback.")
                return
        except Exception:
            # If we cannot verify, proceed cautiously
            pass
        
        max_steps = 20 
        steps_processed = 0
        while steps_processed < max_steps:
            steps_processed += 1
            current_step_before_processing = self.current_step

            if self.state != CombatState.IN_PROGRESS and self.current_step not in [CombatStep.ENDING_COMBAT, CombatStep.COMBAT_ENDED]:
                logger.warning(f"Combat state changed to {self.state.name} during step processing. Stopping.")
                if self.current_step != CombatStep.ENDING_COMBAT:
                    self.current_step = CombatStep.ENDING_COMBAT 
                if self.current_step == CombatStep.ENDING_COMBAT: self._step_ending_combat(engine) # Pass engine
                break 

            if self.current_step in [CombatStep.AWAITING_PLAYER_INPUT, CombatStep.COMBAT_ENDED, CombatStep.NOT_STARTED, CombatStep.AWAITING_TRANSITION_DATA]:
                logger.debug(f"Stopping step processing loop at step: {self.current_step.name}")
                # If orchestrator is idle and CM was waiting, it should have been resumed by orchestrator.
                # If CM is now at AWAITING_PLAYER_INPUT, it's genuinely waiting.
                break 

            # --- ECFA Change: Ensure orchestrator is set on engine for step handlers ---
            if not hasattr(engine, '_combat_orchestrator'):
                logger.critical("CRITICAL: GameEngine instance in CombatManager does not have _combat_orchestrator. Aborting combat.")
                self.end_combat("Internal Engine Error: Orchestrator missing.")
                self.current_step = CombatStep.COMBAT_ENDED
                break
            # --- End ECFA Change ---

            try:
                logger.debug(f"Processing Combat Step: {self.current_step.name} (Loop Iteration: {steps_processed})")

                step_handlers = {
                    CombatStep.STARTING_COMBAT: self._step_starting_combat,
                    CombatStep.HANDLING_SURPRISE_CHECK: self._step_handling_surprise_check,
                    CombatStep.PERFORMING_SURPRISE_ATTACK: self._step_performing_surprise_attack,
                    CombatStep.NARRATING_SURPRISE_OUTCOME: self._step_narrating_surprise_outcome,
                    CombatStep.ENDING_SURPRISE_ROUND: self._step_ending_surprise_round,
                    CombatStep.ROLLING_INITIATIVE: self._step_rolling_initiative,
                    CombatStep.STARTING_ROUND: self._step_starting_round,
                    CombatStep.PROCESSING_PLAYER_ACTION: self._step_processing_player_action,
                    CombatStep.AWAITING_NPC_INTENT: self._step_awaiting_npc_intent,
                    CombatStep.PROCESSING_NPC_ACTION: self._step_processing_npc_action,
                    CombatStep.RESOLVING_ACTION_MECHANICS: self._step_resolving_action_mechanics,
                    CombatStep.NARRATING_ACTION_OUTCOME: self._step_narrating_action_outcome,
                    CombatStep.APPLYING_STATUS_EFFECTS: self._step_applying_status_effects,
                    CombatStep.ADVANCING_TURN: self._step_advancing_turn,
                    CombatStep.ENDING_COMBAT: self._step_ending_combat,
                }

                handler = step_handlers.get(self.current_step)

                if handler:
                    # --- ECFA Change: Pass engine to handlers that need it ---
                    # Most handlers will now need `engine` to access `_combat_orchestrator`
                    # We can inspect handler signature or just pass it if common.
                    # For simplicity, let's update handlers to accept `engine` if they interact with orchestrator.
                    
                    # Determine if handler needs engine (could be more sophisticated)
                    # For now, assume all step handlers might need it or are refactored to accept it.
                    handler(engine) # Pass engine to all step handlers
                    # --- End ECFA Change ---

                    # If the handler set waiting_for_display_completion, break the loop
                    if self.waiting_for_display_completion:
                        logger.debug(f"Step {current_step_before_processing.name} set waiting_for_display_completion. Pausing CM.")
                        break 
                elif self.current_step not in [CombatStep.NOT_STARTED, CombatStep.AWAITING_TRANSITION_DATA, CombatStep.COMBAT_ENDED, CombatStep.AWAITING_PLAYER_INPUT]:
                    logger.warning(f"No handler defined for combat step: {self.current_step.name}")
                    break

                if self.current_step == current_step_before_processing and not self.waiting_for_display_completion:
                    logger.error(f"Combat step {self.current_step.name} did not transition state or set wait flag. Breaking loop.")
                    # This is a safeguard. If a step runs, doesn't queue events (so waiting_for_display is false),
                    # and doesn't change current_step, it's an infinite loop.
                    break

            except Exception as e:
                logger.exception(f"Error processing combat step {self.current_step.name}: {e}")
                # Try to queue an error message via orchestrator if available
                if hasattr(engine, '_combat_orchestrator'):
                    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                    err_event = DisplayEvent(
                        type=DisplayEventType.SYSTEM_MESSAGE,
                        content=f"System Error during {self.current_step.name}: {e}",
                        target_display=DisplayTarget.COMBAT_LOG
                    )
                    engine._combat_orchestrator.add_event_to_queue(err_event)
                self.end_combat(f"Error during step {self.current_step.name}: {e}")
                self.current_step = CombatStep.COMBAT_ENDED # Ensure it stops
                break 
        else: 
            if steps_processed >= max_steps:
                logger.error(f"Exceeded maximum combat steps ({max_steps}). Forcing combat end.")
                self.end_combat("Error: Combat processing limit exceeded.")
                self.current_step = CombatStep.COMBAT_ENDED

    def _step_starting_combat(self, engine):
        """Handles the initial combat announcement AND THEN decides the next step."""
        if not hasattr(engine, '_combat_orchestrator'): 
            logger.error("CombatOutputOrchestrator not found on engine in _step_starting_combat.")
            self.end_combat("Internal error: Orchestrator unavailable.")
            self.current_step = CombatStep.COMBAT_ENDED
            return

        # This method will now execute its full logic in one go.
        # It queues its message, then determines the next step, then sets the wait flag.
        
        player = self.entities.get(self._player_entity_id)
        enemies = [self.entities[eid] for eid in self._enemy_entity_ids if eid in self.entities]
        enemy_names_display = ', '.join(e.combat_name for e in enemies)
        player_name_display = player.combat_name if player else "Player"

        start_msg = f"Combat started! {player_name_display} vs {enemy_names_display}"
        self._add_to_log(start_msg) 

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
        event = DisplayEvent(
            type=DisplayEventType.SYSTEM_MESSAGE,
            content=start_msg,
            target_display=DisplayTarget.COMBAT_LOG,
            gradual_visual_display=False, tts_eligible=False,
            source_step=self.current_step.name # Current step is STARTING_COMBAT
        )
        engine._combat_orchestrator.add_event_to_queue(event)
        
        # Now, determine the *actual next game step*
        if self._surprise_attack:
            logger.info("Surprise attack indicated. Next actual game step: HANDLING_SURPRISE_CHECK.")
            self.current_step = CombatStep.HANDLING_SURPRISE_CHECK
        else:
            logger.info("No surprise attack. Next actual game step: ROLLING_INITIATIVE.")
            self.current_step = CombatStep.ROLLING_INITIATIVE
            
        # Pause for the "Combat Started!" message to display.
        # When process_combat_step resumes, it will pick up the new current_step.
        self.waiting_for_display_completion = True

    def _step_handling_surprise_check(self, engine):
        """Determines surprise effects, queues messages, sets up surprise action, sets next step, then pauses."""
        if not hasattr(engine, '_combat_orchestrator') or not hasattr(engine, '_combat_narrator_agent'):
            logger.error("Orchestrator or CombatNarratorAgent not found on engine in _step_handling_surprise_check.")
            self.end_combat("Internal error: Core components unavailable for surprise check.")
            self.current_step = CombatStep.COMBAT_ENDED
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        from core.interaction.context_builder import ContextBuilder
        from core.agents.base_agent import AgentContext

        attacker = self.entities.get(self._player_entity_id)
        if not attacker:
            logger.error("Cannot handle surprise: Attacker (player) not found.")
            self.current_step = CombatStep.ROLLING_INITIATIVE 
            self.waiting_for_display_completion = False 
            return

        targets = [self.entities.get(eid) for eid in self._enemy_entity_ids if self.entities.get(eid) and self.entities.get(eid).is_alive()]

        if not targets:
            logger.info("No valid enemy targets for surprise attack. Ending surprise sequence.")
            self.current_step = CombatStep.ENDING_SURPRISE_ROUND
            self.waiting_for_display_completion = False
            if not engine._combat_orchestrator.is_processing_event and not engine._combat_orchestrator.event_queue:
                QTimer.singleShot(0, lambda: self.process_combat_step(engine))
            return

        surprised_target_names = []
        for target_entity in targets:
            if not target_entity: continue
            target_stats_manager = self._get_entity_stats_manager(target_entity.id)
            if target_stats_manager:
                surprise_effect = StatusEffect(name="Surprised", description="Caught off guard", effect_type=StatusEffectType.DEBUFF, duration=1)
                target_stats_manager.add_status_effect(surprise_effect)
                target_entity.add_status_effect("Surprised", duration=1) 
                surprised_target_names.append(target_entity.combat_name)

        if not self._is_surprise_round: self._is_surprise_round = True # Should be true if surprise_attack was true
        # _surprise_round_entities for CM's internal logic (who *can* act)
        # This should be only non-surprised entities IF enemies attack first by surprise.
        # For player surprise, only player acts.
        self._surprise_round_entities = [attacker.id] # Player is the one acting in surprise

        event_round_msg = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content="Round 1 (Surprise Attack!)", target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name)
        engine._combat_orchestrator.add_event_to_queue(event_round_msg)

        if surprised_target_names:
            event_surprised_targets = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=f"Targets Surprised: {', '.join(surprised_target_names)}", target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name)
            engine._combat_orchestrator.add_event_to_queue(event_surprised_targets)
        else:
            event_no_surprise = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content="No targets were successfully surprised.", target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name)
            engine._combat_orchestrator.add_event_to_queue(event_no_surprise)
        
        self._active_entity_id = attacker.id 
        self._pending_action = None 

        # Queue TURN_ORDER_UPDATE for surprise round. This will be handled by _set_next_actor_step
        # after the initial messages are processed.
        # _set_next_actor_step is called via perform_action or advancing turn.
        # For surprise, we will call _set_next_actor_step(attacker.id) before PROCESSING_PLAYER_ACTION effectively.

        if "attack" in self._initiating_intent.lower() and targets: 
            target_to_attack = targets[0] 
            self._pending_action = AttackAction(
                performer_id=attacker.id, target_id=target_to_attack.id,
                weapon_name="surprise attack", dice_notation="1d6" 
            )
            self._add_to_log(f"[INTERNAL] Pending surprise action: {self._pending_action.name} on {target_to_attack.combat_name}")

            game_state = engine._state_manager.current_state
            if not game_state:
                logger.error("GameState not found for surprise narrative.")
                self.current_step = CombatStep.ENDING_SURPRISE_ROUND 
                self.waiting_for_display_completion = True 
                return

            context_builder = ContextBuilder() 
            agent_call_context_dict = context_builder.build_context(game_state, InteractionMode.COMBAT, actor_id=attacker.id)
            narrator_input_for_surprise = (
                f"[System Event: Surprise Attack Attempt]\nActor: '{attacker.combat_name}'\n"
                f"Target: '{target_to_attack.combat_name}' (Status: Surprised)\nOriginal Intent: '{self._initiating_intent}'\n"
                f"Action: Attempting a surprise attack.\nDescribe the attacker's initial move and the target's "
                f"unawareness leading up to the strike. Focus on the *attempt*, not the outcome."
            )
            agent_context_for_narrator = AgentContext(
                game_state=agent_call_context_dict, player_state=agent_call_context_dict.get('player',{}), 
                world_state=agent_call_context_dict.get('world',{}), player_input=narrator_input_for_surprise,
                conversation_history=game_state.conversation_history if game_state else [], additional_context=agent_call_context_dict
            )
            attempt_narrative = f"{attacker.combat_name} launches a swift surprise attack on {target_to_attack.combat_name}!" 
            try:
                narrator_output = engine._combat_narrator_agent.process(agent_context_for_narrator)
                if narrator_output and narrator_output.get("narrative"): attempt_narrative = narrator_output["narrative"]
            except Exception as e: logger.error(f"Error getting surprise attempt narrative: {e}", exc_info=True)
            
            event_attempt_narrative = DisplayEvent(type=DisplayEventType.NARRATIVE_ATTEMPT, content=attempt_narrative, role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name)
            engine._combat_orchestrator.add_event_to_queue(event_attempt_narrative)
            # This will call _set_next_actor_step which queues the TURN_ORDER_UPDATE for surprise
            self._set_next_actor_step(attacker.id) # Ensure correct step (PROCESSING_PLAYER_ACTION for surprise)
            self.current_step = CombatStep.PERFORMING_SURPRISE_ATTACK # Correct target step for surprise action
        else: 
            no_action_narrative = f"{attacker.combat_name} looks for an opening, but the moment for a surprise attack passes."
            event_no_action = DisplayEvent(type=DisplayEventType.NARRATIVE_GENERAL, content=no_action_narrative, role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name)
            engine._combat_orchestrator.add_event_to_queue(event_no_action)
            self._pending_action = None 
            self.current_step = CombatStep.ENDING_SURPRISE_ROUND
            
        self.waiting_for_display_completion = True

    def _step_performing_surprise_attack(self, engine): # Added engine parameter
        """
        Initiates the processing of the pending surprise attack action by calling self.perform_action.
        The perform_action method (and its called handlers) will queue all necessary 
        DisplayEvents for rolls, UI updates, and system messages.
        """
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_performing_surprise_attack.")
            self.current_step = CombatStep.ENDING_SURPRISE_ROUND
            self.waiting_for_display_completion = False 
            # QTimer.singleShot(0, lambda: self.process_combat_step(engine)) # No need if loop continues
            return

        if not self._pending_action:
            logger.error("No pending action found for surprise attack step.")
            self.current_step = CombatStep.ENDING_SURPRISE_ROUND
            self.waiting_for_display_completion = False 
            # QTimer.singleShot(0, lambda: self.process_combat_step(engine))
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget # Local import

        action_to_process = self._pending_action
        # self._pending_action = None # Clear this LATER, after perform_action and narration

        logger.info(f"Initiating surprise action mechanics for: {action_to_process.name}")

        # Call perform_action. It will handle all sub-steps of mechanics execution
        # and queueing display events. _last_action_result_detail will be set within perform_action.
        action_execution_summary = self.perform_action(action_to_process, engine)

        # Check if perform_action itself failed catastrophically or didn't queue anything
        # unexpectedly (though it should always queue something, even a failure message).
        if not action_execution_summary.get("queued_events", False) and not action_execution_summary.get("success", False):
            logger.warning(f"perform_action for surprise attack {action_to_process.name} did not queue events and reported failure. "
                           f"Message: {action_execution_summary.get('message')}")
            # Ensure a generic failure message is shown if perform_action didn't.
            # This is a fallback.
            if not engine._combat_orchestrator.event_queue: # Check if queue is truly empty
                fail_msg = self._last_action_result_detail.get("message") if self._last_action_result_detail else f"Surprise attack {action_to_process.name} by {self.entities[action_to_process.performer_id].combat_name} could not be resolved."
                event_action_fail = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=fail_msg, target_display=DisplayTarget.COMBAT_LOG)
                engine._combat_orchestrator.add_event_to_queue(event_action_fail)
        
        # The actual outcome (hit/miss/damage) is in self._last_action_result_detail,
        # which was updated by perform_action (via its call to the specific action handler).
        
        # Regardless of the mechanical success/failure, we move to narrate the outcome.
        # The NARRATING step will use self._last_action_result_detail.
        self.current_step = CombatStep.NARRATING_SURPRISE_OUTCOME
        
        # We must pause here to let the orchestrator display all events queued by perform_action.
        self.waiting_for_display_completion = True

    def _step_narrating_surprise_outcome(self, engine):
        """Generates and outputs the narrative description of the surprise attack's outcome, then sets next step."""
        if not hasattr(engine, '_combat_orchestrator') or not hasattr(engine, '_combat_narrator_agent'):
            logger.error("Orchestrator or CombatNarratorAgent not found in _step_narrating_surprise_outcome.")
            self.current_step = CombatStep.ENDING_SURPRISE_ROUND
            self.waiting_for_display_completion = False
            return

        if not self._last_action_result_detail:
            logger.warning("No action result found to narrate surprise outcome. Skipping narration.")
            self.current_step = CombatStep.ENDING_SURPRISE_ROUND
            self.waiting_for_display_completion = False # No event queued for this path
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        logger.info("Generating narrative for surprise attack outcome.")

        outcome_narrative = None
        # ... (logic to get outcome_narrative from LLM or placeholder, as before) ...
        agent_failed = False
        try:
            outcome_narrative = engine._combat_narrator_agent.narrate_outcome(self._last_action_result_detail, self)
            if not outcome_narrative: agent_failed = True
        except Exception as e: logger.error(f"Error calling narrate_outcome for surprise: {e}", exc_info=True); agent_failed = True
        if agent_failed:
            result = self._last_action_result_detail
            performer_name = result.get("performer_name", "Attacker")
            target_name = result.get("target_name", "Target")
            if result.get("success"):
                damage = result.get("damage", 0)
                outcome_narrative = f"The surprise attack by {performer_name} connects against {target_name}, dealing {damage:.0f} damage."
                if result.get("target_defeated"): outcome_narrative += f" {target_name} is defeated!"
            else: outcome_narrative = f"Despite the surprise, {performer_name}'s attack on {target_name} misses!"
        # --- End outcome_narrative generation ---

        if outcome_narrative:
            event_outcome_narrative = DisplayEvent(
                type=DisplayEventType.NARRATIVE_IMPACT, content=outcome_narrative,
                role="gm", tts_eligible=True, gradual_visual_display=True,
                target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name
            )
            engine._combat_orchestrator.add_event_to_queue(event_outcome_narrative)
            self.waiting_for_display_completion = True
        else: # Should not happen if placeholder is good
            self.waiting_for_display_completion = False

        self._last_action_result_detail = None # Clear after use
        self.current_step = CombatStep.ENDING_SURPRISE_ROUND # Always go to this step after narration (or lack thereof)

    def _step_ending_surprise_round(self, engine):
        """Cleans up surprise status, queues message, sets next step to ROLLING_INITIATIVE, then pauses."""
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_ending_surprise_round.")
            self.current_step = CombatStep.ROLLING_INITIATIVE 
            self.waiting_for_display_completion = False
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
        
        self._add_to_log("Surprise round ends.") 
        event_surprise_end = DisplayEvent(
            type=DisplayEventType.SYSTEM_MESSAGE, content="Surprise round ends.",
            target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name
        )
        engine._combat_orchestrator.add_event_to_queue(event_surprise_end)

        for entity_id in list(self.entities.keys()): 
            entity = self.entities.get(entity_id)
            if entity and entity.has_status_effect("Surprised"):
                stats_manager = self._get_entity_stats_manager(entity_id)
                if stats_manager:
                    stats_manager.status_effect_manager.remove_effects_by_name("Surprised")
                entity.remove_status_effect("Surprised") 
                logger.debug(f"Removed Surprised status from {entity.combat_name}")

        self._surprise_attack = False 
        self._initiating_intent = None 
        self._is_surprise_round = False # Explicitly set to False
        
        self.current_step = CombatStep.ROLLING_INITIATIVE 
        self.waiting_for_display_completion = True 

    def _step_rolling_initiative(self, engine):
        """Rolls initiative, queues messages, sets next step to STARTING_ROUND, then pauses if messages were queued."""
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_rolling_initiative.")
            self.end_combat("Internal error: Orchestrator unavailable for initiative.")
            self.current_step = CombatStep.COMBAT_ENDED
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget

        events_queued_this_pass = False
        if not self.turn_order: # Only roll if not already determined
            initiative_values = [] 
            for entity_id, entity in self.entities.items():
                if not entity.is_alive() or not getattr(entity, 'is_active_in_combat', True): continue
                base_initiative = entity.get_stat(DerivedStatType.INITIATIVE)
                roll = random.randint(1, 6)
                total_initiative = base_initiative + roll
                entity.initiative = total_initiative
                initiative_values.append((entity_id, total_initiative))
                roll_detail_msg = f"{entity.combat_name} rolls initiative: {total_initiative:.0f} (Base:{base_initiative:.0f} + Roll:{roll})"
                self._add_to_log(roll_detail_msg) 
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=roll_detail_msg, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name))
                events_queued_this_pass = True

            initiative_values.sort(key=lambda x: x[1], reverse=True)
            self.turn_order = [entity_id for entity_id, _ in initiative_values]
            self.current_turn_index = 0 # Reset for new turn order
            
            # Note: Turn order string is queued by _step_starting_round now for better flow.
        else:
            logger.debug("Initiative already determined.")

        self.round_number = 0 # Initialize for the first regular round
        self.current_turn_index = -1 # Will be set by _step_starting_round
        self.current_step = CombatStep.STARTING_ROUND
        
        if events_queued_this_pass:
            self.waiting_for_display_completion = True
        else:
            self.waiting_for_display_completion = False # No new messages, proceed

    def _step_starting_round(self, engine):
        """Increments round, queues messages, sets first actor step, then pauses."""
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_starting_round.")
            self.end_combat("Internal error: Orchestrator unavailable for round start.")
            self.current_step = CombatStep.COMBAT_ENDED
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        
        self.round_number += 1
        round_start_msg = f"Round {self.round_number} begins!"
        self._add_to_log(round_start_msg) 
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=round_start_msg, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name))

        if not self.turn_order:
            logger.error("Cannot start round: Turn order is empty. This should have been set by _step_rolling_initiative.")
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content="System Error: Turn order missing for round start.", target_display=DisplayTarget.COMBAT_LOG))
            self.end_combat("Error: Turn order missing.")
            self.current_step = CombatStep.ENDING_COMBAT
            self.waiting_for_display_completion = True 
            return
            
        turn_order_log_msg = "Turn order: " + ", ".join(self.entities[eid].combat_name for eid in self.turn_order if eid in self.entities and self.entities[eid].is_alive() and getattr(self.entities[eid], 'is_active_in_combat', True))
        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=turn_order_log_msg, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name + "_order_display"))
            
        first_actor_this_round_id = None
        first_actor_index_this_round = -1
        for i, entity_id_in_order in enumerate(self.turn_order):
            entity = self.entities.get(entity_id_in_order)
            if entity and entity.is_alive() and getattr(entity, 'is_active_in_combat', True):
                if first_actor_this_round_id is None: 
                    first_actor_this_round_id = entity_id_in_order
                    first_actor_index_this_round = i
        
        if first_actor_this_round_id:
            self.current_turn_index = first_actor_index_this_round 
            self._active_entity_id = first_actor_this_round_id
            logger.info(f"Round {self.round_number}. First active entity identified: {self.entities[self._active_entity_id].combat_name}")
            self._set_next_actor_step(self._active_entity_id, engine) # Pass engine here
        else:
            logger.warning("No active entities found to start the round. Ending combat.")
            self._check_combat_state() 
            if self.state == CombatState.IN_PROGRESS: self.end_combat("No active combatants to start round.")
            self.current_step = CombatStep.ENDING_COMBAT
        
        self.waiting_for_display_completion = True
    def receive_player_action(self, engine: 'GameEngine', intent: str):
        if self.current_step != CombatStep.AWAITING_PLAYER_INPUT:
            logger.warning(f"Received player action intent '{intent[:50]}...' but current step is {self.current_step}. Ignoring.")
            return
        logger.info(f"Player action intent received: '{intent}'")
        self._current_intent = intent
        self.current_step = CombatStep.PROCESSING_PLAYER_ACTION
        self.process_combat_step(engine)

    def prepare_for_combat(self, player_entity: CombatEntity, enemy_entities: List[CombatEntity], surprise: bool, initiating_intent: str):
        logger.info(f"Preparing for combat. Surprise: {surprise}. Intent: '{initiating_intent[:50]}...'")
        self.entities = {}
        self.turn_order = []
        self.current_turn_index = 0
        self.round_number = 0
        self.state = CombatState.NOT_STARTED # Will be set to IN_PROGRESS after sync
        self.combat_log = []
        self.last_action_results = {}
        self._pending_action = None
        self._last_action_result_detail = None
        self._current_intent = None
        self._active_entity_id = None
        self._surprise_attack = surprise
        self._initiating_intent = initiating_intent
        self._is_surprise_round = False # Initialize
        self._surprise_round_entities = [] # Initialize

        if not hasattr(player_entity, 'combat_name') or not player_entity.combat_name:
            logger.error(f"Player entity missing combat_name: {player_entity.name}")
            player_entity.combat_name = player_entity.name # Fallback
        self.entities[player_entity.id] = player_entity
        self._player_entity_id = player_entity.id
        
        self._enemy_entity_ids = []
        for enemy in enemy_entities:
            if not hasattr(enemy, 'combat_name') or not enemy.combat_name:
                logger.error(f"Enemy entity missing combat_name: {enemy.name}")
                enemy.combat_name = enemy.name # Fallback
            self.entities[enemy.id] = enemy
            self._enemy_entity_ids.append(enemy.id)
            logger.info(f"Added entity to combat prep: {enemy.name} (Combat Name: {enemy.combat_name}, ID: {enemy.id})")

        # Explicitly sync CombatEntity fields with their StatsManagers
        for entity_id, combat_entity_obj in self.entities.items():
            entity_stats_manager = self._get_entity_stats_manager(entity_id)
            if entity_stats_manager:
                try:
                    combat_entity_obj.max_hp = entity_stats_manager.get_stat_value(DerivedStatType.MAX_HEALTH)
                    combat_entity_obj.current_hp = entity_stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                    
                    combat_entity_obj.max_stamina = entity_stats_manager.get_stat_value(DerivedStatType.MAX_STAMINA)
                    combat_entity_obj.current_stamina = entity_stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                    
                    combat_entity_obj.max_mp = entity_stats_manager.get_stat_value(DerivedStatType.MAX_MANA)
                    combat_entity_obj.current_mp = entity_stats_manager.get_current_stat_value(DerivedStatType.MANA)
                    
                    combat_entity_obj.initiative = entity_stats_manager.get_stat_value(DerivedStatType.INITIATIVE) # Sync initiative base
                    
                    # Sync status effects from StatsManager to CombatEntity's simple dict
                    # This ensures CombatEntity.status_effects (Dict[str, Optional[int]]) is up-to-date
                    # for display purposes and simple checks, while StatsManager.status_effect_manager
                    # holds the full StatusEffect objects.
                    combat_entity_obj.status_effects.clear()
                    active_stat_effects = entity_stats_manager.status_effect_manager.active_effects
                    for effect_id, status_effect_obj in active_stat_effects.items():
                        combat_entity_obj.add_status_effect(status_effect_obj.name, status_effect_obj.duration)

                    logger.debug(f"Synced CombatEntity {combat_entity_obj.combat_name} with its StatsManager: "
                                f"HP: {combat_entity_obj.current_hp}/{combat_entity_obj.max_hp}, "
                                f"Stamina: {combat_entity_obj.current_stamina}/{combat_entity_obj.max_stamina}, "
                                f"MP: {combat_entity_obj.current_mp}/{combat_entity_obj.max_mp}, "
                                f"Status: {list(combat_entity_obj.status_effects.keys())}")
                except Exception as e:
                    logger.error(f"Error syncing CombatEntity {entity_id} with its StatsManager in prepare_for_combat: {e}", exc_info=True)
            else:
                logger.warning(f"Could not find StatsManager for entity {entity_id} during combat prep sync.")
        
        if self._surprise_attack and self._player_entity_id:
            # For player-initiated surprise, player is the one acting
            self._is_surprise_round = True
            self._surprise_round_entities = [self._player_entity_id]
            # Enemies would get "Surprised" status in _step_handling_surprise_check

        self.state = CombatState.IN_PROGRESS
        self.current_step = CombatStep.STARTING_COMBAT
        logger.info("CombatManager prepared. Next step: STARTING_COMBAT.")

    def _determine_initiative(self) -> None:
        initiative_rolls = []
        for entity_id, entity in self.entities.items():
            base_initiative = entity.get_stat(DerivedStatType.INITIATIVE)
            roll = random.randint(1, 6)
            total_initiative = base_initiative + roll
            entity.initiative = total_initiative
            initiative_rolls.append((entity_id, total_initiative))
            self._add_to_log(f"{entity.name} rolled initiative: {total_initiative} ({base_initiative} + {roll})")
        initiative_rolls.sort(key=lambda x: x[1], reverse=True)
        self.turn_order = [entity_id for entity_id, _ in initiative_rolls]
        self.current_turn_index = 0

    def _log_turn_order(self) -> None:
        turn_order_str = "Turn order: "
        turn_order_str += ", ".join(self.entities[entity_id].combat_name for entity_id in self.turn_order if entity_id in self.entities)
        self._add_to_log(turn_order_str)

    def get_current_entity(self) -> Optional[CombatEntity]:
        if self.state != CombatState.IN_PROGRESS: return None
        if self._is_surprise_round:
            if self._active_entity_id: return self.entities.get(self._active_entity_id)
            else: logger.warning("In surprise round but _active_entity_id is not set."); return None
        elif self.turn_order and self.current_turn_index < len(self.turn_order):
            entity_id = self.turn_order[self.current_turn_index]
            if entity_id != self._active_entity_id:
                logger.warning(f"Mismatch between turn order index ({self.current_turn_index} -> {entity_id}) and active entity ({self._active_entity_id}). Using turn order.")
                self._active_entity_id = entity_id
            return self.entities.get(entity_id)
        elif self._active_entity_id:
            logger.warning("Turn order invalid, but _active_entity_id is set. Returning entity based on active ID.")
            return self.entities.get(self._active_entity_id)
        logger.debug("No current entity could be determined.")
        return None

    def get_current_entity_id(self) -> Optional[str]:
        return self._active_entity_id

    def is_player_turn(self) -> bool:
        current_entity = self.get_current_entity()
        return current_entity is not None and current_entity.entity_type == EntityType.PLAYER

    def _calculate_stamina_cost(self, action: CombatAction, performer: CombatEntity) -> Tuple[float, List[str]]:
        cost_details = []
        from core.stats.derived_stats import get_modifier_from_stat
        base_cost = 0.0
        if action.action_type == ActionType.ATTACK: base_cost = 5.0
        elif action.action_type == ActionType.SPELL: base_cost = 2.0
        elif action.action_type == ActionType.SKILL: base_cost = 10.0
        elif action.action_type == ActionType.DEFEND: base_cost = 3.0
        elif action.action_type == ActionType.MOVE: base_cost = 2.0
        elif action.action_type == ActionType.FLEE: base_cost = 8.0
        base_cost = action.cost_stamina if action.cost_stamina > 0 else base_cost
        cost_details.append(f"Base Cost: {base_cost}")
        con_mod = 0
        try:
            con_value = performer.get_stat(StatType.CONSTITUTION)
            con_mod = get_modifier_from_stat(con_value)
            base_cost -= con_mod
            cost_details.append(f"CON Mod: {-con_mod}")
        except Exception as e: logger.warning(f"Could not get CON modifier for stamina cost: {e}")
        encumbrance_multiplier = 1.0
        try:
            inventory_manager = get_inventory_manager()
            current_weight = inventory_manager.get_current_weight()
            max_carry_capacity = performer.get_stat(DerivedStatType.CARRY_CAPACITY)
            if max_carry_capacity > 0:
                encumbrance_percent = (current_weight / max_carry_capacity) * 100
                if encumbrance_percent > 100: encumbrance_multiplier = 2.0; cost_details.append("Encumbrance: Over (>100%, x2.0)")
                elif encumbrance_percent > 75: encumbrance_multiplier = 1.5; cost_details.append(f"Encumbrance: Heavy ({encumbrance_percent:.0f}%, x1.5)")
                elif encumbrance_percent > 50: encumbrance_multiplier = 1.25; cost_details.append(f"Encumbrance: Medium ({encumbrance_percent:.0f}%, x1.25)")
                else: cost_details.append(f"Encumbrance: Light ({encumbrance_percent:.0f}%, x1.0)")
            else: cost_details.append("Encumbrance: N/A (Max Capacity 0)")
        except Exception as e: logger.warning(f"Could not calculate encumbrance modifier: {e}"); cost_details.append("Encumbrance: Error")
        status_multiplier = 1.0
        if performer.has_status_effect("Fatigued"): status_multiplier = 1.5; cost_details.append("Status: Fatigued (x1.5)")
        if performer.has_status_effect("Energized"): status_multiplier = 0.75; cost_details.append("Status: Energized (x0.75)")
        final_cost = max(0, base_cost * encumbrance_multiplier * status_multiplier)
        cost_details.append(f"Final Cost: {final_cost:.2f}")
        return final_cost, cost_details

    def perform_action(self, action: CombatAction, engine: Optional['GameEngine'] = None) -> Dict[str, Any]:
        """
        Performs the *mechanics* of a combat action, updating state via StatsManager.
        It now also queues DisplayEvents for rolls, damage, UI updates via the orchestrator
        by calling handlers from action_handlers.py.
        Stamina/Mana costs are now applied *before* the action handler is called.
        Does NOT call agents or advance turns. Returns a detailed result dictionary for internal use
        and a flag if events were queued.

        Args:
            action: The action to perform.
            engine: The GameEngine instance (for accessing orchestrator).

        Returns:
            Dictionary with the detailed results and a 'queued_events': True/False flag.
        """
        if not engine or not hasattr(engine, '_combat_orchestrator'):
            logger.error("Engine or Orchestrator unavailable in perform_action. Cannot queue display events.")
            return {"success": False, "message": "Internal Error: Orchestrator missing.", "queued_events": False}

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 

        default_result = {"success": False, "message": "Action could not be performed.", "queued_events": False}
        if self.state != CombatState.IN_PROGRESS:
            return {**default_result, "message": "Combat is not in progress"}

        performer = self.entities.get(action.performer_id)
        if not performer:
            return {**default_result, "message": "Performer entity not found"}

        performer_stats_manager = self._get_entity_stats_manager(performer.id)
        if not performer_stats_manager:
            logger.error(f"Could not find StatsManager for performer {performer.id}.")
            err_msg = f"Internal Error: Stats missing for {performer.combat_name}."
            event_err = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=err_msg, target_display=DisplayTarget.COMBAT_LOG)
            engine._combat_orchestrator.add_event_to_queue(event_err)
            return {**default_result, "message": err_msg, "queued_events": True}

        queued_events_flag = False 

        stamina_cost, cost_details_stamina = self._calculate_stamina_cost(action, performer)
        mana_cost = action.cost_mp
        current_stamina_val = performer_stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
        current_mana_val = performer_stats_manager.get_current_stat_value(DerivedStatType.MANA)
        
        self._last_action_result_detail = {
            "performer_id": performer.id, "performer_name": performer.combat_name,
            "action_name": action.name, "stamina_cost_calculated": stamina_cost,
            "mana_cost_calculated": mana_cost,
            "action_id_for_narration": action.id # Store action ID for outcome narration matching
        }
        if action.targets:
            target_obj = self.entities.get(action.targets[0])
            if target_obj: self._last_action_result_detail["target_name"] = target_obj.combat_name
            self._last_action_result_detail["target_id"] = action.targets[0]

        if current_stamina_val < stamina_cost:
            cost_fail_msg = f"{performer.combat_name} tries to {action.name} but lacks stamina ({current_stamina_val:.1f}/{stamina_cost:.1f})"
            self._add_to_log(cost_fail_msg) 
            event_cost_fail = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=cost_fail_msg, target_display=DisplayTarget.COMBAT_LOG)
            engine._combat_orchestrator.add_event_to_queue(event_cost_fail)
            queued_events_flag = True
            self._last_action_result_detail.update({"success": False, "message": "Not enough stamina."})
            return {**default_result, "message": "Not enough stamina.", "queued_events": queued_events_flag}
        
        if mana_cost > 0 and current_mana_val < mana_cost:
            cost_fail_msg = f"{performer.combat_name} tries to {action.name} but lacks mana ({current_mana_val:.1f}/{mana_cost:.1f})"
            self._add_to_log(cost_fail_msg)
            event_cost_fail = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=cost_fail_msg, target_display=DisplayTarget.COMBAT_LOG)
            engine._combat_orchestrator.add_event_to_queue(event_cost_fail)
            queued_events_flag = True
            self._last_action_result_detail.update({"success": False, "message": "Not enough mana."})
            return {**default_result, "message": "Not enough mana.", "queued_events": queued_events_flag}

        # --- Defer resource cost visual updates to the action handler (after roll/attempt text) ---
        # Costs are recorded here to be applied (and displayed) by the handler at the correct timing
        self._last_action_result_detail["stamina_spent"] = stamina_cost
        self._last_action_result_detail["stamina_remaining_after_action_preview"] = current_stamina_val - stamina_cost
        self._last_action_result_detail["mana_spent"] = mana_cost if mana_cost > 0 else 0
        self._last_action_result_detail["mana_remaining_after_action_preview"] = (current_mana_val - mana_cost) if mana_cost > 0 else current_mana_val
        new_mana_preview = current_mana_val
        
        # Action handler execution
        try:
            action_handler_func = None
            if action.action_type == ActionType.ATTACK: action_handler_func = _handle_attack_action 
            elif action.action_type == ActionType.SPELL: action_handler_func = _handle_spell_action   
            elif action.action_type == ActionType.DEFEND: action_handler_func = _handle_defend_action 
            elif action.action_type == ActionType.ITEM: action_handler_func = _handle_item_action   
            elif action.action_type == ActionType.FLEE: action_handler_func = _handle_flee_action_mechanics

            if action_handler_func:
                # _last_action_result_detail is passed to be updated by the handler
                handler_result_dict = action_handler_func(self, action, performer, performer_stats_manager, engine, self._last_action_result_detail)
                # The handler_result_dict is now effectively the updated self._last_action_result_detail
                if handler_result_dict.get("queued_events", False): queued_events_flag = True
            else:
                generic_action_msg = f"{performer.combat_name} performs action: {action.name} (Type: {action.action_type.name}) - No specific handler."
                self._add_to_log(generic_action_msg)
                event_generic = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=generic_action_msg, target_display=DisplayTarget.COMBAT_LOG)
                engine._combat_orchestrator.add_event_to_queue(event_generic)
                queued_events_flag = True
                self._last_action_result_detail.update({"success": True, "message": f"Performed generic action: {action.name}"})

        except Exception as e:
            logger.error(f"Error executing action {action.name} mechanics for {performer.combat_name}: {e}", exc_info=True)
            exec_err_msg = f"System Error during {action.name}: {e}"
            event_exec_err = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=exec_err_msg, target_display=DisplayTarget.COMBAT_LOG)
            engine._combat_orchestrator.add_event_to_queue(event_exec_err)
            queued_events_flag = True
            self._last_action_result_detail.update({"success": False, "message": f"Error during execution: {e}"})
            return {**default_result, "message": f"Error: {e}", "queued_events": queued_events_flag}
        
        # Update the main result dict with success being the success of the mechanical action itself
        # (e.g., hit, spell landed, item used as intended)
        # The handlers directly modify self._last_action_result_detail.
        final_action_success = self._last_action_result_detail.get("success", False)
        final_action_message = self._last_action_result_detail.get("message", "Action processed.")
        
        return {"success": final_action_success, "message": final_action_message, "queued_events": queued_events_flag, "details": self._last_action_result_detail}
    
    def _step_processing_npc_action(self, engine):
        """Processes the NPC's stored intent, queues attempt narrative, converts to action, sets next step, then pauses."""
        if not hasattr(engine, '_combat_orchestrator') or not hasattr(engine, '_combat_narrator_agent'):
            logger.error("Orchestrator or CombatNarratorAgent not found in _step_processing_npc_action.")
            self.current_step = CombatStep.ADVANCING_TURN 
            self.waiting_for_display_completion = False
            return

        active_id = self._active_entity_id
        if not self._current_intent or not active_id:
            logger.error(f"Processing NPC action step for {active_id}, but no intent or active_id. Advancing turn.")
            self.current_step = CombatStep.ADVANCING_TURN 
            self.waiting_for_display_completion = False
            return

        npc_entity = self.entities.get(active_id)
        if not npc_entity: # Should not happen
            logger.error(f"Cannot process NPC action: NPC entity {active_id} not found. Advancing turn.")
            self.current_step = CombatStep.ADVANCING_TURN 
            self.waiting_for_display_completion = False
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        from core.interaction.context_builder import ContextBuilder
        from core.agents.base_agent import AgentContext
        logger.info(f"Processing NPC Intent ({npc_entity.combat_name}): '{self._current_intent}'")

        game_state = engine._state_manager.current_state
        if not game_state:
            logger.error("GameState not found for NPC action processing. Advancing.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            return

        context_dict = ContextBuilder().build_context(game_state, InteractionMode.COMBAT, actor_id=active_id)
        agent_context = AgentContext(
            game_state=context_dict, player_state=context_dict.get('player', {}),
            world_state={k: v for k, v in context_dict.items() if k in ['location', 'time_of_day', 'environment']},
            player_input=self._current_intent, conversation_history=game_state.conversation_history,
            additional_context=context_dict
        )
        
        agent_output = None; conversion_success = False
        try: agent_output = engine._combat_narrator_agent.process(agent_context)
        except Exception as e: logger.error(f"Error calling CombatNarratorAgent for NPC {active_id} action: {e}", exc_info=True)

        if not agent_output or "narrative" not in agent_output:
            logger.error(f"Combat Narrator failed for NPC {active_id}. Fallback: Attack player.")
            fallback_narrative = f"{npc_entity.combat_name} looks confused, then lashes out wildly!"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.NARRATIVE_ATTEMPT, content=fallback_narrative, role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG))
            player_target = next((e for e in self.entities.values() if e.entity_type == EntityType.PLAYER and e.is_alive()), None)
            if player_target: self._pending_action = AttackAction(performer_id=active_id, target_id=player_target.id, weapon_name="fallback attack")
            else: self._pending_action = None
        else:
            if agent_output["narrative"]:
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.NARRATIVE_ATTEMPT, content=agent_output["narrative"], role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name))
            
            self._pending_action = None 
            validated_requests = agent_output.get("requests", [])
            if not validated_requests:
                no_req_msg = f"{npc_entity.combat_name} considers their options but doesn't act this turn."
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.NARRATIVE_GENERAL, content=no_req_msg, role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG))
            else: # Process first request to form an action
                action_request = validated_requests[0]
                try:
                    def normalize_action_type(action_name_str: str) -> str: return action_name_str.upper().strip().replace(' ', '_')
                    action_type_map = {"MELEE_ATTACK": ActionType.ATTACK, "RANGED_ATTACK": ActionType.ATTACK, "UNARMED_ATTACK": ActionType.ATTACK, "SPELL_ATTACK": ActionType.SPELL, "DEFEND": ActionType.DEFEND, "FLEE": ActionType.FLEE, "USE_ITEM": ActionType.ITEM}
                    
                    skill_name = action_request.get("skill_name") # e.g., "SPELL_ATTACK" or "Fireball"
                    combat_action_type = ActionType.OTHER
                    normalized_skill_for_action_name = skill_name or "action" # Use skill_name for spell/weapon name
                    if skill_name:
                        normalized_skill = normalize_action_type(skill_name)
                        combat_action_type = action_type_map.get(normalized_skill, ActionType.OTHER)
                        # If it's a generic type like "SPELL_ATTACK", the action name should be more specific if possible
                        # For example, if the intent was "cast fireball", skill_name from agent might be "Fireball"
                        if normalized_skill in ["SPELL_ATTACK", "MELEE_ATTACK", "RANGED_ATTACK"]:
                            # Use a more generic name for the action object if skill_name itself is generic
                            # The action_handlers will use dice_notation etc from the action object.
                            # The specific skill_name is more for display and determining type.
                            pass # normalized_skill_for_action_name is already skill_name

                    target_internal_id = None
                    target_combat_name_req = action_request.get("target_actor_id")
                    if target_combat_name_req:
                        target_entity = self._find_entity_by_combat_name(target_combat_name_req)
                        if target_entity: target_internal_id = target_entity.id
                        else: engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=f"{npc_entity.combat_name} looks for '{target_combat_name_req}' but can't find them!", target_display=DisplayTarget.COMBAT_LOG))

                    if combat_action_type == ActionType.ATTACK and target_internal_id:
                        self._pending_action = AttackAction(performer_id=active_id, target_id=target_internal_id, weapon_name=normalized_skill_for_action_name, dice_notation=action_request.get("dice_notation", "1d6"))
                    elif combat_action_type == ActionType.SPELL: # Fixed: Check if target_internal_id exists for targeted spells
                        # Assume for now that if target_internal_id is None, it's an area spell or self-buff
                        # This needs more robust handling based on spell type from agent
                        self._pending_action = SpellAction(
                            performer_id=active_id, spell_name=normalized_skill_for_action_name, 
                            target_ids=[target_internal_id] if target_internal_id else [], # Empty list if no target
                            cost_mp=float(action_request.get("cost_mp", 5.0)), 
                            dice_notation=action_request.get("dice_notation", "1d8" if target_internal_id else ""), # No dice if no target for default
                            description=action_request.get("description", f"Casting {normalized_skill_for_action_name}")
                        )
                    elif combat_action_type == ActionType.DEFEND:
                         self._pending_action = DefendAction(performer_id=active_id)
                    elif combat_action_type == ActionType.FLEE:
                         self._pending_action = FleeAction(performer_id=active_id)
                    
                    if self._pending_action:
                        logger.info(f"NPC ({npc_entity.combat_name}) action request converted to CombatAction: {self._pending_action.name}")
                        conversion_success = True
                    else: # Conversion failed or required target missing
                        # Only queue this if error wasn't already about target not found
                        if not (target_internal_id is None and (combat_action_type == ActionType.ATTACK or (combat_action_type == ActionType.SPELL and action_request.get("dice_notation")) )): 
                            conversion_fail_msg = f"{npc_entity.combat_name} attempts to {skill_name or 'act'}, but hesitates."
                            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.NARRATIVE_GENERAL, content=conversion_fail_msg, role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG))
                except Exception as e:
                    logger.exception(f"Error converting NPC {active_id} action request: {e}")
                    engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=f"[System Error: Could not process {npc_entity.combat_name}'s action.]", target_display=DisplayTarget.COMBAT_LOG))
        
        # Determine next step based on whether an action was successfully prepared
        if self._pending_action:
            self.current_step = CombatStep.RESOLVING_ACTION_MECHANICS
        else: # No action prepared (conversion fail, no request, fallback failed)
            self.current_step = CombatStep.APPLYING_STATUS_EFFECTS # Skip to end of turn

        self._current_intent = None 
        self.waiting_for_display_completion = True 

    def _step_resolving_action_mechanics(self, engine): # Added engine parameter
        """
        Initiates the processing of the current pending action (player or NPC regular turn)
        by calling self.perform_action.
        """
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_resolving_action_mechanics.")
            self.current_step = CombatStep.ADVANCING_TURN 
            self.waiting_for_display_completion = False
            return

        if not self._pending_action:
            logger.error("Resolving mechanics step, but no pending action stored.")
            self.current_step = CombatStep.APPLYING_STATUS_EFFECTS 
            self.waiting_for_display_completion = False
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 

        action_to_process = self._pending_action
        # self._pending_action = None # Clear this LATER

        logger.info(f"Initiating regular action mechanics for: {action_to_process.name} by entity {action_to_process.performer_id}")

        action_execution_summary = self.perform_action(action_to_process, engine)

        if not action_execution_summary.get("queued_events", False) and not action_execution_summary.get("success", False):
            logger.warning(f"perform_action for {action_to_process.name} did not queue events and reported failure. "
                           f"Message: {action_execution_summary.get('message')}")
            if not engine._combat_orchestrator.event_queue:
                fail_msg = self._last_action_result_detail.get("message") if self._last_action_result_detail else f"Action {action_to_process.name} by {self.entities[action_to_process.performer_id].combat_name} could not be resolved."
                event_action_fail = DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=fail_msg, target_display=DisplayTarget.COMBAT_LOG)
                engine._combat_orchestrator.add_event_to_queue(event_action_fail)
        
        self.current_step = CombatStep.NARRATING_ACTION_OUTCOME
        self.waiting_for_display_completion = True

    def _step_narrating_action_outcome(self, engine):
        """Generates and outputs the narrative description of the action's outcome, then sets next step."""
        if not hasattr(engine, '_combat_orchestrator') or not hasattr(engine, '_combat_narrator_agent'):
            logger.error("Orchestrator or CombatNarratorAgent not found in _step_narrating_action_outcome.")
            self.current_step = CombatStep.APPLYING_STATUS_EFFECTS
            self.waiting_for_display_completion = False
            return

        if not self._last_action_result_detail:
            logger.warning("No action result found to narrate outcome. Skipping narration.")
            self.current_step = CombatStep.APPLYING_STATUS_EFFECTS 
            self.waiting_for_display_completion = False
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        action_name_log = self._last_action_result_detail.get('action_name', 'Unknown Action')
        logger.info(f"Generating narrative for action outcome: {action_name_log}")

        outcome_narrative = None; agent_failed = False
        try:
            outcome_narrative = engine._combat_narrator_agent.narrate_outcome(self._last_action_result_detail, self)
            if not outcome_narrative: agent_failed = True
        except Exception as e: logger.error(f"Error calling narrate_outcome: {e}", exc_info=True); agent_failed = True

        if agent_failed: # Fallback narrative
            result = self._last_action_result_detail
            performer_name = result.get("performer_name", "Actor")
            target_name = result.get("target_name", "Target")
            action_name_disp = result.get("action_name", "action")
            damage = result.get("damage", 0)
            success_flag = result.get("success", False) # This is mechanical success of the action handler

            if success_flag: 
                if result.get("fled") is True: outcome_narrative = f"{performer_name} successfully flees the battle!"
                elif result.get("action_type") == ActionType.DEFEND: outcome_narrative = f"{performer_name} braces defensively."
                elif damage > 0: outcome_narrative = f"The {action_name_disp} from {performer_name} strikes {target_name} for {damage:.0f} damage."
                else: outcome_narrative = f"{performer_name}'s {action_name_disp} affects {target_name}, but deals no direct damage."
                if result.get("target_defeated"): outcome_narrative += f" {target_name} is overcome and falls!"
            else: # Mechanical failure
                if result.get("fled") is False : outcome_narrative = f"{performer_name} tries to flee but cannot escape!"
                else: outcome_narrative = f"{performer_name}'s {action_name_disp} against {target_name} fails utterly."
        
        if outcome_narrative:
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.NARRATIVE_IMPACT, content=outcome_narrative, role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name))
            self.waiting_for_display_completion = True
        else:
            self.waiting_for_display_completion = False # No narrative, proceed faster

        # Decide whether combat should end right after outcome narrative
        end_player_victory = False
        end_player_defeat = False
        try:
            from core.combat.combat_entity import EntityType
            # Player defeat if player entity is not alive
            player_id = getattr(self, '_player_entity_id', None)
            if player_id and player_id in self.entities:
                player_entity_obj = self.entities.get(player_id)
                if player_entity_obj and not player_entity_obj.is_alive():
                    end_player_defeat = True
            # Victory if no active, alive enemies remain
            remaining_enemies = [e for e in self.entities.values() if getattr(e, 'entity_type', None) == EntityType.ENEMY and getattr(e, 'is_active_in_combat', True) and e.is_alive()]
            if len(remaining_enemies) == 0:
                end_player_victory = True
        except Exception:
            pass

        # Clear pending action only AFTER narration is done with its details
        if self._pending_action and self._pending_action.id == self._last_action_result_detail.get("action_id_for_narration"):
            self._pending_action = None
        self._last_action_result_detail = None # Clear after use

        if end_player_defeat:
            self.state = CombatState.PLAYER_DEFEAT
            self.current_step = CombatStep.ENDING_COMBAT
            # keep waiting_for_display_completion as set above when narrative was queued
        elif end_player_victory:
            self.state = CombatState.PLAYER_VICTORY
            self.current_step = CombatStep.ENDING_COMBAT
        else:
            self.current_step = CombatStep.APPLYING_STATUS_EFFECTS 

    def _step_applying_status_effects(self, engine): # Added engine parameter
        """Applies end-of-turn status effects, regeneration, and updates durations. Queues messages."""
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_applying_status_effects.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            return

        if not self._active_entity_id: 
            logger.warning("Cannot apply status effects: No _active_entity_id set.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            return

        entity = self.entities.get(self._active_entity_id)
        if not entity:
            logger.warning(f"Cannot apply status effects: Entity {self._active_entity_id} not found.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        logger.debug(f"Applying end-of-turn effects for {entity.combat_name} ({entity.id})")
        queued_any_effect_event = False

        stats_manager_for_actor = self._get_entity_stats_manager(entity.id)
        if not stats_manager_for_actor:
            logger.warning(f"Cannot process status effects for {entity.combat_name}: StatsManager not found.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            return

        # --- DOT/HOT processing ---
        if entity.has_status_effect("Poisoned"): 
            poison_damage = 3.0 
            hp_before_poison = stats_manager_for_actor.get_current_stat_value(DerivedStatType.HEALTH)
            hp_after_poison_preview = hp_before_poison - poison_damage
            
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={}, metadata={"entity_id": entity.id, "bar_type": "hp", "old_value": hp_before_poison, "new_value_preview": hp_after_poison_preview, "max_value": entity.max_hp})); queued_any_effect_event = True
            
            stats_manager_for_actor.set_current_stat(DerivedStatType.HEALTH, hp_after_poison_preview)
            entity.set_current_hp(hp_after_poison_preview) 

            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={}, metadata={"entity_id": entity.id, "bar_type": "hp", "final_new_value": hp_after_poison_preview, "max_value": entity.max_hp})); queued_any_effect_event = True
            
            poison_msg = f"{entity.combat_name} takes {poison_damage:.0f} damage from Poison. (HP: {int(hp_after_poison_preview)}/{int(entity.max_hp)})"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=poison_msg, target_display=DisplayTarget.COMBAT_LOG)); self._add_to_log(poison_msg)
            queued_any_effect_event = True
            if hp_after_poison_preview <=0 and entity.is_alive(): 
                entity.is_active_in_combat = False 
                defeat_msg = f"{entity.combat_name} succumbs to poison!"
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=defeat_msg, target_display=DisplayTarget.COMBAT_LOG)); self._add_to_log(defeat_msg)
                queued_any_effect_event = True
        
        # --- Stamina Regeneration ---
        if entity.is_alive() and hasattr(stats_manager_for_actor, 'regenerate_combat_stamina'):
            regen_amount, regen_narrative = stats_manager_for_actor.regenerate_combat_stamina()
            if regen_amount > 0 and regen_narrative:
                # Note: regenerate_combat_stamina already calls set_current_stat, which emits stats_changed.
                # The UI will react to stats_changed for CharacterSheet.
                # For CombatDisplayWidget, we need explicit PHASE1/PHASE2 for stamina.
                current_stam_after_action_before_regen = stats_manager_for_actor.get_current_stat_value(DerivedStatType.STAMINA) - regen_amount #Approximate before regen
                current_stam_after_regen = stats_manager_for_actor.get_current_stat_value(DerivedStatType.STAMINA)
                max_stam = stats_manager_for_actor.get_stat_value(DerivedStatType.MAX_STAMINA)

                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE1, content={}, metadata={"entity_id": entity.id, "bar_type": "stamina", "old_value": current_stam_after_action_before_regen, "new_value_preview": current_stam_after_regen, "max_value": max_stam}))
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.UI_BAR_UPDATE_PHASE2, content={}, metadata={"entity_id": entity.id, "bar_type": "stamina", "final_new_value": current_stam_after_regen, "max_value": max_stam}))
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=regen_narrative, target_display=DisplayTarget.COMBAT_LOG))
                self._add_to_log(regen_narrative)
                queued_any_effect_event = True


        # --- Decrement durations ---
        expired_effect_names_this_turn = entity.decrement_status_effect_durations() 
        
        if expired_effect_names_this_turn:
            for expired_name in expired_effect_names_this_turn:
                stats_manager_for_actor.modifier_manager.remove_modifiers_by_source(ModifierSource.CONDITION, expired_name)
                
                expired_msg_content = f"Status effect '{expired_name}' has worn off {entity.combat_name}."
                engine._combat_orchestrator.add_event_to_queue(
                    DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=expired_msg_content, target_display=DisplayTarget.COMBAT_LOG)
                ); self._add_to_log(expired_msg_content)
                queued_any_effect_event = True
        
        self.current_step = CombatStep.ADVANCING_TURN
        if queued_any_effect_event:
            self.waiting_for_display_completion = True 
        else: 
            self.waiting_for_display_completion = False
            
    def _step_processing_player_action(self, engine): # Engine is passed
        """Processes the player's stored intent, queues attempt narrative, converts to action or mode transition, then sets next step and pauses."""
        if not hasattr(engine, '_combat_orchestrator') or not hasattr(engine, '_combat_narrator_agent'):
            logger.error("Orchestrator or CombatNarratorAgent not found in _step_processing_player_action.")
            self.current_step = CombatStep.AWAITING_PLAYER_INPUT 
            self.waiting_for_display_completion = False
            return

        if not self._current_intent:
            logger.error("Processing player action step, but no intent stored. Reverting to AWAITING_PLAYER_INPUT.")
            self.current_step = CombatStep.AWAITING_PLAYER_INPUT 
            self.waiting_for_display_completion = False
            return

        player_id = self._player_entity_id
        if not player_id: 
            logger.error("Cannot process player action: Player ID unknown. Advancing turn.")
            self.current_step = CombatStep.ADVANCING_TURN 
            self.waiting_for_display_completion = False
            return
            
        player_entity = self.entities.get(player_id)
        if not player_entity:
            logger.error(f"Player entity {player_id} not found for action processing. Advancing turn.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        from core.interaction.context_builder import ContextBuilder
        from core.agents.base_agent import AgentContext
        logger.info(f"Processing Player Intent ({player_entity.combat_name}): '{self._current_intent}'")

        game_state = engine._state_manager.current_state
        if not game_state: 
            logger.error("GameState not found for player action processing. Reverting.")
            self.current_step = CombatStep.AWAITING_PLAYER_INPUT
            self.waiting_for_display_completion = False
            return
            
        context_dict = ContextBuilder().build_context(game_state, InteractionMode.COMBAT, actor_id=player_id)
        agent_context = AgentContext(
            game_state=context_dict, player_state=context_dict.get('player', {}),
            world_state={k: v for k, v in context_dict.items() if k in ['location', 'time_of_day', 'environment']},
            player_input=self._current_intent, conversation_history=game_state.conversation_history if game_state else [],
            additional_context=context_dict
        )

        agent_output = None
        try:
            agent_output = engine._combat_narrator_agent.process(agent_context)
        except Exception as e: logger.error(f"Error calling CombatNarratorAgent for player action: {e}", exc_info=True)
        
        action_processed_this_step = False # Flag to track if any action path was taken

        if not agent_output or "narrative" not in agent_output:
            err_msg = "[System Error: Failed to interpret action. Please try again, perhaps phrase differently.]"
            engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=err_msg, target_display=DisplayTarget.COMBAT_LOG))
            self.current_step = CombatStep.AWAITING_PLAYER_INPUT 
        else:
            if agent_output["narrative"]:
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.NARRATIVE_ATTEMPT, content=agent_output["narrative"], role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name))
            
            self._pending_action = None 
            validated_requests = agent_output.get("requests", [])

            if not validated_requests:
                no_req_msg = f"{player_entity.combat_name} considers their options but doesn't commit to an action."
                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.NARRATIVE_GENERAL, content=no_req_msg, role="gm", tts_eligible=True, gradual_visual_display=True, target_display=DisplayTarget.COMBAT_LOG))
                self.current_step = CombatStep.APPLYING_STATUS_EFFECTS 
                action_processed_this_step = True
            else:
                action_request = validated_requests[0]
                
                if action_request.get("action") == "request_mode_transition":
                    action_processed_this_step = True
                    logger.info(f"Player action interpreted as mode transition: {action_request}")
                    # Ensure actor_id from request is valid, fallback to current player_entity if needed
                    actor_combat_name_from_req = action_request.get("actor_id", player_entity.combat_name)
                    actor_for_transition = self._find_entity_by_combat_name(actor_combat_name_from_req)
                    if not actor_for_transition: actor_for_transition = player_entity 

                    from core.game_flow.mode_transitions import _handle_transition_request 
                    
                    if action_request.get("target_mode") == "NARRATIVE" and action_request.get("origin_mode") == "COMBAT":
                        action_request["additional_context"] = {
                            "original_intent": self._current_intent,
                            "narrative_context": agent_output["narrative"] 
                        }
                    
                    # _handle_transition_request will manage messages and potential mode changes.
                    # It returns a narrative string, which might be an error or success confirmation for non-combat transitions.
                    # For flee/surrender, it internally calls other functions that queue messages.
                    _handle_transition_request(engine, game_state, action_request, actor_for_transition.id)
                    
                    # After _handle_transition_request, check if mode actually changed
                    if game_state.current_mode != InteractionMode.COMBAT: 
                        self.current_step = CombatStep.ENDING_COMBAT # If mode changed, combat is ending.
                    else: 
                        # Mode is still COMBAT. This means flee/surrender failed or was not applicable.
                        # Player's turn ends.
                        self.current_step = CombatStep.APPLYING_STATUS_EFFECTS
                else: 
                    # Process as a regular combat action (attack, spell, etc.)
                    action_processed_this_step = True
                    try:
                        def normalize_action_type(action_name_str: str) -> str: return action_name_str.upper().strip().replace(' ', '_')
                        action_type_map = {"MELEE_ATTACK": ActionType.ATTACK, "RANGED_ATTACK": ActionType.ATTACK, "UNARMED_ATTACK": ActionType.ATTACK, "SPELL_ATTACK": ActionType.SPELL, "DEFEND": ActionType.DEFEND, "FLEE": ActionType.FLEE, "USE_ITEM": ActionType.ITEM}
                        
                        skill_name = action_request.get("skill_name")
                        combat_action_type = ActionType.OTHER
                        normalized_skill_for_action_name = skill_name or "action"
                        if skill_name:
                            normalized_skill = normalize_action_type(skill_name)
                            combat_action_type = action_type_map.get(normalized_skill, ActionType.OTHER)
                        
                        # Bridge: infer FLEE or SURRENDER from intent/context even if LLM didn't return ideal request
                        intent_lower = (self._current_intent or "").lower()
                        context_lower = str(action_request.get("context", "")).lower()
                        # Detect surrender intent and convert to mode transition immediately
                        if any(tok in intent_lower for tok in ["surrender", "yield", "give up"]) or any(tok in context_lower for tok in ["surrender", "yield", "give up"]):
                            from core.game_flow.mode_transitions import _handle_transition_request
                            req = {
                                "action": "request_mode_transition",
                                "target_mode": "NARRATIVE",
                                "origin_mode": "COMBAT",
                                "reason": "surrender",
                                "additional_context": {"original_intent": self._current_intent, "narrative_context": agent_output.get("narrative", "")},
                            }
                            _handle_transition_request(engine, game_state, req, player_entity.id)
                            if game_state.current_mode != InteractionMode.COMBAT:
                                self.current_step = CombatStep.ENDING_COMBAT
                            else:
                                self.current_step = CombatStep.APPLYING_STATUS_EFFECTS
                            # Already handled as transition path
                            self.waiting_for_display_completion = True
                            return
                        # Detect flee intent and convert to FleeAction mechanics
                        if combat_action_type == ActionType.OTHER:
                            flee_tokens = ["flee", "escape", "run", "retreat", "disengage"]
                            if any(tok in intent_lower for tok in flee_tokens) or any(tok in context_lower for tok in flee_tokens) or (skill_name and normalize_action_type(skill_name) in ["ATHLETICS", "ACROBATICS"] and any(tok in intent_lower for tok in flee_tokens)):
                                combat_action_type = ActionType.FLEE
                        
                        target_internal_id = None
                        target_combat_name_req = action_request.get("target_actor_id")
                        if target_combat_name_req:
                            target_entity = self._find_entity_by_combat_name(target_combat_name_req)
                            if target_entity: target_internal_id = target_entity.id
                            else: engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=f"Cannot perform action: Target '{target_combat_name_req}' not found.", target_display=DisplayTarget.COMBAT_LOG))
                        
                        if combat_action_type == ActionType.ATTACK and target_internal_id:
                            self._pending_action = AttackAction(performer_id=player_id, target_id=target_internal_id, weapon_name=normalized_skill_for_action_name, dice_notation=action_request.get("dice_notation", "1d6"))
                        elif combat_action_type == ActionType.SPELL:
                            self._pending_action = SpellAction(performer_id=player_id, spell_name=normalized_skill_for_action_name, target_ids=[target_internal_id] if target_internal_id else [], cost_mp=float(action_request.get("cost_mp", 5.0)), dice_notation=action_request.get("dice_notation", "1d8"))
                        elif combat_action_type == ActionType.DEFEND:
                            self._pending_action = DefendAction(performer_id=player_id)
                        elif combat_action_type == ActionType.FLEE: # Explicit or inferred FleeAction
                            self._pending_action = FleeAction(performer_id=player_id)
                        elif combat_action_type == ActionType.ITEM:
                            item_name_from_skill = skill_name 
                            item_id_placeholder = action_request.get("item_id", item_name_from_skill.lower().replace(" ","_")) if item_name_from_skill else "unknown_item"
                            self._pending_action = CombatAction(action_type=ActionType.ITEM, performer_id=player_id, name=f"Use {item_name_from_skill or 'Item'}", targets=[target_internal_id] if target_internal_id else [player_id], special_effects={"item_id": item_id_placeholder, "effect_type": "healing_potion", "heal_amount": 10})
                        
                        if self._pending_action:
                            logger.info(f"Player action request converted to CombatAction: {self._pending_action.name}")
                            self.current_step = CombatStep.RESOLVING_ACTION_MECHANICS
                        else: 
                            if not (target_internal_id is None and (combat_action_type == ActionType.ATTACK or (combat_action_type == ActionType.SPELL and not (skill_name and skill_name.lower().startswith("self")) ))):
                                conversion_fail_msg = f"Could not prepare action '{skill_name or 'unknown'}'. Try again."
                                engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=conversion_fail_msg, target_display=DisplayTarget.COMBAT_LOG))
                            self.current_step = CombatStep.AWAITING_PLAYER_INPUT 
                    except Exception as e:
                        logger.exception(f"Error converting player action request: {e}")
                        engine._combat_orchestrator.add_event_to_queue(DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=f"[System Error: Could not process action. Please rephrase.]", target_display=DisplayTarget.COMBAT_LOG))
                        self.current_step = CombatStep.AWAITING_PLAYER_INPUT
            
            if not action_processed_this_step: # Fallback if no request path was taken (should be rare)
                logger.warning("No specific action path taken in _step_processing_player_action. Defaulting to end turn.")
                self.current_step = CombatStep.APPLYING_STATUS_EFFECTS
        
        self._current_intent = None 
        self.waiting_for_display_completion = True

    def _get_entity_stats_manager(self, entity_id: str, quiet: bool = False) -> Optional['StatsManager']:
        state_manager = get_state_manager()
        if not state_manager.current_state:
            if not quiet:
                logger.error("Current game state not found in StateManager.")
            return None
        player_id = getattr(state_manager.current_state.player, 'id', None) or getattr(state_manager.current_state.player, 'stats_manager_id', None)
        if entity_id == player_id:
            if hasattr(state_manager, 'stats_manager') and state_manager.stats_manager:
                logger.debug(f"Retrieved main StatsManager for player ID {entity_id}")
                return state_manager.stats_manager
            else:
                if not quiet:
                    logger.error(f"Could not retrieve main StatsManager for player ID {entity_id}")
                return None
        npc_system = state_manager.get_npc_system()
        if npc_system:
            npc = None
            if hasattr(npc_system, 'get_npc_by_id'):
                npc = npc_system.get_npc_by_id(entity_id)
                if npc: logger.debug(f"Found NPC {entity_id} via get_npc_by_id")
            else:
                if not quiet:
                    logger.warning("NPCSystem does not have get_npc_by_id method.")
            if npc is None and hasattr(npc_system, 'get_npc_by_name'):
                try:
                    combat_entity = self.entities.get(entity_id)
                    if combat_entity:
                        entity_name = combat_entity.name
                        if not quiet:
                            logger.warning(f"Attempting fallback lookup for NPC '{entity_name}' (ID: {entity_id}) via get_npc_by_name.")
                        npc = npc_system.get_npc_by_name(entity_name)
                        if npc: logger.debug(f"Found NPC {entity_name} via get_npc_by_name")
                    else:
                        if not quiet:
                            logger.warning(f"Cannot find entity name for ID {entity_id} to use get_npc_by_name.")
                except Exception as e:
                    if not quiet:
                        logger.error(f"Error looking up NPC by name '{entity_id}': {e}")
            if npc and hasattr(npc, 'stats_manager'):
                logger.debug(f"Retrieved StatsManager from NPCSystem for NPC ID {entity_id}")
                return npc.stats_manager
            elif npc:
                if not quiet:
                    logger.warning(f"NPC {entity_id} found via NPCSystem, but lacks a 'stats_manager' attribute.")
            else:
                if not quiet:
                    logger.warning(f"Could not find NPC for ID {entity_id} via NPCSystem using available methods.")
        else:
            if not quiet:
                logger.warning("NPCSystem not available via StateManager to retrieve NPC StatsManager.")
        if not quiet:
            logger.error(f"Could not retrieve StatsManager for entity ID {entity_id}")
        return None

    def _step_ending_combat(self, engine): # Engine is passed
        """Handles the end of combat, cleanup. Queues final message FOR COMBAT LOG."""
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_ending_combat.")
            self.current_step = CombatStep.COMBAT_ENDED 
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
        logger.info(f"Processing ENDING_COMBAT step. Final State: {self.state.name}")
        
        # Clean up combat effects
        for entity in self.entities.values():
            stats_manager = self._get_entity_stats_manager(entity.id)
            if stats_manager:
                stats_manager.status_effect_manager.remove_effects_by_name("Defending")
                stats_manager.status_effect_manager.remove_effects_by_name("Advantage") 
                stats_manager.status_effect_manager.remove_effects_by_name("Surprised") 
            if hasattr(entity, 'remove_status_effect'): 
                entity.remove_status_effect("Defending") 
                entity.remove_status_effect("Advantage")
                entity.remove_status_effect("Surprised")

        # Generate loot from defeated NPCs
        self._generate_combat_loot(engine)

        # This message is the LAST message for the COMBAT LOG.
        # The GameEngine will handle the overall "Combat has concluded. Outcome: ..." for GameOutputWidget
        # and the LLM closing narrative AFTER the mode changes.
        final_combat_log_message = f"--- Combat Concluded ({self.state.name}) ---"
        self._add_to_log(final_combat_log_message) 

        event_combat_end_log = DisplayEvent(
            type=DisplayEventType.SYSTEM_MESSAGE, content=final_combat_log_message,
            target_display=DisplayTarget.COMBAT_LOG, 
            source_step=self.current_step.name,
            gradual_visual_display=False # Make this last one quick
        )
        engine._combat_orchestrator.add_event_to_queue(event_combat_end_log)
        
        self.current_step = CombatStep.COMBAT_ENDED # This signals GameEngine to take over for mode change etc.
        self.waiting_for_display_completion = True # Pause for this last combat log message

    def _step_advancing_turn(self, engine):
        """Advances the turn, queues message, sets next actor step, then pauses."""
        if not hasattr(engine, '_combat_orchestrator'):
            logger.error("Orchestrator not found on engine in _step_advancing_turn.")
            self.end_combat("Internal error: Orchestrator unavailable for turn advancement.")
            self.current_step = CombatStep.COMBAT_ENDED
            return

        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        logger.debug("Executing step: ADVANCING_TURN")

        self._last_action_result_detail = None 

        next_entity_id = self._advance_turn() 

        if self.state != CombatState.IN_PROGRESS:
            logger.info(f"Combat ended ({self.state.name}) during/after _advance_turn. Moving to ENDING_COMBAT step.")
            self.current_step = CombatStep.ENDING_COMBAT
            self.waiting_for_display_completion = False 
            return

        if next_entity_id is None: # Should be caught by _advance_turn's _check_combat_state
            logger.error("Advancing turn failed to find next active entity, but combat state is IN_PROGRESS. This indicates an issue in _advance_turn or _check_combat_state. Forcing end.")
            if self.state == CombatState.IN_PROGRESS: self.end_combat("Error: Could not determine next turn.")
            self.current_step = CombatStep.ENDING_COMBAT
            self.waiting_for_display_completion = False
            return

        # --- Logic to queue "It is now X's turn" and set next step ---
        next_entity_obj = self.entities.get(next_entity_id)
        queued_turn_message = False
        if next_entity_obj:
            turn_msg = f"It is now {next_entity_obj.combat_name}'s turn."
            # _add_to_log for this message is handled in _advance_turn
            event_next_turn = DisplayEvent(
                type=DisplayEventType.SYSTEM_MESSAGE, content=turn_msg,
                target_display=DisplayTarget.COMBAT_LOG, source_step=self.current_step.name
            )
            engine._combat_orchestrator.add_event_to_queue(event_next_turn)
            queued_turn_message = True
        
        # Determine the actual next game step (AWAITING_PLAYER_INPUT or AWAITING_NPC_INTENT)
        self._set_next_actor_step(next_entity_id) 
        # self.current_step is now updated by _set_next_actor_step

        if queued_turn_message:
            self.waiting_for_display_completion = True # Pause for the "next turn" message
        else:
            # If no message was queued (should not happen if next_entity_obj exists),
            # don't pause, let process_combat_step loop continue to the new current_step.
            self.waiting_for_display_completion = False

    def _advance_turn(self) -> Optional[str]:
        if not self.turn_order:
            logger.error("Cannot advance turn: Turn order is empty.")
            self._check_combat_state(); return None
        self._check_combat_state()
        if self.state != CombatState.IN_PROGRESS:
            logger.info(f"Combat ended ({self.state.name}) during turn advancement check."); return None
        start_index = self.current_turn_index
        num_entities = len(self.turn_order)
        for i in range(1, num_entities + 1):
            next_index = (start_index + i) % num_entities
            next_entity_id = self.turn_order[next_index]
            next_entity = self.entities.get(next_entity_id)
            if next_entity and next_entity.is_alive() and getattr(next_entity, 'is_active_in_combat', True):
                self.current_turn_index = next_index
                self._active_entity_id = next_entity_id
                logger.info(f"Advanced turn. It is now {next_entity.combat_name}'s turn.")
                self._add_to_log(f"{next_entity.combat_name}'s turn.")
                return next_entity_id
            elif next_entity:
                reason = "inactive/fled" if not getattr(next_entity, 'is_active_in_combat', True) else "defeated"
                logger.debug(f"Skipping turn for {reason} entity: {next_entity.combat_name}")
        logger.warning("Looped through turn order and found no active entities.")
        self._check_combat_state(); return None

    def _set_next_actor_step(self, entity_id: str, engine: Optional['GameEngine'] = None): # Added engine parameter
        entity = self.entities.get(entity_id)
        if not entity:
            logger.error(f"Cannot set next step: Entity {entity_id} not found.")
            self.current_step = CombatStep.ADVANCING_TURN; return
        
        # --- Use passed engine parameter ---
        # engine = get_state_manager().current_state.game_engine if get_state_manager().current_state else None # Get engine # REMOVE THIS LINE
        
        if engine and hasattr(engine, '_combat_orchestrator'):
            turn_order_display_list = []
            for i, id_in_order in enumerate(self.turn_order):
                e = self.entities.get(id_in_order)
                if e and e.is_alive() and getattr(e, 'is_active_in_combat', True):
                    prefix = "→ " if id_in_order == entity_id else "  "
                    turn_order_display_list.append(f"{prefix}{getattr(e, 'combat_name', e.name)}")
                elif e:
                    turn_order_display_list.append(f"  [{getattr(e, 'combat_name', e.name)} - Defeated/Inactive]")
            
            active_entity_combat_name = getattr(entity, 'combat_name', entity.name)
            
            turn_order_event_content = {
                "turn_order_display_list": turn_order_display_list,
                "active_entity_combat_name": active_entity_combat_name,
                "is_surprise": self._is_surprise_round, 
                "round_number": self.round_number
            }
            from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
            engine._combat_orchestrator.add_event_to_queue(
                DisplayEvent(
                    type=DisplayEventType.TURN_ORDER_UPDATE, 
                    content=turn_order_event_content, 
                    target_display=DisplayTarget.MAIN_GAME_OUTPUT, 
                    source_step=f"SET_ACTOR_{entity_id}"
                )
            )
            logger.debug(f"Queued TURN_ORDER_UPDATE for CharacterSheet on {entity.combat_name}'s turn start.")
        elif not engine:
            logger.warning("_set_next_actor_step: Engine reference not provided, cannot queue TURN_ORDER_UPDATE for CharacterSheet.")

        if entity.has_status_effect("Stunned") or entity.has_status_effect("Immobilized") or entity.has_status_effect("Asleep"):
            status_name = "Stunned"
            if entity.has_status_effect("Immobilized"): status_name = "Immobilized"
            elif entity.has_status_effect("Asleep"): status_name = "Asleep"
            
            skip_turn_msg = f"{entity.combat_name} cannot act this turn (Status: {status_name})."
            if engine and hasattr(engine, '_combat_orchestrator'):
                from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
                engine._combat_orchestrator.add_event_to_queue(
                    DisplayEvent(type=DisplayEventType.SYSTEM_MESSAGE, content=skip_turn_msg, target_display=DisplayTarget.COMBAT_LOG)
                )
            else: 
                self._add_to_log(skip_turn_msg)

            logger.info(f"{entity.combat_name}'s turn skipped due to status: {status_name}")
            self.current_step = CombatStep.APPLYING_STATUS_EFFECTS 
            return

        if entity.entity_type == EntityType.PLAYER:
            logger.info("Next step: AWAITING_PLAYER_INPUT")
            self.current_step = CombatStep.AWAITING_PLAYER_INPUT
        else:
            logger.info("Next step: AWAITING_NPC_INTENT")
            self.current_step = CombatStep.AWAITING_NPC_INTENT

    def _step_awaiting_npc_intent(self, engine): # Engine is passed
        """Retrieves the NPC's intended action for the turn."""
        if not self._active_entity_id:
            logger.error("Awaiting NPC intent step, but _active_entity_id is not set.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False # No display event, allow immediate next step
            QTimer.singleShot(0, lambda: self.process_combat_step(engine)) # Nudge
            return
        
        from core.game_flow.npc_interaction import get_npc_intent

        npc_id = self._active_entity_id
        npc_entity = self.entities.get(npc_id)
        if not npc_entity:
            logger.error(f"Cannot get NPC intent: Entity {npc_id} not found.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            QTimer.singleShot(0, lambda: self.process_combat_step(engine))
            return

        logger.info(f"Requesting intent for NPC: {npc_entity.combat_name} ({npc_id})")
        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget # Local import

        # This step is purely logical for now; LLM call happens here.
        # If there was a "NPC is thinking..." message, it would be queued.
        game_state = engine._state_manager.current_state
        if not game_state:
            logger.error("GameState not found for NPC intent.")
            self.current_step = CombatStep.ADVANCING_TURN
            self.waiting_for_display_completion = False
            QTimer.singleShot(0, lambda: self.process_combat_step(engine))
            return
            
        intent = get_npc_intent(engine, game_state, npc_id)

        if intent:
            self._current_intent = intent
            logger.info(f"NPC Intent received for {npc_entity.combat_name}: '{intent}'")
            self.current_step = CombatStep.PROCESSING_NPC_ACTION
        else:
            logger.warning(f"Failed to get intent for NPC {npc_id}. NPC will falter.")
            self._current_intent = "Falter" # Give a default intent for processing
            # The "falters" narrative will be generated in the next step
            self.current_step = CombatStep.PROCESSING_NPC_ACTION 
            # (No, if no intent, directly to APPLYING_STATUS_EFFECTS after a message)
            # Correction: If intent is None/empty, generate falter message and go to APPLYING_STATUS_EFFECTS
            # Forcing PROCESSING_NPC_ACTION with "Falter" intent allows narrator to describe it.

        self.waiting_for_display_completion = False # No display events generated *in this specific step*
        # The next step (PROCESSING_NPC_ACTION) will queue display events.
        # We can let the process_combat_step loop continue if no display events were queued here.
        # However, to maintain consistency of Orchestrator driving resumption:
        if not engine._combat_orchestrator.event_queue and not engine._combat_orchestrator.is_processing_event:
             QTimer.singleShot(0, lambda: self.process_combat_step(engine))
        # This ensures that if this step doesn't queue anything, the CM loop continues.

    def _end_surprise_round(self) -> None:
        logger.info("Ending surprise round and transitioning to normal combat.")
        self._is_surprise_round = False
        self._surprise_round_entities = []
        for entity in self.entities.values():
            if entity.has_status_effect("Surprised"):
                entity.remove_status_effect("Surprised")
                logger.debug(f"Removed Surprised status from {entity.name} at end of surprise round")
        self.round_number = 1
        self.current_turn_index = 0
        self._add_to_log(f"Round {self.round_number} begins!")
        self._log_turn_order()

    def _process_status_effects(self, entity_id: str) -> None:
        entity = self.entities.get(entity_id)
        if not entity or not entity.is_alive(): return
        if hasattr(entity, 'decrement_status_effect_durations'):
            expired_effects = entity.decrement_status_effect_durations()
            if expired_effects:
                self._add_to_log(f"{entity.name} status effects expired: {', '.join(expired_effects)}")
                logger.debug(f"Status effects expired for {entity.name}: {expired_effects}")
            if "Defending" in expired_effects: self._add_to_log(f"{entity.name} stops defending.")
        else: logger.debug(f"Entity {entity.name} does not support timed status effects.")

    def _check_combat_state(self) -> None:
        if self.state != CombatState.IN_PROGRESS: return
        alive_players = 0; alive_enemies = 0
        for entity in self.entities.values():
            if entity.is_alive() and getattr(entity, 'is_active_in_combat', True):
                if entity.entity_type == EntityType.PLAYER or entity.entity_type == EntityType.ALLY: alive_players += 1
                elif entity.entity_type == EntityType.ENEMY: alive_enemies += 1
        if alive_players == 0:
            self.state = CombatState.PLAYER_DEFEAT
            self._add_to_log("Combat ended: All players defeated!")
        elif alive_enemies == 0:
            self.state = CombatState.PLAYER_VICTORY
            escaped_enemies = [e.name for e in self.entities.values() if e.entity_type == EntityType.ENEMY and not getattr(e, 'is_active_in_combat', False) and e.is_alive()]
            if escaped_enemies: self._add_to_log(f"Combat ended: Victory! All active enemies defeated! ({', '.join(escaped_enemies)} escaped)")
            else: self._add_to_log("Combat ended: Victory! All enemies defeated!")

    def _add_to_log(self, message: str) -> None:
        self.combat_log.append(message)
        logger.debug(f"Combat log: {message}")

    def get_combat_summary(self) -> Dict[str, Any]:
        current_entity = self.get_current_entity()
        return {
            "id": self.id, "state": self.state.name, "round": self.round_number,
            "current_turn": current_entity.name if current_entity else None,
            "entities": {
                entity_id: {
                    "name": entity.name, "hp": f"{int(entity.current_hp)}/{int(entity.max_hp)}",
                    "mp": f"{int(entity.current_mp)}/{int(entity.max_mp)}",
                    "stamina": f"{int(entity.current_stamina)}/{int(entity.max_stamina)}",
                    "status": list(entity.status_effects.keys()), "is_alive": entity.is_alive(),
                    "type": entity.entity_type.name
                } for entity_id, entity in self.entities.items()
            },
            "log": self.combat_log[-10:],
            "turn_order": [self.entities[entity_id].name for entity_id in self.turn_order if entity_id in self.entities]
        }

    def get_entity_by_id(self, entity_id: str) -> Optional[CombatEntity]:
        return self.entities.get(entity_id)

    def apply_surprise(self, surprised_entities: Optional[List[str]] = None, attacker_id: Optional[str] = None) -> None:
        if self.state != CombatState.IN_PROGRESS:
            logger.warning("Cannot apply surprise: Combat not in progress."); return
        if surprised_entities is None:
            player_ids = [eid for eid, e in self.entities.items() if e.entity_type in [EntityType.PLAYER, EntityType.ALLY]]
            enemy_ids = [eid for eid, e in self.entities.items() if e.entity_type == EntityType.ENEMY]
            if attacker_id in player_ids: surprised_entities = enemy_ids
            elif attacker_id in enemy_ids: surprised_entities = player_ids
            else: surprised_entities = player_ids
        for entity_id in surprised_entities:
            entity = self.entities.get(entity_id)
            if entity and entity.is_alive():
                if hasattr(entity, 'add_status_effect'):
                    entity.add_status_effect("Surprised", duration=1)
                    logger.debug(f"Applied Surprised status to {entity.name} for 1 turn")

    def end_combat(self, reason: str = "Combat ended") -> None:
        if self.state != CombatState.IN_PROGRESS:
            logger.warning(f"Attempted to end combat but state was {self.state.name}")
        previous_state = self.state
        if self.state == CombatState.IN_PROGRESS:
             if "fled" in reason.lower(): self.state = CombatState.FLED
             else: self.state = CombatState.NOT_STARTED
        self._add_to_log(f"Combat ended: {reason} (Final State: {self.state.name})")
        logger.info(f"Ending combat. Reason: {reason}. State changed from {previous_state.name} to {self.state.name}")
        for entity in self.entities.values():
            if hasattr(entity, 'remove_status_effect'):
                 entity.remove_status_effect("Defending")
                 entity.remove_status_effect("Surprised")
        self.current_turn_index = 0
        self.round_number = 0
        self.last_action_results = {}
        self._surprise_round_entities = []
        self._is_surprise_round = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "entities": {entity_id: entity.to_dict() for entity_id, entity in self.entities.items()},
            "turn_order": self.turn_order,
            "current_turn_index": self.current_turn_index,
            "round_number": self.round_number,
            "state": self.state.name,
            "current_step": self.current_step.name if hasattr(self.current_step, 'name') else str(self.current_step),
            "active_entity_id": self._active_entity_id,
            "player_entity_id": self._player_entity_id,
            "enemy_entity_ids": self._enemy_entity_ids,
            "is_surprise_round": self._is_surprise_round,
            "surprise_round_entities": self._surprise_round_entities,
            "combat_log": self.combat_log,
            "combat_log_html": self.display_log_html,
            "last_action_results": self.last_action_results
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CombatManager':
        manager = cls()
        manager.id = data.get("id", str(uuid.uuid4()))
        manager.entities = {
            entity_id: CombatEntity.from_dict(entity_data)
            for entity_id, entity_data in data.get("entities", {}).items()
        }
        manager.turn_order = data.get("turn_order", [])
        manager.current_turn_index = data.get("current_turn_index", 0)
        manager.round_number = data.get("round_number", 0)
        manager.state = CombatState[data.get("state", "NOT_STARTED")]
        # Restore current step and pointers
        from .enums import CombatStep as _CombatStep
        try:
            manager.current_step = _CombatStep[data.get("current_step", "NOT_STARTED")]
        except Exception:
            manager.current_step = _CombatStep.NOT_STARTED
        manager._active_entity_id = data.get("active_entity_id")
        manager._player_entity_id = data.get("player_entity_id")
        manager._enemy_entity_ids = data.get("enemy_entity_ids", [])
        manager._is_surprise_round = data.get("is_surprise_round", False)
        manager._surprise_round_entities = data.get("surprise_round_entities", [])

        # Logs / HTML snapshot
        manager.combat_log = data.get("combat_log", [])
        manager.display_log_html = data.get("combat_log_html", "")

        manager.last_action_results = data.get("last_action_results", {})
        return manager

    def sync_stats_with_managers_from_entities(self) -> None:
        """Sync StatsManager current values to match saved CombatEntity values.
        Player is always synced. NPCs are synced only if an NPC StatsManager is available.
        """
        for entity_id, combat_entity in self.entities.items():
            try:
                stats_manager = self._get_entity_stats_manager(entity_id, quiet=True)
                if not stats_manager:
                    # Quietly skip if we cannot obtain a stats manager (e.g., NPC without NPCSystem linkage)
                    continue
                # Sync HP/Stamina/Mana current values (best effort)
                try:
                    stats_manager.set_current_stat(DerivedStatType.HEALTH, combat_entity.current_hp)
                except Exception:
                    pass
                try:
                    stats_manager.set_current_stat(DerivedStatType.STAMINA, combat_entity.current_stamina)
                except Exception:
                    pass
                try:
                    stats_manager.set_current_stat(DerivedStatType.MANA, combat_entity.current_mp)
                except Exception:
                    pass
                # Optional: Attempt to reconstruct status effects on the StatsManager
                try:
                    from core.stats.combat_effects import StatusEffect, StatusEffectType
                    if hasattr(stats_manager, 'status_effect_manager'):
                        for eff_name, duration in (combat_entity.status_effects or {}).items():
                            try:
                                se = StatusEffect(name=eff_name, description=eff_name, effect_type=StatusEffectType.DEBUFF, duration=duration)
                                if hasattr(stats_manager, 'add_status_effect'):
                                    stats_manager.add_status_effect(se)
                            except Exception:
                                continue
                except Exception:
                    pass
            except Exception:
                # Never escalate here; this is a best-effort re-sync to avoid noisy logs
                continue

    def _find_entity_by_combat_name(self, combat_name: str) -> Optional[CombatEntity]:
        if not combat_name: return None
        name_lower = combat_name.lower()
        for entity in self.entities.values():
            entity_combat_name = getattr(entity, 'combat_name', None)
            if entity_combat_name and entity_combat_name.lower() == name_lower:
                return entity
        logger.debug(f"Could not find entity with combat_name: '{combat_name}' in current combat.")
        return None
    
    def _generate_combat_loot(self, engine):
        """Generate loot from defeated NPCs and make it available to the player."""
        if self.state != CombatState.PLAYER_VICTORY:
            return  # Only generate loot on player victory
        
        try:
            from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
            
            # Get state manager to access NPCs
            state_manager = engine._state_manager if hasattr(engine, '_state_manager') else None
            if not state_manager or not state_manager.current_state:
                logger.warning("Cannot generate loot: State manager unavailable")
                return
            
            game_state = state_manager.current_state
            available_loot = []
            loot_sources = []
            
            # Check each defeated enemy entity for loot
            for entity_id, entity in self.entities.items():
                if entity.entity_type == EntityType.ENEMY and not entity.is_alive():
                    # Try to get the NPC from the NPC system
                    npc = None
                    if hasattr(game_state, 'npc_system') and game_state.npc_system:
                        npc = game_state.npc_system.get_npc_by_id(entity_id)
                    
                    if npc and hasattr(npc, 'equipment_manager') and npc.equipment_manager:
                        # Extract equipment from defeated NPC
                        npc_loot = self._extract_npc_equipment(npc, entity.combat_name)
                        if npc_loot:
                            available_loot.extend(npc_loot)
                            loot_sources.append(entity.combat_name)
            
            # Store loot in game state for player to collect
            if available_loot:
                if not hasattr(game_state, 'available_loot'):
                    game_state.available_loot = []
                game_state.available_loot.extend(available_loot)
                
                # Generate loot message
                loot_count = len(available_loot)
                source_names = ", ".join(loot_sources)
                loot_message = f"Victory! Found {loot_count} item(s) from defeated enemies: {source_names}. Use 'loot' to examine available items."
                
                # Queue loot notification
                loot_event = DisplayEvent(
                    type=DisplayEventType.SYSTEM_MESSAGE,
                    content=loot_message,
                    target_display=DisplayTarget.COMBAT_LOG,
                    gradual_visual_display=False
                )
                engine._combat_orchestrator.add_event_to_queue(loot_event)
                
                logger.info(f"Generated {loot_count} loot items from {len(loot_sources)} defeated enemies")
            else:
                logger.debug("No loot generated from combat - no equipped items found on defeated enemies")
                
        except Exception as e:
            logger.error(f"Error generating combat loot: {e}", exc_info=True)
    
    def _extract_npc_equipment(self, npc, combat_name: str) -> List[Dict[str, Any]]:
        """Extract equipment from a defeated NPC as loot items."""
        loot_items = []
        
        try:
            if not hasattr(npc, 'equipment_manager') or not npc.equipment_manager:
                return loot_items
            
            # Get all equipped items
            equipped_items = npc.equipment_manager.equipment
            for slot, item in equipped_items.items():
                if item is not None:
                    # Create loot entry
                    from core.inventory.item_serialization import item_to_dict
                    loot_item = {
                        'item_data': item_to_dict(item),
                        'source': combat_name,
                        'source_type': 'defeated_enemy',
                        'slot': slot.value if hasattr(slot, 'value') else str(slot)
                    }
                    loot_items.append(loot_item)
                    logger.debug(f"Added {item.name} to loot from {combat_name}")
            
            # Clear the NPC's equipment (they're defeated)
            if loot_items:
                npc.equipment_manager.unequip_all()
                
        except Exception as e:
            logger.error(f"Error extracting equipment from NPC {combat_name}: {e}", exc_info=True)
        
        return loot_items
```

### File: core\combat\dev_commands.py

```python
#!/usr/bin/env python3
"""
Developer commands for the combat system.

This module provides developer commands for testing and debugging the combat system.
"""

import logging
from typing import Dict, List, Any, Optional, Union
import uuid

from core.base.commands import CommandProcessor, CommandResult
from core.base.state import GameState, get_state_manager
from core.interaction.enums import InteractionMode
from core.utils.logging_config import get_logger
from core.combat.combat_manager import CombatManager
from core.combat.combat_entity import CombatEntity, EntityType
from core.combat.combat_action import CombatAction, ActionType, AttackAction
from core.character.npc_system import NPCSystem
from core.stats.stats_base import StatType, DerivedStatType # Import specific types
from core.stats.stats_manager import get_stats_manager
# Import trigger_combat_narration from the new npc_interaction module
from core.game_flow.npc_interaction import trigger_combat_narration

# Get the module logger
logger = get_logger("GAME")

def register_combat_dev_commands(command_processor: CommandProcessor):
    """Register all combat-related developer commands."""
    
    command_processor.register_dev_command(
        name="start_combat",
        handler=dev_start_combat,
        syntax="//start_combat <enemy_template> [level] [count]",
        description="Start a combat encounter with specified enemies.",
        examples=[
            "start_combat bandit",
            "start_combat wolf 3",
            "start_combat goblin 2 3"
        ]
    )
    
    logger.info("Registered combat developer commands")
    

def create_player_combat_entity(game_state: GameState, combat_name: str) -> CombatEntity: 
    """Creates a CombatEntity for the player."""
    player_state = game_state.player
    stats_manager = get_stats_manager()

    max_hp = stats_manager.get_stat_value(DerivedStatType.MAX_HEALTH)
    max_mp = stats_manager.get_stat_value(DerivedStatType.MAX_MANA)
    max_stamina = stats_manager.get_stat_value(DerivedStatType.MAX_STAMINA)

    current_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
    current_mp = stats_manager.get_current_stat_value(DerivedStatType.MANA)
    current_stamina = stats_manager.get_current_stat_value(DerivedStatType.STAMINA)

    current_hp = min(current_hp, max_hp)
    current_mp = min(current_mp, max_mp)
    current_stamina = min(current_stamina, max_stamina)

    all_stats_dict = {stat_enum: stats_manager.get_stat_value(stat_enum) for stat_enum in stats_manager.stats}
    all_stats_dict.update({stat_enum: stats_manager.get_stat_value(stat_enum) for stat_enum in stats_manager.derived_stats})

    return CombatEntity(
        id=player_state.stats_manager_id or "player_default_id",
        name=player_state.name,
        combat_name=combat_name, #
        entity_type=EntityType.PLAYER,
        stats=all_stats_dict,
        current_hp=current_hp,
        max_hp=max_hp,
        current_mp=current_mp,
        max_mp=max_mp,
        current_stamina=current_stamina,
        max_stamina=max_stamina,
        description=f"{player_state.race} {player_state.path}"
    )

def create_enemy_combat_entity(npc, combat_name: str) -> CombatEntity:
    """Creates a CombatEntity for an enemy NPC."""
    if not hasattr(npc, 'stats_manager'):
        raise ValueError(f"NPC {getattr(npc, 'name', 'Unknown')} is missing a stats_manager.")

    stats_manager = npc.stats_manager

    max_hp = stats_manager.get_stat_value(DerivedStatType.MAX_HEALTH)
    max_mp = stats_manager.get_stat_value(DerivedStatType.MAX_MANA)
    max_stamina = stats_manager.get_stat_value(DerivedStatType.MAX_STAMINA)

    current_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
    current_mp = stats_manager.get_current_stat_value(DerivedStatType.MANA)
    # --- Corrected line for current_stamina ---
    current_stamina = stats_manager.get_current_stat_value(DerivedStatType.STAMINA)

    current_hp = min(current_hp, max_hp)
    current_mp = min(current_mp, max_mp)
    current_stamina = min(current_stamina, max_stamina) # Ensure current stamina doesn't exceed max

    all_stats_dict = {stat_enum: stats_manager.get_stat_value(stat_enum) for stat_enum in stats_manager.stats}
    all_stats_dict.update({stat_enum: stats_manager.get_stat_value(stat_enum) for stat_enum in stats_manager.derived_stats})


    return CombatEntity(
        id=npc.id,
        name=npc.name,
        combat_name=combat_name, 
        entity_type=EntityType.ENEMY,
        stats=all_stats_dict,
        current_hp=current_hp,
        max_hp=max_hp,
        current_mp=current_mp,
        max_mp=max_mp,
        current_stamina=current_stamina,
        max_stamina=max_stamina,
        description=getattr(npc, 'description', '')
    )

def dev_start_combat(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Initiates combat mode with specified enemies.
    """
    if game_state.current_mode == InteractionMode.COMBAT:
        return CommandResult.failure("Already in combat.")

    if not args:
        return CommandResult.invalid("Specify enemy template: //start_combat <template> [level] [count]")

    enemy_template = args[0]
    level = int(args[1]) if len(args) > 1 else 1
    count = int(args[2]) if len(args) > 2 else 1

    try:
        state_manager = get_state_manager()
        npc_system = state_manager.get_npc_system()
        if not npc_system:
            logger.warning("NPCSystem not found in StateManager, attempting to create fallback.")
            from core.character.npc_system import NPCSystem
            npc_system = NPCSystem()
            state_manager.set_npc_system(npc_system)

        enemy_npcs = []
        # --- Temporary list to hold created NPCs before assigning combat names ---
        temp_enemy_npcs = []
        for i in range(count):
            enemy_name = f"{enemy_template.capitalize()} {i+1}" if count > 1 else enemy_template.capitalize()
            try:
                enemy_npc = npc_system.create_enemy_for_combat(
                    name=enemy_name, # Use potentially non-unique name for creation
                    enemy_type=enemy_template,
                    level=level,
                    location=game_state.player.current_location
                )
                if enemy_npc and hasattr(enemy_npc, 'id'):
                    temp_enemy_npcs.append(enemy_npc) # Add to temp list
                else:
                    logger.error(f"Failed to create or get ID for enemy NPC: {enemy_name}")
            except Exception as creation_error:
                logger.error(f"Error creating enemy NPC '{enemy_name}': {creation_error}", exc_info=True)
                return CommandResult.error(f"Error creating enemy NPC '{enemy_name}': {creation_error}")

        if not temp_enemy_npcs:
            return CommandResult.error(f"Could not create any enemy NPCs with template '{enemy_template}'.")

        # --- Create Player Combat Entity (determine combat_name first) ---
        player_id = getattr(game_state.player, 'id', getattr(game_state.player, 'stats_manager_id', 'player_default_id'))
        player_combat_name = game_state.player.name # Start with player name
        # Check against potential enemy names *before* numbering enemies
        initial_enemy_names = {npc.name for npc in temp_enemy_npcs}
        if player_combat_name in initial_enemy_names:
             player_combat_name += " (Player)" # Append clarification if name clashes
        try:
            player_entity = create_player_combat_entity(game_state, player_combat_name) # Pass name
        except ValueError as e:
            logger.error(f"Error retrieving player stats: {e}")
            return CommandResult.error(f"Failed to get player stats for combat: {e}")

        # --- Generate Unique Combat Names and Create Enemy Entities ---
        enemy_entities = []
        name_counts: Dict[str, int] = {}
        # Initialize counts based on existing names (including player)
        all_combat_names_so_far = {player_entity.combat_name}

        for npc in temp_enemy_npcs:
            base_name = npc.name
            combat_name = base_name
            if base_name in name_counts:
                name_counts[base_name] += 1
                combat_name = f"{base_name} {name_counts[base_name]}"
            else:
                name_counts[base_name] = 1
                # Initial assignment is base_name

            # Final uniqueness check against *all* names assigned so far
            final_name = combat_name
            final_count = 1
            while final_name in all_combat_names_so_far:
                 final_count = name_counts[base_name] + 1 # Increment based on original count
                 final_name = f"{base_name} {final_count}"
                 name_counts[base_name] = final_count # Update count for next potential collision

            # Assign the unique name and create entity
            try:
                enemy_entity = create_enemy_combat_entity(npc, final_name) # Pass unique name
                enemy_entities.append(enemy_entity)
                all_combat_names_so_far.add(final_name) # Add to set for uniqueness check
            except Exception as e:
                logger.error(f"Error creating combat entity for {npc.name} ({final_name}): {e}", exc_info=True)
                # Optionally decide whether to skip this enemy or halt combat start

        if not enemy_entities:
             return CommandResult.error(f"Failed to create combat entities for enemies.")


        # --- Initialize Combat Manager ---
        combat_manager = CombatManager()
        # Pass entities that *now have combat_name assigned*
        combat_manager.start_combat(player_entity, enemy_entities)

        # --- Update Game State ---
        game_state.combat_manager = combat_manager
        game_state.current_combatants = [e.id for e in [player_entity] + enemy_entities]
        game_state.set_interaction_mode(InteractionMode.COMBAT)

        enemy_names_display = ', '.join(e.combat_name for e in enemy_entities) # Use combat names
        logger.info(f"Initiating COMBAT mode. Player ({player_entity.combat_name}) vs Enemies: {enemy_names_display} ([{', '.join(e.id for e in enemy_entities)}])")
        logger.info(f"CombatManager created and assigned to GameState. Round: {combat_manager.round_number}")

        from core.base.engine import get_game_engine
        engine = get_game_engine()
        trigger_combat_narration(engine, game_state)

        return CommandResult.success(
            f"Combat initiated! {player_entity.combat_name} vs {enemy_names_display}. Entering combat mode."
        )

    except Exception as e:
        logger.error(f"Error starting combat via dev command: {e}", exc_info=True)
        return CommandResult.error(f"Failed to start combat: {str(e)}")

```

### File: core\combat\enums.py

```python
from enum import Enum, auto

class CombatState(Enum):
    """Possible states of combat."""
    NOT_STARTED = auto()
    IN_PROGRESS = auto()
    PLAYER_VICTORY = auto()
    PLAYER_DEFEAT = auto()
    FLED = auto()

class CombatStep(Enum):
    NOT_STARTED = auto()
    AWAITING_TRANSITION_DATA = auto() # New step for data arrival
    STARTING_COMBAT = auto()
    HANDLING_SURPRISE_CHECK = auto()
    PERFORMING_SURPRISE_ATTACK = auto()
    NARRATING_SURPRISE_OUTCOME = auto()
    ENDING_SURPRISE_ROUND = auto()
    ROLLING_INITIATIVE = auto()
    STARTING_ROUND = auto()
    AWAITING_PLAYER_INPUT = auto()
    PROCESSING_PLAYER_ACTION = auto()
    AWAITING_NPC_INTENT = auto()
    PROCESSING_NPC_ACTION = auto()
    RESOLVING_ACTION_MECHANICS = auto()
    NARRATING_ACTION_OUTCOME = auto()
    APPLYING_STATUS_EFFECTS = auto()
    ADVANCING_TURN = auto()
    ENDING_COMBAT = auto()
    COMBAT_ENDED = auto()
```

### File: core\game_flow\__init__.py

```python
# This file makes the core/game_flow directory a Python package.

```

### File: core\game_flow\command_handlers.py

```python
"""
Handles the execution of specific direct commands (e.g., /save, /quit, mode changes).
"""

import logging
from typing import List, TYPE_CHECKING, Optional

from core.base.commands import CommandResult
from core.interaction.enums import InteractionMode
from core.utils.logging_config import get_logger
from core.inventory import get_inventory_manager, EquipmentSlot, get_item_factory # Added EquipmentSlot, get_item_factory

if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState

# Get the module logger
logger = get_logger("COMMAND_HANDLERS")

# --- Special LLM Command Handlers ---

def handle_mode_transition(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the MODE_TRANSITION command from LLM output.

    Format is: target_mode:origin_mode:surprise:target_entity_id:reason
    """
    logger.info(f"Handling mode transition command with args: {args}")
    if not args:
        return CommandResult.invalid("MODE_TRANSITION command requires arguments.")

    # Parse the arguments string
    arg_str = args[0]
    parts = arg_str.split(":", 4)  # Allow up to 5 parts
    
    if len(parts) < 2:
        return CommandResult.invalid("MODE_TRANSITION requires at least target_mode and origin_mode.")
    
    # Extract the parts
    target_mode_str = parts[0].upper()
    origin_mode_str = parts[1].upper()
    surprise = parts[2].lower() == "true" if len(parts) > 2 else False
    target_entity_id = parts[3] if len(parts) > 3 and parts[3] else None
    reason = parts[4] if len(parts) > 4 else "Mode transition requested."
    
    logger.info(f"Mode transition requested: {origin_mode_str} -> {target_mode_str} (Surprise: {surprise}, Target: {target_entity_id}, Reason: {reason})")
    
    # Create a structured request for the mode transition handler
    request = {
        "target_mode": target_mode_str,
        "origin_mode": origin_mode_str,
        "surprise": surprise,
        "target_entity_id": target_entity_id,
        "reason": reason
    }
    
    # Import the handler directly
    from core.game_flow.mode_transitions import _handle_transition_request
    
    # Get the actor ID (typically the player)
    actor_id = getattr(game_state.player, 'id', getattr(game_state.player, 'stats_manager_id', 'player_default_id'))
    
    # Call the transition handler
    narrative_result = _handle_transition_request(engine, game_state, request, actor_id)
    
    # Return the result
    return CommandResult.success(narrative_result or "Mode transition processed.")


def handle_start_trade(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /start_trade command."""
    if len(args) < 1:
        return CommandResult.invalid("Usage: /start_trade <npc_id>")
    npc_id = args[0]
    # TODO: Add validation here to check if npc_id exists and is tradeable
    logger.info(f"Initiating trade with NPC: {npc_id}")
    game_state.current_trade_partner_id = npc_id
    game_state.set_interaction_mode(InteractionMode.TRADE)
    engine._output("system", f"Starting trade with {npc_id}.")
    # TODO: Trigger initial trade narration/UI update
    return CommandResult.success(f"Starting trade with {npc_id}.")

def handle_start_social(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /start_social command."""
    if len(args) < 1:
        return CommandResult.invalid("Usage: /start_social <npc_id>")
    npc_id = args[0]
    # TODO: Add validation here to check if npc_id exists and can enter social conflict
    logger.info(f"Initiating social conflict with NPC: {npc_id}")
    player_id = getattr(game_state.player, 'id', None)
    if player_id is None:
        logger.error("Player ID not found in game state for social conflict.")
        return CommandResult.error("Internal error: Player ID missing.")
    # TODO: Initialize social conflict state properly (e.g., setting resolve)
    game_state.current_combatants = [player_id, npc_id] # Using combatants for now
    game_state.set_interaction_mode(InteractionMode.SOCIAL_CONFLICT)
    engine._output("system", f"Starting social conflict with {npc_id}.")
    # TODO: Trigger initial social conflict narration/UI update
    return CommandResult.success(f"Starting social conflict with {npc_id}.")

def handle_end_combat(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /end_combat command."""
    if game_state.current_mode != InteractionMode.COMBAT:
        return CommandResult.invalid("Not currently in combat.")
    logger.info("Ending combat mode.")
    # TODO: Add combat cleanup logic (rewards, status effects removal?)
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
    engine._output("system", "Combat ended.")
    return CommandResult.success("Combat ended.")

def handle_leave_trade(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /leave_trade command."""
    if game_state.current_mode != InteractionMode.TRADE:
        return CommandResult.invalid("Not currently trading.")
    logger.info("Ending trade mode.")
    # TODO: Add trade finalization logic?
    game_state.current_trade_partner_id = None
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
    engine._output("system", "Trade concluded.")
    return CommandResult.success("Trade concluded.")

def handle_end_social(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles the /end_social command."""
    if game_state.current_mode != InteractionMode.SOCIAL_CONFLICT:
        return CommandResult.invalid("Not currently in social conflict.")
    logger.info("Ending social conflict mode.")
    # TODO: Add social conflict resolution logic
    game_state.current_combatants = [] # Clear participants
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
    engine._output("system", "Social conflict resolved.")
    return CommandResult.success("Social conflict resolved.")

def _handle_equip_command(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles direct 'equip' commands."""
    if not args:
        return CommandResult.invalid("Usage: equip <item_id_or_name> [slot_name]")
    
    inventory_manager = get_inventory_manager()
    item_identifier = args[0]
    preferred_slot_str: Optional[str] = args[1] if len(args) > 1 else None
    preferred_slot_enum: Optional[EquipmentSlot] = None

    if preferred_slot_str:
        try:
            preferred_slot_enum = EquipmentSlot(preferred_slot_str.lower().replace(" ", "_"))
        except ValueError:
            return CommandResult.invalid(f"Invalid slot name: {preferred_slot_str}. Valid slots are: {', '.join([s.value for s in EquipmentSlot])}")

    item = inventory_manager.get_item(item_identifier)
    if not item: # Try finding by name
        found_items = inventory_manager.find_items(name=item_identifier) # Basic name search
        if found_items:
            item = found_items[0] # Take the first match for simplicity
            logger.info(f"Found item '{item.name}' by name for equip command.")
        else:
            return CommandResult.failure(f"Item '{item_identifier}' not found in inventory.")

    if not item.is_equippable:
        return CommandResult.failure(f"Item '{item.name}' is not equippable.")

    if inventory_manager.equip_item(item.id, preferred_slot_enum):
        # Determine the actual slot it was equipped to for the message
        equipped_slot_str = "a suitable slot"
        for slot_enum_loop, item_id_loop in inventory_manager.equipment.items():
            if item_id_loop == item.id:
                equipped_slot_str = slot_enum_loop.value.replace("_", " ")
                break
        return CommandResult.success(f"Equipped {item.name} to {equipped_slot_str}.")
    else:
        return CommandResult.failure(f"Could not equip {item.name}. Check available slots or item requirements.")

def _handle_unequip_command(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles direct 'unequip' commands."""
    if not args:
        return CommandResult.invalid("Usage: unequip <slot_name_or_item_id_or_item_name>")
    
    inventory_manager = get_inventory_manager()
    identifier = args[0]
    
    # Try to interpret as slot first
    try:
        slot_to_unequip = EquipmentSlot(identifier.lower().replace(" ", "_"))
        item_id_in_slot = inventory_manager.equipment.get(slot_to_unequip)
        if not item_id_in_slot:
            return CommandResult.failure(f"No item equipped in {slot_to_unequip.value.replace('_', ' ')}.")
        
        item_name = inventory_manager.get_item(item_id_in_slot).name if item_id_in_slot else "Unknown item"
        if inventory_manager.unequip_item(slot_to_unequip):
            return CommandResult.success(f"Unequipped {item_name} from {slot_to_unequip.value.replace('_', ' ')}.")
        else: # Should not happen if item_id_in_slot was found
            return CommandResult.error(f"Failed to unequip item from {slot_to_unequip.value.replace('_', ' ')}.")

    except ValueError: # Not a valid slot name, try as item ID or name
        item_to_unequip = inventory_manager.get_item(identifier)
        if not item_to_unequip: # Try by name
            found_items = inventory_manager.find_items(name=identifier)
            if found_items:
                item_to_unequip = found_items[0]
            else:
                return CommandResult.failure(f"Item '{identifier}' not found equipped or in inventory to identify.")
        
        if not item_to_unequip: # Still not found
            return CommandResult.failure(f"Item '{identifier}' not found.")

        # Find which slot it's equipped in
        slot_equipped_in: Optional[EquipmentSlot] = None
        for slot_enum_loop, item_id_loop in inventory_manager.equipment.items():
            if item_id_loop == item_to_unequip.id:
                slot_equipped_in = slot_enum_loop
                break
        
        if not slot_equipped_in:
            return CommandResult.failure(f"{item_to_unequip.name} is not currently equipped.")
            
        if inventory_manager.unequip_item(slot_equipped_in):
            return CommandResult.success(f"Unequipped {item_to_unequip.name} from {slot_equipped_in.value.replace('_', ' ')}.")
        else:
            return CommandResult.error(f"Failed to unequip {item_to_unequip.name}.")

# --- Main Direct Command Dispatch ---

MODE_TRANSITION_COMMANDS = {
    "start_trade": handle_start_trade,
    "start_social": handle_start_social,
    "end_combat": handle_end_combat,
    "leave_trade": handle_leave_trade,
    "end_social": handle_end_social,
    "equip": _handle_equip_command,
    "unequip": _handle_unequip_command,
    # Add other mode transition commands here
}

# --- LLM Command Mapping ---

LLM_COMMAND_HANDLERS = {
    "MODE_TRANSITION": handle_mode_transition,
    "QUEST_UPDATE": None,   # placeholders; set below after function defs
    "QUEST_STATUS": None,
    "STATE_CHANGE": None,
}

def _parse_single_json_arg(args: List[str]) -> dict:
    try:
        import json
        if not args:
            return {}
        payload = args[0]
        if isinstance(payload, dict):
            return payload
        return json.loads(payload)
    except Exception:
        return {}


def _handle_quest_update(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles QUEST_UPDATE command with a JSON payload from LLM.
    Payload schema: {"quest_id","objective_id","new_status","confidence", "evidence": [...]}
    """
    payload = _parse_single_json_arg(args)
    try:
        from core.game_flow.quest_updates import apply_objective_update_from_llm
        ok, msg = apply_objective_update_from_llm(engine, game_state, payload)
        return CommandResult.success(msg) if ok else CommandResult.failure(msg)
    except Exception as e:
        return CommandResult.error(f"Quest update error: {e}")


def _handle_quest_status(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handles QUEST_STATUS command with a JSON payload from LLM.
    Payload schema: {"quest_id","new_status","confidence","evidence": [...]}"""
    payload = _parse_single_json_arg(args)
    try:
        from core.game_flow.quest_updates import apply_quest_status_from_llm
        ok, msg = apply_quest_status_from_llm(engine, game_state, payload)
        return CommandResult.success(msg) if ok else CommandResult.failure(msg)
    except Exception as e:
        return CommandResult.error(f"Quest status error: {e}")


def _handle_state_change(engine: 'GameEngine', game_state: 'GameState', args: List[str]) -> CommandResult:
    """Handle STATE_CHANGE requests from the LLM.

    Supports at least inventory mutations via JSON payload with schema similar to:
      {
        "action": "request_state_change",
        "target_id": "player",     # normalized by AgentManager
        "attribute": "inventory",   # or other attributes like stamina (acknowledged only)
        "change_type": "add",       # add|remove|drop|consume
        "quantity": 1,
        "template_id": "test_apple" # or item_template | item_id | item_spec
      }
    Fallback colon format is also parsed: target:attribute:change_type:value:item_identifier
    """
    import json as _json

    # Try JSON payload first
    payload = _parse_single_json_arg(args)

    if not payload:
        # Fallback: parse colon-delimited string
        arg_str = args[0] if args else ""
        parts = arg_str.split(":") if arg_str else []
        payload = {
            "target_id": parts[0] if len(parts) > 0 else None,
            "attribute": parts[1] if len(parts) > 1 else None,
            "change_type": parts[2] if len(parts) > 2 else None,
            "value": parts[3] if len(parts) > 3 else None,
            "item_id": parts[4] if len(parts) > 4 else None,
        }

    attribute = (payload.get("attribute") or "").lower()

    if attribute == "inventory":
        try:
            inventory = get_inventory_manager()
            item_factory = get_item_factory()

            change_type = (payload.get("change_type") or payload.get("change") or "add").lower()

            # Quantity may be specified as 'quantity' or (poorly) as 'value'
            q_raw = payload.get("quantity", payload.get("value", 1))
            try:
                quantity = int(q_raw)
            except Exception:
                quantity = 1
            if quantity <= 0:
                quantity = 1

            if change_type in ("add", "give", "pickup", "obtain", "create"):
                item_obj = None
                # Prefer explicit item_spec if provided
                item_spec = payload.get("item_spec") or payload.get("item_data")
                if isinstance(item_spec, dict):
                    try:
                        item_obj = item_factory.create_item_from_spec(item_spec)
                    except Exception as e:
                        logger.warning(f"STATE_CHANGE inventory add: invalid item_spec: {e}")

                if item_obj is None:
                    # template id options
                    template_id = payload.get("template_id") or payload.get("item_template")
                    # if item_id references an existing inventory item, use it as prototype
                    ref_item_id = payload.get("item_id")
                    if ref_item_id:
                        existing = inventory.get_item(ref_item_id)
                        if existing:
                            item_obj = existing
                        elif not template_id:
                            template_id = ref_item_id  # treat as template id fallback

                    if item_obj is None and template_id:
                        item_obj = item_factory.create_item_from_template(template_id, variation=False)

                if item_obj is None:
                    # Last resort: try by name among inventory (not ideal for new items)
                    item_name = payload.get("item_name") or payload.get("name")
                    if item_name:
                        found = inventory.find_items(name=item_name)
                        if found:
                            item_obj = found[0]

                if item_obj is None:
                    return CommandResult.failure("STATE_CHANGE inventory add: could not resolve item to add.")

                added_ids = inventory.add_item(item_obj, quantity=quantity)
                if not added_ids:
                    return CommandResult.failure(f"Could not add {quantity}x {getattr(item_obj, 'name', 'item')}.")
                return CommandResult.success(f"Added {quantity}x {item_obj.name} to inventory.")

            elif change_type in ("remove", "drop", "discard", "consume", "delete"):
                target_item = None
                # Identify target by item_id, template_id, or name
                ref_item_id = payload.get("item_id")
                if ref_item_id:
                    target_item = inventory.get_item(ref_item_id)

                if not target_item:
                    template_id = payload.get("template_id") or payload.get("item_template")
                    if template_id:
                        # Search inventory by template_id
                        for it in getattr(inventory, "_items", {}).values():
                            if getattr(it, "template_id", None) == template_id:
                                target_item = it
                                break

                if not target_item:
                    item_name = payload.get("item_name") or payload.get("name")
                    if item_name:
                        found = inventory.find_items(name=item_name)
                        if found:
                            target_item = found[0]

                if not target_item:
                    return CommandResult.failure("STATE_CHANGE inventory remove: target item not found in inventory.")

                ok = inventory.remove_item(target_item.id, quantity)
                return CommandResult.success(f"Removed {quantity}x {target_item.name} from inventory.") if ok else CommandResult.failure(f"Failed to remove {quantity}x {target_item.name}.")
            else:
                return CommandResult.invalid(f"STATE_CHANGE inventory: unsupported change_type '{change_type}'.")
        except Exception as e:
            logger.exception("STATE_CHANGE inventory error")
            return CommandResult.error(f"Inventory state change error: {e}")

    elif attribute == "location":
        # Developer-only direct location change for test convenience
        try:
            from PySide6.QtCore import QSettings
            q = QSettings("RPGGame", "Settings")
            dev_enabled = bool(q.value("dev/enabled", False, type=bool) or q.value("dev/quest_verbose", False, type=bool))
        except Exception:
            dev_enabled = False

        location_id = str(payload.get("value") or payload.get("location") or "").strip()
        logger.debug(f"STATE_CHANGE location requested -> '{location_id}', dev_enabled={dev_enabled}")

        if not location_id:
            return CommandResult.invalid("STATE_CHANGE location: missing 'value'.")

        if not dev_enabled:
            explanation = None
            try:
                if hasattr(engine, "_rule_checker") and engine._rule_checker is not None:
                    from core.agents.base_agent import AgentContext
                    from core.interaction.context_builder import ContextBuilder
                    from core.interaction.enums import InteractionMode
                    ctx = ContextBuilder().build_context(game_state, InteractionMode.NARRATIVE, actor_id="player")
                    validation_input = f"STATE_CHANGE location -> {location_id} (request denied in normal play)"
                    agent_ctx = AgentContext(
                        game_state=ctx,
                        player_state=ctx.get("player", {}),
                        world_state={
                            "location": ctx.get("location"),
                            "time_of_day": ctx.get("time_of_day"),
                            "environment": ctx.get("environment"),
                        },
                        player_input=validation_input,
                        conversation_history=getattr(game_state, "conversation_history", []),
                        relevant_memories=[],
                        additional_context=ctx,
                    )
                    is_valid, reason = engine._rule_checker.validate_action(agent_ctx)
                    if not is_valid and reason:
                        explanation = reason
            except Exception:
                pass
            if not explanation:
                explanation = "developer-only teleportation is disabled in normal play"
            return CommandResult.failure(f"This action is not permitted - {explanation}.")

        try:
            game_state.player.current_location = location_id
            if hasattr(game_state, "world"):
                game_state.world.current_location = location_id
            try:
                from core.game_flow.event_log import record_location_visited
                record_location_visited(game_state, location_id=location_id)
            except Exception:
                pass
            logger.info(f"STATE_CHANGE location applied (dev): {location_id}")
            return CommandResult.success(f"Location set to {location_id} (dev).")
        except Exception as e:
            logger.exception("STATE_CHANGE location error")
            return CommandResult.error(f"Failed to change location: {e}")

    # Non-inventory attributes: acknowledge but do not apply mechanics here unless explicitly supported
    return CommandResult.invalid(f"STATE_CHANGE not supported for attribute '{attribute}'.")
def process_llm_command(engine: 'GameEngine', command: str, args: List[str], game_state: 'GameState') -> CommandResult:
    """Process a command from the LLM output.
    
    Args:
        engine: The GameEngine instance.
        command: The command name (e.g., MODE_TRANSITION, STAT_CHECK)
        args: The command arguments
        game_state: The current game state
        
    Returns:
        The result of processing the command
    """
    logger.info(f"Processing LLM command: {command} with args: {args}")
    
    # Check if command is in our LLM command handlers
    if command.upper() in LLM_COMMAND_HANDLERS:
        handler = LLM_COMMAND_HANDLERS[command.upper()]
        if handler is None:
            return CommandResult.error(f"Handler not initialized for {command}")
        return handler(engine, game_state, args)
    else:
        # Fall back to CommandProcessor for unknown commands
        logger.warning(f"Unknown LLM command: {command}, falling back to CommandProcessor")
        cmd_args_str = " ".join(args) if args else ""
        result = engine._command_processor.process_llm_commands(game_state, f"{{{command} {cmd_args_str}}}")
        # Return a simple CommandResult from the tuple returned by process_llm_commands
        if isinstance(result, tuple) and len(result) == 2:
            return CommandResult.success(result[0])
        return CommandResult.success("Command processed.")

def process_direct_command(engine: 'GameEngine', command_text: str) -> CommandResult:
    """
    Process a direct command (e.g., starting with '/', 'command:', or '//').

    This function determines if it's a mode transition or should be passed
    to the core CommandProcessor.

    Args:
        engine: The GameEngine instance.
        command_text: The command text to process (without the leading '/' or 'command:').

    Returns:
        The result of executing the command.
    """
    current_state = engine._state_manager.current_state
    if current_state is None:
        return CommandResult.error("No game in progress.")

    # Handle developer commands separately first if needed
    if command_text.startswith('//'):
        logger.debug(f"Processing developer command: {command_text}")
        # Delegate directly to CommandProcessor for dev commands
        result = engine._command_processor.process_command(current_state, command_text)
        # Dev commands typically handle their own output via CommandProcessor registration
        return result

    # Parse command and arguments for regular direct commands
    parts = command_text.split()
    if not parts: # Handle empty command after stripping prefix
        return CommandResult.invalid("Empty command received.")
        
    command_verb = parts[0].lower() # Use verb for dictionary lookup
    args = parts[1:]

    # Check if it's a mode transition command handled here
    if command_verb in MODE_TRANSITION_COMMANDS:
        handler = MODE_TRANSITION_COMMANDS[command_verb]
        result = handler(engine, current_state, args)
        # Mode transition handlers (like equip/unequip) might return messages
        # that should NOT be outputted if they are purely mechanical UI feedback.
        # The individual handlers should decide if their message is for internal logging or UI.
        # For equip/unequip, they are now silent.
        if result.message and command_verb not in ["equip", "unequip"]: # Don't output for equip/unequip
            engine._output("system", result.message)
        return result
    else:
        # Otherwise, delegate to the core CommandProcessor
        logger.debug(f"Delegating direct command to CommandProcessor: {command_text}")
        result = engine._command_processor.process_command(current_state, command_text)

        # Handle side effects like exit
        if result.is_exit:
            logger.info("Exit command received via CommandProcessor")
            engine._running = False # Signal engine to stop

        # Output the result message from CommandProcessor if one exists,
        # unless it's a command that should not have direct output (like a UI-proxied drop before LLM)
        if result.message:
            # Check if the original command was a UI-proxied drop.
            # If so, and drop_command returned a message, suppress it here because LLM handles output.
            is_ui_drop_command = command_verb == "drop" and any('-' in arg for arg in args)
            
            if not (is_ui_drop_command and result.is_success): # Don't output success of mechanical drop if UI initiated and LLM handles narrative
                output_role = "gm" if result.is_success else "system"
                engine._output(output_role, result.message)

        return result

# Initialize handlers now that functions are defined
LLM_COMMAND_HANDLERS["QUEST_UPDATE"] = _handle_quest_update
LLM_COMMAND_HANDLERS["QUEST_STATUS"] = _handle_quest_status
LLM_COMMAND_HANDLERS["STATE_CHANGE"] = _handle_state_change

```

### File: core\game_flow\command_router.py

```python
#!/usr/bin/env python3
"""
Handles routing of player commands based on game mode and input type.

This module now serves as a compatibility layer that delegates to InputRouter.
"""

from typing import TYPE_CHECKING

from core.base.commands import CommandResult
from core.utils.logging_config import get_logger
from core.game_flow.input_router import get_input_router

if TYPE_CHECKING:
    from core.base.engine import GameEngine

# Get the module logger
logger = get_logger("COMMAND_ROUTER")

def route_command(engine: 'GameEngine', command_text: str) -> CommandResult:
    """
    Process a command by routing it based on game state and input type.
    This function is now a compatibility wrapper for InputRouter.
    
    Args:
        engine: The GameEngine instance.
        command_text: The raw command text from the player.

    Returns:
        The result of executing the command.
    """
    logger.debug(f"Routing raw input (legacy): '{command_text}'")
    logger.warning("route_command is deprecated - use InputRouter.route_input directly")
    
    # Use InputRouter for processing
    input_router = get_input_router()
    return input_router.route_input(engine, command_text)

```

### File: core\game_flow\event_log.py

```python
#!/usr/bin/env python3
"""
Event log utilities for recording game-time receipts of player/world actions.
"""
from __future__ import annotations
from typing import Dict, Any, Optional

from core.utils.logging_config import get_logger

logger = get_logger("EVENT_LOG")

# Event types (string constants to keep it simple and JSON-friendly)
EV_ENEMY_DEFEATED = "EnemyDefeated"
EV_ITEM_DELTA = "ItemDelta"
EV_LOCATION_VISITED = "LocationVisited"
EV_DIALOGUE = "DialogueCompleted"
EV_INTERACTION = "InteractionCompleted"
EV_FLAG_SET = "FlagSet"
EV_OBJECTIVE_STATUS = "ObjectiveStatusChange"
EV_QUEST_STATUS = "QuestStatusChange"


def _append(game_state, event: Dict[str, Any]) -> None:
    try:
        if not hasattr(game_state, 'event_log') or not isinstance(game_state.event_log, list):
            game_state.event_log = []
        game_state.event_log.append(event)
    except Exception as e:
        logger.warning(f"Failed to append event: {e}")
        return

    # Phase 1: trigger quest evaluation after appending relevant events
    try:
        from core.base.engine import get_game_engine
        from core.game_flow.quest_updates import process_event_for_quests
        engine = get_game_engine()
        if engine is not None:
            process_event_for_quests(engine, game_state, event)
    except Exception as e:
        # Non-fatal: continue
        logger.debug(f"Quest evaluation hook error (ignored): {e}")


def record_enemy_defeated(game_state, *, entity_id: str, template_id: Optional[str], tags: Dict[str, Any], location_id: Optional[str]) -> None:
    ev = {
        'type': EV_ENEMY_DEFEATED,
        'entity_id': entity_id,
        'template_id': template_id,
        'tags': tags or {},
        'location_id': location_id,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_item_delta(game_state, *, item_id: str, delta: int, source: str) -> None:
    ev = {
        'type': EV_ITEM_DELTA,
        'item_id': item_id,
        'delta': int(delta),
        'source': source,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_location_visited(game_state, *, location_id: str) -> None:
    ev = {
        'type': EV_LOCATION_VISITED,
        'location_id': location_id,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_dialogue(game_state, *, dialogue_id: str, npc_id: Optional[str] = None) -> None:
    ev = {
        'type': EV_DIALOGUE,
        'dialogue_id': dialogue_id,
        'npc_id': npc_id,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_interaction(game_state, *, interaction_id: str, meta: Optional[Dict[str, Any]] = None) -> None:
    ev = {
        'type': EV_INTERACTION,
        'interaction_id': interaction_id,
        'meta': meta or {},
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_flag_set(game_state, *, key: str, value: Any) -> None:
    ev = {
        'type': EV_FLAG_SET,
        'key': key,
        'value': value,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_objective_status(game_state, *, quest_id: str, objective_id: str, new_status: str) -> None:
    ev = {
        'type': EV_OBJECTIVE_STATUS,
        'quest_id': quest_id,
        'objective_id': objective_id,
        'new_status': new_status,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


def record_quest_status(game_state, *, quest_id: str, new_status: str) -> None:
    ev = {
        'type': EV_QUEST_STATUS,
        'quest_id': quest_id,
        'new_status': new_status,
        'game_time': getattr(game_state.world, 'game_time', 0.0),
    }
    _append(game_state, ev)


```

### File: core\game_flow\game_flow_utils.py

```python
#!/usr/bin/env python3
"""
Utility functions for game flow modules.
"""

import logging
from typing import Optional, Any

from core.base.state import GameState
from core.interaction.enums import InteractionMode
from core.character.npc_base import NPC # Moved from local import

# Get the module logger
logger = logging.getLogger("GAME_FLOW_UTILS")

def get_participant_by_id(game_state: 'GameState', entity_id: str, try_fuzzy_match: bool = True) -> Optional[Any]: # Use Any for broader compatibility
    """Helper to find a participant (player or NPC/CombatEntity) by ID.
    
    Args:
        game_state: The current game state
        entity_id: The ID or name of the entity to find
        try_fuzzy_match: If True, attempt fuzzy matching if exact match fails
    
    Returns:
        The found entity or None if not found
    """
    logger.debug(f"Attempting to find participant with ID: {entity_id}")

    # Check for special case 'player' id string
    if entity_id == 'player' and game_state.player:
        logger.debug(f"Found participant '{entity_id}' as player")
        return game_state.player

    # Check if it matches player's actual ID
    if game_state.player and getattr(game_state.player, 'id', None) == entity_id:
        logger.debug(f"Found participant '{entity_id}' matching player ID")
        return game_state.player
    
    # Check if it matches player's name (case insensitive)
    player_name = getattr(game_state.player, 'name', '')
    if player_name and player_name.lower() == entity_id.lower():
        logger.debug(f"Found participant '{entity_id}' matching player name")
        return game_state.player

    # Check combat manager entities first if in combat
    if game_state.current_mode == InteractionMode.COMBAT and game_state.combat_manager:
        try:
            # Try exact match first
            participant = game_state.combat_manager.get_entity_by_id(entity_id)
            if participant:
                logger.debug(f"Found entity {entity_id} in combat manager")
                return participant
            
            # Try to match by name if exact ID match failed
            for eid, entity in game_state.combat_manager.entities.items():
                entity_name = getattr(entity, 'name', '')
                if entity_name and entity_name.lower() == entity_id.lower():
                    logger.debug(f"Found entity with name '{entity_id}' in combat manager (ID: {eid})")
                    return entity
        except Exception as e:
            logger.error(f"Error getting entity from combat manager: {e}")
            # Continue to other lookup methods if this fails

    # Check current location for NPCs by ID
    current_location = None
    if hasattr(game_state, 'player') and hasattr(game_state.player, 'current_location'):
        current_location = game_state.player.current_location
    
    if current_location and hasattr(game_state, 'world') and hasattr(game_state.world, 'get_location'):
        try:
            location = game_state.world.get_location(current_location)
            if location and hasattr(location, 'npcs') and location.npcs:
                # Try exact match on ID first
                for npc in location.npcs:
                    if getattr(npc, 'id', '') == entity_id:
                        logger.debug(f"Found NPC '{entity_id}' in current location")
                        return npc
                    
                # Try name match
                for npc in location.npcs:
                    if getattr(npc, 'name', '').lower() == entity_id.lower():
                        logger.debug(f"Found NPC with name '{entity_id}' in current location")
                        return npc
        except Exception as e:
            logger.error(f"Error getting NPCs from current location: {e}")

    # Check current_combatants (used for social conflict)
    if hasattr(game_state, 'current_combatants') and entity_id in game_state.current_combatants:
         # Need a way to get the actual NPC/Player object from the ID
         if game_state.player and getattr(game_state.player, 'id', None) == entity_id:
             logger.debug(f"Found participant '{entity_id}' in current_combatants (matches player ID)")
             return game_state.player
         # Option 2: Check NPC manager/system
         if hasattr(game_state, 'npc_system') and game_state.npc_system:
             if hasattr(game_state.npc_system, 'get_npc_by_id'):
                 npc = game_state.npc_system.get_npc_by_id(entity_id)
                 if npc:
                     logger.debug(f"Found participant '{entity_id}' in current_combatants (via NPC system)")
                     return npc
             # Try to find by name if get_npc_by_id exists
             if hasattr(game_state.npc_system, 'get_npcs') and try_fuzzy_match:
                 try:
                     all_npcs = game_state.npc_system.get_npcs()
                     for npc in all_npcs:
                         if getattr(npc, 'name', '').lower() == entity_id.lower():
                             logger.debug(f"Found NPC with name '{entity_id}' via NPC system")
                             return npc
                 except Exception as e:
                     logger.error(f"Error getting NPCs from NPC system: {e}")
         # Option 3: Check entity manager (if it holds NPCs)
         if hasattr(game_state, 'entity_manager') and game_state.entity_manager and hasattr(game_state.entity_manager, 'get_entity_by_id'):
              entity = game_state.entity_manager.get_entity_by_id(entity_id)
              # Check if the entity is compatible (e.g., is an NPC or Player)
              if isinstance(entity, NPC) or hasattr(entity, 'entity_type'): # Or a common base class
                  logger.debug(f"Found participant '{entity_id}' in current_combatants (via entity manager)")
                  return entity

    # Fallback: Check world NPCs
    if game_state.world:
        # Check if get_npc_by_id method exists for exact ID match
        if hasattr(game_state.world, 'get_npc_by_id'):
            npc = game_state.world.get_npc_by_id(entity_id)
            if npc:
                logger.debug(f"Found participant '{entity_id}' in world NPCs")
                return npc
        
        # Try to match by name if we have access to all NPCs
        if try_fuzzy_match and hasattr(game_state.world, 'get_all_npcs'):
            try:
                all_npcs = game_state.world.get_all_npcs()
                for npc in all_npcs:
                    if getattr(npc, 'name', '').lower() == entity_id.lower():
                        logger.debug(f"Found NPC with name '{entity_id}' via world.get_all_npcs")
                        return npc
            except Exception as e:
                logger.error(f"Error accessing all NPCs: {e}")

    # If NPC system exists, try to get all NPCs and match by name
    if try_fuzzy_match and hasattr(game_state, 'npc_system') and game_state.npc_system:
        if hasattr(game_state.npc_system, 'get_npcs'):
            try:
                all_npcs = game_state.npc_system.get_npcs()
                for npc in all_npcs:
                    npc_name = getattr(npc, 'name', '')
                    if npc_name and npc_name.lower() == entity_id.lower():
                        logger.debug(f"Found NPC with name '{entity_id}' via npc_system.get_npcs")
                        return npc
            except Exception as e:
                logger.error(f"Error getting NPCs from NPC system: {e}")

    logger.warning(f"Could not find participant with ID or name: {entity_id} in current context.")
    return None
```

### File: core\game_flow\input_router.py

```python
"""
Centralized input router for the RPG game.

This module provides a unified approach to routing player input based on
game mode, input type, and content analysis.
"""

from typing import Any, Dict, Optional, Tuple, TYPE_CHECKING

from core.base.commands import CommandResult
from core.combat.combat_entity import EntityType
from core.combat.enums import CombatState, CombatStep
from core.interaction.enums import InteractionMode
from core.utils.logging_config import get_logger

# Import the modules for processing the input after routing
from core.game_flow import command_handlers
# Import functions from the refactored interaction processor modules
from core.game_flow.interaction_core import run_unified_loop, process_interactive_text, should_narrative_use_unified_loop
from core.game_flow.npc_interaction import get_npc_intent


if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState
    from core.agents.base_agent import BaseAgent

# Get the module logger
logger = get_logger("INPUT_ROUTER")

# Define essential commands allowed in any mode (without the leading '/')
# These bypass the mode-specific intent handling.
ESSENTIAL_COMMANDS = {"quit", "exit", "save", "load", "help", "status", "llm", "speed", "pause"}
UI_PROXY_COMMANDS = {"examine", "equip", "unequip", "drop", "use"} # Commands that might originate from UI buttons


class InputRouter:
    """
    Centralized router for player input based on game mode and input type.
    
    This class handles the routing of all player input to the appropriate
    processors based on the current game mode, input format, and content analysis.
    It also handles mode transitions and logging of routing decisions.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(InputRouter, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the input router."""
        if self._initialized:
            return
        
        self._initialized = True
        # The command processor instance is not currently used in this class.
        # self._command_processor = get_command_processor()

        logger.info("InputRouter initialized")
    
    def route_input(self, engine: 'GameEngine', input_text: str) -> CommandResult:
        """
        Route player input to the appropriate processor based on mode and type.

        Args:
            engine: The GameEngine instance.
            input_text: The raw input text from the player.

        Returns:
            The result of processing the input.
        """
        logger.debug(f"Routing input: '{input_text}'")

        game_state = engine._state_manager.current_state
        if game_state is None:
            logger.warning("Cannot process input: No current game state")
            return CommandResult.error("No game in progress. Start a new game or load a saved game.")

        input_text = input_text.strip()
        if not input_text:
            return CommandResult.invalid("Please enter a command or action.")

        current_mode = game_state.current_mode
        logger.debug(f"Current mode: {current_mode.name}")
        
        # Check if this input might be a UI-proxied command that should be handled directly
        # by the command_handlers.py and not echoed as player input to GameOutputWidget.
        # This is specifically for commands like "examine {uuid}" which are generated by UI clicks.
        is_ui_generated_command = False
        try:
            parts = input_text.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in UI_PROXY_COMMANDS:
                # Further check if the second part looks like a UUID (simple check)
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10: # Basic UUID-like check
                    is_ui_generated_command = True
                    logger.info(f"Identified as UI-generated command, will not echo: '{input_text}'")
        except Exception:
            pass # Ignore parsing errors here, will be handled by normal routing

        if self._is_essential_command(input_text):
            logger.info(f"Processing essential command: '{input_text}'")
            return self._process_direct_command(engine, game_state, input_text)

        if self._is_direct_command(input_text) and not is_ui_generated_command:
            # Direct commands typed by user (e.g. /look) should still be echoed.
            # UI-generated commands like "examine {uuid}" are "direct" but should not be echoed.
            logger.info(f"Processing direct command: '{input_text}'")
            if not input_text.startswith('//'): # Don't echo dev commands starting with //
                engine._output("player", input_text) # Echo direct commands typed by player
            return self._process_direct_command(engine, game_state, input_text)
        elif is_ui_generated_command: # Handle UI-generated commands that look like direct commands but shouldn't be echoed
            logger.info(f"Processing UI-generated command directly (no echo): '{input_text}'")
            return self._process_direct_command(engine, game_state, input_text)


        # --- Mode-specific routing ---
        if current_mode == InteractionMode.COMBAT:
            logger.info(f"COMBAT input received: '{input_text}'")
            if game_state.combat_manager is None:
                logger.error("COMBAT mode active but CombatManager is None.")
                return CommandResult.error("Internal Error: Combat state invalid.")

            combat_manager = game_state.combat_manager

            # Check if it's awaiting player input specifically
            if combat_manager.current_step == CombatStep.AWAITING_PLAYER_INPUT:
                # Echo player input immediately
                engine._output("player", input_text)
                # Delegate action receiving to CombatManager, passing engine and intent
                combat_manager.receive_player_action(engine, input_text) 
                # Signal that the action was received, combat manager will process
                return CommandResult.success("Action received...")
            else:
                # Not awaiting player input (e.g., NPC turn, resolving action)
                display_name = "Someone else"
                active_id = getattr(combat_manager, '_active_entity_id', None)
                if active_id:
                    entity = combat_manager.entities.get(active_id)
                    if entity: display_name = entity.combat_name
                logger.info(f"Input received during non-player-input step ({combat_manager.current_step.name}). Ignoring.")
                return CommandResult.invalid(f"Please wait, currently processing {display_name}'s turn or resolving actions.")

        elif current_mode == InteractionMode.NARRATIVE:
            # ... (rest of narrative logic remains the same) ...
            if should_narrative_use_unified_loop(input_text):
                logger.info(f"NARRATIVE input routed to unified loop: '{input_text}'")
                if not is_ui_generated_command: engine._output("player", input_text)
                return run_unified_loop(engine, game_state, input_text)
            else:
                logger.info(f"NARRATIVE input routed to interactive text: '{input_text}'")
                # Echo player input if processed by LLM and not UI-generated
                if engine._use_llm and not is_ui_generated_command:
                    engine._output("player", input_text)
                result = process_interactive_text(engine, input_text)
                # Output LLM response if applicable
                is_welcome_narration = "I've just started a new game" in input_text and "introduce me to the game world" in input_text
                if result.is_success and result.data and "commands" in result.data and not is_welcome_narration:
                    logger.debug(f"Sending output from LLM result. Role 'gm'. Snippet: '{result.message[:100]}...'")
                    if result.message: # Only output if there's a message
                         engine._output("gm", result.message)
                elif result.is_success and result.message: # LLM response without commands, still output it
                    engine._output("gm", result.message)
                return result

        elif current_mode in [InteractionMode.SOCIAL_CONFLICT, InteractionMode.TRADE]:
            # ... (logic for these modes remains the same) ...
            logger.info(f"{current_mode.name} input routed to unified loop: '{input_text}'")
            if not is_ui_generated_command: engine._output("player", input_text)
            # TODO: Implement proper turn handling/state checks for these modes if needed
            return run_unified_loop(engine, game_state, input_text)

        else:
            logger.warning(f"Unknown mode: {current_mode.name}. Falling back to narrative.")
            if not is_ui_generated_command: engine._output("player", input_text)
            return process_interactive_text(engine, input_text)
    
    def _is_essential_command(self, input_text: str) -> bool:
        """Check if the input is an essential command."""
        if input_text.startswith('/'):
            try:
                command_verb = input_text[1:].split(maxsplit=1)[0].lower()
                return command_verb in ESSENTIAL_COMMANDS
            except IndexError:
                pass  # Input was just '/'
        return False
    
    def _is_direct_command(self, input_text: str) -> bool:
        """Check if the input is a direct command (bypassing mode-specific processing)."""
        return (input_text.startswith('command:') or 
                input_text.startswith('//') or 
                input_text.startswith('/'))
    
    def _process_direct_command(self, engine: 'GameEngine', game_state: 'GameState', input_text: str) -> CommandResult:
        """Process a direct command."""
        # Strip 'command:' prefix if present
        command_to_process = input_text
        if input_text.startswith('command:'):
            command_to_process = input_text[8:].strip()
        elif input_text.startswith('/'): # Also strip '/' for consistency if it's not a dev command
            if not input_text.startswith('//'):
                command_to_process = input_text[1:].strip()
            
        # Pass to the command handlers
        return command_handlers.process_direct_command(engine, command_to_process)
    
    def _get_entity_display_name(self, game_state: 'GameState', entity_id: str) -> str:
        """Get the display name for an entity."""
        # Try combat manager first
        if game_state.current_mode == InteractionMode.COMBAT and game_state.combat_manager:
            try:
                entity = game_state.combat_manager.get_entity_by_id(entity_id)
                if entity and hasattr(entity, 'name'):
                    return entity.name
            except Exception as e:
                logger.warning(f"Error getting entity name from combat manager: {e}")

        # Try NPC system
        if hasattr(game_state, 'npc_system') and game_state.npc_system:
            npc = getattr(game_state.npc_system, 'get_npc', lambda id: None)(entity_id)
            if npc and hasattr(npc, 'name'):
                return npc.name

        # Fallback to ID
        return entity_id

# Convenience function
def get_input_router() -> InputRouter:
    """Get the input router instance."""
    return InputRouter()
```

### File: core\game_flow\interaction_core.py

```python
#!/usr/bin/env python3
"""
Core interaction processing loop and main entry points for natural language input.
"""

import json
import logging
from typing import Optional, TYPE_CHECKING, Dict, Any, List, Tuple

from core.base.commands import CommandResult
from core.interaction.enums import InteractionMode
from core.interaction.context_builder import ContextBuilder
from core.interaction.structured_requests import AgentOutput 
from core.agents.base_agent import AgentContext
from core.agents.rule_checker import RuleCheckerAgent
from core.base.state import GameState
from core.game_flow.mode_transitions import _handle_transition_request
from core.game_flow.request_handlers import _process_skill_check_request, _process_state_change_request


if TYPE_CHECKING:
    from core.base.engine import GameEngine

logger = logging.getLogger("INTERACTION_PROC") # Keep original logger name for minimal changes

# --- Helper Functions (General) ---

def should_narrative_use_unified_loop(intent: str) -> bool:
    """
    Decide whether narrative input should use the unified loop.

    Design decision: always route Narrative mode input through the
    unified loop so that structured requests (skill checks, state
    changes, mode transitions) are validated and executed consistently.
    """
    return True

# --- Core Interaction Processing ---

def process_interactive_text(engine: 'GameEngine', command_text: str) -> CommandResult:
    """
    Process interactive text input, potentially using LLM.
    
    Args:
        engine: The GameEngine instance.
        command_text: The player's input text.
        
    Returns:
        CommandResult with the response.
    """
    if not engine._state_manager or not engine._state_manager.current_state:
        logger.error("Cannot process interactive text: No current game state.")
        return CommandResult.error("No game in progress.")

    current_game_state = engine._state_manager.current_state

    if engine._use_llm:
        logger.info(f"Processing interactive text with LLM: {command_text[:100]}...")
        # Pass the actual GameState object to process_with_llm
        return process_with_llm(current_game_state, command_text)
    else:
        # Handle non-LLM interactive text (e.g., simple parser, keyword matching)
        # For now, just echo back or provide a canned response
        logger.info(f"LLM disabled. Echoing interactive text: {command_text[:100]}...")
        return CommandResult.success(f"You said: {command_text}")
    
def process_with_llm(game_state: GameState, player_input: str) -> CommandResult:
    """
    Process player input using the LLM agent manager.

    Args:
        game_state: The current game state.
        player_input: The player's input text.

    Returns:
        CommandResult with the LLM's response.
    """
    # Import get_game_engine here to ensure it's available
    from core.base.engine import get_game_engine
    engine = get_game_engine() # Get the engine instance

    if not engine:
        logger.error("GameEngine instance not found in process_with_llm.")
        return CommandResult.error("System error: Game engine unavailable.")

    if not engine._agent_manager:
        logger.error("AgentManager not initialized in process_with_llm.")
        return CommandResult.error("System error: Agent manager unavailable.")

    if not game_state: # Should have been checked by caller, but good to be safe
        logger.error("GameState not provided to process_with_llm.")
        return CommandResult.error("System error: Game state unavailable.")

    logger.info(f"Processing with LLM: {player_input[:100]}...")
    logger.info("LIFECYCLE_DEBUG: Sending request to LLM agent manager")
    
    try:
        # Process the input through the agent manager
        logger.info("LIFECYCLE_DEBUG: About to call agent_manager.process_input()")
        response_text, commands = engine._agent_manager.process_input(
            game_state=game_state, 
            player_input=player_input
        )
        logger.info(f"LIFECYCLE_DEBUG: Received LLM response - Length: {len(response_text) if response_text else 0} chars")
        logger.info(f"LIFECYCLE_DEBUG: Response preview: '{response_text[:150] if response_text else 'None'}...'")
        logger.info(f"LIFECYCLE_DEBUG: Commands returned: {len(commands) if commands else 0}")
        
        # For now, we're primarily interested in the response text.
        # Command processing from LLM output will be handled by the engine
        # if this function is called as part of a larger command processing flow.
        # If called directly for narration (like in lifecycle), commands might be ignored
        # or handled differently depending on context.
        
        if commands:
            logger.info(f"LLM response included {len(commands)} commands: {commands}")
            # Here, we could potentially process these commands immediately if needed,
            # or pass them up for the main game loop to handle.
            # For initial welcome narration, commands are less likely/important.
            # For general input, GameEngine.process_command would handle them.
            
            # If this function is meant to also execute commands, we'd need engine access here.
            # For now, assuming lifecycle uses this primarily for narrative generation.
            # The CommandResult can carry these commands if needed.
            pass # Commands are noted but not processed directly within this function.

        result = CommandResult.success(response_text, data={"commands": commands})
        logger.info(f"LIFECYCLE_DEBUG: Returning CommandResult - Success: {result.is_success}, Message length: {len(result.message) if result.message else 0}")
        return result
        
    except Exception as e:
        logger.error(f"Error processing input with LLM: {e}", exc_info=True)
        logger.error("LIFECYCLE_DEBUG: Exception in process_with_llm, returning error result")
        return CommandResult.error(f"LLM processing error: {e}")
    
# --- Unified Loop Helper Functions ---

def _build_interaction_context(game_state: 'GameState', current_mode: InteractionMode, actor_id: Optional[str]) -> Dict[str, Any]:
    """Builds the context dictionary for the current interaction."""
    logger.debug(f"Building context for Actor: {actor_id}, Mode: {current_mode.name}")
    context_builder = ContextBuilder()
    context = context_builder.build_context(game_state, current_mode, actor_id=actor_id)
    logger.debug("Context built successfully.")
    return context

def _get_agent_response(engine: 'GameEngine', game_state: 'GameState', context: Dict[str, Any], intent: str, current_mode: InteractionMode) -> Optional[AgentOutput]:
    """Calls the appropriate LLM agent based on the mode and returns the structured output."""
    logger.debug(f"Getting agent response for Mode: {current_mode.name}, Intent: '{intent}'")
    agent_context = AgentContext(
        game_state=context, # Pass context dict as game_state for agent
        player_state=context.get('player', {}),
        world_state={
            'location': context.get('location'),
            'time_of_day': context.get('time_of_day'),
            'environment': context.get('environment')
        },
        player_input=intent, # Use the intent as the input
        conversation_history=game_state.conversation_history,
        relevant_memories=[], # Placeholder
        additional_context=context
    )

    agent_output: Optional[AgentOutput] = None
    # Select appropriate agent
    if current_mode == InteractionMode.COMBAT and engine._combat_narrator_agent:
        logger.debug(f"Using CombatNarratorAgent for mode {current_mode.name}")
        agent_output = engine._combat_narrator_agent.process(agent_context)
    # TODO: Add elif for SOCIAL_CONFLICT, TRADE agents
    else:
        # For Narrative (and other non-combat unified flows), call NarratorAgent directly
        # to obtain structured AgentOutput with requests.
        try:
            from core.agents.narrator import get_narrator_agent
            narrator = get_narrator_agent()
            logger.debug("Using NarratorAgent for structured AgentOutput in unified loop")
            agent_output = narrator.process(agent_context)
        except Exception as e:
            logger.error(f"Failed to obtain structured AgentOutput from NarratorAgent: {e}")
            agent_output = None


    if not agent_output:
        logger.error("LLM Agent did not return structured output.")
        return None

    # Log the received output
    logger.debug(f"Agent Output received (JSON): {json.dumps(agent_output, indent=2)}")
    narrative_snippet = agent_output.get('narrative', '')[:50]
    requests_list = agent_output.get('requests', [])
    logger.debug(f"Agent Output received. Narrative: '{narrative_snippet}...', Requests: {len(requests_list)}")

    return agent_output

def _validate_agent_action(engine: 'GameEngine', context: Dict[str, Any], agent_output: AgentOutput, intent: str) -> tuple[bool, str]:
    """Validates the agent's proposed action using the RuleCheckerAgent."""
    logger.debug(f"Validating agent action. Intent: '{intent}', Output: {json.dumps(agent_output, indent=2)}")

    # Prepare validation context, embedding the structured request in the input
    validation_input = f"Action intent: {intent}\nStructured requests: {json.dumps(agent_output.get('requests', []), indent=2)}"
    validation_context = AgentContext(
        game_state=context,
        player_state=context.get('player', {}),
        world_state={
            'location': context.get('location'),
            'time_of_day': context.get('time_of_day'),
            'environment': context.get('environment')
        },
        player_input=validation_input,
        conversation_history=context.get('conversation_history', []), # Get history from context if available
        relevant_memories=[], # Placeholder
        additional_context=context
    )

    # Ensure rule checker agent is available
    if not engine._rule_checker:
        logger.error("RuleCheckerAgent not available for validation.")
        # In a real game, this might be a critical error or allow actions without validation
        # For now, assume validation fails if the agent isn't there.
        return False, "System Error: Rule checker is not available."


    is_valid, validation_feedback = engine._rule_checker.validate_action(validation_context)

    if not is_valid:
        logger.warning(f"Action validation failed: {validation_feedback}")
    else:
        logger.debug("Action validation successful.")

    return is_valid, validation_feedback

# Modify _execute_validated_requests in core/game_flow/interaction_core.py
def _execute_validated_requests(engine: 'GameEngine', game_state: 'GameState', agent_output: AgentOutput, effective_actor_id: str, intent: str) -> list[str]:
    """Processes the validated requests from the agent output."""
    final_narrative_parts = []
    requests_list = agent_output.get('requests', [])
    initial_narrative = agent_output.get('narrative', '') # CAPTURE initial narrative

    logger.debug(f"Executing {len(requests_list)} validated requests for actor {effective_actor_id}.")
    logger.info(f"Request list contents: {json.dumps(requests_list, indent=2)}")

    # --- Separate request types ---
    mode_transitions = []
    other_requests = []
    data_retrieval_requests = []

    for request in requests_list:
        if not isinstance(request, dict):
            logger.warning(f"Skipping non-dictionary request item: {request}")
            continue

        action_type = request.get("action")
        if action_type == "request_mode_transition":
            mode_transitions.append(request)
        elif action_type == "request_data_retrieval":
            data_retrieval_requests.append(request)
        else:
            other_requests.append(request)

    # --- Handle Data Retrieval First (if any) ---
    if data_retrieval_requests:
        logger.info(f"Processing {len(data_retrieval_requests)} data retrieval requests.")
        retrieved_data_narrative = []
        from core.agents.data_retrieval_commands import process_data_retrieval_command # Import here
        for req in data_retrieval_requests:
            data_type = req.get("data_type", "unknown")
            # Format args if needed, currently assuming no args for simple GETs
            retrieved_data = process_data_retrieval_command(f"GET_{data_type.upper()}", "", game_state)
            # Format the retrieved data into a readable string (basic example)
            # In a real scenario, this might call another LLM to summarize or format
            retrieved_data_narrative.append(f"--- {data_type.upper()} ---")
            retrieved_data_narrative.append(json.dumps(retrieved_data, indent=2, default=str))

        if retrieved_data_narrative:
             # Output data retrieval results (usually replaces narrative)
             data_narrative_str = "\n".join(retrieved_data_narrative)
             engine._output("gm", data_narrative_str) # Output retrieved data
             # If data was retrieved, usually we don't process other requests/narrative
             # unless specifically designed otherwise. Clear other lists.
             mode_transitions = []
             other_requests = []
             initial_narrative = "" # Clear original narrative if data was requested


    # --- Process Mode Transitions (if not superseded by data retrieval) ---
    processed_mode_transition = False
    if mode_transitions:
        request = mode_transitions[0]
        logger.info(f"Processing mode transition request: {json.dumps(request, indent=2)}")

        # Pass the INITIAL narrative into the context for the transition function
        if request.get("target_mode") == "COMBAT":
            request["additional_context"] = {
                "original_intent": intent,
                "narrative_context": initial_narrative
            }

        # Call the function from mode_transitions.py
        # This function will now only PREPARE combat, not fully start it.
        # It will output the initiating narrative.
        narrative_result = _handle_transition_request(engine, game_state, request, effective_actor_id)
        # The narrative_result from _handle_transition_request is now mainly for logging/errors,
        # as the initiating narrative is handled within it.
        if narrative_result and "System Error" in narrative_result:
            final_narrative_parts.append(narrative_result) # Append error messages

        processed_mode_transition = True
        if game_state.current_mode.name != request.get("origin_mode", ""):
            logger.info(f"Mode changed to {game_state.current_mode.name}. Clearing other pending requests.")
            other_requests = []

    # --- Process Other Requests (if no mode transition occurred or they weren't cleared) ---
    if not processed_mode_transition or other_requests: # Process if no transition or if requests remain
        for request in other_requests:
            action_type = request.get("action")
            narrative_result = ""

            if action_type == "request_skill_check":
                request["intent_hint"] = intent # Pass intent hint
                narrative_result = _process_skill_check_request(engine, game_state, request, effective_actor_id)
            elif action_type == "request_state_change":
                narrative_result = _process_state_change_request(engine, game_state, request, effective_actor_id)
            else:
                logger.warning(f"Unknown or missing action type in request: {request}")
                narrative_result = f"System Error: Unknown action type '{action_type}'."

            if narrative_result:
                final_narrative_parts.append(narrative_result)

    return final_narrative_parts


# --- Main Unified Loop Function ---

def run_unified_loop(engine: 'GameEngine', game_state: 'GameState', intent: str, actor_id: Optional[str] = None) -> CommandResult:
    """
    Implements the Unified Core Loop using helper methods.
    Handles context building, agent calls, validation, and execution for an actor's intent.

    Args:
        engine: The GameEngine instance.
        game_state: The current game state.
        intent: The description of the intended action (from player or generated for NPC).
        actor_id: The ID of the entity performing the action. Defaults to player if None.

    Returns:
        The result of processing the action.
    """
    current_mode = game_state.current_mode
    # Determine the acting entity's ID, defaulting to player if not specified
    effective_actor_id = actor_id or getattr(game_state.player, 'id', getattr(game_state.player, 'stats_manager_id', 'player_default_id'))
    logger.debug(f"Entering Unified Loop for Actor ID: {effective_actor_id}, Mode: {current_mode.name}, Intent: '{intent}'")

    # --- Get Actor Combat Name ---
    actor_combat_name = "Unknown" # Default
    actor_entity = None
    if game_state.combat_manager:
         actor_entity = game_state.combat_manager.get_entity_by_id(effective_actor_id)
         if actor_entity:
             actor_combat_name = getattr(actor_entity, 'combat_name', actor_entity.name)
         else:
             logger.warning(f"Could not find actor entity with ID {effective_actor_id} in combat manager.")
    elif effective_actor_id == getattr(game_state.player, 'id', 'player_default_id'):
         actor_combat_name = getattr(game_state.player, 'name', 'Player') # Fallback for player outside combat?
    else:
         # Try getting from NPC system if not in combat? Less likely scenario.
         pass
    logger.debug(f"Determined effective actor combat name: '{actor_combat_name}'")
    # --- End Get Actor Combat Name ---


    try:
        # 1. Build Context
        context = _build_interaction_context(game_state, current_mode, effective_actor_id)

        # 2. Get Agent Response
        agent_output = _get_agent_response(engine, game_state, context, intent, current_mode)
        if not agent_output:
            engine._output("system", "Sorry, I couldn't process that request properly (Agent Error).")
            return CommandResult.error("Agent failed to produce structured output.")

        requests_list = agent_output.get('requests', [])
        if requests_list and actor_combat_name != "Unknown":
            corrected_requests = []
            for req in requests_list:
                 if isinstance(req, dict) and "actor_id" in req:
                     llm_actor_id = req.get("actor_id")
                     if not llm_actor_id or llm_actor_id == "Unknown" or llm_actor_id != actor_combat_name:
                          if llm_actor_id and llm_actor_id != "Unknown":
                              logger.warning(f"Correcting actor_id in request: LLM provided '{llm_actor_id}', expected '{actor_combat_name}'.")
                          else:
                               logger.debug(f"Setting actor_id in request to known actor: '{actor_combat_name}' (LLM provided '{llm_actor_id}').")
                          req["actor_id"] = actor_combat_name 
                 corrected_requests.append(req)
            agent_output["requests"] = corrected_requests

        # 3. Validate Action
        is_valid, validation_feedback = _validate_agent_action(engine, context, agent_output, intent)
        if not is_valid:
            is_npc_action = hasattr(game_state, 'is_processing_npc_action') and game_state.is_processing_npc_action
            if is_npc_action:
                logger.warning(f"NPC action validation failed: {validation_feedback}")
                logger.info("Proceeding with NPC action despite validation failure to maintain combat flow")
            else:
                engine._output("system", f"Action cannot be performed: {validation_feedback}")
                return CommandResult.invalid(f"Action invalid: {validation_feedback}")


        # 4. Output primary narrative (if any) before executing mechanics, unless it's a pure data retrieval
        primary_narrative = agent_output.get('narrative', '') or ''
        requests_list = agent_output.get('requests', []) or []
        has_data_retrieval = any(isinstance(r, dict) and r.get('action') == 'request_data_retrieval' for r in requests_list)
        if primary_narrative.strip() and not has_data_retrieval:
            engine._output("gm", primary_narrative)

        # 5. Execute Validated Requests & Handle outcome/system lines
        final_narrative_parts = _execute_validated_requests(engine, game_state, agent_output, effective_actor_id, intent)

        # 5. Output Final System Messages (Results of checks/changes)
        if final_narrative_parts:
            final_outcome_narrative = "\n".join(final_narrative_parts)
            engine._output("system", final_outcome_narrative)

        processed_requests_count = len(agent_output.get('requests', []))
        return CommandResult.success("Action processed.", data={"processed_requests": processed_requests_count})

    except Exception as e:
        logger.error(f"Error in Unified Core Loop for mode {current_mode.name}: {e}", exc_info=True)
        engine._output("system", f"An unexpected error occurred while processing your action: {e}")
        return CommandResult.error(f"Internal error processing action: {e}")
```

### File: core\game_flow\interaction_processor.py

```python
# This file has been refactored and its contents moved to the following modules:
# - core.game_flow.interaction_core
# - core.game_flow.mode_transitions
# - core.game_flow.request_handlers
# - core.game_flow.npc_interaction
# Please update any imports to use the new modules.

```

### File: core\game_flow\lifecycle.py

```python
#!/usr/bin/env python3
"""
Handles game lifecycle operations like starting, loading, saving, and ticking.
"""

import os
import logging
from typing import Any, Dict, Optional

# Need to import GameEngine for type hinting and accessing its members
# Use a forward reference (string) to avoid circular import at runtime
# from core.base.engine import GameEngine
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState # Keep GameState

# Import interaction_core to call its functions
from core.game_flow import interaction_core
from core.base.state import GameState
from core.utils.logging_config import get_logger
from core.inventory import get_inventory_manager, get_item_factory

# Get the module logger (using a distinct name)
logger = get_logger("LIFECYCLE")


def start_new_game_with_state(engine: 'GameEngine', game_state: 'GameState') -> 'GameState':
    """
    Initializes systems for a new game using an already created GameState.
    
    Args:
        engine: The game engine instance.
        game_state: The pre-created and StatManager-initialized game state.
    
    Returns:
        The initialized game state.
    """
    logger.info(f"Starting new game for player {game_state.player.name} using existing game state")
    
    # Set current state in state manager
    engine._state_manager._current_state = game_state

    # Ensure the engine-level RuleChecker (used by GUI flow) is clean for this session
    try:
        if hasattr(engine, "_rule_checker") and hasattr(engine._rule_checker, "reset"):
            engine._rule_checker.reset()
            logger.info("Engine RuleChecker reset for new game session.")
    except Exception as e:
        logger.warning(f"Failed to reset engine RuleChecker for new game: {e}")
    
    # Initialize memory/context system
    engine._state_manager.initialize_memory_context(game_state)
    logger.info("Memory/context system initialized for new game")

    # Initialize player's inventory
    inventory_manager = get_inventory_manager()
    logger.info(f"LIFECYCLE: Using InventoryManager instance ID: {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
    inventory_manager.clear() 
    if hasattr(inventory_manager, 'inventory_id_for_debug'): # Check for the debug ID
        game_state.player.inventory_id = inventory_manager.inventory_id_for_debug
    elif hasattr(inventory_manager, 'instance_id_for_debug'): # Fallback to the new debug ID
         game_state.player.inventory_id = inventory_manager.instance_id_for_debug
    else: # Fallback if InventoryManager doesn't have a direct inventory_id attribute
        import uuid
        inventory_manager_id = str(uuid.uuid4())
        try:
            setattr(inventory_manager, 'inventory_id_for_debug', inventory_manager_id) 
        except AttributeError:
            logger.warning("Could not set 'inventory_id_for_debug' on InventoryManager instance.")
        game_state.player.inventory_id = inventory_manager_id
        logger.warning(f"InventoryManager instance did not have 'inventory_id_for_debug'. Assigned new ID for player state: {inventory_manager_id}")


    # Configure world time and settings based on origin
    origin_id = game_state.player.origin_id 

    if origin_id:
        from core.base.config import get_config
        config = get_config() 
        origins_config = config.get('origins') 

        if origins_config and isinstance(origins_config, dict) and origin_id in origins_config:
            origin_data = origins_config[origin_id]
            
            # Set starting location based on origin settings
            starting_location_id = origin_data.get('starting_location_id')
            if starting_location_id:
                # Resolve to location name via GameConfig locations domain
                location_name = config.get(f"locations.{starting_location_id}.name")
                resolved_location = location_name or starting_location_id
                game_state.player.current_location = resolved_location
                game_state.world.current_location = resolved_location
                logger.info(f"Set starting location to '{resolved_location}' (id='{starting_location_id}') for origin '{origin_id}'")
            else:
                logger.warning(f"Origin '{origin_id}' has no starting_location_id. Leaving current_location unchanged.")
            
            # Set up world time based on origin settings
            starting_time_period = origin_data.get('starting_time_period')
            starting_season = origin_data.get('starting_season')
            
            if starting_time_period:
                # Convert time period to actual game time
                from core.utils.enhanced_time_manager import get_enhanced_time_manager, TimePeriod
                from core.utils.time_utils import HOUR
                
                # Map time periods to approximate hours
                time_period_hours = {
                    'deep_night': 2, 'pre_dawn': 4.5, 'dawn': 6, 'morning': 9,
                    'noon': 12, 'afternoon': 15, 'evening': 18, 'sunset': 20.5, 'night': 22
                }
                
                if starting_time_period in time_period_hours:
                    target_hour = time_period_hours[starting_time_period]
                    game_state.world.game_time = target_hour * HOUR
                    logger.info(f"Set starting time to {starting_time_period} ({target_hour}:00) for origin '{origin_id}'")
                
            if starting_season:
                # Set the season in world global variables
                game_state.world.set_global_var('current_season', starting_season)
                logger.info(f"Set starting season to {starting_season} for origin '{origin_id}'")
            
            # Add starting items from origin
            starting_item_ids_from_origin = origin_data.get('starting_items', [])
            item_factory = get_item_factory()

            logger.info(f"Processing starting items for origin '{origin_id}': {starting_item_ids_from_origin}")
            for item_template_id in starting_item_ids_from_origin:
                logger.debug(f"Attempting to create starting item from template_id: '{item_template_id}'")
                item_instance = item_factory.create_item_from_template(item_template_id, variation=False)
                if item_instance:
                    added_ids = inventory_manager.add_item(item_instance)
                    if added_ids:
                        logger.info(f"Added starting item '{item_instance.name}' (ID: {added_ids[0]}) to inventory via manager {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}.")
                    else:
                        logger.warning(f"Failed to add starting item '{item_template_id}' to inventory for player '{game_state.player.name}'.")
                else:
                    logger.warning(f"Could not create starting item from template_id: '{item_template_id}' for player '{game_state.player.name}'. Template not found or creation failed.")
        elif not origins_config:
            logger.warning("Origins configuration data not found or is not a dictionary. Cannot add starting items.")
        else: 
            logger.warning(f"Origin ID '{origin_id}' not found in origins configuration. Cannot add starting items.")
    else:
        logger.warning("No origin_id found on game_state.player. Cannot add starting items.")

    # --- Activate initial quests from origin ---
    try:
        origin_id = game_state.player.origin_id
        if origin_id:
            from core.base.config import get_config
            config = get_config()
            origins_cfg = config.get('origins') or {}
            quests_cfg = config.get('quests') or {}
            if isinstance(origins_cfg, dict) and isinstance(quests_cfg, dict) and origin_id in origins_cfg:
                init_ids = origins_cfg[origin_id].get('initial_quests', []) or []
                # Ensure journal exists on state
                if not hasattr(game_state, 'journal') or not isinstance(getattr(game_state, 'journal'), dict):
                    game_state.journal = {"character": "", "quests": {}, "notes": []}
                started_events: list[tuple[str, str]] = []  # (id, title)
                # Activate each quest: add to journal.quests with status=active and copy objectives
                for qid in init_ids:
                    if qid in quests_cfg and qid not in game_state.journal["quests"]:
                        qdef = quests_cfg[qid]
                        # Build objectives with default mandatory=True unless marked (O)
                        built_objectives = []
                        for index, obj in enumerate(qdef.get("objectives", [])):
                            if isinstance(obj, dict):
                                desc_text = obj.get("description") or ""
                                oid = obj.get("id") or str(index)
                                mandatory = obj.get("mandatory")
                            else:
                                desc_text = str(obj)
                                oid = str(index)
                                mandatory = None
                            text_lower = desc_text.lower()
                            is_optional = "(o)" in text_lower if isinstance(desc_text, str) else False
                            # If 'mandatory' explicitly given, use it; otherwise infer from tags
                            is_mandatory = (mandatory if isinstance(mandatory, bool) else ("(m)" in text_lower or not is_optional))

                            # Build hydrated objective entry with all relevant fields for evaluation
                            hydrated_obj = {
                                "id": oid,
                                "description": desc_text,
                                "completed": False,
                                "failed": False,
                                "mandatory": bool(is_mandatory),
                            }
                            if isinstance(obj, dict):
                                for k in ["type", "target_id", "location_id", "completion_criteria", "condition_dsl", "time_limit_s", "fail_if"]:
                                    if k in obj:
                                        hydrated_obj[k] = obj[k]
                            built_objectives.append(hydrated_obj)

                        title = qdef.get("title", qid)
                        game_state.journal["quests"][qid] = {
                            "title": title,
                            "description": qdef.get("description", ""),
                            "status": "active",
                            "objectives": built_objectives,
                            "rewards": qdef.get("rewards", {}),
                            "prerequisites": qdef.get("prerequisites", []),
                            "tags": qdef.get("tags", []),
                        }
                        started_events.append((qid, title))
                logger.info(f"Activated {len(init_ids)} initial quests for origin '{origin_id}'.")
    except Exception as e:
        logger.error(f"Failed to activate initial quests: {e}")

    # Send welcome message
    welcome_message_base = f"==== WELCOME TO YOUR ADVENTURE ====\n\nGreetings, {game_state.player.name} the {game_state.player.race} {game_state.player.path} from {game_state.player.background}!"
    
    introduction_text_for_llm = game_state.player.background 
    if origin_id: 
        from core.base.config import get_config
        config = get_config() 
        origins_config = config.get('origins') 
        if origins_config and isinstance(origins_config, dict) and origin_id in origins_config:
            introduction_text_for_llm = origins_config[origin_id].get('introduction_text', game_state.player.background)
    
    full_welcome_message = f"{welcome_message_base}\n\nYour journey begins now..." 
    
    logger.info(f"Sending welcome message: '{full_welcome_message[:100]}...' with role 'gm'")
    engine._output("gm", full_welcome_message)
    
    # Send help message
    help_message = "Type 'help' for a list of commands."
    engine._output("system", help_message)
    
    # Generate initial narrative if LLM is enabled
    if engine._use_llm:
        logger.info("Generating welcome narration")
        narration_prompt = (
            f"I've just started a new game as {game_state.player.name}, a {game_state.player.race} {game_state.player.path}. "
            f"My background is: \"{introduction_text_for_llm}\". "
            f"Please provide an initial immersive narration based on this, describing my immediate surroundings and current situation as the game begins. "
            f"This is the first narrative in the game, so make it welcoming and informative."
        )

        from core.game_flow.interaction_core import process_with_llm 
        result = process_with_llm(game_state, narration_prompt) 
        
        narrative_text = None
        if result.is_success and result.message:
            logger.info(f"Received welcome narrative from LLM, first 100 chars: '{result.message[:100]}...'")
            narrative_text = result.message
        else:
            logger.warning("Failed to generate welcome narrative from LLM.")
            narrative_text = "The world awaits your command..."

        # Route the initial narrative through the orchestrator so we can append quest-start messages afterwards
        try:
            if hasattr(engine, '_combat_orchestrator') and engine._combat_orchestrator:
                from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
                engine._combat_orchestrator.add_event_to_queue(
                    DisplayEvent(
                        type=DisplayEventType.NARRATIVE_GENERAL,
                        content=narrative_text,
                        role="gm",
                        target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                        gradual_visual_display=True,
                        tts_eligible=True,
                    )
                )
                # After the narrative is queued, append quest-start system messages to the queue
                try:
                    started_events = locals().get('started_events', [])
                except Exception:
                    started_events = []
                # Consolidate all started quests into a single instant system line
                titles = [title for _, title in started_events] if started_events else []
                if titles:
                    msg = "Quests started: " + "; ".join(titles)
                    engine._combat_orchestrator.add_event_to_queue(
                        DisplayEvent(
                            type=DisplayEventType.SYSTEM_MESSAGE,
                            content=msg,
                            target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                            gradual_visual_display=False,
                            tts_eligible=False,
                        )
                    )
            else:
                # Fallback: no orchestrator. Output narrative immediately, then quest messages.
                engine._output("gm", narrative_text)
                for qid, title in locals().get('started_events', []):
                    engine._output("system", f"Quest Started: {title}")
        except Exception as e:
            logger.warning(f"Failed to route initial narrative/quest-start via orchestrator: {e}")
    else:
        engine._output("gm", "The world awaits your command...")
        # With LLM disabled, we can emit quest start messages immediately afterwards (no gradual display to wait for)
        try:
            titles = [title for _, title in locals().get('started_events', [])]
            if titles:
                engine._output("system", "Quests started: " + "; ".join(titles))
        except Exception:
            pass
        
    logger.info(f"New game started for {game_state.player.name}")
    return game_state

def start_new_game(engine: 'GameEngine', player_name: str, race: str = "Human",
                   path: str = "Wanderer", background: str = "Commoner",
                   sex: str = "Male", character_image: Optional[str] = None,
                   stats: Optional[Dict[str, int]] = None) -> GameState:
    """
    Start a new game.

    Args:
        engine: The GameEngine instance.
        player_name: The name of the player character.
        race: The race of the player character.
        path: The class/path of the player character.
        background: The background of the player character.
        sex: The sex/gender of the player character.
        character_image: Path to character image.
        stats: Optional dictionary of starting stats.

    Returns:
        The new game state.
    """
    logger.info(f"Starting new game for player {player_name}")

    # Clean up existing game if present
    if engine._state_manager.current_state is not None:
        logger.info("Cleaning up existing game before starting new one")
        if engine._game_loop.is_running:
            engine._game_loop.pause()
        if engine._agent_manager is not None and engine._use_llm:
            try:
                engine._agent_manager.reset_state()
            except Exception as e:
                logger.warning(f"Error resetting agent state: {e}")

    # Create new game state
    game_state = engine._state_manager.create_new_game(
        player_name=player_name,
        race=race,
        path=path,
        background=background,
        sex=sex,
        character_image=character_image,
        stats=stats
    )
    
    # Now use the shared function to start the game with this state
    return start_new_game_with_state(engine, game_state)


def load_game(engine: 'GameEngine', filename: str) -> Optional[GameState]:
    """
    Load a game from a save file.

    Args:
        engine: The GameEngine instance.
        filename: The name of the save file.

    Returns:
        The loaded game state, or None if the load failed.
    """
    logger.info(f"Loading game from {filename}")

    # Clean up existing game if present
    if engine._state_manager.current_state is not None:
        logger.info("Cleaning up existing game before loading")
        if engine._game_loop.is_running:
            engine._game_loop.pause()
        if engine._agent_manager is not None and engine._use_llm:
            try:
                engine._agent_manager.reset_state()
            except Exception as e:
                logger.warning(f"Error resetting agent state: {e}")
        # Also reset the engine-level RuleChecker which is used for validation in GUI
        try:
            if hasattr(engine, "_rule_checker") and hasattr(engine._rule_checker, "reset"):
                engine._rule_checker.reset()
                logger.info("Engine RuleChecker reset before load.")
        except Exception as e:
            logger.warning(f"Failed to reset engine RuleChecker before load: {e}")

    # Load the game state
    game_state = engine._state_manager.load_game(filename)

    if game_state is None:
        logger.error(f"Failed to load game from {filename}")
        engine._output("system", f"Failed to load game from {filename}")
        return None

    # Set up the game loop with the loaded world state
    engine._game_loop.set_world_state(game_state.world)

    # Sync player location with world current_location for web server compatibility
    game_state.world.current_location = game_state.player.current_location

    # Reset auto-save timer
    engine._auto_save_timer = 0

    # Initialize memory/context system if available
    try:
        if hasattr(engine._state_manager, 'initialize_memory_context'):
            engine._state_manager.initialize_memory_context(game_state)
            logger.info("Memory/context system initialized for loaded game")
    except Exception as e:
        logger.warning(f"Error initializing memory/context system: {e}")

    # Prepare agent system for the loaded game if LLM is enabled
    if engine._use_llm and engine._agent_manager is not None:
        try:
            logger.info("Preparing agent system for loaded game")
            # Reset agent state to prepare for loaded context
            engine._agent_manager.reset_state()
            logger.info("Agent manager state reset for loaded game")
        except Exception as e:
            logger.warning(f"Error preparing agent system: {e}")
    # Ensure the engine-level RuleChecker is also cleared for the loaded session
    try:
        if hasattr(engine, "_rule_checker") and hasattr(engine._rule_checker, "reset"):
            engine._rule_checker.reset()
            logger.info("Engine RuleChecker reset for loaded game.")
    except Exception as e:
        logger.warning(f"Failed to reset engine RuleChecker after load: {e}")

    # Start/unpause the game loop if it was paused
    if engine._game_loop.is_paused:
        logger.info("Unpausing game loop for loaded game")
        engine._game_loop.unpause()

    # Output welcome back message
    engine._output(
        "gm",
        f"Welcome back, {game_state.player.name}! You are currently at {game_state.player.current_location}."
    )

    # Output system info about time using narrative description
    world_state = game_state.world
    time_description = world_state.time_of_day
    engine._output(
        "system",
        f"It is {time_description}."
    )

    # Generate reintroductory narrative if LLM is enabled (AFTER initial messages like new game)
    if engine._use_llm:
        logger.info("Generating reintroductory narrative for loaded game")
        reintroductory_narrative = _generate_reintroductory_narrative_content(engine, game_state)
        
        if reintroductory_narrative:
            logger.info(f"Received reintroductory narrative from LLM, first 100 chars: '{reintroductory_narrative[:100]}...'")
            engine._output("gm", reintroductory_narrative)
        else:
            logger.warning("Failed to generate reintroductory narrative from LLM.")
            engine._output("system", "You continue your adventure...")

    return game_state


def _generate_reintroductory_narrative_content(engine: 'GameEngine', game_state: 'GameState') -> Optional[str]:
    """
    Generate reintroductory narrative content for loaded games (without sending it).
    
    This provides context to help players re-engage with their saved game,
    summarizing their current situation and recent context.
    
    Args:
        engine: The game engine instance.
        game_state: The loaded game state.
        
    Returns:
        The generated narrative content, or None if generation failed.
    """
    try:
        # Build contextual prompt for reintroduction
        player = game_state.player
        current_location = player.current_location or "an unknown location"
        
        # Use enhanced time descriptions instead of clock time
        world_state = game_state.world
        time_of_day = world_state.atmospheric_time  # Rich atmospheric description
        
        # Get player's background/origin context if available
        background_context = ""
        if hasattr(player, 'background') and player.background:
            background_context = f"Background: {player.background}. "
        
        # Build the reintroduction prompt
        reintro_prompt = (
            f"I'm continuing my adventure as {player.name}, a {player.race} {player.path}. "
            f"{background_context}"
            f"I'm currently at {current_location}. "
            f"It is {time_of_day}. "
            f"Please provide an immersive narrative that reintroduces me to my current situation. "
            f"Describe my immediate surroundings and give me a sense of what I was doing or what's happening. "
            f"Make it atmospheric, but not overly narrative and help me get back into the story - I need all most important details from my previous game."
        )
        
        # Generate the narrative using the LLM
        logger.info("LIFECYCLE_DEBUG: About to call process_with_llm for reintroductory narrative")
        logger.info(f"LIFECYCLE_DEBUG: Prompt length: {len(reintro_prompt)} chars")
        from core.game_flow.interaction_core import process_with_llm 
        result = process_with_llm(game_state, reintro_prompt)
        
        logger.info(f"LIFECYCLE_DEBUG: process_with_llm returned - Success: {result.is_success}")
        if result.message:
            logger.info(f"LIFECYCLE_DEBUG: Result message length: {len(result.message)} chars")
            logger.info(f"LIFECYCLE_DEBUG: Result message preview: '{result.message[:200]}...'")
        else:
            logger.warning("LIFECYCLE_DEBUG: Result message is None or empty")
            
        if result.is_success and result.message:
            logger.info(f"Generated reintroductory narrative: '{result.message[:100]}...'")
            logger.info("LIFECYCLE_DEBUG: Returning generated narrative content")
            return result.message
        else:
            logger.warning("Failed to generate reintroductory narrative from LLM")
            logger.warning(f"LIFECYCLE_DEBUG: Result details - Success: {result.is_success}, Message: {result.message}")
            # Provide a simple fallback narrative
            fallback_message = (
                f"You find yourself at {current_location} as {time_of_day.lower()} settles in. "
                f"The familiar surroundings remind you of your ongoing adventure."
            )
            logger.info("LIFECYCLE_DEBUG: Returning fallback narrative content")
            return fallback_message
            
    except Exception as e:
        logger.error(f"Error generating reintroductory narrative: {e}", exc_info=True)
        # Provide a minimal fallback
        return "You take a moment to gather your bearings and continue your adventure."


def save_game(engine: 'GameEngine', filename: Optional[str] = None,
              auto_save: bool = False) -> Optional[str]:
    """
    Save the current game.

    Args:
        engine: The GameEngine instance.
        filename: The name of the save file. If None, generates a name.
        auto_save: Whether this is an auto-save.

    Returns:
        The path to the save file, or None if the save failed.
    """
    logger.info(f"Saving game{' (auto)' if auto_save else ''}")

    if engine._state_manager.current_state is None:
        logger.error("Cannot save: No current game state")
        engine._output("system", "Cannot save: No game in progress")
        return None

    # Save the game state
    save_path = engine._state_manager.save_game(filename, auto_save)

    if save_path is None:
        logger.error("Failed to save game")
        engine._output("system", "Failed to save game")
        return None

    # Output save confirmation (unless auto-save)
    if not auto_save:
        engine._output("system", f"Game saved to {os.path.basename(save_path)}")

    return save_path


def handle_tick(engine: 'GameEngine', elapsed_game_time: float) -> None:
    """
    Handle a game loop tick, primarily for auto-saving.

    Args:
        engine: The GameEngine instance.
        elapsed_game_time: The elapsed game time in seconds since the last tick.
    """
    # Increment auto-save timer (assuming _auto_save_timer is still managed by engine)
    engine._auto_save_timer += elapsed_game_time

    # Auto-save if interval has passed
    if engine._auto_save_timer >= engine._auto_save_interval:
        engine._auto_save_timer = 0
        save_game(engine, auto_save=True) # Call the save_game function in this module

    # Process time-based quest deadlines
    try:
        if engine._state_manager and engine._state_manager.current_state:
            from core.game_flow.quest_updates import process_time_for_quests
            process_time_for_quests(engine, engine._state_manager.current_state)
    except Exception as e:
        logger.warning(f"Tick quest deadline processing failed: {e}")

```

### File: core\game_flow\mode_transitions.py

```python
#!/usr/bin/env python3
"""
Handles transitions between different interaction modes.
"""

import logging
import time
import json
from typing import Dict, List, Optional, Any, TYPE_CHECKING, Tuple

from core.interaction.enums import InteractionMode
from core.combat.combat_manager import CombatManager
from core.combat.enums import CombatState
from core.character.npc_system import NPCSystem
from core.base.state import get_state_manager, GameState # Import GameState for type hinting
from core.combat.dev_commands import create_enemy_combat_entity, create_player_combat_entity
from core.stats.stats_base import DerivedStatType, StatType # Import StatType for checks
from core.combat.combat_entity import EntityType, CombatEntity # Import EntityType and CombatEntity
from core.stats.skill_check import SkillCheckResult # Import SkillCheckResult

# Import necessary functions/classes from interaction_core
from core.game_flow.game_flow_utils import get_participant_by_id # Assuming this helper stays in interaction_core
from core.game_flow.npc_interaction import trigger_combat_narration # Assuming this is called after combat init

if TYPE_CHECKING:
    from core.base.engine import GameEngine # Import GameEngine for type hinting


logger = logging.getLogger("INTERACTION_PROC")


# --- Helper: Mode Transition Cooldown ---

def _check_and_apply_cooldown(game_state: 'GameState', origin_mode: InteractionMode, target_mode: InteractionMode) -> Optional[str]:
    """Checks if a transition is on cooldown. Returns error message if blocked."""
    cooldown_key = f"{origin_mode.name}_TO_{target_mode.name}"
    current_time = time.time()
    if cooldown_key in game_state.mode_transition_cooldowns:
        cooldown_expires = game_state.mode_transition_cooldowns[cooldown_key]
        if current_time < cooldown_expires:
            remaining_time = int(cooldown_expires - current_time)
            narrative_result = f"You cannot attempt to transition from {origin_mode.name} to {target_mode.name} yet. Cooldown remaining: {remaining_time} seconds."
            logger.info(f"Mode transition {cooldown_key} blocked by cooldown. Remaining: {remaining_time}s")
            return narrative_result
        else:
            # Cooldown expired, remove it
            del game_state.mode_transition_cooldowns[cooldown_key]
            logger.debug(f"Cooldown {cooldown_key} expired and removed.")
    return None

def _set_cooldown_on_failure(game_state: 'GameState', origin_mode: InteractionMode, target_mode: InteractionMode, narrative_result: str) -> str:
    """Applies cooldown if transition failed and updates narrative."""
    if game_state.current_mode != target_mode:
        cooldown_key = f"{origin_mode.name}_TO_{target_mode.name}"
        cooldown_duration = 60 # seconds (Example: 1 minute cooldown)
        current_time = time.time()
        game_state.mode_transition_cooldowns[cooldown_key] = current_time + cooldown_duration
        logger.info(f"Applied cooldown for {cooldown_key}. Expires at {game_state.mode_transition_cooldowns[cooldown_key]}")
        # Add a note to the narrative if it doesn't already indicate failure/cooldown
        if "fail" not in narrative_result.lower() and "cannot" not in narrative_result.lower() and "remain" not in narrative_result.lower() and "still in" not in narrative_result.lower():
            narrative_result += f"\n(A cooldown is now active for this transition.)"
    return narrative_result

# --- Helper: Combat Initiation ---

def _create_combat_enemies(game_state: 'GameState', request: Dict[str, Any]) -> Tuple[List[CombatEntity], Optional[str]]:
    """Creates CombatEntity objects for enemies based on the request."""
    enemy_entities = []
    target_entity_id_or_name = request.get("target_entity_id") # Keep original request value
    enemy_template = request.get("enemy_template")
    enemy_level = request.get("enemy_level", 1) # Keep level/count in case template is used later
    enemy_count = request.get("enemy_count", 1)

    # Optional compact spawn hints (from NarratorAgent)
    spawn_hints = request.get("spawn_hints") or {}
    # Normalize keys
    if isinstance(spawn_hints, dict):
        actor_type_hint = str(spawn_hints.get("actor_type", "")).lower() or None
        threat_tier_hint = str(spawn_hints.get("threat_tier", "")).lower() or None
        is_boss_hint = bool(spawn_hints.get("is_boss", False))
        overlay_hint = spawn_hints.get("overlay")
        species_tags = spawn_hints.get("species_tags") if isinstance(spawn_hints.get("species_tags"), list) else []
    else:
        actor_type_hint = None
        threat_tier_hint = None
        is_boss_hint = False
        overlay_hint = None
        species_tags = []

    # Get NPC System (Ensuring it exists or creating fallback)
    npc_system = None
    state_manager = get_state_manager()
    try:
        npc_system = state_manager.get_npc_system()
        if not npc_system:
            logger.warning("NPCSystem not found in StateManager. Creating a new instance.")
            from core.character.npc_system import NPCSystem
            npc_system = NPCSystem()
            state_manager.set_npc_system(npc_system)
    except (AttributeError, Exception) as e:
        logger.error(f"Error accessing NPCSystem via state manager: {e}")
        from core.character.npc_system import NPCSystem
        npc_system = NPCSystem()


    # --- Resolve Target NPC ---
    target_npc = None

    # If no explicit target NPC and we have a spawn intent without a template,
    # resolve a default family/variant id when families mode is enabled.
    if not target_entity_id_or_name and not enemy_template and (actor_type_hint or threat_tier_hint or species_tags):
        try:
            from core.base.config import get_config
            cfg = get_config()
            mode = (cfg.get("system.npc_generation_mode", "legacy") or "legacy").lower()
        except Exception:
            mode = "legacy"
        if mode == "families":
            # Normalize tier and actor_type
            valid_tiers = ["harmless", "easy", "normal", "dangerous", "ferocious", "mythic"]
            tier = threat_tier_hint if threat_tier_hint in valid_tiers else "normal"
            atype = actor_type_hint if actor_type_hint in ["beast", "humanoid"] else None
            # If no actor_type provided, infer from species tags and reason keywords
            if not atype:
                keywords = (species_tags or []) + [str(request.get("reason", ""))]
                kstr = " ".join([k.lower() for k in keywords])
                if any(w in kstr for w in ["wolf", "hound", "dog", "boar", "bear", "lion", "beast"]):
                    atype = "beast"
                elif any(h in kstr for h in ["bandit", "guard", "soldier", "human", "goblin", "thug", "brigand"]):
                    atype = "humanoid"
            if atype:
                computed_id = f"{atype}_{tier}_base"
                # If boss, prefer using overlay via +boss unless overlay id explicitly provided
                if is_boss_hint and not overlay_hint:
                    enemy_template = f"{computed_id}+boss"
                elif overlay_hint:
                    enemy_template = f"{computed_id}::{overlay_hint}"
                else:
                    enemy_template = computed_id
    if target_entity_id_or_name:
        # Try finding by ID/Name using the utility function first
        participant = get_participant_by_id(game_state, target_entity_id_or_name)
        if participant and getattr(participant, 'entity_type', None) != EntityType.PLAYER:
            target_npc = participant
            logger.info(f"Found target NPC '{getattr(target_npc, 'name', 'Unknown')}' via get_participant_by_id.")
        else:
            # If not found by utility, try NPCSystem directly
            logger.warning(f"Participant '{target_entity_id_or_name}' not found via standard lookup. Trying NPCSystem directly.")
            if npc_system:
                 # Try by ID first if it looks like one
                if len(target_entity_id_or_name) > 10 and '-' in target_entity_id_or_name: # Basic UUID check
                    if hasattr(npc_system, 'get_npc_by_id'):
                        target_npc = npc_system.get_npc_by_id(target_entity_id_or_name)
                # If not found by ID or doesn't look like ID, try by name
                if not target_npc and hasattr(npc_system, 'get_npc_by_name'):
                    target_npc = npc_system.get_npc_by_name(target_entity_id_or_name)

            if target_npc:
                logger.info(f"Found target NPC '{getattr(target_npc, 'name', 'Unknown')}' via NPCSystem lookup.")
            else:
                # --- MODIFICATION: Attempt Dynamic Creation HERE ---
                logger.warning(f"Provided target '{target_entity_id_or_name}' not found via NPCSystem either.")
                # Only attempt creation if no template was provided and we have a name
                if not enemy_template and target_entity_id_or_name and npc_system:
                    logger.info(f"Attempting dynamic creation of '{target_entity_id_or_name}' within _create_combat_enemies.")
                    try:
                        # Determine type/level dynamically using the existing function
                        dynamic_enemy_type, dynamic_level = _determine_dynamic_enemy_details(request, target_entity_id_or_name)
                        player_location = getattr(game_state.player, 'current_location', 'unknown_location')
                        target_npc = npc_system.create_enemy_for_combat(
                            name=target_entity_id_or_name, # Use the requested name
                            enemy_type=dynamic_enemy_type,
                            level=dynamic_level,
                            location=player_location
                        )
                        if target_npc:
                            logger.info(f"Successfully created dynamic NPC: {target_npc.name} (ID: {target_npc.id})")
                            # The newly created NPC is now assigned to target_npc
                        else:
                             logger.error(f"Dynamic creation failed for '{target_entity_id_or_name}'.")
                             target_entity_id_or_name = None # Mark as invalid if creation failed
                    except Exception as fallback_creation_error:
                         logger.error(f"Error during dynamic NPC creation: {fallback_creation_error}", exc_info=True)
                         target_entity_id_or_name = None # Mark as invalid
                else:
                     # If we had a template or no name, clear the invalid target name
                     target_entity_id_or_name = None
                 # --- END MODIFICATION ---


    # --- Check if we have a target or template AFTER potential dynamic creation ---
    if not target_npc and not enemy_template:
        logger.error("Combat initiation request missing valid target_entity_id/name or enemy_template.")
        return [], "System Error: Combat initiation request is incomplete (missing target or template)."

    # --- Create list of NPCs to process ---
    npcs_to_process = []
    if target_npc: # If we found or created the target NPC
        npcs_to_process.append(target_npc)
        logger.info(f"Targeting NPC '{getattr(target_npc, 'name', 'Unknown')}' for combat.")
    elif enemy_template and npc_system: # If we didn't have a target, but have a template
        logger.info(f"Creating {enemy_count} enemies from template '{enemy_template}' (Level {enemy_level})")
        for i in range(enemy_count):
            # Use a readable name even when template is a family id
            base_label = enemy_template.replace("_base", "").replace("_", " ")
            enemy_name = f"{base_label.title()} {i+1}" if enemy_count > 1 else base_label.title()
            try:
                player_location = getattr(game_state.player, 'current_location', 'unknown_location')
                if not player_location:
                    logger.warning("Player location not found, using 'unknown_location' for enemy creation.")
                    player_location = 'unknown_location'

                enemy_npc = npc_system.create_enemy_for_combat(
                    name=enemy_name, enemy_type=enemy_template, level=enemy_level, location=player_location
                )
                if enemy_npc and hasattr(enemy_npc, 'id'):
                    npcs_to_process.append(enemy_npc)
                    logger.debug(f"Successfully created enemy NPC '{enemy_name}' (ID: {enemy_npc.id})")
                else:
                    logger.error(f"Failed to create or get ID for enemy NPC: {enemy_name}")
            except Exception as creation_error:
                logger.error(f"Error creating enemy NPC '{enemy_name}': {creation_error}", exc_info=True)


    if not npcs_to_process:
        logger.error("No enemy NPCs were identified or created for combat initiation.")
        return [], "System Error: Could not initiate combat (failed to identify/create enemies)."

    # --- Generate Unique Combat Names and Create Combat Entities ---
    enemy_entities = []
    name_counts: Dict[str, int] = {}
    player_combat_name = getattr(game_state.player, 'name', 'Player')

    for npc in npcs_to_process:
        base_name = npc.name
        combat_name = base_name
        if base_name == player_combat_name:
             combat_name = f"{base_name} (NPC)"

        current_count = name_counts.get(base_name, 0) + 1
        name_counts[base_name] = current_count
        if current_count > 1:
            combat_name = f"{base_name} {current_count}"

        final_name = combat_name
        temp_count = 1
        existing_combat_names = {e.combat_name for e in enemy_entities}
        while final_name == player_combat_name or final_name in existing_combat_names:
             temp_count += 1
             final_name = f"{combat_name}_{temp_count}"

        try:
            enemy_entity = create_enemy_combat_entity(npc, final_name)
            enemy_entities.append(enemy_entity)
        except TypeError as te:
            logger.error(f"TypeError creating combat entity for {npc.name} ({final_name}): {te}", exc_info=True)
            return [], f"System Error: Failed to create combat entity ({te})"
        except Exception as e:
            logger.error(f"Failed to create combat entity for {npc.name} ({final_name}): {e}", exc_info=True)
            return [], f"System Error: Failed to prepare enemy for combat ({e})"

    return enemy_entities, None # Return list and no error message if successful

def _determine_dynamic_enemy_details(request: Dict[str, Any], target_entity_id: str) -> Tuple[str, int]:
    """Determines enemy type and level from context for dynamic creation."""
    enemy_type = "hostile"
    level = 1
    reason = request.get("reason", "")
    additional_context = request.get("additional_context", {})

    # Determine enemy type from context/reason/name
    type_keywords = {
        "bandit": ["bandit", "thief", "rogue", "thug", "brigand"],
        "guard": ["guard", "soldier", "watchman", "sentinel", "cop", "police"],
        "wolf": ["wolf", "hound", "dog", "canine", "beast"],
        "goblin": ["goblin", "hobgoblin", "creature", "monster"],
        "skeleton": ["skeleton", "undead", "bones", "animated", "dead"],
        "giant": ["giant", "ogre", "troll", "colossus"],
        "dragon": ["dragon", "drake", "wyvern", "serpent"],
        "wizard": ["wizard", "mage", "witch", "warlock", "sorcerer", "magician"],
    }
    check_strings = [target_entity_id.lower(), reason.lower()]
    # Add more context strings if available, e.g., from additional_context["narrative_context"]

    for type_name, keywords in type_keywords.items():
        for string in check_strings:
            for keyword in keywords:
                if keyword in string:
                    enemy_type = type_name
                    logger.debug(f"Determined enemy type '{enemy_type}' from context")
                    break
            if enemy_type != "hostile": break
        if enemy_type != "hostile": break

    # Determine level from context
    level_indicators = {
        "boss": 5, "elder": 4, "powerful": 4, "strong": 3, "experienced": 3,
        "veteran": 3, "dangerous": 3, "mighty": 3, "lesser": 1, "weak": 1,
        "young": 1, "apprentice": 1, "novice": 1
    }
    for indicator, value in level_indicators.items():
        if indicator in target_entity_id.lower() or indicator in reason.lower():
            level = value
            logger.debug(f"Determined level {level} from context keyword '{indicator}'")
            break

    return enemy_type, level

# --- Helper: Flee Attempt ---

def _determine_flee_parameters(game_state: 'GameState', player_entity: CombatEntity) -> Tuple[int, int, List[str]]:
    """Determines the DC and situational modifier for a flee attempt."""
    flee_dc = 12 # Base difficulty
    situational_modifier = 0
    modifier_reasons = []
    player_status_effects = getattr(player_entity, 'status_effects', set())

    # Calculate DC based on enemies
    enemy_count = 0
    highest_enemy_initiative = 0
    if game_state.combat_manager and game_state.combat_manager.entities:
        for entity in game_state.combat_manager.entities.values():
            if entity.entity_type == EntityType.ENEMY:
                enemy_count += 1
                enemy_initiative = entity.get_stat(DerivedStatType.INITIATIVE) # Use get_stat
                highest_enemy_initiative = max(highest_enemy_initiative, enemy_initiative)

        flee_dc = max(flee_dc, 10 + int(highest_enemy_initiative)) # Ensure int
        if enemy_count > 1:
            dc_increase = min(enemy_count - 1, 5)
            flee_dc += dc_increase
            logger.debug(f"Adjusting flee DC by +{dc_increase} for {enemy_count} enemies to {flee_dc}")

    # Calculate situational modifier based on player status
    if "HASTED" in player_status_effects:
        situational_modifier += 2
        modifier_reasons.append("Hasted (+2)")
    if "SLOWED" in player_status_effects:
        situational_modifier -= 2
        modifier_reasons.append("Slowed (-2)")
    if "ENCUMBERED" in player_status_effects:
        situational_modifier -= 1
        modifier_reasons.append("Encumbered (-1)")
    # TODO: Add equipment/terrain modifiers

    logger.debug(f"Calculated Flee DC: {flee_dc}, Situational Modifier: {situational_modifier} ({', '.join(modifier_reasons)})")
    return flee_dc, situational_modifier, modifier_reasons

def _perform_flee_check(engine: 'GameEngine', player_entity: CombatEntity, flee_dc: int, situational_modifier: int, modifier_reasons: List[str]) -> Tuple[SkillCheckResult, str]:
    """Performs the Dexterity check for fleeing."""
    try:
        from core.stats.stats_manager import get_stats_manager
        stats_manager = get_stats_manager()
        entity_stats_manager = getattr(player_entity, 'stats_manager', None)

        if entity_stats_manager and hasattr(entity_stats_manager, 'perform_skill_check'):
            check_result = entity_stats_manager.perform_skill_check(
                stat_type=StatType.DEXTERITY, difficulty=flee_dc, situational_modifier=situational_modifier
            )
        elif stats_manager and hasattr(stats_manager, 'perform_skill_check'):
            logger.warning(f"Using global stats manager for flee check for entity {player_entity.id}")
            check_result = stats_manager.perform_skill_check(
                stat_type=StatType.DEXTERITY, difficulty=flee_dc, situational_modifier=situational_modifier
            )
        else:
            raise ValueError("Stats manager not available for flee check.")

        # Format the check result narrative
        modifier_str = f"{check_result.modifier} (stat)"
        if check_result.situational_modifier != 0:
            modifier_str += f" {check_result.situational_modifier:+}"
            if modifier_reasons: modifier_str += f" ({', '.join(modifier_reasons)})"
            else: modifier_str += " (situational)"

        check_output = (
            f"Flee attempt ({StatType.DEXTERITY.name} check DC {flee_dc}): "
            f"Roll {check_result.roll} + {modifier_str} "
            f"= {check_result.total} -> {check_result.outcome_desc}"
            f"{' (Crit!)' if check_result.critical else ''}"
        )
        engine._output("system", check_output)
        return check_result, check_output

    except Exception as e:
        logger.error(f"Error performing flee check for actor {player_entity.id}: {e}", exc_info=True)
        raise e # Re-raise the exception to be caught by the caller

def _handle_flee_outcome(game_state: 'GameState', success: bool, outcome_narrative: str) -> str:
    """Handles the outcome of the flee check, updating game state and returning narrative."""
    if success:
        if game_state.combat_manager and hasattr(game_state.combat_manager, 'end_combat'):
            game_state.combat_manager.end_combat("Player fled") # Pass reason
        game_state.combat_manager = None
        game_state.current_combatants = []
        game_state.set_interaction_mode(InteractionMode.NARRATIVE)
        narrative_result = f"You successfully escape the battle! {outcome_narrative} You find yourself back in the narrative."
        logger.info("Successfully fled combat. Transitioned to NARRATIVE mode.")
    else:
        narrative_result = f"You try to escape, but your enemies cut off your retreat! {outcome_narrative} You are still in combat."
        logger.info("Flee attempt failed. Remaining in COMBAT mode.")
    return narrative_result

# --- Main Transition Handlers ---

def _handle_transition_request(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Processes a mode transition request."""
    target_mode_str = request.get("target_mode")
    origin_mode_str = request.get("origin_mode")
    
    logger.debug(f"Handling Mode Transition Request: From {origin_mode_str} To {target_mode_str} by Actor {effective_actor_id}. Request Details: {json.dumps(request, indent=2)}")

    if not target_mode_str or not origin_mode_str:
        logger.error(f"ModeTransitionRequest missing target_mode or origin_mode: {request}")
        return "System Error: Mode transition request is incomplete."

    try:
        target_mode = InteractionMode[target_mode_str.upper()]
        origin_mode = InteractionMode[origin_mode_str.upper()]
    except KeyError:
        logger.error(f"Invalid mode name in ModeTransitionRequest: {request}")
        return f"System Error: Invalid mode name specified: {target_mode_str} or {origin_mode_str}."

    cooldown_message = _check_and_apply_cooldown(game_state, origin_mode, target_mode)
    if cooldown_message:
        # If in combat, queue message via orchestrator
        if game_state.current_mode == InteractionMode.COMBAT and hasattr(engine, '_combat_orchestrator') and game_state.combat_manager:
            from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
            event = DisplayEvent(
                type=DisplayEventType.SYSTEM_MESSAGE, content=cooldown_message,
                target_display=DisplayTarget.COMBAT_LOG, role="system"
            )
            engine._combat_orchestrator.add_event_to_queue(event)
            game_state.combat_manager.waiting_for_display_completion = True
        else: # Output directly if not in orchestrated combat context for this message
            engine._output("system", cooldown_message)
        return cooldown_message 

    narrative_result = ""
    transition_successful = False 
    original_mode_before_attempt = game_state.current_mode # Store for potential revert

    if origin_mode == InteractionMode.NARRATIVE and target_mode == InteractionMode.COMBAT:
        logger.debug("Setting game_state.is_transitioning_to_combat = True before calling _initiate_combat_transition.")
        game_state.is_transitioning_to_combat = True
        narrative_result = _initiate_combat_transition(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.COMBAT
        if narrative_result and not transition_successful: 
             game_state.is_transitioning_to_combat = False 
    elif origin_mode == InteractionMode.COMBAT and target_mode == InteractionMode.NARRATIVE:
        reason_lower = request.get("reason", "").lower()
        # Player surrender/flee from COMBAT mode is now primarily handled by CombatManager converting the
        # "request_mode_transition" into a FleeAction or processing surrender directly.
        # This _handle_transition_request function, when called by CombatManager,
        # is confirming if the mechanical outcome of that FleeAction/Surrender leads to a mode change.
        if game_state.combat_manager:
            actor_entity = game_state.combat_manager.get_entity_by_id(effective_actor_id)
            if actor_entity and not actor_entity.is_active_in_combat: # Flee was successful for this actor
                transition_successful = True
                narrative_result = f"{actor_entity.combat_name} has fled the battle."
                # Check if all players fled or all enemies defeated to actually change mode
                game_state.combat_manager._check_combat_state()
                if game_state.combat_manager.state != CombatState.IN_PROGRESS:
                    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
                    # CM will go to ENDING_COMBAT step.
                else: # Other players still in combat
                    narrative_result += " The battle continues for the others."
                    transition_successful = False # Mode doesn't change overall yet
            elif "surrender" in reason_lower:
                narrative_result = _attempt_surrender_transition(engine, game_state, request, effective_actor_id)
                transition_successful = game_state.current_mode == InteractionMode.NARRATIVE # surrender changes mode directly if successful
            else: # Generic "flee" reason, but actor still active (means mechanical flee failed or not processed yet)
                narrative_result = "Your attempt to leave combat was unsuccessful."
                transition_successful = False
        else:
            # Guard: if engine is already waiting for the orchestrated closing narrative, do not intervene.
            try:
                if hasattr(engine, '_waiting_for_closing_narrative_display') and engine._waiting_for_closing_narrative_display:
                    logger.info("Mode transition request received after combat finalize begun; ignoring extra transition and message.")
                    narrative_result = ""  # No extra message; finalization flow will handle narrative
                    transition_successful = True
                else:
                    logger.warning("Origin mode is COMBAT but CombatManager is missing. Treating as already concluded; switching to NARRATIVE.")
                    game_state.set_interaction_mode(InteractionMode.NARRATIVE)
                    narrative_result = "You are no longer in combat."
                    transition_successful = True
            except Exception:
                logger.warning("Guard failed; applying safe fallback to NARRATIVE.")
                game_state.set_interaction_mode(InteractionMode.NARRATIVE)
                narrative_result = "You are no longer in combat."
                transition_successful = True

    elif origin_mode == InteractionMode.NARRATIVE and target_mode == InteractionMode.TRADE:
        narrative_result = _initiate_trade_transition(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.TRADE
    elif origin_mode == InteractionMode.TRADE and target_mode == InteractionMode.NARRATIVE:
        narrative_result = _end_trade_transition(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.NARRATIVE
    elif origin_mode == InteractionMode.NARRATIVE and target_mode == InteractionMode.SOCIAL_CONFLICT:
        narrative_result = _initiate_social_conflict_transition(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.SOCIAL_CONFLICT
    elif origin_mode == InteractionMode.SOCIAL_CONFLICT and target_mode == InteractionMode.NARRATIVE:
        narrative_result = _end_social_conflict_transition(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.NARRATIVE
    elif origin_mode == InteractionMode.TRADE and target_mode == InteractionMode.SOCIAL_CONFLICT:
        narrative_result = _handle_trade_to_social_conflict(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.SOCIAL_CONFLICT
    elif origin_mode == InteractionMode.SOCIAL_CONFLICT and target_mode == InteractionMode.TRADE:
        narrative_result = _handle_social_conflict_to_trade(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.TRADE
    elif origin_mode == InteractionMode.TRADE and target_mode == InteractionMode.COMBAT:
        if not game_state.is_transitioning_to_combat: game_state.is_transitioning_to_combat = True
        narrative_result = _handle_trade_to_combat(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.COMBAT
        if not transition_successful: game_state.is_transitioning_to_combat = False
    elif origin_mode == InteractionMode.SOCIAL_CONFLICT and target_mode == InteractionMode.COMBAT:
        if not game_state.is_transitioning_to_combat: game_state.is_transitioning_to_combat = True
        narrative_result = _handle_social_conflict_to_combat(engine, game_state, request, effective_actor_id)
        transition_successful = game_state.current_mode == InteractionMode.COMBAT
        if not transition_successful: game_state.is_transitioning_to_combat = False
    else:
        logger.warning(f"Unhandled mode transition requested: {origin_mode.name} -> {target_mode.name}")
        narrative_result = f"System Warning: Requested transition from {origin_mode.name} to {target_mode.name} is not yet implemented."
        transition_successful = False

    if not transition_successful and game_state.current_mode == original_mode_before_attempt: # Only apply cooldown if mode didn't change at all
        narrative_result = _set_cooldown_on_failure(game_state, origin_mode, target_mode, narrative_result)
    
    if target_mode == InteractionMode.COMBAT and not transition_successful: 
        game_state.is_transitioning_to_combat = False # Ensure flag is reset on any COMBAT transition failure

    if narrative_result:
        role_for_output = "system" if "Error" in narrative_result or "Warning" in narrative_result else "gm"
        
        # If the current mode is COMBAT (e.g., failed flee/surrender text) and orchestrator exists
        if game_state.current_mode == InteractionMode.COMBAT and hasattr(engine, '_combat_orchestrator') and game_state.combat_manager:
            from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
            event = DisplayEvent(
                type=DisplayEventType.SYSTEM_MESSAGE, content=narrative_result,
                target_display=DisplayTarget.COMBAT_LOG, role=role_for_output
            )
            engine._combat_orchestrator.add_event_to_queue(event)
            game_state.combat_manager.waiting_for_display_completion = True
        elif game_state.current_mode != InteractionMode.COMBAT or not (transition_successful and target_mode == InteractionMode.COMBAT):
            # Output for non-combat transitions or if combat transition failed early and returned to NARRATIVE
            engine._output(role_for_output, narrative_result)

    return narrative_result 

def _attempt_surrender_transition(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the attempt to surrender from Combat to Narrative mode."""
    logger.info(f"Handling surrender attempt by {effective_actor_id}")
    active_enemies_remain = False
    enemy_details = [] 

    if game_state.combat_manager:
        for entity_id, entity in game_state.combat_manager.entities.items():
            if entity.entity_type == EntityType.ENEMY and \
               entity.is_alive() and \
               getattr(entity, 'is_active_in_combat', True):
                active_enemies_remain = True
                enemy_details.append(f"{entity.combat_name} (Active)")
            elif entity.entity_type == EntityType.ENEMY:
                 enemy_details.append(f"{entity.combat_name} (Inactive/Defeated)")
        logger.debug(f"Checking for active enemies for surrender: {enemy_details}")
    else:
        logger.warning("Cannot check for active enemies: CombatManager is None.")
        active_enemies_remain = True # Assume enemies if CM is missing

    if active_enemies_remain:
        logger.info("Surrender failed: Active enemies remain.")
        # Message will be queued by CombatManager's orchestrator path for failed transition
        narrative_result = "You attempt to surrender, but your enemies are not willing to accept your plea while they still stand!"
        # Do NOT change game_state.current_mode here. Caller (CombatManager) handles turn end.
        return narrative_result # Return feedback to be queued by CM
    else:
        logger.info("Surrender accepted (no active enemies). Ending combat.")
        final_combat_state_name = "PLAYER_SURRENDERED" # Or derive more specifically
        if game_state.combat_manager:
            # Let CombatManager handle its state change to FLED or a specific SURRENDER state if added
            game_state.combat_manager.state = CombatState.FLED # Using FLED as a proxy for player ending combat by choice
            reason = f"Player {effective_actor_id} surrendered."
            if hasattr(game_state.combat_manager, 'end_combat'): # This method might set a more specific state
                 game_state.combat_manager.end_combat(reason)
            final_combat_state_name = game_state.combat_manager.state.name


        # Game state changes (mode, clearing CM) are handled by CombatManager when its step becomes ENDING_COMBAT / COMBAT_ENDED
        # or by the calling function in CombatManager._step_processing_player_action if transition is successful.
        # This function's role is to determine IF surrender is mechanically possible and give feedback.
        # The actual mode change is now handled by the caller in CombatManager based on this outcome.
        game_state.set_interaction_mode(InteractionMode.NARRATIVE) # If successful, mode changes
        if game_state.combat_manager: game_state.combat_manager = None # Clear CM if mode changed
        game_state.current_combatants = []

        narrative_result = f"Your surrender is accepted as there are no active opponents. The combat ends ({final_combat_state_name})."
        # engine._output("system", narrative_result) # Orchestrator will handle this via CM queue
        return narrative_result

def _initiate_combat_transition(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Prepares for the transition to Combat mode, setting up CombatManager."""
    logger.info(f"[MODE TRANSITION] Initiating NARRATIVE -> COMBAT. Request: {json.dumps(request, indent=2)}")

    # The initiating narrative (e.g., "You lunge at the guard...") is now expected to be in
    # game_state.combat_narrative_buffer, put there by MainWindow because
    # game_state.is_transitioning_to_combat was set to True by _handle_transition_request
    # before this function was called. This function no longer outputs it.

    # Extract original_intent for CombatManager.prepare_for_combat
    additional_context = request.get("additional_context", {})
    original_intent = additional_context.get("original_intent", "Unknown combat-initiating action")
    # narrative_context_for_log = additional_context.get("narrative_context", "") # For logging if needed

    # logger.debug(f"Original player intent for combat: '{original_intent}'")
    # logger.debug(f"Narrative context that led to combat: '{narrative_context_for_log[:100]}...'")


    if game_state.current_mode == InteractionMode.COMBAT:
        # If there is no active/in-progress CombatManager, force reset to NARRATIVE and continue
        try:
            from core.combat.enums import CombatState
            cm = getattr(game_state, 'combat_manager', None)
            if not cm or getattr(cm, 'state', None) != CombatState.IN_PROGRESS:
                logger.warning("Current mode is COMBAT but no active in-progress CombatManager. Forcing reset to NARRATIVE and continuing with new combat.")
                game_state.set_interaction_mode(InteractionMode.NARRATIVE)
            else:
                logger.warning("Attempted to initiate combat while already in COMBAT mode.")
                # game_state.is_transitioning_to_combat = False # Should be handled by caller if transition fails overall
                return "System Warning: Already in combat." # Return message to caller
        except Exception:
            # On any error determining CM state, be conservative and block duplicate combat
            logger.warning("Error checking CombatManager state while already in COMBAT mode. Blocking duplicate initiation.")
            return "System Warning: Already in combat."

    if game_state.combat_manager:
        logger.warning("Clearing existing CombatManager before initiating new combat.")
        game_state.combat_manager = None
        if hasattr(engine, '_combat_orchestrator'): 
            engine._combat_orchestrator.set_combat_manager(None)
            engine._combat_orchestrator.clear_queue_and_reset_flags()

    game_state.current_combatants = []
    # game_state.combat_narrative_buffer is populated by MainWindow

    try:
        enemy_entities, error_msg = _create_combat_enemies(game_state, request)
        if error_msg:
            # game_state.is_transitioning_to_combat = False # Handled by caller on error
            return error_msg 

        player_combat_name = game_state.player.name
        enemy_combat_names = {e.combat_name for e in enemy_entities}
        if player_combat_name in enemy_combat_names:
            player_combat_name += " (Player)"

        try:
            player_entity = create_player_combat_entity(game_state, player_combat_name)
        except Exception as e:
            logger.error(f"Failed to create player combat entity: {e}", exc_info=True)
            # game_state.is_transitioning_to_combat = False # Handled by caller
            return "System Error: Failed to prepare player for combat."

        combat_manager = CombatManager()
        game_state.combat_manager = combat_manager 
        if hasattr(engine, '_combat_orchestrator'): 
            engine._combat_orchestrator.set_combat_manager(combat_manager)

        surprise = request.get("surprise", False)
        
        combat_manager.prepare_for_combat(
            player_entity=player_entity,
            enemy_entities=enemy_entities,
            surprise=surprise,
            initiating_intent=original_intent 
        )
        logger.info("CombatManager initialized and prepared with entities.")

        # Set the mode. MainWindow._update_ui will detect this change.
        # If is_transitioning_to_combat is still true, _update_ui will handle flushing the buffer.
        game_state.set_interaction_mode(InteractionMode.COMBAT) 
        logger.info("Transitioned game_state to COMBAT mode.")
        
        # The first call to combat_manager.process_combat_step(engine) is now triggered
        # by MainWindow._update_ui after it processes the mode switch and potentially
        # queues the BUFFER_FLUSH event with the orchestrator. The orchestrator then starts CM.

        return "" # Success, no direct narrative output.

    except Exception as e:
        logger.error(f"Error initiating combat transition: {e}", exc_info=True)
        # game_state.is_transitioning_to_combat = False # Handled by caller
        if game_state.combat_manager: game_state.combat_manager = None
        if hasattr(engine, '_combat_orchestrator'): engine._combat_orchestrator.set_combat_manager(None)
        game_state.current_combatants = []
        # If mode somehow got set to COMBAT, revert it
        if game_state.current_mode == InteractionMode.COMBAT: 
            game_state.set_interaction_mode(InteractionMode.NARRATIVE) # This will also clear is_transitioning_to_combat
        return f"System Error: Failed to initiate combat transition: {str(e)}"

def _attempt_flee_transition(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the attempt to flee from Combat to Narrative mode."""
    logger.info(f"Attempting to flee combat for actor {effective_actor_id}.")
    narrative_result = "Flee attempt processing..." # Default
    
    if not game_state.combat_manager:
        logger.error("Cannot attempt flee: CombatManager is None.")
        game_state.set_interaction_mode(InteractionMode.NARRATIVE)
        return "System Error: Combat already concluded or in error state. Flee not applicable."

    player_entity = game_state.combat_manager.get_entity_by_id(effective_actor_id)

    if not player_entity:
        logger.error(f"Could not get player entity for flee check: {effective_actor_id}")
        return "System Error: Cannot perform flee check (player entity unavailable)."

    
    if game_state.combat_manager.state == CombatState.FLED and not player_entity.is_active_in_combat:
        game_state.set_interaction_mode(InteractionMode.NARRATIVE)
        game_state.combat_manager = None 
        game_state.current_combatants = []
        narrative_result = "You successfully escaped the battle!"
        logger.info(f"Flee successful for {effective_actor_id}. Transitioned to NARRATIVE.")
    else:
        narrative_result = "Your attempt to flee was unsuccessful. The battle continues!" # Placeholder
        logger.info(f"Flee attempt for {effective_actor_id} seems to have failed or is being handled by CM. Staying in COMBAT.")
        
    return narrative_result 


def _initiate_trade_transition(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Narrative to Trade mode."""
    target_entity_id = request.get("target_entity_id")
    if not target_entity_id:
        logger.error("Initiate trade request missing target_entity_id.")
        return "System Error: Who do you want to trade with?"

    trade_partner = get_participant_by_id(game_state, target_entity_id)
    if not trade_partner:
        logger.warning(f"Target entity '{target_entity_id}' not found for trading.")
        return f"You don't see '{target_entity_id}' here to trade with."

    game_state.current_trade_partner_id = target_entity_id
    game_state.set_interaction_mode(InteractionMode.TRADE)

    partner_name = getattr(trade_partner, 'name', target_entity_id)
    narrative_result = f"You approach {partner_name} to trade."
    logger.info(f"Transitioned to TRADE mode with partner {target_entity_id}.")
    return narrative_result

def _end_trade_transition(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Trade to Narrative mode."""
    if game_state.current_mode != InteractionMode.TRADE:
        logger.warning("Attempted to end trade when not in TRADE mode.")
        return ""

    partner_id = game_state.current_trade_partner_id
    partner_name = "your trading partner"
    if partner_id:
        trade_partner = get_participant_by_id(game_state, partner_id)
        if trade_partner:
            partner_name = getattr(trade_partner, 'name', partner_id)

    game_state.current_trade_partner_id = None
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)

    narrative_result = f"You finish trading with {partner_name}."
    logger.info("Ended trade. Transitioned back to NARRATIVE mode.")
    return narrative_result

def _initiate_social_conflict_transition(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Narrative to Social Conflict mode."""
    target_entity_id = request.get("target_entity_id")
    if not target_entity_id:
        logger.error("Initiate social conflict request missing target_entity_id.")
        return "System Error: Who do you want to engage in a social conflict with?"

    conflict_partner = get_participant_by_id(game_state, target_entity_id)
    if not conflict_partner:
        logger.warning(f"Target entity '{target_entity_id}' not found for social conflict.")
        return f"You don't see '{target_entity_id}' here to confront."

    player_id = getattr(game_state.player, 'id', getattr(game_state.player, 'stats_manager_id', None))
    if not player_id:
        logger.error("Cannot initiate social conflict: Player ID not found.")
        return "System Error: Cannot determine player identity for social conflict."

    if player_id == target_entity_id:
        return "You cannot start a social conflict with yourself."

    game_state.current_combatants = [player_id, target_entity_id]
    game_state.set_interaction_mode(InteractionMode.SOCIAL_CONFLICT)

    # Initialize resolve (example)
    player_entity = get_participant_by_id(game_state, player_id)
    if player_entity and hasattr(player_entity, 'stats_manager') and hasattr(player_entity.stats_manager, 'set_current_stat'):
        initial_player_resolve = getattr(player_entity.stats_manager, 'get_stat', lambda s: 10)('resolve')
        player_entity.stats_manager.set_current_stat('resolve', initial_player_resolve)
        logger.debug(f"Initialized player {player_id} resolve to {initial_player_resolve}")

    if conflict_partner and hasattr(conflict_partner, 'stats_manager') and hasattr(conflict_partner.stats_manager, 'set_current_stat'):
        initial_partner_resolve = getattr(conflict_partner.stats_manager, 'get_stat', lambda s: 10)('resolve')
        conflict_partner.stats_manager.set_current_stat('resolve', initial_partner_resolve)
        logger.debug(f"Initialized partner {target_entity_id} resolve to {initial_partner_resolve}")

    partner_name = getattr(conflict_partner, 'name', target_entity_id)
    narrative_result = f"You initiate a social conflict with {partner_name}."
    logger.info(f"Transitioned to SOCIAL_CONFLICT mode with participants: {game_state.current_combatants}.")
    return narrative_result

def _end_social_conflict_transition(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Social Conflict to Narrative mode."""
    if game_state.current_mode != InteractionMode.SOCIAL_CONFLICT:
        logger.warning("Attempted to end social conflict when not in SOCIAL_CONFLICT mode.")
        return ""

    participants = game_state.current_combatants[:]
    participant_names = [getattr(get_participant_by_id(game_state, p_id), 'name', p_id) for p_id in participants]

    game_state.current_combatants = []
    game_state.set_interaction_mode(InteractionMode.NARRATIVE)

    narrative_result = f"The social conflict between {', '.join(participant_names)} ends."
    logger.info("Ended social conflict. Transitioned back to NARRATIVE mode.")
    return narrative_result

def _perform_charisma_check(engine: 'GameEngine', actor: Any, target_name: str, dc: int, context_msg: str) -> Tuple[bool, str]:
    """Performs a Charisma check and returns success status and narrative."""
    if not hasattr(actor, 'stats_manager') or not hasattr(actor.stats_manager, 'perform_skill_check'):
        raise AttributeError(f"Actor {getattr(actor, 'name', 'Unknown')} has no stats_manager or perform_skill_check method.")

    check_result = actor.stats_manager.perform_skill_check(stat_type=StatType.CHARISMA, difficulty=dc)
    check_narrative = (
        f"{getattr(actor, 'name', 'Unknown')} attempts to {context_msg} with {target_name} ({StatType.CHARISMA.name} check DC {dc}): "
        f"Roll {check_result.roll} + {check_result.modifier} (stat) = {check_result.total} -> {check_result.outcome_desc}"
    )
    engine._output("system", check_narrative)
    return check_result.is_success, check_result.outcome_desc

def _handle_trade_to_social_conflict(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Trade to Social Conflict mode."""
    logger.info(f"Attempting transition TRADE -> SOCIAL_CONFLICT for actor {effective_actor_id}")

    target_entity_id = request.get("target_entity_id") or game_state.current_trade_partner_id
    if not target_entity_id:
        logger.error("Transition TRADE -> SOCIAL_CONFLICT failed: No target.")
        return "System Error: Cannot transition to social conflict without a target."
    request["target_entity_id"] = target_entity_id

    actor = get_participant_by_id(game_state, effective_actor_id)
    target = get_participant_by_id(game_state, target_entity_id)
    if not actor or not target:
        logger.error(f"Transition TRADE -> SOCIAL_CONFLICT failed: Participants not found.")
        return "System Error: Could not find participants for social conflict."

    actor_name = getattr(actor, 'name', effective_actor_id)
    target_name = getattr(target, 'name', target_entity_id)

    try:
        success, outcome_desc = _perform_charisma_check(engine, actor, target_name, 13, "escalate trade")
        if success:
            logger.info("Charisma check succeeded. Transitioning TRADE -> SOCIAL_CONFLICT.")
            end_trade_narrative = _end_trade_transition(engine, game_state, request, effective_actor_id)
            init_social_narrative = _initiate_social_conflict_transition(engine, game_state, request, effective_actor_id)
            transition_reason = request.get("reason", "The situation escalates.")
            return f"{end_trade_narrative} {transition_reason} {init_social_narrative}"
        else:
            logger.info("Charisma check failed. Remaining in TRADE mode.")
            return f"Your attempt to escalate the situation with {target_name} fails ({outcome_desc}). You remain in trade."
    except Exception as e:
        logger.error(f"Error during TRADE -> SOCIAL_CONFLICT transition check: {e}", exc_info=True)
        return f"System Error: Failed to perform transition check: {str(e)}"

def _handle_social_conflict_to_trade(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Social Conflict to Trade mode."""
    logger.info(f"Attempting transition SOCIAL_CONFLICT -> TRADE for actor {effective_actor_id}")

    target_entity_id = request.get("target_entity_id")
    if not target_entity_id:
        participants = game_state.current_combatants
        if len(participants) == 2:
            target_entity_id = next((p_id for p_id in participants if p_id != effective_actor_id), None)
            if target_entity_id: request["target_entity_id"] = target_entity_id
            else: return "System Error: Cannot determine target for trade transition."
        else: return "System Error: Cannot transition to trade without a clear target."

    actor = get_participant_by_id(game_state, effective_actor_id)
    target = get_participant_by_id(game_state, target_entity_id)
    if not actor or not target:
        logger.error(f"Transition SOCIAL_CONFLICT -> TRADE failed: Participants not found.")
        return "System Error: Could not find participants for trade transition."

    actor_name = getattr(actor, 'name', effective_actor_id)
    target_name = getattr(target, 'name', target_entity_id)

    try:
        success, outcome_desc = _perform_charisma_check(engine, actor, target_name, 15, "de-escalate conflict into trade")
        if success:
            logger.info("Charisma check succeeded. Transitioning SOCIAL_CONFLICT -> TRADE.")
            end_social_narrative = _end_social_conflict_transition(engine, game_state, request, effective_actor_id)
            init_trade_narrative = _initiate_trade_transition(engine, game_state, request, effective_actor_id)
            transition_reason = request.get("reason", "You manage to calm the situation.")
            return f"{end_social_narrative} {transition_reason} {init_trade_narrative}"
        else:
            logger.info("Charisma check failed. Remaining in SOCIAL_CONFLICT mode.")
            return f"Your attempt to de-escalate the conflict with {target_name} fails ({outcome_desc}). The social conflict continues."
    except Exception as e:
        logger.error(f"Error during SOCIAL_CONFLICT -> TRADE transition check: {e}", exc_info=True)
        return f"System Error: Failed to perform transition check: {str(e)}"

def _handle_trade_to_combat(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Trade to Combat mode."""
    logger.info(f"Attempting transition TRADE -> COMBAT for actor {effective_actor_id}")

    target_entity_id = request.get("target_entity_id") or game_state.current_trade_partner_id
    if not target_entity_id:
        logger.error("Transition TRADE -> COMBAT failed: No target.")
        return "System Error: Cannot transition to combat without a target."
    request["target_entity_id"] = target_entity_id

    target = get_participant_by_id(game_state, target_entity_id)
    if not target:
        logger.error(f"Transition TRADE -> COMBAT failed: Target ({target_entity_id}) not found.")
        return "System Error: Could not find target for combat transition."
    if not hasattr(target, 'stats_manager') and not hasattr(target, 'get_stat'):
        logger.warning(f"Target {target_entity_id} does not appear combat-capable.")
        return f"System Error: {getattr(target, 'name', target_entity_id)} cannot engage in combat."

    end_trade_narrative = _end_trade_transition(engine, game_state, request, effective_actor_id)
    combat_request = {
        "target_mode": "COMBAT", "origin_mode": "TRADE",
        "reason": request.get("reason", "Trade escalated to combat."),
        "target_entity_id": target_entity_id, "surprise": request.get("surprise", False)
    }
    init_combat_narrative = _initiate_combat_transition(engine, game_state, combat_request, effective_actor_id)
    return f"{end_trade_narrative} The situation rapidly escalates! {init_combat_narrative}"

def _handle_social_conflict_to_combat(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Handles the transition from Social Conflict to Combat mode."""
    logger.info(f"Attempting transition SOCIAL_CONFLICT -> COMBAT for actor {effective_actor_id}")

    target_entity_id = request.get("target_entity_id")
    if not target_entity_id:
        participants = game_state.current_combatants
        if len(participants) == 2:
            target_entity_id = next((p_id for p_id in participants if p_id != effective_actor_id), None)
            if target_entity_id: request["target_entity_id"] = target_entity_id
            else: return "System Error: Cannot determine target for combat transition."
        else: return "System Error: Cannot transition to combat without a clear target."

    target = get_participant_by_id(game_state, target_entity_id)
    if not target:
        logger.error(f"Transition SOCIAL_CONFLICT -> COMBAT failed: Target ({target_entity_id}) not found.")
        return "System Error: Could not find target for combat transition."
    if not hasattr(target, 'stats_manager') and not hasattr(target, 'get_stat'):
        logger.warning(f"Target {target_entity_id} does not appear combat-capable.")
        return f"System Error: {getattr(target, 'name', target_entity_id)} cannot engage in combat."

    end_social_narrative = _end_social_conflict_transition(engine, game_state, request, effective_actor_id)
    combat_request = {
        "target_mode": "COMBAT", "origin_mode": "SOCIAL_CONFLICT",
        "reason": request.get("reason", "Social conflict escalated to combat."),
        "target_entity_id": target_entity_id, "surprise": request.get("surprise", False)
    }
    init_combat_narrative = _initiate_combat_transition(engine, game_state, combat_request, effective_actor_id)
    return f"{end_social_narrative} Words fail, and the situation turns violent! {init_combat_narrative}"

```

### File: core\game_flow\npc_interaction.py

```python
#!/usr/bin/env python3
"""
Handles logic related to NPC actions and interactions.
"""

import logging
import json
import re # Import re for cleaning intent
from typing import Optional, TYPE_CHECKING, Dict, Any

from core.interaction.enums import InteractionMode
from core.interaction.context_builder import ContextBuilder
from core.combat.combat_entity import EntityType
from core.agents.base_agent import AgentContext
from core.agents.combat_narrator import get_combat_narrator_agent

if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState
    from core.combat.combat_manager import CombatManager 


logger = logging.getLogger("INTERACTION_PROC") # Keep original logger name


def get_npc_intent(engine: 'GameEngine', game_state: 'GameState', npc_id: str) -> Optional[str]:
    """
    Determine the NPC's intended action using an LLM agent.

    Args:
        engine: The GameEngine instance.
        game_state: The current game state.
        npc_id: The ID of the NPC whose turn it is.

    Returns:
        A string describing the NPC's intended action, or None if failed.
    """
    if not engine._use_llm or engine._agent_manager is None:
        logger.warning(f"LLM disabled or AgentManager not available. Cannot get intent for NPC {npc_id}.")
        if game_state.current_mode == InteractionMode.COMBAT:
            logger.info(f"Using fallback combat intent for NPC {npc_id}: 'Attack the player'")
            return "Attack the player"
        return None

    current_mode = game_state.current_mode
    logger.debug(f"Building context for NPC {npc_id} in mode {current_mode.name}")
    try:
        context_builder = ContextBuilder()
        context = context_builder.build_context(game_state, current_mode, actor_id=npc_id)
        
        if current_mode == InteractionMode.COMBAT and game_state.combat_manager:
            combat_manager = game_state.combat_manager
            current_entity = combat_manager.get_entity_by_id(npc_id) if hasattr(combat_manager, 'get_entity_by_id') else None
            player_entity = None
            for entity_id, entity in combat_manager.entities.items():
                 if hasattr(entity, 'entity_type') and entity.entity_type == EntityType.PLAYER:
                     player_entity = entity
                     break
            if current_entity and player_entity:
                 combat_status = {
                     "current_entity": {"id": npc_id, "name": getattr(current_entity, 'name', 'Unknown'), "hp": getattr(current_entity, 'current_hp', 0), "max_hp": getattr(current_entity, 'max_hp', 0)},
                     "player": {"id": player_entity.id, "name": player_entity.name, "hp": player_entity.current_hp, "max_hp": player_entity.max_hp},
                     "turn_order": combat_manager.turn_order,
                     "current_turn": npc_id,
                     "round": combat_manager.round_number
                 }
                 if 'combat_context' not in context: context['combat_context'] = {}
                 context['combat_context'].update(combat_status)

        prompt = (
            f"You are the AI controlling the character '{npc_id}'.\n"
            f"Current Situation:\n{json.dumps(context, indent=2, default=str)}\n" 
            f"Game Mode: {current_mode.name}\n"
            f"It is currently your turn ('{npc_id}').\n"
            f"Based on the situation, your character's likely goals, stats, and available abilities (if known), "
            f"state the *single, specific action* you will take this turn. Be concise and action-oriented.\n"
            f"Examples: 'Attack the player with sword', 'Cast Fireball at Qa', 'Use Healing Potion on self', 'Defend', 'Attempt to flee'.\n"
            f"Your Action Intent:" 
        )
        logger.debug(f"Generated NPC intent prompt for {npc_id}:\n{prompt[:500]}...")

        intent_agent_context = AgentContext(
             game_state={}, player_state={}, world_state={},
             player_input=prompt, 
             conversation_history=[], relevant_memories=[], additional_context={}
        )
        intent_response = None
        try:
            narrator_agent = engine._agent_manager._narrator_agent 
            if not narrator_agent:
                raise ValueError("NarratorAgent instance not found in AgentManager.")
            if not hasattr(narrator_agent, '_llm_manager'):
                 raise AttributeError("NarratorAgent does not have _llm_manager attribute.")

            llm_manager = narrator_agent._llm_manager
            
            messages = narrator_agent._prepare_messages(intent_agent_context)

            llm_response = llm_manager.get_completion(
                 messages=messages,
                 provider_type=narrator_agent._provider_type,
                 model=narrator_agent._model or None,
                 temperature=0.5, 
                 max_tokens=50 
            )

            if llm_response and llm_response.content:
                 intent_response = llm_response.content
            else:
                 raise ValueError("LLM returned no content for NPC intent.")

        except Exception as e:
            logger.error(f"Error calling LLM for NPC intent string: {e}", exc_info=True) 
            if current_mode == InteractionMode.COMBAT:
                intent_response = "Attack the player"
                logger.info(f"Using fallback combat intent for NPC {npc_id}: '{intent_response}'")
            else:
                intent_response = None 

        if intent_response:
            cleaned_intent = intent_response.strip()
            cleaned_intent = re.sub(r'^(action intent|my action|action|intent)\s*[:\-]\s*', '', cleaned_intent, flags=re.IGNORECASE)
            cleaned_intent = cleaned_intent.strip('"\'')
            logger.info(f"LLM returned intent string for NPC {npc_id}: '{cleaned_intent}'")
            return cleaned_intent
        else:
            logger.error(f"LLM Agent failed to generate intent string for NPC {npc_id}.")
            return None

    except Exception as e:
        logger.error(f"Error getting NPC intent for {npc_id}: {e}", exc_info=True)
        return None

def trigger_combat_narration(engine: 'GameEngine', game_state: 'GameState', narrative_context: Optional[str] = None):
    """Triggers the CombatNarratorAgent to provide initial combat description."""
    if not engine._use_llm:
        logger.warning("Cannot trigger combat narration: LLM disabled.")
        # Basic fallback message
        enemy_names = "some enemies"
        if game_state.combat_manager:
             enemies = [e.name for e in game_state.combat_manager.entities.values() if e.entity_type == EntityType.ENEMY]
             if enemies: enemy_names = ', '.join(enemies)
        engine._output("gm", f"Combat begins against {enemy_names}!")
        return

    # Use the Combat Narrator Agent instance from the engine if available
    combat_narrator = getattr(engine, '_combat_narrator_agent', None)
    if combat_narrator is None:
        logger.error("CombatNarratorAgent not found on engine. Cannot trigger narration.")
        engine._output("system", "Error: Combat narrator is unavailable.")
        return

    logger.info("Triggering CombatNarratorAgent for initial combat description.")
    try:
        context_builder = ContextBuilder()
        context_dict = context_builder.build_context(game_state, InteractionMode.COMBAT)

        # Use a system event description as the "input"
        player_input_event = "[System Event: Combat Started]"
        if narrative_context:
            player_input_event += f"\nInitial Context: {narrative_context}"


        agent_context = AgentContext(
            game_state=context_dict, # Pass the built dictionary
            player_state=context_dict.get('player', {}),
            world_state={k: v for k, v in context_dict.items() if k in ['location', 'time_of_day', 'environment']},
            player_input=player_input_event,
            conversation_history=game_state.conversation_history,
            relevant_memories=[],
            additional_context=context_dict # Pass the full context here too
        )

        # Call the CombatNarratorAgent's process method
        agent_output = combat_narrator.process(agent_context) # Use the instance variable

        if agent_output and agent_output.get("narrative"):
            logger.info("CombatNarratorAgent provided initial narration.")
            engine._output("gm", agent_output["narrative"])
            # Process initial requests if needed (e.g., surprise checks derived from narration)
            # initial_requests = agent_output.get("requests", [])
            # if initial_requests: ... process ...
        else:
            logger.warning("CombatNarratorAgent failed to provide initial narration (or returned empty).")
            # Fallback message
            enemy_names = "some enemies"
            if game_state.combat_manager:
                 enemies = [e.name for e in game_state.combat_manager.entities.values() if e.entity_type == EntityType.ENEMY]
                 if enemies: enemy_names = ', '.join(enemies)
            engine._output("gm", f"Combat begins against {enemy_names}!")

    except Exception as e:
        logger.error(f"Error triggering combat narration: {e}", exc_info=True)
        engine._output("system", f"Error generating combat start narration: {e}")
```

### File: core\game_flow\quest_updates.py

```python
#!/usr/bin/env python3
"""
Quest update application module: validates and applies LLM-proposed quest/objective updates.
Includes a minimal DSL evaluator for deterministic objectives and orchestrated messages.
"""
from __future__ import annotations
from typing import Dict, Any, Tuple, Optional, List

from core.utils.logging_config import get_logger
from core.base.config import get_config
import re

# Event log recorders
try:
    from core.game_flow.event_log import (
        record_objective_status,
        record_quest_status,
        EV_ENEMY_DEFEATED,
        EV_ITEM_DELTA,
        EV_LOCATION_VISITED,
        EV_DIALOGUE,
        EV_INTERACTION,
        EV_FLAG_SET,
    )
except Exception:  # fallback if not yet available
    record_objective_status = lambda *args, **kwargs: None
    record_quest_status = lambda *args, **kwargs: None
    EV_ENEMY_DEFEATED = "EnemyDefeated"
    EV_ITEM_DELTA = "ItemDelta"
    EV_LOCATION_VISITED = "LocationVisited"
    EV_DIALOGUE = "DialogueCompleted"
    EV_INTERACTION = "InteractionCompleted"
    EV_FLAG_SET = "FlagSet"

logger = get_logger("QUESTS")

# Developer-verbose quest logging toggle (read from config)

def _dev_quest_verbose() -> bool:
    """Return True if developer quest logs should be shown in the UI.
    Checks config dev.quest_verbose first; falls back to QSettings dev/enabled or dev/quest_verbose.
    """
    try:
        cfg = get_config()
        val = cfg.get("dev.quest_verbose", None)
        if isinstance(val, bool):
            return val
    except Exception:
        pass
    # Fallback to QSettings (GUI toggle)
    try:
        from PySide6.QtCore import QSettings
        s = QSettings("RPGGame", "Settings")
        # Respect dedicated quest verbose flag if set; otherwise use dev/enabled as a coarse switch
        if s.contains("dev/quest_verbose"):
            return bool(s.value("dev/quest_verbose", False, type=bool))
        return bool(s.value("dev/enabled", False, type=bool))
    except Exception:
        return False


def _queue_dev(engine, text: str) -> None:
    """Queue a dev quest message to MAIN_GAME_OUTPUT if dev.quest_verbose is enabled."""
    if not _dev_quest_verbose():
        return
    try:
        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        engine._combat_orchestrator.add_event_to_queue(
            DisplayEvent(
                type=DisplayEventType.SYSTEM_MESSAGE,
                content=f"[DEV][QUEST] {text}",
                target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                gradual_visual_display=False,
                tts_eligible=False,
            )
        )
    except Exception:
        # Swallow errors to avoid impacting gameplay
        pass

# --- Minimal DSL evaluator ---

def _eval_condition_dsl(dsl: Any, signals: Dict[str, Any]) -> Optional[bool]:
    """Evaluate minimal boolean DSL against signals. Return True/False/None (unknown)."""
    try:
        if dsl is None:
            return None
        if isinstance(dsl, bool):
            return dsl
        if isinstance(dsl, dict):
            # Supported forms: {op: args}
            if 'all' in dsl:
                return all(_eval_condition_dsl(x, signals) is True for x in dsl['all'])
            if 'any' in dsl:
                return any(_eval_condition_dsl(x, signals) is True for x in dsl['any'])
            if 'none' in dsl:
                return all(_eval_condition_dsl(x, signals) is False for x in dsl['none'])
            if 'inventory_has' in dsl:
                item_id = dsl['inventory_has'].get('item_id')
                count = int(dsl['inventory_has'].get('count', 1))
                inv = signals.get('inventory', {})
                have = inv.get(item_id, 0)
                return bool(have >= count)
            if 'defeated' in dsl:
                entity_id = dsl['defeated']
                return bool(entity_id in (signals.get('defeated', [])))
            if 'visited' in dsl:
                loc_id = dsl['visited']
                return bool(loc_id in (signals.get('visited', [])))
            if 'flag' in dsl:
                key = dsl['flag'].get('key')
                val = dsl['flag'].get('value', True)
                return bool(signals.get('flags', {}).get(key) == val)
            if 'time_before' in dsl:
                t = float(dsl['time_before'])
                return bool(signals.get('time', 0.0) < t)
            if 'time_after' in dsl:
                t = float(dsl['time_after'])
                return bool(signals.get('time', 0.0) > t)
        return None
    except Exception as e:
        logger.warning(f"DSL eval error: {e}")
        return None

# --- Signals builder (phase 1: derive from current state and event log) ---

def _build_signals(game_state) -> Dict[str, Any]:
    """Construct signals snapshot used by the DSL evaluator.
    Phase 1: build from inventory and event_log (defeats, visits, flags, time).
    """
    inv_counts: Dict[str, int] = {}
    try:
        from core.inventory import get_inventory_manager
        im = get_inventory_manager()
        # Aggregate inventory by template_id (fallback to name) and sum quantities
        for itm in getattr(im, 'items', []) or []:
            try:
                tid = getattr(itm, 'template_id', None) or getattr(itm, 'name', None)
                if not tid:
                    continue
                qty = int(getattr(itm, 'quantity', 1) or 1)
                inv_counts[tid] = inv_counts.get(tid, 0) + qty
            except Exception:
                continue
    except Exception:
        pass

    defeated_ids: List[str] = []
    visited_ids: List[str] = []
    try:
        log = getattr(game_state, 'event_log', []) or []
        # Include template_id, entity_id, and normalized combat names for defeated
        for ev in log:
            et = ev.get('type')
            if et == EV_ENEMY_DEFEATED:
                eid = ev.get('entity_id'); tid = ev.get('template_id')
                tags = ev.get('tags', {}) or {}
                cname = str(tags.get('combat_name', '') or '').strip()
                # Lowercase all candidates
                if tid:
                    defeated_ids.append(str(tid).lower())
                if eid:
                    defeated_ids.append(str(eid).lower())
                if cname:
                    defeated_ids.append(cname.lower())
                    # Base name by stripping trailing _<digits>
                    base = re.sub(r'_[0-9]+$', '', cname.lower())
                    if base and base != cname.lower():
                        defeated_ids.append(base)
            elif et == EV_LOCATION_VISITED:
                lid = ev.get('location_id')
                if lid: visited_ids.append(str(lid).lower())
    except Exception:
        pass

    # Build flags/time
    try:
        flags = getattr(game_state.world, 'global_vars', {}) if hasattr(game_state, 'world') else {}
    except Exception:
        flags = {}
    try:
        tnow = getattr(game_state.world, 'game_time', 0.0)
    except Exception:
        tnow = 0.0

    signals = {
        'inventory': inv_counts,            # Dict[template_id_or_name, count]
        'defeated': defeated_ids,           # List of ids/templates seen defeated
        'visited': visited_ids,             # List of visited location ids
        'flags': flags or {},
        'time': tnow,
    }
    return signals

# --- Evidence verification ---

def _verify_evidence(game_state, payload: Dict[str, Any]) -> Tuple[bool, str]:
    """Verify at least one piece of evidence against engine records.
    Evidence schema examples:
      {"type":"defeated","id":"entity_or_template_id"}
      {"type":"item","id":"item_id","count":1}
      {"type":"visited","id":"location_id"}
      {"type":"flag","key":"flag.key","value":true}
      {"type":"dialogue","id":"dialogue_id"}
      {"type":"interaction","id":"interaction_id"}
    """
    evid = payload.get('evidence')
    if not isinstance(evid, list) or not evid:
        return False, 'No evidence provided'

    log: List[Dict[str, Any]] = getattr(game_state, 'event_log', []) if hasattr(game_state, 'event_log') else []

    # Access inventory and flags if needed
    inv_counts: Dict[str, int] = {}
    try:
        from core.inventory import get_inventory_manager
        im = get_inventory_manager()
        # Aggregate by template_id (fallback to name) and sum quantities
        for itm in getattr(im, 'items', []):
            try:
                tid = getattr(itm, 'template_id', None) or getattr(itm, 'name', None)
                if not tid:
                    continue
                qty = int(getattr(itm, 'quantity', 1) or 1)
                inv_counts[tid] = inv_counts.get(tid, 0) + qty
            except Exception:
                continue
    except Exception:
        pass
    flags = {}
    try:
        flags = getattr(game_state.world, 'global_vars', {}) if hasattr(game_state, 'world') else {}
    except Exception:
        flags = {}

    def any_log(predicate) -> bool:
        try:
            return any(predicate(ev) for ev in log)
        except Exception:
            return False

    for evref in evid:
        if not isinstance(evref, dict):
            continue
        etype = str(evref.get('type', '')).lower()
        # defeated
        if etype == 'defeated':
            rid = evref.get('id')
            if not rid: 
                continue
            found = any_log(lambda ev: ev.get('type') == EV_ENEMY_DEFEATED and (ev.get('entity_id') == rid or ev.get('template_id') == rid))
            if found:
                return True, 'Evidence verified: defeated'
        # item
        elif etype == 'item':
            iid = evref.get('id'); need = int(evref.get('count', 1))
            have = inv_counts.get(iid, 0)
            if iid and have >= need:
                return True, 'Evidence verified: item in inventory'
            # fallback: check logs for positive deltas
            if iid:
                gained = sum(ev.get('delta', 0) for ev in log if ev.get('type') == EV_ITEM_DELTA and ev.get('item_id') == iid and ev.get('delta', 0) > 0)
                if gained >= need:
                    return True, 'Evidence verified: item gained in log'
        # visited
        elif etype == 'visited':
            lid = evref.get('id')
            if not lid:
                continue
            found = any_log(lambda ev: ev.get('type') == EV_LOCATION_VISITED and ev.get('location_id') == lid)
            if found:
                return True, 'Evidence verified: visited'
        # flag
        elif etype == 'flag':
            key = evref.get('key'); val = evref.get('value', True)
            if key is not None and flags.get(key) == val:
                return True, 'Evidence verified: flag'
            # fallback: presence in event log
            found = any_log(lambda ev: ev.get('type') == EV_FLAG_SET and ev.get('key') == key and ev.get('value') == val)
            if found:
                return True, 'Evidence verified: flag set (log)'
        # dialogue
        elif etype == 'dialogue':
            did = evref.get('id')
            found = did and any_log(lambda ev: ev.get('type') == EV_DIALOGUE and ev.get('dialogue_id') == did)
            if found:
                return True, 'Evidence verified: dialogue'
        # interaction
        elif etype == 'interaction':
            iid = evref.get('id')
            found = iid and any_log(lambda ev: ev.get('type') == EV_INTERACTION and ev.get('interaction_id') == iid)
            if found:
                return True, 'Evidence verified: interaction'

    return False, 'No verifying evidence found'

# --- Validation helpers ---

def _allowed_objective_transition(old: str, new: str) -> bool:
    if old in (None, '', 'pending', 'active'):
        return new in ('completed', 'failed')
    # Disallow regressions by default
    return False

# --- Orchestrated messages ---

def _queue_system(engine, text: str):
    try:
        from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
        engine._combat_orchestrator.add_event_to_queue(
            DisplayEvent(
                type=DisplayEventType.SYSTEM_MESSAGE,
                content=text,
                target_display=DisplayTarget.MAIN_GAME_OUTPUT,
                gradual_visual_display=False,
                tts_eligible=False,
            )
        )
    except Exception as e:
        logger.warning(f"Failed to queue system message: {e}")

# --- Apply objective update from LLM ---

def apply_objective_update_from_llm(engine, game_state, payload: Dict[str, Any]) -> Tuple[bool, str]:
    quest_id = payload.get('quest_id')
    objective_id = payload.get('objective_id')
    new_status = payload.get('new_status')
    confidence = float(payload.get('confidence', 0.0))

    if not quest_id or not objective_id or new_status not in ('completed','failed'):
        return False, 'Invalid quest update payload'

    journal = getattr(game_state, 'journal', {})
    quests = journal.get('quests', {}) if isinstance(journal, dict) else {}
    q = quests.get(quest_id)
    if not q:
        return False, f'Unknown quest id: {quest_id}'

    obj = None
    for o in q.get('objectives', []) or []:
        if o.get('id') == objective_id:
            obj = o; break
    if not obj:
        return False, f'Unknown objective id: {objective_id}'

    # Check current status
    old_status = 'completed' if obj.get('completed') else 'failed' if obj.get('failed') else 'pending'
    if not _allowed_objective_transition(old_status, new_status):
        return False, f'Illegal transition from {old_status} to {new_status}'

    # If DSL exists and contradicts proposal, reject
    dsl = obj.get('condition_dsl')
    signals = _build_signals(game_state)
    dsl_eval = _eval_condition_for_quest(dsl, signals, q)
    if new_status == 'completed' and dsl_eval is False:
        return False, 'Contradicts DSL (not satisfied)'

    # Confidence threshold for semantic (when DSL is None)
    if dsl is None:
        if confidence < 0.9:
            return False, 'Confidence too low for semantic objective update'
        ev_ok, ev_msg = _verify_evidence(game_state, payload)
        if not ev_ok:
            return False, f'Evidence check failed: {ev_msg}'

    # Apply update
    if new_status == 'completed':
        obj['completed'] = True; obj['failed'] = False
        _queue_system(engine, f"Objective completed: {obj.get('description','')}" )
    else:
        obj['failed'] = True; obj['completed'] = False
        _queue_system(engine, f"Objective failed: {obj.get('description','')}" )

    # Record event
    try:
        record_objective_status(game_state, quest_id=quest_id, objective_id=objective_id, new_status=new_status)
    except Exception:
        pass

    # Recompute quest status (mandatory logic)
    _recompute_quest_status(engine, q)
    return True, 'Objective update applied'


def _recompute_quest_status(engine, q: Dict[str, Any]) -> None:
    objs = q.get('objectives', []) or []
    mandatory_total = sum(1 for o in objs if o.get('mandatory', True)) or 0
    mandatory_completed = sum(1 for o in objs if o.get('mandatory', True) and o.get('completed', False))
    any_failed = any(o.get('failed', False) for o in objs if o.get('mandatory', True))
    if q.get('abandoned'):
        q['status'] = 'failed'
        return
    if mandatory_total > 0 and mandatory_completed == mandatory_total and not any_failed:
        if q.get('status') != 'completed':
            q['status'] = 'completed'
            _queue_system(engine, f"Quest Completed: {q.get('title','')}" )
    else:
        if q.get('status') == 'completed':
            # Do not regress
            return
        # keep active or failed as is
        if q.get('status') not in ('failed','active'):
            q['status'] = 'active'

# --- Quest-aware DSL evaluation helpers (aliases and resolver) ---

def _quest_alias_candidates(q: Dict[str, Any], domain: str, label: str) -> List[str]:
    """Return candidate canonical IDs for a label using quest-local aliases or global resolver."""
    try:
        if not label:
            return []
        # Quest-local aliases structure suggestion: q['aliases'] = { 'entities': { 'white_wolf': ['wolf_alpha'] }, ...}
        aliases = q.get('aliases', {}) if isinstance(q, dict) else {}
        dom = aliases.get(domain, {}) if isinstance(aliases, dict) else {}
        # Normalize
        if isinstance(dom, dict):
            v = dom.get(label) or dom.get(str(label).lower())
            if isinstance(v, list):
                return [str(x) for x in v]
            if isinstance(v, str):
                return [v]
        # Fall back to global resolver
        try:
            from core.game_flow.reference_resolver import get_reference_resolver
            resolver = get_reference_resolver()
            return resolver.resolve(domain, label)
        except Exception:
            return [label]
    except Exception:
        return [label]


def _label_matches_any(candidates: List[str], haystack: List[str]) -> bool:
    if not candidates or not haystack:
        return False
    hs = set(str(x).lower() for x in haystack)
    for c in candidates:
        if str(c).lower() in hs:
            return True
    return False


def _eval_condition_for_quest(dsl: Any, signals: Dict[str, Any], q: Dict[str, Any]) -> Optional[bool]:
    """Evaluate DSL with quest-aware alias resolution for defeated/visited/inventory_has."""
    try:
        if dsl is None:
            return None
        if isinstance(dsl, bool):
            return dsl
        if isinstance(dsl, dict):
            # Composition
            if 'all' in dsl:
                return all(_eval_condition_for_quest(x, signals, q) is True for x in dsl['all'])
            if 'any' in dsl:
                return any(_eval_condition_for_quest(x, signals, q) is True for x in dsl['any'])
            if 'none' in dsl:
                return all(_eval_condition_for_quest(x, signals, q) is False for x in dsl['none'])
            # Inventory has
            if 'inventory_has' in dsl:
                spec = dsl['inventory_has'] or {}
                item_id = spec.get('item_id')
                count = int(spec.get('count', 1))
                inv = signals.get('inventory', {})
                if item_id:
                    candidates = _quest_alias_candidates(q, 'items', item_id)
                    # sum counts for any candidate
                    have = sum(inv.get(c, 0) for c in candidates)
                    return bool(have >= count)
                return False
            # Defeated
            if 'defeated' in dsl:
                label = dsl['defeated']
                defeated_list = signals.get('defeated', [])
                if label:
                    candidates = _quest_alias_candidates(q, 'entities', label)
                    return _label_matches_any(candidates, defeated_list)
                return False
            # Visited
            if 'visited' in dsl:
                label = dsl['visited']
                visited_list = signals.get('visited', [])
                if label:
                    candidates = _quest_alias_candidates(q, 'locations', label)
                    return _label_matches_any(candidates, visited_list)
                return False
            # Flags and time remain the same
            if 'flag' in dsl:
                key = dsl['flag'].get('key')
                val = dsl['flag'].get('value', True)
                return bool(signals.get('flags', {}).get(key) == val)
            if 'time_before' in dsl:
                t = float(dsl['time_before'])
                return bool(signals.get('time', 0.0) < t)
            if 'time_after' in dsl:
                t = float(dsl['time_after'])
                return bool(signals.get('time', 0.0) > t)
        return None
    except Exception as e:
        logger.warning(f"Quest-aware DSL eval error: {e}")
        return None

# --- Automatic evaluation on events (Phase 1) ---

def _derive_dsl_from_objective(obj: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """Derive a minimal DSL from basic objective fields when none is provided."""
    try:
        otype = (obj.get('type') or '').lower()
        target = obj.get('target_id') or obj.get('target')
        if otype == 'kill' and target:
            return {'defeated': target}
        if otype == 'fetch' and target:
            return {'inventory_has': {'item_id': target, 'count': int(obj.get('count', 1))}}
        if otype in ('explore', 'visit') and target:
            return {'visited': target}
        # Interaction/objectives without clear deterministic signals remain semantic-only
        return None
    except Exception:
        return None


def _evaluate_and_update_all(engine, game_state, objective_type_filter: Optional[List[str]] = None, event: Optional[Dict[str, Any]] = None) -> None:
    """Evaluate all quest objectives using the DSL and update statuses.
    Non-regressive: once completed/failed, we do not regress here.
    """
    journal = getattr(game_state, 'journal', {}) or {}
    quests = journal.get('quests', {}) if isinstance(journal, dict) else {}
    if not isinstance(quests, dict) or not quests:
        return

    signals = _build_signals(game_state)

    # Evaluate each quest/objective
    for qid, q in quests.items():
        try:
            changed = False
            for obj in (q.get('objectives') or []):
                if not isinstance(obj, dict):
                    continue
                # Optional filter by objective type (event-driven bucketing)
                if objective_type_filter:
                    otype = str(obj.get('type', '')).lower()
                    if otype not in [t.lower() for t in objective_type_filter]:
                        continue
                # Skip if already terminal
                if obj.get('completed') or obj.get('failed'):
                    continue
                # If this scan was triggered by an item event, narrow fetch objectives to that item only
                try:
                    if objective_type_filter and any(t.lower() == 'fetch' for t in objective_type_filter):
                        ev_item_id = (event or {}).get('item_id') if isinstance(event, dict) else None
                        if ev_item_id:
                            target_id = str(obj.get('target_id') or '').strip()
                            if target_id and str(ev_item_id).strip().lower() != target_id.strip().lower():
                                # This fetch objective targets a different item; skip on this event tick
                                continue
                except Exception:
                    pass
                # DEV: log objective scan line
                if _dev_quest_verbose():
                    try:
                        _queue_dev(engine, f"Check objective q='{qid}' id='{obj.get('id')}' type='{obj.get('type')}' target='{obj.get('target_id')}'")
                    except Exception:
                        pass
                # Ensure activation_time is set when we first see the objective
                try:
                    if 'activation_time' not in obj or obj.get('activation_time') is None:
                        obj['activation_time'] = getattr(game_state.world, 'game_time', 0.0)
                except Exception:
                    pass
                # Time-based failure via time_limit_s
                try:
                    time_limit = obj.get('time_limit_s')
                    if time_limit is not None:
                        activation = float(obj.get('activation_time', getattr(game_state.world, 'game_time', 0.0)))
                        now = getattr(game_state.world, 'game_time', 0.0)
                        if now >= activation + float(time_limit):
                            obj['failed'] = True
                            obj['completed'] = False
                            try:
                                record_objective_status(game_state, quest_id=qid, objective_id=str(obj.get('id')), new_status='failed')
                            except Exception:
                                pass
                            changed = True
                            # No further evaluation if failed by time
                            continue
                except Exception:
                    pass
                # Completion DSL
                dsl = obj.get('condition_dsl')
                # Derive a minimal DSL when not provided for basic objective types
                if dsl is None:
                    dsl = _derive_dsl_from_objective(obj)
                    if _dev_quest_verbose() and dsl is not None:
                        try:
                            _queue_dev(engine, f"Derived DSL for objective '{obj.get('id')}' -> {dsl}")
                        except Exception:
                            pass
                    if dsl is None:
                        continue  # semantic-only; skip auto when still None
                ev = _eval_condition_dsl(dsl, signals)
                # Dev-verbose: log evaluation result per objective and a small defeated snapshot
                if _dev_quest_verbose():
                    try:
                        defeated_snapshot = signals.get('defeated', [])[:6]
                        _queue_dev(engine, f"Objective eval: id='{obj.get('id')}', desc='{obj.get('description','')}', result={ev}, defeated~={defeated_snapshot}")
                    except Exception:
                        pass
                if ev is True:
                    obj['completed'] = True; obj['failed'] = False
                    try:
                        record_objective_status(game_state, quest_id=qid, objective_id=str(obj.get('id')), new_status='completed')
                    except Exception:
                        pass
                    changed = True
            if changed:
                _recompute_quest_status(engine, q)
                if _dev_quest_verbose():
                    try:
                        _queue_dev(engine, f"Quest '{q.get('title','')}' status recomputed: {q.get('status')}")
                    except Exception:
                        pass
        except Exception as e:
            logger.warning(f"Quest evaluation error for {qid}: {e}")


def process_event_for_quests(engine, game_state, event: Dict[str, Any]) -> None:
    """Phase 1 hook: after an event is logged, re-evaluate quest objectives.
    For now, re-evaluate all quests for simplicity. Later, index by event type.
    """
    try:
        et = event.get('type')
        # Suppress noisy dev logs during startup before quests are activated
        try:
            journal = getattr(game_state, 'journal', {}) or {}
            quests = journal.get('quests', {}) if isinstance(journal, dict) else {}
            quests_empty = not bool(quests)
        except Exception:
            quests_empty = True
        if quests_empty:
            # No quests to evaluate yet; skip dev logs and evaluation safely
            return
        if _dev_quest_verbose():
            try:
                _queue_dev(engine, f"Quest evaluation triggered by event: {et}")
            except Exception:
                pass
        # Map events to objective type filters (bucketing)
        type_map = {
            EV_ENEMY_DEFEATED: ["kill"],
            EV_ITEM_DELTA: ["fetch"],
            EV_LOCATION_VISITED: ["explore", "visit"],
            EV_DIALOGUE: ["interact"],
            EV_INTERACTION: ["interact"],
            EV_FLAG_SET: ["flag"],
        }
        filt = type_map.get(et)
        if et in (EV_ENEMY_DEFEATED, EV_ITEM_DELTA, EV_LOCATION_VISITED, EV_DIALOGUE, EV_INTERACTION, EV_FLAG_SET,):
            # DEV: show event normalization snapshot for EnemyDefeated
            if _dev_quest_verbose() and et == EV_ENEMY_DEFEATED:
                try:
                    tid = (event.get('template_id') or '')
                    tags = event.get('tags', {}) or {}
                    cname = str(tags.get('combat_name', '') or '')
                    tid_l = tid.lower() if tid else ''
                    cname_l = cname.lower() if cname else ''
                    base = re.sub(r'_[0-9]+$', '', cname_l) if cname_l else ''
                    _queue_dev(engine, f"EnemyDefeated norm: template_id='{tid_l}', combat_name='{cname_l}', base='{base}'")
                except Exception:
                    pass
            # Evaluate only relevant objectives
            if _dev_quest_verbose():
                try:
                    filt_str = ",".join(filt) if filt else "all"
                    from collections import Counter
                    journal = getattr(game_state, 'journal', {}) or {}
                    quests = journal.get('quests', {}) if isinstance(journal, dict) else {}
                    total = 0
                    types = []
                    for _, q in quests.items():
                        for obj in (q.get('objectives') or []):
                            if isinstance(obj, dict):
                                types.append(str(obj.get('type','')).lower())
                                total += 1
                    counts = dict(Counter(types))
                    _queue_dev(engine, f"Objective scan: total={total}, types={counts}, filter={filt_str}")
                except Exception:
                    pass
            _evaluate_and_update_all(engine, game_state, objective_type_filter=filt, event=event)
            # Optional LLM fallback for near-match kill objectives
            try:
                if et == EV_ENEMY_DEFEATED and get_config().get("quests.llm_fallback.enabled", False):
                    _attempt_llm_fallback_for_kill(engine, game_state, event)
            except Exception:
                pass
    except Exception as e:
        logger.warning(f"process_event_for_quests failed: {e}")


# --- LLM Fallback (Last Resort) ---

def _attempt_llm_fallback_for_kill(engine, game_state, event: Dict[str, Any]) -> None:
    """As a last resort, ask the LLM to confirm if a 'kill' objective is satisfied given a near match.
    Debounced implicitly by only running once per EnemyDefeated event.
    """
    try:
        # Extract normalized labels from event
        tid = (event.get('template_id') or '')
        tags = event.get('tags', {}) or {}
        cname = str(tags.get('combat_name', '') or '')
        tid_l = tid.lower() if tid else ''
        cname_l = cname.lower() if cname else ''
        base = re.sub(r'_[0-9]+$', '', cname_l) if cname_l else ''
        if not (tid_l or base or cname_l):
            return
        # Iterate active quests and kill objectives that are not completed/failed
        journal = getattr(game_state, 'journal', {}) or {}
        quests = journal.get('quests', {}) if isinstance(journal, dict) else {}
        for qid, q in quests.items():
            for obj in (q.get('objectives') or []):
                if not isinstance(obj, dict):
                    continue
                if obj.get('completed') or obj.get('failed'):
                    continue
                if str(obj.get('type','')).lower() != 'kill':
                    continue
                label = str(obj.get('target_id') or '').lower()
                if not label:
                    continue
                # Near match heuristic
                if label in (tid_l, base, cname_l):
                    # Ask LLM once for confirmation
                    try:
                        from core.game_flow.interaction_core import process_with_llm
                        prompt = (
                            "You are verifying a quest objective.\n"
                            f"Objective: defeat '{label}'.\n"
                            f"Recent event: enemy defeated with template_id='{tid_l}', combat_name='{cname_l}'.\n"
                            "Question: Has the objective been satisfied?\n"
                            "Reply with exactly one word: YES or NO."
                        )
                        result = process_with_llm(game_state, prompt)
                        if getattr(result, 'is_success', False) and isinstance(result.message, str):
                            ans = result.message.strip().lower()
                            if ans.startswith('yes'):
                                obj['completed'] = True; obj['failed'] = False
                                try:
                                    record_objective_status(game_state, quest_id=qid, objective_id=str(obj.get('id')), new_status='completed')
                                except Exception:
                                    pass
                                _recompute_quest_status(engine, q)
                                if _dev_quest_verbose():
                                    _queue_dev(engine, f"LLM fallback confirmed completion for kill objective '{obj.get('id')}'.")
                    except Exception as e:
                        logger.warning(f"LLM fallback error: {e}")
    except Exception as e:
        logger.warning(f"fallback_for_kill failed: {e}")

# --- Apply quest status from LLM ---

def apply_quest_status_from_llm(engine, game_state, payload: Dict[str, Any]) -> Tuple[bool, str]:
    quest_id = payload.get('quest_id')
    new_status = payload.get('new_status')
    confidence = float(payload.get('confidence', 0.0))

    if not quest_id or new_status not in ('active','completed','failed','abandoned'):
        return False, 'Invalid quest status payload'

    journal = getattr(game_state, 'journal', {})
    quests = journal.get('quests', {}) if isinstance(journal, dict) else {}
    q = quests.get(quest_id)
    if not q:
        return False, f'Unknown quest id: {quest_id}'

    # Enforce policy: completed derived from mandatory objectives; abandoned/failed allowed with high confidence
    if new_status == 'completed':
        # Derive rather than accept
        _recompute_quest_status(engine, q)
        try:
            record_quest_status(game_state, quest_id=quest_id, new_status=q.get('status','active'))
        except Exception:
            pass
        return True, 'Quest status derived from objectives'

    if new_status in ('failed','abandoned'):
        if confidence < 0.95:
            return False, 'Confidence too low for failing/abandoning quest'
        # Require at least one piece of evidence
        ev_ok, ev_msg = _verify_evidence(game_state, payload)
        if not ev_ok:
            return False, f'Evidence check failed: {ev_msg}'
        q['status'] = 'failed'
        if new_status == 'abandoned':
            q['abandoned'] = True
            _queue_system(engine, f"Quest Abandoned: {q.get('title','')}" )
        else:
            _queue_system(engine, f"Quest Failed: {q.get('title','')}" )
        try:
            record_quest_status(game_state, quest_id=quest_id, new_status=q['status'])
        except Exception:
            pass
        return True, 'Quest status update applied'

    if new_status == 'active':
        # Disallow reopen by default
        return False, 'Reopening quests not allowed by default'

    return False, 'Unhandled quest status'

# --- Time-based processing on tick ---

def process_time_for_quests(engine, game_state) -> None:
    """Checks time-based failure conditions (deadlines) on tick.
    Lightweight scan of active objectives that have time_limit_s.
    """
    try:
        journal = getattr(game_state, 'journal', {}) or {}
        quests = journal.get('quests', {}) if isinstance(journal, dict) else {}
        now = getattr(game_state.world, 'game_time', 0.0)
        any_changed = False
        for qid, q in quests.items():
            changed_q = False
            for obj in (q.get('objectives') or []):
                if not isinstance(obj, dict):
                    continue
                if obj.get('completed') or obj.get('failed'):
                    continue
                time_limit = obj.get('time_limit_s')
                if time_limit is None:
                    continue
                activation = float(obj.get('activation_time', now))
                if now >= activation + float(time_limit):
                    obj['failed'] = True
                    obj['completed'] = False
                    try:
                        record_objective_status(game_state, quest_id=qid, objective_id=str(obj.get('id')), new_status='failed')
                    except Exception:
                        pass
                    changed_q = True
                    any_changed = True
            if changed_q:
                _recompute_quest_status(engine, q)
        if any_changed and _dev_quest_verbose():
            _queue_dev(engine, "Processed time-based objective failures on tick.")
    except Exception as e:
        logger.warning(f"process_time_for_quests error: {e}")


```

### File: core\game_flow\reference_resolver.py

```python
#!/usr/bin/env python3
"""
ReferenceResolver: resolves narrative labels to canonical references (template_id, ids) using
config-defined aliases. This is a lightweight Phase 1 resolver; LLM-assisted mapping can be
added later behind this interface.
"""
from __future__ import annotations
from typing import Dict, List, Optional

from core.base.config import GameConfig
from core.utils.logging_config import get_logger

logger = get_logger("REF_RESOLVER")

class ReferenceResolver:
    """Resolves labels to canonical IDs based on config aliases.

    Aliases config shape suggestion (config/world/aliases.json):
    {
      "entities": { "white_wolf": ["wolf_alpha", "test_wolf_alpha"] },
      "items": { "healing_herb": ["herb_healing"] },
      "locations": { "ruins": ["ancient_ruins"] },
      "dialogues": { },
      "interactions": { }
    }
    Values can be a string or list of strings (candidate canonical IDs).
    """

    def __init__(self) -> None:
        self._config = GameConfig()

    def _get_domain_aliases(self, domain: str) -> Dict[str, List[str]]:
        try:
            # Primary global aliases
            data = self._config.get("aliases", {})
            dom = data.get(domain, {}) if isinstance(data, dict) else {}
            # Optional NPC entity-specific aliases (config/aliases/entities.json)
            if domain == "entities":
                npc_aliases = self._config.get("npc_entity_aliases.entities", {}) or {}
                # Merge npc_entity_aliases into dom (prefer explicitly provided lists)
                if isinstance(npc_aliases, dict):
                    for k, v in npc_aliases.items():
                        key = str(k).lower()
                        if key not in dom:
                            dom[key] = v
                        else:
                            # Merge lists if both exist
                            try:
                                existing = dom.get(key, [])
                                if isinstance(existing, list) and isinstance(v, list):
                                    dom[key] = list({*map(str, existing), *map(str, v)})
                            except Exception:
                                pass
            # Normalize to list[str]
            out: Dict[str, List[str]] = {}
            for k, v in (dom or {}).items():
                if isinstance(v, list):
                    out[str(k).lower()] = [str(x) for x in v]
                elif isinstance(v, str):
                    out[str(k).lower()] = [v]
            return out
        except Exception:
            return {}

    def resolve(self, domain: str, label: str) -> List[str]:
        """Return candidate canonical IDs for label within domain.
        If no mapping found, return [label] as identity fallback.
        """
        if not label:
            return []
        key = str(label).lower()
        dom_aliases = self._get_domain_aliases(domain)
        mapped = dom_aliases.get(key)
        if mapped:
            return mapped
        return [label]


_resolver_instance: Optional[ReferenceResolver] = None

def get_reference_resolver() -> ReferenceResolver:
    global _resolver_instance
    if _resolver_instance is None:
        _resolver_instance = ReferenceResolver()
    return _resolver_instance

```

### File: core\game_flow\request_handlers.py

```python
#!/usr/bin/env python3
"""
Handles execution of validated structured requests (skill checks, state changes).
"""

import logging
from typing import Dict, List, Optional, Any, TYPE_CHECKING

# --- Core Imports ---
from core.stats.combat_effects import StatusEffect, StatusEffectType
from core.stats.enums import Skill
from core.stats.stats_base import StatType, DerivedStatType
from core.stats.stats_manager import get_stats_manager
from core.interaction.enums import InteractionMode
from core.interaction.social_effects import SocialStatusEffect
from core.combat.combat_entity import CombatEntity, EntityType
from core.combat.combat_manager import CombatManager
from core.combat.enums import CombatState
from core.combat.combat_action import CombatAction, ActionType, AttackAction # Import relevant actions

# --- Utils ---
from core.game_flow.game_flow_utils import get_participant_by_id

if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.base.state import GameState

# --- Logger ---
logger = logging.getLogger("INTERACTION_PROC") # Keep original logger name


def _process_skill_check_request(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """
    Processes a skill check request by constructing and performing the corresponding
    CombatAction via the CombatManager. Uses combat_name for lookups.
    """
    skill_name_str = request.get("skill_name")
    # --- MODIFICATION: Get names instead of IDs ---
    actor_combat_name = request.get("actor_id") # This field now holds the combat_name
    target_combat_name = request.get("target_actor_id")
    # --- END MODIFICATION ---
    context_msg = request.get("context", f"Attempting {skill_name_str or 'skill check'}")

    logger.debug(f"Processing SkillCheckRequest for actor '{actor_combat_name}': {request}")

    try:
        if not skill_name_str: raise ValueError("Missing 'skill_name'")
        if not game_state.combat_manager: raise ValueError("CombatManager not found in GameState.")
        if not actor_combat_name: raise ValueError("Missing 'actor_id' (combat_name) in request")

        # --- MODIFICATION: Find entities by combat_name ---
        actor = game_state.combat_manager._find_entity_by_combat_name(actor_combat_name)
        if not actor: raise ValueError(f"Actor '{actor_combat_name}' not found in combat.")
        actor_internal_id = actor.id # Get the actual UUID

        target = None
        target_internal_id = None
        is_attack_skill = skill_name_str.upper() in ["MELEE_ATTACK", "RANGED_ATTACK", "UNARMED_ATTACK", "SPELL_ATTACK"]
        if is_attack_skill:
            if not target_combat_name:
                raise ValueError(f"Attack skill '{skill_name_str}' requires a target_actor_id (combat_name).")
            target = game_state.combat_manager._find_entity_by_combat_name(target_combat_name)
            if not target:
                 # Allow action to proceed but log error and potentially return specific message
                 logger.error(f"Target '{target_combat_name}' not found for skill check {skill_name_str}.")
                 # Return error message immediately, prevents further processing with invalid target
                 return f"Action failed: Target '{target_combat_name}' not found."
            target_internal_id = target.id # Get the actual UUID
        # --- END MODIFICATION ---

        action_to_perform: Optional[CombatAction] = None
        skill_upper = skill_name_str.upper()

        if is_attack_skill:
            # Use internal UUIDs for the action
            action_to_perform = AttackAction(
                performer_id=actor_internal_id,
                target_id=target_internal_id,
                weapon_name=request.get("weapon_name", skill_name_str),
                dice_notation=request.get("dice_notation", "1d6"),
            )
            action_to_perform.action_type = ActionType.ATTACK
        elif skill_upper == "DEFENSE":
             logger.warning("DEFENSE skill check request currently not linked to a CombatAction.")
             return f"{actor.combat_name} attempts to defend (DEFENSE check not fully implemented)."
        elif skill_upper == "DODGE":
             logger.warning("DODGE skill check request currently not linked to a CombatAction.")
             return f"{actor.combat_name} attempts to dodge (DODGE check not fully implemented)."
        else:
             logger.warning(f"Unhandled skill check request type for direct action: {skill_name_str}. Processing as generic check.")
             return f"System Error: Skill check '{skill_name_str}' cannot be directly performed as a combat action in this context."

        if action_to_perform:
            logger.info(f"Attempting to perform action via CombatManager: {action_to_perform.name} by {actor.combat_name} ({actor_internal_id})")
            action_result = game_state.combat_manager.perform_action(action_to_perform)

            # --- Format Narrative from Action Result (Uses combat_names) ---
            performer_name_display = action_result.get("performer", actor.combat_name)
            target_name_display = action_result.get("target", target.combat_name if target else "target")

            if action_result.get("success"):
                damage = action_result.get("damage", 0)
                hp_remaining_val = action_result.get("target_hp_remaining", '?')
                hp_remaining = f"{hp_remaining_val:.0f}" if isinstance(hp_remaining_val, (int, float)) else '?'
                max_hp_val = action_result.get("target_max_hp", '?') # Assuming result might include max hp
                max_hp = f"{max_hp_val:.0f}" if isinstance(max_hp_val, (int, float)) else '?'
                target_defeated = action_result.get("target_defeated", False)
                crit_str = " Critically!" if action_result.get("is_critical") else ""

                if damage > 0:
                    narrative = f"{performer_name_display} hits {target_name_display}{crit_str} for {damage} damage."
                    if target_defeated: narrative += f" {target_name_display} is defeated!"
                    else: narrative += f" (HP: {hp_remaining}/{max_hp})"
                else:
                    narrative = f"{performer_name_display}'s attack hits {target_name_display} but deals no damage."

                stamina_cost_val = action_result.get('stamina_cost')
                stamina_rem_val = action_result.get('stamina_remaining')
                stamina_cost_str = f"{stamina_cost_val:.1f}" if isinstance(stamina_cost_val, (int, float)) else '?'
                stamina_rem_str = f"{stamina_rem_val:.1f}" if isinstance(stamina_rem_val, (int, float)) else '?'
                narrative += f" (Stamina Cost: {stamina_cost_str}, Remaining: {stamina_rem_str})"

            else: # Action failed
                narrative = action_result.get("message", f"{performer_name_display}'s action failed.")
                stamina_cost_val = action_result.get('stamina_cost')
                stamina_rem_val = action_result.get('stamina_remaining')
                if stamina_cost_val is not None and stamina_rem_val is not None:
                    stamina_cost_str = f"{stamina_cost_val:.1f}" if isinstance(stamina_cost_val, (int, float)) else '?'
                    stamina_rem_str = f"{stamina_rem_val:.1f}" if isinstance(stamina_rem_val, (int, float)) else '?'
                    narrative += f" (Stamina Cost: {stamina_cost_str}, Remaining: {stamina_rem_str})"

            logger.info(f"Skill Check Action Result Narrative: {narrative}")
            return narrative
        else:
            logger.error(f"No CombatAction constructed for skill check request: {request}")
            return f"System Error: Could not determine action for skill '{skill_name_str}'."

    except ValueError as e:
        logger.error(f"Validation error processing SkillCheckRequest {request}: {e}")
        return f"System Error: Invalid skill check request ({e})."
    except AttributeError as e:
         logger.error(f"Missing attribute processing SkillCheckRequest {request}: {e}", exc_info=True)
         return f"System Error: Missing data for skill check ({e})."
    except Exception as e:
        logger.error(f"Unexpected error performing skill check {request}: {e}", exc_info=True)
        return f"System Error: Unexpected error during {skill_name_str or 'skill'} check."

def _process_state_change_request(engine: 'GameEngine', game_state: 'GameState', request: Dict[str, Any], effective_actor_id: str) -> str:
    """Processes a single state change request and returns the narrative result. Uses combat_name."""
    # --- MODIFICATION: Get combat_name instead of ID ---
    target_combat_name = request.get("target_entity")
    # --- END MODIFICATION ---
    attribute = request.get("attribute")
    value = request.get("value")
    duration_str = request.get("duration")

    duration_int: Optional[int] = None
    if duration_str is not None:
        try:
            duration_int = int(duration_str)
        except (ValueError, TypeError):
            logger.warning(f"Invalid duration format '{duration_str}' in state change request. Ignoring duration.")

    logger.debug(f"Processing StateChangeRequest: {request}")
    if not target_combat_name or not attribute: # Check name
        logger.error(f"StateChangeRequest missing target_entity (combat_name) or attribute: {request}")
        return "System Error: State change request is incomplete."

    # Handle inventory before any combat-specific lookups (no CombatManager required)
    if attribute == "inventory":
        try:
            from core.inventory import get_inventory_manager, get_item_factory
            inv = get_inventory_manager()
            item_factory = get_item_factory()

            change_type_raw = (request.get("change_type") or request.get("change") or "add").lower()
            qty_raw = request.get("quantity", request.get("count", 1))
            try:
                quantity = int(qty_raw)
            except Exception:
                quantity = 1
            if quantity <= 0:
                quantity = 1

            if change_type_raw in ("add", "give", "pickup", "obtain", "create"):
                item_obj = None
                item_spec = request.get("item_spec") or request.get("item_data")
                if isinstance(item_spec, dict):
                    try:
                        item_obj = item_factory.create_item_from_spec(item_spec)
                    except Exception:
                        item_obj = None
                if item_obj is None:
                    template_id = request.get("template_id") or request.get("item_template")
                    ref_item_id = request.get("item_id")
                    if ref_item_id:
                        existing = inv.get_item(ref_item_id)
                        if existing:
                            item_obj = existing
                        elif not template_id:
                            template_id = ref_item_id
                    if item_obj is None and template_id:
                        item_obj = item_factory.create_item_from_template(template_id, variation=False)
                if item_obj is None:
                    item_name = request.get("item_name") or request.get("name")
                    if item_name:
                        found = inv.find_items(name=item_name)
                        if found:
                            item_obj = found[0]
                if item_obj is not None:
                    inv.add_item(item_obj, quantity=quantity)
                return ""  # silent
            elif change_type_raw in ("remove", "drop", "discard", "consume", "delete"):
                target_item = None
                ref_item_id = request.get("item_id")
                if ref_item_id:
                    target_item = inv.get_item(ref_item_id)
                if not target_item:
                    template_id = request.get("template_id") or request.get("item_template")
                    if template_id:
                        for it in getattr(inv, "_items", {}).values():
                            if getattr(it, "template_id", None) == template_id:
                                target_item = it
                                break
                if not target_item:
                    item_name = request.get("item_name") or request.get("name")
                    if item_name:
                        found = inv.find_items(name=item_name)
                        if found:
                            target_item = found[0]
                if target_item is not None:
                    inv.remove_item(target_item.id, quantity=quantity)
                return ""  # silent regardless
            else:
                return ""
        except Exception:
            return ""

    try:
        # --- MODIFICATION: Find participant by combat_name ---
        if not game_state.combat_manager: raise ValueError("CombatManager not found.")
        participant = game_state.combat_manager._find_entity_by_combat_name(target_combat_name)
        if not participant:
            # Check if the target is the effective actor (e.g., applying buff to self)
            effective_actor = game_state.combat_manager._find_entity_by_combat_name(effective_actor_id) # Find actor by name
            if effective_actor and effective_actor.combat_name == target_combat_name:
                 participant = effective_actor
                 logger.debug(f"State change target is the actor themselves: {target_combat_name}")
            else:
                 raise ValueError(f"Target entity '{target_combat_name}' not found.")
        # --- END MODIFICATION ---

        target_internal_id = participant.id # Get the actual internal ID
        change_applied = False
        change_narrative = ""
        participant_name_display = participant.combat_name # Use combat name for display

        # Get the StatsManager for the target participant
        stats_manager = engine._get_entity_stats_manager(target_internal_id) # Use internal ID
        if not stats_manager:
            raise ValueError(f"Could not get StatsManager for target '{participant_name_display}' ({target_internal_id}).")

        # --- Apply State Change (using StatsManager) ---
        if attribute == "hp":
            try:
                delta = float(value)
                current_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                new_hp = current_hp + delta
                set_ok = stats_manager.set_current_stat(DerivedStatType.HEALTH, new_hp)

                if set_ok:
                    final_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                    max_hp = stats_manager.get_stat_value(DerivedStatType.MAX_HEALTH)
                    if delta < 0:
                         change_narrative = f"{participant_name_display} takes {abs(delta):.0f} damage. Current HP: {final_hp:.0f}/{max_hp:.0f}."
                    else:
                         change_narrative = f"{participant_name_display} heals {delta:.0f} HP. Current HP: {final_hp:.0f}/{max_hp:.0f}."
                    change_applied = True
                    if final_hp <= 0 and game_state.combat_manager:
                         # Ensure combat entity HP also reflects 0
                         combat_entity = game_state.combat_manager.get_entity_by_id(target_internal_id)
                         if combat_entity: combat_entity.current_hp = 0
                         change_narrative += f" {participant_name_display} is defeated!"
                         if hasattr(game_state.combat_manager, '_check_combat_state'):
                              game_state.combat_manager._check_combat_state()
                else:
                    change_narrative = f"System Error: Failed to apply HP change to {participant_name_display}."
            except (ValueError, TypeError):
                 change_narrative = f"System Error: Invalid HP change value '{value}'."

        elif attribute == "stamina":
            try:
                delta = float(value)
                current_stamina = stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                new_stamina = current_stamina + delta
                set_ok = stats_manager.set_current_stat(DerivedStatType.STAMINA, new_stamina)

                if set_ok:
                    final_stamina = stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                    max_stamina = stats_manager.get_stat_value(DerivedStatType.MAX_STAMINA)
                    if delta < 0:
                        change_narrative = f"{participant_name_display} spends {abs(delta):.1f} stamina. Remaining: {final_stamina:.1f}/{max_stamina:.1f}."
                    else:
                        change_narrative = f"{participant_name_display} recovers {delta:.1f} stamina. Current: {final_stamina:.1f}/{max_stamina:.1f}."
                    change_applied = True
                else:
                    if delta < 0 and current_stamina < abs(delta):
                         change_narrative = f"{participant_name_display} does not have enough stamina (Needs {abs(delta):.1f}, Has {current_stamina:.1f})."
                    else:
                         change_narrative = f"System Error: Failed to apply Stamina change to {participant_name_display}."
            except (ValueError, TypeError):
                 change_narrative = f"System Error: Invalid Stamina change value '{value}'."

        elif attribute == "add_status_effect":
            if isinstance(value, str):
                effect_name = value
                # Pass converted integer duration
                stats_manager.add_status_effect(StatusEffect(name=effect_name, description=f"Applied {effect_name}", effect_type=StatusEffectType.SPECIAL, duration=duration_int if duration_int is not None else -1))
                # Also update the CombatEntity's local status_effects dict
                participant.add_status_effect(effect_name, duration=duration_int)
                duration_str_narrative = f" for {duration_int} turns" if duration_int is not None else ""
                change_narrative = f"{participant_name_display} is now afflicted with {effect_name}{duration_str_narrative}."
                change_applied = True
            else:
                change_narrative = f"System Error: Invalid status effect name '{value}'."

        elif attribute == "remove_status_effect":
            if isinstance(value, str):
                effect_name = value
                removed_count = stats_manager.status_effect_manager.remove_effects_by_name(effect_name)
                # Also remove from CombatEntity's local status_effects dict
                participant.remove_status_effect(effect_name)
                if removed_count > 0:
                     change_narrative = f"{participant_name_display} is no longer affected by {effect_name}."
                     change_applied = True
                else:
                     change_narrative = f"{participant_name_display} was not affected by {effect_name}."
            else:
                change_narrative = f"System Error: Invalid status effect name '{value}'."


        elif attribute == "location":
            # Developer-only direct location change to support testing visit/explore objectives.
            try:
                # Check Developer Mode via QSettings (GUI)
                from PySide6.QtCore import QSettings
                q = QSettings("RPGGame", "Settings")
                dev_enabled = bool(q.value("dev/enabled", False, type=bool) or q.value("dev/quest_verbose", False, type=bool))
            except Exception:
                dev_enabled = False

            location_id = str(value) if value is not None else ""

            if not dev_enabled:
                # Attempt to get an explanation from the RuleChecker; if none, fall back to a simple message.
                explanation = None
                try:
                    if hasattr(engine, '_rule_checker') and engine._rule_checker is not None:
                        from core.agents.base_agent import AgentContext
                        from core.interaction.context_builder import ContextBuilder
                        from core.interaction.enums import InteractionMode
                        context_dict = ContextBuilder().build_context(game_state, InteractionMode.NARRATIVE, actor_id=effective_actor_id)
                        validation_input = f"STATE_CHANGE location -> {location_id} (request denied in normal play)"
                        agent_ctx = AgentContext(
                            game_state=context_dict,
                            player_state=context_dict.get('player', {}),
                            world_state={
                                'location': context_dict.get('location'),
                                'time_of_day': context_dict.get('time_of_day'),
                                'environment': context_dict.get('environment')
                            },
                            player_input=validation_input,
                            conversation_history=game_state.conversation_history if hasattr(game_state, 'conversation_history') else [],
                            relevant_memories=[],
                            additional_context=context_dict
                        )
                        is_valid, reason = engine._rule_checker.validate_action(agent_ctx)
                        if not is_valid and reason:
                            explanation = reason
                except Exception:
                    pass
                if not explanation:
                    explanation = "developer-only teleportation is disabled in normal play"
                return f"This action is not permitted - {explanation}."

            # Developer mode enabled: apply direct location change and record visit event.
            try:
                game_state.player.current_location = location_id
                if hasattr(game_state, 'world'):
                    game_state.world.current_location = location_id
                try:
                    from core.game_flow.event_log import record_location_visited
                    record_location_visited(game_state, location_id=location_id)
                except Exception:
                    pass
                change_applied = True
                change_narrative = f"Location set to {location_id} (dev)."
            except Exception as e:
                change_narrative = f"System Error: Failed to change location to '{location_id}' ({e})."

        # Add Social Effect / Remove Social Effect (These might need specific logic if not handled by StatsManager)
        # elif attribute == "add_social_effect":
        #      # TODO: Implement social effect handling, potentially on NPC state or a dedicated system
        #      change_narrative = f"Applying social effect '{value}' to {participant_name} (Not fully implemented)."
        #      logger.warning(f"Social effect application for '{value}' on {target_entity_id} not fully implemented.")

        # elif attribute == "remove_social_effect":
        #      # TODO: Implement social effect removal
        #      change_narrative = f"Removing social effect '{value}' from {participant_name} (Not fully implemented)."
        #      logger.warning(f"Social effect removal for '{value}' on {target_entity_id} not fully implemented.")

        # else:
        #     # Fallback for unhandled attributes
        #     logger.warning(f"Unhandled StateChangeRequest attribute: {attribute} for target {participant_name}")
        #     change_narrative = f"State change requested for {target_entity_id}.{attribute} (Unhandled)."

        # Output the narrative result of the state change
        if change_narrative:
            engine._output("system", change_narrative)
        return ""

    except ValueError as e:
         logger.error(f"Invalid value or target in StateChangeRequest: {request} ({e})")
         return f"System Error: Invalid state change request ({e})."
    except AttributeError as e:
        logger.error(f"Missing attribute processing StateChangeRequest {request}: {e}", exc_info=True)
        return f"System Error: Cannot modify {attribute} for {target_combat_name} ({e})."
    except Exception as e:
        logger.error(f"Error applying state change {request}: {e}", exc_info=True)
        return f"Error applying state change for {target_combat_name}.{attribute}."
```

### File: world_configurator\models\__init__.py

```python
"""
Models for the World Configurator Tool.
"""

```

### File: world_configurator\models\base_models.py

```python
"""
Base data models for the World Configurator Tool.
"""

from dataclasses import dataclass, field, asdict, fields # Added 'fields' import
from typing import Dict, List, Any, Optional, Union, Literal
import json
import uuid
import logging

logger = logging.getLogger("world_configurator.models")

@dataclass
class BaseModel:
    """Base class for all data models."""

    def to_dict(self) -> Dict[str, Any]:
        """Convert the model to a dictionary."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'BaseModel':
        """Create a model instance from a dictionary."""
        # Basic implementation, might need overrides in subclasses for complex types
        # Filter data to only include fields defined in the dataclass
        known_fields = {f.name for f in fields(cls)} # Use imported 'fields'
        filtered_data = {k: v for k, v in data.items() if k in known_fields}
        try:
            return cls(**filtered_data)
        except TypeError as e:
            logger.error(f"Error creating {cls.__name__} from dict. Data: {filtered_data}, Error: {e}")
            # Attempt to create with minimal required fields if possible, or raise
            # This part depends on how you want to handle partial data.
            # For now, re-raising might be safer.
            raise e

    def to_json(self, indent: int = 2) -> str:
        """Convert the model to a JSON string."""
        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)

    @classmethod
    def from_json(cls, json_str: str) -> 'BaseModel':
        """Create a model instance from a JSON string."""
        data = json.loads(json_str)
        return cls.from_dict(data)

    @staticmethod
    def generate_id() -> str:
        """Generate a unique ID."""
        return str(uuid.uuid4())


@dataclass
class WorldModelState:
    """
    Tracks the state of a model (modified status, etc.)
    """
    modified: bool = False
    path: Optional[str] = None

    def mark_modified(self) -> None:
        """Mark the model as modified."""
        self.modified = True

    def mark_saved(self, path: str) -> None:
        """Mark the model as saved."""
        self.modified = False
        self.path = path

# --- Culture Related ---
@dataclass
class CultureValue:
    """
    Represents a cultural value.
    """
    name: str
    description: str
    importance: int = 5  # 1-10 scale

@dataclass
class Tradition:
    """
    Represents a cultural tradition.
    """
    name: str
    description: str
    occasion: str
    significance: str

@dataclass
class Culture(BaseModel):
    """
    Represents a culture in the game world.
    """
    id: str
    name: str
    description: str
    values: List[CultureValue] = field(default_factory=list)
    traditions: List[Tradition] = field(default_factory=list)
    language_style: str = ""
    naming_conventions: Dict[str, str] = field(default_factory=dict)
    common_traits: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'Culture':
        """Create a new culture with a unique ID."""
        culture_id = cls.generate_id()
        return cls(
            id=culture_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Culture':
        """Create a culture instance from a dictionary."""
        data_copy = data.copy()
        if 'values' in data_copy and isinstance(data_copy['values'], list):
            values = []
            for value_data in data_copy['values']:
                if isinstance(value_data, dict):
                    values.append(CultureValue(**value_data))
                elif isinstance(value_data, CultureValue): # Handle already converted objects
                    values.append(value_data)
            data_copy['values'] = values

        if 'traditions' in data_copy and isinstance(data_copy['traditions'], list):
            traditions = []
            for tradition_data in data_copy['traditions']:
                if isinstance(tradition_data, dict):
                    traditions.append(Tradition(**tradition_data))
                elif isinstance(tradition_data, Tradition): # Handle already converted objects
                    traditions.append(tradition_data)
            data_copy['traditions'] = traditions

        # Use superclass from_dict for basic field assignment after handling nested lists
        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)


# --- Location Related ---
@dataclass
class LocationConnection:
    """
    Represents a connection between locations.
    """
    target: str  # ID of the target location
    description: str
    travel_time: int  # In minutes
    requirements: List[str] = field(default_factory=list)

@dataclass
class LocationFeature:
    """
    Represents a special feature of a location.
    """
    name: str
    description: str
    interaction_type: str = "none"  # none, examine, use, etc.

@dataclass
class Location(BaseModel):
    """
    Represents a location in the game world.
    """
    id: str
    name: str
    description: str
    type: str  # village, city, dungeon, etc.
    region: str = ""
    culture_id: str = ""
    population: int = 0
    culture_mix: Dict[str, float] = field(default_factory=dict)
    features: List[LocationFeature] = field(default_factory=list)
    connections: List[LocationConnection] = field(default_factory=list)
    npcs: List[str] = field(default_factory=list)  # IDs of important NPCs

    @classmethod
    def create_new(cls, name: str, description: str, location_type: str) -> 'Location':
        """Create a new location with a unique ID."""
        location_id = cls.generate_id()
        return cls(
            id=location_id,
            name=name,
            description=description,
            type=location_type
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Location':
        """Create a location instance from a dictionary."""
        data_copy = data.copy()
        if 'features' in data_copy and isinstance(data_copy['features'], list):
            features = []
            for feature_data in data_copy['features']:
                if isinstance(feature_data, dict):
                    features.append(LocationFeature(**feature_data))
                elif isinstance(feature_data, LocationFeature):
                    features.append(feature_data)
            data_copy['features'] = features

        if 'connections' in data_copy and isinstance(data_copy['connections'], list):
            connections = []
            for connection_data in data_copy['connections']:
                if isinstance(connection_data, dict):
                    connections.append(LocationConnection(**connection_data))
                elif isinstance(connection_data, LocationConnection):
                    connections.append(connection_data)
            data_copy['connections'] = connections

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

# --- History Related ---
@dataclass
class HistoricalEvent:
    """
    Represents a significant historical event.
    """
    year: int
    title: str
    description: str
    significance: str = ""
    affected_locations: List[str] = field(default_factory=list)
    affected_cultures: List[str] = field(default_factory=list)

@dataclass
class Era:
    """
    Represents a historical era.
    """
    name: str
    start_year: int
    end_year: int
    description: str
    events: List[HistoricalEvent] = field(default_factory=list)

@dataclass
class WorldHistory(BaseModel):
    """
    Represents the history of the game world.
    """
    name: str
    description: str
    current_year: int
    eras: List[Era] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str, current_year: int) -> 'WorldHistory':
        """Create a new world history."""
        return cls(
            name=name,
            description=description,
            current_year=current_year
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldHistory':
        """Create a world history instance from a dictionary."""
        data_copy = data.copy()
        if 'eras' in data_copy and isinstance(data_copy['eras'], list):
            eras = []
            for era_data in data_copy['eras']:
                if isinstance(era_data, dict):
                    events = []
                    if 'events' in era_data and isinstance(era_data['events'], list):
                        for event_data in era_data['events']:
                            if isinstance(event_data, dict):
                                events.append(HistoricalEvent(**event_data))
                            elif isinstance(event_data, HistoricalEvent):
                                events.append(event_data)
                    era_data['events'] = events # Update the dict before creating Era
                    eras.append(Era(**era_data))
                elif isinstance(era_data, Era):
                    eras.append(era_data)
            data_copy['eras'] = eras

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

# --- Quest Related ---
@dataclass
class QuestObjective:
    """
    Represents an objective in a quest.
    """
    id: str
    description: str
    type: str  # fetch, kill, escort, etc.
    target_id: str = ""
    location_id: str = ""
    completion_criteria: str = ""
    rewards: Dict[str, Any] = field(default_factory=dict)
    mandatory: bool = True

@dataclass
class Quest(BaseModel):
    """
    Represents a quest in the game.
    """
    id: str
    title: str
    description: str
    giver_id: str = ""
    level: int = 1
    objectives: List[QuestObjective] = field(default_factory=list)
    rewards: Dict[str, Any] = field(default_factory=dict)
    prerequisites: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, title: str, description: str) -> 'Quest':
        """Create a new quest with a unique ID."""
        quest_id = cls.generate_id()
        return cls(
            id=quest_id,
            title=title,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Quest':
        """Create a quest instance from a dictionary."""
        data_copy = data.copy()
        if 'objectives' in data_copy and isinstance(data_copy['objectives'], list):
            objectives = []
            for obj_data in data_copy['objectives']:
                if isinstance(obj_data, dict):
                    if 'id' not in obj_data: obj_data['id'] = cls.generate_id() # Ensure ID
                    if 'mandatory' not in obj_data:
                        obj_data['mandatory'] = True
                    objectives.append(QuestObjective(**obj_data))
                elif isinstance(obj_data, QuestObjective):
                    if not hasattr(obj_data, 'mandatory'):
                        try:
                            setattr(obj_data, 'mandatory', True)
                        except Exception:
                            pass
                    objectives.append(obj_data)
            data_copy['objectives'] = objectives

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

# --- Rules Related ---
@dataclass
class FundamentalRule:
    """
    Represents a fundamental rule of the game world.
    """
    name: str
    description: str
    category: str  # magic, physics, society, etc.
    effects: List[str] = field(default_factory=list)

@dataclass
class WorldRules(BaseModel):
    """
    Represents the fundamental rules of the game world.
    """
    name: str
    description: str
    rules: List[FundamentalRule] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'WorldRules':
        """Create a new world rules definition."""
        return cls(
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldRules':
        """Create a WorldRules instance from a dictionary."""
        data_copy = data.copy()
        if 'rules' in data_copy and isinstance(data_copy['rules'], list):
            rules = []
            for rule_data in data_copy['rules']:
                if isinstance(rule_data, dict):
                    rules.append(FundamentalRule(**rule_data))
                elif isinstance(rule_data, FundamentalRule):
                    rules.append(rule_data)
            data_copy['rules'] = rules

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)


# --- Magic System Related ---
@dataclass
class SpellEffect:
    """
    Represents a single effect of a spell.
    """
    target_type: Literal["caster", "target"] = "target"
    effect_type: Literal["damage", "healing", "stat_modification", "status_effect"] = "damage"
    value: float = 0.0
    stat_affected: str = ""
    status_effect: str = ""
    duration: int = 0
    dice_notation: str = ""
    description: str = ""

@dataclass
class Spell(BaseModel):
    """
    Represents a spell in the magic system.
    """
    id: str
    name: str
    description: str
    mana_cost: int = 0
    casting_time: str = "1 action"
    range: str = "10m"
    target: str = "single"
    effects: List[SpellEffect] = field(default_factory=list)
    level: int = 1
    components: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'Spell':
        """Create a new spell with a unique ID."""
        spell_id = cls.generate_id()
        return cls(
            id=spell_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Spell':
        """Create a spell instance from a dictionary."""
        data_copy = data.copy()
        if 'effects' in data_copy and isinstance(data_copy['effects'], list):
            effects = []
            for effect_data in data_copy['effects']:
                if isinstance(effect_data, dict):
                    effects.append(SpellEffect(**effect_data))
                elif isinstance(effect_data, SpellEffect):
                    effects.append(effect_data)
            data_copy['effects'] = effects

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

@dataclass
class RacialAffinity:
    """
    Represents a race's affinity to a magical system.
    """
    affinity_level: str = "Medium"
    learning_difficulty: str = "Moderate"
    natural_talent: bool = False
    bonus_effects: Optional[str] = None

@dataclass
class ClassAffinity:
    """
    Represents a class's affinity to a magical system.
    """
    affinity_level: str = "Medium"
    learning_difficulty: str = "Moderate"
    required_stats: Dict[str, int] = field(default_factory=dict)

@dataclass
class MagicalSystem(BaseModel):
    """
    Represents a magical system in the game world.
    """
    id: str
    name: str
    description: str
    origin: str = ""
    limitations: str = ""
    practitioners: str = ""
    cultural_significance: str = ""
    racial_affinities: Dict[str, RacialAffinity] = field(default_factory=dict)
    class_affinities: Dict[str, ClassAffinity] = field(default_factory=dict)
    spells: Dict[str, Spell] = field(default_factory=dict)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'MagicalSystem':
        """Create a new magical system with a unique ID."""
        system_id = cls.generate_id()
        return cls(
            id=system_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MagicalSystem':
        """Create a magical system instance from a dictionary."""
        data_copy = data.copy()
        if 'spells' in data_copy and isinstance(data_copy['spells'], dict):
            spells = {}
            for spell_id, spell_data in data_copy['spells'].items():
                if isinstance(spell_data, dict):
                    if 'id' not in spell_data: spell_data['id'] = spell_id
                    spells[spell_id] = Spell.from_dict(spell_data)
                elif isinstance(spell_data, Spell):
                    spells[spell_id] = spell_data
            data_copy['spells'] = spells

        if 'racial_affinities' in data_copy and isinstance(data_copy['racial_affinities'], dict):
            racial_affinities = {}
            for race_name, affinity_data in data_copy['racial_affinities'].items():
                if isinstance(affinity_data, dict):
                    racial_affinities[race_name] = RacialAffinity(**affinity_data)
                elif isinstance(affinity_data, RacialAffinity):
                    racial_affinities[race_name] = affinity_data
            data_copy['racial_affinities'] = racial_affinities

        if 'class_affinities' in data_copy and isinstance(data_copy['class_affinities'], dict):
            class_affinities = {}
            for class_name, affinity_data in data_copy['class_affinities'].items():
                if isinstance(affinity_data, dict):
                    class_affinities[class_name] = ClassAffinity(**affinity_data)
                elif isinstance(affinity_data, ClassAffinity):
                    class_affinities[class_name] = affinity_data
            data_copy['class_affinities'] = class_affinities

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)


# --- Race and Class Related (MOVED HERE) ---
@dataclass
class RaceTrait:
    """Represents a specific trait of a race."""
    name: str
    description: str

@dataclass
class Race(BaseModel):
    """Represents a playable race in the game world."""
    id: str
    name: str
    description: str
    stat_modifiers: Dict[str, int] = field(default_factory=dict)
    traits: List[RaceTrait] = field(default_factory=list)
    recommended_classes: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'Race':
        """Create a new race with a unique ID."""
        race_id = cls.generate_id()
        return cls(
            id=race_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Race':
        """Create a race instance from a dictionary."""
        data_copy = data.copy()
        if 'traits' in data_copy and isinstance(data_copy['traits'], list):
            traits = []
            for trait_data in data_copy['traits']:
                if isinstance(trait_data, dict):
                    traits.append(RaceTrait(**trait_data))
                elif isinstance(trait_data, RaceTrait):
                     traits.append(trait_data)
            data_copy['traits'] = traits

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

@dataclass
class ClassArchetype:
    """Represents a specific archetype or specialization within a class."""
    name: str
    description: str
    stat_distribution: Dict[str, int] = field(default_factory=dict)

@dataclass
class CharacterClass(BaseModel):
    """Represents a character class in the game."""
    id: str
    name: str
    description: str
    stat_modifiers: Dict[str, int] = field(default_factory=dict)
    minimum_stats: Dict[str, int] = field(default_factory=dict)
    recommended_stats: Dict[str, List[str]] = field(default_factory=dict) # e.g., {"primary": ["STR"], "secondary": ["CON"]}
    archetypes: Dict[str, ClassArchetype] = field(default_factory=dict)
    weapon_proficiencies: List[str] = field(default_factory=list)
    armor_proficiencies: List[str] = field(default_factory=list)

    @classmethod
    def create_new(cls, name: str, description: str) -> 'CharacterClass':
        """Create a new class with a unique ID."""
        class_id = cls.generate_id()
        return cls(
            id=class_id,
            name=name,
            description=description
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CharacterClass':
        """Create a class instance from a dictionary."""
        data_copy = data.copy()
        if 'archetypes' in data_copy and isinstance(data_copy['archetypes'], dict):
            archetypes = {}
            for arch_name, arch_data in data_copy['archetypes'].items():
                if isinstance(arch_data, dict):
                     # Ensure name is included if missing in nested dict
                    if 'name' not in arch_data:
                        arch_data['name'] = arch_name
                    archetypes[arch_name] = ClassArchetype(**arch_data)
                # If it's already an object, keep it
                elif isinstance(arch_data, ClassArchetype):
                    archetypes[arch_name] = arch_data
            data_copy['archetypes'] = archetypes

        known_fields = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data_copy.items() if k in known_fields}
        return cls(**filtered_data)

@dataclass
class OriginTrait:
    """Represents a minor trait granted by an Origin."""
    name: str = ""
    description: str = ""

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'OriginTrait':
        return cls(
            name=data.get("name", ""),
            description=data.get("description", "")
        )

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "description": self.description
        }

@dataclass
class Origin:
    """Represents a starting origin/scenario for a character."""
    id: str = field(default_factory=lambda: f"origin_{uuid.uuid4().hex[:8]}")
    name: str = "New Origin"
    description: str = ""
    starting_location_id: str = ""
    starting_culture_id: Optional[str] = None # Optional culture override
    starting_items: List[str] = field(default_factory=list)
    initial_quests: List[str] = field(default_factory=list)
    suitable_races: List[str] = field(default_factory=list)
    suitable_classes: List[str] = field(default_factory=list)
    introduction_text: str = ""
    skill_proficiencies: List[str] = field(default_factory=list) # NEW
    origin_traits: List[OriginTrait] = field(default_factory=list) # NEW
    
    # Time-related settings for enhanced time management
    starting_time_period: Optional[str] = None  # e.g., "dawn", "noon", "evening", etc.
    starting_season: Optional[str] = None       # e.g., "Spring", "Summer", "Fall", "Winter"
    time_progression_rate: Optional[float] = None  # Custom time scale if different from default

    @classmethod
    def create_new(cls, name: str, description: str, location_id: str) -> 'Origin':
        """Helper to create a new Origin with a default ID."""
        return cls(
            name=name,
            description=description,
            starting_location_id=location_id
        )

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Origin':
        # Handle optional fields gracefully
        traits_data = data.get("origin_traits", [])
        traits = [OriginTrait.from_dict(t) for t in traits_data if isinstance(t, dict)]

        return cls(
            id=data.get("id", f"origin_{uuid.uuid4().hex[:8]}"),
            name=data.get("name", "Unknown Origin"),
            description=data.get("description", ""),
            starting_location_id=data.get("starting_location_id", data.get("starting_location", "")), # Check old key too
            starting_culture_id=data.get("starting_culture_id"), # Okay if None
            starting_items=data.get("starting_items", []),
            initial_quests=data.get("initial_quests", []),
            suitable_races=data.get("suitable_races", []),
            suitable_classes=data.get("suitable_classes", []),
            introduction_text=data.get("introduction_text", ""),
            skill_proficiencies=data.get("skill_proficiencies", []), # NEW
            origin_traits=traits # NEW
        )

    def to_dict(self) -> Dict[str, Any]:
        # Filter out None values for cleaner JSON, especially for optional culture
        data = {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "starting_location_id": self.starting_location_id,
            "starting_items": self.starting_items,
            "initial_quests": self.initial_quests,
            "suitable_races": self.suitable_races,
            "suitable_classes": self.suitable_classes,
            "introduction_text": self.introduction_text,
            "skill_proficiencies": self.skill_proficiencies, # NEW
            "origin_traits": [t.to_dict() for t in self.origin_traits] # NEW
        }
        if self.starting_culture_id is not None:
            data["starting_culture_id"] = self.starting_culture_id
        return data

# --- World Config Container
@dataclass
class WorldConfig:
    """
    Container for all world configuration data.
    Uses the unified Origin concept.
    """
    cultures: Dict[str, Culture] = field(default_factory=dict)
    locations: Dict[str, Location] = field(default_factory=dict)
    history: Optional[WorldHistory] = None
    rules: Optional[WorldRules] = None
    origins: Dict[str, Origin] = field(default_factory=dict)
    quests: Dict[str, Quest] = field(default_factory=dict)
    magic_systems: Dict[str, MagicalSystem] = field(default_factory=dict)
    races: Dict[str, Race] = field(default_factory=dict)
    classes: Dict[str, CharacterClass] = field(default_factory=dict)
    state: WorldModelState = field(default_factory=WorldModelState)

    def add_race(self, race: Race) -> None:
        """Add a race to the configuration."""
        self.races[race.id] = race
        self.state.mark_modified()

    def add_class(self, char_class: CharacterClass) -> None:
        """Add a character class to the configuration."""
        self.classes[char_class.id] = char_class
        self.state.mark_modified()

    # RENAMED add_scenario to add_origin
    def add_origin(self, origin: Origin) -> None:
        """Add a starting origin to the configuration."""
        self.origins[origin.id] = origin
        self.state.mark_modified()

    def add_culture(self, culture: Culture) -> None:
        """Add a culture to the configuration."""
        self.cultures[culture.id] = culture
        self.state.mark_modified()

    def add_location(self, location: Location) -> None:
        """Add a location to the configuration."""
        self.locations[location.id] = location
        self.state.mark_modified()

    def add_magic_system(self, magic_system: MagicalSystem) -> None:
        """Add a magical system to the configuration."""
        self.magic_systems[magic_system.id] = magic_system
        self.state.mark_modified()

    def set_history(self, history: WorldHistory) -> None:
        """Set the world history."""
        self.history = history
        self.state.mark_modified()

    def set_rules(self, rules: WorldRules) -> None:
        """Set the fundamental rules."""
        self.rules = rules
        self.state.mark_modified()

    def to_dict(self) -> Dict[str, Any]:
        """Convert the configuration to a dictionary."""
        result = {
            "cultures": {k: v.to_dict() for k, v in self.cultures.items()},
            "locations": {k: v.to_dict() for k, v in self.locations.items()},
            "origins": {k: v.to_dict() for k, v in self.origins.items()}, # RENAMED from scenarios
            "quests": {k: v.to_dict() for k, v in self.quests.items()},
            "magic_systems": {k: v.to_dict() for k, v in self.magic_systems.items()},
            "races": {k: v.to_dict() for k, v in self.races.items()},
            "classes": {k: v.to_dict() for k, v in self.classes.items()},
        }
        if self.history: result["history"] = self.history.to_dict()
        if self.rules: result["rules"] = self.rules.to_dict()
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'WorldConfig':
        """Create a configuration from a dictionary."""
        config = cls()
        if "cultures" in data:
            for item_id, item_data in data["cultures"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.cultures[item_id] = Culture.from_dict(item_data)
        if "locations" in data:
            for item_id, item_data in data["locations"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.locations[item_id] = Location.from_dict(item_data)
        if "origins" in data:
            for item_id, item_data in data["origins"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.origins[item_id] = Origin.from_dict(item_data)
        if "quests" in data:
            for item_id, item_data in data["quests"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.quests[item_id] = Quest.from_dict(item_data)
        if "magic_systems" in data:
            for item_id, item_data in data["magic_systems"].items():
                if "id" not in item_data: item_data["id"] = item_id
                config.magic_systems[item_id] = MagicalSystem.from_dict(item_data)
        if "history" in data:
            config.history = WorldHistory.from_dict(data["history"])
        if "rules" in data:
            config.rules = WorldRules.from_dict(data["rules"])
        if "races" in data:
            for race_id, race_data in data["races"].items():
                if "id" not in race_data: race_data["id"] = race_id
                config.races[race_id] = Race.from_dict(race_data)
        if "classes" in data:
            for class_id, class_data in data["classes"].items():
                if "id" not in class_data: class_data["id"] = class_id
                config.classes[class_id] = CharacterClass.from_dict(class_data)

        return config

```

### File: world_configurator\models\item_data_manager.py

```python
# world_configurator/models/item_data_manager.py
"""
Manager for all item data files (origin_items.json, base_weapons.json, etc.).
"""

import logging
import os
import shutil
import datetime
from typing import Dict, List, Optional, Any

from models.base_models import WorldModelState
from utils.file_manager import load_json, save_json, get_project_root, get_config_dir

logger = logging.getLogger("world_configurator.models.item_data_manager")

# This mapping should ideally match ItemEditorPanel.ITEM_CATEGORIES keys to file paths
# It defines which item files this manager is responsible for.
# Paths are relative to the project root.
MANAGED_ITEM_FILES = {
    "items_origin": "config/items/origin_items.json",
    "items_weapons": "config/items/base_weapons.json",
    "items_armor": "config/items/base_armor.json",
    "items_consumables": "config/items/consumables.json",
    "items_misc": "config/items/miscellaneous.json"
    # Add more if new item categories are introduced
}

class ItemDataManager:
    """
    Manages loading, saving, and exporting for all item-related JSON files.
    """
    def __init__(self):
        # Stores data for each managed item file, e.g., {"items_origin": [list of items], ...}
        self.all_item_data: Dict[str, List[Dict[str, Any]]] = {}
        # Tracks modification state per file key
        self.file_states: Dict[str, WorldModelState] = {}
        self.project_root_path = get_project_root()

        for key, _ in MANAGED_ITEM_FILES.items():
            self.file_states[key] = WorldModelState()
            self.all_item_data[key] = []


    def load_item_file(self, file_key: str) -> bool:
        """
        Load a specific item file based on its key.

        Args:
            file_key: The key identifying the item file (e.g., "items_origin").

        Returns:
            True if loading was successful, False otherwise.
        """
        relative_path = MANAGED_ITEM_FILES.get(file_key)
        if not relative_path:
            logger.error(f"ItemDataManager: Unknown item file key '{file_key}'. Cannot load.")
            return False

        full_path = os.path.join(self.project_root_path, relative_path)
        
        try:
            data = load_json(full_path)
            if isinstance(data, list): # Item files are expected to be lists of items
                self.all_item_data[file_key] = data
                self.file_states[file_key].path = full_path
                self.file_states[file_key].modified = False
                logger.info(f"Loaded {len(data)} items for '{file_key}' from {full_path}")
                return True
            else:
                logger.warning(f"Invalid item file format for '{file_key}' (expected list) in {full_path}. Initializing empty.")
                self.all_item_data[file_key] = []
                if os.path.exists(full_path):
                    self.file_states[file_key].modified = True
                return False
        except Exception as e:
            logger.error(f"Error loading item file '{file_key}' from {full_path}: {e}", exc_info=True)
            self.all_item_data[file_key] = []
            return False

    def save_item_file(self, file_key: str, project_dir_override: Optional[str] = None) -> bool:
        """
        Save a specific item file.

        Args:
            file_key: The key identifying the item file.
            project_dir_override: If provided, save relative to this directory instead of original.

        Returns:
            True if saving was successful, False otherwise.
        """
        relative_path = MANAGED_ITEM_FILES.get(file_key)
        if not relative_path:
            logger.error(f"ItemDataManager: Unknown item file key '{file_key}'. Cannot save.")
            return False

        data_to_save = self.all_item_data.get(file_key, [])
        
        save_path: str
        if project_dir_override:
            # Construct path relative to the project_dir_override
            # MANAGED_ITEM_FILES paths are like "config/items/origin_items.json"
            # We need to join project_dir_override with the parts after "config/"
            # This assumes project_dir_override is the "config" directory itself or its parent.
            # For WorldConfigManager.save_project, target_dir is the *project's* root,
            # so we need to create "config/items" subdirectories within it.
            path_parts = relative_path.split(os.sep) # e.g. ['config', 'items', 'origin_items.json']
            # We need to ensure the 'items' subdirectory exists within 'project_dir_override/config/'
            save_dir = os.path.join(project_dir_override, *path_parts[:-1]) # e.g. project_dir/config/items
            os.makedirs(save_dir, exist_ok=True)
            save_path = os.path.join(save_dir, path_parts[-1])

        else: # Saving to original loaded path or default
            save_path = self.file_states[file_key].path or os.path.join(self.project_root_path, relative_path)


        try:
            if save_json(data_to_save, save_path):
                self.file_states[file_key].path = save_path # Update path if it changed
                self.file_states[file_key].modified = False
                logger.info(f"Saved {len(data_to_save)} items for '{file_key}' to {save_path}")
                return True
            return False
        except Exception as e:
            logger.error(f"Error saving item file '{file_key}' to {save_path}: {e}", exc_info=True)
            return False

    def get_item_data_for_key(self, file_key: str) -> Optional[List[Dict[str, Any]]]:
        """Returns the item data list for a given file key."""
        return self.all_item_data.get(file_key)

    def update_item_data_for_key(self, file_key: str, new_data: List[Dict[str, Any]]):
        """Updates the item data for a given file key."""
        if file_key in self.all_item_data:
            self.all_item_data[file_key] = new_data
            self.file_states[file_key].mark_modified()
            logger.info(f"Item data for '{file_key}' updated in manager.")
        else:
            logger.warning(f"ItemDataManager: Attempted to update data for unknown file key '{file_key}'.")

    def load_all_managed_files(self, project_dir: Optional[str] = None):
        """Loads all item files defined in MANAGED_ITEM_FILES."""
        logger.info("ItemDataManager: Loading all managed item files.")
        for file_key in MANAGED_ITEM_FILES.keys():
            file_path_to_load = None
            if project_dir: # Loading from a specific project directory
                relative_path = MANAGED_ITEM_FILES[file_key]
                file_path_to_load = os.path.join(project_dir, relative_path)
                if not os.path.exists(file_path_to_load):
                    logger.debug(f"Item file {file_path_to_load} not found in project. Will use default if available or create new.")
                    # Reset specific file state if not found in project, it will try default path or create new
                    self.all_item_data[file_key] = []
                    self.file_states[file_key] = WorldModelState() # Reset state
                    # Try default load for this file
                    self.load_item_file(file_key) # This will use default path if project one DNE
                    continue # Move to next file key
            
            # If no project_dir or file not in project_dir, load_item_file handles default path logic.
            if not self.load_item_file(file_key) and not project_dir: # Only log error if not project specific and default fails
                 logger.warning(f"Failed to load default item file for '{file_key}'.")


    def save_all_managed_files(self, project_dir: Optional[str] = None) -> bool:
        """Saves all modified item files."""
        all_successful = True
        for file_key in MANAGED_ITEM_FILES.keys():
            # Save if modified OR if a project_dir_override is given (forcing save to new location)
            if self.file_states[file_key].modified or project_dir:
                if not self.save_item_file(file_key, project_dir_override=project_dir):
                    all_successful = False
        return all_successful

    def export_item_file_to_game(self, file_key: str) -> bool:
        """Exports a specific item file to the game's config directory."""
        relative_path_from_config_root = MANAGED_ITEM_FILES.get(file_key)
        if not relative_path_from_config_root:
            logger.error(f"Cannot export unknown item file key: {file_key}")
            return False
        
        # MANAGED_ITEM_FILES paths are like "config/items/origin_items.json"
        # We need path relative to "config" dir for export target construction.
        # e.g., "items/origin_items.json"
        if not relative_path_from_config_root.startswith("config/"):
            logger.error(f"Invalid path format for item file key '{file_key}': {relative_path_from_config_root}")
            return False
        
        path_in_config_dir = os.path.relpath(relative_path_from_config_root, "config")

        game_config_dir = get_config_dir() # This is .../RPG-Text-Game/config
        target_path = os.path.join(game_config_dir, path_in_config_dir)
        
        # Ensure target subdirectory (e.g., 'items') exists
        target_subdir = os.path.dirname(target_path)
        os.makedirs(target_subdir, exist_ok=True)

        # Backup existing game file
        backup_dir = os.path.join(target_subdir, "backup")
        os.makedirs(backup_dir, exist_ok=True)
        if os.path.exists(target_path):
            filename = os.path.basename(target_path)
            name, ext = os.path.splitext(filename)
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"{name}_{file_key}_{timestamp}{ext}" # More specific backup
            backup_file_path = os.path.join(backup_dir, backup_filename)
            try:
                shutil.copy2(target_path, backup_file_path)
                logger.info(f"Created backup of game's {filename} at {backup_file_path}")
            except Exception as e_backup:
                logger.error(f"Failed to backup game's {filename}: {e_backup}")
        
        # Load freshest data from source file on disk to avoid stale in-memory state
        source_full_path = os.path.join(get_project_root(), MANAGED_ITEM_FILES[file_key])
        latest = load_json(source_full_path)
        data_to_export = latest if isinstance(latest, list) else self.all_item_data.get(file_key, [])
        if save_json(data_to_export, target_path):
            logger.info(f"Successfully exported '{file_key}' to {target_path}")
            return True
        else:
            logger.error(f"Failed to export '{file_key}' to {target_path}")
            return False

    def is_any_file_modified(self) -> bool:
        """Checks if any managed item file has been modified."""
        return any(state.modified for state in self.file_states.values())
```

### File: world_configurator\models\location_data.py

```python
"""
Location data models for the world configurator.
"""

import logging
import os
import shutil
import datetime
from typing import Dict, List, Any, Optional, Union

from models.base_models import Location, LocationConnection, LocationFeature, WorldModelState
from utils.file_manager import load_json, save_json, get_world_config_dir

logger = logging.getLogger("world_configurator.models.location_data")

class LocationManager:
    """
    Manager for location data.
    """
    def __init__(self):
        self.locations: Dict[str, Location] = {}
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load locations from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "locations" not in data:
                logger.error(f"Invalid locations file format: {file_path}")
                return False
            
            # Clear existing locations
            self.locations.clear()
            
            # Load each location
            for location_id, location_data in data["locations"].items():
                # Ensure the location has an ID
                if "id" not in location_data:
                    location_data["id"] = location_id
                
                location = Location.from_dict(location_data)
                self.locations[location_id] = location
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded {len(self.locations)} locations from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading locations from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save locations to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving locations")
                return False
            
            # Prepare data
            data = {
                "locations": {k: v.to_dict() for k, v in self.locations.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Location definitions for the RPG game world"
                }
            }
            
            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.locations)} locations to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving locations: {e}")
            return False
    
    def add_location(self, location: Location) -> None:
        """
        Add a location to the manager.
        
        Args:
            location: The location to add.
        """
        self.locations[location.id] = location
        self.state.modified = True
        logger.info(f"Added location: {location.name} ({location.id})")
    
    def remove_location(self, location_id: str) -> bool:
        """
        Remove a location from the manager.
        
        Args:
            location_id: The ID of the location to remove.
        
        Returns:
            True if the location was removed, False if it wasn't found.
        """
        if location_id in self.locations:
            del self.locations[location_id]
            self.state.modified = True
            logger.info(f"Removed location: {location_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent location: {location_id}")
            return False
    
    def get_location(self, location_id: str) -> Optional[Location]:
        """
        Get a location by ID.
        
        Args:
            location_id: The ID of the location to get.
        
        Returns:
            The location if found, None otherwise.
        """
        return self.locations.get(location_id)
    
    def add_connection(self, source_id: str, target_id: str, description: str, travel_time: int) -> bool:
        """
        Add a connection between two locations.
        
        Args:
            source_id: The ID of the source location.
            target_id: The ID of the target location.
            description: Description of the connection.
            travel_time: Travel time in minutes.
        
        Returns:
            True if the connection was added, False if a location wasn't found.
        """
        source = self.get_location(source_id)
        target = self.get_location(target_id)
        
        if not source:
            logger.warning(f"Cannot add connection from non-existent location: {source_id}")
            return False
        
        if not target:
            logger.warning(f"Cannot add connection to non-existent location: {target_id}")
            return False
        
        # Create connection
        connection = LocationConnection(
            target=target_id,
            description=description,
            travel_time=travel_time
        )
        
        # Add to source location
        source.connections.append(connection)
        self.state.modified = True
        
        logger.info(f"Added connection from {source_id} to {target_id}")
        return True
    
    def remove_connection(self, source_id: str, target_id: str) -> bool:
        """
        Remove a connection between two locations.
        
        Args:
            source_id: The ID of the source location.
            target_id: The ID of the target location.
        
        Returns:
            True if the connection was removed, False if a location or connection wasn't found.
        """
        source = self.get_location(source_id)
        
        if not source:
            logger.warning(f"Cannot remove connection from non-existent location: {source_id}")
            return False
        
        for i, connection in enumerate(source.connections):
            if connection.target == target_id:
                source.connections.pop(i)
                self.state.modified = True
                logger.info(f"Removed connection from {source_id} to {target_id}")
                return True
        
        logger.warning(f"No connection found from {source_id} to {target_id}")
        return False
    
    def add_feature_to_location(self, location_id: str, feature: LocationFeature) -> bool:
        """
        Add a feature to a location.
        
        Args:
            location_id: The ID of the location to modify.
            feature: The feature to add.
        
        Returns:
            True if the feature was added, False if the location wasn't found.
        """
        location = self.get_location(location_id)
        if not location:
            logger.warning(f"Cannot add feature to non-existent location: {location_id}")
            return False
        
        location.features.append(feature)
        self.state.modified = True
        logger.info(f"Added feature to location {location_id}: {feature.name}")
        return True
    
    def remove_feature_from_location(self, location_id: str, feature_name: str) -> bool:
        """
        Remove a feature from a location.
        
        Args:
            location_id: The ID of the location to modify.
            feature_name: The name of the feature to remove.
        
        Returns:
            True if the feature was removed, False if the location or feature wasn't found.
        """
        location = self.get_location(location_id)
        if not location:
            logger.warning(f"Cannot remove feature from non-existent location: {location_id}")
            return False
        
        for i, feature in enumerate(location.features):
            if feature.name == feature_name:
                location.features.pop(i)
                self.state.modified = True
                logger.info(f"Removed feature {feature_name} from location {location_id}")
                return True
        
        logger.warning(f"No feature named {feature_name} found in location {location_id}")
        return False
    
    def verify_connections(self) -> List[str]:
        """
        Verify that all connections reference valid location IDs.
        
        Returns:
            A list of error messages, or an empty list if all connections are valid.
        """
        errors = []
        
        for location_id, location in self.locations.items():
            for i, connection in enumerate(location.connections):
                if connection.target not in self.locations:
                    error = f"Location {location_id} has invalid connection to non-existent location: {connection.target}"
                    errors.append(error)
                    logger.warning(error)
        
        return errors
    
    def export_to_game(self) -> bool:
        """
        Export locations to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "locations")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "locations.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting locations to game: {e}")
            return False

```

### File: world_configurator\models\location_defaults_manager.py

```python
"""
LocationDefaultsManager for handling config/world/locations/defaults.json within the World Configurator.
"""
import os
import json
import logging
import shutil
import datetime
from typing import Optional, Dict, Any

from models.base_models import WorldModelState
from utils.file_manager import get_world_config_dir, save_json, load_json

logger = logging.getLogger("world_configurator.models.location_defaults_manager")

class LocationDefaultsManager:
    """Manager for world/locations/defaults.json which includes global culture_mix defaults."""

    def __init__(self):
        # Stored structure: { "culture_mix": {"culture_id": weight, ...}, "metadata": {...} }
        self.data: Dict[str, Any] = {"culture_mix": {}, "metadata": {"version": "1.0.0"}}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """Load defaults.json from a file path."""
        try:
            raw = load_json(file_path)
            if not isinstance(raw, dict):
                logger.error(f"Invalid defaults file format (not an object): {file_path}")
                self.data = {"culture_mix": {}, "metadata": {"version": "1.0.0"}}
                return False
            if "culture_mix" not in raw or not isinstance(raw["culture_mix"], dict):
                logger.warning("defaults.json missing 'culture_mix' object; initializing empty.")
                raw["culture_mix"] = {}
            self.data = raw
            self.state.path = file_path
            self.state.modified = False
            logger.info(
                f"Loaded culture mix defaults from {file_path} (entries: {len(self.data['culture_mix'])})"
            )
            return True
        except Exception as e:
            logger.error(f"Error loading defaults.json from {file_path}: {e}")
            self.data = {"culture_mix": {}, "metadata": {"version": "1.0.0"}}
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """Save defaults.json to the given file path or to the current state path."""
        try:
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving defaults.json")
                return False
            # Normalize structure
            data_to_save = dict(self.data) if isinstance(self.data, dict) else {"culture_mix": {}, "metadata": {"version": "1.0.0"}}
            if "culture_mix" not in data_to_save or not isinstance(data_to_save["culture_mix"], dict):
                data_to_save["culture_mix"] = {}
            ok = save_json(data_to_save, path)
            if ok:
                self.state.path = path
                self.state.modified = False
                logger.info(
                    f"Saved culture mix defaults to {path} (entries: {len(data_to_save['culture_mix'])})"
                )
            return ok
        except Exception as e:
            logger.error(f"Error saving defaults.json: {e}")
            return False

    def export_to_game(self) -> bool:
        """Export the current defaults data to the game's config/world/locations/defaults.json with backups."""
        try:
            if not isinstance(self.data, dict):
                logger.error("No defaults data to export.")
                return False
            target_dir = os.path.join(get_world_config_dir(), "locations")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "defaults.json")

            # Backup if target exists
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            if os.path.exists(target_path):
                name, ext = os.path.splitext(os.path.basename(target_path))
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = os.path.join(backup_dir, f"{name}_{timestamp}{ext}")
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup for defaults.json: {backup_err}")
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting defaults.json to game: {e}")
            return False

```

### File: world_configurator\models\names_manager.py

```python
"""
NamesManager for handling config/npc/names.json within the World Configurator.
"""
import os
import json
import logging
import shutil
import datetime
from typing import Optional, Dict, Any

from models.base_models import WorldModelState
from utils.file_manager import get_config_dir, save_json, load_json

logger = logging.getLogger("world_configurator.models.names_manager")

class NamesManager:
    """Manager for culture-aware names configuration (config/npc/names.json)."""

    def __init__(self):
        self.data: Dict[str, Any] = {"cultures": {}}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """Load names.json from a file path."""
        try:
            raw = load_json(file_path)
            if not isinstance(raw, dict):
                logger.error(f"Invalid names file format (not an object): {file_path}")
                self.data = {"cultures": {}}
                return False
            if "cultures" not in raw or not isinstance(raw["cultures"], dict):
                logger.warning("names.json missing 'cultures' object; initializing empty.")
                raw["cultures"] = {}
            self.data = raw
            self.state.path = file_path
            self.state.modified = False
            logger.info(f"Loaded names from {file_path} (cultures: {len(self.data['cultures'])})")
            return True
        except Exception as e:
            logger.error(f"Error loading names from {file_path}: {e}")
            self.data = {"cultures": {}}
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """Save names.json to the given file path or to the current state path."""
        try:
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving names.json")
                return False
            # Normalize structure
            data_to_save = dict(self.data) if isinstance(self.data, dict) else {"cultures": {}}
            if "cultures" not in data_to_save or not isinstance(data_to_save["cultures"], dict):
                data_to_save["cultures"] = {}
            ok = save_json(data_to_save, path)
            if ok:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved names to {path} (cultures: {len(data_to_save['cultures'])})")
            return ok
        except Exception as e:
            logger.error(f"Error saving names.json: {e}")
            return False

    def export_to_game(self) -> bool:
        """Export the current names data to the game's config/npc/names.json with backups."""
        try:
            # Ensure we have data to save
            if not isinstance(self.data, dict):
                logger.error("No names data to export.")
                return False
            target_dir = os.path.join(get_config_dir(), "npc")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "names.json")

            # Backup if target exists
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            if os.path.exists(target_path):
                name, ext = os.path.splitext(os.path.basename(target_path))
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = os.path.join(backup_dir, f"{name}_{timestamp}{ext}")
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup for names.json: {backup_err}")
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting names to game: {e}")
            return False


```

### File: world_configurator\models\origin_data.py

```python
# world_configurator/models/origin_data.py
"""
Origin data models for starting origins.
(Formerly Scenario Data)
"""

import logging
import os
import shutil
import datetime
from typing import Dict, List, Any, Optional, Union

# Assuming Origin model exists in base_models with the new fields
from models.base_models import Origin, Quest, QuestObjective, WorldModelState
from utils.file_manager import load_json, save_json, get_world_config_dir

logger = logging.getLogger("world_configurator.models.origin_data") # Updated logger name

class OriginManager: # Renamed class
    """
    Manager for starting origin data.
    """
    def __init__(self):
        self.origins: Dict[str, Origin] = {} # Renamed variable and type hint
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """
        Load origins from a JSON file.

        Args:
            file_path: Path to the JSON file.

        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            # Check for 'origins' key instead of 'scenarios'
            if not data or "origins" not in data:
                logger.error(f"Invalid origins file format: {file_path}")
                return False

            # Clear existing origins
            self.origins.clear() # Renamed variable

            # Load each origin
            for origin_id, origin_data in data["origins"].items(): # Use 'origins' key
                # Ensure the origin has an ID
                if "id" not in origin_data:
                    origin_data["id"] = origin_id

                origin = Origin.from_dict(origin_data) # Use Origin model
                self.origins[origin_id] = origin # Renamed variable

            # Update state
            self.state.path = file_path
            self.state.modified = False

            logger.info(f"Loaded {len(self.origins)} origins from {file_path}") # Renamed log message
            return True
        except Exception as e:
            logger.error(f"Error loading origins from {file_path}: {e}", exc_info=True) # Added exc_info
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save origins to a JSON file.

        Args:
            file_path: Path to the JSON file. If None, uses the path from state.

        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving origins")
                return False

            # Prepare data
            data = {
                # Use 'origins' key
                "origins": {k: v.to_dict() for k, v in self.origins.items()}, # Renamed variable
                "metadata": {
                    "version": "1.0.1", # Updated version
                    "description": "Starting origin definitions for the RPG game world" # Updated description
                }
            }

            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.origins)} origins to {path}") # Renamed log message

            return result
        except Exception as e:
            logger.error(f"Error saving origins: {e}", exc_info=True) # Added exc_info
            return False

    def add_origin(self, origin: Origin) -> None: # Renamed method and type hint
        """
        Add an origin to the manager.

        Args:
            origin: The origin to add.
        """
        self.origins[origin.id] = origin # Renamed variable
        self.state.modified = True
        logger.info(f"Added origin: {origin.name} ({origin.id})")

    def remove_origin(self, origin_id: str) -> bool: # Renamed method
        """
        Remove an origin from the manager.

        Args:
            origin_id: The ID of the origin to remove.

        Returns:
            True if the origin was removed, False if it wasn't found.
        """
        if origin_id in self.origins: # Renamed variable
            del self.origins[origin_id] # Renamed variable
            self.state.modified = True
            logger.info(f"Removed origin: {origin_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent origin: {origin_id}")
            return False

    def get_origin(self, origin_id: str) -> Optional[Origin]: # Renamed method and return type
        """
        Get an origin by ID.

        Args:
            origin_id: The ID of the origin to get.

        Returns:
            The origin if found, None otherwise.
        """
        return self.origins.get(origin_id) # Renamed variable

    def export_to_game(self) -> bool:
        """
        Export origins to the game's configuration directory.

        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path - Changed filename
            target_dir = os.path.join(get_world_config_dir(), "scenarios") # Keep subfolder for now
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "origins.json") # Changed filename

            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)

                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails

            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting origins to game: {e}", exc_info=True) # Added exc_info
            return False

# --- QuestManager remains the same ---
# (Assuming Quest data structure hasn't changed)
# ... (Keep existing QuestManager class here) ...
class QuestManager:
    """
    Manager for quest data.
    """
    def __init__(self):
        self.quests: Dict[str, Quest] = {}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """
        Load quests from a JSON file.

        Args:
            file_path: Path to the JSON file.

        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "quests" not in data:
                logger.error(f"Invalid quests file format: {file_path}")
                return False

            # Clear existing quests
            self.quests.clear()

            # Load each quest
            for quest_id, quest_data in data["quests"].items():
                # Ensure the quest has an ID
                if "id" not in quest_data:
                    quest_data["id"] = quest_id

                quest = Quest.from_dict(quest_data)
                self.quests[quest_id] = quest

            # Update state
            self.state.path = file_path
            self.state.modified = False

            logger.info(f"Loaded {len(self.quests)} quests from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading quests from {file_path}: {e}")
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save quests to a JSON file.

        Args:
            file_path: Path to the JSON file. If None, uses the path from state.

        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving quests")
                return False

            # Prepare data
            data = {
                "quests": {k: v.to_dict() for k, v in self.quests.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Quest definitions for the RPG game world"
                }
            }

            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.quests)} quests to {path}")

            return result
        except Exception as e:
            logger.error(f"Error saving quests: {e}")
            return False

    def add_quest(self, quest: Quest) -> None:
        """
        Add a quest to the manager.

        Args:
            quest: The quest to add.
        """
        self.quests[quest.id] = quest
        self.state.modified = True
        logger.info(f"Added quest: {quest.title} ({quest.id})")

    def remove_quest(self, quest_id: str) -> bool:
        """
        Remove a quest from the manager.

        Args:
            quest_id: The ID of the quest to remove.

        Returns:
            True if the quest was removed, False if it wasn't found.
        """
        if quest_id in self.quests:
            del self.quests[quest_id]
            self.state.modified = True
            logger.info(f"Removed quest: {quest_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent quest: {quest_id}")
            return False

    def get_quest(self, quest_id: str) -> Optional[Quest]:
        """
        Get a quest by ID.

        Args:
            quest_id: The ID of the quest to get.

        Returns:
            The quest if found, None otherwise.
        """
        quest = self.quests.get(quest_id)

        # Ensure we're returning a Quest object, not a dict
        if quest and isinstance(quest, dict):
            try:
                quest = Quest.from_dict(quest)
                self.quests[quest_id] = quest  # Update the dictionary with the object
                logger.info(f"Converted dict to Quest object for {quest_id}")
            except Exception as e:
                logger.error(f"Error converting quest dict to object for {quest_id}: {str(e)}")

        return quest

    def add_objective_to_quest(self, quest_id: str, objective: QuestObjective) -> bool:
        """
        Add an objective to a quest.

        Args:
            quest_id: The ID of the quest to modify.
            objective: The objective to add.

        Returns:
            True if the objective was added, False if the quest wasn't found.
        """
        quest = self.get_quest(quest_id)
        if not quest:
            logger.warning(f"Cannot add objective to non-existent quest: {quest_id}")
            return False

        quest.objectives.append(objective)
        self.state.modified = True
        logger.info(f"Added objective to quest {quest_id}: {objective.description}")
        return True

    def remove_objective_from_quest(self, quest_id: str, objective_id: str) -> bool:
        """
        Remove an objective from a quest.

        Args:
            quest_id: The ID of the quest to modify.
            objective_id: The ID of the objective to remove.

        Returns:
            True if the objective was removed, False if the quest or objective wasn't found.
        """
        quest = self.get_quest(quest_id)
        if not quest:
            logger.warning(f"Cannot remove objective from non-existent quest: {quest_id}")
            return False

        initial_len = len(quest.objectives)
        quest.objectives = [obj for obj in quest.objectives if obj.id != objective_id]

        if len(quest.objectives) < initial_len:
             self.state.modified = True
             logger.info(f"Removed objective {objective_id} from quest {quest_id}")
             return True
        else:
             logger.warning(f"Cannot remove non-existent objective {objective_id} from quest {quest_id}")
             return False


    def export_to_game(self) -> bool:
        """
        Export quests to the game's configuration directory.

        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "scenarios") # Keep quests in scenarios subfolder for now
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "quests.json")

            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)

                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails

            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting quests to game: {e}")
            return False
```

### File: world_configurator\models\skill_manager.py

```python
# world_configurator/models/skill_manager.py
"""
Manager for skill data (skills.json).
"""

import logging
import os
import shutil
import datetime
from typing import Dict, Optional, Any

from models.base_models import WorldModelState
from utils.file_manager import load_json, save_json, get_project_root, get_config_dir

logger = logging.getLogger("world_configurator.models.skill_manager")

class SkillManager:
    """
    Manager for skill data from skills.json.
    """
    def __init__(self):
        # The skills_data will store the direct content of the "skills" key in skills.json
        # e.g., {"melee_attack": {"name": "Melee Attack", ...}, ...}
        self.skills_data: Dict[str, Dict[str, Any]] = {}
        self.state = WorldModelState()
        self.file_path: Optional[str] = None
        self._ensure_default_file_path()

    def _ensure_default_file_path(self):
        """Ensures a default file path is set if not already loaded."""
        if not self.file_path:
            # Default path construction, assuming skills.json is in 'config/'
            project_r = get_project_root()
            self.file_path = os.path.join(project_r, "config", "skills.json")
            self.state.path = self.file_path # Also update state path

    def load_from_file(self, file_path: Optional[str] = None) -> bool:
        """
        Load skills from skills.json.

        Args:
            file_path: Path to the JSON file. If None, uses the default path.

        Returns:
            True if loading was successful, False otherwise.
        """
        load_path = file_path or self.file_path
        if not load_path:
            self._ensure_default_file_path()
            load_path = self.file_path
            if not load_path: # Still no path
                logger.error("SkillManager: No file path specified or determined for loading skills.")
                return False
        
        self.file_path = load_path # Update internal path

        try:
            data = load_json(load_path)
            if data and "skills" in data and isinstance(data["skills"], dict):
                self.skills_data = data["skills"]
                self.state.path = load_path
                self.state.modified = False
                logger.info(f"Loaded {len(self.skills_data)} skills from {load_path}")
                return True
            else:
                logger.warning(f"Invalid skills file format or 'skills' key missing in {load_path}. Initializing empty.")
                self.skills_data = {}
                # If the file exists but is invalid, we might want to mark as modified or handle differently
                if os.path.exists(load_path):
                     self.state.modified = True # Mark modified if we had to reset due to bad format
                return False # Indicate that loading wasn't fully successful if format was bad
        except Exception as e:
            logger.error(f"Error loading skills from {load_path}: {e}", exc_info=True)
            self.skills_data = {} # Reset on error
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save skills to skills.json.

        Args:
            file_path: Path to the JSON file. If None, uses the path from state or default.

        Returns:
            True if saving was successful, False otherwise.
        """
        save_path = file_path or self.state.path or self.file_path
        if not save_path:
            self._ensure_default_file_path()
            save_path = self.file_path
            if not save_path: # Still no path
                logger.error("SkillManager: No file path specified or determined for saving skills.")
                return False

        data_to_save = {"skills": self.skills_data}
        try:
            if save_json(data_to_save, save_path):
                self.state.path = save_path
                self.file_path = save_path
                self.state.modified = False
                logger.info(f"Saved {len(self.skills_data)} skills to {save_path}")
                return True
            return False
        except Exception as e:
            logger.error(f"Error saving skills to {save_path}: {e}", exc_info=True)
            return False

    def get_all_skills(self) -> Dict[str, Dict[str, Any]]:
        """Returns all loaded skill data."""
        return self.skills_data

    def update_skills(self, new_skills_data: Dict[str, Dict[str, Any]]):
        """
        Completely replaces the current skills data.
        Used by editor when it saves changes.
        """
        self.skills_data = new_skills_data
        self.state.mark_modified()
        logger.info(f"SkillManager data updated with {len(new_skills_data)} skills.")


    def export_to_game(self) -> bool:
        """
        Export skills to the game's configuration directory (config/skills.json).
        """
        try:
            target_dir = get_config_dir() # config/
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "skills.json")

            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_skills_{timestamp}{ext}" # More specific backup name
                backup_path = os.path.join(backup_dir, backup_filename)
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of skills.json at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create skills.json backup: {backup_err}")

            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting skills to game: {e}", exc_info=True)
            return False
```

### File: world_configurator\models\variants_manager.py

```python
"""
VariantsManager for handling config/npc/variants.json within the World Configurator.
"""
import os
import json
import logging
import shutil
import datetime
from typing import Optional, Dict, Any, List

from models.base_models import WorldModelState
from utils.file_manager import get_config_dir, save_json, load_json

logger = logging.getLogger("world_configurator.models.variants_manager")

class VariantsManager:
    """Manager for NPC variants configuration (config/npc/variants.json)."""

    def __init__(self):
        # Stored structure: { "variants": {"variant_id": {...}}, "metadata": {...} }
        self.data: Dict[str, Any] = {"variants": {}, "metadata": {"version": "1.0.0"}}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """Load variants.json from a file path."""
        try:
            raw = load_json(file_path)
            if not isinstance(raw, dict):
                logger.error(f"Invalid variants file format (not an object): {file_path}")
                self.data = {"variants": {}, "metadata": {"version": "1.0.0"}}
                return False
            if "variants" not in raw or not isinstance(raw["variants"], dict):
                logger.warning("variants.json missing 'variants' object; initializing empty.")
                raw["variants"] = {}
            self.data = raw
            self.state.path = file_path
            self.state.modified = False
            logger.info(
                f"Loaded variants from {file_path} (variants: {len(self.data['variants'])})"
            )
            return True
        except Exception as e:
            logger.error(f"Error loading variants.json from {file_path}: {e}")
            self.data = {"variants": {}, "metadata": {"version": "1.0.0"}}
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """Save variants.json to the given file path or to the current state path."""
        try:
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving variants.json")
                return False
            # Normalize structure
            data_to_save = dict(self.data) if isinstance(self.data, dict) else {"variants": {}, "metadata": {"version": "1.0.0"}}
            if "variants" not in data_to_save or not isinstance(data_to_save["variants"], dict):
                data_to_save["variants"] = {}
            ok = save_json(data_to_save, path)
            if ok:
                self.state.path = path
                self.state.modified = False
                logger.info(
                    f"Saved variants to {path} (variants: {len(data_to_save['variants'])})"
                )
            return ok
        except Exception as e:
            logger.error(f"Error saving variants.json: {e}")
            return False

    def export_to_game(self) -> bool:
        """Export the current variants data to the game's config/npc/variants.json with backups."""
        try:
            if not isinstance(self.data, dict):
                logger.error("No variants data to export.")
                return False
            target_dir = os.path.join(get_config_dir(), "npc")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "variants.json")

            # Backup if target exists
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            if os.path.exists(target_path):
                name, ext = os.path.splitext(os.path.basename(target_path))
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = os.path.join(backup_dir, f"{name}_{timestamp}{ext}")
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup for variants.json: {backup_err}")
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting variants.json to game: {e}")
            return False

    def get_variant(self, variant_id: str) -> Optional[Dict[str, Any]]:
        """Get a variant by ID."""
        return self.data.get("variants", {}).get(variant_id)

    def add_variant(self, variant_id: str, variant_data: Dict[str, Any]) -> None:
        """Add or update a variant."""
        if "variants" not in self.data:
            self.data["variants"] = {}
        self.data["variants"][variant_id] = variant_data
        self.state.modified = True
        logger.debug(f"Added/updated variant: {variant_id}")

    def remove_variant(self, variant_id: str) -> bool:
        """Remove a variant by ID."""
        if "variants" in self.data and variant_id in self.data["variants"]:
            del self.data["variants"][variant_id]
            self.state.modified = True
            logger.debug(f"Removed variant: {variant_id}")
            return True
        return False

    def get_variants_by_family(self, family_id: str) -> List[Dict[str, Any]]:
        """Get all variants that belong to a specific family."""
        variants = []
        for variant_id, variant_data in self.data.get("variants", {}).items():
            if variant_data.get("family_id") == family_id:
                variant_copy = dict(variant_data)
                variant_copy["id"] = variant_id  # Ensure ID is included
                variants.append(variant_copy)
        return variants

    def get_social_role_variants(self, role: str) -> List[Dict[str, Any]]:
        """Get all variants that have a specific social role tag."""
        role_tag = f"role:{role}"
        variants = []
        for variant_id, variant_data in self.data.get("variants", {}).items():
            tags_add = variant_data.get("tags_add", [])
            if role_tag in tags_add:
                variant_copy = dict(variant_data)
                variant_copy["id"] = variant_id
                variants.append(variant_copy)
        return variants

    def get_culture_variants(self, culture: str) -> List[Dict[str, Any]]:
        """Get all variants that belong to a specific culture family."""
        variants = []
        culture_pattern = f"{culture}_"  # e.g., "concordant_", "verdant_"
        for variant_id, variant_data in self.data.get("variants", {}).items():
            if variant_id.startswith(culture_pattern):
                variant_copy = dict(variant_data)
                variant_copy["id"] = variant_id
                variants.append(variant_copy)
        return variants

    def validate_variant(self, variant_data: Dict[str, Any]) -> List[str]:
        """Validate a variant data structure and return list of errors."""
        errors = []
        
        # Required fields
        required_fields = ["id", "family_id", "name", "description"]
        for field in required_fields:
            if field not in variant_data or not variant_data[field]:
                errors.append(f"Missing required field: {field}")

        # Validate stat_modifiers structure
        if "stat_modifiers" in variant_data:
            stat_mods = variant_data["stat_modifiers"]
            if not isinstance(stat_mods, dict):
                errors.append("stat_modifiers must be a dictionary")
            else:
                valid_stats = ["hp", "damage", "defense", "initiative"]
                for stat, mod in stat_mods.items():
                    if stat not in valid_stats:
                        errors.append(f"Unknown stat in stat_modifiers: {stat}")
                    if not isinstance(mod, dict):
                        errors.append(f"stat_modifiers.{stat} must be a dictionary")
                    else:
                        for op in mod:
                            if op not in ["add", "mul"]:
                                errors.append(f"Unknown operation in stat_modifiers.{stat}: {op}")

        # Validate list fields
        list_fields = ["roles_add", "abilities_add", "tags_add"]
        for field in list_fields:
            if field in variant_data and not isinstance(variant_data[field], list):
                errors.append(f"{field} must be a list")

        return errors

    def create_social_role_variant(self, 
                                 culture: str, 
                                 role: str, 
                                 family_id: str, 
                                 name: str, 
                                 description: str,
                                 stat_modifiers: Optional[Dict[str, Dict[str, float]]] = None,
                                 abilities: Optional[List[str]] = None,
                                 roles: Optional[List[str]] = None) -> str:
        """
        Create a new social role variant with appropriate defaults.
        
        Returns:
            The generated variant ID
        """
        variant_id = f"{culture}_{role}"
        
        # Default stat modifiers by role
        default_stat_mods = {
            "guard": {"hp": {"add": 5}, "defense": {"add": 2}},
            "official": {"hp": {"add": 3}},
            "scholar": {"defense": {"add": 1}, "damage": {"add": 1}}
        }
        
        # Default abilities by role
        default_abilities = {
            "guard": ["resonant_shield"],
            "official": ["rally_shout"],
            "scholar": ["chorus_of_clarity"]
        }
        
        # Default combat roles by social role
        default_roles = {
            "guard": ["tank", "controller"],
            "official": ["support"],
            "scholar": ["controller", "support"]
        }
        
        variant_data = {
            "id": variant_id,
            "family_id": family_id,
            "name": name,
            "description": description,
            "stat_modifiers": stat_modifiers or default_stat_mods.get(role, {}),
            "roles_add": roles or default_roles.get(role, []),
            "abilities_add": abilities or default_abilities.get(role, []),
            "tags_add": [f"role:{role}"]
        }
        
        # Add duty tag for guards
        if role == "guard":
            variant_data["tags_add"].append("duty:watch")
        
        self.add_variant(variant_id, variant_data)
        return variant_id

```

### File: world_configurator\models\world_config.py

```python
"""
World configuration manager for the World Configurator Tool.
"""

import os
import logging
from typing import Dict, List, Any, Optional, Tuple

from models.base_models import WorldModelState
from models.world_data import CultureManager, WorldHistoryManager, WorldRulesManager, RaceManager, ClassManager, MagicSystemManager
from models.names_manager import NamesManager
from models.location_data import LocationManager
from models.location_defaults_manager import LocationDefaultsManager
from models.variants_manager import VariantsManager
from models.origin_data import OriginManager, QuestManager
from utils.file_manager import get_config_dir, get_project_root, get_world_config_dir, load_json, save_json

logger = logging.getLogger("world_configurator.models.world_config")

# Define expected filenames for each component relative to the main 'config' directory
COMPONENT_FILES = {
    "cultures": ("world/base", "cultures.json"),
    "races": ("character", "races.json"),
    "classes": ("character", "classes.json"),
    "locations": ("world/locations", "locations.json"), # Corrected path
    "history": ("world/base", "world_history.json"),
    "rules": ("world/base", "fundamental_rules.json"),
    "origins": ("world/scenarios", "origins.json"),
    "quests": ("world/scenarios", "quests.json"),
    "magic_systems": ("world/base", "magic_systems.json")
}

class WorldConfigManager:
    """Manages loading, saving, and accessing all world configuration components."""
    def __init__(self):
        self.state = WorldModelState()
        self.project_name: str = "Untitled Project"

        # Initialize managers
        self.culture_manager = CultureManager()
        self.race_manager = RaceManager()
        self.class_manager = ClassManager()
        self.location_manager = LocationManager()
        self.history_manager = WorldHistoryManager()
        self.rules_manager = WorldRulesManager()
        self.origin_manager = OriginManager()
        self.quest_manager = QuestManager()
        self.magic_system_manager = MagicSystemManager()
        
        # NEW Managers
        from .skill_manager import SkillManager # Local import
        self.skill_manager = SkillManager()
        
        # Names manager (npc/names.json)
        self.names_manager = NamesManager()
        
        # Location defaults (world/locations/defaults.json)
        self.location_defaults_manager = LocationDefaultsManager()
        
        # NPC Variants manager (npc/variants.json)
        self.variants_manager = VariantsManager()
        
        from .item_data_manager import ItemDataManager, MANAGED_ITEM_FILES as ITEM_FILE_KEYS_MAP # Local import
        self.item_data_manager = ItemDataManager()
        self.ITEM_FILE_KEYS_MAP = ITEM_FILE_KEYS_MAP # Store for convenience

        # Map component names to managers for easier iteration
        self.managers = {
            "cultures": self.culture_manager,
            "races": self.race_manager,
            "classes": self.class_manager,
            "skills": self.skill_manager, # NEW
            # Individual item categories will be handled by ItemDataManager
            "locations": self.location_manager,
            "history": self.history_manager,
            "rules": self.rules_manager,
            "origins": self.origin_manager,
            "quests": self.quest_manager,
            "magic_systems": self.magic_system_manager,
            "names": self.names_manager,
            "location_defaults": self.location_defaults_manager,
            "variants": self.variants_manager
        }
        # Add item file keys to managers for load/save/export logic continuity if needed,
        # or handle item_data_manager specially. For now, ItemDataManager handles its own files.

    def new_project(self, name: str):
        """Start a new, empty project."""
        self.project_name = name
        self.state = WorldModelState() # Reset state
        for manager in self.managers.values():
            manager.__init__() # Reinitialize each manager
        logger.info(f"Started new project: {name}")
    
    def load_project(self, project_dir: str) -> bool:
        """
        Load a project from a specified directory.
        Assumes each component is saved as a separate JSON file within the directory.
        """
        if not os.path.isdir(project_dir):
            logger.error(f"Project directory not found: {project_dir}")
            return False

        self.project_name = os.path.basename(project_dir)
        all_loaded = True
        loaded_components = []

        # Define expected filenames for each component relative to the project_dir
        # Note: item files are handled separately by ItemDataManager
        project_component_files = {
            "cultures": "cultures.json",
            "races": "races.json",
            "classes": "classes.json",
            "skills": "skills.json", # Assuming skills.json is at the root of project_dir
            "locations": "locations.json",
            "history": "world_history.json",
            "rules": "fundamental_rules.json",
            "origins": "origins.json",
            "quests": "quests.json",
            "magic_systems": "magic_systems.json",
            "names": "names.json",
            "location_defaults": "location_defaults.json",
            "variants": "variants.json"
        }

        for component, filename in project_component_files.items():
            file_path = os.path.join(project_dir, filename) # Files expected at root of project_dir
            manager = self.managers.get(component)
            if manager:
                if os.path.exists(file_path):
                    if manager.load_from_file(file_path):
                        loaded_components.append(component)
                    else:
                        logger.warning(f"Failed to load component '{component}' from {file_path}")
                else:
                    logger.debug(f"Component file not found in project, skipping: {file_path}")
                    manager.__init__() # Reset manager
            else:
                 logger.warning(f"No manager found for component '{component}'")
        
        # Load all item files via ItemDataManager, relative to project_dir
        # ItemDataManager's load_all_managed_files needs to accept project_dir
        # and construct full paths like project_dir/config/items/file.json
        # This implies the project structure should mirror the game's config structure
        # e.g. MyProject/config/items/origin_items.json
        self.item_data_manager.load_all_managed_files(project_dir=project_dir)
        # We can assume items are "loaded" if the manager tried, success is per-file.
        loaded_components.append("items (all categories)")


        self.state.path = project_dir
        self.state.modified = False 
        logger.info(f"Project '{self.project_name}' loaded from {project_dir}. Components loaded: {', '.join(loaded_components)}")
        return True
    
    def save_project(self, project_dir: Optional[str] = None) -> bool:
        """
        Save the current project to a directory.
        If project_dir is None, saves to the current project path.
        """
        target_dir = project_dir or self.state.path
        if not target_dir:
            logger.error("Cannot save project: No directory specified or loaded.")
            return False

        os.makedirs(target_dir, exist_ok=True)
        all_saved = True

        # Define expected filenames for each component relative to the target_dir
        project_component_files = {
            "cultures": "cultures.json",
            "races": "races.json",
            "classes": "classes.json",
            "skills": "skills.json",
            "locations": "locations.json",
            "history": "world_history.json",
            "rules": "fundamental_rules.json",
            "origins": "origins.json",
            "quests": "quests.json",
            "magic_systems": "magic_systems.json",
            "names": "names.json",
            "location_defaults": "location_defaults.json",
            "variants": "variants.json"
        }

        for component, filename in project_component_files.items():
            manager = self.managers.get(component)
            if manager:
                file_path = os.path.join(target_dir, filename)
                if not manager.save_to_file(file_path):
                    logger.error(f"Failed to save component '{component}' to {file_path}")
                    all_saved = False
            else:
                logger.warning(f"No manager found for component '{component}', cannot save.")
        
        # Save all item files via ItemDataManager
        # It needs to save to project_dir/config/items/filename.json
        if not self.item_data_manager.save_all_managed_files(project_dir=target_dir):
            logger.error(f"Failed to save one or more item files for project '{self.project_name}'")
            all_saved = False


        if all_saved:
            self.state.path = target_dir 
            self.state.modified = False 
            logger.info(f"Project '{self.project_name}' saved to {target_dir}")
        else:
            logger.error(f"Project '{self.project_name}' saved to {target_dir} with errors.")

        return all_saved
    
    def export_to_game(self, export_options: Dict[str, bool]) -> Tuple[bool, List[str]]:
        """
        Export selected components to the game's config directory.

        Args:
            export_options: A dictionary where keys are component names
                            and values are booleans indicating if they should be exported.
                            Item categories will have keys like "items_origin", "items_weapons", etc.
        Returns:
            A tuple (bool, List[str]) indicating overall success and a list of errors.
        """
        all_success = True
        errors = []
        exported_count = 0

        # Refresh ItemDataManager from disk so we export latest files saved by editors
        try:
            self.item_data_manager.load_all_managed_files(project_dir=get_project_root())
        except Exception:
            logger.warning("ItemDataManager reload before export failed; proceeding with existing in-memory data.")

        # Before exporting, ensure active editors have flushed changes to disk
        try:
            from ui.editors.item_editor_panel import ItemEditorPanel  # type: ignore
            # Attempt to find a live instance via MainWindow if available is out of scope here.
            # As a safety, re-load item files from disk just before export below.
        except Exception:
            pass

        # Standard components
        for component_key, should_export in export_options.items():
            if not should_export:
                continue

            # Handle item categories separately
            if component_key.startswith("items_"):
                item_file_key_to_export = component_key # e.g., "items_origin"
                if self.item_data_manager:
                    logger.debug(f"Attempting to export item category: {item_file_key_to_export}")
                    if self.item_data_manager.export_item_file_to_game(item_file_key_to_export):
                        logger.info(f"Successfully exported {item_file_key_to_export}")
                        exported_count +=1
                    else:
                        all_success = False
                        error_msg = f"Failed to export item category {item_file_key_to_export}."
                        errors.append(error_msg)
                        logger.error(error_msg)
                else:
                    error_msg = f"ItemDataManager not found, cannot export {item_file_key_to_export}."
                    errors.append(error_msg)
                    logger.warning(error_msg)
                continue # Move to next export option

            # Handle other standard managers
            manager = self.managers.get(component_key)
            if manager:
                logger.debug(f"Attempting to export component: {component_key}")
                if hasattr(manager, 'export_to_game') and callable(manager.export_to_game):
                    if manager.export_to_game():
                        logger.info(f"Successfully exported {component_key}")
                        exported_count += 1
                    else:
                        all_success = False
                        error_msg = f"Failed to export {component_key}."
                        errors.append(error_msg)
                        logger.error(error_msg)
                else:
                     logger.warning(f"Manager for '{component_key}' does not have a callable export_to_game method.")
            # If component_key is not for items and not in self.managers, it's an unknown option.
            # This case should ideally not happen if ExportDialog keys are consistent.
            elif not component_key.startswith("items_"):
                 error_msg = f"No manager found for component '{component_key}', cannot export."
                 errors.append(error_msg)
                 logger.warning(error_msg)


        if exported_count > 0 and all_success:
            logger.info(f"Successfully exported {exported_count} components/item files.")
        elif exported_count > 0:
            logger.warning(f"Export completed with errors. Successfully exported {exported_count} components/item files.")
        elif not errors: # No items selected for export
            logger.info("No components selected for export.")
            # This is not an error, so return True
        else: # No export count but errors exist (e.g. trying to export non-existent component)
             logger.error("Export failed. No components were exported successfully.")


        return all_success, errors
    
    def synchronize_with_game(self) -> bool:
        """Load all components directly from the game's config directory."""
        # game_config_dir is the root `config` directory of the game project.
        game_config_dir = get_config_dir()
        self.project_name = "Game Configuration" # Default name for this mode
        all_loaded = True
        loaded_components = []

        # This map defines how component keys map to subdirectories and filenames
        # *within the game's `config` directory*.
        game_files_structure = {
            "cultures": ("world/base", "cultures.json"),
            "races": ("character", "races.json"),
            "classes": ("character", "classes.json"),
            "skills": ("", "skills.json"), # skills.json is directly in config/
            "locations": ("world/locations", "locations.json"),
            "history": ("world/base", "world_history.json"),
            "rules": ("world/base", "fundamental_rules.json"),
            "origins": ("world/scenarios", "origins.json"),
            "quests": ("world/scenarios", "quests.json"),
            "magic_systems": ("world/base", "magic_systems.json"),
            "names": ("npc", "names.json"),
            "location_defaults": ("world/locations", "defaults.json"),
            "variants": ("npc", "variants.json")
            # Item files are handled by ItemDataManager below
        }

        for component, (subdir, filename) in game_files_structure.items():
            # Construct full path: game_config_dir / subdir / filename
            file_path = os.path.join(game_config_dir, subdir, filename) if subdir else os.path.join(game_config_dir, filename)
            
            manager = self.managers.get(component)
            if manager:
                if os.path.exists(file_path):
                    if manager.load_from_file(file_path):
                        loaded_components.append(component)
                    else:
                        logger.warning(f"Failed to sync component '{component}' from {file_path}")
                        all_loaded = False
                else:
                    logger.warning(f"Game config file not found for component '{component}', resetting: {file_path}")
                    manager.__init__() # Reset manager
            else:
                 logger.warning(f"No manager found for component '{component}' during sync.")

        # Synchronize all item files using ItemDataManager
        # ItemDataManager.load_all_managed_files() internally knows the "config/items/..." paths
        # relative to project root. For sync, project root IS the game's root.
        self.item_data_manager.load_all_managed_files(project_dir=get_project_root())
        # Assuming item data manager tries to load all its files, mark as "attempted"
        loaded_components.append("items (all categories)")


        self.state.path = None 
        self.state.modified = False 
        logger.info(f"Synchronized with game config. Components loaded/attempted: {', '.join(loaded_components)}")
        return all_loaded
    
    def is_modified(self) -> bool:
        """
        Check if any part of the world configuration has been modified.
        
        Returns:
            True if any manager has modified data, False otherwise.
        """
        if self.state.modified: return True # Project level modification (e.g. save as)

        for manager_name, manager_instance in self.managers.items():
            if hasattr(manager_instance, 'state') and manager_instance.state.modified:
                logger.debug(f"Modification detected in manager: {manager_name}")
                return True
        
        if hasattr(self, 'item_data_manager') and self.item_data_manager.is_any_file_modified():
            logger.debug("Modification detected in ItemDataManager.")
            return True
            
        return False
```

### File: world_configurator\models\world_data.py

```python
"""
World data models for cultures, history, and rules.
"""

import logging
import os
import shutil
import datetime
from typing import Dict, Optional

from models.base_models import CharacterClass, Culture, Race, WorldHistory, WorldRules, MagicalSystem, Spell, WorldModelState
from utils.file_manager import load_json, save_json, get_world_config_dir


logger = logging.getLogger("world_configurator.models.world_data")

class CultureManager:
    """
    Manager for culture data.
    """
    def __init__(self):
        self.cultures: Dict[str, Culture] = {}
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load cultures from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "cultures" not in data:
                logger.error(f"Invalid cultures file format: {file_path}")
                return False
            
            # Clear existing cultures
            self.cultures.clear()
            
            # Load each culture
            for culture_id, culture_data in data["cultures"].items():
                # Ensure the culture has an ID
                if "id" not in culture_data:
                    culture_data["id"] = culture_id
                
                culture = Culture.from_dict(culture_data)
                self.cultures[culture_id] = culture
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded {len(self.cultures)} cultures from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading cultures from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save cultures to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving cultures")
                return False
            
            # Prepare data
            data = {
                "cultures": {k: v.to_dict() for k, v in self.cultures.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Culture definitions for the RPG game world"
                }
            }
            
            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.cultures)} cultures to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving cultures: {e}")
            return False
    
    def add_culture(self, culture: Culture) -> None:
        """
        Add a culture to the manager.
        
        Args:
            culture: The culture to add.
        """
        self.cultures[culture.id] = culture
        self.state.modified = True
        logger.info(f"Added culture: {culture.name} ({culture.id})")
    
    def remove_culture(self, culture_id: str) -> bool:
        """
        Remove a culture from the manager.
        
        Args:
            culture_id: The ID of the culture to remove.
        
        Returns:
            True if the culture was removed, False if it wasn't found.
        """
        if culture_id in self.cultures:
            del self.cultures[culture_id]
            self.state.modified = True
            logger.info(f"Removed culture: {culture_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent culture: {culture_id}")
            return False
    
    def get_culture(self, culture_id: str) -> Optional[Culture]:
        """
        Get a culture by ID.
        
        Args:
            culture_id: The ID of the culture to get.
        
        Returns:
            The culture if found, None otherwise.
        """
        return self.cultures.get(culture_id)
    
    def export_to_game(self) -> bool:
        """
        Export cultures to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "cultures.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting cultures to game: {e}")
            return False

class WorldHistoryManager:
    """
    Manager for world history data.
    """
    def __init__(self):
        self.history: Optional[WorldHistory] = None
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load world history from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data:
                logger.error(f"Invalid world history file format: {file_path}")
                return False
            
            # Create history from data
            self.history = WorldHistory.from_dict(data)
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded world history from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading world history from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save world history to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Check if we have history data
            if not self.history:
                logger.error("No world history data to save")
                return False
            
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving world history")
                return False
            
            # Save to file
            result = save_json(self.history.to_dict(), path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved world history to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving world history: {e}")
            return False
    
    def create_new_history(self, name: str, description: str, current_year: int) -> None:
        """
        Create a new world history.
        
        Args:
            name: The name of the world.
            description: A description of the world.
            current_year: The current year in the world timeline.
        """
        self.history = WorldHistory.create_new(name, description, current_year)
        self.state.modified = True
        logger.info(f"Created new world history: {name}")
    
    def export_to_game(self) -> bool:
        """
        Export world history to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "world_history.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting world history to game: {e}")
            return False

class WorldRulesManager:
    """
    Manager for world rules data.
    """
    def __init__(self):
        self.rules: Optional[WorldRules] = None
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load world rules from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data:
                logger.error(f"Invalid world rules file format: {file_path}")
                return False
            
            # Create rules from data
            self.rules = WorldRules.from_dict(data)
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded world rules from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading world rules from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save world rules to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Check if we have rules data
            if not self.rules:
                logger.error("No world rules data to save")
                return False
            
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving world rules")
                return False
            
            # Save to file
            result = save_json(self.rules.to_dict(), path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved world rules to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving world rules: {e}")
            return False
    
    def create_new_rules(self, name: str, description: str) -> None:
        """
        Create new world rules.
        
        Args:
            name: The name of the rules set.
            description: A description of the rules.
        """
        self.rules = WorldRules.create_new(name, description)
        self.state.modified = True
        logger.info(f"Created new world rules: {name}")
    
    def export_to_game(self) -> bool:
        """
        Export world rules to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "fundamental_rules.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting world rules to game: {e}")
            return False

class MagicSystemManager:
    """
    Manager for magic system data.
    """
    def __init__(self):
        self.magic_systems: Dict[str, MagicalSystem] = {}
        self.state = WorldModelState()
    
    def load_from_file(self, file_path: str) -> bool:
        """
        Load magic systems from a JSON file.
        
        Args:
            file_path: Path to the JSON file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            data = load_json(file_path)
            if not data or "magic_systems" not in data:
                logger.error(f"Invalid magic systems file format: {file_path}")
                return False
            
            # Clear existing magic systems
            self.magic_systems.clear()
            
            # Load each magic system
            for system_id, system_data in data["magic_systems"].items():
                # Ensure the magic system has an ID
                if "id" not in system_data:
                    system_data["id"] = system_id
                
                magic_system = MagicalSystem.from_dict(system_data)
                self.magic_systems[system_id] = magic_system
            
            # Update state
            self.state.path = file_path
            self.state.modified = False
            
            logger.info(f"Loaded {len(self.magic_systems)} magic systems from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading magic systems from {file_path}: {e}")
            return False
    
    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """
        Save magic systems to a JSON file.
        
        Args:
            file_path: Path to the JSON file. If None, uses the path from state.
        
        Returns:
            True if saving was successful, False otherwise.
        """
        try:
            # Use provided path or the one from state
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving magic systems")
                return False
            
            # Prepare data
            data = {
                "magic_systems": {k: v.to_dict() for k, v in self.magic_systems.items()},
                "metadata": {
                    "version": "1.0.0",
                    "description": "Magic system definitions for the RPG game world"
                }
            }
            
            # Save to file
            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.magic_systems)} magic systems to {path}")
            
            return result
        except Exception as e:
            logger.error(f"Error saving magic systems: {e}")
            return False
    
    def add_magic_system(self, magic_system: MagicalSystem) -> None:
        """
        Add a magic system to the manager.
        
        Args:
            magic_system: The magic system to add.
        """
        self.magic_systems[magic_system.id] = magic_system
        self.state.modified = True
        logger.info(f"Added magic system: {magic_system.name} ({magic_system.id})")
    
    def remove_magic_system(self, system_id: str) -> bool:
        """
        Remove a magic system from the manager.
        
        Args:
            system_id: The ID of the magic system to remove.
        
        Returns:
            True if the magic system was removed, False if it wasn't found.
        """
        if system_id in self.magic_systems:
            del self.magic_systems[system_id]
            self.state.modified = True
            logger.info(f"Removed magic system: {system_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent magic system: {system_id}")
            return False
    
    def get_magic_system(self, system_id: str) -> Optional[MagicalSystem]:
        """
        Get a magic system by ID.
        
        Args:
            system_id: The ID of the magic system to get.
        
        Returns:
            The magic system if found, None otherwise.
        """
        return self.magic_systems.get(system_id)
    
    def add_spell_to_system(self, system_id: str, spell: Spell) -> bool:
        """
        Add a spell to a magic system.
        
        Args:
            system_id: The ID of the magic system to add the spell to.
            spell: The spell to add.
        
        Returns:
            True if the spell was added, False if the magic system wasn't found.
        """
        magic_system = self.get_magic_system(system_id)
        if not magic_system:
            logger.warning(f"Cannot add spell to non-existent magic system: {system_id}")
            return False
        
        magic_system.spells[spell.id] = spell
        self.state.modified = True
        logger.info(f"Added spell '{spell.name}' to magic system '{magic_system.name}'")
        return True
    
    def remove_spell_from_system(self, system_id: str, spell_id: str) -> bool:
        """
        Remove a spell from a magic system.
        
        Args:
            system_id: The ID of the magic system to remove the spell from.
            spell_id: The ID of the spell to remove.
        
        Returns:
            True if the spell was removed, False if the magic system or spell wasn't found.
        """
        magic_system = self.get_magic_system(system_id)
        if not magic_system:
            logger.warning(f"Cannot remove spell from non-existent magic system: {system_id}")
            return False
        
        if spell_id in magic_system.spells:
            del magic_system.spells[spell_id]
            self.state.modified = True
            logger.info(f"Removed spell '{spell_id}' from magic system '{magic_system.name}'")
            return True
        else:
            logger.warning(f"Cannot remove non-existent spell '{spell_id}' from magic system '{magic_system.name}'")
            return False
    
    def get_spell(self, system_id: str, spell_id: str) -> Optional[Spell]:
        """
        Get a spell from a magic system.
        
        Args:
            system_id: The ID of the magic system to get the spell from.
            spell_id: The ID of the spell to get.
        
        Returns:
            The spell if found, None otherwise.
        """
        magic_system = self.get_magic_system(system_id)
        if not magic_system:
            return None
        
        return magic_system.spells.get(spell_id)
    
    def export_to_game(self) -> bool:
        """
        Export magic systems to the game's configuration directory.
        
        Returns:
            True if export was successful, False otherwise.
        """
        try:
            # Define target path
            target_dir = os.path.join(get_world_config_dir(), "base")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "magic_systems.json")
            
            # Create backup folder if it doesn't exist
            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Create timestamped backup if target file exists
            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")
                    # Continue with export even if backup fails
            
            # Save to target path
            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting magic systems to game: {e}")
            return False

class RaceManager:
    """Manager for race data."""
    def __init__(self):
        self.races: Dict[str, Race] = {}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """Load races from a JSON file."""
        try:
            data = load_json(file_path)
            if not data or "races" not in data:
                logger.error(f"Invalid races file format: {file_path}")
                self.races.clear() # Clear even if load fails partially
                return False

            self.races.clear()
            for race_key, race_data in data["races"].items():
                if "id" not in race_data: race_data["id"] = race_key
                if "name" not in race_data:
                    race_data["name"] = race_key
                race = Race.from_dict(race_data)
                self.races[race_key] = race

            self.state.path = file_path
            self.state.modified = False
            logger.info(f"Loaded {len(self.races)} races from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading races from {file_path}: {e}")
            self.races.clear()
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """Save races to a JSON file using name as the key."""
        try:
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving races")
                return False

            # This dictionary comprehension now correctly uses the name as the key
            data_to_save = {k: v.to_dict() for k, v in self.races.items()}

            final_data = {"races": data_to_save}


            result = save_json(final_data, path) # Save the structure {"races": {...}}
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.races)} races to {path}")
            return result
        except Exception as e:
            logger.error(f"Error saving races: {e}")
            return False
        
    def add_race(self, race: Race) -> None:
        """Add a race to the manager."""
        self.races[race.name] = race
        self.state.modified = True
        logger.info(f"Added race: {race.name} ({race.id})")

    def remove_race(self, race_name: str) -> bool:
        """Remove a race from the manager."""
        if race_name in self.races:
            del self.races[race_name]
            self.state.modified = True
            logger.info(f"Removed race: {race_name}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent race: {race_name}")
            return False

    def get_race(self, race_name: str) -> Optional[Race]:
        """Get a race by ID."""
        return self.races.get(race_name)

    def export_to_game(self) -> bool:
        """Export races to the game's configuration directory."""
        try:
            target_dir = os.path.join(get_world_config_dir(), "..", "character")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "races.json")

            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")

            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting races to game: {e}")
            return False

class ClassManager:
    """Manager for character class data."""
    def __init__(self):
        self.classes: Dict[str, CharacterClass] = {}
        self.state = WorldModelState()

    def load_from_file(self, file_path: str) -> bool:
        """Load classes from a JSON file."""
        try:
            data = load_json(file_path)
            if not data or "classes" not in data:
                logger.error(f"Invalid classes file format: {file_path}")
                self.classes.clear()
                return False

            self.classes.clear()
            for class_id, class_data in data["classes"].items():
                if "id" not in class_data: class_data["id"] = class_id
                if "name" not in class_data:
                    class_data["name"] = class_id
                char_class = CharacterClass.from_dict(class_data)
                self.classes[char_class.id] = char_class # Use class.id as key

            self.state.path = file_path
            self.state.modified = False
            logger.info(f"Loaded {len(self.classes)} classes from {file_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading classes from {file_path}: {e}")
            self.classes.clear()
            return False

    def save_to_file(self, file_path: Optional[str] = None) -> bool:
        """Save classes to a JSON file."""
        try:
            path = file_path or self.state.path
            if not path:
                logger.error("No file path specified for saving classes")
                return False

            data = {
                "classes": {k: v.to_dict() for k, v in self.classes.items()},
                 # Optionally add metadata from JSON if needed
                # "display_colors": {...},
                # "details": {...}
            }

            result = save_json(data, path)
            if result:
                self.state.path = path
                self.state.modified = False
                logger.info(f"Saved {len(self.classes)} classes to {path}")
            return result
        except Exception as e:
            logger.error(f"Error saving classes: {e}")
            return False

    def add_class(self, char_class: CharacterClass) -> None:
        """Add a class to the manager."""
        self.classes[char_class.id] = char_class
        self.state.modified = True
        logger.info(f"Added class: {char_class.name} ({char_class.id})")

    def remove_class(self, class_id: str) -> bool:
        """Remove a class from the manager."""
        if class_id in self.classes:
            del self.classes[class_id]
            self.state.modified = True
            logger.info(f"Removed class: {class_id}")
            return True
        else:
            logger.warning(f"Cannot remove non-existent class: {class_id}")
            return False

    def get_class(self, class_id: str) -> Optional[CharacterClass]:
        """Get a class by ID."""
        return self.classes.get(class_id)

    def export_to_game(self) -> bool:
        """Export classes to the game's configuration directory."""
        try:
            target_dir = os.path.join(get_world_config_dir(), "..", "character")
            os.makedirs(target_dir, exist_ok=True)
            target_path = os.path.join(target_dir, "classes.json")

            backup_dir = os.path.join(target_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)

            if os.path.exists(target_path):
                filename = os.path.basename(target_path)
                name, ext = os.path.splitext(filename)
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_filename = f"{name}_{timestamp}{ext}"
                backup_path = os.path.join(backup_dir, backup_filename)
                try:
                    shutil.copy2(target_path, backup_path)
                    logger.info(f"Created backup of {target_path} at {backup_path}")
                except Exception as backup_err:
                    logger.error(f"Failed to create backup: {backup_err}")

            return self.save_to_file(target_path)
        except Exception as e:
            logger.error(f"Error exporting classes to game: {e}")
            return False

```

### File: core\interaction\context_builder.py

```python
from typing import Any, Dict, List, Optional, TYPE_CHECKING
from .enums import EnvironmentalTag, InteractionMode # Import the new enum and InteractionMode

# Placeholder for actual GameState type - replace with real import
if TYPE_CHECKING:
    from core.base.state.game_state import GameState # Corrected GameState import path
    # Add imports for other managers/states if needed, e.g.:
    # from core.player import PlayerState
    # from core.world import WorldState
    # from core.inventory import InventoryManager
    # from core.combat import CombatManager
    # from core.event import EventLog # Assu Katarzyna was ming an event log system

class ContextBuilder:
    """
    Gathers and structures relevant game state information to provide context
    for LLM agents based on the current interaction mode.
    """

    def build_context(self, game_state: 'GameState', mode: InteractionMode, actor_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Builds a context dictionary based on the game state and interaction mode.

        Args:
            game_state: The current state of the game.
            mode: The current interaction mode.
            actor_id: Optional ID of the entity whose perspective the context is for (e.g., player or NPC).

        Returns:
            A dictionary containing structured context information suitable for LLM consumption.
        """
        if not isinstance(mode, InteractionMode):
            raise TypeError(f"Expected InteractionMode, got {type(mode)}")

        common_context = self._get_common_context(game_state)
        mode_specific_context = {}

        if mode == InteractionMode.COMBAT:
            mode_specific_context = self._get_combat_context(game_state)
        elif mode == InteractionMode.SOCIAL_CONFLICT:
            # Assuming social conflict shares similarities with combat for participants
            mode_specific_context = self._get_social_conflict_context(game_state)
        elif mode == InteractionMode.TRADE:
            mode_specific_context = self._get_trade_context(game_state)
        elif mode == InteractionMode.NARRATIVE:
            mode_specific_context = self._get_narrative_context(game_state)
        else:
            # Fallback or error for unsupported modes
            print(f"Warning: Context building not fully implemented for mode: {mode.value}")
            # Or raise NotImplementedError("Context building not implemented for this mode")

        # --- Add Environmental Tags ---
        environment_tags = []
        world_state = getattr(game_state, 'world', None)
        if world_state:
            location = getattr(world_state, 'current_location', None)
            if location:
                # Assume location has an 'environmental_tags' attribute
                # containing EnvironmentalTag enums or strings
                raw_tags = getattr(location, 'environmental_tags', [])
                environment_tags = [tag.name if isinstance(tag, EnvironmentalTag) else str(tag) for tag in raw_tags]
        # --- End Environmental Tags ---


        # Merge common and mode-specific contexts
        # Mode-specific context can override common context keys if necessary
        full_context = {
            'mode': mode.value,
            **common_context,
            **mode_specific_context,
            'environment': environment_tags # Add the environmental tags
        }

        return full_context

    def _get_common_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context common to all interaction modes."""
        # --- Access game state components ---
        player_state = game_state.player
        world_state = game_state.world
        
        # For proper stat access, try to get the stats manager
        from core.stats.stats_manager import get_stats_manager
        stats_manager = get_stats_manager()
        # --- End access ---

        context = {}

        # Player Info
        if player_state:
            player_info = {
                'name': getattr(player_state, 'name', 'Player'),
                'id': getattr(player_state, 'id', getattr(player_state, 'stats_manager_id', 'player_id')),
                'stats': {}
            }
            
            # Try to get stats from stats manager
            try:
                player_info['stats'] = {
                    'hp': stats_manager.get_stat_value("HEALTH"),
                    'max_hp': stats_manager.get_stat_value("MAX_HEALTH"),
                    'resolve': stats_manager.get_stat_value("RESOLVE"),
                    'max_resolve': stats_manager.get_stat_value("MAX_RESOLVE"),
                    'strength': stats_manager.get_stat_value("STRENGTH"),
                    'dexterity': stats_manager.get_stat_value("DEXTERITY"),
                    'constitution': stats_manager.get_stat_value("CONSTITUTION"),
                    'intelligence': stats_manager.get_stat_value("INTELLIGENCE"),
                    'wisdom': stats_manager.get_stat_value("WISDOM"),
                    'charisma': stats_manager.get_stat_value("CHARISMA")
                }
            except Exception as e:
                # Fallback to direct attribute access if stats manager doesn't work
                player_info['stats'] = {
                    'hp': getattr(player_state, 'current_hp', None),
                    'max_hp': getattr(player_state, 'max_hp', None),
                    'resolve': getattr(player_state, 'current_resolve', 0.0),
                    'max_resolve': getattr(player_state, 'max_resolve', None)
                }
            
            # Get player status effects
            status_effects = []
            if hasattr(player_state, 'status_effects'):
                # Similar pattern to how we handled combat entities
                if isinstance(player_state.status_effects, dict):
                    status_effects = [{'name': k, 'duration': v} for k, v in player_state.status_effects.items()]
                elif hasattr(player_state, 'get_active_status_effects'):
                    status_effects = player_state.get_active_status_effects()
                elif isinstance(player_state.status_effects, (list, set)):
                    status_effects = list(player_state.status_effects)
            player_info['status_effects'] = status_effects
            
            context['player'] = player_info

        # Inventory Info (Relevant Items)
        inventory_manager = getattr(player_state, 'inventory_manager', None)
        if inventory_manager:
            equipped = getattr(inventory_manager, 'get_equipped_items', lambda: [])() # Placeholder
            quest_items = getattr(inventory_manager, 'get_quest_items', lambda: [])() # Placeholder
            context['inventory'] = {
                'equipped': [item.name for item in equipped], # Assuming items have a 'name' attribute
                'quest_items': [item.name for item in quest_items],
            }

        # World/Environment Info
        if world_state:
            location = getattr(world_state, 'current_location', None) # Placeholder
            if location:
                context['location'] = {
                    'name': getattr(location, 'name', 'Unknown Area'), # Placeholder
                    'description': getattr(location, 'description', ''), # Placeholder
                    'tags': getattr(location, 'tags', []), # Placeholder (e.g., ['forest', 'dark', 'ruins'])
                }
            # Use enhanced time description instead of clock time
            context['time_of_day'] = world_state.time_of_day if hasattr(world_state, 'time_of_day') else 'Unknown'

        # Recent Events
        event_log = getattr(world_state, 'event_log', None) # Placeholder
        if event_log:
            # Get the last N significant events (adjust N as needed)
            recent_events = getattr(event_log, 'get_recent_events', lambda limit: [])(limit=5) # Placeholder
            context['recent_events'] = [str(event) for event in recent_events] # Assuming events have __str__

        return context

    def _get_combat_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to combat mode."""
        # --- Access game state components directly ---
        combat_manager = game_state.combat_manager
        world_state = game_state.world
        # --- End Access ---

        context = {}

        if combat_manager:
            participants_data = []
            # Try to get combat entities directly from the combat manager
            entities = getattr(combat_manager, 'entities', {})
            
            # Current entity info
            current_entity_id = getattr(combat_manager, 'get_current_entity_id', lambda: None)()
            current_entity = entities.get(current_entity_id) if current_entity_id else None
            
            # Find player entity
            player_entity = None
            player_id = None
            for entity_id, entity in entities.items():
                if hasattr(entity, 'entity_type') and hasattr(entity.entity_type, 'name') and entity.entity_type.name == 'PLAYER':
                    player_entity = entity
                    player_id = entity_id
                    break
            
            # Add entities as participants
            for entity_id, entity in entities.items():
                if not hasattr(entity, 'name'): 
                    continue  # Skip entities with missing data
                
                # Get status effects formatted safely
                status_effects = []
                if hasattr(entity, 'status_effects'):
                    if isinstance(entity.status_effects, dict):
                        # New method using dict of status effects
                        status_effects = [{'name': effect_name, 'duration': duration} 
                                        for effect_name, duration in entity.status_effects.items()]
                    elif isinstance(entity.status_effects, (list, set)):
                        # Old method using list/set of effect names
                        status_effects = [{'name': effect} for effect in entity.status_effects]
                
                # Format entity data
                entity_data = {
                    'id': entity_id,
                    'name': entity.name,
                    'hp': getattr(entity, 'current_hp', 0),
                    'max_hp': getattr(entity, 'max_hp', 0),
                    'mp': getattr(entity, 'current_mp', 0) if hasattr(entity, 'current_mp') else 0,
                    'max_mp': getattr(entity, 'max_mp', 0) if hasattr(entity, 'max_mp') else 0,
                    'status_effects': status_effects,
                    'entity_type': getattr(entity.entity_type, 'name', 'UNKNOWN') if hasattr(entity, 'entity_type') else 'UNKNOWN'
                }
                
                # Include combat stats if available
                if hasattr(entity, 'stats') and isinstance(entity.stats, dict):
                    # Extract key combat stats
                    combat_stats = {
                        'strength': entity.stats.get('strength', 0),
                        'dexterity': entity.stats.get('dexterity', 0),
                        'constitution': entity.stats.get('constitution', 0),
                        'intelligence': entity.stats.get('intelligence', 0), 
                        'wisdom': entity.stats.get('wisdom', 0),
                        'charisma': entity.stats.get('charisma', 0),
                        'attack': entity.stats.get('attack', 0),
                        'defense': entity.stats.get('defense', 0),
                        'initiative': entity.stats.get('initiative', 0),
                    }
                    entity_data['stats'] = combat_stats
                
                participants_data.append(entity_data)
                
            # Store participants
            context['participants'] = participants_data
            
            # Build combat-specific context
            combat_context = {
                'turn_order': combat_manager.turn_order,
                'current_turn': current_entity_id,
                'round': combat_manager.round_number,
                'current_entity': None,
                'player': None
            }
            
            # Add current entity info
            if current_entity:
                combat_context['current_entity'] = {
                    'id': current_entity_id,
                    'name': current_entity.name,
                    'hp': getattr(current_entity, 'current_hp', 0),
                    'max_hp': getattr(current_entity, 'max_hp', 0)
                }
                
            # Add player entity info
            if player_entity:
                combat_context['player'] = {
                    'id': player_id,
                    'name': player_entity.name,
                    'hp': getattr(player_entity, 'current_hp', 0),
                    'max_hp': getattr(player_entity, 'max_hp', 0)
                }
                
            context['combat_context'] = combat_context

        # Environment details relevant to combat
        if world_state:
            location = getattr(world_state, 'current_location', None)
            if location:
                 # Example: Filter tags or get specific combat-relevant properties
                interactables = getattr(location, 'get_interactables', lambda: [])() # Placeholder
                context['environment_interactables'] = [str(i) for i in interactables] # Placeholder

        return context

    def _get_social_conflict_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to social conflict mode."""
        context = {}
        participants_data = []
        # Access current_combatants directly from game_state
        # Need to fetch actual participant objects based on IDs
        participant_ids = game_state.current_combatants
        world = game_state.world # Assume world has a way to get characters by ID
        participants = [getattr(world, 'get_character', lambda char_id: None)(pid) for pid in participant_ids]
        participants = [p for p in participants if p is not None] # Filter out not found participants

        # Define key social elements to fetch
        social_stats_keys = ['Charisma', 'Willpower', 'Insight']
        social_skills_keys = ['Persuasion', 'Intimidation', 'Deception', 'Insight'] # Assuming Insight skill exists too

        for p in participants:
            # Access stats manager, assuming it exists on participant objects
            stats_manager = getattr(p, 'stats_manager', None)

            social_stats = {}
            social_skills = {}
            if stats_manager:
                for stat in social_stats_keys:
                    social_stats[stat] = getattr(stats_manager, 'get_stat_value', lambda k, d=None: d)(stat, None)
                for skill in social_skills_keys:
                    social_skills[skill] = getattr(stats_manager, 'get_skill_value', lambda k, d=None: d)(skill, None)

            # Get active *social* effects specifically
            active_effects = getattr(p, 'active_social_effects', [])
            # Ensure effects are serializable (e.g., get their names or dict representation)
            serializable_effects = []
            for effect in active_effects:
                if hasattr(effect, 'to_dict'):
                    serializable_effects.append(effect.to_dict())
                elif hasattr(effect, 'name'):
                     serializable_effects.append(effect.name)
                else:
                     serializable_effects.append(str(effect))


            participants_data.append({
                'id': getattr(p, 'id', 'unknown_id'),
                'name': getattr(p, 'name', 'Unknown Participant'),
                'resolve': getattr(p, 'current_resolve', None),
                'max_resolve': getattr(p, 'max_resolve', None),
                'social_stats': social_stats,
                'social_skills': social_skills,
                'active_social_effects': serializable_effects,
                # 'disposition': getattr(p, 'disposition_towards_player', 'neutral'), # Optional/Future
            })

        context['participants'] = participants_data

        # Recent social events might be implicitly covered by 'recent_events' in common context
        # If more specific social event tracking exists, add it here.

        return context

    def _get_trade_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to trade mode."""
        context = {}
        # Assume inventory manager is part of player state or accessible differently
        player = game_state.player
        inventory_manager = getattr(player, 'inventory_manager', None) # Example: Access via player
        world = game_state.world
        partner_id = game_state.current_trade_partner_id

        if not inventory_manager or not world or not player:
            # Log warning or handle missing components
            return context # Cannot build full trade context

        # --- Player Trade Info ---
        player_currency = 0
        player_trade_items = []
        if player and hasattr(player, 'id'): # Check if player object and id exist
            player_currency = getattr(inventory_manager, 'get_currency', lambda owner_id: 0)(player.id)
            player_inv = getattr(inventory_manager, 'get_inventory', lambda owner_id: [])(player.id)
            player_trade_items = [
                {'name': item.name, 'value': getattr(item, 'base_value', 0), 'id': getattr(item, 'id', None)} # Assuming items have name, base_value, id
                for item in player_inv if getattr(item, 'can_be_traded', True) # Filter for tradable items
            ]

        context['player_trade_info'] = {
            'currency': player_currency,
            'inventory': player_trade_items
        }

        # --- Trade Partner Info ---
        if partner_id:
            partner = getattr(world, 'get_character', lambda char_id: None)(partner_id) # Fetch partner object
            if partner:
                partner_currency = getattr(inventory_manager, 'get_currency', lambda owner_id: 0)(partner.id) # Get partner currency
                partner_inv = getattr(inventory_manager, 'get_inventory', lambda owner_id: [])(partner.id) # Get partner inventory
                partner_trade_items = [
                    {'name': item.name, 'value': getattr(item, 'base_value', 0), 'id': getattr(item, 'id', None)}
                    for item in partner_inv if getattr(item, 'can_be_traded', True)
                ]

                context['trade_partner'] = {
                    'id': partner_id,
                    'name': getattr(partner, 'name', 'Unknown Merchant'),
                    'currency': partner_currency, # Include partner currency
                    'inventory': partner_trade_items,
                    # Add disposition or other relevant partner info if available
                    # 'disposition': getattr(partner, 'disposition_towards_player', 'neutral'),
                }
            else:
                # Log warning: Partner ID set but character not found
                context['trade_partner'] = {'id': partner_id, 'error': 'Character not found'}
        else:
             context['trade_partner'] = None # No active trade partner

        return context

    def _get_narrative_context(self, game_state: 'GameState') -> Dict[str, Any]:
        """Gathers context specific to narrative mode."""
        # --- Access game state components directly ---
        # Assuming quest_manager and dialogue_manager are part of world or player state
        world_state = game_state.world
        player_state = game_state.player
        quest_manager = getattr(player_state, 'quest_manager', None) # Example access via player
        dialogue_manager = getattr(world_state, 'dialogue_manager', None) # Example access via world
        # --- End Access ---

        context = {}

        # Active Quests
        if quest_manager:
            active_quests = getattr(quest_manager, 'get_active_quests', lambda: [])() # Placeholder
            context['active_quests'] = [
                {'name': q.name, 'objective': getattr(q, 'current_objective', '')} # Assuming quests have name/objective
                for q in active_quests
            ]

        # Recent Dialogue
        if dialogue_manager:
            recent_lines = getattr(dialogue_manager, 'get_recent_dialogue', lambda limit: [])(limit=5) # Placeholder
            context['recent_dialogue'] = [str(line) for line in recent_lines] # Assuming lines have __str__

        # Known NPCs/Locations nearby (if available)
        if world_state:
            location = getattr(world_state, 'current_location', None)
            if location:
                nearby_npcs = getattr(location, 'get_nearby_npcs', lambda: [])() # Placeholder
                nearby_locations = getattr(location, 'get_nearby_locations', lambda: [])() # Placeholder
                context['nearby_npcs'] = [npc.name for npc in nearby_npcs] # Assuming NPCs have name
                context['nearby_locations'] = [loc.name for loc in nearby_locations] # Assuming locations have name

        return context

# Example Usage (Conceptual - requires actual GameState and managers)
if __name__ == '__main__':
    # This is conceptual and won't run without actual game state implementation
    class MockGameState:
        # Add mock attributes/methods matching placeholders used above
        player = type('obj', (object,), {'name': 'MockPlayer', 'current_hp': 90, 'max_hp': 100, 'current_resolve': 50, 'max_resolve': 50, 'get_active_status_effects': lambda: ['focused']})()
        inventory_manager = type('obj', (object,), {
            'get_equipped_items': lambda: [type('obj', (object,), {'name': 'Iron Sword'})()],
            'get_quest_items': lambda: [type('obj', (object,), {'name': 'Mystic Key'})()],
            'get_currency': lambda: 150
        })()
        world = type('obj', (object,), {
            'current_location': type('obj', (object,), {'name': 'Whispering Woods', 'description': 'Ancient trees loom overhead.', 'tags': ['forest', 'overgrown'], 'get_interactables': lambda: ['old_shrine', 'fallen_log']})(),
            'time_of_day': 'afternoon'
        })()
        event_log = type('obj', (object,), {'get_recent_events': lambda limit: ['Player entered Whispering Woods.', 'A twig snapped nearby.']})()
        combat_manager = type('obj', (object,), {
            'get_participants': lambda: [
                type('obj', (object,), {'id': 'wolf_1', 'name': 'Dire Wolf', 'current_hp': 40, 'max_hp': 40, 'get_active_status_effects': lambda: [], 'position': 'close', 'is_player': False})(),
                type('obj', (object,), {'id': 'wolf_2', 'name': 'Alpha Wolf', 'current_hp': 60, 'max_hp': 60, 'get_active_status_effects': lambda: ['enraged'], 'position': 'medium', 'is_player': False})()
            ]
        })()
        # Add mock managers for other modes as needed

    mock_game_state = MockGameState()
    builder = ContextBuilder()

    print("--- Combat Context ---")
    combat_context = builder.build_context(mock_game_state, InteractionMode.COMBAT)
    import json
    print(json.dumps(combat_context, indent=2))

    print("\n--- Narrative Context (Minimal Mock) ---")
    narrative_context = builder.build_context(mock_game_state, InteractionMode.NARRATIVE)
    print(json.dumps(narrative_context, indent=2))

    # Add calls for other modes (TRADE, SOCIAL_CONFLICT) if mocks are implemented
```

### File: core\interaction\enums.py

```python
from enum import Enum, auto

class InteractionMode(Enum):
    """
    Represents the different modes of interaction the player can be in.
    """
    NARRATIVE = auto()        # Default mode, story progression, exploration
    COMBAT = auto()           # Turn-based or real-time combat encounters
    SOCIAL_CONFLICT = auto()  # Debates, negotiations, persuasion challenges
    TRADE = auto()            # Exchanging goods or services with NPCs


class EnvironmentalTag(Enum):
    """
    Represents descriptive tags for environmental features in a scene.
    """
    LOW_COVER = auto()
    HIGH_COVER = auto()
    FLAMMABLE_OBJECT = auto()
    UNSTABLE_GROUND = auto()
    THROWABLE_OBJECT = auto()
    DARK = auto()
    BRIGHT_LIGHT = auto()
    OBSTACLE_SMALL = auto()
    OBSTACLE_LARGE = auto()
    INTERACTIVE_LEVER = auto() # Added an example interactive object
    WATER_SOURCE = auto()
    DIFFICULT_TERRAIN = auto()

```

### File: core\interaction\social_effects.py

```python
"""
Defines status effects specific to social interactions.
"""

from enum import Enum, auto
from dataclasses import dataclass
from typing import Any, Dict, Optional

@dataclass
class StatusEffectData:
    """Holds data for an active status effect."""
    effect_type: Enum  # Could be SocialStatusEffect or CombatStatusEffect etc.
    duration: Optional[int] = None  # Turns or time units, None for permanent
    intensity: Optional[float] = None # Magnitude of the effect (e.g., penalty amount)
    source: Optional[str] = None # Origin of the effect (e.g., ability name, character ID)

    def __str__(self) -> str:
        details = []
        if self.duration is not None:
            details.append(f"duration={self.duration}")
        if self.intensity is not None:
            details.append(f"intensity={self.intensity}")
        if self.source:
            details.append(f"source='{self.source}'")
        details_str = f" ({', '.join(details)})" if details else ""
        return f"{self.effect_type.name}{details_str}"

    def to_dict(self) -> Dict[str, Any]:
        """Convert StatusEffectData to a dictionary for serialization."""
        return {
            "effect_type_name": self.effect_type.name, # Store enum name
            "duration": self.duration,
            "intensity": self.intensity,
            "source": self.source,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StatusEffectData':
        """Create a StatusEffectData from a dictionary."""
        effect_type_name = data.get("effect_type_name")
        effect_type = None
        if effect_type_name:
            try:
                # Assuming SocialStatusEffect for now, might need adjustment if other types exist
                effect_type = SocialStatusEffect[effect_type_name]
            except KeyError:
                # Handle cases where the effect type name is invalid or from a different enum
                print(f"Warning: Unknown status effect type '{effect_type_name}' found in data.") # Or use logger

        return cls(
            effect_type=effect_type, # Store the actual enum member or None
            duration=data.get("duration"),
            intensity=data.get("intensity"),
            source=data.get("source"),
        )


class SocialStatusEffect(Enum):
    """Status effects resulting from social interactions."""
    # Positive/Neutral
    CHARMED = auto()        # Highly positive disposition, susceptible to requests.
    CONVINCED = auto()      # Believes a specific argument or piece of information.
    TRUSTING = auto()       # Generally believes what the source says.
    FRIENDLY = auto()       # Positive disposition towards the source.

    # Negative
    INTIMIDATED = auto()    # Fearful, less likely to oppose, may comply reluctantly.
    ANGERED = auto()        # Hostile disposition, likely to refuse or argue.
    SUSPICIOUS = auto()     # Distrustful, likely to question motives or statements.
    UNFRIENDLY = auto()     # Negative disposition towards the source.
    DECEIVED = auto()       # Believes a falsehood presented by the source.

    # Could add more nuanced effects like:
    # INSPIRED, DEMORALIZED, CONFUSED, OBLIGATED, GRATEFUL, RESENTFUL

    def __str__(self) -> str:
        return self.name
```

### File: core\interaction\structured_requests.py

```python
"""
Defines the standardized structures for requests generated by LLM agents.

These structures are intended to be parsed by the core game loop and validated
by the RuleCheckerAgent before being executed.
"""

from typing import TypedDict, Optional, Union, List, Dict, Any

# --- Skill Check Request ---

class SkillCheckRequest(TypedDict):
    """
    Represents a request for a skill check to be performed.
    """
    action: str  # Always 'request_skill_check'
    actor_id: str # ID of the entity performing the check (e.g., 'player')
    skill_name: str # The specific skill being used (e.g., 'lockpicking', 'persuasion')
    stat_name: Optional[str] # Optional: Base stat if different from skill's default (e.g., using Strength for an Athletics check)
    target_actor_id: Optional[str] # Optional: ID of the entity being targeted by the skill check
    difficulty_class: Optional[int] # Optional: A specific DC set by the narrative/situation
    # Optional: Modifiers specific to this check instance (e.g., situational bonuses/penalties)
    # Example: {'advantage': 1, 'circumstance_bonus': 2, 'penalty_reason': "Distracted"}
    modifiers: Optional[Dict[str, Any]]
    # Optional: Contextual information about why the check is being made
    context: Optional[str]


# --- State Change Request ---

class StateChangeRequest(TypedDict):
    """
    Represents a request to modify the game state programmatically.
    """
    action: str # Always 'request_state_change'
    target_id: str # ID of the entity or object whose state is changing (e.g., 'player', 'goblin_1', 'door_A')
    attribute: str # The specific attribute to change (e.g., 'hp', 'status_effects', 'position', 'inventory', 'relationship_stance')
    change_type: str # How to apply the change ('set', 'add', 'remove', 'append', 'update_dict')
    value: Any # The value to set, add, remove, etc.
    # Optional: Duration for temporary effects (e.g., in turns or seconds, depending on context)
    duration: Optional[int]
    # Optional: Contextual information about why the state change is occurring
    context: Optional[str]


# --- Agent Output Structure ---
# An agent's response might contain narrative and potentially multiple requests.

class AgentOutput(TypedDict):
    """
    Standard output structure for LLM agents.
    """
    narrative: str # The descriptive text generated by the agent.
    requests: List[Union[SkillCheckRequest, StateChangeRequest]] # List of structured requests. Can be empty.
```

### File: core\__init__.py

```python
"""
Core package for the RPG game.

This package contains the core functionality of the game,
including base classes, utilities, and game logic.
"""

__version__ = "0.1.0"
```

### File: core\inventory\__init__.py

```python
"""
Inventory system package.

This package provides classes and utilities for managing
items, equipment, and currency in the game.
"""

# Import the enums first since they have no dependencies
from core.inventory.item_enums import ItemType, ItemRarity, EquipmentSlot

# Import the base classes next
from core.inventory.item_stat import ItemStat
from core.inventory.item import Item
from core.inventory.item_effect import DiceRollEffect

# Import serialization utilities
from core.inventory.item_serialization import item_to_dict, dict_to_item

# Import inventory base components
from core.inventory.inventory_base import InventoryBase
from core.inventory.inventory_item_operations import InventoryItemOperations
from core.inventory.inventory_limits import InventoryLimits
from core.inventory.equipment_manager import EquipmentManager
from core.inventory.currency_manager import CurrencyManager

# Import item modifiers and generators
from core.inventory.item_stat_modifier import ItemStatModifier
from core.inventory.item_variation_generator import ItemVariationGenerator

# Import higher-level managers and their getters
from core.inventory.item_template_loader import ItemTemplateLoader, get_item_template_loader
from core.inventory.item_factory import ItemFactory, get_item_factory
from core.inventory.inventory_manager import InventoryManager # Import the class for type hinting

# Re-export get_inventory_manager from item_manager.py to ensure a single source for the singleton
from core.inventory.item_manager import get_inventory_manager

# Import narrative item management
from core.inventory.narrative_item_manager import NarrativeItemManager 

# Global instance for NarrativeItemManager - make it a singleton too for consistency
_narrative_item_manager_singleton = None

def get_narrative_item_manager() -> NarrativeItemManager:
    """Get or create a narrative item manager instance."""
    global _narrative_item_manager_singleton
    if _narrative_item_manager_singleton is None:
        _narrative_item_manager_singleton = NarrativeItemManager()
    return _narrative_item_manager_singleton

# Import inventory commands - must be after all getters to avoid circular imports
from core.inventory.inventory_commands import register_inventory_commands
```

### File: core\inventory\currency_manager.py

```python
#!/usr/bin/env python3
"""
Currency management module.

This module provides functionality for managing in-game currency.
"""

from typing import Dict, Optional, Tuple
import logging

from core.utils.logging_config import get_logger

# Get module logger
logger = get_logger("Inventory")


class CurrencyManager:
    """
    Manager for in-game currency.
    
    This class handles operations related to currency, including
    conversions and transactions.
    """
    
    def __init__(self):
        """Initialize the currency manager."""
        # Initialize currency values
        self._copper: int = 0
        
        # Currency conversion rates
        self._copper_per_silver: int = 100
        self._silver_per_gold: int = 100
        
        logger.info("Currency manager initialized")
    
    @property
    def copper(self) -> int:
        """Get the total currency value in copper."""
        return self._copper
    
    @property
    def silver(self) -> int:
        """Get the silver component of the currency."""
        return (self._copper // self._copper_per_silver) % self._silver_per_gold
    
    @property
    def gold(self) -> int:
        """Get the gold component of the currency."""
        return self._copper // (self._copper_per_silver * self._silver_per_gold)
    
    def get_formatted_currency(self) -> str:
        """
        Get a formatted string representation of the currency.
        
        Returns:
            String in the format "X gold, Y silver, Z copper".
        """
        result = []
        
        gold_value = self.gold
        silver_value = self.silver
        copper_value = self._copper % self._copper_per_silver
        
        if gold_value > 0:
            result.append(f"{gold_value} gold")
        
        if silver_value > 0 or (gold_value > 0 and copper_value > 0):
            result.append(f"{silver_value} silver")
        
        if copper_value > 0 or not result:
            result.append(f"{copper_value} copper")
        
        return ", ".join(result)
    
    def get_currency_dict(self) -> Dict[str, int]:
        """
        Get the currency values as a dictionary.
        
        Returns:
            Dictionary with gold, silver, and copper values.
        """
        return {
            "gold": self.gold,
            "silver": self.silver,
            "copper": self._copper % self._copper_per_silver,
            "total_copper": self._copper
        }
    
    def add_currency(self, amount: int) -> bool:
        """
        Add currency (in copper).
        
        Args:
            amount: The amount to add in copper.
            
        Returns:
            True if the currency was added successfully.
        """
        if amount <= 0:
            logger.warning(f"Cannot add non-positive currency amount: {amount}")
            return False
        
        self._copper += amount
        logger.info(f"Added {amount} copper to currency")
        return True
    
    def remove_currency(self, amount: int) -> bool:
        """
        Remove currency (in copper).
        
        Args:
            amount: The amount to remove in copper.
            
        Returns:
            True if the currency was removed successfully, False if insufficient funds.
        """
        if amount <= 0:
            logger.warning(f"Cannot remove non-positive currency amount: {amount}")
            return False
        
        if amount > self._copper:
            logger.warning(f"Insufficient funds: {self._copper} copper available, {amount} copper required")
            return False
        
        self._copper -= amount
        logger.info(f"Removed {amount} copper from currency")
        return True
    
    def add_mixed_currency(self, gold: int = 0, silver: int = 0, copper: int = 0) -> bool:
        """
        Add currency using mixed denominations.
        
        Args:
            gold: Amount of gold to add.
            silver: Amount of silver to add.
            copper: Amount of copper to add.
            
        Returns:
            True if the currency was added successfully.
        """
        if gold < 0 or silver < 0 or copper < 0:
            logger.warning(f"Cannot add negative currency amounts: {gold}g, {silver}s, {copper}c")
            return False
        
        if gold == 0 and silver == 0 and copper == 0:
            return True
        
        total_copper = (gold * self._copper_per_silver * self._silver_per_gold) + \
                       (silver * self._copper_per_silver) + \
                       copper
        
        return self.add_currency(total_copper)
    
    def remove_mixed_currency(self, gold: int = 0, silver: int = 0, copper: int = 0) -> bool:
        """
        Remove currency using mixed denominations.
        
        Args:
            gold: Amount of gold to remove.
            silver: Amount of silver to remove.
            copper: Amount of copper to remove.
            
        Returns:
            True if the currency was removed successfully, False if insufficient funds.
        """
        if gold < 0 or silver < 0 or copper < 0:
            logger.warning(f"Cannot remove negative currency amounts: {gold}g, {silver}s, {copper}c")
            return False
        
        if gold == 0 and silver == 0 and copper == 0:
            return True
        
        total_copper = (gold * self._copper_per_silver * self._silver_per_gold) + \
                       (silver * self._copper_per_silver) + \
                       copper
        
        return self.remove_currency(total_copper)
    
    def has_enough_currency(self, amount: int) -> bool:
        """
        Check if there is enough currency available.
        
        Args:
            amount: The amount to check in copper.
            
        Returns:
            True if there is enough currency, False otherwise.
        """
        return self._copper >= amount
    
    def has_enough_mixed_currency(self, gold: int = 0, silver: int = 0, copper: int = 0) -> bool:
        """
        Check if there is enough currency available using mixed denominations.
        
        Args:
            gold: Amount of gold to check.
            silver: Amount of silver to check.
            copper: Amount of copper to check.
            
        Returns:
            True if there is enough currency, False otherwise.
        """
        total_copper = (gold * self._copper_per_silver * self._silver_per_gold) + \
                       (silver * self._copper_per_silver) + \
                       copper
        
        return self.has_enough_currency(total_copper)
    
    def set_currency(self, amount: int) -> None:
        """
        Set the total currency to a specific amount (in copper).
        
        Args:
            amount: The amount to set in copper.
        """
        if amount < 0:
            logger.warning(f"Cannot set currency to negative value: {amount}")
            self._copper = 0
        else:
            self._copper = amount
            logger.info(f"Set currency to {amount} copper")
    
    def set_mixed_currency(self, gold: int = 0, silver: int = 0, copper: int = 0) -> None:
        """
        Set the currency using mixed denominations.
        
        Args:
            gold: Amount of gold to set.
            silver: Amount of silver to set.
            copper: Amount of copper to set.
        """
        if gold < 0 or silver < 0 or copper < 0:
            logger.warning(f"Cannot set negative currency amounts: {gold}g, {silver}s, {copper}c")
            self._copper = 0
            return
        
        total_copper = (gold * self._copper_per_silver * self._silver_per_gold) + \
                       (silver * self._copper_per_silver) + \
                       copper
        
        self.set_currency(total_copper)

```

### File: core\inventory\equipment_manager.py

```python
#!/usr/bin/env python3
"""
Equipment management module.

This module extends the inventory system with methods to manage
equipped items and equipment slots.
"""

from typing import Dict, List, Optional, Any, Set, Union
import logging

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_enums import EquipmentSlot
from core.inventory.inventory_base import InventoryBase

# Get module logger
logger = get_logger("Inventory")


class EquipmentManager(InventoryBase):
    """
    Equipment manager for handling equipped items.
    
    This class extends the base inventory with methods for equipping,
    unequipping, and managing equipped items.
    """
    
    def __init__(self):
        """Initialize the equipment manager."""
        super().__init__()
        
        # Equipment slots
        self._equipment: Dict[EquipmentSlot, Optional[str]] = {
            slot: None for slot in EquipmentSlot
        }
        
        # Set of equipment effects/modifiers
        self._equipment_modifiers: Dict[str, Dict[str, Any]] = {}
        
        logger.info("Equipment manager initialized")
    
    @property
    def equipment(self) -> Dict[EquipmentSlot, Optional[Item]]:
        """
        Get the currently equipped items.
        
        Returns:
            Dictionary mapping slots to equipped items (or None if empty).
        """
        result = {}
        for slot, item_id_or_obj in self._equipment.items(): # Iterate over raw _equipment dict
            if isinstance(item_id_or_obj, str): # If it's an ID (older save format compatibility)
                item_obj = self._items.get(item_id_or_obj)
                if item_obj:
                    result[slot] = item_obj
                else:
                    result[slot] = None
                    if item_id_or_obj: # Log if an ID was there but item is missing
                         logger.warning(f"Equipment slot {slot.value} had ID '{item_id_or_obj}' but item not found in _items.")
            elif isinstance(item_id_or_obj, Item): # If it's already an Item object
                result[slot] = item_id_or_obj
            else: # It's None or unexpected type
                result[slot] = None
                
        return result
    
    def get_equipped_item(self, slot: Union[EquipmentSlot, str]) -> Optional[Item]:
        """
        Get the item equipped in a specific slot.
        
        Args:
            slot: The equipment slot to check.
            
        Returns:
            The equipped Item, or None if the slot is empty.
        """
        # Convert string to enum if needed
        if isinstance(slot, str):
            try:
                slot = EquipmentSlot(slot)
            except ValueError:
                logger.error(f"Invalid equipment slot: {slot}")
                return None
                
        item_id = self._equipment.get(slot)
        if item_id:
            return self._items.get(item_id)
            
        return None
    
    def is_slot_empty(self, slot: Union[EquipmentSlot, str]) -> bool:
        """
        Check if an equipment slot is empty.
        
        Args:
            slot: The equipment slot to check.
            
        Returns:
            True if the slot is empty, False otherwise.
        """
        # Convert string to enum if needed
        if isinstance(slot, str):
            try:
                slot = EquipmentSlot(slot)
            except ValueError:
                logger.error(f"Invalid equipment slot: {slot}")
                return True
                
        return self._equipment.get(slot) is None
    
    def can_equip(self, item_id: str) -> bool:
        """
        Check if an item can be equipped.
        
        Args:
            item_id: The ID of the item to check.
            
        Returns:
            True if the item can be equipped, False otherwise.
        """
        item = self.get_item(item_id)
        if not item:
            logger.warning(f"Cannot equip: Item {item_id} not found")
            return False
            
        if not item.is_equippable:
            logger.warning(f"Cannot equip: Item {item_id} is not equippable")
            return False
            
        if not item.equip_slots:
            logger.warning(f"Cannot equip: Item {item_id} has no valid equipment slots")
            return False
            
        # Check if any of the item's slots are available
        for slot in item.equip_slots:
            # Special handling for two-handed weapons
            if slot == EquipmentSlot.TWO_HAND:
                if (self.is_slot_empty(EquipmentSlot.MAIN_HAND) and 
                    self.is_slot_empty(EquipmentSlot.OFF_HAND)):
                    return True
            # Special handling for main hand if two-handed weapon is equipped
            elif slot == EquipmentSlot.MAIN_HAND:
                if self.is_slot_empty(EquipmentSlot.MAIN_HAND):
                    # Check if a two-handed weapon is equipped
                    if not self.is_slot_empty(EquipmentSlot.TWO_HAND):
                        continue  # Can't equip main hand if two-handed is equipped
                    return True
            # Special handling for off hand if two-handed weapon is equipped
            elif slot == EquipmentSlot.OFF_HAND:
                if self.is_slot_empty(EquipmentSlot.OFF_HAND):
                    # Check if a two-handed weapon is equipped
                    if not self.is_slot_empty(EquipmentSlot.TWO_HAND):
                        continue  # Can't equip off hand if two-handed is equipped
                    return True
            # Normal slot check
            elif self.is_slot_empty(slot):
                return True
                
        logger.warning(f"Cannot equip: No available slots for item {item_id}")
        return False
    
    def equip_item(self, item_id: str, preferred_slot: Optional[Union[EquipmentSlot, str]] = None) -> bool:
        """
        Equip an item.
        
        Args:
            item_id: The ID of the item to equip.
            preferred_slot: The preferred slot to equip the item in (if applicable).
            
        Returns:
            True if the item was equipped, False otherwise.
        """
        item = self.get_item(item_id) # This gets the Item object
        if not item:
            logger.warning(f"Cannot equip: Item {item_id} not found")
            return False
            
        if not item.is_equippable:
            logger.warning(f"Cannot equip: Item {item.name} is not equippable")
            return False
            
        if not item.equip_slots:
            logger.warning(f"Cannot equip: Item {item.name} has no valid equipment slots")
            return False
            
        if preferred_slot and isinstance(preferred_slot, str):
            try:
                preferred_slot = EquipmentSlot(preferred_slot.lower().replace(" ","_"))
            except ValueError:
                logger.warning(f"Invalid preferred slot string: {preferred_slot}")
                preferred_slot = None
                
        target_slot = None
        
        if preferred_slot and preferred_slot in item.equip_slots:
            if preferred_slot == EquipmentSlot.TWO_HAND:
                if not self.is_slot_empty(EquipmentSlot.MAIN_HAND): self.unequip_item(EquipmentSlot.MAIN_HAND)
                if not self.is_slot_empty(EquipmentSlot.OFF_HAND): self.unequip_item(EquipmentSlot.OFF_HAND)
                target_slot = preferred_slot
            elif preferred_slot == EquipmentSlot.MAIN_HAND or preferred_slot == EquipmentSlot.OFF_HAND:
                if not self.is_slot_empty(EquipmentSlot.TWO_HAND): self.unequip_item(EquipmentSlot.TWO_HAND)
                if self.is_slot_empty(preferred_slot): target_slot = preferred_slot
                else: self.unequip_item(preferred_slot); target_slot = preferred_slot
            elif self.is_slot_empty(preferred_slot):
                target_slot = preferred_slot
            else:
                self.unequip_item(preferred_slot)
                target_slot = preferred_slot
                
        if not target_slot:
            for slot_option in item.equip_slots:
                if slot_option == EquipmentSlot.TWO_HAND:
                    if self.is_slot_empty(EquipmentSlot.MAIN_HAND) and self.is_slot_empty(EquipmentSlot.OFF_HAND):
                        target_slot = slot_option; break
                    else: # Try to make space
                        if not self.is_slot_empty(EquipmentSlot.MAIN_HAND): self.unequip_item(EquipmentSlot.MAIN_HAND)
                        if not self.is_slot_empty(EquipmentSlot.OFF_HAND): self.unequip_item(EquipmentSlot.OFF_HAND)
                        if self.is_slot_empty(EquipmentSlot.MAIN_HAND) and self.is_slot_empty(EquipmentSlot.OFF_HAND):
                             target_slot = slot_option; break
                elif slot_option == EquipmentSlot.MAIN_HAND or slot_option == EquipmentSlot.OFF_HAND:
                    if not self.is_slot_empty(EquipmentSlot.TWO_HAND): continue 
                    if self.is_slot_empty(slot_option): target_slot = slot_option; break
                elif self.is_slot_empty(slot_option):
                    target_slot = slot_option; break
            
            # If still no empty slot found after first pass, try unequipping existing item in first valid slot
            if not target_slot and item.equip_slots:
                first_valid_slot_for_item = item.equip_slots[0]
                if first_valid_slot_for_item == EquipmentSlot.TWO_HAND:
                    if not self.is_slot_empty(EquipmentSlot.MAIN_HAND): self.unequip_item(EquipmentSlot.MAIN_HAND)
                    if not self.is_slot_empty(EquipmentSlot.OFF_HAND): self.unequip_item(EquipmentSlot.OFF_HAND)
                elif (first_valid_slot_for_item == EquipmentSlot.MAIN_HAND or first_valid_slot_for_item == EquipmentSlot.OFF_HAND) and not self.is_slot_empty(EquipmentSlot.TWO_HAND):
                    self.unequip_item(EquipmentSlot.TWO_HAND)
                
                # Unequip whatever is in the first_valid_slot_for_item if it's occupied
                if not self.is_slot_empty(first_valid_slot_for_item):
                    self.unequip_item(first_valid_slot_for_item)
                target_slot = first_valid_slot_for_item


        if target_slot:
            self._equipment[target_slot] = item.id # Store item ID
            self._update_equipment_modifiers()
            logger.info(f"Equipped {item.name} (ID: {item.id}) in {target_slot.value}")
            
            # Trigger stats synchronization if available
            self._sync_stats_modifiers()
            
            return True
        
        logger.warning(f"Failed to equip {item.name}: No suitable slot found or made available.")
        return False
    
    def unequip_item(self, slot: Union[EquipmentSlot, str]) -> Optional[str]:
        """
        Unequip an item from a specific slot.
        
        Args:
            slot: The slot to unequip from.
            
        Returns:
            The ID of the unequipped item, or None if the slot was empty or error.
        """
        if isinstance(slot, str):
            try:
                slot = EquipmentSlot(slot.lower().replace(" ", "_"))
            except ValueError:
                logger.error(f"Invalid equipment slot string: {slot}")
                return None
        
        item_id_in_slot = self._equipment.get(slot) # This should be an item ID (string)
        if not item_id_in_slot or not isinstance(item_id_in_slot, str): # Ensure it's a string ID
            logger.debug(f"Cannot unequip: Slot {slot.value} is already empty or contains invalid data.")
            if slot == EquipmentSlot.TWO_HAND: # Also clear main/off if un-equipping two-hand
                self._equipment[EquipmentSlot.MAIN_HAND] = None
                self._equipment[EquipmentSlot.OFF_HAND] = None
            return None
        
        item_obj = self.get_item(item_id_in_slot) # Fetch Item object using the ID
        
        self._equipment[slot] = None
        # If a two-handed weapon was unequipped, ensure main_hand and off_hand are also cleared
        if slot == EquipmentSlot.TWO_HAND:
            self._equipment[EquipmentSlot.MAIN_HAND] = None
            self._equipment[EquipmentSlot.OFF_HAND] = None
        # If main_hand or off_hand was unequipped, and a two_handed weapon was there, clear two_hand slot
        elif (slot == EquipmentSlot.MAIN_HAND or slot == EquipmentSlot.OFF_HAND) and self._equipment.get(EquipmentSlot.TWO_HAND) == item_id_in_slot :
             self._equipment[EquipmentSlot.TWO_HAND] = None


        self._update_equipment_modifiers()
        
        # Trigger stats synchronization if available
        self._sync_stats_modifiers()
        
        item_name_for_log = item_obj.name if item_obj else f"Item ID {item_id_in_slot}"
        logger.info(f"Unequipped {item_name_for_log} from {slot.value}")
        
        return item_id_in_slot
    
    def unequip_all(self) -> List[str]:
        """
        Unequip all items.
        
        Returns:
            List of unequipped item IDs.
        """
        unequipped_items = []
        
        for slot in self._equipment:
            item_id = self._equipment[slot]
            if item_id:
                self._equipment[slot] = None
                unequipped_items.append(item_id)
        
        self._update_equipment_modifiers()
        
        # Trigger stats synchronization if available
        self._sync_stats_modifiers()
        
        logger.info(f"Unequipped all items ({len(unequipped_items)} items)")
        
        return unequipped_items
    
    def _update_equipment_modifiers(self) -> None:
        """Update the equipment modifiers based on currently equipped items."""
        # Clear existing modifiers
        self._equipment_modifiers = {}
        
        # Add modifiers from each equipped item
        for slot, item_id in self._equipment.items():
            if not item_id:
                continue
                
            item = self.get_item(item_id)
            if not item:
                continue
                
            # Add stat modifiers
            for stat in item.stats:
                source_id = f"{item.id}_{stat.name}"
                self._equipment_modifiers[source_id] = {
                    "stat": stat.name,
                    "value": stat.value,
                    "is_percentage": stat.is_percentage,
                    "source_item": item.id,
                    "source_slot": slot.value
                }
        
        logger.debug(f"Updated equipment modifiers: {len(self._equipment_modifiers)} active modifiers")
    
    def _sync_stats_modifiers(self) -> None:
        """
        Trigger synchronization of equipment modifiers with the stats manager.
        This method will be overridden by InventoryManager to provide the stats manager reference.
        """
        # Base implementation does nothing - will be overridden in InventoryManager
        pass
    
    def get_stat_modifiers(self, stat_name: str) -> List[Dict[str, Any]]:
        """
        Get all modifiers for a specific stat from equipped items.
        
        Args:
            stat_name: The name of the stat to get modifiers for.
            
        Returns:
            List of modifier dictionaries.
        """
        modifiers = []
        
        for modifier_id, modifier in self._equipment_modifiers.items():
            if modifier["stat"] == stat_name:
                modifiers.append(modifier)
        
        return modifiers
    
    def get_equipped_slots_for_item(self, item_id: str) -> List[EquipmentSlot]:
        """
        Get all slots where a specific item is equipped.
        
        Args:
            item_id: The ID of the item to check.
            
        Returns:
            List of equipment slots where the item is equipped.
        """
        slots = []
        
        for slot, equipped_id in self._equipment.items():
            if equipped_id == item_id:
                slots.append(slot)
        
        return slots
    
    def is_item_equipped(self, item_id: str) -> bool:
        """
        Check if an item is equipped in any slot.
        
        Args:
            item_id: The ID of the item to check.
            
        Returns:
            True if the item is equipped, False otherwise.
        """
        return item_id in self._equipment.values()
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the equipment manager to a dictionary for serialization.
        
        Returns:
            Dictionary representation of the equipment manager.
        """
        # Serialize the equipment slots and items
        equipment_dict = {}
        for slot, item_id in self._equipment.items():
            equipment_dict[slot.value] = item_id
        
        # Get all equipped items data
        items_dict = {}
        for item_id, item in self._items.items():
            if item_id in self._equipment.values():  # Only serialize equipped items
                from core.inventory.item_serialization import item_to_dict
                items_dict[item_id] = item_to_dict(item)
        
        return {
            "equipment": equipment_dict,
            "items": items_dict,
            "equipment_modifiers": self._equipment_modifiers
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'EquipmentManager':
        """
        Create an equipment manager from a dictionary.
        
        Args:
            data: Dictionary representation of the equipment manager.
            
        Returns:
            New EquipmentManager instance.
        """
        manager = cls()
        
        # Restore items first
        items_data = data.get("items", {})
        for item_id, item_data in items_data.items():
            from core.inventory.item_serialization import dict_to_item
            item = dict_to_item(item_data)
            manager._items[item_id] = item
        
        # Restore equipment slots
        equipment_data = data.get("equipment", {})
        for slot_name, item_id in equipment_data.items():
            try:
                slot = EquipmentSlot(slot_name)
                manager._equipment[slot] = item_id
            except ValueError:
                logger.warning(f"Unknown equipment slot '{slot_name}' during deserialization")
        
        # Restore equipment modifiers
        manager._equipment_modifiers = data.get("equipment_modifiers", {})
        
        return manager

```

### File: core\inventory\inventory_base.py

```python
#!/usr/bin/env python3
"""
Core inventory module.

This module provides the base InventoryManager class with
core properties and query methods.
"""

from typing import Dict, List, Optional, Any, Tuple, Set, Union
import logging

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_enums import ItemType

# Get module logger
logger = get_logger("Inventory")


class InventoryBase:
    """
    Base manager for a player's inventory.
    
    This class provides core inventory properties and query methods.
    """
    
    def __init__(self):
        """Initialize the inventory manager."""
        # Dictionary of items by ID
        self._items: Dict[str, Item] = {}
        
        # Item weight limits
        self._weight_limit: float = 100.0
        self._weight_limit_base: float = 100.0
        self._weight_limit_modifiers: Dict[str, float] = {}
        
        # Storage slot limits
        self._slot_limit: int = 20
        self._slot_limit_base: int = 20
        self._slot_limit_modifiers: Dict[str, int] = {}
        
        logger.info("Inventory manager initialized")
    
    @property
    def items(self) -> List[Item]:
        """Get all items in the inventory."""
        return list(self._items.values())
    
    @property
    def weight_limit(self) -> float:
        """Get the current weight limit."""
        return self._weight_limit
    
    @property
    def slot_limit(self) -> int:
        """Get the current slot limit."""
        return self._slot_limit
    
    def get_current_weight(self) -> float:
        """Get the current total weight of all items."""
        return sum(item.weight * item.quantity for item in self._items.values())
    
    def get_used_slots(self) -> int:
        """Get the number of slots currently used."""
        # Count unstackable items as 1 slot each, stackable items as 1 slot per stack
        return sum(1 for item in self._items.values() if not item.is_stackable) + \
               sum(1 for item in self._items.values() if item.is_stackable)
    
    def get_free_slots(self) -> int:
        """Get the number of free slots."""
        return max(0, self._slot_limit - self.get_used_slots())
    
    def get_item(self, item_id: str) -> Optional[Item]:
        """Get an item by ID."""
        return self._items.get(item_id)
    
    def find_items(self, **criteria) -> List[Item]:
        """
        Find items based on criteria.
        
        Args:
            **criteria: Criteria to match, e.g., name="Sword", item_type=ItemType.WEAPON
            
        Returns:
            List of items matching the criteria.
        """
        results = []
        
        for item in self._items.values():
            matches = True
            
            for key, value in criteria.items():
                # Handle special case for item_type which might be an enum or string
                if key == "item_type" and isinstance(value, str):
                    try:
                        value = ItemType(value)
                    except ValueError:
                        # If it's not a valid enum value, keep as is
                        pass
                
                item_value = getattr(item, key, None)
                
                # Check if the item has the attribute and it matches the value
                if item_value is None or item_value != value:
                    matches = False
                    break
            
            if matches:
                results.append(item)
        
        return results
    
    def is_empty(self) -> bool:
        """Check if the inventory is empty."""
        return len(self._items) == 0
    
    def get_items_by_type(self, item_type: Union[ItemType, str]) -> List[Item]:
        """Get all items of a specific type."""
        if isinstance(item_type, str):
            try:
                item_type = ItemType(item_type)
            except ValueError:
                # If it's not a valid enum value, return empty list
                return []
        
        return [item for item in self._items.values() if item.item_type == item_type]
    
    def get_total_value(self) -> int:
        """Get the total value of all items in the inventory (in copper)."""
        return sum(item.value * item.quantity for item in self._items.values())

```

### File: core\inventory\inventory_commands.py

```python
#!/usr/bin/env python3
"""
Inventory command handlers for the RPG game.

This module provides command handlers for inventory-related commands
like 'inventory', 'equip', 'unequip', 'examine', etc.
"""

from typing import List, Optional
import logging

from core.utils.logging_config import get_logger
from core.base.state import GameState
from core.base.commands import CommandResult, get_command_processor
from core.inventory import get_inventory_manager, EquipmentSlot, ItemType

# Import command functions from other modules
from core.inventory.inventory_commands_2 import (
    equip_command,
    unequip_command,
    examine_command
)

from core.inventory.inventory_commands_3 import (
    currency_command,
    equipment_command,
    drop_command
)

# Get module logger
logger = get_logger("INVENTORY")

# Helper to normalize equipped mapping to item ID
from typing import Any as _Any

def equipment_item_id(equipped_entry: _Any) -> str:
    try:
        # EquipmentManager.equipment returns Item objects
        from core.inventory.item import Item as _Item
        if isinstance(equipped_entry, _Item):
            return equipped_entry.id
        # For backward/save compatibility if value is an ID string
        if isinstance(equipped_entry, str):
            return equipped_entry
    except Exception:
        pass
    return ""

def register_inventory_commands():
    """Register all inventory-related commands with the command processor."""
    command_processor = get_command_processor()
    
    # Register the inventory command
    command_processor.register_command(
        name="inventory",
        handler=inventory_command,
        syntax="inventory [category]",
        description="Display the contents of your inventory, optionally filtered by category.",
        examples=["inventory", "inventory weapons", "inventory armor"],
        aliases=["inv", "i"]
    )
    
    # Register the equip command
    command_processor.register_command(
        name="equip",
        handler=equip_command,
        syntax="equip <item_id or item_name>",
        description="Equip an item from your inventory.",
        examples=["equip sword", "equip 12345"],
        aliases=["wear", "wield"]
    )
    
    # Register the unequip command
    command_processor.register_command(
        name="unequip",
        handler=unequip_command,
        syntax="unequip <slot or item_id or item_name>",
        description="Unequip an item from a specific slot or by item name/ID.",
        examples=["unequip weapon", "unequip 12345", "unequip sword"],
        aliases=["remove", "unwield"]
    )
    
    # Register the examine command
    command_processor.register_command(
        name="examine",
        handler=examine_command,
        syntax="examine <item_id or item_name>",
        description="Examine an item in your inventory to learn more about it.",
        examples=["examine sword", "examine 12345"],
        aliases=["look", "inspect"]
    )
    
    # Register the currency command
    command_processor.register_command(
        name="currency",
        handler=currency_command,
        syntax="currency",
        description="Display your current currency.",
        examples=["currency"],
        aliases=["gold", "money", "coins"]
    )
    
    # Register the equipment command
    command_processor.register_command(
        name="equipment",
        handler=equipment_command,
        syntax="equipment",
        description="Display your currently equipped items.",
        examples=["equipment"],
        aliases=["equipped", "gear"]
    )
    
    # Register the drop command
    command_processor.register_command(
        name="drop",
        handler=drop_command,
        syntax="drop <item_id or item_name> [quantity]",
        description="Drop an item from your inventory.",
        examples=["drop sword", "drop 12345", "drop potion 5"],
        aliases=["discard"]
    )
    
    # Register the loot command
    command_processor.register_command(
        name="loot",
        handler=loot_command,
        syntax="loot [take <item_id|all>]",
        description="List available loot or take items from defeated enemies.",
        examples=["loot", "loot take sword", "loot take all"],
        aliases=["take", "pickup"]
    )
    
    logger.info("Registered inventory commands")


def inventory_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Display the contents of the inventory, optionally filtered by category.
    
    Args:
        game_state: The current game state.
        args: Optional category filter.
            
    Returns:
        CommandResult with inventory information.
    """
    inventory = get_inventory_manager()
    
    # Check if inventory is empty
    if not inventory.items:
        return CommandResult.success("Your inventory is empty.")
    
    # Check for category filter
    category = args[0].lower() if args else None
    
    # Get all items, filtered if necessary
    items = list(inventory.items)
    
    if category:
        # Try to match category to ItemType
        matched_type = None
        for item_type in ItemType:
            if category in item_type.value.lower():
                matched_type = item_type
                break
        
        if matched_type:
            items = [item for item in items if item.item_type == matched_type]
            if not items:
                return CommandResult.success(f"You have no {matched_type.value.lower()} items in your inventory.")
        else:
            # Try to match by item name
            items = [item for item in items if category.lower() in item.name.lower()]
            if not items:
                return CommandResult.success(f"No items matching '{category}' found in your inventory.")
    
    # Sort items by type and name
    items = sorted(items, key=lambda item: (item.item_type.value, item.name))
    
    # Build the inventory display
    result_lines = ["Inventory:"]
    
    # Group by item type
    current_type = None
    
    for item in items:
        # Add type header if this is a new type
        if current_type != item.item_type:
            current_type = item.item_type
            result_lines.append(f"\n{current_type.value}:")
        
        # Check if item is equipped
        equipped = ""
        for slot, equipped_item in inventory.equipment.items():
            if equipped_item and equipment_item_id(equipped_item) == item.id:
                equipped = f" (Equipped: {slot.value})"
                break
        
        # Add quantity for stackable items
        quantity = f" x{item.quantity}" if item.is_stackable and item.quantity > 1 else ""
        
        # Add item with ID
        result_lines.append(f"  {item.name}{quantity} [ID: {item.id}]{equipped}")
    
    # Add inventory stats
    result_lines.append(f"\nInventory: {inventory.get_used_slots()}/{inventory.slot_limit} slots used")
    result_lines.append(f"Weight: {inventory.get_current_weight():.1f}/{inventory.weight_limit:.1f} units")
    result_lines.append(f"Currency: {inventory.currency.get_formatted_currency()}")
    
    return CommandResult.success("\n".join(result_lines))


def loot_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Handle loot-related commands: list, take, take all.
    
    Usage:
        loot - List available loot
        loot take <item_id> - Take a specific item
        loot take all - Take all available items
    """
    # Check if there's any available loot
    if not hasattr(game_state, 'available_loot') or not game_state.available_loot:
        return CommandResult.success("No loot available.")
    
    if not args:
        # List available loot
        return _list_available_loot(game_state)
    
    command = args[0].lower()
    
    if command == "take":
        if len(args) < 2:
            return CommandResult.error("Usage: loot take <item_id> or loot take all")
        
        if args[1].lower() == "all":
            return _take_all_loot(game_state)
        else:
            item_identifier = args[1]
            return _take_specific_loot(game_state, item_identifier)
    
    return CommandResult.error(f"Unknown loot command: {command}. Use: loot, loot take <item_id>, or loot take all")


def _list_available_loot(game_state: GameState) -> CommandResult:
    """List all available loot items."""
    available_loot = game_state.available_loot
    
    if not available_loot:
        return CommandResult.success("No loot available.")
    
    result_lines = ["Available Loot:"]
    
    for i, loot_entry in enumerate(available_loot):
        try:
            item_data = loot_entry.get('item_data', {})
            item_name = item_data.get('name', 'Unknown Item')
            item_id = item_data.get('id', f'loot_{i}')
            source = loot_entry.get('source', 'Unknown')
            slot = loot_entry.get('slot', 'unknown')
            
            result_lines.append(f"  {item_name} [ID: {item_id}] (from {source}, was equipped in {slot})")
            
        except Exception as e:
            logger.error(f"Error listing loot item {i}: {e}")
            result_lines.append(f"  <Error listing item {i}>")
    
    result_lines.append(f"\nTotal: {len(available_loot)} item(s)")
    result_lines.append("Use 'loot take <item_id>' to take an item or 'loot take all' to take everything.")
    
    return CommandResult.success("\n".join(result_lines))


def _take_specific_loot(game_state: GameState, item_identifier: str) -> CommandResult:
    """Take a specific loot item."""
    available_loot = game_state.available_loot
    
    # Find the loot item
    loot_entry = None
    loot_index = None
    
    for i, entry in enumerate(available_loot):
        item_data = entry.get('item_data', {})
        if (item_data.get('id') == item_identifier or 
            item_data.get('name', '').lower() == item_identifier.lower()):
            loot_entry = entry
            loot_index = i
            break
    
    if not loot_entry:
        return CommandResult.error(f"Loot item '{item_identifier}' not found.")
    
    try:
        # Convert loot to item and add to inventory
        from core.inventory.item_serialization import dict_to_item
        item = dict_to_item(loot_entry['item_data'])
        
        # Get player inventory
        inventory = get_inventory_manager()
        
        # Try to add the item
        if inventory.can_add_item(item):
            inventory.add_item(item)
            
            # Remove from available loot
            del available_loot[loot_index]
            
            source = loot_entry.get('source', 'defeated enemy')
            return CommandResult.success(f"Took {item.name} from {source}.")
        else:
            return CommandResult.error(f"Cannot take {item.name}: not enough inventory space.")
    
    except Exception as e:
        logger.error(f"Error taking loot item {item_identifier}: {e}")
        return CommandResult.error(f"Failed to take item: {e}")


def _take_all_loot(game_state: GameState) -> CommandResult:
    """Take all available loot items."""
    available_loot = game_state.available_loot
    
    if not available_loot:
        return CommandResult.success("No loot to take.")
    
    inventory = get_inventory_manager()
    taken_items = []
    failed_items = []
    
    # Process each loot item
    for loot_entry in available_loot[:]:  # Copy list to avoid modification during iteration
        try:
            from core.inventory.item_serialization import dict_to_item
            item = dict_to_item(loot_entry['item_data'])
            
            if inventory.can_add_item(item):
                inventory.add_item(item)
                taken_items.append(item.name)
                available_loot.remove(loot_entry)
            else:
                failed_items.append(item.name)
                
        except Exception as e:
            logger.error(f"Error processing loot item: {e}")
            failed_items.append(f"<Error: {e}>")
    
    # Generate result message
    result_lines = []
    
    if taken_items:
        result_lines.append(f"Took {len(taken_items)} items:")
        for item_name in taken_items:
            result_lines.append(f"  - {item_name}")
    
    if failed_items:
        result_lines.append(f"\nCould not take {len(failed_items)} items (insufficient space):")
        for item_name in failed_items:
            result_lines.append(f"  - {item_name}")
    
    if not taken_items and not failed_items:
        return CommandResult.success("No loot was available to take.")
    
    return CommandResult.success("\n".join(result_lines))

```

### File: core\inventory\inventory_commands_2.py

```python
#!/usr/bin/env python3
"""
Additional inventory command handlers for the RPG game.

This module provides more command handlers for inventory-related commands
like 'equip', 'unequip', 'examine', etc.
"""

from typing import List, Optional
import logging

from core.inventory.item import Item
from core.utils.logging_config import get_logger
from core.base.state import GameState
from core.base.commands import CommandResult
from core.inventory import get_inventory_manager, EquipmentSlot, ItemType

# Get module logger
logger = get_logger("INVENTORY")

def equip_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Equip an item from the inventory.
    
    Args:
        game_state: The current game state.
        args: Item ID or name to equip, optionally followed by slot name.
            
    Returns:
        CommandResult indicating success or failure.
    """
    if not args:
        return CommandResult.invalid("Usage: equip <item_id_or_name> [slot_name]")
    
    inventory = get_inventory_manager()
    item_id_or_name = args[0]
    preferred_slot_str: Optional[str] = args[1] if len(args) > 1 else None
    preferred_slot_enum: Optional[EquipmentSlot] = None

    if preferred_slot_str:
        try:
            preferred_slot_enum = EquipmentSlot(preferred_slot_str.lower().replace(" ", "_"))
        except ValueError:
            return CommandResult.invalid(f"Invalid slot name: {preferred_slot_str}. Valid slots are: {', '.join([s.value for s in EquipmentSlot])}")
    
    # Try to find the item by ID first
    item = inventory.get_item(item_id_or_name)
    
    # If not found by ID, try by name (case-insensitive partial match)
    if not item:
        # More robust name matching: find items where args[0] is a substring of item name
        # and prefer exact matches if multiple are found.
        found_items = []
        for inv_item_id, inv_item_obj in inventory._items.items(): # Access internal dict
            if item_id_or_name.lower() in inv_item_obj.name.lower():
                if inv_item_obj.name.lower() == item_id_or_name.lower(): # Exact match
                    item = inv_item_obj
                    break
                found_items.append(inv_item_obj)
        
        if not item and found_items: # No exact match, take first partial if any
            item = found_items[0]
            logger.info(f"Equip command: Found item '{item.name}' by partial name match for '{item_id_or_name}'.")

    if not item:
        return CommandResult.failure(f"Item '{item_id_or_name}' not found in your inventory.")
    
    # Check if item is equippable
    if not item.is_equippable:
        return CommandResult.failure(f"You cannot equip {item.name}.")
    
    # Try to equip the item
    if inventory.equip_item(item.id, preferred_slot=preferred_slot_enum):
        # Find which slot it was equipped to for the message
        slot_actually_equipped_to_str = "a suitable slot"
        for slot_enum_loop, item_id_loop in inventory.equipment.items(): # Iterate over current equipment state
            if item_id_loop == item.id:
                slot_actually_equipped_to_str = slot_enum_loop.value.replace("_", " ")
                break
        
        logger.info(f"Equipped {item.name} to {slot_actually_equipped_to_str} via command.")
        return CommandResult.success(f"You equipped {item.name} to your {slot_actually_equipped_to_str}.")
    else:
        # equip_item logs warnings if it fails
        return CommandResult.failure(f"Could not equip {item.name}. Check available slots or item requirements.")


def unequip_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Unequip an item by slot, ID, or name.
    Args:
        game_state: The current game state.
        args: Slot, item ID, or item name to unequip.
            
    Returns:
        CommandResult indicating success or failure.
    """
    if not args:
        return CommandResult.invalid("Usage: unequip <slot_name_or_item_id_or_item_name>")

    inventory = get_inventory_manager()
    target_identifier = args[0] 

    target_slot_to_unequip: Optional[EquipmentSlot] = None
    item_to_unequip_obj: Optional[Item] = None

    # Try to interpret target_identifier as a slot first
    try:
        potential_slot = EquipmentSlot(target_identifier.lower().replace(" ", "_"))
        equipped_val = inventory.equipment.get(potential_slot)  # May be Item or ID string
        if equipped_val:
            if isinstance(equipped_val, Item):
                item_to_unequip_obj = equipped_val
            else:
                item_to_unequip_obj = inventory.get_item(equipped_val)
            if item_to_unequip_obj:
                target_slot_to_unequip = potential_slot
            else:
                return CommandResult.error(f"Item in slot {potential_slot.value} is missing from inventory records.")
        else:
            return CommandResult.failure(f"You have nothing equipped in your {potential_slot.value.replace('_', ' ')}.")
    except ValueError:
        # Not a direct slot name, try to find item by ID or name among equipped items
        # Search all equipped items
        for slot_enum_loop, equipped_val in inventory.equipment.items():  # Iterate over current equipment state
            if not equipped_val:
                continue
            if isinstance(equipped_val, Item):
                item_obj_in_loop = equipped_val
                equipped_id = equipped_val.id
            else:
                equipped_id = equipped_val
                item_obj_in_loop = inventory.get_item(equipped_id)
            if item_obj_in_loop:
                if equipped_id == target_identifier or target_identifier.lower() in (item_obj_in_loop.name or '').lower():
                    item_to_unequip_obj = item_obj_in_loop
                    target_slot_to_unequip = slot_enum_loop
                    break  # Found the item and its slot
        if not item_to_unequip_obj:
            return CommandResult.failure(f"You don't have an item matching '{target_identifier}' equipped, nor is it a valid slot name.")

    if not target_slot_to_unequip or not item_to_unequip_obj:
        return CommandResult.error("Failed to identify item or slot for unequipping.")

    item_name_display = item_to_unequip_obj.name
    slot_name_display = target_slot_to_unequip.value.replace("_", " ")

    unequipped_item_id_returned = inventory.unequip_item(target_slot_to_unequip)

    if unequipped_item_id_returned and unequipped_item_id_returned == item_to_unequip_obj.id:
        logger.info(f"Unequipped {item_name_display} from {slot_name_display} via command.")
        return CommandResult.success(f"You unequipped {item_name_display} from your {slot_name_display}.")
    elif unequipped_item_id_returned: 
        return CommandResult.error(f"An unexpected item was unequipped when trying to unequip {item_name_display}.")
    else: 
        return CommandResult.failure(f"Could not unequip {item_name_display}. Slot might have been empty or an error occurred.")
    
def examine_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Examine an item to learn more about it.
    This command, when typed by player, will still go to LLM for narrative.
    The UI button will directly open the ItemInfoDialog.
    
    Args:
        game_state: The current game state.
        args: Item ID or name to examine.
            
    Returns:
        CommandResult with item information (or to be processed by LLM).
    """
    if not args:
        return CommandResult.invalid("Please specify an item to examine.")
    
    inventory = get_inventory_manager()
    item_id_or_name = " ".join(args) # Join all args to handle multi-word item names
    
    # Try to find the item by ID first
    item = inventory.get_item(item_id_or_name)
    
    # If not found by ID, try by name (case-insensitive partial match)
    if not item:
        # More robust name matching: find items where args[0] is a substring of item name
        # and prefer exact matches if multiple are found.
        found_items = []
        # Access internal dict for comprehensive search
        all_inventory_items = inventory._items.values() if hasattr(inventory, '_items') else inventory.items

        for inv_item_obj in all_inventory_items:
            if item_id_or_name.lower() in inv_item_obj.name.lower():
                if inv_item_obj.name.lower() == item_id_or_name.lower(): # Exact match
                    item = inv_item_obj
                    break
                found_items.append(inv_item_obj)
        
        if not item and found_items: # No exact match, take first partial if any
            if len(found_items) == 1:
                item = found_items[0]
                logger.info(f"Examine command: Found item '{item.name}' by partial name match for '{item_id_or_name}'.")
            else:
                # Multiple partial matches, ask user to be more specific or list them
                matched_names = [f"'{i.name}' (ID: {i.id})" for i in found_items[:5]] # Show up to 5
                return CommandResult.failure(f"Found multiple items matching '{item_id_or_name}': {', '.join(matched_names)}. Please be more specific or use the item ID.")
    
    if not item:
        return CommandResult.failure(f"Item '{item_id_or_name}' not found in your inventory.")
    
    # If the command originated from UI (e.g. examine {uuid}), InputRouter will handle it directly.
    # If typed by player (e.g. "examine sword"), InputRouter passes it to LLM.
    # This handler, if called by LLM processing (which it might not be directly anymore),
    # would provide structured data to the LLM.
    # For now, we assume LLM handles the narration if it's a typed command.
    # If this is called mechanically (e.g., after an LLM command {EXAMINE_ITEM item_id}),
    # then this structured output is useful.

    # Build the item description string for LLM context or direct display if no LLM
    result_parts = [f"You examine the {item.name}:"]
    
    # Basic properties (always known or become known on first examine)
    item.discover_property("name")
    item.discover_property("item_type")
    item.discover_property("rarity")
    item.discover_property("description") # Discover description on examine

    result_parts.append(f"- Type: {item.item_type.value.capitalize()}")
    result_parts.append(f"- Rarity: {item.rarity.value.capitalize()} (Color: {item.rarity.color})")
    
    if item.is_property_known("description"):
        result_parts.append(f"- Description: {item.description}")
    else:
        result_parts.append("- Description: You can't quite make out the details.")

    if item.is_property_known("weight"):
        result_parts.append(f"- Weight: {item.weight:.2f} units")
    
    if item.is_property_known("value"):
        from core.inventory.currency_manager import CurrencyManager # Local import
        cm_temp = CurrencyManager()
        cm_temp.set_currency(item.value)
        result_parts.append(f"- Value: {cm_temp.get_formatted_currency()}")

    if item.is_equippable and item.is_property_known("equip_slots"):
        slots_str = ", ".join(s.value.replace('_', ' ').title() for s in item.equip_slots) if item.equip_slots else "None"
        result_parts.append(f"- Equip Slots: {slots_str}")

    if item.durability is not None and item.is_property_known("durability"):
        cur_dur = item.current_durability if item.current_durability is not None else item.durability
        result_parts.append(f"- Durability: {cur_dur}/{item.durability}")

    # Stats
    known_stats = [s for s in item.stats if item.is_stat_known(s.name)]
    if known_stats:
        result_parts.append("- Stats:")
        for stat in known_stats:
            val_str = f"{stat.value:+.1f}" if isinstance(stat.value, (int, float)) and stat.value !=0 else str(stat.value)
            if stat.is_percentage and isinstance(stat.value, (int,float)): val_str += "%"
            display_name = stat.display_name if stat.display_name else stat.name.replace('_', ' ').title()
            result_parts.append(f"  - {display_name}: {val_str}")
    
    # Dice Roll Effects
    if item.dice_roll_effects and item.is_property_known("dice_roll_effects"):
        result_parts.append("- Effects:")
        for effect in item.dice_roll_effects:
            effect_desc = f"{effect.dice_notation} {effect.effect_type.replace('_', ' ').title()}"
            if effect.description: effect_desc += f" ({effect.description})"
            result_parts.append(f"  - {effect_desc}")

    # Custom Properties
    known_custom_props = {k: v for k, v in item.custom_properties.items() if item.is_property_known(f"custom_{k}")}
    if known_custom_props:
        result_parts.append("- Properties:")
        for key, value in known_custom_props.items():
            result_parts.append(f"  - {key.replace('_', ' ').title()}: {value}")
            
    if item.is_property_known("tags") and item.tags:
        result_parts.append(f"- Tags: {', '.join(item.tags)}")

    # For the purpose of this command handler returning a string for LLM:
    # If called by a direct "examine sword" from player, the LLM provides narration.
    # If this function is called as a result of an LLM issuing an EXAMINE_MECHANICAL command,
    # this detailed string could be used by another agent or logged.
    # Since UI button directly opens a dialog, this path is less critical for UI.
    
    # The `InputRouter` logic was changed: UI-generated "examine {uuid}" commands
    # are processed by `_process_direct_command`. If that direct command is "examine",
    # this `examine_command` handler is called.
    # For UI-originated "examine", we do NOT want text output to the game window.
    # MainWindow._handle_item_examine_requested should open the dialog.
    # This command handler should just return success for the engine's loop.

    # Check if the command was likely UI-generated (contains UUID)
    # A bit of a hack here, ideally InputRouter would pass a flag.
    is_likely_ui_command = '-' in item_id_or_name and len(item_id_or_name) > 10 

    if is_likely_ui_command:
        # The actual dialog display is handled by MainWindow when it receives item_examine_requested signal
        logger.info(f"Examine command (likely UI initiated) for {item.name} (ID: {item.id}) processed mechanically.")
        return CommandResult.success(message=f"Examined {item.name}.", data={"item_id": item.id, "action": "examine_dialog"})
    else:
        # This is for a typed command, let LLM narrate.
        # The engine will get this text, then pass it to AgentManager.
        # AgentManager's NarratorAgent should use this as part of its context.
        logger.info(f"Examine command (typed) for {item.name}. LLM will narrate.")
        return CommandResult.success("\n".join(result_parts), data={"item_id": item.id, "action": "examine_llm_narrate"})
```

### File: core\inventory\inventory_commands_3.py

```python
#!/usr/bin/env python3
"""
Finalized inventory command handlers for the RPG game.

This module provides the remaining command handlers for inventory-related commands
like 'currency', 'equipment', and 'drop'.
"""

from typing import List, Optional
import logging

from core.utils.logging_config import get_logger
from core.base.state import GameState
from core.base.commands import CommandResult
from core.inventory import get_inventory_manager, EquipmentSlot

# Get module logger
logger = get_logger("INVENTORY")

def currency_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Display current currency.
    
    Args:
        game_state: The current game state.
        args: Command arguments (ignored).
            
    Returns:
        CommandResult with currency information.
    """
    inventory = get_inventory_manager()
    
    # Get formatted currency
    currency_str = inventory.currency.get_formatted_currency()
    
    # Show details of each denomination
    gold = inventory.currency.gold
    silver = inventory.currency.silver
    copper = inventory.currency.copper
    
    result_lines = [
        "Your Currency:",
        f"  {currency_str}",
        "",
        f"  Gold: {gold}",
        f"  Silver: {silver}",
        f"  Copper: {copper}"
    ]
    
    return CommandResult.success("\n".join(result_lines))


def equipment_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Display currently equipped items.
    
    Args:
        game_state: The current game state.
        args: Command arguments (ignored).
            
    Returns:
        CommandResult with equipment information.
    """
    inventory = get_inventory_manager()
    
    # Group equipment slots by category
    equipment_categories = {
        "Weapons": [EquipmentSlot.MAIN_HAND, EquipmentSlot.OFF_HAND, EquipmentSlot.TWO_HAND, EquipmentSlot.RANGED, EquipmentSlot.AMMUNITION],
        "Armor": [EquipmentSlot.HEAD, EquipmentSlot.SHOULDERS, EquipmentSlot.ARMS, EquipmentSlot.WRISTS, EquipmentSlot.HANDS, EquipmentSlot.CHEST, EquipmentSlot.WAIST, EquipmentSlot.LEGS, EquipmentSlot.FEET],
        "Accessories": [EquipmentSlot.NECK, EquipmentSlot.BACK, EquipmentSlot.FINGER_1, EquipmentSlot.FINGER_2, EquipmentSlot.TRINKET_1, EquipmentSlot.TRINKET_2]
    }
    
    result_lines = ["Your Equipment:"]
    
    # Show equipment by category
    for category, slots in equipment_categories.items():
        result_lines.append(f"\n{category}:")
        
        for slot in slots:
            equipped = inventory.equipment.get(slot)
            item = equipped if equipped is not None else None
            if item:
                # Show item rarity and stats if known
                stats_str = ""
                known_stats = [stat for stat in item.stats 
                               if f"stat_{stat.name}" in item.known_properties]
                
                if known_stats:
                    stats = []
                    for stat in known_stats:
                        stats.append(f"{stat.name.capitalize()}: {stat.value}")
                    stats_str = f" ({', '.join(stats)})"
                
                # Show durability if known
                durability_str = ""
                if getattr(item, "durability", None) and "durability" in item.known_properties:
                    try:
                        durability_percent = (float(item.current_durability or item.durability) / float(item.durability)) * 100
                        durability_str = f" [{durability_percent:.1f}%]"
                    except Exception:
                        pass
                
                result_lines.append(f"  {slot.value}: {item.name} ({item.rarity.value}){stats_str}{durability_str}")
            else:
                result_lines.append(f"  {slot.value}: Empty")
    
    # Add summary stats if the character has any equipment
    if any(inventory.equipment.values()):
        result_lines.append("\nEquipment Stats:")
        
        # Calculate total stats from equipped items
        total_stats = {}
        
        for item_id in inventory.equipment.values():
            if item_id:
                item = inventory.get_item(item_id)
                if item:
                    for stat in item.stats:
                        if f"stat_{stat.name}" in item.known_properties:
                            if stat.name in total_stats:
                                total_stats[stat.name] += stat.value
                            else:
                                total_stats[stat.name] = stat.value
        
        # Display total stats
        for stat_name, stat_value in sorted(total_stats.items()):
            result_lines.append(f"  {stat_name.capitalize()}: {stat_value}")
    
    return CommandResult.success("\n".join(result_lines))


def drop_command(game_state: GameState, args: List[str]) -> CommandResult:
    """
    Drop an item from the inventory.
    If this is called after LLM narration (e.g. via a specific mechanical command),
    it should be silent. If called by player typing "/drop", LLM handles narration,
    so this just does mechanics.
    
    Args:
        game_state: The current game state.
        args: Item ID or name to drop, and optional quantity.
            
    Returns:
        CommandResult indicating success or failure.
    """
    if not args:
        return CommandResult.invalid("Please specify an item to drop.")
    
    inventory = get_inventory_manager()
    item_id_or_name = " ".join(args) # Join all args to handle multi-word item names
    quantity_to_drop = 1 # Default to dropping 1 or whole stack if not specified otherwise

    # Crude check for quantity at the end of the string
    if len(args) > 1 and args[-1].isdigit():
        try:
            quantity_to_drop = int(args[-1])
            item_id_or_name = " ".join(args[:-1]) # Remove quantity from name string
            if quantity_to_drop <= 0:
                return CommandResult.invalid("Quantity must be a positive number.")
        except ValueError:
            # Last arg wasn't a number, assume it's part of the name
            pass
    
    item_to_drop = inventory.get_item(item_id_or_name) # Try ID first
    if not item_to_drop: # Try name
        found_items = inventory.find_items(name=item_id_or_name)
        if found_items:
            if len(found_items) == 1:
                item_to_drop = found_items[0]
            else:
                # If multiple items match name, player needs to be more specific or use ID
                # For now, we won't output this to game window, just log.
                matched_names_log = [f"'{i.name}' (ID: {i.id})" for i in found_items[:3]]
                logger.warning(f"Drop command: Multiple items match '{item_id_or_name}': {', '.join(matched_names_log)}. Aborting mechanical drop.")
                return CommandResult.failure(f"Multiple items match '{item_id_or_name}'. Please use item ID.")
    
    if not item_to_drop:
        logger.warning(f"Drop command: Item '{item_id_or_name}' not found for mechanical drop.")
        return CommandResult.failure(f"Item '{item_id_or_name}' not found in your inventory.")
    
    # Check if item is equipped (this check is also in MainWindow, but good to have here for direct command use)
    if inventory.is_item_equipped(item_to_drop.id):
        logger.warning(f"Drop command: Attempt to drop equipped item '{item_to_drop.name}'. Must be unequipped first.")
        return CommandResult.failure(f"You cannot drop equipped items. Unequip {item_to_drop.name} first.")
    
    actual_quantity_in_stack = item_to_drop.quantity
    quantity_being_dropped = quantity_to_drop

    if item_to_drop.is_stackable and quantity_to_drop < actual_quantity_in_stack:
        # Dropping part of a stack
        success = inventory.remove_item(item_to_drop.id, quantity_being_dropped)
    else:
        # Dropping a non-stackable item or the entire stack
        quantity_being_dropped = actual_quantity_in_stack # Ensure we log the correct amount if dropping whole stack
        success = inventory.remove_item(item_to_drop.id, quantity_being_dropped) # quantity arg will be ignored for non-stackable or if > stack

    if success:
        logger.info(f"Mechanically dropped {quantity_being_dropped}x '{item_to_drop.name}' (ID: {item_to_drop.id}).")
        # The message here will be suppressed by process_direct_command if UI-initiated
        # and LLM narration is expected. If called mechanically post-LLM, this message is fine.
        # For now, let drop_command return a message, and calling context decides to show it.
        # To make it silent for UI flow, InputRouter/CommandHandler needs to know not to echo it.
        # The current refactor in InputRouter should handle suppressing echo for UI-initiated "drop {uuid}".
        # For typed "/drop sword", the LLM provides narration.
        # The core issue is if *this* command's success message gets output *in addition* to LLM.
        #
        # Decision: This mechanical command should be silent. The narration comes from LLM.
        # The CommandResult can still indicate success/failure for internal logic.
        # The `process_direct_command` will now suppress this message if it's a UI-initiated drop.
        return CommandResult.success(f"You dropped {quantity_being_dropped}x {item_to_drop.name}.", data={"dropped_item_id": item_to_drop.id, "quantity": quantity_being_dropped})
    else:
        logger.error(f"Mechanical drop failed for '{item_to_drop.name}' (ID: {item_to_drop.id}).")
        return CommandResult.failure(f"Failed to drop {item_to_drop.name}.")
# Additional functions to integrate with the narrative item manager

def handle_item_discovery(game_state: GameState, item_data: dict) -> CommandResult:
    """
    Handle the discovery of an item in the narrative.
    
    This function would be called by the LLM via the ITEM_DISCOVER command.
    
    Args:
        game_state: The current game state.
        item_data: Item discovery data from the LLM.
            
    Returns:
        CommandResult with discovery information.
    """
    # This function would interface with the NarrativeItemManager
    # to handle item discovery in the game world
    # For now, return a placeholder
    return CommandResult.success("Item discovery placeholder.")

```

### File: core\inventory\inventory_item_operations.py

```python
#!/usr/bin/env python3
"""
Inventory item operations module.

This module extends the base inventory with methods
for adding, removing, and managing items.
"""

from typing import Dict, List, Optional, Any, Union
import logging
import copy

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.inventory_base import InventoryBase
# Lazy getter to avoid circular import during module import time
# Do not import get_state_manager at module scope; resolve it when called
def get_state_manager():
    from core.base.state.state_manager import get_state_manager as _get
    return _get()
try:
    from core.game_flow.event_log import record_item_delta
except Exception:
    record_item_delta = lambda *args, **kwargs: None

# Get module logger
logger = get_logger("Inventory")


class InventoryItemOperations(InventoryBase):
    """
    Inventory manager with item manipulation operations.
    
    This class extends the base inventory with methods to add, remove,
    and manage items.
    """
    
    def can_add_item(self, item: Item, quantity: int = 1) -> bool:
        """
        Check if an item can be added to the inventory.
        
        Args:
            item: The item to add.
            quantity: The quantity to add.
            
        Returns:
            True if the item can be added, False otherwise.
        """
        # Check weight limit
        new_weight = self.get_current_weight() + (item.weight * quantity)
        if new_weight > self._weight_limit:
            return False
        
        # Check slot limit for non-stackable items or new stacks
        if not item.is_stackable:
            if self.get_used_slots() + quantity > self._slot_limit:
                return False
        else:
            # For stackable items, check if can be combined with existing items
            existing_item = self.find_stackable_item(item)
            if not existing_item:
                # New stack
                if self.get_used_slots() + 1 > self._slot_limit:
                    return False
            elif existing_item.quantity + quantity > existing_item.stack_limit:
                # Would exceed stack limit, need a new stack
                remaining = (existing_item.quantity + quantity) - existing_item.stack_limit
                if self.get_used_slots() + 1 > self._slot_limit:
                    return False
        
        return True
    
    def find_stackable_item(self, item: Item) -> Optional[Item]:
        """
        Find an existing stackable item that can be combined with the given item.
        
        Args:
            item: The item to find a stack for.
            
        Returns:
            An existing Item that can be stacked with the given item, or None.
        """
        if not item.is_stackable:
            return None
        
        # Look for existing items that can accept more quantity
        for existing_item in self._items.values():
            if not existing_item.is_stackable:
                continue
            if existing_item.quantity >= existing_item.stack_limit:
                continue

            # Primary rule: identical template_id stacks merge
            if existing_item.template_id and item.template_id and existing_item.template_id == item.template_id:
                return existing_item

            # Fallback rule: allow merging by identical properties for items created without template_id
            # This avoids duplicate-name suffixing like "(2)" for functionally identical items
            if self._can_stack_by_properties(existing_item, item):
                return existing_item
        
        return None

    def _can_stack_by_properties(self, a: Item, b: Item) -> bool:
        """
        Determine if two items can stack based on core properties when template_id doesn't match.
        Conservative: requires identical name (ignoring trailing numeric suffix), item_type, rarity,
        consumable flag, tags, weight, value, and no differing stats or custom_properties.
        """
        try:
            # Normalize trailing numeric suffix " (n)" often used for disambiguation
            import re
            def norm(name: str) -> str:
                return re.sub(r" \(\d+\)$", "", (name or "").strip()).lower()

            if norm(a.name) != norm(b.name):
                return False
            if a.item_type != b.item_type:
                return False
            if a.rarity != b.rarity:
                return False
            if bool(a.is_consumable) != bool(b.is_consumable):
                return False
            # Tags as sets must match
            if set(a.tags or []) != set(b.tags or []):
                return False
            # Ensure identical base economics/weight
            if (a.value != b.value):
                return False
            if abs((a.weight or 0.0) - (b.weight or 0.0)) > 1e-6:
                return False
            # Do not merge if either has stats and they differ
            if (a.stats and not b.stats) or (b.stats and not a.stats):
                return False
            if a.stats and b.stats:
                amap = {s.name: (s.value, getattr(s, 'display_name', None), getattr(s, 'is_percentage', False)) for s in a.stats}
                bmap = {s.name: (s.value, getattr(s, 'display_name', None), getattr(s, 'is_percentage', False)) for s in b.stats}
                if amap != bmap:
                    return False
            # Do not merge if custom_properties differ
            if (getattr(a, 'custom_properties', {}) or getattr(b, 'custom_properties', {})):
                if getattr(a, 'custom_properties', {}) != getattr(b, 'custom_properties', {}):
                    return False
            return True
        except Exception:
            return False
    
    def add_item(self, item: Item, quantity: int = 1) -> List[str]:
        """
        Add an item to the inventory. Handles name collision for non-template items.
        
        Args:
            item: The item to add.
            quantity: The quantity to add.
            
        Returns:
            List of item IDs that were added.
        """
        # Instance ID logging at the start of the method
        manager_instance_id = getattr(self, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')
        logger.debug(f"InventoryManager ({manager_instance_id}) add_item called for '{item.name}', qty: {quantity}. Current item count: {len(self._items)}")

        if quantity <= 0:
            return []
        
        # Check if we can add the item
        if not self.can_add_item(item, quantity):
            logger.warning(f"InventoryManager ({manager_instance_id}) Cannot add item '{item.name}' to inventory. Weight or slot limit exceeded.")
            return []
        
        added_item_ids = []
        
        original_item_name_for_collision_check = item.name
        is_new_stackable_instance = item.is_stackable and not self.find_stackable_item(item)
        
        if (not item.is_stackable or is_new_stackable_instance) and not item.is_template:
            current_name = item.name
            name_count = 1
            all_inventory_names = [i.name for i in self._items.values()]
            
            if current_name in all_inventory_names:
                name_count = 2 
                while f"{original_item_name_for_collision_check} ({name_count})" in all_inventory_names:
                    name_count += 1
                item.name = f"{original_item_name_for_collision_check} ({name_count})"
                logger.info(f"InventoryManager ({manager_instance_id}) Item name collision for '{original_item_name_for_collision_check}'. Renamed to '{item.name}'.")

        if item.is_stackable:
            existing_item = self.find_stackable_item(item)
            
            if existing_item:
                # Upgrade stack limit if needed, preferring canonical template value, then the larger of the two
                try:
                    canonical_limit = None
                    if getattr(existing_item, 'template_id', None):
                        try:
                            from core.inventory.item_template_loader import get_item_template_loader
                            tl = get_item_template_loader()
                            tmpl = tl.get_template(existing_item.template_id)
                            if tmpl and getattr(tmpl, 'is_stackable', False):
                                canonical_limit = getattr(tmpl, 'stack_limit', None)
                        except Exception:
                            pass
                    new_limit = max(int(getattr(existing_item, 'stack_limit', 1) or 1),
                                    int(getattr(item, 'stack_limit', 1) or 1),
                                    int(canonical_limit) if canonical_limit is not None else 1)
                    if new_limit != existing_item.stack_limit and getattr(existing_item, 'is_stackable', False):
                        existing_item.stack_limit = new_limit
                except Exception:
                    pass

                space_in_stack = max(0, int(existing_item.stack_limit) - int(existing_item.quantity))
                amount_to_add = min(int(quantity), space_in_stack)
                existing_item.quantity += amount_to_add
                added_item_ids.append(existing_item.id)
                remaining_quantity_to_add = int(quantity) - amount_to_add
                if remaining_quantity_to_add > 0:
                    current_name_for_new_stacks = original_item_name_for_collision_check
                    while remaining_quantity_to_add > 0:
                        temp_new_item_for_naming = self._create_item_copy(item, 1)
                        temp_new_item_for_naming.name = current_name_for_new_stacks
                        all_inventory_names_for_new_stack_check = [i.name for i in self._items.values()]
                        final_name_for_new_stack = temp_new_item_for_naming.name
                        if final_name_for_new_stack in all_inventory_names_for_new_stack_check:
                            new_stack_name_count = 2
                            while f"{current_name_for_new_stacks} ({new_stack_name_count})" in all_inventory_names_for_new_stack_check:
                                new_stack_name_count += 1
                            final_name_for_new_stack = f"{current_name_for_new_stacks} ({new_stack_name_count})"
                        new_item_stack = self._create_item_copy(item, min(remaining_quantity_to_add, item.stack_limit))
                        new_item_stack.name = final_name_for_new_stack
                        self._items[new_item_stack.id] = new_item_stack
                        added_item_ids.append(new_item_stack.id)
                        remaining_quantity_to_add -= new_item_stack.quantity
            else:
                current_name_for_new_stacks = item.name 
                first_stack_quantity = min(quantity, item.stack_limit)
                item_for_first_stack = self._create_item_copy(item, first_stack_quantity) 
                item_for_first_stack.name = item.name 
                self._items[item_for_first_stack.id] = item_for_first_stack
                added_item_ids.append(item_for_first_stack.id)
                remaining_quantity_to_add = quantity - first_stack_quantity
                while remaining_quantity_to_add > 0:
                    all_inventory_names_for_new_stack_check = [i.name for i in self._items.values()]
                    final_name_for_new_stack = original_item_name_for_collision_check
                    if final_name_for_new_stack in all_inventory_names_for_new_stack_check:
                        new_stack_name_count = 2
                        while f"{original_item_name_for_collision_check} ({new_stack_name_count})" in all_inventory_names_for_new_stack_check:
                            new_stack_name_count += 1
                        final_name_for_new_stack = f"{original_item_name_for_collision_check} ({new_stack_name_count})"
                    new_item_further_stack = self._create_item_copy(item, min(remaining_quantity_to_add, item.stack_limit))
                    new_item_further_stack.name = final_name_for_new_stack 
                    self._items[new_item_further_stack.id] = new_item_further_stack
                    added_item_ids.append(new_item_further_stack.id)
                    remaining_quantity_to_add -= new_item_further_stack.quantity
        else:
            item_to_add_name = item.name
            new_item_instance = self._create_item_copy(item, 1)
            new_item_instance.name = item_to_add_name 
            self._items[new_item_instance.id] = new_item_instance
            added_item_ids.append(new_item_instance.id)
            for i in range(1, quantity):
                next_item_for_naming = self._create_item_copy(item, 1)
                next_item_for_naming.name = original_item_name_for_collision_check
                all_inventory_names_for_next_item_check = [i.name for i in self._items.values()]
                final_name_for_next_item = next_item_for_naming.name
                if final_name_for_next_item in all_inventory_names_for_next_item_check:
                    next_item_name_count = 2
                    while f"{original_item_name_for_collision_check} ({next_item_name_count})" in all_inventory_names_for_next_item_check:
                        next_item_name_count += 1
                    final_name_for_next_item = f"{original_item_name_for_collision_check} ({next_item_name_count})"
                actual_new_item_instance = self._create_item_copy(item, 1)
                actual_new_item_instance.name = final_name_for_next_item
                self._items[actual_new_item_instance.id] = actual_new_item_instance
                added_item_ids.append(actual_new_item_instance.id)
        
        logger.info(f"InventoryManager ({manager_instance_id}) Added {quantity}x instances of '{original_item_name_for_collision_check}'. Resulting IDs: {added_item_ids}. Total items now: {len(self._items)}")
        
        # Record event log entry (ItemDelta) for testing/evidence
        try:
            state = get_state_manager().current_state
            if state is not None:
                item_id_for_log = getattr(item, 'template_id', None) or (getattr(item, 'id', None) or original_item_name_for_collision_check)
                record_item_delta(state, item_id=item_id_for_log, delta=int(quantity), source='inventory_add')
        except Exception:
            pass
        
        return added_item_ids
    
    def remove_item(self, item_id: str, quantity: int = 1) -> bool:
        """
        Remove an item from the inventory.
        
        Args:
            item_id: The ID of the item to remove.
            quantity: The quantity to remove.
            
        Returns:
            True if the item was removed, False otherwise.
        """
        if item_id not in self._items:
            logger.warning(f"Item with ID '{item_id}' not found in inventory")
            return False
        
        item = self._items[item_id]
        
        if quantity <= 0:
            return False
        
        if item.is_stackable:
            if quantity >= item.quantity:
                # Remove the entire stack
                removed_qty = item.quantity
                self._items.pop(item_id)
                logger.info(f"Removed {removed_qty}x '{item.name}' from inventory (entire stack)")
            else:
                # Remove part of the stack
                item.quantity -= quantity
                removed_qty = quantity
                logger.info(f"Removed {quantity}x '{item.name}' from inventory (partial stack)")
        else:
            # Non-stackable items
            removed_qty = 1
            self._items.pop(item_id)
            logger.info(f"Removed '{item.name}' from inventory")
        
        # Record event log entry (ItemDelta) for testing/evidence
        try:
            state = get_state_manager().current_state
            if state is not None:
                item_id_for_log = getattr(item, 'template_id', None) or (getattr(item, 'id', None) or item.name)
                record_item_delta(state, item_id=item_id_for_log, delta=-int(removed_qty), source='inventory_remove')
        except Exception:
            pass
        
        return True
    
    def merge_stacks(self, source_id: str, target_id: str) -> bool:
        """
        Merge two stacks of items.
        
        Args:
            source_id: ID of the source stack to merge from.
            target_id: ID of the target stack to merge into.
            
        Returns:
            True if stacks were merged, False otherwise.
        """
        # Get both items
        source_item = self.get_item(source_id)
        target_item = self.get_item(target_id)
        
        # Check if both items exist and are stackable
        if not source_item or not target_item:
            logger.warning("Cannot merge stacks: One or both items not found")
            return False
        
        if not source_item.is_stackable or not target_item.is_stackable:
            logger.warning("Cannot merge stacks: One or both items are not stackable")
            return False
        
        # Check if items can be stacked together (same template)
        if source_item.template_id != target_item.template_id:
            logger.warning("Cannot merge stacks: Items are of different types")
            return False
        
        # Calculate how much we can move
        space_in_target = target_item.stack_limit - target_item.quantity
        amount_to_move = min(source_item.quantity, space_in_target)
        
        if amount_to_move <= 0:
            logger.warning("Cannot merge stacks: Target stack is already at capacity")
            return False
        
        # Move items
        target_item.quantity += amount_to_move
        
        # Update or remove source stack
        if amount_to_move == source_item.quantity:
            # Source stack is empty, remove it
            self._items.pop(source_id)
        else:
            # Update source stack
            source_item.quantity -= amount_to_move
        
        logger.info(f"Merged {amount_to_move}x '{source_item.name}' from stack {source_id} to {target_id}")
        return True
    
    def split_stack(self, item_id: str, quantity: int) -> Optional[str]:
        """
        Split a stack of items into two stacks.
        
        Args:
            item_id: ID of the stack to split.
            quantity: Amount to put in the new stack.
            
        Returns:
            ID of the new stack if successful, None otherwise.
        """
        # Get the item
        item = self.get_item(item_id)
        
        # Check if item exists and is stackable
        if not item:
            logger.warning(f"Cannot split stack: Item {item_id} not found")
            return None
        
        if not item.is_stackable:
            logger.warning(f"Cannot split stack: Item {item_id} is not stackable")
            return None
        
        # Check if quantity is valid
        if quantity <= 0 or quantity >= item.quantity:
            logger.warning(f"Cannot split stack: Invalid quantity {quantity}")
            return None
        
        # Check if we have a free slot
        if self.get_free_slots() <= 0:
            logger.warning("Cannot split stack: No free slots available")
            return None
        
        # Create new stack
        new_item = self._create_item_copy(item, quantity)
        
        # Update original stack
        item.quantity -= quantity
        
        # Add new stack to inventory
        self._items[new_item.id] = new_item
        
        logger.info(f"Split {quantity}x '{item.name}' from stack {item_id} to new stack {new_item.id}")
        return new_item.id
    
    def _create_item_copy(self, source_item: Item, quantity: int = 1) -> Item:
        """
        Create a copy of an item with a new ID.
        
        Args:
            source_item: The item to copy.
            quantity: The quantity for the new item.
            
        Returns:
            A new Item instance.
        """
        # Create a new item with the same properties
        new_item = Item(
            name=source_item.name,
            description=source_item.description,
            item_type=source_item.item_type,
            rarity=source_item.rarity,
            weight=source_item.weight,
            value=source_item.value,
            icon_path=source_item.icon_path,
            is_equippable=source_item.is_equippable,
            equip_slots=source_item.equip_slots.copy() if source_item.equip_slots else [],
            stats=copy.deepcopy(source_item.stats),
            is_consumable=source_item.is_consumable,
            is_stackable=source_item.is_stackable,
            stack_limit=source_item.stack_limit,
            quantity=quantity,
            is_quest_item=source_item.is_quest_item,
            durability=source_item.durability,
            current_durability=source_item.current_durability,
            tags=source_item.tags.copy() if source_item.tags else [],
            template_id=source_item.template_id,
            source=source_item.source,
            custom_properties=copy.deepcopy(source_item.custom_properties)
        )
        
        # Copy known properties
        new_item.known_properties = source_item.known_properties.copy()
        
        return new_item

```

### File: core\inventory\inventory_limits.py

```python
#!/usr/bin/env python3
"""
Inventory limits module.

This module extends the inventory system with methods to manage
weight and slot limits.
"""

from typing import Dict
import logging

from core.utils.logging_config import get_logger
from core.inventory.inventory_base import InventoryBase

# Get module logger
logger = get_logger("Inventory")


class InventoryLimits(InventoryBase):
    """
    Inventory manager with limit management operations.
    
    This class extends the base inventory with methods for managing
    weight and slot limits.
    """
    
    def update_weight_limits(self) -> None:
        """Update weight limits based on modifiers."""
        # Calculate total weight limit from base + modifiers
        total_modifier = sum(self._weight_limit_modifiers.values())
        self._weight_limit = self._weight_limit_base + total_modifier
        logger.debug(f"Updated weight limit to {self._weight_limit}")
    
    def update_slot_limits(self) -> None:
        """Update slot limits based on modifiers."""
        # Calculate total slot limit from base + modifiers
        total_modifier = sum(self._slot_limit_modifiers.values())
        self._slot_limit = self._slot_limit_base + total_modifier
        logger.debug(f"Updated slot limit to {self._slot_limit}")
    
    def set_weight_limit_base(self, base_limit: float) -> None:
        """
        Set the base weight limit.
        
        Args:
            base_limit: New base weight limit value
        """
        self._weight_limit_base = base_limit
        self.update_weight_limits()
        logger.info(f"Set base weight limit to {base_limit}")
    
    def set_slot_limit_base(self, base_limit: int) -> None:
        """
        Set the base slot limit.
        
        Args:
            base_limit: New base slot limit value
        """
        self._slot_limit_base = base_limit
        self.update_slot_limits()
        logger.info(f"Set base slot limit to {base_limit}")
    
    def add_weight_modifier(self, source: str, value: float) -> None:
        """
        Add a weight limit modifier.
        
        Args:
            source: Identifier for the source of this modifier
            value: The value to add to the weight limit
        """
        self._weight_limit_modifiers[source] = value
        self.update_weight_limits()
        logger.info(f"Added weight modifier '{source}': {value}")
    
    def remove_weight_modifier(self, source: str) -> None:
        """
        Remove a weight limit modifier.
        
        Args:
            source: Identifier for the modifier to remove
        """
        if source in self._weight_limit_modifiers:
            value = self._weight_limit_modifiers.pop(source)
            self.update_weight_limits()
            logger.info(f"Removed weight modifier '{source}': {value}")
    
    def add_slot_modifier(self, source: str, value: int) -> None:
        """
        Add a slot limit modifier.
        
        Args:
            source: Identifier for the source of this modifier
            value: The value to add to the slot limit
        """
        self._slot_limit_modifiers[source] = value
        self.update_slot_limits()
        logger.info(f"Added slot modifier '{source}': {value}")
    
    def remove_slot_modifier(self, source: str) -> None:
        """
        Remove a slot limit modifier.
        
        Args:
            source: Identifier for the modifier to remove
        """
        if source in self._slot_limit_modifiers:
            value = self._slot_limit_modifiers.pop(source)
            self.update_slot_limits()
            logger.info(f"Removed slot modifier '{source}': {value}")
    
    def get_weight_limit_info(self) -> Dict[str, float]:
        """
        Get detailed information about weight limits.
        
        Returns:
            Dictionary with base, modifiers, and total weight limit.
        """
        return {
            "base": self._weight_limit_base,
            "modifiers": dict(self._weight_limit_modifiers),
            "total": self._weight_limit
        }
    
    def get_slot_limit_info(self) -> Dict[str, int]:
        """
        Get detailed information about slot limits.
        
        Returns:
            Dictionary with base, modifiers, and total slot limit.
        """
        return {
            "base": self._slot_limit_base,
            "modifiers": dict(self._slot_limit_modifiers),
            "total": self._slot_limit
        }

```

### File: core\inventory\inventory_manager.py

```python
"""
Complete inventory management system.

This module implements the InventoryManager class which combines all
inventory-related functionality into a single interface.
"""

from typing import Dict, List, Optional, Any, Tuple, Set, Union
import logging
import json
import os
import uuid

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_enums import ItemType, ItemRarity, EquipmentSlot
from core.inventory.item_serialization import item_to_dict, dict_to_item
from core.inventory.inventory_item_operations import InventoryItemOperations
from core.inventory.inventory_limits import InventoryLimits
from core.inventory.equipment_manager import EquipmentManager
from core.inventory.currency_manager import CurrencyManager
from core.base.config import get_config

# Get module logger
logger = get_logger("Inventory")


class InventoryManager(InventoryItemOperations, InventoryLimits, EquipmentManager):
    """
    Complete inventory manager.
    
    This class combines item operations, weight/slot limits, equipment management,
    and currency handling into a unified interface.
    """
    
    def __init__(self):
        """Initialize the inventory manager."""
        # Check if already initialized (part of some singleton patterns, though get_inventory_manager handles it)
        # For this class, super().__init__() is important to call base initializers.
        super().__init__() # Calls __init__ of InventoryItemOperations, InventoryLimits, EquipmentManager
        
        # Initialize currency manager
        self._currency = CurrencyManager()
        
        # Add an instance ID for logging/debugging
        # This should be set ONCE per actual object instantiation.
        if not hasattr(self, 'instance_id_for_debug'): # Set only if not already set (e.g. by a subclass's super call)
            self.instance_id_for_debug = str(uuid.uuid4())
        
        # Reference to stats manager for equipment modifier synchronization
        self._stats_manager = None
        
        logger.info(f"InventoryManager CLASS __init__ called. Instance ID: {self.instance_id_for_debug}")
    
    @property
    def inventory_id(self) -> Optional[str]:
        """Compatibility identifier for this inventory instance (maps to instance_id_for_debug)."""
        return getattr(self, 'instance_id_for_debug', None)
    
    @property
    def currency(self) -> CurrencyManager:
        """Get the currency manager."""
        return self._currency
    
    def load_from_dict(self, data: Dict[str, Any]) -> None:
        """
        Load inventory and equipment state into this existing manager instance.
        This updates items, limits, equipment, and currency in-place.
        """
        try:
            # Clear existing data first
            self._items = {}
            
            # Load items
            for item_id, item_data in data.get("items", {}).items():
                item = dict_to_item(item_data)
                self._items[item_id] = item
            
            # Load inventory limits
            self._weight_limit_base = data.get("weight_limit_base", 100.0)
            self._weight_limit_modifiers = data.get("weight_limit_modifiers", {})
            self._slot_limit_base = data.get("slot_limit_base", 20)
            self._slot_limit_modifiers = data.get("slot_limit_modifiers", {})
            self.update_weight_limits()
            self.update_slot_limits()
            
            # Load equipment mapping (slot names back to enum -> item IDs)
            # Preserve string IDs in _equipment per EquipmentManager's internal representation
            for slot_name, item_id in data.get("equipment", {}).items():
                try:
                    slot = EquipmentSlot(slot_name)
                    self._equipment[slot] = item_id
                except ValueError:
                    logger.warning(f"Invalid equipment slot in saved data: {slot_name}")
            
            # Load currency
            currency_data = data.get("currency", {})
            if "total_copper" in currency_data:
                self._currency.set_currency(currency_data["total_copper"])
            else:
                gold = currency_data.get("gold", 0)
                silver = currency_data.get("silver", 0)
                copper = currency_data.get("copper", 0)
                self._currency.set_mixed_currency(gold, silver, copper)
            
            # Refresh equipment-derived modifiers
            try:
                self._update_equipment_modifiers()
            except Exception:
                pass
            
            logger.info("InventoryManager state loaded from dict (in-place).")
        except Exception as e:
            logger.error(f"Error loading inventory from dict into existing manager: {e}")
    
    def to_dict(self, include_unknown: bool = True) -> Dict[str, Any]:
        """
        Convert the inventory to a dictionary for serialization.
        
        Args:
            include_unknown: Whether to include unknown item properties.
            
        Returns:
            Dictionary representation of the inventory.
        """
        return {
            # Basic inventory data
            "items": {item_id: item_to_dict(item, include_unknown) 
                     for item_id, item in self._items.items()},
            
            # Inventory limits
            "weight_limit_base": self._weight_limit_base,
            "weight_limit_modifiers": self._weight_limit_modifiers,
            "slot_limit_base": self._slot_limit_base,
            "slot_limit_modifiers": self._slot_limit_modifiers,
            
            # Equipment data
            "equipment": {slot.value: item_id for slot, item_id in self._equipment.items() 
                         if item_id is not None},
            
            # Currency data
            "currency": self._currency.get_currency_dict()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'InventoryManager':
        """
        Create an inventory manager from a dictionary.
        
        Args:
            data: Dictionary containing inventory data.
            
        Returns:
            An InventoryManager instance.
        """
        inventory = cls()
        
        # Load items
        for item_id, item_data in data.get("items", {}).items():
            item = dict_to_item(item_data)
            inventory._items[item_id] = item
        
        # Load inventory limits
        inventory._weight_limit_base = data.get("weight_limit_base", 100.0)
        inventory._weight_limit_modifiers = data.get("weight_limit_modifiers", {})
        inventory._slot_limit_base = data.get("slot_limit_base", 20)
        inventory._slot_limit_modifiers = data.get("slot_limit_modifiers", {})
        inventory.update_weight_limits()
        inventory.update_slot_limits()
        
        # Load equipment
        for slot_name, item_id in data.get("equipment", {}).items():
            try:
                slot = EquipmentSlot(slot_name)
                inventory._equipment[slot] = item_id
            except ValueError:
                logger.warning(f"Invalid equipment slot in saved data: {slot_name}")
        
        # Load currency
        currency_data = data.get("currency", {})
        if "total_copper" in currency_data:
            inventory._currency.set_currency(currency_data["total_copper"])
        else:
            # Fallback to individual denominations if total not available
            gold = currency_data.get("gold", 0)
            silver = currency_data.get("silver", 0)
            copper = currency_data.get("copper", 0)
            inventory._currency.set_mixed_currency(gold, silver, copper)
        
        return inventory
    
    def set_stats_manager(self, stats_manager) -> None:
        """
        Set the stats manager reference for equipment modifier synchronization.
        
        Args:
            stats_manager: The stats manager instance
        """
        self._stats_manager = stats_manager
        logger.debug("Stats manager reference set in InventoryManager")
        
        # If we already have equipment modifiers, sync them now
        if hasattr(self, '_equipment_modifiers') and self._equipment_modifiers:
            self._sync_stats_modifiers()
    
    def _sync_stats_modifiers(self) -> None:
        """
        Override of EquipmentManager method to trigger stats synchronization.
        In addition to any upstream hooks, this wires equipment-based typed resistances into the StatsManager.
        """
        if not self._stats_manager:
            logger.debug("No stats manager available for equipment modifier sync")
            return
        # Load allowed effect types from combat config (fallback to defaults)
        try:
            cfg = get_config()
            allowed_types = cfg.get("combat.damage.types", []) or []
            if not isinstance(allowed_types, list) or not allowed_types:
                allowed_types = ["slashing","piercing","bludgeoning","fire","cold","lightning","poison","acid","arcane"]
            allowed_types = [str(x).strip().lower() for x in allowed_types if isinstance(x, str)]
        except Exception:
            allowed_types = ["slashing","piercing","bludgeoning","fire","cold","lightning","poison","acid","arcane"]
        # First, clear previous equipment-based contributions for all slots
        try:
            from core.inventory.item_enums import EquipmentSlot
            for slot in EquipmentSlot:
                try:
                    self._stats_manager.remove_resistance_contribution(f"equip_{slot.value}")
                except Exception:
                    pass
        except Exception as clr_err:
            logger.debug(f"Error clearing previous resistance contributions: {clr_err}")
        # Apply contributions from currently equipped items that define typed_resistances in custom_properties
        try:
            for slot, item_id in self._equipment.items():
                if not item_id:
                    continue
                it = self.get_item(item_id)
                if not it:
                    continue
                cp = getattr(it, 'custom_properties', {}) if hasattr(it, 'custom_properties') else {}
                if not isinstance(cp, dict):
                    continue
                typed_map = None
                # Prefer explicit key to avoid conflicts with generic names
                if 'typed_resistances' in cp and isinstance(cp['typed_resistances'], dict):
                    typed_map = cp['typed_resistances']
                # Build sanitized mapping from allowed types only
                if isinstance(typed_map, dict):
                    sanitized: Dict[str, float] = {}
                    for k, v in typed_map.items():
                        try:
                            dt = str(k or "").strip().lower()
                            if dt in allowed_types:
                                sanitized[dt] = float(v)
                        except Exception:
                            continue
                    if sanitized:
                        try:
                            self._stats_manager.set_resistance_contribution(f"equip_{slot.value}", sanitized)
                            logger.debug(f"Applied typed resistances from {it.name} in {slot.value}: {sanitized}")
                        except Exception as ap_err:
                            logger.debug(f"Failed applying typed resistances for {it.name}: {ap_err}")
        except Exception as apply_err:
            logger.debug(f"Error applying equipment typed resistances: {apply_err}")
        # Upstream hook if present (non-critical)
        if hasattr(self._stats_manager, 'sync_equipment_modifiers'):
            try:
                self._stats_manager.sync_equipment_modifiers()
                logger.debug("Triggered equipment modifier synchronization with stats manager")
            except Exception as e:
                logger.error(f"Error synchronizing equipment modifiers with stats manager: {e}")
    
    def save_to_file(self, filepath: str, include_unknown: bool = True) -> bool:
        """
        Save the inventory to a JSON file.
        
        Args:
            filepath: Path to the file.
            include_unknown: Whether to include unknown item properties.
            
        Returns:
            True if successful, False otherwise.
        """
        try:
            # Convert to dictionary
            data = self.to_dict(include_unknown)
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            # Write to file
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
                
            logger.info(f"Saved inventory to {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Error saving inventory to {filepath}: {e}")
            return False
    
    @classmethod
    def load_from_file(cls, filepath: str) -> Optional['InventoryManager']:
        """
        Load inventory from a JSON file.
        
        Args:
            filepath: Path to the file.
            
        Returns:
            An InventoryManager instance, or None if loading failed.
        """
        try:
            # Read from file
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            # Create inventory from data
            inventory = cls.from_dict(data)
            
            logger.info(f"Loaded inventory from {filepath}")
            return inventory
            
        except Exception as e:
            logger.error(f"Error loading inventory from {filepath}: {e}")
            return None
    
    def get_inventory_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the inventory.
        
        Returns:
            Dictionary with inventory summary information.
        """
        # Count items by type
        item_counts = {}
        for item_type in ItemType:
            count = len(self.get_items_by_type(item_type))
            if count > 0:
                item_counts[item_type.value] = count
        
        # Count items by rarity
        rarity_counts = {}
        for item in self._items.values():
            rarity = item.rarity.value
            rarity_counts[rarity] = rarity_counts.get(rarity, 0) + 1
        
        # Get equipment summary
        equipment_summary = {}
        for slot, item_id in self._equipment.items():
            if item_id:
                item = self.get_item(item_id)
                if item:
                    equipment_summary[slot.value] = {
                        "id": item.id,
                        "name": item.name,
                        "rarity": item.rarity.value
                    }
        
        return {
            "total_items": len(self._items),
            "used_slots": self.get_used_slots(),
            "free_slots": self.get_free_slots(),
            "slot_limit": self._slot_limit,
            "current_weight": self.get_current_weight(),
            "weight_limit": self._weight_limit,
            "items_by_type": item_counts,
            "items_by_rarity": rarity_counts,
            "currency": self._currency.get_currency_dict(),
            "equipped_items": equipment_summary
        }
    
    def get_item_discovery_stats(self) -> Dict[str, Any]:
        """
        Get statistics about item property discovery.
        
        Returns:
            Dictionary with discovery statistics.
        """
        # Count number of known properties for each item
        total_properties = 0
        total_known_properties = 0
        items_with_all_known = 0
        
        for item in self._items.values():
            # Get all possible properties
            all_properties = set(dir(item))
            # Filter out private properties and methods
            all_properties = {prop for prop in all_properties 
                              if not prop.startswith('_') and not callable(getattr(item, prop))}
            # Add stat properties
            for stat in item.stats:
                all_properties.add(f"stat_{stat.name}")
            # Add custom properties
            for custom_prop_key in item.custom_properties:
                all_properties.add(f"custom_{custom_prop_key}")
            # Add dice_roll_effects as a single knowable property concept
            if item.dice_roll_effects:
                 all_properties.add("dice_roll_effects")
            
            # Count known properties
            known = len(item.known_properties)
            total = len(all_properties)
            
            total_properties += total
            total_known_properties += known
            
            if known == total:
                items_with_all_known += 1
        
        # Calculate discovery percentage
        discovery_percentage = 0
        if total_properties > 0:
            discovery_percentage = (total_known_properties / total_properties) * 100
        
        return {
            "total_items": len(self._items),
            "total_properties": total_properties,
            "known_properties": total_known_properties,
            "discovery_percentage": discovery_percentage,
            "items_fully_discovered": items_with_all_known
        }
    
    def clear(self) -> None:
        """Clear all inventory data."""
        logger.info(f"InventoryManager ({getattr(self, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}) clear() called.")
        # Clear items
        self._items = {}
        
        # Reset limits
        self._weight_limit_base = 100.0
        self._weight_limit_modifiers = {}
        self._slot_limit_base = 20
        self._slot_limit_modifiers = {}
        self.update_weight_limits()
        self.update_slot_limits()
        
        # Clear equipment
        for slot in self._equipment:
            self._equipment[slot] = None
        
        # Clear currency
        self._currency.set_currency(0)
        
        logger.info(f"InventoryManager ({getattr(self, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}) Cleared inventory. Item count: {len(self._items)}")
        
    def discover_item_property(self, item_id: str, property_name: str) -> bool:
        """
        Discover a property of an item.
        
        Args:
            item_id: The ID of the item.
            property_name: The name of the property to discover.
            
        Returns:
            True if the property was newly discovered, False otherwise.
        """
        item = self.get_item(item_id)
        if not item:
            logger.warning(f"Cannot discover property: Item {item_id} not found")
            return False
        
        return item.discover_property(property_name)
    
    def discover_item_stat(self, item_id: str, stat_name: str) -> bool:
        """
        Discover a stat of an item.
        
        Args:
            item_id: The ID of the item.
            stat_name: The name of the stat to discover.
            
        Returns:
            True if the stat was newly discovered, False otherwise.
        """
        item = self.get_item(item_id)
        if not item:
            logger.warning(f"Cannot discover stat: Item {item_id} not found")
            return False
        
        return item.discover_stat(stat_name)
    
    def discover_all_item_properties(self, item_id: str) -> int:
        """
        Discover all properties of an item.
        
        Args:
            item_id: The ID of the item.
            
        Returns:
            The number of newly discovered properties.
        """
        item = self.get_item(item_id)
        if not item:
            logger.warning(f"Cannot discover properties: Item {item_id} not found")
            return 0
        
        # Get all possible properties
        all_properties = set(attr for attr in dir(item) if not attr.startswith('_') and not callable(getattr(item, attr)))
        # Add stat properties
        for stat in item.stats:
            all_properties.add(f"stat_{stat.name}")
        # Add custom properties
        for custom_prop_key in item.custom_properties:
            all_properties.add(f"custom_{custom_prop_key}")
        # Add dice_roll_effects as a single knowable "property"
        if item.dice_roll_effects:
            all_properties.add("dice_roll_effects") # Assuming this becomes a knowable string
        
        # Discover all properties
        count = 0
        for prop in all_properties:
            if item.discover_property(prop):
                count += 1
        
        logger.info(f"Discovered {count} properties for item {item.name}")
        return count

    def use_item(self, item_id: str, quantity: int = 1) -> Tuple[bool, str]:
        """
        Use a consumable item. This method assumes the narrative part is handled elsewhere
        and this is the mechanical effect of consumption.

        Args:
            item_id: The ID of the item to use.
            quantity: The quantity to use.

        Returns:
            A tuple (success: bool, message: str).
        """
        item = self.get_item(item_id)
        if not item:
            return False, f"Item '{item_id}' not found."
        if not item.is_consumable:
            return False, f"{item.name} is not a consumable item."
        if item.quantity < quantity:
            return False, f"Not enough {item.name} to use. Have {item.quantity}, need {quantity}."

        # TODO: Apply item effects (healing, mana restore, buffs, etc.)
        # This would involve getting item.stats, interpreting them, and calling StatsManager.
        # For now, just log and remove.
        effects_applied_msg = f"Effects of {item.name} applied (placeholder)."
        logger.info(f"Simulating effects for consuming {quantity}x {item.name}. Item stats: {item.stats}")


        if self.remove_item(item_id, quantity):
            logger.info(f"Consumed {quantity}x {item.name} (ID: {item_id}).")
            return True, f"Used {quantity}x {item.name}. {effects_applied_msg}"
        else:
            # This should ideally not happen if checks above are correct
            logger.error(f"Failed to remove item {item_id} after use confirmation.")
            return False, f"Error consuming {item.name}."

    def get_item_details_for_dialog(self, item_id: str) -> Optional[Item]:
        """
        Retrieves the full Item object for display in an ItemInfoDialog.
        This ensures all data, including known_properties, is available.
        Args:
            item_id: The ID of the item.
        Returns:
            The Item object if found, else None.
        """
        item = self.get_item(item_id)
        if not item:
            logger.warning(f"ItemInfoDialog: Item with ID '{item_id}' not found in inventory.")
            return None
        return item
```

### File: core\inventory\item.py

```python
"""
Item data structure module.

This module defines the core Item class used to represent
game items with their properties, stats, and behaviors.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Union, Any
import uuid
from datetime import datetime

from core.inventory.item_enums import ItemType, ItemRarity, EquipmentSlot
from core.inventory.item_stat import ItemStat
from core.inventory.item_effect import DiceRollEffect # Added import


@dataclass
class Item:
    """
    A game item with properties and stats.
    
    This class represents items that can be acquired, used, and equipped by the player.
    Items can have various types, rarities, and statistics.
    """
    
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    description: str = ""
    item_type: ItemType = ItemType.MISCELLANEOUS
    rarity: ItemRarity = ItemRarity.COMMON
    weight: float = 0.0
    value: int = 0  # Value in copper coins
    icon_path: Optional[str] = None
    
    # Equipment-specific properties
    is_equippable: bool = False
    equip_slots: List[EquipmentSlot] = field(default_factory=list)
    
    # Item stats and modifiers
    stats: List[ItemStat] = field(default_factory=list)
    dice_roll_effects: List[DiceRollEffect] = field(default_factory=list) # New field
    
    # Usage properties
    is_consumable: bool = False
    is_stackable: bool = False
    stack_limit: int = 1
    quantity: int = 1
    is_quest_item: bool = False
    
    # Item condition
    durability: Optional[int] = None
    current_durability: Optional[int] = None
    is_destroyed: bool = False
    
    # Item knowledge tracking
    known_properties: Set[str] = field(default_factory=set)
    discovered_at: Optional[str] = None  # ISO format datetime
    
    # Meta properties
    tags: List[str] = field(default_factory=list)
    template_id: Optional[str] = None
    is_template: bool = False
    source: str = "template"  # "template", "loot", "quest", "narrative", "player_created", etc.
    
    # Custom properties for narrative items
    custom_properties: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Initialize derived properties and defaults."""
        if isinstance(self.item_type, str):
            try:
                self.item_type = ItemType(self.item_type)
            except ValueError:
                self.item_type = ItemType.MISCELLANEOUS
        if isinstance(self.rarity, str):
            try:
                self.rarity = ItemRarity(self.rarity)
            except ValueError:
                self.rarity = ItemRarity.COMMON
            
        processed_equip_slots = []
        for slot_val in self.equip_slots:
            if isinstance(slot_val, str):
                try:
                    processed_equip_slots.append(EquipmentSlot(slot_val))
                except ValueError:
                    pass 
            elif isinstance(slot_val, EquipmentSlot):
                processed_equip_slots.append(slot_val)
        self.equip_slots = processed_equip_slots
            
        if not self.discovered_at:
            self.discovered_at = datetime.now().isoformat()
            
        if not self.known_properties:
            self.known_properties = {
                "name", "item_type", "weight", "is_stackable", "quantity",
                "is_quest_item", "tags", "icon_path", "rarity"
            }
            if self.is_equippable:
                self.known_properties.add("is_equippable")
                self.known_properties.add("equip_slots")
            
            if not self.is_template:
                self.known_properties.add("description")
                self.known_properties.add("value")
                if self.durability is not None: 
                    self.known_properties.add("durability")
                    self.known_properties.add("current_durability")
                
                # Automatically make core combat effects/stats known for instances
                if self.item_type == ItemType.WEAPON and self.dice_roll_effects:
                    self.known_properties.add("dice_roll_effects")
                    # Also make individual stats listed in item.stats known by default if it's a weapon and has stats
                    if self.stats:
                        self.known_properties.add("stats") # Make the category known
                        for stat_obj in self.stats:
                             self.known_properties.add(f"stat_{stat_obj.name}")
                
                if (self.item_type == ItemType.ARMOR or self.item_type == ItemType.SHIELD):
                    if self.stats: # If armor/shield has stats defined
                        self.known_properties.add("stats") # Make the category known
                        for stat_obj in self.stats:
                            # Make primary defensive stats (like 'armor' or 'defense') known by default
                            if stat_obj.name.lower() in ["armor", "defense", "block_chance"]: # Add other common defensive stat names
                                self.known_properties.add(f"stat_{stat_obj.name}")
                            # Other stats on armor might still require discovery unless explicitly made known here
            
        if self.durability is not None and self.current_durability is None:
            self.current_durability = self.durability
            
    def get_stat(self, name: str) -> Optional[ItemStat]:
        """Get a stat by name."""
        for stat in self.stats:
            if stat.name == name:
                return stat
        return None
    
    def add_stat(self, name: str, value: Union[int, float, str, bool], 
                display_name: Optional[str] = None, is_percentage: bool = False) -> None:
        """Add or update a stat."""
        existing_stat = self.get_stat(name)
        if existing_stat:
            existing_stat.value = value
            if display_name:
                existing_stat.display_name = display_name
            existing_stat.is_percentage = is_percentage
        else:
            new_stat = ItemStat(name, value, display_name, is_percentage)
            self.stats.append(new_stat)
    
    def remove_stat(self, name: str) -> bool:
        """Remove a stat by name. Returns True if successful."""
        for i, stat in enumerate(self.stats):
            if stat.name == name:
                self.stats.pop(i)
                return True
        return False
    
    def damage(self, amount: int) -> bool:
        """Apply damage to the item. Returns True if the item was destroyed."""
        if self.durability is None or self.current_durability is None:
            return False  # Item doesn't have durability
            
        self.current_durability = max(0, self.current_durability - amount)
        
        if self.current_durability == 0:
            self.is_destroyed = True
            return True
            
        return False
    
    def repair(self, amount: int) -> int:
        """Repair the item. Returns the amount of durability restored."""
        if (self.durability is None or self.current_durability is None 
            or self.is_destroyed):
            return 0  # Item can't be repaired
            
        old_durability = self.current_durability
        self.current_durability = min(self.durability, self.current_durability + amount)
        
        return self.current_durability - old_durability
    
    def discover_property(self, property_name: str) -> bool:
        """Mark a property as known to the player. Returns True if newly discovered."""
        if property_name in self.known_properties:
            return False
            
        self.known_properties.add(property_name)
        return True
    
    def is_property_known(self, property_name: str) -> bool:
        """Check if a property is known to the player."""
        return property_name in self.known_properties
    
    def get_known_value(self, property_name: str) -> Any:
        """Get a property value if it's known, otherwise None."""
        if not self.is_property_known(property_name):
            return None
            
        if property_name == "stats":
            return [stat for stat in self.stats 
                   if f"stat_{stat.name}" in self.known_properties]
        
        return getattr(self, property_name, None)
    
    def discover_stat(self, stat_name: str) -> bool:
        """Mark a stat as known to the player."""
        property_name = f"stat_{stat_name}"
        return self.discover_property(property_name)
    
    def is_stat_known(self, stat_name: str) -> bool:
        """Check if a stat is known to the player."""
        property_name = f"stat_{stat_name}"
        return self.is_property_known(property_name)
    
    def get_value_in_currency(self) -> Dict[str, int]:
        """Convert the value (in copper) to gold, silver, copper."""
        gold = self.value // 10000
        silver = (self.value % 10000) // 100
        copper = self.value % 100
        
        return {
            "gold": gold,
            "silver": silver,
            "copper": copper
        }
```

### File: core\inventory\item_effect.py

```python
#!/usr/bin/env python3
"""
Item effect definitions, such as dice roll effects.
"""
from dataclasses import dataclass, field
from typing import Optional, Dict, Any

@dataclass
class DiceRollEffect:
    """
    Represents a dice-roll based effect on an item.
    """
    effect_type: str  # e.g., "physical_damage", "fire_damage", "healing", "stat_buff"
    dice_notation: str # e.g., "1d6", "2d4+1"
    description: Optional[str] = None # e.g., "Deals fire damage on hit"
    # Future considerations: target_type (self, target_enemy, area), duration, application_trigger (on_hit, on_use)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "effect_type": self.effect_type,
            "dice_notation": self.dice_notation,
            "description": self.description,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DiceRollEffect':
        """Create a DiceRollEffect from a dictionary."""
        return cls(
            effect_type=data.get("effect_type", "unknown_effect"),
            dice_notation=data.get("dice_notation", "1d4"),
            description=data.get("description"),
        )
```

### File: core\inventory\item_enums.py

```python
#!/usr/bin/env python3
"""
Enums for the inventory system.

This module defines the enumerations used throughout the item system,
including item types, rarities, and equipment slots.
"""

from enum import Enum, auto


class ItemType(str, Enum):
    """Types of items in the game."""
    WEAPON = "weapon"
    ARMOR = "armor"
    SHIELD = "shield"
    ACCESSORY = "accessory"
    CONSUMABLE = "consumable"
    QUEST = "quest"
    MATERIAL = "material"
    CONTAINER = "container"
    KEY = "key"
    DOCUMENT = "document"
    TOOL = "tool"
    TREASURE = "treasure"
    MISCELLANEOUS = "miscellaneous"
    
    def __str__(self) -> str:
        """Return a display-friendly string representation."""
        return self.value.capitalize()


class ItemRarity(str, Enum):
    """Rarity levels for items."""
    COMMON = "common"
    UNCOMMON = "uncommon"
    RARE = "rare"
    EPIC = "epic"
    LEGENDARY = "legendary"
    ARTIFACT = "artifact"
    UNIQUE = "unique"
    
    def __str__(self) -> str:
        """Return a display-friendly string representation."""
        return self.value.capitalize()
    
    @property
    def color(self) -> str:
        """Get a color code for this rarity (for UI display)."""
        colors = {
            "common": "#c0c0c0",      # Silver
            "uncommon": "#00ff00",    # Green
            "rare": "#0070dd",        # Blue
            "epic": "#a335ee",        # Purple
            "legendary": "#ff8000",   # Orange
            "artifact": "#e6cc80",    # Gold
            "unique": "#ff0000"       # Red
        }
        return colors.get(self.value, "#ffffff")


class EquipmentSlot(str, Enum):
    """Equipment slots for wearable items."""
    HEAD = "head"
    NECK = "neck"
    SHOULDERS = "shoulders"
    ARMS = "arms"
    CHEST = "chest"
    BACK = "back"
    WRISTS = "wrists"
    HANDS = "hands"
    WAIST = "waist"
    LEGS = "legs"
    FEET = "feet"
    FINGER_1 = "finger_1"
    FINGER_2 = "finger_2"
    FINGER_3 = "finger_3"
    FINGER_4 = "finger_4"
    FINGER_5 = "finger_5"
    FINGER_6 = "finger_6"
    FINGER_7 = "finger_7"
    FINGER_8 = "finger_8"
    FINGER_9 = "finger_9"
    FINGER_10 = "finger_10"
    MAIN_HAND = "main_hand"
    OFF_HAND = "off_hand"
    TWO_HAND = "two_hand"
    RANGED = "ranged"
    AMMUNITION = "ammunition"
    TRINKET_1 = "trinket_1"
    TRINKET_2 = "trinket_2"
    
    def __str__(self) -> str:
        """Return a display-friendly string representation."""
        return self.value.replace('_', ' ').title()
    
    @property
    def is_finger(self) -> bool:
        """Check if this is a finger slot."""
        return self.value.startswith("finger_")
    
    @property
    def is_hand(self) -> bool:
        """Check if this is a hand slot."""
        return self.value in ["main_hand", "off_hand", "two_hand"]

```

### File: core\inventory\item_factory.py

```python
#!/usr/bin/env python3
"""
Item factory module.

This module provides the ItemFactory class for creating items
from templates and specifications.
"""

from typing import Dict, List, Optional, Any, Union, Tuple
import logging
import uuid
import random
import json
import os
from pathlib import Path
from datetime import datetime

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_enums import ItemType, ItemRarity, EquipmentSlot
from core.inventory.item_stat import ItemStat
from core.inventory.item_template_loader import get_item_template_loader
from core.inventory.item_variation_generator import ItemVariationGenerator

# Get module logger
logger = get_logger("Inventory")


class ItemFactory:
    """
    Factory for creating game items.
    
    This class handles creation of items from templates or
    custom specifications.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(ItemFactory, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the item factory."""
        if self._initialized:
            return
            
        logger.info("Initializing ItemFactory")
        
        # Get template loader
        self._template_loader = get_item_template_loader()
        
        self._initialized = True
        
        # Cache for icon directories to avoid repeated filesystem calls
        self._icon_cache = {}
        
        logger.info("ItemFactory initialized")
    
    def create_item_from_template(self, 
                                 template_id: str, 
                                 variation: bool = False,
                                 quality_override: Optional[float] = None) -> Optional[Item]:
        """
        Create an item from a template.
        
        Args:
            template_id: The ID of the template to use.
            variation: Whether to create a variation with randomized stats.
            quality_override: Optional quality factor override (0.0 to 2.0).
            
        Returns:
            A new Item instance, or None if the template was not found.
        """
        # Get the template
        template = self._template_loader.get_template(template_id)
        if not template:
            logger.warning(f"Template not found: {template_id}")
            return None
        
        # Create variation or copy
        if variation:
            item = ItemVariationGenerator.create_variation(template, quality_override)
        else:
            # Create a regular copy
            item = Item(
                name=template.name,
                description=template.description,
                item_type=template.item_type,
                rarity=template.rarity,
                weight=template.weight,
                value=template.value,
                icon_path=template.icon_path,
                is_equippable=template.is_equippable,
                equip_slots=[slot for slot in template.equip_slots] if template.equip_slots else [],
                stats=[ItemStat(
                    name=stat.name,
                    value=stat.value,
                    display_name=stat.display_name,
                    is_percentage=stat.is_percentage
                ) for stat in template.stats],
                is_consumable=template.is_consumable,
                is_stackable=template.is_stackable,
                stack_limit=template.stack_limit,
                quantity=1,
                is_quest_item=template.is_quest_item,
                durability=template.durability,
                current_durability=template.durability,
                tags=template.tags.copy() if template.tags else [],
                template_id=template.id,
                source="template_copy"
            )
        
        # Assign random icon if not specified
        if not item.icon_path:
            self.assign_random_icon(item)
        
        logger.info(f"Created item from template: {template_id}")
        return item
    
    def create_random_item(self, 
                          item_type: Optional[Union[ItemType, str]] = None,
                          rarity: Optional[Union[ItemRarity, str]] = None,
                          min_value: Optional[int] = None,
                          max_value: Optional[int] = None,
                          variation: bool = True) -> Optional[Item]:
        """
        Create a random item with optional constraints.
        
        Args:
            item_type: Optional type constraint.
            rarity: Optional rarity constraint.
            min_value: Optional minimum value constraint.
            max_value: Optional maximum value constraint.
            variation: Whether to create a variation with randomized stats.
            
        Returns:
            A new random Item instance, or None if no template matched the criteria.
        """
        # Convert string types to enums if needed
        if isinstance(item_type, str):
            try:
                item_type = ItemType(item_type)
            except ValueError:
                logger.warning(f"Invalid item type: {item_type}")
                return None
        
        if isinstance(rarity, str):
            try:
                rarity = ItemRarity(rarity)
            except ValueError:
                logger.warning(f"Invalid item rarity: {rarity}")
                return None
        
        # Build criteria dict
        criteria = {}
        if item_type:
            criteria["item_type"] = item_type
        if rarity:
            criteria["rarity"] = rarity
        
        # Get matching templates
        templates = self._template_loader.get_templates_by_criteria(**criteria)
        if not templates:
            logger.warning(f"No templates match the criteria: {criteria}")
            return None
        
        # Filter by value if needed
        if min_value is not None or max_value is not None:
            filtered_templates = {}
            for template_id, template in templates.items():
                if min_value is not None and template.value < min_value:
                    continue
                if max_value is not None and template.value > max_value:
                    continue
                filtered_templates[template_id] = template
            
            templates = filtered_templates
            
            if not templates:
                logger.warning(f"No templates match the value criteria: min={min_value}, max={max_value}")
                return None
        
        # Select a random template
        template_id = random.choice(list(templates.keys()))
        
        # Create item from template
        return self.create_item_from_template(template_id, variation)
    
    def create_loot_table(self, 
                         item_count: int,
                         rarity_weights: Optional[Dict[ItemRarity, float]] = None,
                         type_weights: Optional[Dict[ItemType, float]] = None,
                         value_range: Optional[Tuple[int, int]] = None) -> List[Item]:
        """
        Create a table of random loot items.
        
        Args:
            item_count: Number of items to generate.
            rarity_weights: Optional dictionary mapping rarities to weights.
            type_weights: Optional dictionary mapping types to weights.
            value_range: Optional tuple of (min_value, max_value).
            
        Returns:
            A list of generated items.
        """
        # Default rarity weights if not provided
        if rarity_weights is None:
            rarity_weights = {
                ItemRarity.COMMON: 0.6,
                ItemRarity.UNCOMMON: 0.25,
                ItemRarity.RARE: 0.10,
                ItemRarity.EPIC: 0.04,
                ItemRarity.LEGENDARY: 0.01
            }
        
        # Convert weights to lists for random.choices
        rarity_choices = list(rarity_weights.keys())
        rarity_weights_list = list(rarity_weights.values())
        
        type_choices = None
        type_weights_list = None
        if type_weights:
            type_choices = list(type_weights.keys())
            type_weights_list = list(type_weights.values())
        
        # Generate items
        items = []
        for _ in range(item_count):
            # Select random rarity
            rarity = random.choices(rarity_choices, weights=rarity_weights_list, k=1)[0]
            
            # Select random type if weights provided
            item_type = None
            if type_choices:
                item_type = random.choices(type_choices, weights=type_weights_list, k=1)[0]
            
            # Set value range
            min_value = None
            max_value = None
            if value_range:
                min_value, max_value = value_range
            
            # Create random item
            item = self.create_random_item(
                item_type=item_type,
                rarity=rarity,
                min_value=min_value,
                max_value=max_value,
                variation=True
            )
            
            if item:
                items.append(item)
        
        logger.info(f"Generated loot table with {len(items)} items")
        return items
    
    def create_item_from_spec(self, spec: Dict[str, Any]) -> Optional[Item]:
        """
        Create an item from a specification dictionary.
        
        Args:
            spec: Dictionary with item specifications.
            
        Returns:
            A new Item instance, or None if the specification was invalid.
        """
        try:
            # Check if we should use a template as a base
            template_id = spec.get("template_id")
            if template_id:
                # Create from template first
                template = self._template_loader.get_template(template_id)
                if not template:
                    logger.warning(f"Template not found: {template_id}")
                    return None
                
                base_item = self.create_item_from_template(template_id, False)
                if not base_item:
                    return None
                
                # Update with spec values
                for key, value in spec.items():
                    if key != "template_id" and key != "stats":
                        setattr(base_item, key, value)
                
                # Update stats if provided
                if "stats" in spec:
                    for stat_spec in spec["stats"]:
                        stat_name = stat_spec.get("name")
                        if stat_name:
                            # Check if stat already exists
                            existing_stat = base_item.get_stat(stat_name)
                            if existing_stat:
                                # Update existing stat
                                existing_stat.value = stat_spec.get("value", existing_stat.value)
                                existing_stat.display_name = stat_spec.get("display_name", existing_stat.display_name)
                                existing_stat.is_percentage = stat_spec.get("is_percentage", existing_stat.is_percentage)
                            else:
                                # Add new stat
                                base_item.add_stat(
                                    name=stat_name,
                                    value=stat_spec.get("value", 0),
                                    display_name=stat_spec.get("display_name"),
                                    is_percentage=stat_spec.get("is_percentage", False)
                                )
                
                return base_item
            
            # Create a new item from scratch
            item_type = spec.get("item_type", ItemType.MISCELLANEOUS)
            if isinstance(item_type, str):
                try:
                    item_type = ItemType(item_type)
                except ValueError:
                    logger.warning(f"Invalid item type: {item_type}")
                    item_type = ItemType.MISCELLANEOUS
            
            rarity = spec.get("rarity", ItemRarity.COMMON)
            if isinstance(rarity, str):
                try:
                    rarity = ItemRarity(rarity)
                except ValueError:
                    logger.warning(f"Invalid item rarity: {rarity}")
                    rarity = ItemRarity.COMMON
            
            # Process equipment slots
            equip_slots = []
            if "equip_slots" in spec:
                for slot in spec["equip_slots"]:
                    if isinstance(slot, str):
                        try:
                            equip_slots.append(EquipmentSlot(slot))
                        except ValueError:
                            logger.warning(f"Invalid equipment slot: {slot}")
                    else:
                        equip_slots.append(slot)
            
            # Process stats
            stats = []
            if "stats" in spec:
                for stat_spec in spec["stats"]:
                    stat = ItemStat(
                        name=stat_spec["name"],
                        value=stat_spec["value"],
                        display_name=stat_spec.get("display_name"),
                        is_percentage=stat_spec.get("is_percentage", False)
                    )
                    stats.append(stat)
            
            # Create the item
                item = Item(
                id=spec.get("id", str(uuid.uuid4())),
                name=spec.get("name", "Unknown Item"),
                description=spec.get("description", ""),
                item_type=item_type,
                rarity=rarity,
                weight=spec.get("weight", 0.0),
                value=spec.get("value", 0),
                icon_path=spec.get("icon_path"),
                is_equippable=spec.get("is_equippable", False),
                equip_slots=equip_slots,
                stats=stats,
                is_consumable=spec.get("is_consumable", False),
                is_stackable=spec.get("is_stackable", False),
                stack_limit=(spec.get("stack_limit", 20) if spec.get("is_stackable", False) else spec.get("stack_limit", 1)),
                quantity=spec.get("quantity", 1),
                is_quest_item=spec.get("is_quest_item", False),
                durability=spec.get("durability"),
                current_durability=spec.get("current_durability"),
                tags=spec.get("tags", []),
                source=spec.get("source", "custom")
            )
            
            # Set discovered properties if specified
            if "known_properties" in spec:
                for prop in spec["known_properties"]:
                    item.discover_property(prop)
            
            # Assign random icon if not specified
            if not item.icon_path:
                self.assign_random_icon(item)
            
            logger.info(f"Created custom item: {item.name}")
            return item
            
        except Exception as e:
            logger.error(f"Error creating item from spec: {e}")
            return None
    
    def create_items_from_json(self, json_text: str) -> List[Item]:
        """
        Create items from a JSON string containing specifications.
        
        Args:
            json_text: JSON string with item specifications.
            
        Returns:
            A list of created items.
        """
        try:
            specs = json.loads(json_text)
            
            # Handle both single item and list of items
            if not isinstance(specs, list):
                specs = [specs]
            
            items = []
            for spec in specs:
                item = self.create_item_from_spec(spec)
                if item:
                    items.append(item)
            
            logger.info(f"Created {len(items)} items from JSON")
            return items
            
        except Exception as e:
            logger.error(f"Error creating items from JSON: {e}")
            return []
    
    def assign_random_icon(self, item: Item) -> None:
        """
        Assign a random icon from the pool based on item type and tags.
        Icon path is permanently stored with the item.
        
        Args:
            item: The item to assign an icon to.
        """
        # Skip if already has an icon
        if item.icon_path:
            return
        
        # Determine icon directory based on item type
        type_to_dir = {
            ItemType.WEAPON: "weapon",
            ItemType.ARMOR: "armor",
            ItemType.SHIELD: "shield",
            ItemType.ACCESSORY: "accessory",
            ItemType.CONSUMABLE: "consumable",
            ItemType.QUEST: "quest",
            ItemType.MATERIAL: "material",
            ItemType.CONTAINER: "container",
            ItemType.KEY: "key",
            ItemType.DOCUMENT: "document",
            ItemType.TOOL: "tool",
            ItemType.TREASURE: "treasure",
            ItemType.MISCELLANEOUS: "miscellaneous"
        }
        
        icon_dir = type_to_dir.get(item.item_type, "miscellaneous")
        base_path = Path("images/icons") / icon_dir
        
        # Get candidates from cache or scan directory
        cache_key = str(base_path)
        if cache_key not in self._icon_cache:
            # Scan directory for PNG files
            if base_path.exists():
                self._icon_cache[cache_key] = list(base_path.glob("*.png"))
            else:
                self._icon_cache[cache_key] = []
                logger.warning(f"Icon directory not found: {base_path}")
        
        candidates = []
        
        # Strategy 1: Match by tags (e.g., "dagger" in tags → dagger_*.png)
        if item.tags:
            for tag in item.tags:
                tag_lower = tag.lower()
                matching = [p for p in self._icon_cache.get(cache_key, []) 
                           if tag_lower in p.stem.lower()]
                if matching:
                    candidates.extend(matching)
        
        # Strategy 2: If no tag matches, get all icons in the type directory
        if not candidates:
            candidates = self._icon_cache.get(cache_key, [])
        
        # Strategy 3: Fallback to miscellaneous if type folder empty
        if not candidates:
            misc_path = Path("images/icons/miscellaneous")
            misc_cache_key = str(misc_path)
            if misc_cache_key not in self._icon_cache:
                if misc_path.exists():
                    self._icon_cache[misc_cache_key] = list(misc_path.glob("*.png"))
                else:
                    self._icon_cache[misc_cache_key] = []
            
            candidates = self._icon_cache.get(misc_cache_key, [])
            icon_dir = "miscellaneous"
        
        # Select random icon from candidates
        if candidates:
            selected = random.choice(candidates)
            # Store as web-accessible path (forward slashes for web)
            item.icon_path = f"/images/icons/{icon_dir}/{selected.name}"
            logger.info(f"Assigned random icon to '{item.name}': {item.icon_path}")
        else:
            # No icons available - set None and log warning
            logger.warning(f"No icons available for item type {item.item_type}, item: {item.name}")
            item.icon_path = None


# Convenience function
def get_item_factory() -> ItemFactory:
    """Get the item factory instance."""
    return ItemFactory()

```

### File: core\inventory\item_manager.py

```python
"""
Item manager module.

This module provides a global access point to the inventory manager.
"""
import logging # Added for logging within this module
from typing import Optional
import uuid # Added for instance ID

from core.inventory.inventory_manager import InventoryManager
from core.utils.logging_config import get_logger # Ensure get_logger is available

# Get module logger specifically for this file's logs
logger = get_logger("ITEM_MANAGER_SINGLETON")

# Singleton instance
_inventory_manager_singleton_instance: Optional[InventoryManager] = None

def get_inventory_manager() -> InventoryManager:
    """
    Get the global inventory manager instance.
    
    Returns:
        The singleton inventory manager instance.
    """
    global _inventory_manager_singleton_instance
    
    if _inventory_manager_singleton_instance is None:
        logger.info("InventoryManager singleton is None, creating new instance.")
        _inventory_manager_singleton_instance = InventoryManager() # This calls InventoryManager.__init__
        # The __init__ of InventoryManager should set self.instance_id_for_debug
        new_id = getattr(_inventory_manager_singleton_instance, 'instance_id_for_debug', 'NOT_SET_IN_INIT')
        logger.info(f"NEW InventoryManager instance created with ID: {new_id}")
        # Store the ID on the class itself for future calls if needed (though instance_id_for_debug is preferred on the object)
        # setattr(InventoryManager, '_singleton_instance_id_debug', new_id) 
    else:
        instance_id = getattr(_inventory_manager_singleton_instance, 'instance_id_for_debug', 'ID_WAS_NOT_SET')
        # class_stored_id = getattr(InventoryManager, '_singleton_instance_id_debug', 'CLASS_ID_NOT_STORED')
        logger.debug(f"Returning EXISTING InventoryManager instance with ID: {instance_id}")
        
    return _inventory_manager_singleton_instance
```

### File: core\inventory\item_modifier.py

```python
#!/usr/bin/env python3
"""
Item modifier module.

This module provides functionality for modifying item stats
and creating variations of items.
"""

from typing import Dict, List, Optional, Any, Union, Tuple
import random
import logging
import copy

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_enums import ItemRarity
from core.inventory.item_stat import ItemStat

# Get module logger
logger = get_logger("Inventory")


class ItemModifier:
    """
    
```

### File: core\inventory\item_serialization.py

```python
#!/usr/bin/env python3
"""
Item serialization module.

This module provides serialization and deserialization functions
for Item objects, handling conversions between Item objects and
dictionaries suitable for JSON storage.
"""

from typing import Dict, List, Any, Optional, Set, Union
import json
import uuid

from core.inventory.item import Item
from core.inventory.item_enums import ItemType, ItemRarity, EquipmentSlot
from core.inventory.item_stat import ItemStat


def item_to_dict(item: Item, include_unknown: bool = False) -> Dict[str, Any]:
    """
    Convert an Item to a dictionary for serialization.
    
    Args:
        item: The Item to convert.
        include_unknown: If True, include all properties regardless of known_properties.
                        If False, only include properties the player knows.
    
    Returns:
        Dictionary representation of the item.
    """
    # Always include these basic properties
    result = {
        "id": item.id,
        "name": item.name,
    }
    
    # Properties that might be known or unknown
    property_map = {
        "description": item.description,
        "item_type": item.item_type.value if item.item_type else None,
        "rarity": item.rarity.value if item.rarity else None,
        "weight": item.weight,
        "value": item.value,
        "icon_path": item.icon_path,
        "is_equippable": item.is_equippable,
        "equip_slots": [slot.value for slot in item.equip_slots] if item.equip_slots else [],
        "is_consumable": item.is_consumable,
        "is_stackable": item.is_stackable,
        "stack_limit": item.stack_limit,
        "quantity": item.quantity,
        "is_quest_item": item.is_quest_item,
        "durability": item.durability,
        "current_durability": item.current_durability,
        "is_destroyed": item.is_destroyed,
        "tags": item.tags,
        "template_id": item.template_id,
        "is_template": item.is_template,
        "source": item.source,
        "custom_properties": item.custom_properties,
        "discovered_at": item.discovered_at
    }
    
    # Add properties based on knowledge or inclusion flag
    for prop_name, prop_value in property_map.items():
        if include_unknown or prop_name in item.known_properties:
            result[prop_name] = prop_value
    
    # Handle stats specially
    if include_unknown:
        # Include all stats
        result["stats"] = [stat.to_dict() for stat in item.stats]
    else:
        # Include only known stats
        result["stats"] = [
            stat.to_dict() for stat in item.stats 
            if f"stat_{stat.name}" in item.known_properties
        ]

    # Handle dice_roll_effects
    if include_unknown or "dice_roll_effects" in item.known_properties: # Assuming "dice_roll_effects" becomes a knowable property
        result["dice_roll_effects"] = [effect.to_dict() for effect in item.dice_roll_effects]
    elif item.dice_roll_effects: # If not explicitly known but effects exist, decide if they should be hidden
        # For now, if not 'include_unknown' and not explicitly known, don't include them.
        # This might need adjustment based on game design (e.g., are dice effects always known once item is ID'd?)
        pass
    
    # Include the known_properties set itself if including all properties
    if include_unknown:
        result["known_properties"] = list(item.known_properties)
    
    return result


def dict_to_item(data: Dict[str, Any]) -> Item:
    """
    Create an Item from a dictionary.
    
    Args:
        data: Dictionary containing item data.
    
    Returns:
        An Item object.
    """
    from core.inventory.item_effect import DiceRollEffect # Local import to avoid circularity at module level
    
    # Extract stats first if they exist
    stats = []
    if "stats" in data:
        stats = [ItemStat.from_dict(stat_data) for stat_data in data.get("stats", [])]
    
    # Extract dice_roll_effects
    dice_roll_effects = []
    if "dice_roll_effects" in data:
        dice_roll_effects = [DiceRollEffect.from_dict(effect_data) for effect_data in data.get("dice_roll_effects", [])]

    # Extract known_properties if it exists
    known_properties = set(data.get("known_properties", []))
    
    # Extract equip_slots if they exist
    equip_slots = []
    if "equip_slots" in data:
        raw_slots = data.get("equip_slots", [])
        for slot_val in raw_slots:
            if isinstance(slot_val, str):
                try:
                    equip_slots.append(EquipmentSlot(slot_val))
                except ValueError:
                    # logger.warning(f"Invalid equip_slot string '{slot_val}' in item data, skipping.")
                    pass # Skip invalid slot
            elif isinstance(slot_val, EquipmentSlot): # Should not happen if data is from JSON
                equip_slots.append(slot_val)

    # Ensure item_type is valid or default
    item_type_str = data.get("item_type", ItemType.MISCELLANEOUS.value)
    try:
        item_type_val = ItemType(item_type_str)
    except ValueError:
        # logger.warning(f"Invalid item_type string '{item_type_str}' in item data, defaulting to MISCELLANEOUS.")
        item_type_val = ItemType.MISCELLANEOUS
        
    # Ensure rarity is valid or default
    rarity_str = data.get("rarity", ItemRarity.COMMON.value)
    try:
        rarity_val = ItemRarity(rarity_str)
    except ValueError:
        # logger.warning(f"Invalid rarity string '{rarity_str}' in item data, defaulting to COMMON.")
        rarity_val = ItemRarity.COMMON

    # Create the item with basic properties
    item = Item(
        id=data.get("id", str(uuid.uuid4())), # Ensure ID is generated if missing
        name=data.get("name", ""),
        description=data.get("description", ""),
        item_type=item_type_val,
        rarity=rarity_val,
        weight=data.get("weight", 0.0),
        value=data.get("value", 0),
        icon_path=data.get("icon_path"),
        is_equippable=data.get("is_equippable", False),
        equip_slots=equip_slots,
        stats=stats,
        dice_roll_effects=dice_roll_effects, # Add new field
        is_consumable=data.get("is_consumable", False),
        is_stackable=data.get("is_stackable", False),
        stack_limit=(data.get("stack_limit") if not data.get("is_stackable", False) else data.get("stack_limit", 20)),
        quantity=data.get("quantity", 1),
        is_quest_item=data.get("is_quest_item", False),
        durability=data.get("durability"),
        current_durability=data.get("current_durability"),
        is_destroyed=data.get("is_destroyed", False),
        known_properties=known_properties, # known_properties should be set before __post_init__
        discovered_at=data.get("discovered_at"),
        tags=data.get("tags", []),
        template_id=data.get("template_id"),
        is_template=data.get("is_template", False),
        source=data.get("source", "template"),
        custom_properties=data.get("custom_properties", {})
    )

    # Upgrade stack_limit from template if available and item is stackable
    try:
        # Skip canonical stack limit lookup when we are constructing template objects themselves
        if not getattr(item, 'is_template', False) and getattr(item, 'is_stackable', False):
            canonical_limit = None
            if item.template_id:
                try:
                    from core.inventory.item_template_loader import get_item_template_loader
                    tl = get_item_template_loader()
                    tmpl = tl.get_template(item.template_id)
                    if tmpl and getattr(tmpl, 'is_stackable', False):
                        canonical_limit = getattr(tmpl, 'stack_limit', None)
                except Exception:
                    pass
            if canonical_limit is not None and int(canonical_limit) > int(getattr(item, 'stack_limit', 1) or 1):
                item.stack_limit = int(canonical_limit)
    except Exception:
        pass
    
    # If known_properties was empty in data, __post_init__ would have set defaults.
    # If it was present, ensure the defaults are still there if they were missing from the loaded set.
    if not data.get("known_properties"): # If known_properties was not in data, post_init set defaults
        pass
    else: # If known_properties was in data, ensure defaults are present
        default_known = {"id", "name", "item_type", "weight", "is_stackable", "quantity", "is_quest_item", "tags"}
        item.known_properties.update(default_known.difference(item.known_properties))

    return item


def items_to_json(items: List[Item], include_unknown: bool = False) -> str:
    """
    Convert a list of Items to a JSON string.
    
    Args:
        items: List of Items to convert.
        include_unknown: Whether to include unknown properties.
    
    Returns:
        JSON string representation of the items.
    """
    item_dicts = [item_to_dict(item, include_unknown) for item in items]
    return json.dumps(item_dicts, indent=2)


def json_to_items(json_str: str) -> List[Item]:
    """
    Create a list of Items from a JSON string.
    
    Args:
        json_str: JSON string containing item data.
    
    Returns:
        List of Item objects.
    """
    item_dicts = json.loads(json_str)
    return [dict_to_item(item_dict) for item_dict in item_dicts]

```

### File: core\inventory\item_stat.py

```python
#!/usr/bin/env python3
"""
Item statistics module.

This module defines the ItemStat class used to represent
attributes and properties of items.
"""

from dataclasses import dataclass
from typing import Dict, Union, Optional, Any


@dataclass
class ItemStat:
    """A stat or attribute of an item."""
    name: str
    value: Union[int, float, str, bool]
    display_name: Optional[str] = None
    is_percentage: bool = False
    
    def __str__(self) -> str:
        """Return a display-friendly string representation."""
        display = self.display_name or self.name.replace('_', ' ').title()
        if isinstance(self.value, (int, float)):
            if self.is_percentage:
                return f"{display}: {self.value:+.1f}%"
            return f"{display}: {self.value:+.1f}"
        return f"{display}: {self.value}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "name": self.name,
            "value": self.value,
            "display_name": self.display_name,
            "is_percentage": self.is_percentage
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ItemStat':
        """Create an ItemStat from a dictionary."""
        return cls(
            name=data["name"],
            value=data["value"],
            display_name=data.get("display_name"),
            is_percentage=data.get("is_percentage", False)
        )

```

### File: core\inventory\item_stat_modifier.py

```python
#!/usr/bin/env python3
"""
Item stat modifier module.

This module provides functionality for modifying individual item stats.
"""

from typing import Dict, List, Optional, Any, Union, Tuple
import random
import logging
import copy

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_stat import ItemStat

# Get module logger
logger = get_logger("Inventory")


class ItemStatModifier:
    """
    Handles modifications to individual item stats.
    
    This class provides methods to adjust item stats with various
    scaling factors and constraints.
    """
    
    @staticmethod
    def modify_numeric_stat(
        stat: ItemStat,
        factor: float,
        min_value: Optional[float] = None,
        max_value: Optional[float] = None,
        round_to: Optional[int] = None
    ) -> ItemStat:
        """
        Modify a numeric stat by a factor with optional constraints.
        
        Args:
            stat: The ItemStat to modify.
            factor: The scaling factor to apply.
            min_value: Optional minimum value for the result.
            max_value: Optional maximum value for the result.
            round_to: Optional decimal places to round to.
            
        Returns:
            A new ItemStat with the modified value.
        """
        # Ensure the stat is numeric
        if not isinstance(stat.value, (int, float)):
            return copy.deepcopy(stat)
        
        # Calculate new value
        new_value = stat.value * factor
        
        # Apply constraints
        if min_value is not None:
            new_value = max(min_value, new_value)
        if max_value is not None:
            new_value = min(max_value, new_value)
        
        # Round if needed
        if round_to is not None:
            if round_to == 0:
                new_value = int(round(new_value))
            else:
                new_value = round(new_value, round_to)
        
        # Create new stat with modified value
        return ItemStat(
            name=stat.name,
            value=new_value,
            display_name=stat.display_name,
            is_percentage=stat.is_percentage
        )
    
    @staticmethod
    def modify_stat_random(
        stat: ItemStat,
        min_factor: float,
        max_factor: float,
        min_value: Optional[float] = None,
        max_value: Optional[float] = None,
        round_to: Optional[int] = None
    ) -> ItemStat:
        """
        Modify a numeric stat by a random factor within a range.
        
        Args:
            stat: The ItemStat to modify.
            min_factor: The minimum scaling factor to apply.
            max_factor: The maximum scaling factor to apply.
            min_value: Optional minimum value for the result.
            max_value: Optional maximum value for the result.
            round_to: Optional decimal places to round to.
            
        Returns:
            A new ItemStat with the modified value.
        """
        # Calculate random factor
        factor = random.uniform(min_factor, max_factor)
        
        # Apply the factor
        return ItemStatModifier.modify_numeric_stat(
            stat, factor, min_value, max_value, round_to
        )
    
    @staticmethod
    def apply_quality_factor(
        stat: ItemStat,
        quality: float,
        min_value: Optional[float] = None,
        max_value: Optional[float] = None,
        round_to: Optional[int] = None
    ) -> ItemStat:
        """
        Modify a stat based on an item quality factor (0.0 to 2.0).
        
        Args:
            stat: The ItemStat to modify.
            quality: The quality factor (typically 0.0 to 2.0, where 1.0 is normal).
            min_value: Optional minimum value for the result.
            max_value: Optional maximum value for the result.
            round_to: Optional decimal places to round to.
            
        Returns:
            A new ItemStat with the modified value.
        """
        # Normalize quality (ensure between 0.0 and 2.0)
        normalized_quality = max(0.0, min(2.0, quality))
        
        # Apply quality factor
        return ItemStatModifier.modify_numeric_stat(
            stat, normalized_quality, min_value, max_value, round_to
        )
    
    @staticmethod
    def apply_level_scaling(
        stat: ItemStat,
        item_level: int,
        base_level: int,
        scaling_factor: float,
        min_value: Optional[float] = None,
        max_value: Optional[float] = None,
        round_to: Optional[int] = None
    ) -> ItemStat:
        """
        Scale a stat based on item level compared to a base level.
        
        Args:
            stat: The ItemStat to modify.
            item_level: The level of the item.
            base_level: The base level for comparison.
            scaling_factor: The scaling factor per level difference.
            min_value: Optional minimum value for the result.
            max_value: Optional maximum value for the result.
            round_to: Optional decimal places to round to.
            
        Returns:
            A new ItemStat with the modified value.
        """
        # Calculate level factor
        level_diff = item_level - base_level
        level_factor = 1.0 + (level_diff * scaling_factor)
        
        # Apply level factor
        return ItemStatModifier.modify_numeric_stat(
            stat, level_factor, min_value, max_value, round_to
        )

```

### File: core\inventory\item_template_loader.py

```python
#!/usr/bin/env python3
"""
Item template loader module.

This module provides functionality for loading item templates
from configuration files.
"""

from typing import Dict, List, Optional, Any, Union, Set
import os
import json
import logging
from pathlib import Path

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_enums import ItemType, ItemRarity, EquipmentSlot
from core.inventory.item_stat import ItemStat
from core.inventory.item_serialization import dict_to_item
from core.base.config import get_config

# Get module logger
logger = get_logger("Inventory")


class ItemTemplateLoader:
    """
    Loader for item templates.
    
    This class handles loading item templates from configuration files.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(ItemTemplateLoader, cls).__new__(cls)
            cls._instance._initialized = False
            cls._instance._initializing = False
        return cls._instance
    
    def __init__(self):
        """Initialize the template loader."""
        # Prevent re-entrant initialization during first construction
        if getattr(self, "_initializing", False) or getattr(self, "_initialized", False):
            return
        
        self._initializing = True
        try:
            logger.info("Initializing ItemTemplateLoader")
            
            # Get configuration
            self._config = get_config()
            
            # Item templates
            self._templates: Dict[str, Item] = {}
            
            # Cache of available item icons by category
            self._icon_paths: Dict[str, List[str]] = {}
            
            # Set up directory paths
            self._templates_dir = self._config.get("paths", {}).get(
                "item_templates", os.path.join("config", "items")
            )
            self._icons_dir = self._config.get("paths", {}).get(
                "item_icons", os.path.join("images", "items")
            )
            
            # Load templates and scan for icons
            self._load_templates()
            self._scan_icon_paths()
            
            self._initialized = True
            logger.info(f"ItemTemplateLoader initialized with {len(self._templates)} templates")
        finally:
            self._initializing = False
    
    def _load_templates(self) -> None:
        """Load item templates from configuration files."""
        if not os.path.exists(self._templates_dir):
            logger.warning(f"Item templates directory not found: {self._templates_dir}")
            return
        
        # Find all JSON files in the templates directory
        template_files = []
        for root, _, files in os.walk(self._templates_dir):
            for file in files:
                if file.endswith(".json"):
                    template_files.append(os.path.join(root, file))
        
        # Load each template file
        for filepath in template_files:
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # Handle single template or array of templates
                templates_data = data if isinstance(data, list) else [data]
                
                for template_data in templates_data:
                    try:
                        # Generate a template ID if not provided
                        if "id" not in template_data:
                            # Use filename as part of the ID
                            filename = os.path.basename(filepath)
                            name = template_data.get("name", "unknown")
                            template_data["id"] = f"template_{filename}_{name}".lower().replace(" ", "_")
                        
                        # Mark as template
                        template_data["is_template"] = True
                        
                        # Convert to Item
                        template = dict_to_item(template_data)
                        
                        # Store in templates dictionary
                        self._templates[template.id] = template
                        
                    except Exception as e:
                        logger.error(f"Error processing template in {filepath}: {e}")
                
            except Exception as e:
                logger.error(f"Error loading template file {filepath}: {e}")
        
        logger.info(f"Loaded {len(self._templates)} item templates from {len(template_files)} files")
    
    def _scan_icon_paths(self) -> None:
        """Scan for available item icons and categorize them."""
        if not os.path.exists(self._icons_dir):
            logger.warning(f"Item icons directory not found: {self._icons_dir}")
            return
        
        # Reset icon paths
        self._icon_paths = {}
        
        # Walk through the icons directory
        for root, _, files in os.walk(self._icons_dir):
            relative_path = os.path.relpath(root, self._icons_dir)
            category = relative_path if relative_path != "." else "general"
            
            # Get image files
            image_files = [os.path.join(root, file) for file in files 
                           if file.lower().endswith(('.png', '.jpg', '.jpeg', '.gif'))]
            
            if image_files:
                self._icon_paths[category] = image_files
        
        # Log results
        total_icons = sum(len(icons) for icons in self._icon_paths.values())
        logger.info(f"Found {total_icons} item icons in {len(self._icon_paths)} categories")
    
    def reload_templates(self) -> None:
        """Reload item templates from configuration files."""
        self._templates = {}
        self._load_templates()
        logger.info(f"Reloaded {len(self._templates)} item templates")
    
    def get_template(self, template_id: str) -> Optional[Item]:
        """
        Get a template by ID.
        
        Args:
            template_id: The ID of the template.
            
        Returns:
            The Item template, or None if not found.
        """
        return self._templates.get(template_id)
    
    def get_all_templates(self) -> Dict[str, Item]:
        """
        Get all available templates.
        
        Returns:
            Dictionary mapping template IDs to Item templates.
        """
        return dict(self._templates)
    
    def get_templates_by_type(self, item_type: Union[ItemType, str]) -> Dict[str, Item]:
        """
        Get templates of a specific type.
        
        Args:
            item_type: The type of items to get.
            
        Returns:
            Dictionary mapping template IDs to Item templates of the specified type.
        """
        # Convert string to enum if needed
        if isinstance(item_type, str):
            try:
                item_type = ItemType(item_type)
            except ValueError:
                logger.warning(f"Invalid item type: {item_type}")
                return {}
        
        # Filter templates by type
        return {template_id: template for template_id, template in self._templates.items()
                if template.item_type == item_type}
    
    def get_templates_by_criteria(self, **criteria) -> Dict[str, Item]:
        """
        Get templates matching specific criteria.
        
        Args:
            **criteria: Criteria to match, e.g., rarity=ItemRarity.RARE, is_equippable=True
            
        Returns:
            Dictionary mapping template IDs to matching Item templates.
        """
        # Special handling for item_type and rarity which might be strings
        if "item_type" in criteria and isinstance(criteria["item_type"], str):
            try:
                criteria["item_type"] = ItemType(criteria["item_type"])
            except ValueError:
                logger.warning(f"Invalid item type: {criteria['item_type']}")
                return {}
        
        if "rarity" in criteria and isinstance(criteria["rarity"], str):
            try:
                criteria["rarity"] = ItemRarity(criteria["rarity"])
            except ValueError:
                logger.warning(f"Invalid item rarity: {criteria['rarity']}")
                return {}
        
        # Filter templates by criteria
        result = {}
        for template_id, template in self._templates.items():
            matches = True
            for key, value in criteria.items():
                template_value = getattr(template, key, None)
                if template_value != value:
                    matches = False
                    break
            
            if matches:
                result[template_id] = template
        
        return result
    
    def get_random_icon_path(self, category: str = "general") -> Optional[str]:
        """
        Get a random icon path for a category.
        
        Args:
            category: The icon category.
            
        Returns:
            A random icon path, or None if no icons are available.
        """
        icon_paths = self._icon_paths.get(category, [])
        if not icon_paths:
            # Try general category as fallback
            icon_paths = self._icon_paths.get("general", [])
            if not icon_paths:
                return None
        
        return random.choice(icon_paths)
    
    def get_icon_categories(self) -> List[str]:
        """
        Get available icon categories.
        
        Returns:
            List of available icon categories.
        """
        return list(self._icon_paths.keys())


# Convenience function
def get_item_template_loader() -> ItemTemplateLoader:
    """Get the item template loader instance."""
    return ItemTemplateLoader()

```

### File: core\inventory\item_variation_generator.py

```python
#!/usr/bin/env python3
"""
Item variation generator module.

This module provides functionality for creating variations of items
with different stats and properties.
"""

from typing import Dict, List, Optional, Any, Union, Tuple, Set
import random
import logging
import copy
import uuid

from core.utils.logging_config import get_logger
from core.inventory.item import Item
from core.inventory.item_enums import ItemRarity, ItemType
from core.inventory.item_stat_modifier import ItemStatModifier

# Get module logger
logger = get_logger("Inventory")


class ItemVariationGenerator:
    """
    Generator for item variations.
    
    This class provides methods for creating variations of items
    with different stats and properties based on templates.
    """
    
    # Quality variation ranges by rarity
    QUALITY_RANGES = {
        ItemRarity.COMMON: (0.80, 1.20),
        ItemRarity.UNCOMMON: (0.85, 1.25),
        ItemRarity.RARE: (0.90, 1.30),
        ItemRarity.EPIC: (0.95, 1.40),
        ItemRarity.LEGENDARY: (1.00, 1.50),
        ItemRarity.ARTIFACT: (1.10, 1.75),
        ItemRarity.UNIQUE: (1.20, 2.00)
    }
    
    # Prefix/suffix word lists
    PREFIXES = {
        "weapon": [
            "Sharp", "Keen", "Balanced", "Heavy", "Light", "Swift", 
            "Deadly", "Venomous", "Burning", "Frozen", "Shocking",
            "Masterwork", "Ancient", "Enchanted", "Blessed", "Cursed",
            "Runic", "Ornate", "Brutal", "Precise", "Hunter's"
        ],
        "armor": [
            "Sturdy", "Reinforced", "Plated", "Layered", "Durable",
            "Guardian's", "Warden's", "Defender's", "Protective", "Impenetrable",
            "Elven", "Dwarven", "Orcish", "Enchanted", "Blessed",
            "Runic", "Ornate", "Royal", "Ceremonial", "Knight's"
        ],
        "general": [
            "Fine", "Exceptional", "Superior", "Flawless", "Perfect",
            "Artisan's", "Master's", "Exotic", "Arcane", "Mysterious",
            "Forgotten", "Lost", "Hidden", "Recovered", "Preserved",
            "Sacred", "Profane", "Celestial", "Infernal", "Ethereal"
        ]
    }
    
    SUFFIXES = {
        "weapon": [
            "of Slaying", "of Quickness", "of Accuracy", "of Power", "of Might",
            "of Destruction", "of Ruin", "of the Berserker", "of the Assassin", "of the Duelist",
            "of Fire", "of Ice", "of Lightning", "of Venom", "of Decay",
            "of the Hunt", "of the Wild", "of the Night", "of the Dawn", "of Twilight"
        ],
        "armor": [
            "of Protection", "of Warding", "of Shielding", "of Deflection", "of Absorption",
            "of Resilience", "of Endurance", "of Fortitude", "of Vitality", "of Recovery",
            "of Fire Resistance", "of Frost Resistance", "of Lightning Resistance", "of Poison Resistance", "of Magic Resistance",
            "of the Guardian", "of the Sentinel", "of the Knight", "of the Paladin", "of the Defender"
        ],
        "general": [
            "of Quality", "of Excellence", "of Perfection", "of Mastery", "of Craftsmanship",
            "of the Artisan", "of the Master", "of the Adept", "of the Sage", "of the Scholar",
            "of Fortune", "of Luck", "of Fate", "of Destiny", "of Prophecy",
            "of the Ages", "of the Ancients", "of Legends", "of Myths", "of Legacy"
        ]
    }
    
    @classmethod
    def create_variation(cls, template: Item, quality_override: Optional[float] = None) -> Item:
        """
        Create a variation of an item based on a template.
        
        Args:
            template: The template Item to create a variation from.
            quality_override: Optional quality factor override (0.0 to 2.0).
            
        Returns:
            A new Item instance with modified stats.
        """
        # Create a deep copy of the template
        variation = copy.deepcopy(template)
        
        # Generate a new ID
        variation.id = str(uuid.uuid4())
        
        # Remove template flag
        variation.is_template = False
        
        # Set template_id to reference the original
        variation.template_id = template.id
        
        # Set source
        variation.source = "variation"
        
        # Determine quality factor
        quality = cls._determine_quality(template.rarity) if quality_override is None else quality_override
        
        # Modify stats based on quality
        new_stats = []
        for stat in variation.stats:
            new_stat = ItemStatModifier.apply_quality_factor(stat, quality)
            new_stats.append(new_stat)
        
        variation.stats = new_stats
        
        # Add name prefix/suffix based on quality
        if quality > 1.2:
            variation.name = cls._add_name_affixes(variation)
        
        return variation
    
    @classmethod
    def create_variations(cls, template: Item, count: int) -> List[Item]:
        """
        Create multiple variations of an item.
        
        Args:
            template: The template Item to create variations from.
            count: The number of variations to create.
            
        Returns:
            A list of new Item instances with modified stats.
        """
        variations = []
        for _ in range(count):
            variation = cls.create_variation(template)
            variations.append(variation)
        
        return variations
    
    @classmethod
    def create_upgraded_variation(cls, item: Item, upgrade_level: int) -> Item:
        """
        Create an upgraded variation of an existing item.
        
        Args:
            item: The Item to upgrade.
            upgrade_level: The level of upgrade to apply (1-5 typically).
            
        Returns:
            A new Item instance with improved stats.
        """
        # Create a deep copy of the item
        upgraded = copy.deepcopy(item)
        
        # Generate a new ID
        upgraded.id = str(uuid.uuid4())
        
        # Set source
        upgraded.source = f"upgraded_{upgrade_level}"
        
        # Calculate upgrade quality factor (higher levels give better upgrades)
        upgrade_factor = 1.0 + (upgrade_level * 0.1)  # 1.1, 1.2, 1.3, etc.
        
        # Modify stats based on upgrade factor
        new_stats = []
        for stat in upgraded.stats:
            new_stat = ItemStatModifier.apply_quality_factor(stat, upgrade_factor)
            new_stats.append(new_stat)
        
        upgraded.stats = new_stats
        
        # Modify name to indicate upgrade
        if upgrade_level == 1:
            prefix = "Improved"
        elif upgrade_level == 2:
            prefix = "Superior"
        elif upgrade_level == 3:
            prefix = "Exceptional"
        elif upgrade_level == 4:
            prefix = "Exquisite"
        else:
            prefix = "Masterwork"
        
        upgraded.name = f"{prefix} {upgraded.name}"
        
        return upgraded
    
    @classmethod
    def create_damaged_variation(cls, item: Item, damage_level: int) -> Item:
        """
        Create a damaged variation of an existing item.
        
        Args:
            item: The Item to damage.
            damage_level: The level of damage to apply (1-5 typically).
            
        Returns:
            A new Item instance with reduced stats.
        """
        # Create a deep copy of the item
        damaged = copy.deepcopy(item)
        
        # Generate a new ID
        damaged.id = str(uuid.uuid4())
        
        # Set source
        damaged.source = f"damaged_{damage_level}"
        
        # Calculate damage quality factor (higher levels give worse damage)
        damage_factor = 1.0 - (damage_level * 0.1)  # 0.9, 0.8, 0.7, etc.
        
        # Modify stats based on damage factor
        new_stats = []
        for stat in damaged.stats:
            new_stat = ItemStatModifier.apply_quality_factor(stat, damage_factor)
            new_stats.append(new_stat)
        
        damaged.stats = new_stats
        
        # Modify durability if applicable
        if damaged.durability is not None:
            damaged.current_durability = int(damaged.durability * damage_factor)
        
        # Modify name to indicate damage
        if damage_level == 1:
            prefix = "Worn"
        elif damage_level == 2:
            prefix = "Damaged"
        elif damage_level == 3:
            prefix = "Battered"
        elif damage_level == 4:
            prefix = "Broken"
        else:
            prefix = "Ruined"
        
        damaged.name = f"{prefix} {damaged.name}"
        
        return damaged
    
    @classmethod
    def _determine_quality(cls, rarity: ItemRarity) -> float:
        """
        Determine a random quality factor based on item rarity.
        
        Args:
            rarity: The rarity of the item.
            
        Returns:
            A quality factor value.
        """
        min_quality, max_quality = cls.QUALITY_RANGES.get(
            rarity, (0.8, 1.2)  # Default range for unknown rarities
        )
        
        return random.uniform(min_quality, max_quality)
    
    @classmethod
    def _add_name_affixes(cls, item: Item) -> str:
        """
        Add prefix and/or suffix to an item name based on its type.
        
        Args:
            item: The item to modify.
            
        Returns:
            Modified item name.
        """
        # Determine appropriate prefix/suffix category
        if item.item_type == ItemType.WEAPON:
            category = "weapon"
        elif item.item_type in [ItemType.ARMOR, ItemType.SHIELD]:
            category = "armor"
        else:
            category = "general"
        
        # Get prefix and suffix lists
        prefixes = cls.PREFIXES.get(category, cls.PREFIXES["general"])
        suffixes = cls.SUFFIXES.get(category, cls.SUFFIXES["general"])
        
        # Decide whether to add prefix, suffix, or both
        add_type = random.choices(
            ["prefix", "suffix", "both"],
            weights=[0.4, 0.4, 0.2],
            k=1
        )[0]
        
        name = item.name
        
        if add_type == "prefix" or add_type == "both":
            prefix = random.choice(prefixes)
            name = f"{prefix} {name}"
        
        if add_type == "suffix" or add_type == "both":
            suffix = random.choice(suffixes)
            name = f"{name} {suffix}"
        
        return name

```

### File: core\inventory\narrative_item_creation.py

```python
#!/usr/bin/env python3
"""
Narrative item creation functionality.

This module provides functions for creating items from narrative text
and LLM commands.
"""

import re
import random
import logging
from typing import Dict, List, Optional, Any, Tuple, Set, Union

from core.utils.logging_config import get_logger
from core.inventory import (
    get_inventory_manager, 
    get_item_factory,
    Item, 
    ItemType, 
    ItemRarity, 
    EquipmentSlot,
    ItemStat
)
from core.base.commands import CommandResult

# Get module logger
logger = get_logger("NarrativeItems")

def create_item_from_command(args_text: str, game_state: Any) -> CommandResult:
    """
    Create an item from an ITEM_CREATE command.
    
    Command format: {ITEM_CREATE name rarity:rare type:weapon slot:main_hand [stats]}
    
    Args:
        args_text: The arguments text.
        game_state: The current game state.
            
    Returns:
        CommandResult with the result of the item creation.
    """
    from core.inventory.narrative_item_manager import NarrativeItemManager
    manager = NarrativeItemManager()
    
    # Parse the arguments
    args = manager.parse_command_args(args_text)
    
    if "name" not in args:
        return CommandResult.failure("No item name specified.")
    
    name = args["name"]
    description = args.get("description", f"A {name}.")
    
    # Get type
    item_type = ItemType.MISCELLANEOUS  # Default
    if "type" in args:
        type_str = args["type"].lower()
        item_type = manager._type_mappings.get(type_str, ItemType.MISCELLANEOUS)
    
    # Get rarity
    rarity = ItemRarity.COMMON  # Default
    if "rarity" in args:
        rarity_str = args["rarity"].lower()
        rarity = manager._rarity_mappings.get(rarity_str, ItemRarity.COMMON)
    
    # Equipment-specific properties
    is_equippable = item_type in [ItemType.WEAPON, ItemType.ARMOR, ItemType.ACCESSORY]
    equip_slots = []
    
    if is_equippable and "slot" in args:
        slot_str = args["slot"].lower()
        slot = manager._slot_mappings.get(slot_str)
        if slot:
            equip_slots.append(slot)
    elif is_equippable:
        # Default slots based on item type
        if item_type == ItemType.WEAPON:
            equip_slots.append(EquipmentSlot.MAIN_HAND)
        elif item_type == ItemType.ARMOR:
            # Default to chest armor if not specified
            equip_slots.append(EquipmentSlot.CHEST)
        elif item_type == ItemType.ACCESSORY:
            # Default to neck accessory if not specified
            equip_slots.append(EquipmentSlot.NECK)
    
    # Set default values based on rarity
    rarity_multiplier = {
        ItemRarity.COMMON: 1.0,
        ItemRarity.UNCOMMON: 1.5,
        ItemRarity.RARE: 2.0,
        ItemRarity.EPIC: 3.0,
        ItemRarity.LEGENDARY: 5.0,
        ItemRarity.ARTIFACT: 8.0,
        ItemRarity.UNIQUE: 10.0
    }.get(rarity, 1.0)
    
    # Base value and weight by item type
    base_values = {
        ItemType.WEAPON: 50,
        ItemType.ARMOR: 40,
        ItemType.SHIELD: 45,
        ItemType.CONSUMABLE: 20,
        ItemType.MATERIAL: 5,
        ItemType.QUEST: 0,  # Quest items have no inherent value
        ItemType.ACCESSORY: 35,
        ItemType.CONTAINER: 25,
        ItemType.DOCUMENT: 15,
        ItemType.KEY: 10,
        ItemType.TOOL: 20,
        ItemType.TREASURE: 100,
        ItemType.MISCELLANEOUS: 5
    }
    
    base_weights = {
        ItemType.WEAPON: 4.0,
        ItemType.ARMOR: 5.0,
        ItemType.SHIELD: 6.0,
        ItemType.CONSUMABLE: 0.5,
        ItemType.MATERIAL: 0.2,
        ItemType.QUEST: 0.1,
        ItemType.ACCESSORY: 0.2,
        ItemType.CONTAINER: 2.0,
        ItemType.DOCUMENT: 1.0,
        ItemType.KEY: 0.1,
        ItemType.TOOL: 1.5,
        ItemType.TREASURE: 0.3,
        ItemType.MISCELLANEOUS: 0.5
    }
    
    # Calculate value and weight based on rarity and type
    base_value = base_values.get(item_type, 5)
    value = int(base_value * rarity_multiplier)
    
    base_weight = base_weights.get(item_type, 0.5)
    weight = base_weight
    
    # Get custom value and weight if specified
    if "value" in args:
        try:
            value = int(args["value"])
        except ValueError:
            pass
    
    if "weight" in args:
        try:
            weight = float(args["weight"])
        except ValueError:
            pass
    
    # Check if item is stackable and set quantity
    is_stackable = item_type in [ItemType.MATERIAL, ItemType.CONSUMABLE, ItemType.TREASURE]
    stack_limit = 20 if is_stackable else 1
    quantity = 1
    
    if "quantity" in args:
        try:
            quantity = int(args["quantity"])
            quantity = max(1, min(quantity, stack_limit))
        except ValueError:
            pass
    
    # Consumable-specific properties
    is_consumable = item_type == ItemType.CONSUMABLE
    
    # Durability for equipment
    durability = 0
    if is_equippable:
        durability = int(100 * rarity_multiplier)
        
        if "durability" in args:
            try:
                durability = int(args["durability"])
            except ValueError:
                pass
    
    # Create stats
    stats = []
    
    # Extract stats from args
    for key, value_str in args.items():
        if key in ["name", "description", "type", "rarity", "slot", "value", "weight", "quantity", "durability"]:
            continue
        
        # Check if this is a valid stat name
        for stat_name, normalized_name in manager._stat_mappings.items():
            if key.lower() == stat_name.lower():
                try:
                    stat_value = float(value_str)
                    stats.append(ItemStat(normalized_name, stat_value))
                    break
                except ValueError:
                    logger.warning(f"Invalid stat value for {key}: {value_str}")
    
    # Create the item
    item_factory = get_item_factory()
    inventory = get_inventory_manager()
    
    item = Item(
        name=name,
        description=description,
        item_type=item_type,
        rarity=rarity,
        weight=weight,
        value=value,
        icon_path="",  # Default icon will be assigned by factory
        is_equippable=is_equippable,
        equip_slots=equip_slots,
        stats=stats,
        is_consumable=is_consumable,
        is_stackable=is_stackable,
        stack_limit=stack_limit,
        quantity=quantity,
        is_quest_item=item_type == ItemType.QUEST,
        durability=durability,
        current_durability=durability,
        tags=[],
        template_id=f"narrative_{item_type.value.lower()}",
        source="narrative",
        custom_properties={}
    )
    
    # Add item to inventory
    item_ids = inventory.add_item(item)
    
    if not item_ids:
        return CommandResult.failure(f"Failed to add {name} to inventory. Check weight and slot limits.")
    
    # Generate response message
    if quantity > 1:
        message = f"You acquired {quantity}x {name}."
    else:
        message = f"You acquired {name}."
    
    return CommandResult.success(message, {"item_ids": item_ids})

def generate_loot_from_command(args_text: str, game_state: Any) -> CommandResult:
    """
    Generate loot from a LOOT_GENERATE command.
    
    Command format: {LOOT_GENERATE enemy_type:goblin level:5 quality:good count:3}
    
    Args:
        args_text: The arguments text.
        game_state: The current game state.
            
    Returns:
        CommandResult with the result of the loot generation.
    """
    from core.inventory.narrative_item_manager import NarrativeItemManager
    manager = NarrativeItemManager()
    
    # Parse the arguments
    args = manager.parse_command_args(args_text)
    
    # Get enemy type and level
    enemy_type = args.get("enemy_type", "monster")
    
    level = 1
    if "level" in args:
        try:
            level = int(args["level"])
            level = max(1, level)
        except ValueError:
            pass
    
    # Get loot quality
    quality_values = {
        "poor": 0.5,
        "low": 0.75,
        "normal": 1.0,
        "good": 1.5,
        "excellent": 2.0
    }
    
    quality = args.get("quality", "normal").lower()
    quality_multiplier = quality_values.get(quality, 1.0)
    
    # Get item count
    count = 1
    if "count" in args:
        try:
            count = int(args["count"])
            count = max(1, min(count, 10))  # Limit to 10 items max
        except ValueError:
            pass
    
    # Calculate rarity weights based on level and quality
    rarity_weights = {
        ItemRarity.COMMON: max(0.05, 0.8 - (level * 0.05)),
        ItemRarity.UNCOMMON: min(0.6, 0.15 + (level * 0.03)),
        ItemRarity.RARE: min(0.4, 0.03 + (level * 0.02)),
        ItemRarity.EPIC: min(0.2, 0.01 + (level * 0.01)),
        ItemRarity.LEGENDARY: min(0.1, 0.001 + (level * 0.005)),
        ItemRarity.ARTIFACT: min(0.05, 0.0001 + (level * 0.001)),
        ItemRarity.UNIQUE: min(0.01, 0.00001 + (level * 0.0005))
    }
    
    # Adjust weights based on quality
    for rarity in rarity_weights:
        if rarity == ItemRarity.COMMON:
            rarity_weights[rarity] /= quality_multiplier
        else:
            rarity_weights[rarity] *= quality_multiplier
    
    # Normalize weights
    total_weight = sum(rarity_weights.values())
    for rarity in rarity_weights:
        rarity_weights[rarity] /= total_weight
    
    # Generate loot
    item_factory = get_item_factory()
    loot = item_factory.create_loot_table(
        item_count=count,
        rarity_weights=rarity_weights,
        level_range=(max(1, level-2), level+2)
    )
    
    # Add items to inventory
    inventory = get_inventory_manager()
    added_items = []
    
    for item in loot:
        item_ids = inventory.add_item(item)
        if item_ids:
            added_items.append((item, item_ids[0]))
    
    if not added_items:
        return CommandResult.failure(f"No loot could be added to inventory. Check weight and slot limits.")
    
    # Generate response message
    if len(added_items) == 1:
        item, _ = added_items[0]
        message = f"You found {item.name}."
    else:
        message = f"You found {len(added_items)} items:"
        for item, _ in added_items:
            message += f"\n- {item.name}"
    
    return CommandResult.success(message, {"item_count": len(added_items)})

```

### File: core\inventory\narrative_item_discovery.py

```python
#!/usr/bin/env python3
"""
Narrative item discovery functionality.

This module provides functions for discovering and examining items
in the narrative context.
"""

import re
import random
import logging
from typing import Dict, List, Optional, Any, Tuple, Set, Union

from core.utils.logging_config import get_logger
from core.inventory import get_inventory_manager
from core.base.commands import CommandResult

# Get module logger
logger = get_logger("NarrativeItems")

def discover_item_from_command(args_text: str, game_state: Any) -> CommandResult:
    """
    Discover an item's properties from an ITEM_DISCOVER command.
    
    Command format: {ITEM_DISCOVER item:item_id_or_name property:description}
    
    Args:
        args_text: The arguments text.
        game_state: The current game state.
            
    Returns:
        CommandResult with the result of the item discovery.
    """
    from core.inventory.narrative_item_manager import NarrativeItemManager
    manager = NarrativeItemManager()
    
    # Parse the arguments
    args = manager.parse_command_args(args_text)
    
    if "item" not in args:
        return CommandResult.failure("No item specified for discovery.")
    
    # Get the item
    inventory = get_inventory_manager()
    item_id_or_name = args["item"]
    
    # Try to find the item by ID first
    item = inventory.get_item(item_id_or_name)
    
    # If not found by ID, try by name (case-insensitive partial match)
    if not item:
        for inv_item in inventory.items.values():
            if item_id_or_name.lower() in inv_item.name.lower():
                item = inv_item
                break
    
    if not item:
        return CommandResult.failure(f"Item '{item_id_or_name}' not found in inventory.")
    
    # Check if we're discovering a specific property
    if "property" in args:
        property_name = args["property"].lower()
        
        # Check if it's a stat
        for stat_name, normalized_name in manager._stat_mappings.items():
            if property_name == stat_name.lower() or property_name == normalized_name.lower():
                # Find the stat in the item
                for stat in item.stats:
                    if stat.name.lower() == normalized_name.lower():
                        if item.discover_stat(stat.name):
                            return CommandResult.success(
                                f"You discover that the {item.name} has {stat.name} of {stat.value}.",
                                {"item_id": item.id, "property": f"stat_{stat.name}"}
                            )
                        else:
                            return CommandResult.success(
                                f"You already knew that the {item.name} has {stat.name} of {stat.value}.",
                                {"item_id": item.id, "property": f"stat_{stat.name}"}
                            )
                
                return CommandResult.failure(f"The {item.name} doesn't have a {property_name} stat.")
        
        # Check if it's a standard property
        standard_properties = ["description", "weight", "value", "durability"]
        for prop in standard_properties:
            if property_name == prop.lower():
                if item.discover_property(prop):
                    value = getattr(item, prop)
                    if prop == "value":
                        from core.inventory.currency_manager import format_currency
                        value = format_currency(value)
                    
                    return CommandResult.success(
                        f"You discover that the {item.name} has a {prop} of {value}.",
                        {"item_id": item.id, "property": prop}
                    )
                else:
                    value = getattr(item, prop)
                    if prop == "value":
                        from core.inventory.currency_manager import format_currency
                        value = format_currency(value)
                    
                    return CommandResult.success(
                        f"You already knew that the {item.name} has a {prop} of {value}.",
                        {"item_id": item.id, "property": prop}
                    )
        
        # Check if it's a custom property
        for custom_prop in item.custom_properties:
            if property_name == custom_prop.lower():
                prop_key = f"custom_{custom_prop}"
                if item.discover_property(prop_key):
                    value = item.custom_properties[custom_prop]
                    return CommandResult.success(
                        f"You discover that the {item.name} has a {custom_prop} of {value}.",
                        {"item_id": item.id, "property": prop_key}
                    )
                else:
                    value = item.custom_properties[custom_prop]
                    return CommandResult.success(
                        f"You already knew that the {item.name} has a {custom_prop} of {value}.",
                        {"item_id": item.id, "property": prop_key}
                    )
        
        # Property not found
        return CommandResult.failure(f"The {item.name} doesn't have a {property_name} property.")
    
    # If no specific property was specified, discover something random
    # Get all discoverable properties that aren't known yet
    all_props = set(dir(item))
    all_props = {prop for prop in all_props 
                if not prop.startswith('_') and not callable(getattr(item, prop))}
    stat_props = {f"stat_{stat.name}" for stat in item.stats}
    custom_props = {f"custom_{key}" for key in item.custom_properties.keys()}
    
    all_discoverable = all_props.union(stat_props).union(custom_props)
    unknown = all_discoverable - set(item.known_properties)
    
    if not unknown:
        return CommandResult.success(
            f"You've already discovered everything about the {item.name}.",
            {"item_id": item.id, "property": None}
        )
    
    # Discover a random unknown property
    prop_to_discover = random.choice(list(unknown))
    
    if prop_to_discover.startswith("stat_"):
        stat_name = prop_to_discover[5:]  # Remove "stat_" prefix
        if item.discover_stat(stat_name):
            # Find the stat value
            for stat in item.stats:
                if stat.name == stat_name:
                    return CommandResult.success(
                        f"You discover that the {item.name} has {stat_name} of {stat.value}.",
                        {"item_id": item.id, "property": f"stat_{stat_name}"}
                    )
    elif prop_to_discover.startswith("custom_"):
        custom_name = prop_to_discover[7:]  # Remove "custom_" prefix
        if item.discover_property(f"custom_{custom_name}"):
            value = item.custom_properties[custom_name]
            return CommandResult.success(
                f"You discover that the {item.name} has a {custom_name} of {value}.",
                {"item_id": item.id, "property": f"custom_{custom_name}"}
            )
    else:
        if item.discover_property(prop_to_discover):
            value = getattr(item, prop_to_discover)
            
            if prop_to_discover == "description":
                return CommandResult.success(
                    f"You examine the {item.name} more closely. {value}",
                    {"item_id": item.id, "property": prop_to_discover}
                )
            elif prop_to_discover == "value":
                from core.inventory.currency_manager import format_currency
                value = format_currency(value)
                return CommandResult.success(
                    f"You assess the {item.name} and determine it's worth about {value}.",
                    {"item_id": item.id, "property": prop_to_discover}
                )
            elif prop_to_discover == "weight":
                return CommandResult.success(
                    f"You heft the {item.name} and estimate it weighs around {value} units.",
                    {"item_id": item.id, "property": prop_to_discover}
                )
            elif prop_to_discover == "durability":
                durability_percent = (item.current_durability / item.durability) * 100
                condition = "excellent"
                if durability_percent < 20:
                    condition = "very poor"
                elif durability_percent < 40:
                    condition = "poor"
                elif durability_percent < 60:
                    condition = "fair"
                elif durability_percent < 80:
                    condition = "good"
                
                return CommandResult.success(
                    f"You inspect the {item.name} and find it's in {condition} condition.",
                    {"item_id": item.id, "property": prop_to_discover}
                )
            else:
                return CommandResult.success(
                    f"You discover that the {item.name} has a {prop_to_discover} of {value}.",
                    {"item_id": item.id, "property": prop_to_discover}
                )
    
    # This should not happen, but just in case
    return CommandResult.success(
        f"You study the {item.name} but don't learn anything new.",
        {"item_id": item.id, "property": None}
    )

```

### File: core\inventory\narrative_item_manager.py

```python
#!/usr/bin/env python3
"""
Narrative Item Manager for the RPG game.

This module provides a manager that enables the LLM to create and manage items
through narrative text. It parses narrative text for item references and generates
items based on the LLM's descriptions.
"""

import re
import logging
import random
from typing import Dict, List, Optional, Any, Tuple, Set, Union
import json

from core.utils.logging_config import get_logger
from core.inventory import (
    get_inventory_manager, 
    get_item_factory,
    Item, 
    ItemType, 
    ItemRarity, 
    EquipmentSlot,
    ItemStat
)
from core.base.commands import CommandResult

# Get module logger
logger = get_logger("NarrativeItems")


class NarrativeItemManager:
    """
    Manager for creating and tracking items described in narrative text.
    
    This class provides methods for parsing item descriptions from narrative
    text, generating items from LLM descriptions, and creating loot drops
    for combat encounters.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(NarrativeItemManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the narrative item manager."""
        if self._initialized:
            return
        
        # Initialize inventory manager and item factory
        self._inventory = get_inventory_manager()
        self._item_factory = get_item_factory()
        
        # Initialize command patterns
        self._item_create_pattern = re.compile(r'\{ITEM_CREATE\s+(.+?)\}')
        self._item_discover_pattern = re.compile(r'\{ITEM_DISCOVER\s+(.+?)\}')
        self._loot_generate_pattern = re.compile(r'\{LOOT_GENERATE\s+(.+?)\}')
        
        # Initialize mappings from the mappings module
        from core.inventory.narrative_item_mappings import (
            get_type_mappings,
            get_rarity_mappings,
            get_slot_mappings,
            get_stat_mappings
        )
        
        self._type_mappings = get_type_mappings()
        self._rarity_mappings = get_rarity_mappings()
        self._slot_mappings = get_slot_mappings()
        self._stat_mappings = get_stat_mappings()
        
        self._initialized = True
        logger.info("Narrative item manager initialized")
    
    def process_narrative_commands(self, text: str, game_state: Any) -> Tuple[str, List[CommandResult]]:
        """
        Process item-related commands in narrative text.
        
        Args:
            text: The narrative text containing commands.
            game_state: The current game state.
            
        Returns:
            A tuple of (processed_text, command_results).
        """
        from core.inventory.narrative_item_creation import create_item_from_command, generate_loot_from_command
        from core.inventory.narrative_item_discovery import discover_item_from_command
        
        results = []
        processed_text = text
        
        # Process ITEM_CREATE commands
        for match in self._item_create_pattern.finditer(text):
            command_text = match.group(0)
            args_text = match.group(1)
            
            try:
                result = create_item_from_command(args_text, game_state)
                results.append(result)
                
                # Replace the command with its result
                replacement = result.message if result.is_success else f"[Item Creation Failed: {result.message}]"
                processed_text = processed_text.replace(command_text, replacement)
            except Exception as e:
                logger.error(f"Error processing ITEM_CREATE command: {e}", exc_info=True)
                processed_text = processed_text.replace(command_text, f"[Item Creation Error: {e}]")
        
        # Process ITEM_DISCOVER commands
        for match in self._item_discover_pattern.finditer(text):
            command_text = match.group(0)
            args_text = match.group(1)
            
            try:
                result = discover_item_from_command(args_text, game_state)
                results.append(result)
                
                # Replace the command with its result
                replacement = result.message if result.is_success else f"[Item Discovery Failed: {result.message}]"
                processed_text = processed_text.replace(command_text, replacement)
            except Exception as e:
                logger.error(f"Error processing ITEM_DISCOVER command: {e}", exc_info=True)
                processed_text = processed_text.replace(command_text, f"[Item Discovery Error: {e}]")
        
        # Process LOOT_GENERATE commands
        for match in self._loot_generate_pattern.finditer(text):
            command_text = match.group(0)
            args_text = match.group(1)
            
            try:
                result = generate_loot_from_command(args_text, game_state)
                results.append(result)
                
                # Replace the command with its result
                replacement = result.message if result.is_success else f"[Loot Generation Failed: {result.message}]"
                processed_text = processed_text.replace(command_text, replacement)
            except Exception as e:
                logger.error(f"Error processing LOOT_GENERATE command: {e}", exc_info=True)
                processed_text = processed_text.replace(command_text, f"[Loot Generation Error: {e}]")
        
        return processed_text, results
    
    def parse_command_args(self, args_text: str) -> Dict[str, str]:
        """
        Parse command arguments into a dictionary.
        
        Args:
            args_text: Space-separated arguments text.
            
        Returns:
            Dictionary of argument key-value pairs.
        """
        args = {}
        parts = args_text.split()
        
        # The first argument is always the item name
        if parts:
            args["name"] = parts[0]
            
            # Process the remaining arguments as key-value pairs
            for i in range(1, len(parts)):
                part = parts[i]
                if ":" in part:
                    key, value = part.split(":", 1)
                    args[key.lower()] = value
        
        return args

```

### File: core\inventory\narrative_item_mappings.py

```python
#!/usr/bin/env python3
"""
Mappings for narrative item generation.

This module provides mappings between natural language terms and
game enums for item types, rarities, equipment slots, and stats.
"""

from core.inventory import ItemType, ItemRarity, EquipmentSlot

def get_type_mappings() -> dict:
    """
    Get mappings from natural language to ItemType.
    
    Returns:
        Dictionary mapping strings to ItemType enums.
    """
    return {
        "weapon": ItemType.WEAPON,
        "sword": ItemType.WEAPON,
        "axe": ItemType.WEAPON,
        "mace": ItemType.WEAPON,
        "dagger": ItemType.WEAPON,
        "staff": ItemType.WEAPON,
        "wand": ItemType.WEAPON,
        "bow": ItemType.WEAPON,
        "crossbow": ItemType.WEAPON,
        "spear": ItemType.WEAPON,
        "hammer": ItemType.WEAPON,
        
        "armor": ItemType.ARMOR,
        "helmet": ItemType.ARMOR,
        "breastplate": ItemType.ARMOR,
        "greaves": ItemType.ARMOR,
        "boots": ItemType.ARMOR,
        "gauntlets": ItemType.ARMOR,
        "robe": ItemType.ARMOR,
        
        "shield": ItemType.SHIELD,
        "buckler": ItemType.SHIELD,
        "tower shield": ItemType.SHIELD,
        
        "potion": ItemType.CONSUMABLE,
        "elixir": ItemType.CONSUMABLE,
        "flask": ItemType.CONSUMABLE,
        "vial": ItemType.CONSUMABLE,
        
        "consumable": ItemType.CONSUMABLE,
        "food": ItemType.CONSUMABLE,
        "drink": ItemType.CONSUMABLE,
        "scroll": ItemType.CONSUMABLE,
        
        "material": ItemType.MATERIAL,
        "ingredient": ItemType.MATERIAL,
        "ore": ItemType.MATERIAL,
        "cloth": ItemType.MATERIAL,
        "leather": ItemType.MATERIAL,
        "wood": ItemType.MATERIAL,
        "stone": ItemType.MATERIAL,
        "metal": ItemType.MATERIAL,
        "herb": ItemType.MATERIAL,
        
        "quest item": ItemType.QUEST,
        "quest": ItemType.QUEST,
        "artifact": ItemType.QUEST,
        
        "trinket": ItemType.ACCESSORY,
        
        "accessory": ItemType.ACCESSORY,
        "jewelry": ItemType.ACCESSORY,
        "ring": ItemType.ACCESSORY,
        "amulet": ItemType.ACCESSORY,
        "necklace": ItemType.ACCESSORY,
        "pendant": ItemType.ACCESSORY,
        "earring": ItemType.ACCESSORY,
        "bracelet": ItemType.ACCESSORY,
        
        "container": ItemType.CONTAINER,
        "bag": ItemType.CONTAINER,
        "pouch": ItemType.CONTAINER,
        "sack": ItemType.CONTAINER,
        "chest": ItemType.CONTAINER,
        "box": ItemType.CONTAINER,
        
        "book": ItemType.DOCUMENT,
        "tome": ItemType.DOCUMENT,
        "codex": ItemType.DOCUMENT,
        "scroll": ItemType.DOCUMENT,
        
        "note": ItemType.DOCUMENT,
        "letter": ItemType.DOCUMENT,
        "map": ItemType.DOCUMENT,
        "document": ItemType.DOCUMENT,
        
        "key": ItemType.KEY,
        "lockpick": ItemType.KEY,
        
        "tool": ItemType.TOOL,
        "instrument": ItemType.TOOL,
        
        "treasure": ItemType.TREASURE,
        "gem": ItemType.TREASURE,
        "jewel": ItemType.TREASURE,
        
        "miscellaneous": ItemType.MISCELLANEOUS,
        "misc": ItemType.MISCELLANEOUS,
        
        "gold": ItemType.TREASURE,
        "silver": ItemType.TREASURE,
        "copper": ItemType.TREASURE,
        "coin": ItemType.TREASURE,
        "currency": ItemType.TREASURE,
        "money": ItemType.TREASURE,
    }

def get_rarity_mappings() -> dict:
    """
    Get mappings from natural language to ItemRarity.
    
    Returns:
        Dictionary mapping strings to ItemRarity enums.
    """
    return {
        "common": ItemRarity.COMMON,
        "uncommon": ItemRarity.UNCOMMON,
        "rare": ItemRarity.RARE,
        "epic": ItemRarity.EPIC,
        "legendary": ItemRarity.LEGENDARY,
        "artifact": ItemRarity.ARTIFACT,
        "unique": ItemRarity.UNIQUE,
        
        # Additional synonyms
        "ordinary": ItemRarity.COMMON,
        "basic": ItemRarity.COMMON,
        "standard": ItemRarity.COMMON,
        
        "unusual": ItemRarity.UNCOMMON,
        "special": ItemRarity.UNCOMMON,
        
        "scarce": ItemRarity.RARE,
        "exceptional": ItemRarity.RARE,
        
        "magnificent": ItemRarity.EPIC,
        "superior": ItemRarity.EPIC,
        
        "mythical": ItemRarity.LEGENDARY,
        "mythic": ItemRarity.LEGENDARY,
        "ancient": ItemRarity.LEGENDARY,
        
        "divine": ItemRarity.ARTIFACT,
        "godly": ItemRarity.ARTIFACT,
        
        "one of a kind": ItemRarity.UNIQUE,
        "singular": ItemRarity.UNIQUE,
    }

def get_slot_mappings() -> dict:
    """
    Get mappings from natural language to EquipmentSlot.
    
    Returns:
        Dictionary mapping strings to EquipmentSlot enums.
    """
    return {
        "main hand": EquipmentSlot.MAIN_HAND,
        "off hand": EquipmentSlot.OFF_HAND,
        "head": EquipmentSlot.HEAD,
        "chest": EquipmentSlot.CHEST,
        "legs": EquipmentSlot.LEGS,
        "feet": EquipmentSlot.FEET,
        "shoulders": EquipmentSlot.SHOULDERS,
        "wrists": EquipmentSlot.WRISTS,
        "hands": EquipmentSlot.HANDS,
        "waist": EquipmentSlot.WAIST,
        "neck": EquipmentSlot.NECK,
        "back": EquipmentSlot.BACK,
        "finger1": EquipmentSlot.FINGER_1,
        "finger2": EquipmentSlot.FINGER_2,
        "finger3": EquipmentSlot.FINGER_3,
        "finger4": EquipmentSlot.FINGER_4,
        "finger5": EquipmentSlot.FINGER_5,
        "finger6": EquipmentSlot.FINGER_6,
        "finger7": EquipmentSlot.FINGER_7,
        "finger8": EquipmentSlot.FINGER_8,
        "finger9": EquipmentSlot.FINGER_9,
        "finger10": EquipmentSlot.FINGER_10,
        "trinket1": EquipmentSlot.TRINKET_1,
        "trinket2": EquipmentSlot.TRINKET_2,
        
        # Common synonyms
        "weapon": EquipmentSlot.MAIN_HAND,
        "sword": EquipmentSlot.MAIN_HAND,
        "axe": EquipmentSlot.MAIN_HAND,
        "mace": EquipmentSlot.MAIN_HAND,
        "dagger": EquipmentSlot.MAIN_HAND,
        "staff": EquipmentSlot.MAIN_HAND,
        "wand": EquipmentSlot.MAIN_HAND,
        "bow": EquipmentSlot.MAIN_HAND,
        
        "shield": EquipmentSlot.OFF_HAND,
        "offhand": EquipmentSlot.OFF_HAND,
        "left hand": EquipmentSlot.OFF_HAND,
        
        "helmet": EquipmentSlot.HEAD,
        "hat": EquipmentSlot.HEAD,
        "crown": EquipmentSlot.HEAD,
        "headpiece": EquipmentSlot.HEAD,
        
        "armor": EquipmentSlot.CHEST,
        "breastplate": EquipmentSlot.CHEST,
        "robe": EquipmentSlot.CHEST,
        "tunic": EquipmentSlot.CHEST,
        "chestpiece": EquipmentSlot.CHEST,
        "torso": EquipmentSlot.CHEST,
        
        "pants": EquipmentSlot.LEGS,
        "greaves": EquipmentSlot.LEGS,
        "leggings": EquipmentSlot.LEGS,
        
        "boots": EquipmentSlot.FEET,
        "shoes": EquipmentSlot.FEET,
        "footwear": EquipmentSlot.FEET,
        
        "pauldrons": EquipmentSlot.SHOULDERS,
        "shoulder pads": EquipmentSlot.SHOULDERS,
        
        "bracers": EquipmentSlot.WRISTS,
        "armguards": EquipmentSlot.WRISTS,
        "sleeves": EquipmentSlot.WRISTS,
        
        "gloves": EquipmentSlot.HANDS,
        "gauntlets": EquipmentSlot.HANDS,
        
        "belt": EquipmentSlot.WAIST,
        "girdle": EquipmentSlot.WAIST,
        "sash": EquipmentSlot.WAIST,
        
        "amulet": EquipmentSlot.NECK,
        "pendant": EquipmentSlot.NECK,
        "necklace": EquipmentSlot.NECK,
        "collar": EquipmentSlot.NECK,
        
        "cloak": EquipmentSlot.BACK,
        "cape": EquipmentSlot.BACK,
        "mantle": EquipmentSlot.BACK,
        
        "ring": EquipmentSlot.FINGER_1,
        "finger": EquipmentSlot.FINGER_1,
        
        "bracelet": EquipmentSlot.WRISTS,
        "wristband": EquipmentSlot.WRISTS,
        "bracer": EquipmentSlot.WRISTS,
    }

def get_stat_mappings() -> dict:
    """
    Get mappings from natural language to stat names.
    
    Returns:
        Dictionary mapping strings to stat names.
    """
    return {
        # Combat stats
        "damage": "damage",
        "attack": "damage",
        "power": "damage",
        "strength": "strength",
        "str": "strength",
        "dexterity": "dexterity",
        "dex": "dexterity",
        "agility": "agility",
        "agi": "agility",
        "intelligence": "intelligence",
        "int": "intelligence",
        "wisdom": "wisdom",
        "wis": "wisdom",
        "constitution": "constitution",
        "con": "constitution",
        "vitality": "vitality",
        "vit": "vitality",
        "charisma": "charisma",
        "cha": "charisma",
        "armor": "armor",
        "defense": "defense",
        "protection": "defense",
        "block": "block",
        "parry": "parry",
        "dodge": "dodge",
        "evasion": "dodge",
        "accuracy": "accuracy",
        "hit": "accuracy",
        "critical": "critical",
        "crit": "critical",
        "speed": "speed",
        "attack speed": "attack_speed",
        "attack_speed": "attack_speed",
        "movement speed": "movement_speed",
        "movement_speed": "movement_speed",
        
        # Health stats
        "health": "health",
        "hp": "health",
        "health regeneration": "health_regen",
        "health_regen": "health_regen",
        "hp regen": "health_regen",
        "healing": "healing",
        
        # Energy stats
        "mana": "mana",
        "mp": "mana",
        "energy": "energy",
        "stamina": "stamina",
        "focus": "focus",
        "mana regeneration": "mana_regen",
        "mana_regen": "mana_regen",
        "energy regeneration": "energy_regen",
        "energy_regen": "energy_regen",
        
        # Resistances
        "fire resistance": "fire_resistance",
        "fire_resistance": "fire_resistance",
        "cold resistance": "cold_resistance",
        "cold_resistance": "cold_resistance",
        "lightning resistance": "lightning_resistance",
        "lightning_resistance": "lightning_resistance",
        "poison resistance": "poison_resistance",
        "poison_resistance": "poison_resistance",
        "magic resistance": "magic_resistance",
        "magic_resistance": "magic_resistance",
        "physical resistance": "physical_resistance",
        "physical_resistance": "physical_resistance",
        
        # Utility
        "luck": "luck",
        "fortune": "luck",
        "stealth": "stealth",
        "lockpicking": "lockpicking",
        "pickpocket": "pickpocket",
        "perception": "perception",
        "crafting": "crafting",
        "gathering": "gathering",
        "bargaining": "bargaining",
    }

```

### File: world_configurator\ui\main_window.py

```python
"""
Main window for the World Configurator Tool.
"""

import os
import sys
import logging
from typing import Optional, Dict, Any, Tuple

import json
from PySide6.QtCore import Qt, QSize, Signal, Slot
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QTabWidget, QPushButton, QMenuBar, QMenu,
    QToolBar, QFileDialog, QMessageBox, QDialog,
    QStatusBar, QLabel, QSplitter, QTextEdit, QComboBox
)
from PySide6.QtGui import QIcon, QCloseEvent, QAction, QFont

# Corrected import path assumption (models likely in a subfolder)
from models.world_config import WorldConfigManager
from utils.file_manager import get_project_root, get_world_config_dir, load_json

from .editors.culture_editor import CultureEditor
from .editors.location_editor import LocationEditor
from .editors.history_editor import HistoryEditor
# Renamed import
from .editors.origin_editor import OriginEditor
from .editors.quest_editor import QuestEditor
from .editors.magic_systems_editor import MagicSystemsEditor
from .editors.names_editor import NamesEditor
from .editors.class_editor import ClassEditor
from .editors.race_editor import RaceEditor
# Removed BackgroundEditor import
# from .editors.background_editor import BackgroundEditor

from .dialogs.new_project_dialog import NewProjectDialog
from .dialogs.export_dialog import ExportDialog
from .dialogs.settings_dialog import SettingsDialog

logger = logging.getLogger("world_configurator.ui.main_window")

class MainWindow(QMainWindow):
    """Main window for the World Configurator Tool."""

    # Signals
    project_loaded = Signal(str)  # Project path
    project_saved = Signal(str)  # Project path

    def __init__(self):
        """Initialize the main window."""
        super().__init__()

        # Initialize world config manager
        self.world_config = WorldConfigManager()

        # Set up UI
        self.setup_ui()

        # Set up actions
        self.setup_actions()

        # Set up menus
        self.setup_menus()

        # Set up toolbar
        self.setup_toolbar()

        # Set up status bar
        self.setup_status_bar()

        # Load settings
        self.load_settings()

        # Set window title
        self.update_window_title()

        logger.info("Main window initialized")

        # Show welcome information
        self.show_welcome_info()

    def show_welcome_info(self):
        """Show welcome information to help users get started."""
        QMessageBox.information(
            self,
            "Welcome to World Configurator",
            "Welcome to the World Configurator Tool!\n\n"
            "Currently, the following editors are fully implemented:\n"
            "- Cultures: Create and edit cultures\n"
            "- Races: Create and edit races\n" # Added
            "- Classes: Create and edit classes\n" # Added
            "- Locations: Create and edit locations\n"
            "- World History: Create and edit historical eras and events\n"
            "- Origins: Create and edit starting origins (scenarios)\n" # Updated
            "- Quests: Create and edit quests and objectives\n"
            "- Magic Systems: Create and edit magic systems\n\n" # Added
            "To edit your existing game data, use the 'File > Load from Game' option.\n"
            "This will load your existing JSON files from your game's configuration directory.\n\n"
            "When you export your changes, backup copies of your original files\n"
            "will be automatically created with timestamped filenames in a 'backup' folder."
        )

    def setup_ui(self):
        """Set up the UI components."""
        # Set window properties
        self.setWindowTitle("World Configurator")
        self.setMinimumSize(1000, 700)

        # Create main layout and central widget
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout(self.central_widget)
        self.main_layout.setContentsMargins(5, 5, 5, 5)

        # Create splitter for resizable panels
        self.main_splitter = QSplitter(Qt.Horizontal)
        self.main_layout.addWidget(self.main_splitter)

        # Create tab widget for editors
        self.tab_widget = QTabWidget()
        self.main_splitter.addWidget(self.tab_widget)

        # Create editor widgets
        self.create_editor_tabs()

        # Assistant dock
        from assistant.panel import AssistantDock
        self.assistant_dock = AssistantDock(self, get_provider_cb=self._get_active_assistant_provider)
        self.addDockWidget(Qt.RightDockWidgetArea, self.assistant_dock)

        logger.debug("UI components set up")

    def create_editor_tabs(self):
        """Create tabs for the different editors."""
        # Culture editor
        self.culture_editor = CultureEditor()
        self.culture_editor.set_culture_manager(self.world_config.culture_manager)
        self.tab_widget.addTab(self.culture_editor, "Cultures")

        # Race editor
        self.race_editor = RaceEditor()
        self.race_editor.set_race_manager(self.world_config.race_manager)
        self.tab_widget.addTab(self.race_editor, "Races")

        # Class editor
        self.class_editor = ClassEditor()
        self.class_editor.set_class_manager(self.world_config.class_manager)
        self.tab_widget.addTab(self.class_editor, "Classes")

        # Skills editor - NEW
        from .editors.skills_editor import SkillsEditor # Local import
        self.skills_editor = SkillsEditor()
        # self.skills_editor.set_skill_manager(self.world_config.skill_manager) # Assuming skill_manager exists or will be added
        self.tab_widget.addTab(self.skills_editor, "Skills")

        # Items editor panel - NEW
        from .editors.item_editor_panel import ItemEditorPanel # Local import
        self.item_editor_panel = ItemEditorPanel()
        # self.item_editor_panel.set_item_managers(...) # If it needs access to managers
        self.tab_widget.addTab(self.item_editor_panel, "Items")

        # Location editor
        self.location_editor = LocationEditor()
        self.location_editor.set_managers(
            self.world_config.location_manager,
            self.world_config.culture_manager,
            self.world_config.location_defaults_manager
        )
        self.tab_widget.addTab(self.location_editor, "Locations")

        # History editor
        self.history_editor = HistoryEditor()
        self.history_editor.set_managers(
            self.world_config.history_manager,
            self.world_config.culture_manager,
            self.world_config.location_manager
        )
        self.tab_widget.addTab(self.history_editor, "World History")

        # Origin editor
        self.origin_editor = OriginEditor()
        self.origin_editor.set_managers(
            self.world_config.origin_manager,
            self.world_config.location_manager,
            self.world_config.quest_manager
            # Potentially pass skill manager/data source here if needed for selection dialogs
            # self.world_config.skill_manager 
        )
        self.tab_widget.addTab(self.origin_editor, "Origins")

        # Quest editor
        self.quest_editor = QuestEditor()
        self.quest_editor.set_managers(
            self.world_config.quest_manager,
            self.world_config.location_manager
        )
        self.tab_widget.addTab(self.quest_editor, "Quests")

        # Magic Systems editor
        self.magic_systems_editor = MagicSystemsEditor()
        self.magic_systems_editor.set_magic_system_manager(self.world_config.magic_system_manager)
        self.tab_widget.addTab(self.magic_systems_editor, "Magic Systems")

        # Names editor (npc/names.json)
        self.names_editor = NamesEditor()
        self.names_editor.set_manager(self.world_config.names_manager)
        self.tab_widget.addTab(self.names_editor, "Names")
        
        # Variants editor (npc/variants.json)
        from .editors.variants_editor import VariantsEditor
        self.variants_editor = VariantsEditor()
        self.variants_editor.set_manager(self.world_config.variants_manager)
        self.tab_widget.addTab(self.variants_editor, "NPC Variants")

        # Connect modified signals
        self.culture_editor.culture_modified.connect(self.on_data_modified)
        self.race_editor.race_modified.connect(self.on_data_modified)
        self.class_editor.class_modified.connect(self.on_data_modified)
        self.skills_editor.skills_modified.connect(self.on_data_modified) # NEW
        self.item_editor_panel.item_data_modified.connect(self.on_data_modified) # NEW
        self.location_editor.location_modified.connect(self.on_data_modified)
        self.history_editor.history_modified.connect(self.on_data_modified)
        self.origin_editor.origin_modified.connect(self.on_data_modified)
        self.quest_editor.quest_modified.connect(self.on_data_modified)
        self.magic_systems_editor.magic_system_modified.connect(self.on_data_modified)
        if hasattr(self, 'names_editor'):
            self.names_editor.names_modified.connect(self.on_data_modified)
        if hasattr(self, 'variants_editor'):
            self.variants_editor.variants_modified.connect(self.on_data_modified)

        logger.debug("Editor tabs created")
    def setup_actions(self):
        """Set up actions for the main window."""
        # File actions
        self.action_new = QAction(QIcon.fromTheme("document-new", QIcon(os.path.join(get_project_root(), "world_configurator/ui/icons/new.png"))), "New Project", self)
        self.action_new.setShortcut("Ctrl+N")
        self.action_new.triggered.connect(self.on_new_project)

        self.action_open = QAction(QIcon.fromTheme("document-open", QIcon(os.path.join(get_project_root(), "world_configurator/ui/icons/open.png"))), "Open Project", self)
        self.action_open.setShortcut("Ctrl+O")
        self.action_open.triggered.connect(self.on_open_project)

        self.action_load_from_game = QAction(QIcon.fromTheme("document-import", QIcon(os.path.join(get_project_root(), "world_configurator/ui/icons/import.png"))), "Load from Game", self)
        self.action_load_from_game.setShortcut("Ctrl+L")
        self.action_load_from_game.triggered.connect(self.on_load_from_game)

        self.action_save = QAction(QIcon.fromTheme("document-save", QIcon(os.path.join(get_project_root(), "world_configurator/ui/icons/save.png"))), "Save", self)
        self.action_save.setShortcut("Ctrl+S")
        self.action_save.triggered.connect(self.on_save_project)

        self.action_save_as = QAction(QIcon.fromTheme("document-save-as"), "Save As...", self)
        self.action_save_as.setShortcut("Ctrl+Shift+S")
        self.action_save_as.triggered.connect(self.on_save_project_as)

        self.action_export = QAction(QIcon.fromTheme("document-export", QIcon(os.path.join(get_project_root(), "world_configurator/ui/icons/export.png"))), "Export to Game", self)
        self.action_export.setShortcut("Ctrl+E")
        self.action_export.triggered.connect(self.on_export_to_game)

        self.action_exit = QAction(QIcon.fromTheme("application-exit"), "Exit", self)
        self.action_exit.setShortcut("Alt+F4")
        self.action_exit.triggered.connect(self.close)

        # Edit actions
        self.action_settings = QAction(QIcon.fromTheme("preferences-system"), "Settings", self)
        self.action_settings.triggered.connect(self.on_settings)

        self.action_view_json = QAction(QIcon.fromTheme("text-x-generic"), "View JSON Data", self)
        self.action_view_json.setShortcut("Ctrl+J")
        self.action_view_json.triggered.connect(self.on_view_json)

        # Help actions
        self.action_about = QAction(QIcon.fromTheme("help-about"), "About", self)
        self.action_about.triggered.connect(self.on_about)

        logger.debug("Actions set up")

    def setup_menus(self):
        """Set up the application menus."""
        self.menu_bar = QMenuBar()
        self.setMenuBar(self.menu_bar)

        # File menu
        self.menu_file = self.menu_bar.addMenu("File")
        self.menu_file.addAction(self.action_new)
        self.menu_file.addAction(self.action_open)
        self.menu_file.addAction(self.action_load_from_game)
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.action_save)
        self.menu_file.addAction(self.action_save_as)
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.action_export)
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.action_exit)

        # Edit menu
        self.menu_edit = self.menu_bar.addMenu("Edit")
        self.menu_edit.addAction(self.action_settings)
        self.menu_edit.addSeparator()
        self.menu_edit.addAction(self.action_view_json)

        # Help menu
        self.menu_help = self.menu_bar.addMenu("Help")
        self.menu_help.addAction(self.action_about)

        # Tools menu
        self.menu_tools = self.menu_bar.addMenu("Tools")
        self.action_validate_origins_quests = QAction("Validate Origins ↔ Quests", self)
        self.action_validate_origins_quests.triggered.connect(self.on_validate_origins_quests)
        self.menu_tools.addAction(self.action_validate_origins_quests)

        logger.debug("Menus set up")

    def setup_toolbar(self):
        """Set up the application toolbar."""
        self.toolbar = QToolBar()
        self.toolbar.setMovable(False)
        self.toolbar.setIconSize(QSize(32, 32))
        self.addToolBar(self.toolbar)

        # Add actions to toolbar
        self.toolbar.addAction(self.action_new)
        self.toolbar.addAction(self.action_open)
        self.toolbar.addAction(self.action_save)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.action_export)

        logger.debug("Toolbar set up")

    def setup_status_bar(self):
        """Set up the status bar."""
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        # Add status labels
        self.status_label = QLabel("Ready")
        self.status_bar.addWidget(self.status_label, 1)

        self.project_label = QLabel("No project loaded")
        self.status_bar.addPermanentWidget(self.project_label)

        logger.debug("Status bar set up")

    def _get_active_assistant_provider(self):
        """Return the current tab widget if it implements the assistant context provider interface."""
        try:
            w = self.tab_widget.currentWidget()
            # duck-typing check for required methods
            needed = [
                hasattr(w, "get_assistant_context"),
                hasattr(w, "apply_assistant_patch"),
                hasattr(w, "get_domain_examples"),
                hasattr(w, "get_reference_catalogs"),
                hasattr(w, "create_entry_from_llm"),
            ]
            return w if all(needed) else None
        except Exception:
            return None

    def load_settings(self):
        """Load application settings."""
        # TODO: Implement settings loading
        logger.debug("Settings loaded")

    def save_settings(self):
        """Save application settings."""
        # TODO: Implement settings saving
        logger.debug("Settings saved")

    def update_window_title(self):
        """Update the window title with the current project name."""
        if self.world_config.state.path:
            modified_indicator = "*" if self.world_config.state.modified else ""
            self.setWindowTitle(f"World Configurator - {self.world_config.project_name}{modified_indicator}")
        else:
            self.setWindowTitle("World Configurator")

        # Update project label in status bar
        if self.world_config.state.path:
            self.project_label.setText(self.world_config.project_name)
        else:
            self.project_label.setText("No project loaded")

    def update_ui_from_model(self):
        """Update UI components with data from the model."""
        # Update editors
        self.culture_editor._refresh_culture_list()
        self.race_editor._refresh_race_list()
        self.class_editor._refresh_class_list()
        if hasattr(self, 'skills_editor'): # Check if skills_editor exists
            self.skills_editor.refresh_data()
        if hasattr(self, 'item_editor_panel'): # Check if item_editor_panel exists
            self.item_editor_panel.refresh_current_editor() # Or a more general refresh

        self.location_editor._refresh_location_list()
        self.location_editor._populate_culture_combo()
        self.history_editor.refresh()
        self.origin_editor.refresh()
        self.quest_editor.refresh()
        self.magic_systems_editor._refresh_system_list()
        if hasattr(self, 'names_editor'):
            self.names_editor.refresh()
        if hasattr(self, 'variants_editor'):
            self.variants_editor.refresh()

        # Update window title
        self.update_window_title()

        # Show data overview
        self._show_data_overview()

        logger.debug("UI updated from model")

    def _show_data_overview(self):
        """Show an overview of the data that has been loaded."""
        loaded_items = []

        if self.world_config.culture_manager.cultures:
            loaded_items.append(f"{len(self.world_config.culture_manager.cultures)} cultures")
        if self.world_config.race_manager.races:
            loaded_items.append(f"{len(self.world_config.race_manager.races)} races")
        if self.world_config.class_manager.classes:
            loaded_items.append(f"{len(self.world_config.class_manager.classes)} classes")
        
        # Skills - check if editor exists and has data
        if hasattr(self, 'skills_editor') and self.skills_editor.skills_data:
            loaded_items.append(f"{len(self.skills_editor.skills_data)} skills")

        # Items - for items, it's more complex as it's per category.
        # For now, just indicate if the item panel is present.
        # A more detailed count would require iterating through ITEM_CATEGORIES and loading each file.
        if hasattr(self, 'item_editor_panel'):
            loaded_items.append("Item categories available")


        if self.world_config.location_manager.locations:
            loaded_items.append(f"{len(self.world_config.location_manager.locations)} locations")
        if hasattr(self.world_config, 'history_manager') and self.world_config.history_manager.history:
            loaded_items.append("World history")
        if hasattr(self.world_config, 'rules_manager') and self.world_config.rules_manager.rules:
            rule_count = len(self.world_config.rules_manager.rules.rules) if hasattr(self.world_config.rules_manager.rules, 'rules') else 0
            loaded_items.append(f"{rule_count} world rules")
        if hasattr(self.world_config, 'origin_manager') and self.world_config.origin_manager.origins:
            loaded_items.append(f"{len(self.world_config.origin_manager.origins)} origins")
        if hasattr(self.world_config, 'quest_manager') and self.world_config.quest_manager.quests:
            loaded_items.append(f"{len(self.world_config.quest_manager.quests)} quests")
        if hasattr(self.world_config, 'magic_system_manager') and self.world_config.magic_system_manager.magic_systems:
             loaded_items.append(f"{len(self.world_config.magic_system_manager.magic_systems)} magic systems")

        if loaded_items:
            overview = "Loaded: " + ", ".join(loaded_items)
            self.status_label.setText(overview)
        else:
            self.status_label.setText("No data loaded")

            # Show a message about using "Load from Game" if no editors are available
            if self.tab_widget.count() <= 7: # Adjusted count based on actual tabs (Cultures, Races, Classes, Skills, Items, Locations, History, Origins, Quests, Magic) -> 10
                QMessageBox.information(
                    self,
                    "Editor Information",
                    "Some editors might be missing or still under development.\n\n"
                    "Use the 'Load from Game' option to import existing game configuration files."
                )

    def closeEvent(self, event: QCloseEvent):
        """Handle window close event."""
        if self.check_unsaved_changes():
            # Save settings
            self.save_settings()
            event.accept()
        else:
            event.ignore()

    def check_unsaved_changes(self) -> bool:
        """
        Check if there are unsaved changes and prompt user to save if needed.

        Returns:
            True if it's safe to continue (changes saved or discarded), False to cancel.
        """
        if self.world_config.state.modified:
            response = QMessageBox.question(
                self,
                "Unsaved Changes",
                "There are unsaved changes. Would you like to save before continuing?",
                QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel,
                QMessageBox.Save
            )

            if response == QMessageBox.Save:
                return self.on_save_project()
            elif response == QMessageBox.Cancel:
                return False

        return True

    @Slot()
    def on_data_modified(self):
        """Slot to mark the project as modified when an editor signals changes."""
        if not self.world_config.state.modified:
            self.world_config.state.mark_modified()
            self.update_window_title()
            logger.debug("Project marked as modified due to editor changes.")

    @Slot()
    def on_new_project(self) -> bool:
        """
        Handle creating a new project.

        Returns:
            True if a new project was created, False otherwise.
        """
        # Check for unsaved changes
        if not self.check_unsaved_changes():
            return False

        # Show new project dialog
        dialog = NewProjectDialog(self)
        if dialog.exec() == QDialog.Accepted:
            # Create new project
            project_name = dialog.get_project_name()
            self.world_config.new_project(project_name)

            # Update UI
            self.update_ui_from_model()

            # Set status
            self.status_label.setText(f"Created new project: {project_name}")
            logger.info(f"Created new project: {project_name}")

            return True

        return False

    @Slot()
    def on_open_project(self) -> bool:
        """
        Handle opening an existing project.

        Returns:
            True if a project was opened, False otherwise.
        """
        # Check for unsaved changes
        if not self.check_unsaved_changes():
            return False

        # Show file dialog
        directory = QFileDialog.getExistingDirectory(
            self,
            "Open Project",
            os.path.join(get_project_root(), "projects")
        )

        if directory:
            # Load project
            if self.world_config.load_project(directory):
                # Update UI
                self.update_ui_from_model()

                # Set status
                self.status_label.setText(f"Opened project: {self.world_config.project_name}")
                logger.info(f"Opened project from {directory}")

                # Emit signal
                self.project_loaded.emit(directory)

                return True
            else:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to open project from {directory}. See log for details."
                )

        return False

    @Slot()
    def on_save_project(self) -> bool:
        """
        Handle saving the current project.

        Returns:
            True if the project was saved, False otherwise.
        """
        # If no path set, prompt for save location
        if not self.world_config.state.path:
            return self.on_save_project_as()

        # Save project
        if self.world_config.save_project():
            # Update UI
            self.update_window_title()

            # Set status
            self.status_label.setText(f"Saved project to {self.world_config.state.path}")
            logger.info(f"Saved project to {self.world_config.state.path}")

            # Emit signal
            self.project_saved.emit(self.world_config.state.path)

            return True
        else:
            QMessageBox.critical(
                self,
                "Error",
                f"Failed to save project. See log for details."
            )
            return False

    @Slot()
    def on_save_project_as(self) -> bool:
        """
        Handle saving the current project to a new location.

        Returns:
            True if the project was saved, False otherwise.
        """
        # Show file dialog
        directory = QFileDialog.getExistingDirectory(
            self,
            "Save Project As",
            os.path.join(get_project_root(), "projects")
        )

        if directory:
            # Save project
            if self.world_config.save_project(directory):
                # Update UI
                self.update_window_title()

                # Set status
                self.status_label.setText(f"Saved project to {directory}")
                logger.info(f"Saved project to {directory}")

                # Emit signal
                self.project_saved.emit(directory)

                return True
            else:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to save project to {directory}. See log for details."
                )

        return False

    @Slot()
    def on_export_to_game(self) -> bool:
        """
        Handle exporting the current project to the game.

        Returns:
            True if the project was exported, False otherwise.
        """
        # Confirm with user about potential overwrite
        confirm_response = QMessageBox.question(
            self,
            "Confirm Export",
            "This will export your current project to the game files.\n\n"
            "Existing game files will be automatically backed up with timestamps before being replaced.\n\n"
            "Do you want to continue?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if confirm_response != QMessageBox.Yes:
            return False

        # Show export dialog
        dialog = ExportDialog(self)


        if dialog.exec() == QDialog.Accepted:
            export_options = dialog.get_export_options()
            selected_components = [comp for comp, selected in export_options.items() if selected]
            logger.info(f"Exporting components: {', '.join(selected_components)}")

            # First, flush any unsaved edits from active item editors to disk
            try:
                if hasattr(self, 'item_editor_panel') and self.item_editor_panel:
                    self.item_editor_panel.save_all_item_editors()
            except Exception:
                logger.warning("Failed to flush item editors before export; proceeding anyway.")

            # Export to game with selected options
            # Assumes WorldConfigManager.export_to_game handles calling manager exports
            success, errors = self.world_config.export_to_game(export_options)

            if success:
                QMessageBox.information(
                    self, "Export Successful",
                    f"Successfully exported: {', '.join(selected_components)}\n\n"
                    "Backups created in respective 'backup' folders."
                )
                self.status_label.setText(f"Exported {len(selected_components)} component(s)")
                logger.info(f"Exported {len(selected_components)} component(s) to game")
                return True
            else:
                error_text = "\n".join(errors)
                QMessageBox.critical(self, "Export Failed", f"Failed to export:\n\n{error_text}")
        return False

    @Slot()
    def on_settings(self):
        """Handle showing the settings dialog."""
        dialog = SettingsDialog(self)
        dialog.exec()

    @Slot()
    def on_load_from_game(self) -> bool:
        """
        Handle loading data directly from the game's config files.

        Returns:
            True if game data was loaded successfully, False otherwise.
        """
        # Check for unsaved changes
        if not self.check_unsaved_changes():
            return False

        # Confirm with user
        response = QMessageBox.question(
            self,
            "Load from Game",
            "This will load world configuration data directly from the game files. \n\n"
            "Any unsaved changes in the current project will be lost. Continue?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if response != QMessageBox.Yes:
            return False

        # Load data from game files
        if self.world_config.synchronize_with_game():
            # Update UI with loaded data
            self.update_ui_from_model()

            # Set status message
            self.status_label.setText("Loaded world configuration from game files")
            self.project_label.setText("Game Files (Unsaved Project)")

            # Update project name
            self.world_config.project_name = "Game Configuration"
            self.update_window_title()

            logger.info("Loaded world configuration from game files")
            return True
        else:
            # Show error message
            QMessageBox.critical(
                self,
                "Error",
                "Failed to load world configuration from game files. \n\n"
                "See log for details."
            )
            return False

    @Slot()
    def on_view_json(self):
        """Handle showing the JSON data view dialog."""
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("View JSON Data")
        dialog.resize(800, 600)

        # Create layout
        layout = QVBoxLayout(dialog)

        # Text display
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFont(QFont("Courier New", 10)) # Monospaced font for JSON
        layout.addWidget(text_edit)

        # Get data and set text
        data_type_str, json_str = self._get_current_json_data()
        if data_type_str:
            dialog.setWindowTitle(f"View JSON Data - {data_type_str}")
        text_edit.setText(json_str)

        # Add a refresh button (optional, but can be useful if data changes while dialog is open)
        refresh_button = QPushButton("Refresh Current View")
        def _refresh_view():
            dt_str, j_str = self._get_current_json_data()
            if dt_str: dialog.setWindowTitle(f"View JSON Data - {dt_str}")
            text_edit.setText(j_str)
        refresh_button.clicked.connect(_refresh_view)
        layout.addWidget(refresh_button)


        # Show dialog
        dialog.exec()
        
    @Slot()
    def on_about(self):
        """Handle showing the about dialog."""
        QMessageBox.about(
            self,
            "About World Configurator",
            "World Configurator Tool for the RPG Project\n\n"
            "Version 1.0.1 (Origin Refactor)\n\n" # Updated version
            "A tool for creating and editing world configuration data for the RPG game."
        )

    def _get_current_json_data(self) -> Tuple[Optional[str], str]:
        """
        Gets the JSON data for the currently selected tab or component.
        Helper for on_view_json.

        Returns:
            A tuple (Optional[str], str): The data type string and its JSON representation.
            Returns (None, "No active editor found.") if no suitable editor is active.
        """
        current_tab_widget = self.tab_widget.currentWidget()
        data_type = self.tab_widget.tabText(self.tab_widget.currentIndex())
        json_data_str = "{}"

        try:
            if data_type == "Cultures" and self.world_config.culture_manager:
                data_dict = {k: v.to_dict() for k, v in self.world_config.culture_manager.cultures.items()}
                json_data_str = json.dumps({"cultures": data_dict}, indent=2) if data_dict else "No culture data loaded."
            elif data_type == "Races" and self.world_config.race_manager:
                data_dict = {k: v.to_dict() for k, v in self.world_config.race_manager.races.items()}
                json_data_str = json.dumps({"races": data_dict}, indent=2) if data_dict else "No race data loaded."
            elif data_type == "Classes" and self.world_config.class_manager:
                data_dict = {k: v.to_dict() for k, v in self.world_config.class_manager.classes.items()}
                json_data_str = json.dumps({"classes": data_dict}, indent=2) if data_dict else "No class data loaded."
            elif data_type == "Locations" and self.world_config.location_manager:
                data_dict = {k: v.to_dict() for k, v in self.world_config.location_manager.locations.items()}
                json_data_str = json.dumps({"locations": data_dict}, indent=2) if data_dict else "No location data loaded."
            elif data_type == "World History" and self.world_config.history_manager and self.world_config.history_manager.history:
                json_data_str = json.dumps(self.world_config.history_manager.history.to_dict(), indent=2)
            elif data_type == "Fundamental Rules" and self.world_config.rules_manager and self.world_config.rules_manager.rules:
                json_data_str = json.dumps(self.world_config.rules_manager.rules.to_dict(), indent=2)
            elif data_type == "Origins" and self.world_config.origin_manager:
                data_dict = {k: v.to_dict() for k, v in self.world_config.origin_manager.origins.items()}
                json_data_str = json.dumps({"origins": data_dict}, indent=2) if data_dict else "No origin data loaded."
            elif data_type == "Quests" and self.world_config.quest_manager:
                data_dict = {k: v.to_dict() for k, v in self.world_config.quest_manager.quests.items()}
                json_data_str = json.dumps({"quests": data_dict}, indent=2) if data_dict else "No quest data loaded."
            elif data_type == "Magic Systems" and self.world_config.magic_system_manager:
                data_dict = {k: v.to_dict() for k, v in self.world_config.magic_system_manager.magic_systems.items()}
                json_data_str = json.dumps({"magic_systems": data_dict}, indent=2) if data_dict else "No magic system data loaded."
            elif data_type == "Skills" and hasattr(self, 'skills_editor') and self.skills_editor.skills_data:
                # The skills editor stores skills_data directly as the content of "skills" key
                json_data_str = json.dumps({"skills": self.skills_editor.skills_data}, indent=2)
            elif data_type == "Items" and hasattr(self, 'item_editor_panel'):
                active_item_file_path = self.item_editor_panel.get_active_editor_file_path()
                if active_item_file_path:
                    # Determine project root to construct full path
                    project_root_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
                    full_path = os.path.join(project_root_path, active_item_file_path)
                    if os.path.exists(full_path):
                        loaded_item_data = load_json(full_path) # file_manager.load_json
                        if loaded_item_data is not None:
                            json_data_str = json.dumps(loaded_item_data, indent=2)
                            # Update data_type to be more specific for the JSON view title
                            category_name = self.item_editor_panel.current_category_key or "Items"
                            data_type = f"Items ({category_name})"
                        else:
                            json_data_str = f"Could not load data from: {active_item_file_path}"
                    else:
                        json_data_str = f"File not found: {active_item_file_path}"
                else:
                    json_data_str = "No item category selected in the Items editor."
            elif data_type == "Names" and hasattr(self.world_config, 'names_manager') and self.world_config.names_manager:
                try:
                    data_dict = self.world_config.names_manager.data or {}
                    json_data_str = json.dumps(data_dict, indent=2)
                except Exception as e:
                    json_data_str = f"Error reading names data: {e}"
            elif data_type == "NPC Variants" and hasattr(self.world_config, 'variants_manager') and self.world_config.variants_manager:
                try:
                    data_dict = self.world_config.variants_manager.data or {}
                    json_data_str = json.dumps(data_dict, indent=2)
                except Exception as e:
                    json_data_str = f"Error reading variants data: {e}"
            else:
                return None, "No active editor or data source found for this tab."
        except Exception as e:
            logger.error(f"Error generating JSON view for {data_type}: {e}", exc_info=True)
            return data_type, f"Error generating JSON view: {e}"

        return data_type, json_data_str

    @Slot()
    def on_validate_origins_quests(self):
        """Run the Origins↔Quests validator and display a summary."""
        try:
            from world_configurator.validators.origins_quests_validator import validate as validate_oq
        except Exception:
            try:
                from validators.origins_quests_validator import validate as validate_oq
            except Exception as e:
                QMessageBox.critical(self, "Validator Missing", f"Could not import validator: {e}")
                return
        try:
            origins = {k: v.to_dict() for k, v in self.world_config.origin_manager.origins.items()} if hasattr(self.world_config, 'origin_manager') else {}
            quests = {k: v.to_dict() for k, v in self.world_config.quest_manager.quests.items()} if hasattr(self.world_config, 'quest_manager') else {}
            report = validate_oq(origins, quests)
            ok = report.get('ok', False)
            issues = report.get('issues', [])
            stats = report.get('stats', {})
            summary = f"Valid references: {'Yes' if ok else 'No'}\n" \
                      f"Total refs: {stats.get('total_refs', 0)}\n" \
                      f"Invalid refs: {stats.get('invalid_refs', 0)}\n" \
                      f"Duplicates: {stats.get('duplicates', 0)}\n\n"
            if issues:
                summary += "Issues:\n- " + "\n- ".join(issues)
            else:
                summary += "No issues found."
            QMessageBox.information(self, "Origins ↔ Quests Validation", summary)
        except Exception as e:
            QMessageBox.critical(self, "Validation Error", f"An error occurred during validation:\n{e}")

```

### File: gui\main_window.py

```python
#!/usr/bin/env python3
"""
Main window for the RPG game GUI.
This module provides the MainWindow class that serves as the primary GUI container.
"""

import logging
import os
import weakref
from typing import Optional, List, Dict, Any, Tuple
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QStackedWidget, QDialog, QLabel, QPushButton, 
    QTextEdit, QScrollArea, QGraphicsOpacityEffect, QMessageBox, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QTimer, QSize, QSettings, QObject, QThread, Signal, QParallelAnimationGroup, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QIcon, QPixmap, QPalette, QBrush, QColor, QMovie, QTextCursor # Added QTextCursor
from core.inventory import get_inventory_manager
from core.inventory.item import Item
from core.inventory.item_enums import EquipmentSlot
from gui.dialogs.game_over_dialog import GameOverDialog
from core.base.engine import GameEngine, get_game_engine
from core.combat.enums import CombatState, CombatStep
from core.interaction.enums import InteractionMode # Added import
from core.base.state import GameState, get_state_manager # Added imports
from core.utils.logging_config import get_logger
from gui.components.game_output import GameOutputWidget
from gui.components.command_input import CommandInputWidget
from gui.components.menu_panel import MenuPanelWidget
from gui.components.right_panel import CollapsibleRightPanel
from gui.components.status_bar import GameStatusBar
from gui.components.combat_display import CombatDisplay # Added import
from gui.utils.resource_manager import get_resource_manager
from gui.dialogs.settings.llm_settings_dialog import LLMSettingsDialog

logger = get_logger("GUI")

class MainWindow(QMainWindow):
    """Main window for the RPG game GUI."""
    
    def __init__(self):
            super().__init__()
            
            self._previous_mode = None # Track previous mode for transitions
            
            # Get resource manager
            self.resource_manager = get_resource_manager()
            
            # Get game engine
            self.game_engine = get_game_engine()

            # Register this MainWindow with the engine so orchestrator/engine can nudge UI updates
            try:
                self.game_engine.main_window_ref = weakref.ref(self)
            except Exception:
                pass

            # Set minimum size based on reasonable content size hint
            self.setMinimumSize(1024, 700) # Set a sensible minimum size

            # Store character data temporarily during animation
            self._character_data_for_new_game: Optional[Dict[str, Any]] = None

            # Set up the UI
            self._setup_ui()
            
            # Connect signals and slots
            self._connect_signals()
            
            # Apply initial styling
            self._update_styling()

            self._last_submitted_command = None

    def _apply_initial_window_state(self):
        """Apply saved window state and geometry when the window is first shown."""
        settings = QSettings("RPGGame", "Settings")
        window_state = settings.value("display/window_state", "windowed") # Default to windowed
        
        logger.info(f"Applying initial window state: {window_state}")

        if window_state == "fullscreen":
            self.showFullScreen()
        elif window_state == "maximized":
            self.showMaximized()
        else: # windowed
            # Load saved windowed size or default
            default_size = QSize(1280, 720)
            windowed_size = settings.value("display/windowed_size", default_size)
            # Ensure windowed_size is a QSize object
            if not isinstance(windowed_size, QSize):
                # Attempt conversion if it's a tuple/list or handle potential string format
                if isinstance(windowed_size, (tuple, list)) and len(windowed_size) == 2:
                    windowed_size = QSize(windowed_size[0], windowed_size[1])
                elif isinstance(windowed_size, str):
                     try:
                         parts = windowed_size.strip('()').split(',')
                         windowed_size = QSize(int(parts[0]), int(parts[1]))
                     except Exception:
                         windowed_size = default_size # Fallback on parse error
                else:
                    windowed_size = default_size # Fallback if type is unexpected

            self.showNormal() # Ensure not maximized/fullscreen first
            self.resize(windowed_size) # Apply the loaded/default size
            # Optional: Center the window
            screen_geometry = self.screen().availableGeometry()
            self.move(screen_geometry.center() - self.rect().center())        

    def showEvent(self, event):
        """Override showEvent to apply initial window state after the window is shown."""
        super().showEvent(event)
        # Apply the state only once when the window is first shown
        if not hasattr(self, '_initial_state_applied') or not self._initial_state_applied:
             self._apply_initial_window_state()
             self._initial_state_applied = True

    def closeEvent(self, event):
        """Handle window close event, saving window state."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # --- Save Window State ---
            settings = QSettings("RPGGame", "Settings")
            current_state_str = "windowed" # Default
            if self.isFullScreen():
                current_state_str = "fullscreen"
            elif self.isMaximized():
                current_state_str = "maximized"
            
            settings.setValue("display/window_state", current_state_str)
            
            # Save the *current* size only if the state is 'windowed'
            if current_state_str == "windowed":
                 settings.setValue("display/windowed_size", self.size())
            logger.info(f"Saved window state ({current_state_str}) and size ({self.size() if current_state_str == 'windowed' else 'N/A'}) on exit.")
            # --- End Save Window State ---

            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def _apply_saved_resolution(self):
        """Apply saved resolution from settings."""
        settings = QSettings("RPGGame", "Settings")
        resolution = settings.value("display/resolution", (1280, 720))
        
        # Convert to tuple if it's a string (can happen with some QSettings implementations)
        if isinstance(resolution, str):
            try:
                # Handle string format like "(1280, 720)"
                if resolution.startswith("(") and resolution.endswith(")"):
                    parts = resolution.strip("()").split(",")
                    resolution = (int(parts[0].strip()), int(parts[1].strip()))
            except:
                # Fallback to default if parsing fails
                resolution = (1280, 720)
                logging.warning("Failed to parse resolution setting, using default")
        
        # Set window size
        self.setFixedSize(*resolution)
        logging.info(f"Applied saved resolution: {resolution}")
    
    def _setup_ui(self):
        """Set up the user interface."""
        self.setWindowTitle("RPG Game")
        
        self.background_container = QWidget()
        self.setCentralWidget(self.background_container)
        self.background_container.setStyleSheet("background-color: transparent;")

        self.background_label = QLabel(self.background_container)
        self.background_label.setGeometry(0, 0, self.width(), self.height()) 
        self.background_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.background_label.setScaledContents(True) 

        self.main_content_widget = QWidget(self.background_container)
        self.main_content_widget.setGeometry(0, 0, self.width(), self.height()) 
        self.main_content_widget.setStyleSheet("background-color: transparent;") 

        self.main_layout = QVBoxLayout(self.main_content_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10) 
        self.main_layout.setSpacing(5)
        
        self.mode_stacked_widget = QStackedWidget()
        
        self.narrative_view = QWidget()
        self.narrative_layout = QVBoxLayout(self.narrative_view)
        self.narrative_layout.setContentsMargins(0, 0, 0, 0)
        self.narrative_layout.setSpacing(0)
        
        self.combat_view = QWidget()
        self.combat_layout = QVBoxLayout(self.combat_view)
        self.combat_layout.setContentsMargins(0, 0, 0, 0)
        self.combat_layout.setSpacing(0)
        
        title_pixmap = self.resource_manager.get_pixmap("title_banner")
        if not title_pixmap.isNull():
            self.title_label = QLabel()
            target_height = 100
            scaled_pixmap = title_pixmap.scaled(
                QSize(1000, target_height), 
                Qt.KeepAspectRatio,         
                Qt.SmoothTransformation     
            )
            self.title_label.setPixmap(scaled_pixmap)
            self.title_label.setAlignment(Qt.AlignCenter)
            self.title_label.setContentsMargins(0, 0, 0, 5)
            self.main_layout.addWidget(self.title_label)
        
        self.content_layout = QHBoxLayout()
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.setSpacing(10)
        
        self.menu_panel = MenuPanelWidget()
        
        self.game_output = GameOutputWidget()
        if hasattr(self.game_output, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.game_output.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected GameOutputWidget.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect GameOutputWidget.visualDisplayComplete: Attribute or slot missing.")
        self.narrative_layout.addWidget(self.game_output, 1)
        
        self.narrative_command_input = CommandInputWidget()
        self.narrative_layout.addWidget(self.narrative_command_input, 0)
        
        self.combat_display = CombatDisplay()
        if hasattr(self.combat_display, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.combat_display.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected CombatDisplay.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect CombatDisplay.visualDisplayComplete: Attribute or slot missing.")
        self.combat_layout.addWidget(self.combat_display, 1)
        
        self.combat_command_input = CommandInputWidget()
        self.combat_layout.addWidget(self.combat_command_input, 0)
        
        self.mode_stacked_widget.addWidget(self.narrative_view)
        self.mode_stacked_widget.addWidget(self.combat_view)
        
        self.center_widget = QWidget()
        center_layout = QVBoxLayout(self.center_widget)
        center_layout.setContentsMargins(0, 0, 0, 0)
        center_layout.addWidget(self.mode_stacked_widget)
        
        self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
        
        self.right_panel = CollapsibleRightPanel()
        
        self.content_layout.addWidget(self.menu_panel, 0) # Stretch factor 0 for menu_panel
        self.content_layout.addWidget(self.center_widget, 1) # Stretch factor 1 for center_widget
        self.content_layout.addWidget(self.right_panel, 0) # Stretch factor 0 for right_panel
        
        self.main_layout.addLayout(self.content_layout, 1)
        
        self.music_controls = self._create_music_controls()
        
        self.status_bar = GameStatusBar()
        self.setStatusBar(self.status_bar)

        self._load_and_apply_initial_background()

        self._initialize_panel_effects() 
        
        # Initial state: center, right, and status bar are part of the layout but fully transparent and disabled.
        # setVisible(True) is important for them to be considered by the layout manager from the start.
        self.center_widget.setVisible(True) 
        self.center_widget.setEnabled(False)
        if hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False)
        if hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect.setOpacity(0.0)
            
        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False)
        if hasattr(self, 'status_bar_opacity_effect'):
             self.status_bar_opacity_effect.setOpacity(0.0)

    def _create_music_controls(self):
        """Create music control widgets."""
        # Create a widget for the music controls
        music_widget = QWidget()
        music_layout = QHBoxLayout(music_widget)
        music_layout.setContentsMargins(0, 0, 0, 0)
        music_layout.setSpacing(5)
        
        # Create music control buttons
        play_pause_button = QPushButton()
        play_pause_button.setIcon(self.resource_manager.get_icon("music_play"))
        play_pause_button.setIconSize(QSize(24, 24))
        play_pause_button.setFixedSize(32, 32)
        play_pause_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 16px;
            }
            QPushButton:pressed {
                background-color: rgba(255, 255, 255, 0.2);
            }
        """)
        
        next_button = QPushButton()
        next_button.setIcon(self.resource_manager.get_icon("music_next"))
        next_button.setIconSize(QSize(24, 24))
        next_button.setFixedSize(32, 32)
        next_button.setStyleSheet(play_pause_button.styleSheet())
        
        volume_button = QPushButton()
        volume_button.setIcon(self.resource_manager.get_icon("music_volume"))
        volume_button.setIconSize(QSize(24, 24))
        volume_button.setFixedSize(32, 32)
        volume_button.setStyleSheet(play_pause_button.styleSheet())
        
        # Add buttons to layout
        music_layout.addWidget(play_pause_button)
        music_layout.addWidget(next_button)
        music_layout.addWidget(volume_button)
        
        # Add music controls to the top-right corner
        self.main_layout.insertWidget(0, music_widget, 0, Qt.AlignRight)
        
        # Return the widget for reference
        return music_widget
    
    def _connect_signals(self):
        """Connect signals and slots."""
        self.narrative_command_input.command_submitted.connect(self._process_command)
        self.combat_command_input.command_submitted.connect(self._process_command)

        logger.info("Connecting GameEngine.orchestrated_event_to_ui signal to MainWindow.process_orchestrated_display_event")
        try:
            self.game_engine.orchestrated_event_to_ui.connect(self.process_orchestrated_display_event)
            logger.info("Successfully connected orchestrated_event_to_ui signal")
        except Exception as e:
            logger.error(f"Failed to connect orchestrated_event_to_ui signal: {e}")
        
        logger.info("Connecting game engine output_generated signal to _handle_game_output (for non-orchestrated events)")
        try:
            self.game_engine.output_generated.connect(self._handle_game_output)
            logger.info("Successfully connected engine.output_generated signal")
        except Exception as e:
            logger.error(f"Failed to connect output_generated signal: {e}")

        self.menu_panel.new_game_requested.connect(self._show_new_game_dialog)
        self.menu_panel.save_game_requested.connect(self._show_save_game_dialog)
        self.menu_panel.load_game_requested.connect(self._show_load_game_dialog)
        self.menu_panel.settings_requested.connect(self._show_settings_dialog)
        self.menu_panel.llm_settings_requested.connect(self._show_llm_settings_dialog)
        self.menu_panel.exit_requested.connect(self.close)

        self.right_panel.tab_changed.connect(self._handle_tab_change)

        if hasattr(self.right_panel, 'inventory_panel'):
            self.right_panel.inventory_panel.item_use_requested.connect(self._handle_item_use_requested)
            self.right_panel.inventory_panel.item_examine_requested.connect(self._handle_item_examine_requested)
            self.right_panel.inventory_panel.item_equip_requested.connect(self._handle_item_equip_requested)
            self.right_panel.inventory_panel.item_unequip_requested.connect(self._handle_item_unequip_requested)
            self.right_panel.inventory_panel.item_drop_requested.connect(self._handle_item_drop_requested)
            logger.info("[GUI] MainWindow: Connected signals from InventoryPanelWidget (via right_panel).")
        else:
            logger.error("[GUI] MainWindow: CRITICAL - self.right_panel.inventory_panel not found during signal connection.")

        # Connect signals from CharacterSheetWidget (via right_panel)
        if hasattr(self.right_panel, 'character_sheet'):
            self.right_panel.character_sheet.item_unequip_from_slot_requested.connect(self._handle_item_unequip_from_slot_requested)
            self.right_panel.character_sheet.item_examine_requested.connect(self._handle_item_examine_requested) # Can reuse the same handler
            self.right_panel.character_sheet.item_drop_from_slot_requested.connect(self._handle_item_drop_from_slot_requested)
            logger.info("[GUI] MainWindow: Connected signals from CharacterSheetWidget (via right_panel).")
        else:
            logger.error("[GUI] MainWindow: CRITICAL - self.right_panel.character_sheet not found for signal connection.")


        if self.game_engine.state_manager.stats_manager:
            try:
                self.game_engine.state_manager.stats_manager.stats_changed.disconnect(self._handle_stats_update)
            except (TypeError, RuntimeError): pass 
            self.game_engine.state_manager.stats_manager.stats_changed.connect(self._handle_stats_update)
            logger.info("Connected StatsManager stats_changed signal to MainWindow handler.")
        else:
            logger.warning("StatsManager not available at signal connection time in MainWindow.")
        
        if hasattr(self.game_engine._combat_orchestrator, 'resume_combat_manager') and hasattr(self.game_engine, 'on_orchestrator_idle_and_combat_manager_resumed'):
             self.game_engine._combat_orchestrator.resume_combat_manager.connect(self.game_engine.on_orchestrator_idle_and_combat_manager_resumed)
             logger.info("Connected orchestrator's resume_combat_manager to engine's handler for post-closing-narrative.")
        else:
             logger.error("Could not connect orchestrator's resume signal to engine.")
             
    @Slot(dict)
    def _handle_stats_update(self, stats_data: dict):
        """Handle updates received directly from StatsManager."""
        logger.debug("Received stats update signal in MainWindow")
        state = self.game_engine.state_manager.current_state
        if state:
            # Update Character Sheet (Right Panel)
            # This ensures character sheet gets all data including combat status
            if self.right_panel and hasattr(self.right_panel, 'update_character'):
                self.right_panel.update_character(state.player) # Pass player state for full context
                logger.debug("Updated CharacterSheet (RightPanel) from stats signal.")

            # Update Combat Display if in Combat Mode
            if state.current_mode == InteractionMode.COMBAT:
                logger.debug("Updating CombatDisplay from stats signal")
                self.combat_display.update_display(state) 
            
            # Any other UI elements that need to react to general stats changes can be updated here.

    def _setup_stats_refresh(self):
        """Set up player command tracking and direct signal connections instead of timer-based refresh."""
        # Store the last command submitted by the player to prevent echo
        self._last_submitted_command: Optional[str] = None
        
        # We don't need timer-based stats refresh anymore since we'll use direct signal connections
    
    # The _refresh_stats method is removed since we're using direct signal connections now
    
    def _handle_tab_change(self, index):
        """Handle tab change event."""
        # Update the active tab content
        if index == 0:  # Character tab
            self.right_panel.update_character()
        elif index == 1:  # Inventory tab
            if self.game_engine.state_manager.current_state:
                # Get inventory manager instance
                from core.inventory import get_inventory_manager
                inventory_manager = get_inventory_manager()
                
                if inventory_manager:
                    self.right_panel.update_inventory(inventory_manager)
                else:
                    logger.warning("No inventory manager available")
        elif index == 2:  # Journal tab
            if self.game_engine.state_manager.current_state:
                # Check if journal data exists, create it if not
                if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                    self.game_engine.state_manager.current_state.journal = {
                        "character": "",
                        "quests": {},
                        "notes": []
                    }
                
                self.right_panel.update_journal(
                    self.game_engine.state_manager.current_state.journal
                )
    
    # Define a worker for running commands in a separate thread
    class CommandWorker(QObject):
        finished = Signal()
        error = Signal(str)
        processing = Signal(bool)  # Signal to show/hide processing indicator
        
        def __init__(self, game_engine, command):
            super().__init__()
            self.game_engine = game_engine
            self.command = command
        
        def run(self):
            try:
                self.processing.emit(True)
                # Process input in the worker thread using the new InputRouter-based approach
                command_result = self.game_engine.process_input(self.command) # Original call
                
                # NEW: Process commands returned by LLM
                if command_result.data and "commands" in command_result.data:
                    llm_commands: List[Tuple[str, str]] = command_result.data["commands"]
                    if llm_commands:
                        logger.info(f"CommandWorker: Processing {len(llm_commands)} commands from LLM response: {llm_commands}")
                        # Ensure current_state is available
                        current_game_state = self.game_engine._state_manager.current_state
                        if not current_game_state:
                            logger.error("CommandWorker: Cannot process LLM commands, current_game_state is None.")
                        else:
                            for cmd, args_str in llm_commands:
                                try:
                                    # We need to call the central LLM command processor
                                    # command_handlers.process_llm_command takes (engine, command, args_list, game_state)
                                    # The args_str from the tuple is a single string, so wrap it in a list.
                                    logger.debug(f"CommandWorker: Executing LLM command '{cmd}' with args '{args_str}'")
                                    # Import locally if not already available or pass engine components if needed
                                    from core.game_flow.command_handlers import process_llm_command
                                    
                                    # process_llm_command itself might call engine._output, which triggers _update_ui.
                                    # This is fine, as _update_ui will reflect the state *after* each command.
                                    cmd_exec_result = process_llm_command(self.game_engine, cmd, [args_str], current_game_state)
                                    logger.info(f"CommandWorker: LLM command '{cmd}' execution result: {cmd_exec_result.message if cmd_exec_result else 'No result'}")
                                    if cmd_exec_result and not cmd_exec_result.is_success and cmd_exec_result.message:
                                        # If an LLM command itself fails, output its error message
                                        self.game_engine._output("system", f"Error processing internal command '{cmd}': {cmd_exec_result.message}")

                                except Exception as e_cmd:
                                    logger.error(f"CommandWorker: Error processing extracted LLM command '{cmd}': {e_cmd}", exc_info=True)
                                    self.game_engine._output("system", f"System error processing internal command '{cmd}'.")
                
                self.finished.emit()
            except Exception as e:
                logging.error(f"Error processing input: {e}", exc_info=True)
                self.error.emit(str(e))
            finally:
                self.processing.emit(False)
                
    def _process_command(self, command: str):
        """Process a command using the game engine in a separate thread."""
        if not command.strip():
            return
        
        # --- ECFA Change: Check if waiting for closing narrative ---
        if self.game_engine._waiting_for_closing_narrative_display:
            self.game_output.append_system_message("Please wait, concluding previous actions...", gradual=False)
            # Re-enable input field as this input is being ignored.
            if self.mode_stacked_widget.currentWidget() == self.narrative_view:
                self.narrative_command_input.setEnabled(True)
                self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            else:
                self.combat_command_input.setEnabled(True)
                self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            return
        # --- End ECFA Change ---

        # Check if this command is UI-generated and should not be echoed as player input
        is_ui_generated_command = False
        try:
            parts = command.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in ["examine", "equip", "unequip", "drop", "use"]:
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10: # Basic UUID-like check
                    is_ui_generated_command = True
        except Exception:
            pass

        # Echo player input only in narrative mode; suppress in combat mode
        try:
            state = self.game_engine.state_manager.current_state
            if not is_ui_generated_command and (not state or state.current_mode != InteractionMode.COMBAT):
                self.game_output.append_player_message(command)
            else:
                logger.info("Suppressing player echo in GameOutputWidget (combat mode or UI-generated command).")
        except Exception:
            if not is_ui_generated_command:
                self.game_output.append_player_message(command)
            
        self._last_submitted_command = command # Still store it to prevent potential echoes from engine if it's re-output
        
        active_command_input = self.narrative_command_input if self.mode_stacked_widget.currentWidget() == self.narrative_view else self.combat_command_input
        active_command_input.clear()
        active_command_input.setEnabled(False)
        active_command_input.command_edit.setPlaceholderText("Processing...")
        
        self.status_bar.showMessage("Processing command...", 0)
        
        self.worker_thread = QThread()
        self.worker = self.CommandWorker(self.game_engine, command)
        self.worker.moveToThread(self.worker_thread)
        
        self.worker_thread.started.connect(self.worker.run)
        self.worker.finished.connect(self._on_command_processed)
        self.worker.error.connect(self._on_command_error)
        self.worker.processing.connect(self._set_processing_state) 
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker_thread.finished.connect(self.worker_thread.deleteLater)
        
        self.worker_thread.start()

    def _on_command_processed(self):
        """Handle completion of command processing."""
        # Update UI components
        self._update_ui()
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
    
    def _on_command_error(self, error_msg):
        """Handle error in command processing."""
        self.game_output.append_system_message(f"Error: {error_msg}")
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")

    def _complete_if_same_event(self, event_id: str) -> None:
        """If the orchestrator is still waiting on this exact event, complete it.
        This guards against UI paths that failed to emit completion and prevents stalls.
        """
        try:
            orch = getattr(self.game_engine, '_combat_orchestrator', None)
            if orch is None:
                return
            # Only complete if we are still on the same event and waiting for visual
            if getattr(orch, 'is_processing_event', False) and getattr(orch, 'is_waiting_for_visual', False):
                current_id = getattr(orch, 'current_event_id_for_signals', None)
                if current_id == event_id:
                    logger.warning(f"Safety net: Completing UI_BAR_UPDATE event {event_id} to avoid stall.")
                    try:
                        orch._handle_visual_display_complete()
                    except Exception:
                        pass
        except Exception as e:
            logger.debug(f"_complete_if_same_event guard failed: {e}")
    
    def _set_processing_state(self, is_processing):
        """Update UI to show processing state."""
        if is_processing:
            self.status_bar.showMessage("Processing command...")
            self.narrative_command_input.command_edit.setPlaceholderText("Processing...")
            self.combat_command_input.command_edit.setPlaceholderText("Processing...")
        else:
            self.status_bar.clearMessage()
            self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.narrative_command_input.setEnabled(True)
            self.combat_command_input.setEnabled(True)
    
    def _handle_game_output(self, role: str, content: str):
        """
        Handle non-orchestrated output from the game engine.
        Orchestrated events are handled by `process_orchestrated_display_event`.
        This method is now for general system messages or direct player echoes
        that are NOT part of the CombatOutputOrchestrator's flow.
        """
        logger.info(f"[LEGACY_OUTPUT] Received: role='{role}', content='{content[:200]}...'")
        
        # Special logging for reintroductory narrative debugging
        if role == "gm" and ("night air" in content.lower() or "find yourself" in content.lower()):
            logger.info(f"LIFECYCLE_DEBUG: _handle_game_output - This appears to be reintroductory narrative")
            logger.info(f"LIFECYCLE_DEBUG: Content length: {len(content)}")
            logger.info(f"LIFECYCLE_DEBUG: About to route to GameOutputWidget")
        
        # Prevent echoing the player's command if it somehow comes through this path
        # This also handles the case where UI-generated commands might be echoed by the engine.
        is_ui_generated_command_pattern = False
        try:
            parts = content.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in ["examine", "equip", "unequip", "drop", "use"]:
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10:
                    is_ui_generated_command_pattern = True
        except: # pylint: disable=bare-except
            pass

        if role == "player" and ( (self._last_submitted_command is not None and content == self._last_submitted_command) or is_ui_generated_command_pattern ):
            logger.warning(f"Skipping potential echo of last command or UI-generated command via _handle_game_output: role='{role}', content='{content[:50]}...'")
            if self._last_submitted_command == content: # Clear only if it was an exact match of last submitted
                 self._last_submitted_command = None 
            return
            
        # Clear last submitted command if this output is different, to allow next player input to be echoed
        if self._last_submitted_command is not None and content != self._last_submitted_command:
             self._last_submitted_command = None

        # Route to GameOutputWidget. The append_text method now takes 'gradual'
        # For non-orchestrated output, usually display immediately (gradual=False)
        if role == "system":
            logger.info(f"LIFECYCLE_DEBUG: Routing system message to game_output.append_system_message")
            self.game_output.append_system_message(content, gradual=False)
        elif role == "gm":
            # General GM messages not part of orchestrated combat flow
            logger.info(f"LIFECYCLE_DEBUG: Routing GM message to game_output.append_gm_message with gradual=True")
            self.game_output.append_gm_message(content, gradual=True) # Allow GM narrative to be gradual
        elif role == "player":
            # Do not echo player messages to narrative output while in COMBAT
            try:
                state = self.game_engine.state_manager.current_state
                if state and state.current_mode == InteractionMode.COMBAT:
                    logger.info("Skipping player role output to GameOutputWidget because we're in COMBAT mode.")
                    return
            except Exception:
                pass
            # This path should be rare now, as player input is directly echoed then processed.
            # This will only catch player output if it's *not* the last submitted command.
            self.game_output.append_player_message(content, gradual=False)
        else:
            self.game_output.append_text(f"[{role}] {content}", gradual=False)
                      
        self._update_ui() # Still update UI for general status, etc.
        
    def _update_ui(self):
            """Update UI components based on the current game state."""
            state = self.game_engine.state_manager.current_state
            if not state:
                logger.debug("MainWindow._update_ui: No game state to update UI from.")
                self.status_bar.update_status(location="Not in game", game_time="", speed="", mode="N/A")
                if hasattr(self.right_panel, 'character_sheet') and self.right_panel.character_sheet: 
                    self.right_panel.character_sheet._clear_stat_displays() 
                
                inventory_manager_for_clear = get_inventory_manager() 
                logger.info(f"MainWindow._update_ui (no game state): Using InventoryManager instance ID: {getattr(inventory_manager_for_clear, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
                if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager_for_clear) 
                return

            game_over = False
            if state.current_mode == InteractionMode.COMBAT and state.combat_manager:
                if state.combat_manager.state == CombatState.PLAYER_DEFEAT:
                    game_over = True
            elif state.current_mode != InteractionMode.COMBAT: 
                try:
                    stats_manager = self.game_engine._stats_manager
                    if stats_manager:
                        from core.stats.stats_base import DerivedStatType
                        player_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                        if player_hp <= 0: game_over = True
                except Exception as e: logger.error(f"MainWindow._update_ui: Error checking player HP for game over: {e}", exc_info=True)

            if game_over and not hasattr(self, '_game_over_dialog_shown'):
                logger.info("MainWindow._update_ui: Player defeat detected. Showing Game Over dialog.")
                self._game_over_dialog_shown = True 
                self.narrative_command_input.setEnabled(False)
                self.combat_command_input.setEnabled(False)
                dialog = GameOverDialog(self)
                dialog.set_reason("You have been defeated!") 
                dialog.new_game_requested.connect(self._show_new_game_dialog)
                dialog.load_game_requested.connect(self._show_load_game_dialog)
                dialog.load_last_save_requested.connect(self._load_last_save)
                dialog.exec()
                self.narrative_command_input.setEnabled(True)
                self.combat_command_input.setEnabled(True)
                if hasattr(self, '_game_over_dialog_shown'): 
                    delattr(self, '_game_over_dialog_shown') 
                return 
            
            current_mode_enum = state.current_mode
            current_mode_name = current_mode_enum.name if hasattr(current_mode_enum, 'name') else str(current_mode_enum)
            logger.info(f"MainWindow._update_ui: Updating UI. Target mode: {current_mode_name}. Current QStackedWidget widget: {self.mode_stacked_widget.currentWidget().objectName() if self.mode_stacked_widget.currentWidget() else 'None'}")

            is_transitioning_to_combat = getattr(state, 'is_transitioning_to_combat', False)
            combat_narrative_buffer = getattr(state, 'combat_narrative_buffer', [])

            if current_mode_name == "COMBAT":
                view_switched_this_call = False
                if self.mode_stacked_widget.currentWidget() != self.combat_view:
                    logger.info(f"MainWindow._update_ui: Switching to combat_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.combat_view)
                    view_switched_this_call = True
                else:
                    logger.info("MainWindow._update_ui: combat_view is already the current widget.")

                # Ensure combat_view is visible and updated, regardless of whether it was just switched.
                self.combat_view.setVisible(True) # Explicitly ensure visibility
                self.combat_view.update() # Request a repaint of the combat_view
                self.mode_stacked_widget.update() # Request a repaint of the QStackedWidget
                
                if view_switched_this_call:
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.combat_view:
                        logger.info(f"MainWindow._update_ui: Successfully set combat_view as current widget in QStackedWidget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set combat_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                    
                    if hasattr(self.right_panel, 'tab_widget'): 
                        self.right_panel.tab_widget.setCurrentIndex(0)

                if is_transitioning_to_combat and combat_narrative_buffer:
                    logger.info(f"MainWindow._update_ui: Combat transition: Queuing {len(combat_narrative_buffer)} buffered messages with Orchestrator.")
                    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
                    
                    buffer_event = DisplayEvent(
                        type=DisplayEventType.BUFFER_FLUSH,
                        content=list(combat_narrative_buffer), 
                        role="gm", 
                        target_display=DisplayTarget.COMBAT_LOG,
                        gradual_visual_display=True,
                        tts_eligible=True
                    )
                    self.game_engine._combat_orchestrator.add_event_to_queue(buffer_event)
                    
                    state.combat_narrative_buffer.clear() 
                    state.is_transitioning_to_combat = False 
                    logger.debug("MainWindow._update_ui: Cleared combat_narrative_buffer and reset is_transitioning_to_combat flag.")
                
                # Call combat_display.update_display to refresh its content
                logger.info("MainWindow._update_ui (COMBAT mode): Calling combat_display.update_display.")
                self.combat_display.update_display(state) 
                
                if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player) 

                combat_manager = state.combat_manager 
                if view_switched_this_call and combat_manager and combat_manager.current_step == CombatStep.STARTING_COMBAT:
                    if not self.game_engine._combat_orchestrator.is_processing_event and not self.game_engine._combat_orchestrator.event_queue:
                        logger.info(f"MainWindow._update_ui (view switched to COMBAT this call) triggering initial CombatManager.process_combat_step() as Orchestrator is idle.")
                        QTimer.singleShot(10, lambda cm=combat_manager, eng=self.game_engine: cm.process_combat_step(eng))
                elif combat_manager and combat_manager.current_step == CombatStep.AWAITING_PLAYER_INPUT:
                     logger.debug("MainWindow._update_ui: CombatManager is AWAITING_PLAYER_INPUT. No nudge needed.")


            else: # Not in Combat mode
                if self.mode_stacked_widget.currentWidget() != self.narrative_view:
                    logger.info(f"MainWindow._update_ui: Switching to narrative_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.narrative_view:
                        logger.info(f"MainWindow._update_ui: Successfully set narrative_view as current widget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set narrative_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                
                self.narrative_view.setVisible(True) # Ensure narrative view is visible
                self.narrative_view.update()
                self.mode_stacked_widget.update()


                if is_transitioning_to_combat: 
                    logger.warning("MainWindow._update_ui: Was transitioning to combat, but now in narrative. Resetting transition flag.")
                    state.is_transitioning_to_combat = False 
                    state.combat_narrative_buffer.clear()


            if current_mode_enum == InteractionMode.TRADE and \
               (self._previous_mode is None or self._previous_mode != InteractionMode.TRADE):
                partner_id = getattr(state, 'current_trade_partner_id', None)
                partner_name = "Unknown NPC"
                if partner_id and state.world: 
                    partner_obj = getattr(state.world, 'get_character', lambda pid: None)(partner_id)
                    if partner_obj: partner_name = getattr(partner_obj, 'name', "Unknown NPC")
                self.game_output.append_system_message(f"Trade started with {partner_name}.", gradual=False)

            self._previous_mode = current_mode_enum
            if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player)

            inventory_manager = get_inventory_manager() 
            logger.info(f"MainWindow._update_ui: Using InventoryManager instance ID: {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
            if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager)
            
            journal_data = getattr(state, "journal", None)
            if journal_data is not None and hasattr(self.right_panel, 'update_journal'): self.right_panel.update_journal(journal_data)

            self.status_bar.update_status(
                location=getattr(state.player, 'current_location', 'Unknown') if state.player else 'N/A',
                game_time=self.game_engine.game_loop.game_time.get_formatted_time(),
                speed=self.game_engine.game_loop.speed.name,
                mode=current_mode_name 
            )

    def _show_game_panels_for_loaded_game(self):
        """Make game panels visible and enabled when loading a saved game."""
        self._initialize_panel_effects()
        
        # Make center widget visible and enabled
        self.center_widget.setVisible(True)
        self.center_widget.setEnabled(True)
        if hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect.setOpacity(1.0)
        
        # Make right panel visible and enabled
        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(True)
        if hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect.setOpacity(1.0)
        # Ensure right panel is in expanded state for loaded games
        if not self.right_panel.isExpanded():
            self.right_panel.setExpanded(True)
        
        # Make status bar visible and enabled
        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(True)
        if hasattr(self, 'status_bar_opacity_effect'):
            self.status_bar_opacity_effect.setOpacity(1.0)
        
        logger.info("Game panels made visible and enabled for loaded game")

    def _show_new_game_dialog(self):
        """Show dialog for creating a new game."""
        from gui.dialogs.character_creation_dialog import CharacterCreationDialog
        dialog = CharacterCreationDialog(self)
        if dialog.exec():
            character_data = dialog.get_character_data()
            if not character_data: 
                logger.warning("New game character creation cancelled or failed validation in dialog.")
                return

            logger.info(f"Character data received from dialog. Preparing to start panel animations.")
            
            # Start panel animations, passing character_data to be used after animation
            # This will eventually call _start_game_flow_after_animation
            self._start_panel_animations(character_data)
            
            # DO NOT start game engine here. It will be started by _start_game_flow_after_animation.
        else:
            logger.info("New game dialog cancelled by user.")

    def _show_save_game_dialog(self):
        """Show dialog for saving the game."""
        from gui.dialogs.save_game_dialog import SaveGameDialog
        dialog = SaveGameDialog(self)
        if dialog.exec():
            # Save the game with the provided name
            save_name = dialog.save_name_edit.text()
            # Capture current combat log HTML snapshot if in COMBAT
            try:
                state = self.game_engine.state_manager.current_state
                if state and state.current_mode.name == 'COMBAT' and state.combat_manager:
                    # Ensure current Combat Log HTML is stored for save
                    html_snapshot = ""
                    if hasattr(self, 'combat_display') and hasattr(self.combat_display, 'log_text'):
                        html_snapshot = self.combat_display.log_text.toHtml()
                    state.combat_manager.display_log_html = html_snapshot or state.combat_manager.display_log_html
            except Exception as e:
                logger.warning(f"Failed to snapshot Combat Log HTML before save: {e}")
            saved_path = self.game_engine.save_game(save_name)
            
            if saved_path:
                QMessageBox.information(
                    self, 
                    "Game Saved", 
                    f"Game saved successfully to {saved_path}"
                )
    
    def _show_load_game_dialog(self):
        """Show dialog for loading a saved game."""
        from gui.dialogs.load_game_dialog import LoadGameDialog
        dialog = LoadGameDialog(self)
        if dialog.exec():
            # Load the selected save
            save_filename = dialog.selected_save
            if save_filename:
                # Pre-clear orchestrator and displays before loading save to preserve new outputs
                try:
                    if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                        self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
                except Exception as e:
                    logger.warning(f"Failed to clear orchestrator state before load: {e}")
                try:
                    self.game_output.clear()
                except Exception as e:
                    logger.warning(f"Failed to clear GameOutputWidget before load: {e}")
                try:
                    self.combat_display.clear_display()
                except Exception as e:
                    logger.warning(f"Failed to clear CombatDisplay before load: {e}")
                self._last_submitted_command = None
                loaded_state = self.game_engine.load_game(save_filename)
                
                if loaded_state:
                    # Clear right panel tabs to avoid stale data before repopulating
                    try:
                        if hasattr(self.right_panel, 'journal_panel'):
                            self.right_panel.journal_panel.clear_all()
                        if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                            # If a clear method exists use it; otherwise update_inventory will refresh
                            try:
                                self.right_panel.inventory_panel.clear()
                            except Exception:
                                pass
                        if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                            self.right_panel.character_sheet._clear_stat_displays()
                    except Exception as e:
                        logger.warning(f"Failed to clear right panel widgets prior to load repopulation: {e}")

                    # Ensure journal exists
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": self.game_engine.state_manager.current_state.player.background,
                            "quests": {},
                            "notes": []
                        }
                    
                    # Ensure the stats manager is fully initialized
                    self.game_engine.state_manager.ensure_stats_manager_initialized()

                    # Make game panels visible and enabled for loaded games
                    self._show_game_panels_for_loaded_game()
                    
                    # Update UI
                    self._update_ui()

                    # Bind orchestrator to loaded CombatManager if save is in COMBAT
                    try:
                        state = self.game_engine.state_manager.current_state
                        if state and state.current_mode.name == 'COMBAT' and getattr(state, 'combat_manager', None):
                            if hasattr(self.game_engine, '_combat_orchestrator'):
                                self.game_engine._combat_orchestrator.set_combat_manager(state.combat_manager)
                                logger.info("Bound loaded CombatManager to Orchestrator in MainWindow (load dialog).")
                    except Exception as e:
                        logger.warning(f"Failed to bind CombatManager after load in MainWindow: {e}")

                    # Emit consolidated stats_changed to refresh UI listeners
                    try:
                        sm = self.game_engine.state_manager.stats_manager
                        if sm and hasattr(sm, 'stats_changed'):
                            sm.stats_changed.emit(sm.get_all_stats())
                            logger.info("Emitted consolidated stats_changed after load to refresh UI.")
                    except Exception as e:
                        logger.warning(f"Failed to emit stats_changed after load: {e}")
                    
                    # Force character sheet update with current player
                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                else:
                    QMessageBox.warning(
                        self, 
                        "Load Failed", 
                        f"Failed to load game from {save_filename}"
                    )
    
    def _show_settings_dialog(self):
        """Show dialog for game settings."""
        logger.info("Attempting to show SettingsDialog...") # Log entry
        from gui.dialogs.settings.settings_dialog import SettingsDialog
        logger.info("Imported SettingsDialog.") # Log import success

        try:
            dialog = SettingsDialog(self)
            logger.info("SettingsDialog instance created.") # Log instance creation
        except Exception as e:
            logger.error(f"Error INSTANTIATING SettingsDialog: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"Failed to create settings dialog:\n{e}")
            return

        # Connect the background preview signal from the BackgroundTab within the SettingsDialog
        connected = False
        if hasattr(dialog, 'background_tab') and hasattr(dialog.background_tab, 'preview_background_changed'):
            try:
                # Connect the signal that now emits the full filename
                dialog.background_tab.preview_background_changed.connect(self.update_background)
                connected = True
                logger.info("Connected background_preview_changed signal for live preview.")
            except Exception as e:
                 logger.error(f"Error connecting background_preview_changed signal: {e}")
        else:
            logger.warning("Could not find background_tab or preview_background_changed signal in SettingsDialog.")

        saved = False
        try:
            logger.info("Attempting to execute SettingsDialog...") # Log before exec
            # Execute the dialog
            result = dialog.exec()
            logger.info(f"SettingsDialog execution finished with result: {result}") # Log after exec
            if result == QDialog.Accepted: # Check result code
                saved = True
        except Exception as e:
             logger.error(f"Error EXECUTING SettingsDialog: {e}", exc_info=True)
             QMessageBox.critical(self, "Error", f"Failed to execute settings dialog:\n{e}")
        finally:
            # Disconnect signal after dialog is closed
            if connected:
                try:
                    dialog.background_tab.preview_background_changed.disconnect(self.update_background)
                    logger.info("Disconnected background_preview_changed signal.")
                except Exception as e:
                     logger.warning(f"Failed to disconnect background_preview_changed signal: {e}")

        if saved: # Process saved settings only if dialog was accepted
            logger.info("Settings dialog accepted. Applying settings...") # Log applying settings
            # Apply new settings
            settings = SettingsDialog.get_settings() # Re-fetch to be sure

            # Update dev controls visibility immediately after settings change
            try:
                q_settings = QSettings("RPGGame", "Settings")
                dev_enabled = q_settings.value("dev/enabled", False, type=bool)
                if hasattr(self, 'combat_display') and hasattr(self.combat_display, 'dev_controls_container'):
                    self.combat_display.dev_controls_container.setVisible(bool(dev_enabled))
                # Also toggle orchestrator step mode to match dev setting default (off until user toggles)
                if hasattr(self.game_engine, '_combat_orchestrator') and hasattr(self.game_engine._combat_orchestrator, 'toggle_dev_step_mode'):
                    self.game_engine._combat_orchestrator.toggle_dev_step_mode(False)
            except Exception as e:
                logger.warning(f"Failed to update dev controls visibility post settings: {e}")

            # Update resolution if needed
            resolution = settings["display"]["windowed_size"] # Use windowed_size now
            current_state = settings["display"]["window_state"]

            logger.info(f"Applying settings - State: {current_state}, Windowed Size: {resolution}")

            # Apply window state changes
            if current_state == "fullscreen":
                if not self.isFullScreen(): self.showFullScreen()
            elif current_state == "maximized":
                 if not self.isMaximized(): self.showMaximized()
            else: # windowed
                 if self.isFullScreen() or self.isMaximized(): self.showNormal()
                 # Check if size actually needs changing
                 if QSize(resolution[0], resolution[1]) != self.size():
                     self.resize(resolution[0], resolution[1]) # Use tuple values

            # Update styling (includes non-background styles)
            self._update_styling()

            # Explicitly apply the *saved* background setting after dialog closes
            q_settings = QSettings("RPGGame", "Settings")
            saved_filename = q_settings.value("style/background_filename", None)
            if saved_filename:
                 logger.info(f"Applying saved background from QSettings: {saved_filename}")
                 self.update_background(saved_filename)
            else:
                 logger.warning("Could not read saved background filename after settings dialog closed.")

            # Update UI based on new settings (e.g., status bar, panels)
            # self._update_ui() # Update UI can be complex, might re-trigger things, maybe call specific updates?
            # Let's rely on the window state change and styling update for now.

            # Show confirmation
            self.game_output.append_system_message("Settings saved successfully.")
            logger.info("Settings applied successfully.")
        else:
             logger.info("Settings dialog cancelled or closed without saving.")
    
    def update_background(self, filename: Optional[str]):
        """Load and apply a new background image or GIF to the main window."""
        logger.info(f"Attempting to update background to: {filename}")

        # Stop and clear any existing movie/pixmap
        current_movie = self.background_label.movie()
        if current_movie:
            current_movie.stop()
            self.background_label.setMovie(None)
        self.background_label.setPixmap(QPixmap())
        # Reset palette to default in case previous was PNG
        self.background_container.setAutoFillBackground(False) # Important! Don't let palette fill container
        self.background_label.setProperty("current_background", None) # Store current bg filename

        if not filename:
            logger.warning("No background filename provided, clearing background.")
            # Optionally set a default color on the label if needed
            self.background_label.setStyleSheet("background-color: #1E1E1E;")
            return

        name, ext = os.path.splitext(filename)
        ext_lower = ext.lower()

        if ext_lower == ".png":
            pixmap = self.resource_manager.get_background_pixmap(name)
            if not pixmap.isNull():
                self.background_label.setPixmap(pixmap) # Label scales content
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied PNG background: {filename}")
            else:
                logger.warning(f"Failed to load PNG background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")

        elif ext_lower == ".gif":
            movie = self.resource_manager.get_background_movie(name)
            if movie.isValid():
                self.background_label.setMovie(movie)
                movie.start()
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied GIF background: {filename}")
            else:
                logger.warning(f"Failed to load GIF background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")
        else:
            logger.error(f"Unsupported background file type: {filename}")
            self.background_label.setStyleSheet("background-color: #1E1E1E;") # Fallback color

    def _load_and_apply_initial_background(self):
        """Load the saved background filename from settings and apply it.
        If no valid setting is found, use the first available background alphabetically.
        """
        settings = QSettings("RPGGame", "Settings")
        # Read the full filename setting
        saved_filename = settings.value("style/background_filename", None)

        available_backgrounds = self.resource_manager.list_background_names() # Gets list of (name, ext)
        final_filename = None

        # Check if saved filename exists in the available list
        if saved_filename:
            found = False
            for name, ext in available_backgrounds:
                if f"{name}{ext}" == saved_filename:
                    final_filename = saved_filename
                    found = True
                    break
            if found:
                logger.info(f"Using saved background: {final_filename}")
            else:
                logger.warning(f"Saved background '{saved_filename}' not found in available list.")
                saved_filename = None # Treat as not found

        # If no valid saved name, use the first available background
        if not final_filename and available_backgrounds:
            first_name, first_ext = available_backgrounds[0] # Use first alphabetically
            final_filename = f"{first_name}{first_ext}"
            logger.info(f"No valid saved background found. Using first available: {final_filename}")
        elif not final_filename:
             logger.warning("No saved background setting found and no backgrounds available in images/gui/background/. Applying fallback color.")
             # update_background will handle the fallback color if name is None

        self.update_background(final_filename) # Pass None if no background is available

    def _update_styling(self):
        """Update UI styling based on saved settings."""
        # Update game output styling and formats
        self.game_output._update_formats()
        self.game_output._setup_background()
        
        # Get settings for command input styling
        settings = QSettings("RPGGame", "Settings")
        
        # Update command input styling
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")
        
        # Create a dark frame around command input and enter button
        # Get transparency setting
        input_opacity = int(settings.value("style/input_opacity", 100))
        opacity_percent = input_opacity / 100.0
        
        # Calculate RGB values for the background
        bg_color_obj = QColor("#333333")
        r, g, b = bg_color_obj.red(), bg_color_obj.green(), bg_color_obj.blue()
        
        # Common style for command inputs
        command_input_style = f"""
            CommandInputWidget {{
                background-color: rgba({r}, {g}, {b}, {opacity_percent});
                border-radius: 10px;
                padding: 5px;
                border: 2px solid #333333; /* Same as left/right panels */
            }}
            QLineEdit {{
                background-color: rgba(255, 255, 255, 0.7);
                color: {user_input_font_color};
                border: 1px solid #c4b59d;
                border-radius: 4px;
                padding: 8px;
                font-family: '{user_input_font_family}';
                font-size: {user_input_font_size}pt;
                margin-left: 5px;
                margin-right: 5px;
            }}
        """
        
        # Apply style to both command inputs
        self.narrative_command_input.setStyleSheet(command_input_style)
        self.combat_command_input.setStyleSheet(command_input_style)
    
    def _show_llm_settings_dialog(self):
        """Show dialog for LLM settings."""
        dialog = LLMSettingsDialog(self)
        dialog.settings_saved.connect(self._on_llm_settings_saved)
        dialog.exec()
    
    def _on_llm_settings_saved(self):
        """Handle LLM settings saved event."""
        # Update UI elements that depend on LLM settings
        is_llm_enabled = self.game_engine._use_llm
        
        # Add UI feedback to show LLM status when explicitly changed through settings
        if is_llm_enabled:
            self.game_output.append_system_message("LLM processing is now enabled.")
        else:
            self.game_output.append_system_message("LLM processing is now disabled.")

    # Removed _delayed_character_update method - we now use direct update instead of timers
    
    def closeEvent(self, event):
        """Handle window close event."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.Yes | QMessageBox.No, 
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def resizeEvent(self, event):
        """Handle window resize event to keep background and content sized correctly."""
        super().resizeEvent(event)
        # Keep background label and content widget filling the container
        if hasattr(self, 'background_label'): # Check if widgets exist yet
             self.background_label.setGeometry(0, 0, event.size().width(), event.size().height())
        if hasattr(self, 'main_content_widget'):
             self.main_content_widget.setGeometry(0, 0, event.size().width(), event.size().height())

    def _load_last_save(self):
        """Loads the most recent non-auto save file."""
        logger.info("Attempting to load last save.")
        from core.utils.save_manager import SaveManager # Local import
        save_manager = SaveManager()
        try:
            # Get recent saves, excluding backups and auto-saves initially
            saves = save_manager.get_recent_saves(count=10, include_backups=False) # Get a few recent ones
            last_manual_save = None
            for save in saves:
                 if not save.auto_save:
                      last_manual_save = save
                      break # Found the most recent manual save

            if last_manual_save:
                save_filename = f"{last_manual_save.save_id}/{SaveManager.STATE_FILENAME}" # Need correct path format if StateManager expects full path or just ID
                save_id = last_manual_save.save_id # Use the ID for loading
                logger.info(f"Found last manual save: {last_manual_save.save_name} (ID: {save_id})")

                # Clear any previous UI content and pending orchestrator events BEFORE loading
                try:
                    if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                        self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
                except Exception as e:
                    logger.warning(f"Failed to clear orchestrator state before load: {e}")
                
                try:
                    self.game_output.clear()
                except Exception as e:
                    logger.warning(f"Failed to clear GameOutputWidget before load: {e}")
                
                try:
                    self.combat_display.clear_display()
                except Exception as e:
                    logger.warning(f"Failed to clear CombatDisplay before load: {e}")
                
                # Also clear right panel content to avoid stale state
                try:
                    if hasattr(self.right_panel, 'journal_panel'):
                        self.right_panel.journal_panel.clear_all()
                    if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                        try:
                            self.right_panel.inventory_panel.clear()
                        except Exception:
                            pass
                    if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                        self.right_panel.character_sheet._clear_stat_displays()
                except Exception as e:
                    logger.warning(f"Failed to clear right panel widgets before load: {e}")
                
                self._last_submitted_command = None
                
                # Call engine's load_game method
                loaded_state = self.game_engine.load_game(save_id) # Pass save_id

                if loaded_state:
                    # Ensure journal exists (similar to _show_load_game_dialog)
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": getattr(self.game_engine.state_manager.current_state.player, 'background', ''),
                            "quests": {},
                            "notes": []
                        }
                    self.game_engine.state_manager.ensure_stats_manager_initialized()

                    # Make game panels visible and enabled for loaded games
                    self._show_game_panels_for_loaded_game()
                    
                    self._update_ui() # Update UI after load

                    # Bind orchestrator to loaded CombatManager if save is in COMBAT
                    try:
                        state = self.game_engine.state_manager.current_state
                        if state and state.current_mode.name == 'COMBAT' and getattr(state, 'combat_manager', None):
                            if hasattr(self.game_engine, '_combat_orchestrator'):
                                self.game_engine._combat_orchestrator.set_combat_manager(state.combat_manager)
                                logger.info("Bound loaded CombatManager to Orchestrator in MainWindow (load last save).")
                    except Exception as e:
                        logger.warning(f"Failed to bind CombatManager after loading last save: {e}")

                    # Emit consolidated stats_changed to refresh UI listeners
                    try:
                        sm = self.game_engine.state_manager.stats_manager
                        if sm and hasattr(sm, 'stats_changed'):
                            sm.stats_changed.emit(sm.get_all_stats())
                            logger.info("Emitted consolidated stats_changed after loading last save.")
                    except Exception as e:
                        logger.warning(f"Failed to emit stats_changed after loading last save: {e}")

                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                    self.game_output.append_system_message(f"Loaded last save: {last_manual_save.save_name}")
                else:
                    QMessageBox.warning(self, "Load Failed", f"Failed to load last save: {last_manual_save.save_name}")
                    # If last save fails, open the regular load dialog
                    self._show_load_game_dialog()
            else:
                logger.warning("No manual saves found to load.")
                QMessageBox.information(self, "No Last Save", "No manual save file found. Please load manually or start a new game.")
                # Open the regular load dialog as fallback
                self._show_load_game_dialog()
        except Exception as e:
            logger.error(f"Error loading last save: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An error occurred while trying to load the last save:\n{e}")
            self._show_load_game_dialog() # Fallback to regular load dialog

    @Slot(object) 
    def process_orchestrated_display_event(self, event):
        """
        Handles DisplayEvents routed from the CombatOutputOrchestrator via the GameEngine.
        This method sends the content to the appropriate UI display widget.
        """
        from core.orchestration.events import DisplayEvent, DisplayTarget, DisplayEventType 
        if not isinstance(event, DisplayEvent):
            logger.error(f"MainWindow received non-DisplayEvent object: {type(event)}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()
            return

        logger.info(f"MainWindow processing orchestrated event: {event}")
        state = self.game_engine.state_manager.current_state

        target_widget = None
        # Determine primary target widget
        if event.target_display == DisplayTarget.COMBAT_LOG:
            target_widget = self.combat_display
        elif event.target_display == DisplayTarget.MAIN_GAME_OUTPUT:
            target_widget = self.game_output
            # Ensure the narrative view is visible if routing to MAIN_GAME_OUTPUT AND we are not currently in COMBAT mode
            try:
                state_for_switch = self.game_engine.state_manager.current_state
                if state_for_switch and state_for_switch.current_mode != InteractionMode.COMBAT:
                    if self.mode_stacked_widget.currentWidget() != self.narrative_view:
                        logger.info("MainWindow: MAIN_GAME_OUTPUT event and current mode not COMBAT. Switching to narrative_view.")
                        self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
                        self.narrative_view.setVisible(True)
                        self.mode_stacked_widget.update()
            except Exception as e:
                logger.warning(f"Failed conditional switch to narrative_view on MAIN_GAME_OUTPUT event: {e}")
        else: # Default based on mode if target not explicit
            if state and state.current_mode == InteractionMode.COMBAT:
                target_widget = self.combat_display
            else:
                target_widget = self.game_output
        
        if not target_widget and event.type not in [DisplayEventType.TURN_ORDER_UPDATE, DisplayEventType.UI_BAR_UPDATE_PHASE1, DisplayEventType.UI_BAR_UPDATE_PHASE2]: # These might not have a primary text widget
            logger.error(f"No target widget found for orchestrated event: {event} and not a special UI event.")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete() 
            return

        # Handle event types
        if event.type == DisplayEventType.BUFFER_FLUSH:
            if isinstance(event.content, list) and target_widget == self.combat_display:
                # New: perfect fidelity replay with role per line, batched to a single completion
                try:
                    # Suppress per-line completion during batch
                    if hasattr(self.combat_display, '_suppress_visual_complete'):
                        self.combat_display._suppress_visual_complete = True
                    for item in event.content:
                        if isinstance(item, dict) and 'text' in item:
                            line_text = str(item.get('text', ''))
                            line_role = item.get('role', event.role or 'gm')
                            if line_text:
                                self.combat_display.append_orchestrated_event_content(line_text, line_role, is_gradual=False)
                        else:
                            # Fallback: treat as plain string
                            self.combat_display.append_orchestrated_event_content(str(item), event.role or 'gm', is_gradual=False)
                except Exception as e:
                    logger.error(f"Error during BUFFER_FLUSH replay: {e}", exc_info=True)
                finally:
                    if hasattr(self.combat_display, '_suppress_visual_complete'):
                        self.combat_display._suppress_visual_complete = False
                # Signal completion once for the whole batch (async to avoid re-entrancy)
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    try:
                        QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)
                    except Exception:
                        # Fallback to direct call if QTimer not available
                        self.game_engine._combat_orchestrator._handle_visual_display_complete()
            else:
                logger.error(f"Invalid content type or target for BUFFER_FLUSH event: {type(event.content)}, target: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()

        elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1 or event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
            logger.debug(f"Handling UI_BAR_UPDATE event: {event.metadata}")
            entity_id = event.metadata.get("entity_id")
            bar_type = event.metadata.get("bar_type") 
            
            # Diagnostic: player mapping and widget presence
            player_id_diag = None
            state_for_diag = self.game_engine.state_manager.current_state
            if state_for_diag and state_for_diag.player:
                player_id_diag = getattr(state_for_diag.player, 'id', getattr(state_for_diag.player, 'stats_manager_id', None))
            logger.info(f"UI_BAR_UPDATE {event.type.name}: bar={bar_type}, entity={entity_id}, is_player={(entity_id==player_id_diag)}")
            
            # Update CharacterSheet if it's the player (do this first to align visual timing with CombatDisplay)
            player_id = None
            if state and state.player:
                 player_id = getattr(state.player, 'id', getattr(state.player, 'stats_manager_id', None))

            player_bar_updated = False
            if entity_id == player_id and self.right_panel and self.right_panel.character_sheet:
                try:
                    if event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1:
                        self.right_panel.character_sheet.player_resource_bar_update_phase1(bar_type, event.metadata)
                        player_bar_updated = True
                    elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
                        self.right_panel.character_sheet.player_resource_bar_update_phase2(bar_type, event.metadata)
                        player_bar_updated = True
                except Exception as e:
                    logger.error(f"Error updating CharacterSheet for player bar update: {e}", exc_info=True)

            # Update CombatEntityWidget in CombatDisplay
            entity_widget_combat_display = self.combat_display.entity_widgets.get(entity_id)
            logger.info(f"CombatDisplay widget exists for entity? {bool(entity_widget_combat_display)}")
            animation_invoked = False
            if entity_widget_combat_display:
                method_name = f"animate_{event.type.name.lower()}"
                try:
                    if hasattr(entity_widget_combat_display, method_name):
                        getattr(entity_widget_combat_display, method_name)(event.metadata)
                        animation_invoked = True
                    else:
                        logger.warning(f"CombatEntityWidget missing method {method_name} for entity {entity_id}. Will complete event to prevent stall.")
                except Exception as e:
                    logger.error(f"Error invoking {method_name} on CombatEntityWidget for entity {entity_id}: {e}", exc_info=True)

            # If no animation method was invoked, or if widget is missing, proactively complete to avoid stall
            if (not entity_widget_combat_display) or (not animation_invoked):
                 if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    try:
                        QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)
                    except Exception:
                        self.game_engine._combat_orchestrator._handle_visual_display_complete()
                 if not entity_widget_combat_display:
                     logger.warning(f"UI_BAR_UPDATE for entity {entity_id} but no CombatEntityWidget found. Signalled completion to avoid stall.")
                 else:
                     logger.info(f"UI_BAR_UPDATE fallback completion invoked (no animation) for entity {entity_id}.")

            # Final safety net: if the orchestrator is still processing this same event shortly after, complete it
            try:
                QTimer.singleShot(10, lambda ev_id=event.event_id: self._complete_if_same_event(ev_id))
            except Exception:
                pass


        elif event.type == DisplayEventType.TURN_ORDER_UPDATE:
            if self.right_panel and self.right_panel.character_sheet and hasattr(self.right_panel.character_sheet, 'handle_turn_order_update'):
                self.right_panel.character_sheet.handle_turn_order_update(event.content) # event.content is the data dict
            # This event is primarily for CharacterSheet, CombatDisplay updates turn order itself.
            # Signal completion immediately as CharacterSheet update is synchronous.
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                 QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)


        elif event.type == DisplayEventType.COMBAT_LOG_SET_HTML:
            # Directly set Combat Log HTML for instant rehydration
            try:
                if target_widget == self.combat_display and isinstance(event.content, str):
                    # Freeze updates for fast set
                    self.combat_display.log_text.setUpdatesEnabled(False)
                    self.combat_display.log_text.setHtml(event.content)
                    # Move caret to end and ensure visible using correct API
                    self.combat_display.log_text.moveCursor(QTextCursor.MoveOperation.End)
                    self.combat_display.log_text.ensureCursorVisible()
                    self.combat_display.log_text.setUpdatesEnabled(True)
                else:
                    logger.error(f"COMBAT_LOG_SET_HTML received but target or content invalid: {target_widget}, {type(event.content)}")
            except Exception as e:
                logger.error(f"Error applying COMBAT_LOG_SET_HTML: {e}", exc_info=True)
            # No need to explicitly call visual completion; orchestrator doesn't wait for this type
        elif isinstance(event.content, str): # For NARRATIVE_*, SYSTEM_MESSAGE
            if target_widget == self.combat_display:
                # Log event routing for diagnostics
                logger.info(f"MainWindow: Routing string event to CombatDisplay id={event.event_id} type={event.type.name} gradual={bool(event.gradual_visual_display)}")
                self.combat_display.append_orchestrated_event_content(
                    event_content=event.content,
                    event_role=event.role or "system",
                    is_gradual=event.gradual_visual_display,
                    event_id=event.event_id
                )
            elif target_widget == self.game_output:
                text_format = None 
                if event.role == "system": text_format = self.game_output.system_format
                elif event.role == "gm": text_format = self.game_output.gm_format
                elif event.role == "player": text_format = self.game_output.player_format
                # Hide [DEV] messages unless dev mode is enabled
                try:
                    if isinstance(event.content, str) and event.content.strip().startswith("[DEV]"):
                        q_settings = QSettings("RPGGame", "Settings")
                        if not q_settings.value("dev/enabled", False, type=bool):
                            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                                self.game_engine._combat_orchestrator._handle_visual_display_complete()
                            return
                except Exception:
                    pass
                self.game_output.append_text(event.content, text_format, event.gradual_visual_display)
            elif target_widget is None and event.type == DisplayEventType.TURN_ORDER_UPDATE:
                 # This was already handled above, but log if it falls through
                 logger.debug("TURN_ORDER_UPDATE already handled for CharacterSheet, no primary text widget needed.")
            else:
                logger.error(f"Unhandled target widget for orchestrated string event: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()
        else:
            logger.error(f"Orchestrated event has non-string content and is not a known special type: {event}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()

    def _initialize_panel_effects(self):
        """Initialize QGraphicsOpacityEffect for panels that will be animated."""
        if not hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect = QGraphicsOpacityEffect(self.center_widget)
            self.center_widget.setGraphicsEffect(self.center_opacity_effect)
            self.center_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect = QGraphicsOpacityEffect(self.right_panel)
            self.right_panel.setGraphicsEffect(self.right_panel_opacity_effect)
            self.right_panel_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'status_bar_opacity_effect'):
            self.status_bar_opacity_effect = QGraphicsOpacityEffect(self.status_bar)
            self.status_bar.setGraphicsEffect(self.status_bar_opacity_effect)
            self.status_bar_opacity_effect.setOpacity(0.0)

    def _start_panel_animations(self, character_data: Dict[str, Any]):
        """Starts the animation sequence for showing the main game panels."""
        self._character_data_for_new_game = character_data 

        self._initialize_panel_effects()

        # 1. Make panels visible (for layout) but keep them disabled and transparent
        self.center_widget.setVisible(True)
        self.center_widget.setEnabled(False) # Keep disabled during animation
        self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False) # Keep disabled during animation
        # Ensure right_panel is set to its desired initial expanded state before animation
        if not self.right_panel.isExpanded(): 
             self.right_panel.setExpanded(True) # Set its state, width animation will be part of its logic
        self.right_panel_opacity_effect.setOpacity(0.0)

        animation_duration = 300 

        center_anim = QPropertyAnimation(self.center_opacity_effect, b"opacity", self)
        center_anim.setDuration(animation_duration)
        center_anim.setStartValue(0.0)
        center_anim.setEndValue(1.0)
        center_anim.setEasingCurve(QEasingCurve.InOutQuad)

        right_panel_anim = QPropertyAnimation(self.right_panel_opacity_effect, b"opacity", self)
        right_panel_anim.setDuration(animation_duration)
        right_panel_anim.setStartValue(0.0)
        right_panel_anim.setEndValue(1.0)
        right_panel_anim.setEasingCurve(QEasingCurve.InOutQuad)

        self.parallel_anim_group = QParallelAnimationGroup(self)
        self.parallel_anim_group.addAnimation(center_anim)
        self.parallel_anim_group.addAnimation(right_panel_anim)

        self.parallel_anim_group.finished.connect(self._animate_status_bar_in)
        self.parallel_anim_group.start(QPropertyAnimation.DeleteWhenStopped)

    @Slot()
    def _animate_status_bar_in(self):
        """Makes the status bar visible and animates its fade-in."""
        # Enable the center and right panels now that their fade-in is complete
        self.center_widget.setEnabled(True)
        self.right_panel.setEnabled(True)
        logger.info("Center widget and Right panel enabled after fade-in.")

        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False) # Keep disabled during its own animation
        self.status_bar_opacity_effect.setOpacity(0.0)

        status_bar_anim = QPropertyAnimation(self.status_bar_opacity_effect, b"opacity", self)
        status_bar_anim.setDuration(200) 
        status_bar_anim.setStartValue(0.0)
        status_bar_anim.setEndValue(1.0)
        status_bar_anim.setEasingCurve(QEasingCurve.InOutQuad)

        status_bar_anim.finished.connect(self._start_game_flow_after_animation)
        status_bar_anim.start(QPropertyAnimation.DeleteWhenStopped) 

    @Slot()
    def _start_game_flow_after_animation(self):
        """Final step after all panel animations are complete. Starts the game engine flow."""
        self.status_bar.setEnabled(True)
        logger.info("Status bar enabled after fade-in.")
        logger.info("All panel animations complete. Starting game engine flow.")

        character_data = getattr(self, '_character_data_for_new_game', None)
        if not character_data:
            logger.error("Character data not found after animation. Cannot start new game.")
            QMessageBox.critical(self, "Error", "Failed to retrieve character data to start the game.")
            # Reset UI to pre-new-game state
            self.center_widget.setVisible(False)
            self.center_widget.setEnabled(False)
            if hasattr(self, 'center_opacity_effect'): self.center_opacity_effect.setOpacity(0.0)
            
            self.right_panel.setVisible(False)
            self.right_panel.setEnabled(False)
            if hasattr(self, 'right_panel_opacity_effect'): self.right_panel_opacity_effect.setOpacity(0.0)

            self.status_bar.setVisible(False)
            self.status_bar.setEnabled(False)
            if hasattr(self, 'status_bar_opacity_effect'): self.status_bar_opacity_effect.setOpacity(0.0)
            return

        player_name = character_data['name']
        race = character_data['race']
        path = character_data['path']
        origin_id = character_data.get('origin_id', '') # Get origin_id
        sex = character_data.get('sex', 'Male')
        # 'description' from character_data is the origin's intro_text/background
        origin_description_as_background = character_data.get('description', '') 
        character_image = character_data.get('character_image')
        use_llm = character_data.get('use_llm', True)
        custom_stats = None
        if 'stats' in character_data:
            if all(isinstance(val, int) for val in character_data['stats'].values()):
                custom_stats = character_data['stats']
            else: 
                logger.warning("Unexpected stats format from character_data, attempting to parse.")
                temp_stats = {}
                for stat_name, stat_info in character_data['stats'].items():
                    if isinstance(stat_info, dict) and 'base' in stat_info:
                        temp_stats[stat_name] = stat_info['base']
                    elif isinstance(stat_info, int):
                         temp_stats[stat_name] = stat_info
                if temp_stats: custom_stats = temp_stats
        
        logger.info(f"Starting new game with resolved data: Name={player_name}, Race={race}, Path={path}, OriginID={origin_id}, Sex={sex}, LLM={use_llm}, Stats={custom_stats is not None}")

        # Pre-clear any previous session UI and orchestrator state if starting a new game during an ongoing session
        try:
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                # Detach any existing CombatManager and clear queued events
                try:
                    self.game_engine._combat_orchestrator.set_combat_manager(None)
                except Exception:
                    pass
                self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
        except Exception as e:
            logger.warning(f"Failed to clear orchestrator state before starting new game: {e}")
        # Ensure any lingering closing-narrative wait flag is reset
        try:
            if hasattr(self.game_engine, '_waiting_for_closing_narrative_display'):
                self.game_engine._waiting_for_closing_narrative_display = False
        except Exception:
            pass
        # Clear visible outputs to avoid mixing old content
        try:
            self.game_output.clear()
        except Exception as e:
            logger.warning(f"Failed to clear GameOutputWidget before starting new game: {e}")
        try:
            self.combat_display.clear_display()
        except Exception as e:
            logger.warning(f"Failed to clear CombatDisplay before starting new game: {e}")
        # Clear right panel widgets to avoid stale state
        try:
            if hasattr(self.right_panel, 'journal_panel'):
                self.right_panel.journal_panel.clear_all()
            if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                try:
                    self.right_panel.inventory_panel.clear()
                except Exception:
                    pass
            if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                self.right_panel.character_sheet._clear_stat_displays()
        except Exception as e:
            logger.warning(f"Failed to clear right panel widgets before starting new game: {e}")
        # Reset last submitted command tracking
        self._last_submitted_command = None

        self.game_engine.start_new_game(
            player_name=player_name, 
            race=race, 
            path=path, 
            background=origin_description_as_background, # Pass origin description as background
            sex=sex,
            character_image=character_image,
            stats=custom_stats,
            origin_id=origin_id # Pass origin_id here
        )
        
        self.game_engine.set_llm_enabled(use_llm)
        
        # Ensure journal quests is a dictionary
        initial_quests_data = character_data.get('initial_quests', [])
        journal_quests = {}
        if isinstance(initial_quests_data, dict):
            journal_quests = initial_quests_data
        elif isinstance(initial_quests_data, list):
            logger.warning(f"Initial quests from origin is a list: {initial_quests_data}. Initializing journal quests as an empty dictionary. Full quest population from origin list is not yet implemented here.")
        
        current_game_state = self.game_engine.state_manager.current_state
        if current_game_state:
            if not hasattr(current_game_state, "journal") or current_game_state.journal is None:
                current_game_state.journal = {
                    "character": origin_description_as_background, # Use the same background/origin text
                    "quests": journal_quests,
                    "notes": []
                }
            # Ensure player state's origin_id is set, if GameEngine.start_new_game didn't already
            if not current_game_state.player.origin_id:
                 current_game_state.player.origin_id = origin_id
        
        self._update_ui() 
        self.game_engine.state_manager.ensure_stats_manager_initialized()
        
        if current_game_state and current_game_state.player:
            self.right_panel.update_character(current_game_state.player)

        # Clean up the temporary data
        if hasattr(self, '_character_data_for_new_game'):
            delattr(self, '_character_data_for_new_game')

    @Slot(str)
    def _handle_item_use_requested(self, item_id: str):
        """Handle item use request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item use requested for ID: {item_id}")
        # Placeholder: Implement logic to use the item via InventoryManager or GameEngine
        # For example, this might involve checking if the item is consumable,
        # applying its effects, and removing it from inventory.
        # This could also involve a command like "use <item_id>"
        
        # Example:
        # result = self.game_engine.process_command(f"use {item_id}")
        # self._update_ui() # Update UI after action
        self.game_output.append_system_message(f"Attempting to use item: {item_id} (Handler not fully implemented).")
        # This should ideally go through the command processing loop if 'use' is a player command
        self._process_command(f"use {item_id}")

    @Slot(str)
    def _handle_item_examine_requested(self, item_id: str):
        """Handle item examine request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item examine requested for ID: {item_id}")
        
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item_details_for_dialog(item_id)

        if item:
            from gui.dialogs.item_info_dialog import ItemInfoDialog # Local import
            dialog = ItemInfoDialog(item, self)
            dialog.exec()
        else:
            self.game_output.append_system_message(f"Could not find details for item ID: {item_id}", gradual=False)
            logger.error(f"Could not get item details for ID: {item_id} to show dialog.")
        
        self._update_ui() # Update UI in case item properties were discovered

    @Slot(str) 
    def _handle_item_unequip_requested(self, item_identifier: str): 
        """Handle item unequip request from inventory panel. This is now fully mechanical.
           item_identifier is expected to be an item_id from InventoryPanel.
        """
        logger.info(f"[GUI] MainWindow: Mechanical item unequip requested for ITEM_ID: {item_identifier}")
        inventory_manager = get_inventory_manager()
        
        item_to_unequip = inventory_manager.get_item(item_identifier) 
        if not item_to_unequip: 
            logger.error(f"Cannot unequip: Item ID '{item_identifier}' not found.")
            self._update_ui()
            return
        
        slot_found: Optional[EquipmentSlot] = None
        # inventory_manager.equipment is Dict[EquipmentSlot, Optional[Item]]
        for slot_enum_loop, item_obj_loop in inventory_manager.equipment.items(): 
            if item_obj_loop and isinstance(item_obj_loop, Item) and item_obj_loop.id == item_to_unequip.id:
                slot_found = slot_enum_loop
                break
        
        if not slot_found:
            logger.info(f"{item_to_unequip.name} is not currently equipped (triggered by ID from InventoryPanel).")
            self._update_ui()
            return
        
        item_name_unequipped = item_to_unequip.name
        slot_unequipped_from_str = slot_found.value.replace("_", " ")

        if inventory_manager.unequip_item(slot_found): # unequip_item takes slot
            logger.info(f"Successfully unequipped {item_name_unequipped} from {slot_unequipped_from_str}.")
        else:
            logger.warning(f"Failed to unequip {item_name_unequipped} (Identifier: {item_identifier}).")

        self._update_ui()

    @Slot(str)
    def _handle_item_drop_requested(self, item_id: str):
        """Handle item drop request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item drop requested for ID: {item_id}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id)

        if not item:
            logger.error(f"Drop requested for non-existent item ID: {item_id}")
            self._update_ui()
            return

        if inventory_manager.is_item_equipped(item_id):
            reply = QMessageBox.question(
                self,
                "Confirm Drop Equipped Item",
                f"'{item.name}' is currently equipped. Are you sure you want to drop it?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                logger.info(f"Drop cancelled by user for equipped item: {item.name}")
                return 

            slot_to_unequip: Optional[EquipmentSlot] = None
            for slot_enum, equipped_item_obj in inventory_manager.equipment.items(): 
                if equipped_item_obj and isinstance(equipped_item_obj, Item) and equipped_item_obj.id == item_id: # Check type
                    slot_to_unequip = slot_enum
                    break
            if slot_to_unequip:
                inventory_manager.unequip_item(slot_to_unequip)
                logger.info(f"Unequipped '{item.name}' from {slot_to_unequip.value} prior to dropping.")
                self._update_ui() 
            else:
                logger.error(f"Could not find slot for equipped item '{item.name}' to unequip before dropping.")
                return
        
        logger.info(f"Processing drop command for item ID: {item_id} via LLM.")
        self._process_command(f"drop {item_id}") 

    @Slot(str) 
    def _handle_item_equip_requested(self, item_id: str): 
        """Handle item equip request from inventory panel. This is now fully mechanical."""
        logger.info(f"[GUI] MainWindow: Mechanical item equip requested for ID: {item_id}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id)

        if not item:
            # self.game_output.append_system_message(f"Cannot equip: Item ID {item_id} not found.", gradual=False)
            logger.error(f"Failed to equip item {item_id}: Not found in InventoryManager.")
            self._update_ui() # Update UI to reflect potential state changes even on error
            return

        if not item.is_equippable:
            # self.game_output.append_system_message(f"Cannot equip {item.name}: It is not equippable.", gradual=False)
            logger.info(f"Cannot equip {item.name}: It is not equippable.")
            self._update_ui()
            return

        if inventory_manager.equip_item(item.id): # Preferred slot logic is inside equip_item
            equipped_slot_str = "a suitable slot"
            for slot_enum, equipped_item_id in inventory_manager.equipment.items():
                if equipped_item_id == item.id:
                    equipped_slot_str = slot_enum.value.replace("_", " ")
                    break
            logger.info(f"Successfully equipped {item.name} to {equipped_slot_str}.")
            # No direct output to GameOutputWidget here for mechanical actions
        else:
            # self.game_output.append_system_message(f"Could not equip {item.name}. No suitable slot available or other restriction.", gradual=False)
            logger.warning(f"Failed to equip {item.name} (ID: {item.id}). InventoryManager.equip_item returned false.")

        self._update_ui()

    @Slot(EquipmentSlot)
    def _handle_item_unequip_from_slot_requested(self, slot_to_unequip: EquipmentSlot):
        """Handles unequip request specifically from a known slot (e.g., CharacterSheet)."""
        logger.info(f"[GUI] MainWindow: Mechanical item unequip from slot requested: {slot_to_unequip.value}")
        inventory_manager = get_inventory_manager()
        
        item_obj_in_slot = inventory_manager.equipment.get(slot_to_unequip) # This is an Item object or None
        item_name = "Item"
        if item_obj_in_slot and isinstance(item_obj_in_slot, Item): # Check type
            item_name = item_obj_in_slot.name
        
        if inventory_manager.unequip_item(slot_to_unequip):
            logger.info(f"Successfully unequipped {item_name} from {slot_to_unequip.value}.")
        else:
            logger.warning(f"Failed to unequip item from slot: {slot_to_unequip.value}")
        
        self._update_ui()

    @Slot(EquipmentSlot, str)
    def _handle_item_drop_from_slot_requested(self, slot_to_unequip: EquipmentSlot, item_id_to_drop: str):
        """Handles drop request for an item currently equipped in a slot."""
        logger.info(f"[GUI] MainWindow: Item drop from slot requested. Slot: {slot_to_unequip.value}, Item ID: {item_id_to_drop}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id_to_drop)
        item_name = item.name if item else "the item"

        reply = QMessageBox.question(
            self,
            "Confirm Drop",
            f"Are you sure you want to drop the equipped item '{item_name}' from your {slot_to_unequip.value.replace('_',' ')}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            if inventory_manager.unequip_item(slot_to_unequip):
                logger.info(f"Unequipped {item_name} from {slot_to_unequip.value} prior to dropping.")
                self._process_command(f"drop {item_id_to_drop}") 
            else:
                logger.error(f"Failed to unequip {item_name} (ID: {item_id_to_drop}) from slot {slot_to_unequip.value} before dropping.")
        else:
            logger.info(f"Drop cancelled for item {item_name} from slot {slot_to_unequip.value}.")
        
        self._update_ui()
```

### File: world_configurator\utils\__init__.py

```python
"""
Utility functions for the World Configurator Tool.
"""

```

### File: world_configurator\utils\data_validator.py

```python
"""
Data validation utilities for the World Configurator Tool.
"""

import re
import json
import logging
from typing import Dict, Any, List, Optional, Union, Tuple

logger = logging.getLogger("world_configurator.data_validator")

class ValidationError:
    """
    Represents a validation error in configuration data.
    """
    def __init__(self, field: str, message: str, severity: str = "error"):
        """
        Initialize a ValidationError.
        
        Args:
            field: The field path that has the error.
            message: The error message.
            severity: The severity level ("error", "warning", or "info").
        """
        self.field = field
        self.message = message
        self.severity = severity
    
    def __str__(self) -> str:
        """String representation of the error."""
        return f"{self.severity.upper()} in {self.field}: {self.message}"

class DataValidator:
    """
    Validator for configuration data structures.
    """
    def __init__(self, schema_path: Optional[str] = None):
        """
        Initialize the DataValidator.
        
        Args:
            schema_path: Optional path to a JSON schema file.
        """
        self.schema = None
        if schema_path:
            self.load_schema(schema_path)
    
    def load_schema(self, schema_path: str) -> bool:
        """
        Load a JSON schema from a file.
        
        Args:
            schema_path: Path to the JSON schema file.
        
        Returns:
            True if loading was successful, False otherwise.
        """
        try:
            with open(schema_path, 'r', encoding='utf-8') as f:
                self.schema = json.load(f)
            logger.debug(f"Loaded schema from {schema_path}")
            return True
        except Exception as e:
            logger.error(f"Error loading schema from {schema_path}: {e}")
            self.schema = None
            return False
    
    def validate_cultures(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate cultures data.
        
        Args:
            data: The cultures data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        if "cultures" not in data:
            errors.append(ValidationError("root", "Missing 'cultures' key"))
            return errors
        
        if not isinstance(data["cultures"], dict):
            errors.append(ValidationError("cultures", "Must be a dictionary"))
            return errors
        
        # Check each culture
        for culture_id, culture in data["cultures"].items():
            # Basic field checks
            if not isinstance(culture, dict):
                errors.append(ValidationError(f"cultures.{culture_id}", "Must be a dictionary"))
                continue
            
            # Check for required fields
            required_fields = ["name", "description", "values", "traditions"]
            for field in required_fields:
                if field not in culture:
                    errors.append(ValidationError(
                        f"cultures.{culture_id}", f"Missing required field: {field}"
                    ))
            
            # Check values
            if "values" in culture and isinstance(culture["values"], list):
                if len(culture["values"]) == 0:
                    errors.append(ValidationError(
                        f"cultures.{culture_id}.values", "Should have at least one value"
                    ))
            
            # Check traditions
            if "traditions" in culture and isinstance(culture["traditions"], list):
                if len(culture["traditions"]) == 0:
                    errors.append(ValidationError(
                        f"cultures.{culture_id}.traditions", "Should have at least one tradition"
                    ))
        
        return errors
    
    def validate_locations(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate locations data.
        
        Args:
            data: The locations data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        if "locations" not in data:
            errors.append(ValidationError("root", "Missing 'locations' key"))
            return errors
        
        if not isinstance(data["locations"], dict):
            errors.append(ValidationError("locations", "Must be a dictionary"))
            return errors
        
        # Check each location
        for location_id, location in data["locations"].items():
            # Basic field checks
            if not isinstance(location, dict):
                errors.append(ValidationError(f"locations.{location_id}", "Must be a dictionary"))
                continue
            
            # Check for required fields
            required_fields = ["name", "description", "type"]
            for field in required_fields:
                if field not in location:
                    errors.append(ValidationError(
                        f"locations.{location_id}", f"Missing required field: {field}"
                    ))
            
            # Check connections
            if "connections" in location:
                if not isinstance(location["connections"], list):
                    errors.append(ValidationError(
                        f"locations.{location_id}.connections", "Must be a list"
                    ))
                else:
                    for i, conn in enumerate(location["connections"]):
                        if not isinstance(conn, dict):
                            errors.append(ValidationError(
                                f"locations.{location_id}.connections[{i}]", "Must be a dictionary"
                            ))
                            continue
                        
                        # Check for required connection fields
                        if "target" not in conn:
                            errors.append(ValidationError(
                                f"locations.{location_id}.connections[{i}]", 
                                "Missing required field: target"
                            ))
        
        return errors
    
    def validate_world_history(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate world history data.
        
        Args:
            data: The world history data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        required_fields = ["name", "description", "eras"]
        for field in required_fields:
            if field not in data:
                errors.append(ValidationError("root", f"Missing required field: {field}"))
        
        # Check eras
        if "eras" in data:
            if not isinstance(data["eras"], list):
                errors.append(ValidationError("eras", "Must be a list"))
            else:
                if len(data["eras"]) == 0:
                    errors.append(ValidationError(
                        "eras", "Should have at least one era", "warning"
                    ))
                
                for i, era in enumerate(data["eras"]):
                    if not isinstance(era, dict):
                        errors.append(ValidationError(f"eras[{i}]", "Must be a dictionary"))
                        continue
                    
                    # Check for required era fields
                    era_required = ["name", "start_year", "end_year", "description", "events"]
                    for field in era_required:
                        if field not in era:
                            errors.append(ValidationError(
                                f"eras[{i}]", f"Missing required field: {field}"
                            ))
                    
                    # Check events
                    if "events" in era:
                        if not isinstance(era["events"], list):
                            errors.append(ValidationError(f"eras[{i}].events", "Must be a list"))
                        else:
                            for j, event in enumerate(era["events"]):
                                if not isinstance(event, dict):
                                    errors.append(ValidationError(
                                        f"eras[{i}].events[{j}]", "Must be a dictionary"
                                    ))
                                    continue
                                
                                # Check for required event fields
                                event_required = ["year", "title", "description"]
                                for field in event_required:
                                    if field not in event:
                                        errors.append(ValidationError(
                                            f"eras[{i}].events[{j}]", 
                                            f"Missing required field: {field}"
                                        ))
        
        return errors
    
    def validate_scenario(self, data: Dict[str, Any]) -> List[ValidationError]:
        """
        Validate a scenario definition.
        
        Args:
            data: The scenario data to validate.
        
        Returns:
            A list of validation errors, or an empty list if validation passed.
        """
        errors = []
        
        # Check for required top-level structure
        if not isinstance(data, dict):
            errors.append(ValidationError("root", "Must be a dictionary"))
            return errors
        
        required_fields = ["id", "name", "description", "starting_location", "quests"]
        for field in required_fields:
            if field not in data:
                errors.append(ValidationError("root", f"Missing required field: {field}"))
        
        # Check quests
        if "quests" in data:
            if not isinstance(data["quests"], list):
                errors.append(ValidationError("quests", "Must be a list"))
            else:
                for i, quest in enumerate(data["quests"]):
                    if not isinstance(quest, dict):
                        errors.append(ValidationError(f"quests[{i}]", "Must be a dictionary"))
                        continue
                    
                    # Check for required quest fields
                    quest_required = ["id", "title", "description", "objectives"]
                    for field in quest_required:
                        if field not in quest:
                            errors.append(ValidationError(
                                f"quests[{i}]", f"Missing required field: {field}"
                            ))
                    
                    # Check objectives
                    if "objectives" in quest:
                        if not isinstance(quest["objectives"], list):
                            errors.append(ValidationError(
                                f"quests[{i}].objectives", "Must be a list"
                            ))
                        else:
                            for j, objective in enumerate(quest["objectives"]):
                                if not isinstance(objective, dict):
                                    errors.append(ValidationError(
                                        f"quests[{i}].objectives[{j}]", "Must be a dictionary"
                                    ))
                                    continue
                                
                                # Check for required objective fields
                                obj_required = ["id", "description", "type"]
                                for field in obj_required:
                                    if field not in objective:
                                        errors.append(ValidationError(
                                            f"quests[{i}].objectives[{j}]", 
                                            f"Missing required field: {field}"
                                        ))
        
        return errors
    
    def get_validator_for_type(self, data_type: str):
        """
        Get the appropriate validator function for a data type.
        
        Args:
            data_type: The type of data to validate.
        
        Returns:
            A validation function for the specified data type.
        """
        validators = {
            "cultures": self.validate_cultures,
            "locations": self.validate_locations,
            "world_history": self.validate_world_history,
            "scenario": self.validate_scenario,
        }
        
        return validators.get(data_type, lambda x: [])

```

### File: world_configurator\utils\file_manager.py

```python
"""
File management utilities for the World Configurator Tool.
"""

import os
import json
import logging
import shutil
import datetime
from typing import Dict, Any, Optional, Union

logger = logging.getLogger("world_configurator.file_manager")

def get_project_root() -> str:
    """
    Get the root directory of the project.
    
    Returns:
        The absolute path to the project root directory.
    """
    # Go up from the utils directory to find project root
    current_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    return os.path.normpath(os.path.join(current_dir, ".."))

def get_config_dir() -> str:
    """
    Get the configuration directory of the project.
    
    Returns:
        The absolute path to the config directory.
    """
    return os.path.join(get_project_root(), "config")

def get_world_config_dir() -> str:
    """
    Get the world configuration directory.
    
    Returns:
        The absolute path to the world config directory.
    """
    return os.path.join(get_config_dir(), "world")

def ensure_dir_exists(directory: str) -> None:
    """
    Ensure that a directory exists, creating it if necessary.
    
    Args:
        directory: The directory path to check/create.
    """
    if not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)
        logger.info(f"Created directory: {directory}")

def load_json(file_path: str) -> Optional[Dict[str, Any]]:
    """
    Load JSON data from a file.
    
    Args:
        file_path: The path to the JSON file.
    
    Returns:
        The loaded JSON data as a dictionary, or None if loading failed.
    """
    try:
        if not os.path.exists(file_path):
            logger.warning(f"File does not exist: {file_path}")
            return None
        
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        logger.debug(f"Loaded JSON from {file_path}")
        return data
    except Exception as e:
        logger.error(f"Error loading JSON from {file_path}: {e}")
        return None

def save_json(data: Dict[str, Any], file_path: str, pretty: bool = True) -> bool:
    """
    Save JSON data to a file.
    
    Args:
        data: The data to save.
        file_path: The path to the JSON file.
        pretty: Whether to format the JSON for readability.
    
    Returns:
        True if the save was successful, False otherwise.
    """
    try:
        # Ensure the directory exists
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Save with appropriate formatting
        indent = 2 if pretty else None
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=indent, ensure_ascii=False)
        
        logger.debug(f"Saved JSON to {file_path}")
        return True
    except Exception as e:
        logger.error(f"Error saving JSON to {file_path}: {e}")
        return False

def create_backup(file_path: str) -> Optional[str]:
    """
    Create a backup of a file.
    
    Args:
        file_path: The path to the file to back up.
    
    Returns:
        The path to the backup file, or None if backup failed.
    """
    try:
        if not os.path.exists(file_path):
            logger.warning(f"Cannot back up non-existent file: {file_path}")
            return None
        
        # Create backup filename
        backup_path = f"{file_path}.bak"
        
        # Copy file
        shutil.copy2(file_path, backup_path)
        
        logger.debug(f"Created backup: {backup_path}")
        return backup_path
    except Exception as e:
        logger.error(f"Error creating backup of {file_path}: {e}")
        return None

def export_to_game(source_path: str, target_subpath: str) -> bool:
    """
    Export a configuration file to the game's config directory.
    
    Args:
        source_path: The path to the source file.
        target_subpath: The subpath within the game's config directory.
    
    Returns:
        True if the export was successful, False otherwise.
    """
    try:
        if not os.path.exists(source_path):
            logger.warning(f"Source file does not exist: {source_path}")
            return False
        
        # Construct target path
        config_dir = get_config_dir()
        target_path = os.path.join(config_dir, target_subpath)
        
        # Ensure target directory exists
        os.makedirs(os.path.dirname(target_path), exist_ok=True)
        
        # Create backup folder if it doesn't exist
        backup_dir = os.path.join(os.path.dirname(target_path), "backup")
        os.makedirs(backup_dir, exist_ok=True)
        
        # Create timestamped backup if target exists
        if os.path.exists(target_path):
            filename = os.path.basename(target_path)
            name, ext = os.path.splitext(filename)
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"{name}_{timestamp}{ext}"
            backup_path = os.path.join(backup_dir, backup_filename)
            
            try:
                shutil.copy2(target_path, backup_path)
                logger.info(f"Created backup of {target_path} at {backup_path}")
            except Exception as backup_err:
                logger.error(f"Failed to create backup: {backup_err}")
                # Continue with export even if backup fails
        
        # Copy file
        shutil.copy2(source_path, target_path)
        
        logger.info(f"Exported {source_path} to {target_path}")
        return True
    except Exception as e:
        logger.error(f"Error exporting {source_path} to {target_subpath}: {e}")
        return False

def list_files_in_dir(directory: str, extension: Optional[str] = None) -> list:
    """
    List all files in a directory, optionally filtered by extension.
    
    Args:
        directory: The directory to list files from.
        extension: The file extension to filter by, or None for all files.
    
    Returns:
        A list of filenames in the directory.
    """
    try:
        if not os.path.exists(directory) or not os.path.isdir(directory):
            logger.warning(f"Directory does not exist: {directory}")
            return []
        
        if extension:
            # Filter by extension
            return [f for f in os.listdir(directory) 
                  if os.path.isfile(os.path.join(directory, f)) and f.endswith(extension)]
        else:
            # All files
            return [f for f in os.listdir(directory) 
                  if os.path.isfile(os.path.join(directory, f))]
    except Exception as e:
        logger.error(f"Error listing files in {directory}: {e}")
        return []

```

### File: world_configurator\utils\logging_setup.py

```python
"""
Logging setup for the World Configurator Tool.
"""

import os
import logging
import datetime
from logging.handlers import RotatingFileHandler

def setup_logging(level=logging.INFO):
    """
    Set up logging for the World Configurator Tool.
    
    Args:
        level: The logging level to use.
    """
    # Create logs directory if it doesn't exist
    logs_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "logs")
    os.makedirs(logs_dir, exist_ok=True)
    
    # Create log filename with date
    date_str = datetime.datetime.now().strftime("%Y%m%d")
    log_file = os.path.join(logs_dir, f"world_configurator_{date_str}.log")
    
    # Configure root logger
    logger = logging.getLogger()
    logger.setLevel(level)
    
    # Create console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_format = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%H:%M:%S"
    )
    console_handler.setFormatter(console_format)
    
    # Create file handler
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=5 * 1024 * 1024,  # 5 MB
        backupCount=5
    )
    file_handler.setLevel(level)
    file_format = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    file_handler.setFormatter(file_format)
    
    # Add handlers to root logger
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    # Create world_configurator logger
    wc_logger = logging.getLogger("world_configurator")
    wc_logger.setLevel(level)
    
    return wc_logger

```

### File: core\orchestration\__init__.py

```python

```

### File: core\orchestration\combat_orchestrator.py

```python
"""
Manages the sequential display of combat events, including narratives,
system messages, and UI updates, respecting delays and completion signals.
"""
import collections
import logging
import weakref
from typing import Dict, Optional, TYPE_CHECKING

from PySide6.QtCore import QObject, QTimer, Signal, Slot

from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget

if TYPE_CHECKING:
    from core.base.engine import GameEngine
    from core.combat.combat_manager import CombatManager
    from core.audio.tts_manager import TTSManager # Placeholder

logger = logging.getLogger("ORCHESTRATOR") # New logger category

class CombatOutputOrchestrator(QObject):
    """
    Orchestrates the output of combat-related information to ensure
    sequential display, inter-step delays, and TTS compatibility.
    """
    # Signal to resume CombatManager processing
    resume_combat_manager = Signal()
    # Developer-mode: notify UI whether orchestrator is waiting for manual release
    dev_waiting_state_changed = Signal(bool)

    def __init__(self, parent: Optional[QObject] = None):
        super().__init__(parent)
        self.event_queue: collections.deque[DisplayEvent] = collections.deque()
        self.is_processing_event: bool = False
        self.is_waiting_for_visual: bool = False
        self.is_waiting_for_tts: bool = False # Placeholder for TTS

        self.inter_step_delay_timer: QTimer = QTimer(self)
        self.inter_step_delay_timer.setSingleShot(True)
        self.inter_step_delay_timer.timeout.connect(self._on_inter_step_delay_timeout)

        self.engine_ref: Optional[weakref.ref['GameEngine']] = None
        self.combat_manager_ref: Optional[weakref.ref['CombatManager']] = None
        self.tts_manager_ref: Optional[weakref.ref['TTSManager']] = None # Placeholder

        self.config_delay_ms: int = 1000 # Default 1 second, load from config later
        self.current_event: Optional[DisplayEvent] = None

        # Developer mode controls
        self.dev_manual_step_mode: bool = False
        self.dev_waiting_for_next_click: bool = False
        self.dev_last_skip_delay: bool = False

    def set_references(self, engine: 'GameEngine', tts_manager: Optional['TTSManager'] = None):
        """Set references to other core components. CombatManager is set per combat."""
        self.engine_ref = weakref.ref(engine)
        if tts_manager:
            self.tts_manager_ref = weakref.ref(tts_manager)
        logger.info("CombatOutputOrchestrator references set.")

    def set_combat_manager(self, combat_manager: Optional['CombatManager']):
        """Set or clear the current CombatManager reference."""
        if combat_manager:
            self.combat_manager_ref = weakref.ref(combat_manager)
            logger.debug(f"Orchestrator now referencing CombatManager: {combat_manager.id if combat_manager else 'None'}")
        else:
            self.combat_manager_ref = None
            logger.debug("Orchestrator cleared CombatManager reference.")


    def load_config(self):
        """Loads configuration, e.g., inter-step delay."""
        engine = self.engine_ref() if self.engine_ref else None
        if engine and hasattr(engine, '_config'):
            self.config_delay_ms = engine._config.get("combat.inter_step_delay_ms", 1000)
            logger.info(f"Orchestrator inter-step delay set to {self.config_delay_ms}ms from config.")
        else:
            logger.warning("Could not load orchestrator config, using default delay.")


    def add_event_to_queue(self, event: DisplayEvent):
        """Adds a DisplayEvent to the processing queue."""
        # Guard against stale rehydrate events crossing session boundaries
        try:
            engine = self.engine_ref() if self.engine_ref else None
            if engine and getattr(event, 'source_step', None) == 'REHYDRATE_FROM_SAVE':
                # Accept only if session_id matches current state's session
                expected = None
                try:
                    meta = getattr(event, 'metadata', None) or {}
                    expected = meta.get('session_id')
                except Exception:
                    expected = None
                curr_state = getattr(engine, '_state_manager', None).current_state if engine and hasattr(engine, '_state_manager') else None
                curr_sess = getattr(curr_state, 'session_id', None) if curr_state else None
                if expected is not None and curr_sess is not None and expected != curr_sess:
                    logger.info("Dropping stale REHYDRATE_FROM_SAVE event due to session_id mismatch.")
                    return
        except Exception:
            # Non-fatal: if guard fails, proceed to enqueue (better to over-show than crash)
            pass

        self.event_queue.append(event)
        logger.debug(f"Event added to queue: {event}. Queue size: {len(self.event_queue)}")
        if not self.is_processing_event and not self.inter_step_delay_timer.isActive():
            # If nothing is currently happening (not processing, not in delay), start processing.
            # This handles the case where CombatManager queues an event and immediately pauses.
            logger.debug("Orchestrator was idle, triggering _process_next_event_from_queue.")
            self._process_next_event_from_queue()


    @Slot()
    def _process_next_event_from_queue(self):
        """Processes the next event from the queue if conditions allow."""
        if self.is_processing_event or self.inter_step_delay_timer.isActive():
            logger.debug("Orchestrator busy or in delay, skipping _process_next_event_from_queue.")
            return

        if not self.event_queue:
            logger.debug("Event queue empty. Orchestrator idle.")
            combat_manager = self.combat_manager_ref() if self.combat_manager_ref else None
            engine = self.engine_ref() if self.engine_ref else None
            if combat_manager and getattr(combat_manager, 'waiting_for_display_completion', False):
                 logger.debug("Event queue empty, but CombatManager was waiting. Signalling resume (end of sub-step).")
                 self._signal_combat_manager_resume()
            elif engine and getattr(engine, '_waiting_for_closing_narrative_display', False):
                 logger.info("Orchestrator queue empty, and engine was waiting for closing narrative. Signaling engine completion.")
                 if hasattr(engine, 'on_orchestrator_idle_and_combat_manager_resumed'):
                     engine.on_orchestrator_idle_and_combat_manager_resumed()
            return

        # --- ECFA Fix: Use a local variable for the event being processed ---
        event_being_processed = self.event_queue.popleft()
        # Guard again at processing time against stale rehydrate events that were enqueued before a session change
        try:
            engine = self.engine_ref() if self.engine_ref else None
            if engine and getattr(event_being_processed, 'source_step', None) == 'REHYDRATE_FROM_SAVE':
                meta = getattr(event_being_processed, 'metadata', None) or {}
                expected = meta.get('session_id')
                curr_state = getattr(engine, '_state_manager', None).current_state if engine and hasattr(engine, '_state_manager') else None
                curr_sess = getattr(curr_state, 'session_id', None) if curr_state else None
                if expected is not None and curr_sess is not None and expected != curr_sess:
                    logger.info("Skipping processing of stale REHYDRATE_FROM_SAVE event due to session_id mismatch.")
                    # Immediately move on to next event
                    self.is_processing_event = False
                    self.current_event_id_for_signals = None
                    # Recurse to process next event quickly
                    self._process_next_event_from_queue()
                    return
        except Exception:
            pass

        self.current_event_id_for_signals = event_being_processed.event_id # Store ID for slots to check
        # Track the current event object for timing decisions later
        self.current_event = event_being_processed
        # --- End ECFA Fix ---
        
        logger.info(f"Processing event: {event_being_processed}")
        self.is_processing_event = True # Mark orchestrator as busy with THIS event
        self.is_waiting_for_visual = False
        self.is_waiting_for_tts = False

        engine = self.engine_ref() if self.engine_ref else None
        if not engine:
            logger.error("Engine reference not available in Orchestrator. Cannot process event.")
            self.is_processing_event = False
            self.current_event_id_for_signals = None
            # If an event was popped, try to simulate its completion to avoid stall
            # by directly calling check_event_processing_complete as if it finished.
            self._check_event_processing_complete(event_being_processed.event_id)
            return

        if event_being_processed.type == DisplayEventType.REQUEST_CLOSING_NARRATIVE:
            logger.info("Orchestrator handling REQUEST_CLOSING_NARRATIVE.")
            self._handle_request_closing_narrative(engine, event_being_processed.metadata)
            self.is_processing_event = False 
            self.current_event_id_for_signals = None
            self._process_next_event_from_queue() 
            return

        if event_being_processed.type == DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE:
            logger.debug(f"Applying model resource update: {event_being_processed.metadata}")
            try:
                meta = event_being_processed.metadata or {}
                entity_id = meta.get("entity_id")
                bar_type = str(meta.get("bar_type", "")).lower()
                value = meta.get("final_new_value")
                max_value = meta.get("max_value")
                if entity_id is not None and value is not None:
                    # Clamp value between 0 and max_value if provided
                    try:
                        if max_value is not None:
                            value = max(0, min(int(value), int(max_value)))
                        else:
                            value = max(0, int(value))
                    except Exception:
                        pass
                    cm = self.combat_manager_ref() if self.combat_manager_ref else None
                    if cm:
                        # Update through entity-specific stats manager when available
                        stats_mgr = getattr(cm, '_get_entity_stats_manager', None)
                        entity_stats_mgr = stats_mgr(entity_id) if stats_mgr else None
                        from core.stats.stats_base import DerivedStatType
                        # Map bar_type to stat
                        if bar_type in ("hp", "health"):
                            if entity_stats_mgr:
                                entity_stats_mgr.set_current_stat(DerivedStatType.HEALTH, value)
                            entity = cm.entities.get(entity_id)
                            if entity: entity.set_current_hp(value)
                        elif bar_type in ("stamina",):
                            if entity_stats_mgr:
                                entity_stats_mgr.set_current_stat(DerivedStatType.STAMINA, value)
                            entity = cm.entities.get(entity_id)
                            if entity: entity.set_current_stamina(value)
                        elif bar_type in ("mana", "mp"):
                            if entity_stats_mgr:
                                entity_stats_mgr.set_current_stat(DerivedStatType.MANA, value)
                            entity = cm.entities.get(entity_id)
                            if entity is not None:
                                try:
                                    entity.current_mp = value
                                except Exception:
                                    pass
                        else:
                            logger.warning(f"Unknown bar_type '{bar_type}' in APPLY_ENTITY_RESOURCE_UPDATE")
                    else:
                        logger.error("CombatManager reference missing; cannot apply resource update.")
            except Exception as e:
                logger.error(f"Error applying entity resource update: {e}", exc_info=True)
            # Event-based completion for this non-visual event: keep is_processing_event True so completion advances queue
            logger.debug(f"APPLY_ENTITY_RESOURCE_UPDATE done for {event_being_processed.event_id}; advancing queue")
            self._check_event_processing_complete(event_being_processed.event_id)
            return

        if event_being_processed.type == DisplayEventType.APPLY_ENTITY_STATE_UPDATE:
            logger.debug(f"Applying model state update: {event_being_processed.metadata}")
            try:
                meta = event_being_processed.metadata or {}
                entity_id = meta.get("entity_id")
                cm = self.combat_manager_ref() if self.combat_manager_ref else None
                if cm and entity_id in cm.entities:
                    entity = cm.entities.get(entity_id)
                    if entity is not None:
                        if "is_active_in_combat" in meta:
                            try:
                                entity.is_active_in_combat = bool(meta.get("is_active_in_combat"))
                            except Exception:
                                pass
                else:
                    logger.warning("Cannot apply entity state update; missing CombatManager or entity.")
            except Exception as e:
                logger.error(f"Error applying entity state update: {e}", exc_info=True)
            # Event-based completion for this non-visual event: keep is_processing_event True so completion advances queue
            logger.debug(f"APPLY_ENTITY_STATE_UPDATE done for {event_being_processed.event_id}; advancing queue")
            self._check_event_processing_complete(event_being_processed.event_id)
            return

        # --- Handle special non-visual events ---

        # --- Route event content to UI for visual display ---
        # Assuming UI_BAR_UPDATE and VISUAL_EFFECT also go through orchestrated_event_to_ui
        # and their handlers in MainWindow will call _handle_visual_display_complete appropriately.
        self.is_waiting_for_visual = True
        engine.orchestrated_event_to_ui.emit(event_being_processed)

        # Special case: BUFFER_FLUSH to text displays does not need visual completion waiting
        try:
            if event_being_processed.type in (DisplayEventType.BUFFER_FLUSH, DisplayEventType.COMBAT_LOG_SET_HTML):
                # We consider batch text append immediate for orchestrator purposes
                self.is_waiting_for_visual = False
        except Exception:
            pass

        # No persistence needed here; HTML snapshot approach will be used for rehydration.
        
        # --- Handle TTS ---
        tts_manager = self.tts_manager_ref() if self.tts_manager_ref else None
        if event_being_processed.tts_eligible and tts_manager and tts_manager.is_enabled:
            content_to_speak = ""
            if isinstance(event_being_processed.content, str):
                content_to_speak = event_being_processed.content
            elif isinstance(event_being_processed.content, list) and event_being_processed.type == DisplayEventType.BUFFER_FLUSH:
                content_to_speak = "\n".join(str(item) for item in event_being_processed.content)
            
            if content_to_speak.strip():
                self.is_waiting_for_tts = True
                tts_manager.speak(content_to_speak)
        
        # If neither visual nor TTS is awaited (e.g., event type doesn't require it, or TTS disabled)
        # then call _check_event_processing_complete.
        # This path is tricky because is_waiting_for_visual is set true, expecting a signal.
        # If an event type TRULY has no visual and no TTS, it should bypass setting these flags.
        # For now, assume all emitted events will lead to _handle_visual_display_complete.
        if not self.is_waiting_for_visual and not self.is_waiting_for_tts:
            logger.debug(f"No visual or TTS initially awaited for event {event_being_processed.event_id}. Checking completion.")
            self._check_event_processing_complete(event_being_processed.event_id)

    @Slot()
    def _handle_visual_display_complete(self):
        """Slot called when a UI widget finishes displaying text."""
        # --- ECFA Fix: Check against stored event ID ---
        # This slot might be called for an event that's already "completed" if UI signals are rapid
        # or if a previous event's signal arrives late.
        # We only care if it's for the event we are currently marked as 'processing'.
        if not self.is_processing_event: 
            logger.debug(f"Received visualDisplayComplete but Orchestrator not actively processing an event (or already completed it). Ignoring.")
            return
        # If we want to be super sure, we could pass event_id with the signal, but that makes UI more complex.
        # For now, if is_processing_event is true, assume it's for the event whose ID is in self.current_event_id_for_signals.
        logger.debug(f"Received visualDisplayComplete for current processing cycle (event_id around: {self.current_event_id_for_signals}).")
        # --- End ECFA Fix ---
        
        self.is_waiting_for_visual = False
        self._check_event_processing_complete(self.current_event_id_for_signals)

    @Slot()
    def _handle_tts_playback_complete(self):
        """Slot called when TTS finishes speaking."""
        if not self.is_processing_event:
            logger.debug(f"Received ttsPlaybackComplete but Orchestrator not actively processing an event. Ignoring.")
            return
        logger.debug(f"Received ttsPlaybackComplete for current processing cycle (event_id around: {self.current_event_id_for_signals}).")
        self.is_waiting_for_tts = False
        self._check_event_processing_complete(self.current_event_id_for_signals)

    def _check_event_processing_complete(self, event_id_completed: Optional[str]):
        """
        Checks if all parts of the current event are done (visual, TTS).
        Uses event_id_completed to ensure we are finalizing the correct event.
        """
        # --- ECFA Fix: Only proceed if this completion matches the event being processed ---
        if not self.is_processing_event or self.current_event_id_for_signals != event_id_completed:
            if self.is_processing_event: # Mismatch
                logger.warning(f"_check_event_processing_complete called for event '{event_id_completed}', "
                               f"but currently processing event '{self.current_event_id_for_signals}'. Ignoring this completion call.")
            # Else, already not processing, so this is a late signal for a past event.
            return 
        # --- End ECFA Fix ---

        if not self.is_waiting_for_visual and not self.is_waiting_for_tts:
            logger.info(f"Event processing truly complete for: {self.current_event_id_for_signals}")
            self.is_processing_event = False
            self.current_event_id_for_signals = None # Clear the ID of the event just completed

            # Decide whether to apply an inter-step delay based on event type
            skip_delay = False
            try:
                from core.orchestration.events import DisplayEventType
                if hasattr(self, 'current_event') and self.current_event and \
                   self.current_event.type in (DisplayEventType.UI_BAR_UPDATE_PHASE1, DisplayEventType.UI_BAR_UPDATE_PHASE2,
                                               DisplayEventType.APPLY_ENTITY_RESOURCE_UPDATE, DisplayEventType.APPLY_ENTITY_STATE_UPDATE):
                    skip_delay = True
            except Exception:
                pass

            # Always clear current_event once we've computed skip_delay
            self.dev_last_skip_delay = skip_delay
            self.current_event = None

            # Developer manual step gating
            if getattr(self, 'dev_manual_step_mode', False):
                logger.debug("Developer Step Mode: waiting for manual release before continuing.")
                self.dev_waiting_for_next_click = True
                try:
                    self.dev_waiting_state_changed.emit(True)
                except Exception:
                    pass
                return

            if skip_delay:
                logger.debug("Skipping inter-step delay after UI_BAR_UPDATE event to keep UI updates in sync.")
                self._process_next_event_from_queue()
            else:
                self.inter_step_delay_timer.start(self.config_delay_ms)
                logger.debug(f"Started inter-step delay: {self.config_delay_ms}ms after event {event_id_completed}")

    @Slot()
    def _on_inter_step_delay_timeout(self):
        logger.debug("Inter-step delay timeout.")
        resumed_cm_and_cm_is_not_waiting = self._signal_combat_manager_resume() 
        
        # If we were in dev manual step mode and waiting, clear waiting state upon timeout
        if getattr(self, 'dev_manual_step_mode', False) and getattr(self, 'dev_waiting_for_next_click', False):
            self.dev_waiting_for_next_click = False
            try:
                self.dev_waiting_state_changed.emit(False)
            except Exception:
                pass
        
        engine = self.engine_ref() if self.engine_ref else None
        if engine and hasattr(engine, 'main_window_ref'): # Assuming MainWindow registers itself with engine
            main_window = engine.main_window_ref()
            if main_window and hasattr(main_window, '_update_ui'):
                 logger.debug("Orchestrator delay timeout: Triggering MainWindow._update_ui()")
                 QTimer.singleShot(0, main_window._update_ui) # Schedule UI update

        if not self.is_processing_event and self.event_queue:
            logger.debug("Processing next event from queue after delay.")
            self._process_next_event_from_queue()
        elif not self.is_processing_event and not self.event_queue:
            logger.debug("Queue empty after delay and CM resume signal. Orchestrator idle.")
            # If combat just ended successfully, trigger engine's auto-finalization to switch to narrative mode.
            try:
                engine = self.engine_ref() if self.engine_ref else None
                if engine:
                    from core.interaction.enums import InteractionMode
                    from core.combat.enums import CombatStep, CombatState
                    state_manager = getattr(engine, '_state_manager', None)
                    game_state = state_manager.current_state if state_manager else None
                    if game_state and game_state.current_mode == InteractionMode.COMBAT and getattr(game_state, 'combat_manager', None):
                        cm = game_state.combat_manager
                        if getattr(cm, 'current_step', None) == CombatStep.COMBAT_ENDED and getattr(cm, 'state', None) != CombatState.PLAYER_DEFEAT:
                            QTimer.singleShot(0, engine._finalize_combat_transition_if_needed)
            except Exception as e:
                logger.error(f"Error scheduling automatic post-combat finalization: {e}", exc_info=True)
            # Always notify engine that orchestrator is idle so it can clear any waiting flags
            try:
                self.resume_combat_manager.emit()
            except Exception:
                pass


    def _signal_combat_manager_resume(self) -> bool:
        """Signals CM to resume. Returns True if CM was resumed and is NOT now waiting."""
        combat_manager = self.combat_manager_ref() if self.combat_manager_ref else None
        engine = self.engine_ref() if self.engine_ref else None
        resumed_and_not_waiting_again = False

        if combat_manager and getattr(combat_manager, 'waiting_for_display_completion', False):
            # Do not resume if combat is no longer in progress
            try:
                from core.combat.enums import CombatState
                cm_state = getattr(combat_manager, 'state', None)
                logger.info(f"CombatManager resume check. State: {cm_state.name if cm_state else 'Not available'}")
                if cm_state is not None and cm_state != CombatState.IN_PROGRESS:
                    logger.info(f"CombatManager state is {cm_state.name}, not IN_PROGRESS. Clearing stale events and nudging CM for final messages.")
                    # 1. Clear any stale events from the normal combat flow.
                    self.clear_queue_and_reset_flags()
                    # 2. Nudge the CombatManager to run its final step (_step_ending_combat).
                    #    This will add the correct final messages (loot, conclusion) to the now-clean queue.
                    if engine:
                        QTimer.singleShot(0, lambda: combat_manager.process_combat_step(engine))
                    # 3. Return False because we are not resuming the normal combat loop.
                    return False
            except Exception:
                pass
            logger.info("Signaling CombatManager to resume processing.")
            combat_manager.waiting_for_display_completion = False
            if engine:
                # Use QTimer to allow event loop to process signals first.
                QTimer.singleShot(0, lambda: combat_manager.process_combat_step(engine))
                resumed_and_not_waiting_again = not getattr(combat_manager, 'waiting_for_display_completion', True)
            else:
                logger.error("Cannot resume CombatManager: Engine reference missing.")
        else:
            logger.debug("CombatManager not waiting or not available. No resume signal sent.")
        return resumed_and_not_waiting_again
    
    def clear_queue_and_reset_flags(self):
        """Resets the orchestrator state, typically when combat ends or is forcefully stopped."""
        logger.info("Clearing event queue and resetting orchestrator flags.")
        self.event_queue.clear()
        if self.inter_step_delay_timer.isActive():
            self.inter_step_delay_timer.stop()
        self.is_processing_event = False
        self.is_waiting_for_visual = False
        self.is_waiting_for_tts = False
        self.current_event = None
        # Do not clear combat_manager_ref here, it's managed by set_combat_manager

    def shutdown(self):
        """Called when the engine is shutting down to stop timers."""
        logger.info("Shutting down CombatOutputOrchestrator.")
        self.clear_queue_and_reset_flags()
        self.dev_manual_step_mode = False
        self.dev_waiting_for_next_click = False
        if self.inter_step_delay_timer:
            self.inter_step_delay_timer.timeout.disconnect(self._on_inter_step_delay_timeout)

    def _handle_request_closing_narrative(self, engine: 'GameEngine', metadata: Optional[Dict]):
        """Handles the event to request and queue the closing combat narrative."""
        if not metadata or "outcome" not in metadata:
            logger.error("REQUEST_CLOSING_NARRATIVE missing outcome metadata.")
            # To prevent stalling, we should still allow engine to proceed
            if getattr(engine, '_waiting_for_closing_narrative_display', False):
                 engine._waiting_for_closing_narrative_display = False
            return

        outcome = metadata["outcome"]
        closing_prompt = f"The combat has just ended. The outcome was: {outcome}. Provide a brief, immersive closing narrative (1-2 sentences) describing the aftermath for the player."
        
        llm_narrative = "[Default Closing: The dust settles on the battlefield.]" # Fallback
        if engine._use_llm and hasattr(engine, '_agent_manager'):
            try:
                # This assumes AgentManager has a method or can route this appropriately.
                # A new method in NarratorAgent or AgentManager might be cleaner.
                # For now, using a simplified direct call similar to initial narrative.
                # This should ideally be non-blocking if using threads for LLM calls.
                # For now, this will block the orchestrator briefly.
                logger.info(f"Orchestrator requesting closing combat narrative with prompt: {closing_prompt}")
                
                # Re-using process_with_llm from interaction_core for simplicity,
                # though a dedicated method in AgentManager would be better.
                from core.game_flow.interaction_core import process_with_llm 
                gs = engine._state_manager.current_state if hasattr(engine, '_state_manager') and engine._state_manager else None
                response = process_with_llm(gs, closing_prompt)
                if response.is_success and response.message:
                    llm_narrative = response.message
                    logger.info(f"Orchestrator received closing narrative: {llm_narrative[:70]}...")
                else:
                    logger.warning("Failed to generate closing combat narrative from LLM.")
            except Exception as e:
                logger.error(f"Error generating closing combat narrative via LLM: {e}", exc_info=True)
        else:
            logger.info("LLM disabled, using default closing narrative.")

        closing_narrative_event = DisplayEvent(
            type=DisplayEventType.NARRATIVE_GENERAL,
            content=llm_narrative,
            role="gm",
            target_display=DisplayTarget.MAIN_GAME_OUTPUT,
            gradual_visual_display=True,
            tts_eligible=True,
            source_step="CLOSING_COMBAT_NARRATIVE"
        )
        # Add to the front of the queue to be processed next
        self.event_queue.appendleft(closing_narrative_event)
        logger.debug(f"Queued closing narrative event: {closing_narrative_event}")

    @Slot(bool)
    def toggle_dev_step_mode(self, enabled: bool) -> None:
        """Enable/disable developer manual step mode."""
        prev = getattr(self, 'dev_manual_step_mode', False)
        self.dev_manual_step_mode = bool(enabled)
        logger.info(f"Developer Step Mode set to {self.dev_manual_step_mode}")
        if prev and not self.dev_manual_step_mode:
            # If we were waiting and dev mode is turned off, release automatically
            if getattr(self, 'dev_waiting_for_next_click', False):
                logger.debug("Developer Step Mode disabled during waiting; auto-releasing next step.")
                self.dev_waiting_for_next_click = False
                try:
                    self.dev_waiting_state_changed.emit(False)
                except Exception:
                    pass
                # Follow normal path depending on last skip decision
                if getattr(self, 'dev_last_skip_delay', False):
                    self._process_next_event_from_queue()
                else:
                    self.inter_step_delay_timer.start(self.config_delay_ms)

    @Slot()
    def dev_release_next_step(self) -> None:
        """When in developer manual step mode, release the next event step."""
        if not getattr(self, 'dev_manual_step_mode', False):
            logger.debug("dev_release_next_step called but Developer Step Mode is OFF. Ignoring.")
            return
        if not getattr(self, 'dev_waiting_for_next_click', False):
            logger.debug("dev_release_next_step called but orchestrator is not waiting.")
            return
        logger.info("Developer Step Mode: releasing next step.")
        self.dev_waiting_for_next_click = False
        try:
            self.dev_waiting_state_changed.emit(False)
        except Exception:
            pass
        # Continue according to the last skip-delay decision
        if getattr(self, 'dev_last_skip_delay', False):
            self._process_next_event_from_queue()
        else:
            self.inter_step_delay_timer.start(self.config_delay_ms)


```

### File: core\orchestration\events.py

```python
"""
Defines event structures for the CombatOutputOrchestrator.
"""
from enum import Enum, auto
from dataclasses import dataclass, field
from typing import Union, Dict, Any, Optional, List
import uuid

class DisplayEventType(Enum):
    """Types of events the CombatOutputOrchestrator can handle."""
    NARRATIVE_ATTEMPT = auto()      # LLM narrative describing an action attempt
    NARRATIVE_IMPACT = auto()       # LLM narrative describing an action's outcome
    NARRATIVE_GENERAL = auto()      # Other general narrative from LLM during combat or post-combat
    SYSTEM_MESSAGE = auto()         # Game system messages (rolls, status changes, turns)
    UI_BAR_UPDATE_PHASE1 = auto()   # Initiate visual phase 1 for HP/Stamina/Mana bar decrease
    UI_BAR_UPDATE_PHASE2 = auto()   # Finalize visual phase 2 for HP/Stamina/Mana bar decrease
    VISUAL_EFFECT_TRIGGER = auto()  # Placeholder for triggering visual effects
    BUFFER_FLUSH = auto()           # Special event to process buffered narrative
    REQUEST_CLOSING_NARRATIVE = auto() # New: Event to trigger LLM call for closing combat summary
    TURN_ORDER_UPDATE = auto()      # New: Event to update turn order displays
    COMBAT_LOG_SET_HTML = auto()    # New: Directly set Combat Log HTML (rehydration)
    APPLY_ENTITY_RESOURCE_UPDATE = auto()  # New: Apply a resource (hp/mp/stamina) change to an entity's model
    APPLY_ENTITY_STATE_UPDATE = auto()     # New: Apply state flags (e.g., is_active_in_combat)
    # Add more event types as needed
    
class DisplayTarget(Enum):
    """Specifies where the display event should be primarily rendered."""
    COMBAT_LOG = auto()
    MAIN_GAME_OUTPUT = auto()
    # UI_ELEMENT (for direct UI manipulations not via text, like bar animations) - handled by metadata for now

@dataclass
class DisplayEvent:
    """
    Represents a piece of information to be displayed to the player,
    managed by the CombatOutputOrchestrator.
    """
    type: DisplayEventType
    content: Union[str, List[str], Dict[str, Any]] # Text, list of texts (for buffer), or data for UI updates
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    role: Optional[str] = "system" # Default role for MainWindow._handle_game_output
    target_display: DisplayTarget = DisplayTarget.COMBAT_LOG
    gradual_visual_display: bool = False # Hint for UI on how to display text
    tts_eligible: bool = False # Whether this content should be spoken by TTS
    source_step: Optional[str] = None # For debugging, e.g., CombatManager's current_step.name
    metadata: Optional[Dict[str, Any]] = None # For UI_BAR_UPDATE, VISUAL_EFFECT, etc.

    def __str__(self):
        content_str = ""
        if isinstance(self.content, list):
            content_str = f"[{len(self.content)} items]"
        elif isinstance(self.content, dict):
            content_str = f"{ {k: str(v)[:20] + '...' if len(str(v)) > 20 else str(v) for k, v in self.content.items()} }"
        else:
            content_str = str(self.content)[:50] + ('...' if len(str(self.content)) > 50 else '')

        return (f"DisplayEvent(id={self.event_id}, type={self.type.name}, target={self.target_display.name}, "
                f"tts={self.tts_eligible}, gradual={self.gradual_visual_display}, content='{content_str}')")
```

### File: world_configurator\validators\origins_quests_validator.py

```python
#!/usr/bin/env python3
"""
Validate world config data: ensure Origins.initial_quests reference valid quest IDs
and report duplicates.

Usage (module import): call validate(origins: dict, quests: dict) -> dict with results.
This module is used by the World Configurator or CI checks.
"""
from __future__ import annotations
from typing import Dict, List, Any


def _as_str_list(value: Any) -> List[str]:
    out: List[str] = []
    if isinstance(value, list):
        for el in value:
            if isinstance(el, str) and el.strip():
                out.append(el.strip())
            elif isinstance(el, dict):
                vid = el.get("id")
                if isinstance(vid, str) and vid.strip():
                    out.append(vid.strip())
    return out


def validate(origins: Dict[str, Any], quests: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validate initial_quests across all origins.

    Returns a report dict with keys:
    - ok: bool
    - issues: List[str]
    - stats: dict
    """
    issues: List[str] = []
    quest_ids = set(quests.keys()) if isinstance(quests, dict) else set()

    total_refs = 0
    invalid_refs = 0
    duplicates = 0

    if not isinstance(origins, dict):
        return {"ok": False, "issues": ["origins is not a dict"], "stats": {}}

    for oid, odata in origins.items():
        init = _as_str_list(odata.get("initial_quests", []))
        total_refs += len(init)
        seen = set()
        for qid in init:
            if qid in seen:
                duplicates += 1
                issues.append(f"Origin '{oid}': duplicate quest id '{qid}' in initial_quests")
            else:
                seen.add(qid)
            if qid not in quest_ids:
                invalid_refs += 1
                issues.append(f"Origin '{oid}': unknown quest id '{qid}' in initial_quests")

    ok = (invalid_refs == 0)
    return {
        "ok": ok,
        "issues": issues,
        "stats": {
            "total_refs": total_refs,
            "invalid_refs": invalid_refs,
            "duplicates": duplicates,
        },
    }


```

### File: world_configurator\__init__.py

```python
"""
World Configurator Tool Package.
"""

```

### File: main.py

```python
#!/usr/bin/env python3
"""
Main entry point for the RPG game.
This script handles initialization and startup of the game in GUI mode.
"""

import sys
import argparse
import logging
from dotenv import load_dotenv # Import load_dotenv

# Import module initializer
from core.base.init_modules import init_modules
# Use centralized logging config
from core.utils.logging_config import setup_logging as core_setup_logging

# Application version
VERSION = "0.1.0"

def setup_logging():
    """Set up logging using the centralized project configuration."""
    core_setup_logging()

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="RPG Game")
    parser.add_argument("--version", action="version", version=f"RPG Game v{VERSION}")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    
    return parser.parse_args()

def main():
    """Main entry point for the game."""
    load_dotenv() # Load environment variables from .env file
    # Parse command line arguments
    args = parse_arguments()
    
    # Set up logging
    setup_logging()
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Log startup information
    logging.info(f"Starting RPG Game v{VERSION}")
    
    # Initialize all game modules
    init_modules()
    
    # GUI mode
    logging.info("Running in GUI mode")
    try:
        # Import the GUI runner
        from run_gui import run_gui
        run_gui()
    except ImportError as e:
        logging.error(f"Failed to import GUI components: {e}")
        print("Error: Could not start GUI mode. See log for details.")
        sys.exit(1)
    except Exception as e:
        logging.exception(f"Error starting GUI: {e}")
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### File: world_configurator\main.py

```python
#!/usr/bin/env python
"""
World Configurator Tool for the RPG Project.

This tool allows creating and editing world configuration for the RPG game.
"""

import os
import sys
import logging

# Add the project root to the Python path so we can use absolute imports
project_root = os.path.dirname(os.path.abspath(__file__))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from PySide6.QtWidgets import QApplication

from ui.main_window import MainWindow
from utils.logging_setup import setup_logging

def main():
    """
    Main entry point for the World Configurator Tool.
    """
    # Setup logging
    setup_logging()
    logger = logging.getLogger("world_configurator")
    logger.info("Starting World Configurator Tool")
    
    # Create application
    app = QApplication(sys.argv)
    app.setApplicationName("World Configurator")
    app.setApplicationVersion("1.0.0")
    
    # Create main window
    window = MainWindow()
    window.show()
    
    # Run application
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

```

### File: core\stats\__init__.py

```python
"""
Stats module for the RPG game.

This module contains classes and functions for managing character statistics, 
modifiers, and derived attributes.
"""

from core.stats.stats_base import (
    StatType, DerivedStatType, Stat, StatCategory
)
from core.stats.derived_stats import calculate_derived_stat
from core.stats.stats_manager import StatsManager
from core.stats.modifier import ModifierType, ModifierSource, StatModifier
from core.stats.modifier_manager import ModifierManager

```

### File: core\stats\combat_effects.py

```python
"""
System for managing combat-related stat modifiers and status effects.
"""

from enum import Enum, auto
from typing import Dict, List, Any, Optional, Union, Set
import logging
import uuid

from core.stats.stats_base import StatType, DerivedStatType
from core.stats.modifier import StatModifier, ModifierGroup, ModifierType, ModifierSource


logger = logging.getLogger(__name__)


class StatusEffectType(Enum):
    """Types of status effects that can affect a character."""
    BUFF = auto()        # Positive effect
    DEBUFF = auto()      # Negative effect
    CROWD_CONTROL = auto()  # Control effect (stun, slow, etc.)
    DAMAGE_OVER_TIME = auto()  # Damage over time (poison, bleeding, etc.)
    SPECIAL = auto()     # Special effect with unique mechanics


class StatusEffect:
    """
    A status effect that can be applied to a character.
    Includes common game effects like poison, stun, etc.
    """
    
    def __init__(
        self,
        name: str,
        description: str,
        effect_type: StatusEffectType,
        duration: int,
        modifier_group: Optional[ModifierGroup] = None,
        buff_is_visible: bool = True,
        custom_data: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a status effect.
        
        Args:
            name: The display name of the effect
            description: A description of what the effect does
            effect_type: The type of effect
            duration: How many turns the effect lasts
            modifier_group: Optional group of stat modifiers for this effect
            buff_is_visible: Whether this effect should be visible to the player
            custom_data: Additional custom data for unique effects
        """
        self.name = name
        self.description = description
        self.effect_type = effect_type
        self.duration = duration
        self.modifier_group = modifier_group
        self.buff_is_visible = buff_is_visible
        self.custom_data = custom_data or {}
        self.id = str(uuid.uuid4())
    
    def update_duration(self) -> bool:
        """
        Update the duration of the effect.
        Returns True if the effect is still active, False if expired.
        """
        if self.duration <= 0:
            return False
        
        self.duration -= 1
        if self.modifier_group:
            self.modifier_group.update_duration()
        
        return self.duration > 0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "effect_type": self.effect_type.name,
            "duration": self.duration,
            "modifier_group": self.modifier_group.to_dict() if self.modifier_group else None,
            "buff_is_visible": self.buff_is_visible,
            "custom_data": self.custom_data
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StatusEffect':
        """Create a StatusEffect from a dictionary."""
        effect = cls(
            name=data["name"],
            description=data["description"],
            effect_type=StatusEffectType[data["effect_type"]],
            duration=data["duration"],
            modifier_group=ModifierGroup.from_dict(data["modifier_group"]) if data.get("modifier_group") else None,
            buff_is_visible=data.get("buff_is_visible", True),
            custom_data=data.get("custom_data", {})
        )
        effect.id = data.get("id", effect.id)
        return effect


class StatusEffectManager:
    """
    Manages status effects for a character, including applying, updating,
    and removing effects.
    """
    
    def __init__(self, stats_manager=None):
        """
        Initialize the status effect manager.
        
        Args:
            stats_manager: Optional reference to the character's stats manager
        """
        self.stats_manager = stats_manager
        self.active_effects: Dict[str, StatusEffect] = {}
    
    def add_effect(self, effect: StatusEffect) -> None:
        """
        Add a status effect to the character.
        
        Args:
            effect: The effect to add
        """
        # Skip effects with duration <= 0
        if effect.duration <= 0:
            return
        
        # Check for an existing effect with the same name
        for existing_id, existing_effect in self.active_effects.items():
            if existing_effect.name == effect.name:
                # Replace the existing effect
                self.remove_effect(existing_id)
                break
        
        # Add the effect
        self.active_effects[effect.id] = effect
        
        # Apply the stat modifiers if we have a stats manager
        if self.stats_manager and effect.modifier_group:
            self.stats_manager.add_modifier_group(effect.modifier_group)
        
        logger.debug(f"Added status effect: {effect.name} (Duration: {effect.duration})")
    
    def remove_effect(self, effect_id: str) -> bool:
        """
        Remove a status effect by ID.
        
        Args:
            effect_id: The ID of the effect to remove
            
        Returns:
            True if the effect was found and removed, False otherwise
        """
        if effect_id not in self.active_effects:
            return False
        
        effect = self.active_effects[effect_id]
        
        # Remove the stat modifiers if we have a stats manager
        if self.stats_manager and effect.modifier_group:
            self.stats_manager.remove_modifier_group(effect.modifier_group.id)
        
        # Remove the effect
        del self.active_effects[effect_id]
        logger.debug(f"Removed status effect: {effect.name}")
        
        return True
    
    def remove_effects_by_name(self, name: str) -> int:
        """
        Remove all effects with a specific name.
        
        Args:
            name: The name of the effects to remove
            
        Returns:
            The number of effects removed
        """
        effect_ids = [e_id for e_id, effect in self.active_effects.items() if effect.name == name]
        for effect_id in effect_ids:
            self.remove_effect(effect_id)
        return len(effect_ids)
    
    def remove_effects_by_type(self, effect_type: StatusEffectType) -> int:
        """
        Remove all effects of a specific type.
        
        Args:
            effect_type: The type of effects to remove
            
        Returns:
            The number of effects removed
        """
        effect_ids = [e_id for e_id, effect in self.active_effects.items() if effect.effect_type == effect_type]
        for effect_id in effect_ids:
            self.remove_effect(effect_id)
        return len(effect_ids)
    
    def clear_all_effects(self) -> int:
        """
        Remove all active effects.
        
        Returns:
            The number of effects removed
        """
        count = len(self.active_effects)
        effect_ids = list(self.active_effects.keys())
        for effect_id in effect_ids:
            self.remove_effect(effect_id)
        return count
    
    def update_durations(self) -> Set[str]:
        """
        Update durations for all active effects.
        Removes expired effects.
        
        Returns:
            Set of IDs of expired effects that were removed
        """
        expired_ids = set()
        for effect_id, effect in list(self.active_effects.items()):
            if not effect.update_duration():
                self.remove_effect(effect_id)
                expired_ids.add(effect_id)
        
        if expired_ids:
            logger.debug(f"Removed {len(expired_ids)} expired status effects")
        
        return expired_ids
    
    def get_effect_by_id(self, effect_id: str) -> Optional[StatusEffect]:
        """
        Get a status effect by ID.
        
        Args:
            effect_id: The ID of the effect to get
            
        Returns:
            The effect if found, None otherwise
        """
        return self.active_effects.get(effect_id)
    
    def get_effects_by_name(self, name: str) -> List[StatusEffect]:
        """
        Get all effects with a specific name.
        
        Args:
            name: The name of the effects to get
            
        Returns:
            List of matching effects
        """
        return [effect for effect in self.active_effects.values() if effect.name == name]
    
    def get_effects_by_type(self, effect_type: StatusEffectType) -> List[StatusEffect]:
        """
        Get all effects of a specific type.
        
        Args:
            effect_type: The type of effects to get
            
        Returns:
            List of matching effects
        """
        return [effect for effect in self.active_effects.values() if effect.effect_type == effect_type]
    
    def has_effect(self, name: str) -> bool:
        """
        Check if the character has a specific effect.
        
        Args:
            name: The name of the effect to check for
            
        Returns:
            True if the effect is active, False otherwise
        """
        return any(effect.name == name for effect in self.active_effects.values())
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "active_effects": {e_id: effect.to_dict() for e_id, effect in self.active_effects.items()}
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any], stats_manager=None) -> 'StatusEffectManager':
        """Create a StatusEffectManager from a dictionary."""
        manager = cls(stats_manager)
        
        # Load active effects
        for effect_id, effect_data in data.get("active_effects", {}).items():
            effect = StatusEffect.from_dict(effect_data)
            manager.active_effects[effect_id] = effect
            
            # Apply the stat modifiers if we have a stats manager
            if stats_manager and effect.modifier_group:
                stats_manager.add_modifier_group(effect.modifier_group)
        
        return manager


# Common status effect factory methods
def create_poison_effect(potency: int = 1, duration: int = 3) -> StatusEffect:
    """Create a poison effect."""
    modifier_group = ModifierGroup(
        name="Poison",
        source_type=ModifierSource.CONDITION,
        modifier_type=ModifierType.TEMPORARY,
        duration=duration,
        description=f"Poison dealing {potency} damage per turn"
    )
    
    # Poison reduces CON and deals damage over time
    modifier_group.add_modifier(
        stat=StatType.CONSTITUTION,
        value=-potency,
        is_percentage=False,
        description="Poison weakens your constitution"
    )
    
    return StatusEffect(
        name="Poison",
        description=f"Taking {potency} damage per turn and suffering reduced constitution",
        effect_type=StatusEffectType.DAMAGE_OVER_TIME,
        duration=duration,
        modifier_group=modifier_group,
        custom_data={"damage_per_turn": potency}
    )


def create_stun_effect(duration: int = 1) -> StatusEffect:
    """Create a stun effect."""
    modifier_group = ModifierGroup(
        name="Stunned",
        source_type=ModifierSource.CONDITION,
        modifier_type=ModifierType.TEMPORARY,
        duration=duration,
        description="Stunned and unable to act"
    )
    
    # Stunned characters have severely reduced stats
    modifier_group.add_modifier(
        stat=DerivedStatType.INITIATIVE,
        value=-100,
        is_percentage=False,
        description="Stunned characters cannot act"
    )
    
    return StatusEffect(
        name="Stunned",
        description="Unable to take actions",
        effect_type=StatusEffectType.CROWD_CONTROL,
        duration=duration,
        modifier_group=modifier_group,
        custom_data={"can_act": False}
    )


def create_berserk_effect(duration: int = 3) -> StatusEffect:
    """Create a berserk effect."""
    modifier_group = ModifierGroup(
        name="Berserk",
        source_type=ModifierSource.CONDITION,
        modifier_type=ModifierType.TEMPORARY,
        duration=duration,
        description="Increased damage but reduced defense"
    )
    
    # Berserk increases strength but reduces defense
    modifier_group.add_modifier(
        stat=StatType.STRENGTH,
        value=4,
        is_percentage=False,
        description="Increased strength from berserk rage"
    )
    
    modifier_group.add_modifier(
        stat=DerivedStatType.DEFENSE,
        value=-2,
        is_percentage=False,
        description="Reduced defense from reckless attacks"
    )
    
    return StatusEffect(
        name="Berserk",
        description="Increased damage but reduced defense",
        effect_type=StatusEffectType.BUFF,
        duration=duration,
        modifier_group=modifier_group
    )


def create_regeneration_effect(amount: int = 2, duration: int = 5) -> StatusEffect:
    """Create a regeneration effect."""
    modifier_group = ModifierGroup(
        name="Regeneration",
        source_type=ModifierSource.CONDITION,
        modifier_type=ModifierType.TEMPORARY,
        duration=duration,
        description=f"Regenerating {amount} health per turn"
    )
    
    # No stat modifiers for regeneration, it's handled by the custom data
    
    return StatusEffect(
        name="Regeneration",
        description=f"Regenerating {amount} health per turn",
        effect_type=StatusEffectType.BUFF,
        duration=duration,
        modifier_group=modifier_group,
        custom_data={"heal_per_turn": amount}
    )

```

### File: core\stats\derived_stats.py

```python
"""
Functions for calculating derived stats based on primary stats.
"""

import logging
from typing import Dict, Any, Optional, Union, Callable
import math

from core.stats.stats_base import StatType, DerivedStatType, Stat, StatCategory

logger = logging.getLogger("STATS")

def get_modifier_from_stat(stat_value: float) -> int:
    """
    Calculate the standard D&D-style modifier from a stat value.
    Formula: (stat - 10) / 2, rounded down.
    """
    return math.floor((stat_value - 10) / 2)


def calculate_max_health(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate maximum health points based on Constitution, level, and class."""
    base_hp = config.get("base_health", 10.0) # Ensure float
    con_mod = get_modifier_from_stat(stats[StatType.CONSTITUTION].value)
    per_level_hp = config.get("hp_per_level", 5.0) # Ensure float
    
    calculated_hp = 0.0
    if level == 1:
        calculated_hp = base_hp + con_mod
    else:
        calculated_hp = base_hp + con_mod + (per_level_hp + con_mod) * (level - 1)
    
    return max(1.0, float(calculated_hp))

def calculate_mana(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate maximum mana points based on Intelligence, Wisdom, and level."""
    base_mana = config.get("base_mana", 5.0) # Ensure float
    int_mod = get_modifier_from_stat(stats[StatType.INTELLIGENCE].value)
    wis_mod = get_modifier_from_stat(stats[StatType.WISDOM].value)
    per_level_mana = config.get("mana_per_level", 3.0) # Ensure float
    
    calculated_mana = base_mana + int_mod + wis_mod + (per_level_mana + int_mod) * (level - 1)
    return max(0.0, float(calculated_mana)) 

def calculate_stamina(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate maximum stamina based on Constitution, Strength, and level."""
    base_stamina = config.get("base_stamina", 10.0) # Ensure float
    con_mod = get_modifier_from_stat(stats[StatType.CONSTITUTION].value)
    str_mod = get_modifier_from_stat(stats[StatType.STRENGTH].value)
    per_level_stamina = config.get("stamina_per_level", 2.0) # Ensure float
    
    # Ensure result is at least 1, even with negative modifiers at level 1
    calculated_stamina = base_stamina + con_mod + (per_level_stamina + math.floor(str_mod / 2)) * level
    return max(1.0, float(calculated_stamina)) # Return float, min 1.0

def calculate_initiative(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate initiative based on Dexterity and Wisdom."""
    dex_mod = get_modifier_from_stat(stats[StatType.DEXTERITY].value)
    wis_mod = get_modifier_from_stat(stats[StatType.WISDOM].value)
    
    return dex_mod + math.floor(wis_mod / 2)


def calculate_carry_capacity(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate carrying capacity based on Strength."""
    base_capacity = config.get("base_carry_capacity", 50)
    str_value = stats[StatType.STRENGTH].value
    multiplier = config.get("carry_capacity_multiplier", 5)
    
    return base_capacity + (str_value * multiplier)


def calculate_melee_attack(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate melee attack bonus based on Strength and level."""
    str_mod = get_modifier_from_stat(stats[StatType.STRENGTH].value)
    proficiency = math.ceil(level / 4) + 1  # Simple proficiency bonus based on level
    
    return str_mod + proficiency


def calculate_ranged_attack(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate ranged attack bonus based on Dexterity and level."""
    dex_mod = get_modifier_from_stat(stats[StatType.DEXTERITY].value)
    proficiency = math.ceil(level / 4) + 1  # Simple proficiency bonus based on level
    
    return dex_mod + proficiency


def calculate_magic_attack(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate magic attack bonus based on Intelligence and level."""
    int_mod = get_modifier_from_stat(stats[StatType.INTELLIGENCE].value)
    proficiency = math.ceil(level / 4) + 1  # Simple proficiency bonus based on level
    
    return int_mod + proficiency


def calculate_defense(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate physical defense based on Constitution and Dexterity."""
    base_defense = config.get("base_defense", 10)
    con_mod = get_modifier_from_stat(stats[StatType.CONSTITUTION].value)
    dex_mod = get_modifier_from_stat(stats[StatType.DEXTERITY].value)
    
    # Cap the Dex modifier contribution to defense (if wearing heavy armor, etc.)
    max_dex_mod = config.get("max_dex_mod_to_defense", 5)
    dex_contribution = min(dex_mod, max_dex_mod)
    
    return base_defense + con_mod + dex_contribution


def calculate_magic_defense(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate magic defense based on Wisdom and Intelligence."""
    base_magic_defense = config.get("base_magic_defense", 10)
    wis_mod = get_modifier_from_stat(stats[StatType.WISDOM].value)
    int_mod = get_modifier_from_stat(stats[StatType.INTELLIGENCE].value)
    
    return base_magic_defense + wis_mod + math.floor(int_mod / 2)


def calculate_movement(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate movement speed based on Dexterity."""
    base_movement = config.get("base_movement", 30)
    dex_mod = get_modifier_from_stat(stats[StatType.DEXTERITY].value)
    
    # Movement speed increases with Dex, but with diminishing returns
    if dex_mod <= 0:
        return max(base_movement + dex_mod, 15)  # Minimum movement speed
    else:
        return base_movement + math.floor(math.sqrt(dex_mod) * 5)


def calculate_max_resolve(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate maximum social/mental resolve based on Willpower, Insight, and level."""
    base_resolve = config.get("base_resolve", 10)
    wil_mod = get_modifier_from_stat(stats[StatType.WILLPOWER].value)
    ins_mod = get_modifier_from_stat(stats[StatType.INSIGHT].value) # Changed from CHARISMA to INSIGHT
    per_level_resolve = config.get("resolve_per_level", 3)

    # Similar structure to HP/Mana calculation
    if level == 1:
        return base_resolve + wil_mod + ins_mod

    return base_resolve + wil_mod + ins_mod + (per_level_resolve + wil_mod) * (level - 1)


def calculate_damage_reduction(stats: Dict[Union[StatType, str], Stat], level: int, config: Dict[str, Any]) -> float:
    """Calculate base flat damage reduction based on Constitution."""
    # --- Future DR Integration Points ---
    # 1. Equipment Modifiers: Add logic here or preferably within StatsManager
    #    to sum DR bonuses from equipped items (armor, shields, amulets).
    #    Example: total_dr += stats_manager.get_equipment_modifier(DerivedStatType.DAMAGE_REDUCTION)
    # 2. Status Effect Modifiers: Apply DR from buffs/debuffs via ModifierManager.
    #    The get_stat_value in StatsManager should automatically include these if
    #    DAMAGE_REDUCTION is treated like other stats.
    # 3. Class/Race Features: Apply permanent DR bonuses via modifiers loaded
    #    from class/race configs.
    # ----------------------------------

    base_dr = float(config.get("base_damage_reduction", 0.0))
    # Add a small bonus from CON modifier (example)
    con_stat = stats.get(StatType.CONSTITUTION)
    if con_stat:
        con_mod = get_modifier_from_stat(con_stat.value)
        # Example: +1 DR for every 4 points of CON modifier, minimum 0
        base_dr += max(0, math.floor(con_mod / 4))
    else:
        logger.warning("Constitution stat not found for DR calculation.")

    return base_dr


# Mapping of derived stat types to their calculation functions
DERIVED_STAT_CALCULATORS: Dict[DerivedStatType, Callable] = {
    DerivedStatType.MAX_HEALTH: calculate_max_health,
    DerivedStatType.MAX_RESOLVE: calculate_max_resolve,
    DerivedStatType.MAX_MANA: calculate_mana,
    DerivedStatType.MAX_STAMINA: calculate_stamina,
    DerivedStatType.INITIATIVE: calculate_initiative,
    DerivedStatType.CARRY_CAPACITY: calculate_carry_capacity,
    DerivedStatType.MELEE_ATTACK: calculate_melee_attack,
    DerivedStatType.RANGED_ATTACK: calculate_ranged_attack,
    DerivedStatType.MAGIC_ATTACK: calculate_magic_attack,
    DerivedStatType.DEFENSE: calculate_defense,
    DerivedStatType.MAGIC_DEFENSE: calculate_magic_defense,
    DerivedStatType.MOVEMENT: calculate_movement,
    DerivedStatType.DAMAGE_REDUCTION: calculate_damage_reduction,
}


def calculate_derived_stat(
    stat_type: DerivedStatType,
    stats: Dict[Union[StatType, str], Stat],
    level: int,
    config: Optional[Dict[str, Any]] = None
) -> float:
    """Calculate a derived stat based on primary stats and level."""
    if config is None:
        config = {}
    
    calculator = DERIVED_STAT_CALCULATORS.get(stat_type)
    if not calculator:
        raise ValueError(f"No calculator defined for derived stat {stat_type}")
    
    return calculator(stats, level, config)

```

### File: core\stats\enums.py

```python
#!/usr/bin/env python3
"""
Enumeration types for the stats system.

This module re-exports the enum types from stats_base.py for better organization
and maintains backward compatibility with existing imports.
"""

from core.stats.stats_base import StatCategory, StatType, DerivedStatType, Skill

# Re-export all enum types for backward compatibility
__all__ = ['StatCategory', 'StatType', 'DerivedStatType', 'Skill']

```

### File: core\stats\modifier.py

```python
"""
Classes for handling stat modifiers from various sources.
"""

from enum import Enum, auto
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, Union, List
import uuid

from core.stats.stats_base import StatType, DerivedStatType


class ModifierType(Enum):
    """Types of modifiers based on their duration."""
    PERMANENT = auto()       # Permanent bonus (race, class, etc.)
    SEMI_PERMANENT = auto()  # Long-term but not permanent (disease, training)
    TEMPORARY = auto()       # Short-term effect (spell, potion, etc.)


class ModifierSource(Enum):
    """Sources of stat modifiers."""
    RACIAL = auto()          # Inherent racial bonus
    CLASS = auto()           # Class feature
    BACKGROUND = auto()      # Character background
    EQUIPMENT = auto()       # From equipped items
    SPELL = auto()           # Magical effect
    POTION = auto()          # Consumable effect
    CONDITION = auto()       # Status effect (poisoned, blessed, etc.)
    ENVIRONMENT = auto()     # Location-based effect
    TRAINING = auto()        # Skill improvement
    LEVEL_UP = auto()        # Stat increase from leveling
    NARRATIVE = auto()       # Story-driven effect
    OTHER = auto()           # Miscellaneous source


@dataclass
class StatModifier:
    """
    A modifier that affects a character stat.
    
    Attributes:
        id: Unique identifier for the modifier
        stat: The stat being modified
        value: The value of the modification
        source_type: The type of source (equipment, spell, etc.)
        source_name: Specific name of the source
        modifier_type: Duration category (permanent, temporary, etc.)
        is_percentage: Whether the value is a percentage or flat bonus
        duration: Number of turns or time remaining (None for permanent)
        stacks: Whether this modifier stacks with others from same source
        description: Human-readable description of the effect
    """
    stat: Union[StatType, DerivedStatType, str]
    value: float
    source_type: ModifierSource
    source_name: str
    modifier_type: ModifierType
    is_percentage: bool = False
    duration: Optional[int] = None  # None means permanent
    stacks: bool = False
    description: str = ""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    
    def __str__(self) -> str:
        """Human-readable representation."""
        prefix = "+" if self.value > 0 else ""
        suffix = "%" if self.is_percentage else ""
        duration_str = f" ({self.duration} turns)" if self.duration else ""
        return f"{self.source_name}: {prefix}{self.value}{suffix} to {self.stat}{duration_str}"
    
    def update_duration(self) -> bool:
        """
        Decrement the duration by 1 if it exists.
        Returns True if the modifier is still active, False if expired.
        """
        if self.duration is None:  # Permanent modifier
            return True
        
        if self.duration > 0:
            self.duration -= 1
            return True
        
        return False  # Expired
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "id": self.id,
            "stat": str(self.stat),
            "value": self.value,
            "source_type": self.source_type.name,
            "source_name": self.source_name,
            "modifier_type": self.modifier_type.name,
            "is_percentage": self.is_percentage,
            "duration": self.duration,
            "stacks": self.stacks,
            "description": self.description
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StatModifier':
        """Create a StatModifier from a dictionary."""
        try:
            # Try to convert stat to StatType
            stat = StatType.from_string(data["stat"])
        except ValueError:
            try:
                # Try to convert stat to DerivedStatType
                stat = DerivedStatType.from_string(data["stat"])
            except ValueError:
                # Just use the string name
                stat = data["stat"]
        
        return cls(
            id=data.get("id", str(uuid.uuid4())),
            stat=stat,
            value=data["value"],
            source_type=ModifierSource[data["source_type"]],
            source_name=data["source_name"],
            modifier_type=ModifierType[data["modifier_type"]],
            is_percentage=data["is_percentage"],
            duration=data["duration"],
            stacks=data.get("stacks", False),
            description=data.get("description", "")
        )


@dataclass
class ModifierGroup:
    """
    A group of related modifiers that are applied together.
    For example, all modifiers from a single buff spell or equipment item.
    """
    name: str
    source_type: ModifierSource
    modifier_type: ModifierType
    duration: Optional[int] = None
    modifiers: List[StatModifier] = field(default_factory=list)
    description: str = ""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    
    def add_modifier(self, stat: Union[StatType, DerivedStatType, str], value: float, 
                    is_percentage: bool = False, stacks: bool = False, 
                    description: str = "") -> None:
        """Add a new modifier to this group."""
        modifier = StatModifier(
            stat=stat,
            value=value,
            source_type=self.source_type,
            source_name=self.name,
            modifier_type=self.modifier_type,
            is_percentage=is_percentage,
            duration=self.duration,
            stacks=stacks,
            description=description
        )
        self.modifiers.append(modifier)
    
    def update_duration(self) -> bool:
        """
        Update the duration of all modifiers in the group.
        Returns True if at least one modifier is still active.
        """
        if self.duration is None:  # Permanent group
            return True
        
        if self.duration > 0:
            self.duration -= 1
            # Update all modifiers' durations
            for mod in self.modifiers:
                mod.duration = self.duration
            return True
        
        return False  # All expired
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "id": self.id,
            "name": self.name,
            "source_type": self.source_type.name,
            "modifier_type": self.modifier_type.name,
            "duration": self.duration,
            "modifiers": [mod.to_dict() for mod in self.modifiers],
            "description": self.description
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ModifierGroup':
        """Create a ModifierGroup from a dictionary."""
        group = cls(
            id=data.get("id", str(uuid.uuid4())),
            name=data["name"],
            source_type=ModifierSource[data["source_type"]],
            modifier_type=ModifierType[data["modifier_type"]],
            duration=data["duration"],
            description=data.get("description", "")
        )
        
        # Add modifiers
        for mod_data in data.get("modifiers", []):
            group.modifiers.append(StatModifier.from_dict(mod_data))
        
        return group

```

### File: core\stats\modifier_manager.py

```python
"""
Manager for handling stat modifiers.
"""

from typing import Dict, List, Set, Optional, Union, Any
import logging

from core.stats.stats_base import StatType, DerivedStatType
from core.stats.modifier import StatModifier, ModifierGroup, ModifierType, ModifierSource


logger = logging.getLogger(__name__)


class ModifierManager:
    """
    Manages all stat modifiers for a character.
    """
    
    def __init__(self):
        """Initialize the modifier manager."""
        self.modifiers: List[StatModifier] = []
        self.modifier_groups: List[ModifierGroup] = []
    
    def add_modifier(self, modifier: StatModifier) -> None:
        """
        Add a single modifier.
        
        Args:
            modifier: The modifier to add.
        """
        # Check for non-stacking modifiers from the same source
        if not modifier.stacks:
            # Remove any existing non-stacking modifiers to the same stat from the same source
            self.modifiers = [
                m for m in self.modifiers 
                if not (m.stat == modifier.stat and 
                       m.source_name == modifier.source_name and 
                       not m.stacks)
            ]
        
        self.modifiers.append(modifier)
        logger.debug(f"Added modifier: {modifier}")
    
    def add_modifier_group(self, group: ModifierGroup) -> None:
        """
        Add a group of modifiers.
        
        Args:
            group: The modifier group to add.
        """
        # First add the group to our tracking
        self.modifier_groups.append(group)
        
        # Then add all modifiers from the group
        for modifier in group.modifiers:
            self.add_modifier(modifier)
        
        logger.debug(f"Added modifier group: {group.name} with {len(group.modifiers)} modifiers")
    
    def remove_modifier(self, modifier_id: str) -> bool:
        """
        Remove a specific modifier by its ID.
        
        Args:
            modifier_id: The unique ID of the modifier to remove.
            
        Returns:
            bool: True if the modifier was found and removed, False otherwise.
        """
        original_length = len(self.modifiers)
        self.modifiers = [m for m in self.modifiers if m.id != modifier_id]
        removed = len(self.modifiers) != original_length
        
        if removed:
            logger.debug(f"Removed modifier with ID: {modifier_id}")
        else:
            logger.debug(f"No modifier found with ID: {modifier_id}")
        
        return removed
    
    def remove_modifier_group(self, group_id: str) -> bool:
        """
        Remove a modifier group and all its modifiers.
        
        Args:
            group_id: The unique ID of the group to remove.
            
        Returns:
            bool: True if the group was found and removed, False otherwise.
        """
        # Find the group
        group = next((g for g in self.modifier_groups if g.id == group_id), None)
        if not group:
            logger.debug(f"No modifier group found with ID: {group_id}")
            return False
        
        # Remove all modifiers from the group
        for modifier in group.modifiers:
            self.remove_modifier(modifier.id)
        
        # Remove the group itself
        self.modifier_groups = [g for g in self.modifier_groups if g.id != group_id]
        logger.debug(f"Removed modifier group: {group.name}")
        
        return True
    
    def remove_modifiers_by_source(self, source_type: ModifierSource, source_name: Optional[str] = None) -> int:
        """
        Remove all modifiers from a specific source.
        
        Args:
            source_type: The type of source to remove modifiers from.
            source_name: Optional specific source name to match.
            
        Returns:
            int: The number of modifiers removed.
        """
        # Remove matching modifier groups
        groups_to_remove = []
        for group in self.modifier_groups:
            if group.source_type == source_type and (source_name is None or group.name == source_name):
                groups_to_remove.append(group.id)
        
        for group_id in groups_to_remove:
            self.remove_modifier_group(group_id)
        
        # Remove individual modifiers
        original_length = len(self.modifiers)
        self.modifiers = [
            m for m in self.modifiers 
            if not (m.source_type == source_type and 
                   (source_name is None or m.source_name == source_name))
        ]
        removed_count = original_length - len(self.modifiers)
        
        if removed_count > 0:
            source_desc = f"{source_type.name}"
            if source_name:
                source_desc += f" ({source_name})"
            logger.debug(f"Removed {removed_count} modifiers from source: {source_desc}")
        
        return removed_count
    
    def get_modifiers_for_stat(
        self, stat: Union[StatType, DerivedStatType, str]
    ) -> List[StatModifier]:
        """
        Get all modifiers affecting a specific stat.
        
        Args:
            stat: The stat to get modifiers for.
            
        Returns:
            List of modifiers affecting the stat.
        """
        return [m for m in self.modifiers if m.stat == stat]
    
    def get_stat_modifier_value(
        self, stat: Union[StatType, DerivedStatType, str]
    ) -> Dict[str, float]:
        """
        Calculate the total modifier value for a stat.
        
        Args:
            stat: The stat to calculate modifiers for.
            
        Returns:
            Dictionary with 'flat' and 'percentage' keys for the two types of modifiers.
        """
        flat_modifier = 0.0
        percentage_modifier = 0.0
        
        for modifier in self.get_modifiers_for_stat(stat):
            if modifier.is_percentage:
                percentage_modifier += modifier.value
            else:
                flat_modifier += modifier.value
        
        return {
            'flat': flat_modifier,
            'percentage': percentage_modifier
        }
    
    def update_durations(self) -> Set[str]:
        """
        Update durations for all temporary modifiers.
        Removes expired modifiers and groups.
        
        Returns:
            Set of IDs of expired modifiers that were removed.
        """
        expired_ids = set()
        
        # Update group durations first
        expired_groups = []
        for group in self.modifier_groups:
            if group.modifier_type != ModifierType.PERMANENT and not group.update_duration():
                expired_groups.append(group.id)
                # Add all modifiers from this group to expired list
                expired_ids.update(m.id for m in group.modifiers)
        
        # Remove expired groups
        for group_id in expired_groups:
            self.remove_modifier_group(group_id)
        
        # Update individual modifiers (not in groups)
        expired_individual = []
        for modifier in self.modifiers:
            if (modifier.modifier_type != ModifierType.PERMANENT and 
                modifier.duration is not None and 
                modifier.duration <= 0):
                expired_individual.append(modifier.id)
                expired_ids.add(modifier.id)
        
        # Remove expired individual modifiers
        for modifier_id in expired_individual:
            self.remove_modifier(modifier_id)
        
        if expired_ids:
            logger.debug(f"Removed {len(expired_ids)} expired modifiers")
        
        return expired_ids
    
    def clear_all_modifiers(self) -> None:
        """Remove all modifiers and groups."""
        self.modifiers.clear()
        self.modifier_groups.clear()
        logger.debug("Cleared all modifiers")
    
    def clear_temporary_modifiers(self) -> int:
        """
        Remove all temporary modifiers.
        
        Returns:
            int: Number of modifiers removed.
        """
        # Remove temporary groups
        temp_groups = [g.id for g in self.modifier_groups if g.modifier_type == ModifierType.TEMPORARY]
        for group_id in temp_groups:
            self.remove_modifier_group(group_id)
        
        # Remove individual temporary modifiers
        original_length = len(self.modifiers)
        self.modifiers = [m for m in self.modifiers if m.modifier_type != ModifierType.TEMPORARY]
        removed_count = original_length - len(self.modifiers)
        
        if removed_count > 0:
            logger.debug(f"Cleared {removed_count} temporary modifiers")
        
        return removed_count
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "modifiers": [m.to_dict() for m in self.modifiers],
            "modifier_groups": [g.to_dict() for g in self.modifier_groups]
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ModifierManager':
        """Create a ModifierManager from a dictionary."""
        manager = cls()
        
        # Load modifier groups first
        for group_data in data.get("modifier_groups", []):
            manager.modifier_groups.append(ModifierGroup.from_dict(group_data))
        
        # Load individual modifiers
        for modifier_data in data.get("modifiers", []):
            manager.modifiers.append(StatModifier.from_dict(modifier_data))
        
        return manager

```

### File: core\stats\skill_check.py

```python
"""
System for handling skill checks based on character stats with SkillManager integration.

This module provides functions and classes for performing skill checks,
calculating success chances, and processing check results.
"""

import random
import math
import logging
from typing import Dict, Any, Optional, Union, Tuple

from core.stats.stats_base import StatType, DerivedStatType

# Import skill manager only when needed to avoid circular imports
# The skill_manager module imports StatType from stats_base

logger = logging.getLogger(__name__)


def calculate_success_chance(
    stat_value: float,
    difficulty: int,
    advantage: bool = False,
    disadvantage: bool = False
) -> float:
    """
    Calculate the probability of success for a skill check.
    
    Args:
        stat_value: The value of the stat being checked
        difficulty: The difficulty class (DC) of the check
        advantage: Whether the check has advantage
        disadvantage: Whether the check has disadvantage
        
    Returns:
        Float between 0 and 1 representing the success probability
    """
    # Handle None stat value
    if stat_value is None:
        logger.warning("Stat value is None in calculate_success_chance. Using default value of 10.")
        stat_value = 10

    # Handle None difficulty
    if difficulty is None:
        logger.warning("Difficulty is None in calculate_success_chance. Using default value of 15.")
        difficulty = 15
        
    # Base formula: success if d20 + stat_modifier >= difficulty
    # stat_modifier = (stat_value - 10) / 2
    mod = math.floor((stat_value - 10) / 2)
    
    # Calculate success probability for a single roll
    success_threshold = difficulty - mod
    single_roll_chance = min(max((21 - success_threshold) / 20, 0), 1)
    
    # Apply advantage/disadvantage
    if advantage and disadvantage:
        # They cancel out
        return single_roll_chance
    elif advantage:
        # Advantage: chance of at least one success in two rolls
        return 1 - (1 - single_roll_chance) ** 2
    elif disadvantage:
        # Disadvantage: chance of success in both rolls
        return single_roll_chance ** 2
    else:
        return single_roll_chance


def perform_check(
    stat_value: float,
    difficulty: int,
    advantage: bool = False,
    disadvantage: bool = False,
    situational_modifier: int = 0
) -> Tuple[bool, int]:
    """
    Perform a skill check and determine success or failure.

    Args:
        stat_value: The value of the stat being checked
        difficulty: The difficulty class (DC) of the check
        advantage: Whether the check has advantage
        disadvantage: Whether the check has disadvantage
        situational_modifier: Any additional flat modifier applying to this specific check

    Returns:
        Tuple of (success, roll_result)
    """
    # Handle None stat value
    if stat_value is None:
        logger.warning("Stat value is None in perform_check. Using default value of 10.")
        stat_value = 10
        
    # Handle None difficulty - default to moderate difficulty (15)
    if difficulty is None:
        logger.warning("Difficulty is None in perform_check. Using default value of 15.")
        difficulty = 15
        
    # Calculate modifier
    mod = math.floor((stat_value - 10) / 2)
    
    # Handle advantage/disadvantage
    if advantage and disadvantage:
        # They cancel out
        roll = random.randint(1, 20)
    elif advantage:
        roll1 = random.randint(1, 20)
        roll2 = random.randint(1, 20)
        roll = max(roll1, roll2)
    elif disadvantage:
        roll1 = random.randint(1, 20)
        roll2 = random.randint(1, 20)
        roll = min(roll1, roll2)
    else:
        roll = random.randint(1, 20)
    
    # Critical success always succeeds
    if roll == 20:
        return True, roll
    
    # Critical failure always fails
    if roll == 1:
        return False, roll
    
    # Normal check
    total = roll + mod
    total += situational_modifier
    success = total >= difficulty

    return success, roll


def get_difficulty_description(dc: int) -> str:
    """
    Get a descriptive label for a difficulty class.
    
    Args:
        dc: The difficulty class value
        
    Returns:
        A string describing the difficulty level
    """
    # Handle None dc
    if dc is None:
        logger.warning("DC is None in get_difficulty_description. Using default value of 15.")
        dc = 15
        
    if dc <= 5:
        return "Very Easy"
    elif dc <= 10:
        return "Easy"
    elif dc <= 15:
        return "Medium"
    elif dc <= 20:
        return "Hard"
    elif dc <= 25:
        return "Very Hard"
    elif dc <= 30:
        return "Nearly Impossible"
    else:
        return "Legendary"


def determine_outcome_description(
    success: bool,
    margin: int,
    critical: bool = False
) -> str:
    """
    Generate a description of the check outcome based on success and margin.
    
    Args:
        success: Whether the check succeeded
        margin: How much the check succeeded or failed by
        critical: Whether the roll was a critical success or failure
        
    Returns:
        A descriptive string of the outcome
    """
    if critical:
        if success:
            return "Spectacular Success"
        else:
            return "Spectacular Failure"
    
    if success:
        if margin >= 10:
            return "Exceptional Success"
        elif margin >= 5:
            return "Solid Success"
        else:
            return "Narrow Success"
    else:
        if margin >= 10:
            return "Catastrophic Failure"
        elif margin >= 5:
            return "Clear Failure"
        else:
            return "Near Miss"


class SkillCheckResult:
    """Class to hold the result of a skill check with detailed information."""
    
    def __init__(
        self,
        stat_type: Union[StatType, DerivedStatType, str],
        stat_value: float,
        difficulty: int,
        roll: int,
        modifier: int,
        success: bool,
        advantage: bool = False,
        disadvantage: bool = False,
        situational_modifier: int = 0,
        skill_name: Optional[str] = None,
        skill_exists: bool = True
    ):
        """Initialize the skill check result."""
        self.stat_type = stat_type
        self.skill_name = skill_name  # Optional name of the skill being used
        self.skill_exists = skill_exists  # Whether the skill exists in the system
        
        # Handle None stat_value
        if stat_value is None:
            logger.warning(f"Stat value is None for {skill_name or stat_type} check. Using default value of 10.")
            stat_value = 10
        self.stat_value = stat_value
        
        # Handle None difficulty
        if difficulty is None:
            logger.warning(f"Difficulty is None for {skill_name or stat_type} check. Using default value of 15.")
            difficulty = 15
        self.difficulty = difficulty
        
        self.roll = roll
        self.modifier = modifier
        self.situational_modifier = situational_modifier
        self.total = roll + modifier + situational_modifier # Apply situational modifier to final total
        self.success = success
        self.advantage = advantage
        self.disadvantage = disadvantage
        self.critical = (roll == 20 or roll == 1)

        # Recalculate margin based on final total and critical status
        # Handle criticals overriding success/failure for margin calculation
        effective_success = self.success if not self.critical else (self.roll == 20)
        self.margin = abs(self.total - self.difficulty) if effective_success == (self.total >= self.difficulty) else 0 # Margin is less meaningful on forced crit outcomes

        self.difficulty_desc = get_difficulty_description(difficulty)
        self.outcome_desc = determine_outcome_description(
            success, self.margin, self.critical
        )
    
    def __str__(self) -> str:
        """String representation of the result."""
        if not self.skill_exists and self.skill_name:
            return f"Invalid skill check: '{self.skill_name}' is not a valid skill."
            
        adv_str = ""
        if self.advantage and self.disadvantage:
            adv_str = " (with advantage and disadvantage, which cancel out)"
        elif self.advantage:
            adv_str = " (with advantage)"
        elif self.disadvantage:
            adv_str = " (with disadvantage)"

        # Use skill name if available, otherwise fall back to stat type
        check_name = self.skill_name if self.skill_name else str(self.stat_type)
            
        return (
            f"{check_name} Check ({self.difficulty_desc}, DC {self.difficulty}){adv_str}: " +
            f"Rolled {self.roll}" +
            f" + {self.modifier} (stat)" +
            (f" + {self.situational_modifier}" if self.situational_modifier > 0 else "") +
            (f" - {abs(self.situational_modifier)}" if self.situational_modifier < 0 else "") +
            (f" (situational)" if self.situational_modifier != 0 else "") +
            f" = {self.total} " +
            f"→ {self.outcome_desc}" +
            (f" (Crit!)" if self.critical else "")
        )

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        result = {
            "stat_type": str(self.stat_type),
            "stat_value": self.stat_value,
            "difficulty": self.difficulty,
            "difficulty_desc": self.difficulty_desc,
            "roll": self.roll,
            "modifier": self.modifier,
            "total": self.total,
            "success": self.success,
            "situational_modifier": self.situational_modifier,
            "advantage": self.advantage,
            "disadvantage": self.disadvantage,
            "critical": self.critical,
            "margin": self.margin,
            "outcome_desc": self.outcome_desc
        }
        
        # Add skill-related fields if available
        if self.skill_name:
            result["skill_name"] = self.skill_name
            result["skill_exists"] = self.skill_exists
            
        return result


def get_skill_manager():
    """Import and return the skill manager instance (avoiding circular imports)."""
    from core.stats.skill_manager import get_skill_manager as get_manager
    return get_manager()


def map_intent_to_skill(intent: str) -> Optional[str]:
    """Map a player's intent description to the most appropriate skill."""
    skill_manager = get_skill_manager()
    return skill_manager.find_closest_skill(intent)


def perform_skill_check_by_name(
    skill_name: str,
    difficulty: int,
    stats_manager,  # Will be properly typed when integrated
    advantage: bool = False,
    disadvantage: bool = False,
    situational_modifier: int = 0,
    character_id: Optional[str] = None
) -> SkillCheckResult:
    """Perform a skill check using a skill name instead of a stat type."""
    # Get skill manager instance
    skill_manager = get_skill_manager()
    
    # Check if the skill exists
    skill = None
    if character_id is not None:
        # Try character-specific skills first
        skill = skill_manager.get_character_skill(character_id, skill_name)
    
    if skill is None:
        # Try standard skills
        skill = skill_manager.get_skill(skill_name)
    
    if not skill:
        logger.error(f"Unknown skill: {skill_name}")
        # Return a failure result with skill_exists=False
        return SkillCheckResult(
            stat_type="Unknown",
            stat_value=10,  # Default value
            difficulty=difficulty or 15,
            roll=0,
            modifier=0,
            success=False,
            advantage=advantage,
            disadvantage=disadvantage,
            situational_modifier=situational_modifier,
            skill_name=skill_name,
            skill_exists=False
        )
    
    # Get the primary stat for this skill
    stat_type_str = skill.get("primary_stat", "STRENGTH")  # Default to STRENGTH if not specified
    
    try:
        # Try to convert to StatType enum
        from core.stats.stats_base import StatType
        stat_type = StatType.from_string(stat_type_str)
    except (ValueError, AttributeError):
        # If conversion fails, use the string as is
        stat_type = stat_type_str
        logger.warning(f"Could not convert '{stat_type_str}' to StatType, using as string")
    
    # Get the stat value from the stats manager
    try:
        stat_value = stats_manager.get_stat_value(stat_type)
    except (ValueError, AttributeError) as e:
        logger.error(f"Error getting stat value for {stat_type}: {e}")
        stat_value = None  # Will be handled in perform_check
    
    # Calculate the modifier for display
    try:
        if stat_value is None:
            mod = 0
        else:
            mod = math.floor((stat_value - 10) / 2)
    except Exception as e:
        logger.error(f"Error calculating modifier: {e}")
        mod = 0
    
    # Perform the check
    success, roll = perform_check(
        stat_value=stat_value,
        difficulty=difficulty,
        advantage=advantage,
        disadvantage=disadvantage,
        situational_modifier=situational_modifier
    )
    
    # Create and return the result object
    result = SkillCheckResult(
        stat_type=stat_type,
        stat_value=stat_value,
        difficulty=difficulty,
        roll=roll,
        modifier=mod,
        success=success,
        advantage=advantage,
        disadvantage=disadvantage,
        situational_modifier=situational_modifier,
        skill_name=skill["name"],  # Use the proper display name from the skill definition
        skill_exists=True
    )
    
    logger.debug(f"Skill check result: {result}")
    return result

```

### File: core\stats\skill_manager.py

```python
"""
Skill Manager for loading and managing skills from external JSON files.
"""

import os
import json
import time
import logging
from typing import Dict, Any, Optional, List, Set, Tuple

from core.stats.stats_base import StatType

logger = logging.getLogger(__name__)

class SkillManager:
    """
    Manages skills loaded from external definitions.
    
    This class handles loading skill definitions from JSON files,
    checking skill validity, and providing access to skill data.
    It also supports generating and managing custom skills.
    """
    
    def __init__(self, filepath="config/skills.json"):
        """Initialize the skill manager with skills from a JSON file."""
        self.skills = {}
        self.custom_skills = {}  # Character-specific custom skills
        self.load_skills(filepath)
        logger.info(f"SkillManager initialized with {len(self.skills)} skills")
    
    def load_skills(self, filepath: str) -> None:
        """
        Load skills from a JSON file.
        
        Args:
            filepath: Path to the skills JSON file.
        """
        try:
            full_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), filepath)
            with open(full_path, 'r') as f:
                data = json.load(f)
                self.skills = data.get("skills", {})
            logger.info(f"Successfully loaded {len(self.skills)} skills from {filepath}")
        except Exception as e:
            logger.error(f"Error loading skills from {filepath}: {e}")
            # Fall back to default skills if file can't be loaded
            self._load_default_skills()
    
    def _load_default_skills(self) -> None:
        """Load default skills if JSON fails."""
        # Hardcoded fallback skills
        self.skills = {
            "melee_attack": {
                "name": "Melee Attack",
                "primary_stat": "STRENGTH",
                "category": "COMBAT",
                "description": "Physical close-range combat attacks"
            },
            "ranged_attack": {
                "name": "Ranged Attack",
                "primary_stat": "DEXTERITY",
                "category": "COMBAT",
                "description": "Physical ranged combat attacks"
            },
            "dodge": {
                "name": "Dodge",
                "primary_stat": "DEXTERITY",
                "category": "COMBAT",
                "description": "Avoiding attacks and obstacles"
            }
        }
        logger.warning(f"Loaded {len(self.skills)} default skills as fallback")
    
    def get_skill(self, skill_name: str) -> Optional[Dict[str, Any]]:
        """
        Get a skill by name (case-insensitive).
        
        Args:
            skill_name: The name of the skill to get.
            
        Returns:
            The skill data if found, None otherwise.
        """
        if not skill_name:
            return None
            
        # Normalize the skill name: lowercase and replace spaces with underscores
        normalized_name = skill_name.lower().replace(" ", "_")
        
        # Check in standard skills
        if normalized_name in self.skills:
            return self.skills[normalized_name]
        
        # Check in all character custom skills
        for char_id, char_skills in self.custom_skills.items():
            if normalized_name in char_skills:
                return char_skills[normalized_name]
        
        # Check for partial matches
        for skill_id, skill in self.skills.items():
            if normalized_name in skill_id or normalized_name in skill['name'].lower():
                logger.debug(f"Partial match for '{skill_name}': found '{skill['name']}'")
                return skill
        
        # No match found
        logger.debug(f"No skill found for '{skill_name}'")
        return None
    
    def get_character_skill(self, character_id: str, skill_name: str) -> Optional[Dict[str, Any]]:
        """
        Get a character-specific skill by name.
        
        Args:
            character_id: The ID of the character.
            skill_name: The name of the skill to get.
            
        Returns:
            The skill data if found, None otherwise.
        """
        normalized_name = skill_name.lower().replace(" ", "_")
        
        # Check if this character has custom skills
        char_skills = self.custom_skills.get(character_id, {})
        
        # Try exact match first
        if normalized_name in char_skills:
            return char_skills[normalized_name]
        
        # Then try partial match
        for skill_id, skill in char_skills.items():
            if normalized_name in skill_id or normalized_name in skill['name'].lower():
                return skill
        
        # If not found in character skills, try standard skills
        return self.get_skill(skill_name)
    
    def is_valid_skill(self, skill_name: str) -> bool:
        """
        Check if a skill name is valid.
        
        Args:
            skill_name: The name of the skill to check.
            
        Returns:
            True if the skill is valid, False otherwise.
        """
        return self.get_skill(skill_name) is not None
    
    def get_all_skills(self) -> Dict[str, Dict[str, Any]]:
        """
        Get all skills.
        
        Returns:
            Dictionary of all skills.
        """
        return self.skills
    
    def get_skills_by_category(self, category: str) -> Dict[str, Dict[str, Any]]:
        """
        Get skills filtered by category.
        
        Args:
            category: The category to filter by.
            
        Returns:
            Dictionary of skills in the specified category.
        """
        result = {}
        for skill_id, skill in self.skills.items():
            if skill.get('category', '').upper() == category.upper():
                result[skill_id] = skill
        return result
    
    def get_character_skills(self, character_id: str) -> Dict[str, Dict[str, Any]]:
        """
        Get all custom skills for a character.
        
        Args:
            character_id: The ID of the character.
            
        Returns:
            Dictionary of custom skills for the character.
        """
        return self.custom_skills.get(character_id, {})
    
    def get_skill_list_for_llm(self) -> str:
        """
        Generate a formatted string of skills for LLM prompts.
        
        Returns:
            Formatted string listing all available skills.
        """
        result = "Available skills:\n"
        for skill_id, skill in self.skills.items():
            result += f"- {skill['name']} ({skill_id}): {skill.get('description', '')}\n"
        return result
    
    def get_primary_stat_for_skill(self, skill_name: str) -> Optional[StatType]:
        """
        Get the primary stat type for a skill.
        
        Args:
            skill_name: The name of the skill.
            
        Returns:
            The StatType for the skill's primary stat, or None if not found.
        """
        skill = self.get_skill(skill_name)
        if not skill or 'primary_stat' not in skill:
            return None
            
        try:
            # Convert string stat name to StatType enum
            stat_name = skill['primary_stat']
            from core.stats.stats_base import StatType
            return StatType.from_string(stat_name)
        except (ValueError, ImportError) as e:
            logger.error(f"Error getting primary stat for skill '{skill_name}': {e}")
            return None
    
    def generate_custom_skill(self, character_id: str, skill_data: Dict[str, Any], context: str = "") -> Optional[str]:
        """
        Generate a custom skill for a character.
        
        Args:
            character_id: The ID of the character.
            skill_data: The base data for the skill (name, primary_stat, etc.)
            context: Optional context about how/why the skill was generated.
            
        Returns:
            The ID of the generated skill, or None if generation failed.
        """
        try:
            # Validate required fields
            required_fields = ['name', 'primary_stat', 'description']
            for field in required_fields:
                if field not in skill_data:
                    logger.error(f"Missing required field '{field}' for custom skill")
                    return None
            
            # Generate a unique ID for the skill
            skill_id = f"custom_{character_id}_{int(time.time())}"
            
            # Initialize character's custom skills dict if needed
            if character_id not in self.custom_skills:
                self.custom_skills[character_id] = {}
            
            # Create the skill with the provided data
            self.custom_skills[character_id][skill_id] = {
                "name": skill_data["name"],
                "primary_stat": skill_data["primary_stat"],
                "category": skill_data.get("category", "CUSTOM"),
                "description": skill_data["description"],
                "generation_context": context,
                "created_at": time.time()
            }
            
            logger.info(f"Generated custom skill '{skill_data['name']}' ({skill_id}) for character {character_id}")
            
            # TODO: Save custom skills to disk when persistence is implemented
            
            return skill_id
        except Exception as e:
            logger.error(f"Error generating custom skill: {e}")
            return None
    
    def find_closest_skill(self, intent: str) -> Optional[str]:
        """
        Find the closest matching skill for a given player intent.
        
        Args:
            intent: The player's intention description.
            
        Returns:
            The ID of the closest matching skill, or None if no match.
        """
        intent_lower = intent.lower()
        
        # Define common action keywords and their associated skills
        keyword_mappings = {
            # Attack keywords
            "attack": "melee_attack",
            "hit": "melee_attack",
            "strike": "melee_attack",
            "slash": "melee_attack",
            "stab": "melee_attack",
            "bash": "melee_attack",
            
            # Ranged keywords
            "shoot": "ranged_attack",
            "fire": "ranged_attack",
            "throw": "ranged_attack",
            "aim": "ranged_attack",
            
            # Magic keywords
            "cast": "spell_attack",
            "spell": "spell_attack",
            
            # Evasion keywords
            "dodge": "dodge",
            "evade": "dodge",
            "avoid": "dodge",
            "duck": "dodge",
            "jump": "acrobatics",
            "flip": "acrobatics",
            "somersault": "acrobatics",
            "roll": "acrobatics",
            
            # Unarmed keywords
            "punch": "unarmed_attack",
            "kick": "unarmed_attack",
            "knee": "unarmed_attack",
            "elbow": "unarmed_attack",
            "headbutt": "unarmed_attack"
        }
        
        # Check for direct keyword matches
        for keyword, skill_id in keyword_mappings.items():
            if keyword in intent_lower and skill_id in self.skills:
                return skill_id
        
        # If no match found, try broader categories
        if any(word in intent_lower for word in ["punch", "kick", "unarmed"]):
            return "unarmed_attack"
        
        if any(word in intent_lower for word in ["flip", "jump", "roll", "agile"]):
            return "acrobatics"
            
        if any(word in intent_lower for word in ["attack", "fight", "hit", "combat"]):
            return "melee_attack"
        
        if any(word in intent_lower for word in ["dodge", "avoid", "evade"]):
            return "dodge"
        
        # Default fallback
        return None
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert to a dictionary for serialization.
        
        Returns:
            Dictionary representation of the skill manager.
        """
        return {
            "skills": self.skills,
            "custom_skills": self.custom_skills
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SkillManager':
        """
        Create a SkillManager from a dictionary.
        
        Args:
            data: Dictionary representation of a skill manager.
            
        Returns:
            A new SkillManager instance.
        """
        manager = cls()
        
        # Only load from file if no skills in the data
        if not data.get("skills"):
            # This keeps the default behavior of loading from file
            pass
        else:
            # Override with provided data
            manager.skills = data.get("skills", {})
            manager.custom_skills = data.get("custom_skills", {})
        
        return manager


# Singleton instance
_skill_manager_instance = None

def get_skill_manager() -> SkillManager:
    """
    Get the skill manager instance.
    
    Returns:
        The singleton SkillManager instance.
    """
    global _skill_manager_instance
    if _skill_manager_instance is None:
        _skill_manager_instance = SkillManager()
    
    return _skill_manager_instance

```

### File: core\stats\stat_allocation.py

```python
"""
System for managing stat point allocation during character creation and leveling.
"""

from typing import Dict, List, Any, Optional, Union, Tuple
import logging

from core.stats.stats_base import StatType
from core.stats.stats_manager import StatsManager


logger = logging.getLogger(__name__)


class StatPointAllocator:
    """
    Manages allocation of stat points during character creation and leveling.
    """
    
    def __init__(
        self,
        stats_manager: StatsManager,
        total_points: int = 22,
        min_value: int = 8,
        max_value: int = 15
    ):
        """
        Initialize the stat point allocator.
        
        Args:
            stats_manager: The StatsManager to modify
            total_points: Total points available for allocation
            min_value: Minimum allowed stat value
            max_value: Maximum allowed stat value
        """
        self.stats_manager = stats_manager
        self.total_points = total_points
        self.min_value = min_value
        self.max_value = max_value
        
        # Cost of each point above the minimum value (D&D style)
        self.point_costs = {
            8: 0,    # Base value costs nothing
            9: 1,    # 9 costs 1 point
            10: 2,   # 10 costs 2 points
            11: 3,   # 11 costs 3 points
            12: 4,   # 12 costs 4 points
            13: 5,   # 13 costs 5 points
            14: 7,   # 14 costs 7 points
            15: 9,   # 15 costs 9 points
            16: 11,  # 16 costs 11 points (usually from racial bonuses)
            17: 14,  # 17 costs 14 points
            18: 17   # 18 costs 17 points
        }
        
        # Initialize to minimum values
        self.reset_to_minimum()
    
    def reset_to_minimum(self) -> None:
        """Reset all stats to their minimum values."""
        logger.info("Resetting all stats to minimum values")
        for stat_type in StatType:
            current_value = int(self.stats_manager.get_stat_value(stat_type))
            if current_value != self.min_value:
                logger.debug(f"Resetting {stat_type} from {current_value} to {self.min_value}")
                self.stats_manager.set_base_stat(stat_type, self.min_value)
    
    def get_point_cost(self, value: int) -> int:
        """
        Get the point cost for a specific stat value.
        
        Args:
            value: The stat value to check
            
        Returns:
            The point cost for that value
        """
        if value < self.min_value:
            return 0
        elif value in self.point_costs:
            return self.point_costs[value]
        else:
            # For values beyond our chart, use a quadratic cost
            # This is an approximation of the D&D point buy system
            return value * 2 - 14
    
    def calculate_total_cost(self) -> int:
        """
        Calculate the total point cost of the current stat allocation.
        
        Returns:
            The total points spent
        """
        total_cost = 0
        for stat_type in StatType:
            stat_value = int(self.stats_manager.get_stat_value(stat_type))
            total_cost += self.get_point_cost(stat_value)
        return total_cost
    
    def get_remaining_points(self) -> int:
        """
        Calculate how many points remain to be allocated.
        
        Returns:
            The number of remaining points
        """
        return self.total_points - self.calculate_total_cost()
    
    def can_increase_stat(self, stat_type: StatType) -> bool:
        """
        Check if a stat can be increased.
        
        Args:
            stat_type: The stat to check
            
        Returns:
            True if the stat can be increased, False otherwise
        """
        current_value = int(self.stats_manager.get_stat_value(stat_type))
        
        # Check if we're already at max
        if current_value >= self.max_value:
            return False
        
        # Calculate cost to increase
        current_cost = self.get_point_cost(current_value)
        next_cost = self.get_point_cost(current_value + 1)
        additional_cost = next_cost - current_cost
        
        # Check if we have enough points
        return additional_cost <= self.get_remaining_points()
    
    def can_decrease_stat(self, stat_type: StatType) -> bool:
        """
        Check if a stat can be decreased.
        
        Args:
            stat_type: The stat to check
            
        Returns:
            True if the stat can be decreased, False otherwise
        """
        current_value = int(self.stats_manager.get_stat_value(stat_type))
        return current_value > self.min_value
    
    def increase_stat(self, stat_type: StatType) -> bool:
        """
        Increase a stat by one point.
        
        Args:
            stat_type: The stat to increase
            
        Returns:
            True if the stat was increased, False otherwise
        """
        if not self.can_increase_stat(stat_type):
            logger.debug(f"Cannot increase {stat_type} - max value or not enough points")
            return False
        
        try:
            current_value = int(self.stats_manager.get_stat_value(stat_type))
            new_value = current_value + 1
            logger.info(f"Increasing {stat_type} from {current_value} to {new_value}")
            
            # Get current base value directly from the stat object for accuracy
            actual_base = self.stats_manager.get_stat(stat_type).base_value
            new_base = actual_base + 1
            logger.debug(f"Base value before: {actual_base}, after: {new_base}")
            
            # Update the base stat value
            self.stats_manager.set_base_stat(stat_type, new_base)
            
            # Verify the change was applied
            actual_after = self.stats_manager.get_stat(stat_type).base_value
            if actual_after != new_base:
                logger.error(f"Failed to update {stat_type} base value. Expected {new_base}, got {actual_after}")
                return False
                
            logger.debug(f"Successfully increased {stat_type} to base={actual_after}, total={self.stats_manager.get_stat_value(stat_type)}")
            return True
        except Exception as e:
            logger.error(f"Error increasing {stat_type}: {e}")
            return False
    
    def decrease_stat(self, stat_type: StatType) -> bool:
        """
        Decrease a stat by one point.
        
        Args:
            stat_type: The stat to decrease
            
        Returns:
            True if the stat was decreased, False otherwise
        """
        if not self.can_decrease_stat(stat_type):
            logger.debug(f"Cannot decrease {stat_type} - already at minimum value")
            return False
        
        try:
            current_value = int(self.stats_manager.get_stat_value(stat_type))
            new_value = current_value - 1
            logger.info(f"Decreasing {stat_type} from {current_value} to {new_value}")
            
            # Get current base value directly from the stat object for accuracy
            actual_base = self.stats_manager.get_stat(stat_type).base_value
            new_base = actual_base - 1
            logger.debug(f"Base value before: {actual_base}, after: {new_base}")
            
            # Update the base stat value
            self.stats_manager.set_base_stat(stat_type, new_base)
            
            # Verify the change was applied
            actual_after = self.stats_manager.get_stat(stat_type).base_value
            if actual_after != new_base:
                logger.error(f"Failed to update {stat_type} base value. Expected {new_base}, got {actual_after}")
                return False
                
            logger.debug(f"Successfully decreased {stat_type} to base={actual_after}, total={self.stats_manager.get_stat_value(stat_type)}")
            return True
        except Exception as e:
            logger.error(f"Error decreasing {stat_type}: {e}")
            return False
    
    def allocate_points_automatically(
        self,
        priority_stats: List[StatType] = None,
        balanced: bool = False
    ) -> None:
        """
        Automatically allocate available points.
        
        Args:
            priority_stats: List of stats to prioritize in order
            balanced: If True, maintain a balanced distribution
        """
        # Reset to minimum first
        self.reset_to_minimum()
        
        # If no priority stats provided, use all stats
        if not priority_stats:
            priority_stats = list(StatType)
        
        if balanced:
            # Balanced allocation: round-robin approach
            while self.get_remaining_points() > 0:
                allocated = False
                for stat_type in priority_stats:
                    if self.can_increase_stat(stat_type):
                        self.increase_stat(stat_type)
                        allocated = True
                        break
                
                if not allocated:
                    break  # No more stats can be increased
        else:
            # Priority allocation: max out high priority stats first
            for stat_type in priority_stats:
                # Keep increasing this stat until we can't anymore
                while self.can_increase_stat(stat_type):
                    self.increase_stat(stat_type)
        
        logger.debug(
            f"Automatic allocation complete. "
            f"Spent {self.calculate_total_cost()} points, "
            f"{self.get_remaining_points()} points remaining."
        )
    
    def get_stat_allocation_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the current stat allocation.
        
        Returns:
            Dictionary with allocation details
        """
        stats = {}
        for stat_type in StatType:
            value = int(self.stats_manager.get_stat_value(stat_type))
            cost = self.get_point_cost(value)
            stats[str(stat_type)] = {
                "value": value,
                "cost": cost,
                "can_increase": self.can_increase_stat(stat_type),
                "can_decrease": self.can_decrease_stat(stat_type)
            }
        
        return {
            "stats": stats,
            "total_points": self.total_points,
            "spent_points": self.calculate_total_cost(),
            "remaining_points": self.get_remaining_points(),
            "min_value": self.min_value,
            "max_value": self.max_value
        }

```

### File: core\stats\stat_modifier_info.py

```python
"""
Module for handling race and class stat modifiers.
"""

import os
import json
import logging
from typing import Dict, List, Any, Optional

from core.utils.logging_config import get_logger, log_migration_fix

# Log the import fix
log_migration_fix(
    "core.stats.stat_modifier_info", 
    "from core.utils.logging_config import get_logger, LogCategory\nlogger = get_logger(LogCategory.SYSTEM)", 
    "from core.utils.logging_config import get_logger\nlogger = get_logger(\"STATS\")"
)

logger = get_logger("STATS")


class StatModifierInfo:
    """Holds information about stat modifiers from race/class."""
    
    def __init__(self):
        """Initialize the stat modifier info."""
        self.race_name = ""
        self.class_name = ""
        self.race_modifiers = {}
        self.class_modifiers = {}
        self.minimum_requirements = {}
        self.recommended_stats = {}
        self.race_color_bonus = "#4CAF50"  # Default green
        self.race_color_penalty = "#F44336"  # Default red
        self.class_color_bonus = "#2196F3"  # Default blue
        self.class_color_requirement = "#FF9800"  # Default orange
        self.below_minimum_color = "#F44336"  # Default red
        self.race_description = ""
        self.class_description = ""
        self.archetype_presets = {}
        
    def load_modifiers(self, race_name: str, class_name: str) -> None:
        """
        Load racial and class modifiers from config files.
        
        Args:
            race_name: The name of the selected race
            class_name: The name of the selected class
        """
        # Reset and store new names
        self.race_name = race_name
        self.class_name = class_name
        self.race_modifiers = {}
        self.class_modifiers = {}
        self.minimum_requirements = {}
        self.recommended_stats = {}
        self.race_description = ""
        self.class_description = ""
        self.archetype_presets = {}
        
        # Find the config directory
        project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', '..'))
        race_config_path = os.path.join(project_root, "config", "character", "races.json")
        class_config_path = os.path.join(project_root, "config", "character", "classes.json")
        
        # Debug log paths
        logger.debug(f"Loading modifiers for race: {race_name}, class: {class_name}")
        logger.debug(f"Race config path: {race_config_path}")
        logger.debug(f"Class config path: {class_config_path}")
        
        # Load race data
        if os.path.exists(race_config_path):
            try:
                with open(race_config_path, 'r', encoding='utf-8') as f:
                    race_data = json.load(f)
                
                # Debug log available races
                available_races = list(race_data.get("races", {}).keys())
                logger.debug(f"Available races in config: {available_races}")
                
                if race_name in race_data.get("races", {}):
                    race_info = race_data["races"][race_name]
                    self.race_modifiers = race_info.get("stat_modifiers", {})
                    self.race_description = race_info.get("description", "")
                    
                    # Debug log loaded modifiers
                    logger.debug(f"Loaded race modifiers for {race_name}: {self.race_modifiers}")
                else:
                    logger.warning(f"Race '{race_name}' not found in config. Available races: {available_races}")
                    
                # Load display colors
                if "display_colors" in race_data:
                    self.race_color_bonus = race_data["display_colors"].get("racial_bonus", self.race_color_bonus)
                    self.race_color_penalty = race_data["display_colors"].get("racial_penalty", self.race_color_penalty)
            except Exception as e:
                logger.error(f"Error loading race data: {e}")
                self.race_modifiers = {}
                self.race_description = ""
        else:
            logger.error(f"Race config file not found: {race_config_path}")
        
        # Load class data
        if os.path.exists(class_config_path):
            try:
                with open(class_config_path, 'r', encoding='utf-8') as f:
                    class_data = json.load(f)
                
                # Debug log available classes
                available_classes = list(class_data.get("classes", {}).keys())
                logger.debug(f"Available classes in config: {available_classes}")
                
                if class_name in class_data.get("classes", {}):
                    class_info = class_data["classes"][class_name]
                    self.class_modifiers = class_info.get("stat_modifiers", {})
                    self.minimum_requirements = class_info.get("minimum_stats", {})
                    self.recommended_stats = class_info.get("recommended_stats", {})
                    self.class_description = class_info.get("description", "")
                    self.archetype_presets = class_info.get("archetypes", {})
                    
                    # Debug log loaded data
                    logger.debug(f"Loaded class modifiers for {class_name}: {self.class_modifiers}")
                    logger.debug(f"Loaded minimum requirements: {self.minimum_requirements}")
                    logger.debug(f"Loaded recommended stats: {self.recommended_stats}")
                else:
                    logger.warning(f"Class '{class_name}' not found in config. Available classes: {available_classes}")
                    
                # Load display colors
                if "display_colors" in class_data:
                    self.class_color_bonus = class_data["display_colors"].get("class_bonus", self.class_color_bonus)
                    self.class_color_requirement = class_data["display_colors"].get("class_requirement", self.class_color_requirement)
                    self.below_minimum_color = class_data["display_colors"].get("below_minimum", self.below_minimum_color)
            except Exception as e:
                logger.error(f"Error loading class data: {e}")
                self.class_modifiers = {}
                self.minimum_requirements = {}
                self.recommended_stats = {}
                self.class_description = ""
                self.archetype_presets = {}
        else:
            logger.error(f"Class config file not found: {class_config_path}")
    
    def get_combined_modifier(self, stat_type: str) -> int:
        """
        Get the combined race and class modifier for a stat.
        
        Args:
            stat_type: The stat type to get modifiers for
            
        Returns:
            The combined modifier value
        """
        race_mod = self.race_modifiers.get(stat_type, 0)
        class_mod = self.class_modifiers.get(stat_type, 0)
        return race_mod + class_mod
    
    def get_tooltip_text(self, stat_type: str, current_value: int) -> str:
        """
        Get tooltip text for a stat with modifier info.
        
        Args:
            stat_type: The stat to get tooltip for
            current_value: The current stat value
            
        Returns:
            Formatted tooltip text
        """
        race_mod = self.race_modifiers.get(stat_type, 0)
        class_mod = self.class_modifiers.get(stat_type, 0)
        min_req = self.minimum_requirements.get(stat_type, 0)
        
        # Calculate total value including modifiers
        total_value = current_value + race_mod + class_mod
        
        tooltip = f"<b>{stat_type}</b><hr>"
        
        # Base value
        tooltip += f"Base Value: {current_value}<br>"
        
        # Race modifier
        if race_mod != 0:
            sign = "+" if race_mod > 0 else ""
            tooltip += f"{self.race_name} Modifier: <span style='color: {'#4CAF50' if race_mod > 0 else '#F44336'}'>{sign}{race_mod}</span><br>"
        
        # Class modifier
        if class_mod != 0:
            sign = "+" if class_mod > 0 else ""
            tooltip += f"{self.class_name} Modifier: <span style='color: {'#2196F3' if class_mod > 0 else '#F44336'}'>{sign}{class_mod}</span><br>"
        
        # Total value
        tooltip += f"<b>Total Value: {total_value}</b><br>"
        
        # Minimum requirement
        if min_req > 0:
            tooltip += f"<hr>Minimum Requirement: <span style='color: {'#4CAF50' if total_value >= min_req else '#F44336'}'>{min_req}</span>"
            if total_value < min_req:
                tooltip += " <b>(not met)</b>"
            tooltip += "<br>"
        
        # Primary/secondary stat info
        if stat_type in (self.recommended_stats.get("primary", [])):
            tooltip += "<span style='color: #4CAF50'>This is a primary stat for your class!</span><br>"
        elif stat_type in (self.recommended_stats.get("secondary", [])):
            tooltip += "<span style='color: #FFC107'>This is a secondary stat for your class.</span><br>"
        
        return tooltip
    
    def meets_class_requirements(self, stat_values: Dict[str, int]) -> bool:
        """
        Check if the current stats meet class requirements.
        
        Args:
            stat_values: Dictionary of stat values with modifiers applied
            
        Returns:
            True if all requirements are met, False otherwise
        """
        for stat, min_value in self.minimum_requirements.items():
            if stat_values.get(stat, 0) < min_value:
                return False
        return True
    
    def get_total_stat_value(self, stat_type: str, base_value: int) -> int:
        """
        Calculate the total stat value after applying modifiers.
        
        Args:
            stat_type: The stat to calculate
            base_value: The base value before modifiers
            
        Returns:
            The total value after modifiers
        """
        race_mod = self.race_modifiers.get(stat_type, 0)
        class_mod = self.class_modifiers.get(stat_type, 0)
        return base_value + race_mod + class_mod
    
    def get_stat_modifier_color(self, stat_type: str, source: str = None) -> str:
        """
        Get the color to display a stat modifier.
        
        Args:
            stat_type: The stat type
            source: The modifier source ('race' or 'class')
            
        Returns:
            A color hex code
        """
        if source == 'race':
            mod = self.race_modifiers.get(stat_type, 0)
            return self.race_color_bonus if mod > 0 else (self.race_color_penalty if mod < 0 else "#CCCCCC")
        elif source == 'class':
            mod = self.class_modifiers.get(stat_type, 0)
            return self.class_color_bonus if mod > 0 else (self.race_color_penalty if mod < 0 else "#CCCCCC")
        else:
            # Combined or unknown
            mod = self.get_combined_modifier(stat_type)
            if mod > 0:
                return self.race_color_bonus
            elif mod < 0:
                return self.race_color_penalty
            else:
                return "#CCCCCC"
    
    def apply_preset(self, preset_name: str) -> Optional[Dict[str, int]]:
        """
        Get stat values from a class archetype preset.
        
        Args:
            preset_name: The name of the preset to apply
            
        Returns:
            Dictionary of base stat values, or None if preset not found
        """
        if preset_name in self.archetype_presets:
            return self.archetype_presets[preset_name].get("stat_distribution", None)
        return None

```

### File: core\stats\stats_base.py

```python
"""
Base classes and enums for the stats system.
"""

from enum import Enum, auto
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Union


class StatCategory(Enum):
    """Categories of statistics."""
    PRIMARY = auto()
    DERIVED = auto()
    COMBAT = auto()
    SKILL = auto()
    RESISTANCE = auto()
    MISC = auto()


class StatType(Enum):
    """Primary character statistics."""
    # Primary attributes
    STRENGTH = "STR"        # Physical power
    DEXTERITY = "DEX"       # Agility and reflexes
    CONSTITUTION = "CON"    # Physical resilience
    INTELLIGENCE = "INT"    # Mental acuity
    WISDOM = "WIS"          # Intuition and perception
    CHARISMA = "CHA"        # Social influence
    WILLPOWER = "WIL"       # Mental fortitude, resistance to influence
    INSIGHT = "INS"         # Understanding situations and people

    def __str__(self) -> str:
        return self.value

    @classmethod
    def from_string(cls, stat_name: str) -> 'StatType':
        """Convert a string to a StatType enum."""
        stat_name_lower = stat_name.lower()
        for stat in cls:
            # Check both value (e.g., "STR") and name (e.g., "STRENGTH")
            if stat.value.lower() == stat_name_lower or stat.name.lower() == stat_name_lower:
                return stat
        raise ValueError(f"Unknown stat type: {stat_name}")


class DerivedStatType(Enum):
    """Derived character statistics."""
    # Health and resources
    HEALTH = "Health Points"           # Hit points
    MAX_HEALTH = "Max Health Points"   # Maximum hit points
    MANA = "Mana Points"               # Current magic resource
    MAX_MANA = "Max Mana Points"       # Maximum magic resource 
    STAMINA = "Stamina"                # Current physical resource
    MAX_STAMINA = "Max Stamina"        # Maximum physical resource 
    RESOLVE = "Resolve"                # Social/Mental composure 'health'
    MAX_RESOLVE = "Max Resolve"        # Maximum social/mental composure
    
    # Combat stats
    MELEE_ATTACK = "Melee Attack"      # Melee attack bonus
    RANGED_ATTACK = "Ranged Attack"    # Ranged attack bonus
    MAGIC_ATTACK = "Magic Attack"      # Magic attack bonus
    DEFENSE = "Defense"                # Physical defense
    MAGIC_DEFENSE = "Magic Defense"    # Magic defense
    DAMAGE_REDUCTION = "Damage Reduction" # Flat damage reduction 

    # Utility stats
    INITIATIVE = "Initiative"          # Combat turn order
    CARRY_CAPACITY = "Carry Capacity"  # Weight limit
    MOVEMENT = "Movement"              # Movement speed

    def __str__(self) -> str:
        # Return the user-friendly value (e.g., "Health Points")
        return self.value

    @classmethod
    def from_string(cls, stat_name: str) -> 'DerivedStatType':
        """Convert a string to a DerivedStatType enum."""
        stat_name_lower = stat_name.lower().replace(" ", "_") 
        for stat in cls:
            enum_name_lower = stat.name.lower()
            enum_value_normalized = stat.value.lower().replace(" ", "_")
            if enum_name_lower == stat_name_lower or enum_value_normalized == stat_name_lower:
                return stat
        raise ValueError(f"Unknown derived stat type: {stat_name}")


class Skill(Enum):
    """Character skills."""
    # Social Skills
    PERSUASION = ("Persuasion", StatType.CHARISMA)      # Influencing others through diplomacy, negotiation
    INTIMIDATION = ("Intimidation", StatType.STRENGTH)  # Influencing others through threats, coercion (could also be CHA or WIL depending on flavor)
    DECEPTION = ("Deception", StatType.CHARISMA)       # Influencing others through lies, misdirection
    EMPATHY = ("Empathy", StatType.INSIGHT)           # Understanding others' feelings and intentions (could also be WIS)
    BARTER = ("Barter", StatType.CHARISMA)           # Influencing prices during trade

    # Combat Skills
    MELEE_ATTACK = ("Melee Attack", StatType.STRENGTH)   # Physical close-range combat attacks
    RANGED_ATTACK = ("Ranged Attack", StatType.DEXTERITY) # Physical ranged combat attacks
    SPELL_ATTACK = ("Spell Attack", StatType.INTELLIGENCE) # Magical attacks
    DEFENSE = ("Defense", StatType.DEXTERITY)       # Avoiding physical attacks
    DODGE = ("Dodge", StatType.DEXTERITY)         # Evading physical attacks

    # Add other skill types as needed (e.g., Crafting, Knowledge)

    def __init__(self, display_name: str, primary_stat: StatType):
        self._display_name = display_name
        self._primary_stat = primary_stat

    @property
    def display_name(self) -> str:
        return self._display_name

    @property
    def primary_stat(self) -> StatType:
        return self._primary_stat

# REMOVED: Simple StatModifier dataclass definition

@dataclass
class Stat:
    """A character statistic with base value.""" # Updated docstring
    name: Union[StatType, DerivedStatType, str]
    base_value: float
    category: StatCategory
    description: str = ""

    # REMOVED: modifiers: List[StatModifier] = field(default_factory=list)

    # RESTORED: value property, simplified to return base_value
    @property
    def value(self) -> float:
        """Returns the base value of the stat.
        Note: This does NOT include modifiers managed by ModifierManager.
        Use StatsManager.get_stat_value() for the final calculated value.
        """
        return self.base_value

    # REMOVED: def add_modifier(self, modifier: StatModifier) -> None:
    # REMOVED: def remove_modifier(self, source: str) -> None:
    # REMOVED: def clear_modifiers(self) -> None:

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            # Use the Enum *name* (e.g., STRENGTH) for serialization consistency
            "name": self.name.name if isinstance(self.name, (StatType, DerivedStatType)) else str(self.name),
            "base_value": self.base_value,
            "category": self.category.name,
            # REMOVED: "modifiers": [ ... ] section
            "description": self.description
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Stat':
        """Create a Stat from a dictionary."""
        stat_name_str = data["name"]
        try:
            # Try to convert name string (e.g., "STRENGTH") back to StatType Enum
            name = StatType[stat_name_str]
        except KeyError:
            try:
                 # Try to convert name string (e.g., "MAX_HEALTH") back to DerivedStatType Enum
                name = DerivedStatType[stat_name_str]
            except KeyError:
                # If it's neither, keep it as a string (e.g., for custom stats)
                name = stat_name_str

        category = StatCategory[data["category"]]

        stat = cls(
            name=name,
            base_value=data["base_value"],
            category=category,
            description=data.get("description", "")
        )
        # REMOVED: Loading modifiers from data here

        return stat
```

### File: core\stats\stats_manager.py

```python
"""
Manager for character statistics.
"""

import math
from typing import Dict, List, Any, Optional, Tuple, Union, Set
import logging
import json
import os
import random
from PySide6.QtCore import QObject, Signal

from core.stats.stats_base import Stat, StatType, DerivedStatType, StatCategory, Skill # Import Skill enum
from core.stats.derived_stats import DERIVED_STAT_CALCULATORS, calculate_derived_stat, get_modifier_from_stat
from core.stats.modifier import StatModifier, ModifierSource, ModifierGroup, ModifierType
from core.stats.modifier_manager import ModifierManager
from core.stats.skill_check import perform_check, calculate_success_chance, SkillCheckResult
from core.stats.combat_effects import StatusEffect, StatusEffectManager, StatusEffectType
from core.base.config import get_config


logger = logging.getLogger(__name__)


class StatsManager(QObject):
    """
    Manages character statistics, including primary stats, derived stats, and modifiers.
    """

    # Signal emitted when stats change
    stats_changed = Signal(dict)
    
    def __init__(self, config_file: Optional[str] = None):
        """
        Initialize the stats manager.

        Args:
            config_file: Optional path to a stats configuration file.
        """
        super().__init__()  # Initialize QObject
        
        self.stats: Dict[Union[StatType, str], Stat] = {}
        self.derived_stats: Dict[Union[DerivedStatType, str], Stat] = {}
        self.modifier_manager = ModifierManager()
        self.status_effect_manager = StatusEffectManager(self)
        self.level = 1
        self.config: Dict[str, Any] = {}
        
        # Typed resistance contributions by source_id -> {damage_type: percent}
        # Example: {"armor_chest": {"slashing": 10, "fire": 5}}
        self._typed_resist_contrib_by_source: Dict[str, Dict[str, float]] = {}
        
        # Reference to inventory manager for equipment modifiers
        # This will be set by the state manager or game engine
        self._inventory_manager = None

        # Load default configuration
        if config_file and os.path.exists(config_file):
            with open(config_file, 'r') as f:
                self.config = json.load(f)

        # Initialize primary stats with default values
        self._initialize_primary_stats()

        # Initialize derived stats
        self._initialize_derived_stats()

    def _initialize_primary_stats(self) -> None:
        """Initialize the primary stats with default values."""
        # Default base value for stats
        default_base = self.config.get("default_stat_value", 10)

        # Initialize each primary stat
        for stat_type in StatType:
            base_value = self.config.get(f"base_{stat_type.name.lower()}", default_base)

            self.stats[stat_type] = Stat(
                name=stat_type,
                base_value=base_value,
                category=StatCategory.PRIMARY,
                description=self._get_stat_description(stat_type)
            )

    def _initialize_derived_stats(self) -> None:
            """Initialize the derived stats. Calculates max values and sets current values."""
            for stat_type in DerivedStatType:
                if stat_type in [DerivedStatType.HEALTH, DerivedStatType.RESOLVE, DerivedStatType.MANA, DerivedStatType.STAMINA]:
                    continue

                try:
                    if stat_type in DERIVED_STAT_CALCULATORS:
                        base_value = calculate_derived_stat(
                            stat_type=stat_type,
                            stats=self.stats,
                            level=self.level,
                            config=self.config
                        )
                    else:
                        logger.debug(f"No calculator found for {stat_type}, initializing base value to 0.0.")
                        base_value = 0.0

                    self.derived_stats[stat_type] = Stat(
                        name=stat_type,
                        base_value=float(base_value), 
                        category=StatCategory.DERIVED,
                        description=self._get_stat_description(stat_type)
                    )
                except ValueError as e: 
                    logger.warning(f"{e}, skipping initialization for {stat_type}.")
                    # Ensure stat exists even if calculation fails, with a default.
                    if stat_type not in self.derived_stats:
                        self.derived_stats[stat_type] = Stat(
                            name=stat_type, base_value=0.0, category=StatCategory.DERIVED,
                            description=self._get_stat_description(stat_type)
                        )
                    continue
                except Exception as e:
                    logger.error(f"Unexpected error initializing derived stat {stat_type}: {e}", exc_info=True)
                    if stat_type not in self.derived_stats: # Ensure it exists with default if error
                        self.derived_stats[stat_type] = Stat(name=stat_type, base_value=0.0, category=StatCategory.DERIVED, description=self._get_stat_description(stat_type))
                    continue


            resource_pairs = [
                (DerivedStatType.HEALTH, DerivedStatType.MAX_HEALTH),
                (DerivedStatType.RESOLVE, DerivedStatType.MAX_RESOLVE),
                (DerivedStatType.MANA, DerivedStatType.MAX_MANA),      
                (DerivedStatType.STAMINA, DerivedStatType.MAX_STAMINA) 
            ]

            for current_stat_type, max_stat_type in resource_pairs:
                if max_stat_type in self.derived_stats:
                    # Use get_stat_value for MAX to include any modifiers already applied (e.g. racial to base primary impacting max)
                    max_value = self.get_stat_value(max_stat_type) 
                    
                    if current_stat_type not in self.derived_stats:
                        self.derived_stats[current_stat_type] = Stat(
                            name=current_stat_type,
                            base_value=max_value, 
                            category=StatCategory.DERIVED,
                            description=self._get_stat_description(current_stat_type)
                        )
                    else:
                        # If it exists (e.g. from loaded save), ensure it doesn't exceed the new max
                        self.derived_stats[current_stat_type].base_value = min(
                            self.derived_stats[current_stat_type].base_value,
                            max_value
                        )
                else:
                    default_current = 1.0 # Small default if MAX is somehow not calculable
                    if current_stat_type not in self.derived_stats:
                        self.derived_stats[current_stat_type] = Stat(
                            name=current_stat_type, base_value=default_current, category=StatCategory.DERIVED,
                            description=self._get_stat_description(current_stat_type)
                        )
                    logger.warning(f"{max_stat_type} not calculated, cannot initialize {current_stat_type} based on it. Initialized to {self.derived_stats[current_stat_type].base_value}.")


    def _get_stat_description(self, stat_type: Union[StatType, DerivedStatType]) -> str:
            """Get a description for a stat type."""
            descriptions = {
                # Primary stats
                StatType.STRENGTH: "Physical power, affects melee damage and carrying capacity.",
                StatType.DEXTERITY: "Agility and reflexes, affects ranged attacks, initiative, and dodge.",
                StatType.CONSTITUTION: "Physical resilience, affects health, stamina, and resistance to poison/disease.",
                StatType.INTELLIGENCE: "Mental acuity, affects spell power and learning ability.",
                StatType.WISDOM: "Intuition and perception, affects magical resistance and willpower.",
                StatType.CHARISMA: "Social influence, affects dialogue, prices, and persuasion.",
                StatType.WILLPOWER: "Mental fortitude, resistance to influence and fear.",
                StatType.INSIGHT: "Understanding situations, detecting lies, and sensing motives.",

                # Derived stats
                DerivedStatType.HEALTH: "Your current hit points. When this reaches zero, you are incapacitated.",
                DerivedStatType.MAX_HEALTH: "Your maximum hit points.",
                DerivedStatType.MANA: "Your current magical energy. Required for casting spells.",
                DerivedStatType.MAX_MANA: "Your maximum magical energy.",          
                DerivedStatType.STAMINA: "Your current physical energy. Required for special physical actions.",
                DerivedStatType.MAX_STAMINA: "Your maximum physical energy.",      
                DerivedStatType.RESOLVE: "Your current social/mental composure. Reduced by stress or social defeats.",
                DerivedStatType.MAX_RESOLVE: "Your maximum social/mental composure.",
                DerivedStatType.MELEE_ATTACK: "Your ability to hit opponents in melee combat.",
                DerivedStatType.RANGED_ATTACK: "Your ability to hit opponents with ranged weapons.",
                DerivedStatType.MAGIC_ATTACK: "Your ability to hit opponents with magical attacks.",
                DerivedStatType.DEFENSE: "Your ability to avoid physical damage.",
                DerivedStatType.MAGIC_DEFENSE: "Your ability to resist magical effects.",
                DerivedStatType.DAMAGE_REDUCTION: "Reduces incoming physical damage by a flat amount.",
                DerivedStatType.INITIATIVE: "Determines your turn order in combat.",
                DerivedStatType.CARRY_CAPACITY: "The maximum weight you can carry.",
                DerivedStatType.MOVEMENT: "How far you can move in combat.",
            }

            return descriptions.get(stat_type, "")

    def get_stat(self, stat_type: Union[StatType, DerivedStatType, str]) -> Optional[Stat]:
        """
        Get a stat by its type.

        Args:
            stat_type: The stat type to get.

        Returns:
            The stat if found, None otherwise.
        """
        if isinstance(stat_type, StatType):
            return self.stats.get(stat_type)
        elif isinstance(stat_type, DerivedStatType):
            return self.derived_stats.get(stat_type)
        else:
            # Try to find by string name (case insensitive)
            try:
                return self.stats[StatType.from_string(stat_type)]
            except ValueError:
                try:
                    return self.derived_stats[DerivedStatType.from_string(stat_type)]
                except ValueError:
                    return None

    def get_stat_value(self, stat_type: Union[StatType, DerivedStatType, str]) -> float:
        """
        Get the current value of a stat.

        Args:
            stat_type: The stat type to get.

        Returns:
            The current value of the stat.

        Raises:
            ValueError: If the stat is not found.
        """
        stat = self.get_stat(stat_type)
        if stat is None:
            raise ValueError(f"Stat not found: {stat_type}")

        # Get the base value with any direct modifiers on the stat object
        base_value = stat.value

        # Apply modifiers from the modifier manager
        mods = self.modifier_manager.get_stat_modifier_value(stat_type)

        # Apply flat modifiers first
        modified_value = base_value + mods['flat']

        # Then apply percentage modifiers
        if mods['percentage'] != 0:
            modified_value = modified_value * (1 + mods['percentage'] / 100)

        return modified_value

    def set_base_stat(self, stat_type: Union[StatType, str], value: float) -> None:
        """
        Set the base value of a primary stat.

        Args:
            stat_type: The stat type to set.
            value: The new base value.

        Raises:
            ValueError: If the stat is not found or is not a primary stat.
        """
        if isinstance(stat_type, str):
            try:
                stat_type = StatType.from_string(stat_type)
            except ValueError:
                raise ValueError(f"Unknown primary stat: {stat_type}")

        if stat_type not in self.stats:
            raise ValueError(f"Stat not found: {stat_type}")

        self.stats[stat_type].base_value = value
        logger.debug(f"Set base value of {stat_type} to {value}")

        # Recalculate derived stats that depend on this stat
        self._recalculate_derived_stats()
        
        # Emit signal with current stats
        self.stats_changed.emit(self.get_all_stats())

    def add_modifier(self, modifier: StatModifier) -> None:
        """
        Add a modifier to a stat.

        Args:
            modifier: The modifier to add.
        """
        self.modifier_manager.add_modifier(modifier)

        # If this is a primary stat, recalculate derived stats
        if any(modifier.stat == stat_type for stat_type in StatType):
            self._recalculate_derived_stats()

    def add_modifier_group(self, group: ModifierGroup) -> None:
        """
        Add a group of modifiers.

        Args:
            group: The modifier group to add.
        """
        self.modifier_manager.add_modifier_group(group)

        # Check if any primary stats are affected
        if any(any(modifier.stat == stat_type for stat_type in StatType) for modifier in group.modifiers):
            self._recalculate_derived_stats()

    def remove_modifier(self, modifier_id: str) -> bool:
        """
        Remove a specific modifier by its ID.

        Args:
            modifier_id: The unique ID of the modifier to remove.

        Returns:
            bool: True if the modifier was found and removed, False otherwise.
        """
        result = self.modifier_manager.remove_modifier(modifier_id)

        # Recalculate derived stats
        self._recalculate_derived_stats()
        
        # Emit signal with updated stats
        self.stats_changed.emit(self.get_all_stats())

        return result

    def remove_modifiers_by_source(self, source_type: ModifierSource, source_name: Optional[str] = None) -> int:
        """
        Remove all modifiers from a specific source.

        Args:
            source_type: The type of source to remove modifiers from.
            source_name: Optional specific source name to match.

        Returns:
            int: The number of modifiers removed.
        """
        removed = self.modifier_manager.remove_modifiers_by_source(source_type, source_name)

        if removed > 0:
            # Recalculate derived stats
            self._recalculate_derived_stats()
            
            # Emit signal with updated stats
            self.stats_changed.emit(self.get_all_stats())

        return removed

    def update_durations(self) -> Set[str]:
        """
        Update durations for all temporary modifiers and status effects.
        Removes expired modifiers, groups, and effects.

        Returns:
            Set of IDs of expired modifiers that were removed.
        """
        # Update modifiers
        expired_modifiers = self.modifier_manager.update_durations()

        # Update status effects
        expired_effects = self.status_effect_manager.update_durations()

        if expired_modifiers or expired_effects:
            # Recalculate derived stats
            self._recalculate_derived_stats()
            
            # Emit signal with updated stats
            self.stats_changed.emit(self.get_all_stats())

        # Combine the expired IDs
        expired = expired_modifiers.union(expired_effects)
        return expired

    def add_status_effect(self, effect: StatusEffect) -> None:
        """
        Add a status effect to the character.

        Args:
            effect: The effect to add
        """
        self.status_effect_manager.add_effect(effect)

        # Emit signal with updated stats if the effect has associated stat modifiers
        if effect.modifier_group: # Check for modifier_group instead of stat_modifiers
            # Recalculate derived stats as the group might affect primary stats
            self._recalculate_derived_stats() # Recalculate to be safe
            # Emit signal AFTER recalculating
            self.stats_changed.emit(self.get_all_stats())

    def remove_status_effect(self, effect_id: str) -> bool:
        """
        Remove a status effect by ID.

        Args:
            effect_id: The ID of the effect to remove

        Returns:
            True if the effect was found and removed, False otherwise
        """
        result = self.status_effect_manager.remove_effect(effect_id)
        
        # Emit signal with updated stats if the effect was removed
        if result:
            self.stats_changed.emit(self.get_all_stats())
            
        return result

    def has_status_effect(self, name: str) -> bool:
        """
        Check if the character has a specific status effect.

        Args:
            name: The name of the effect to check for

        Returns:
            True if the effect is active, False otherwise
        """
        return self.status_effect_manager.has_effect(name)

    def get_status_effects(self, effect_type: Optional[StatusEffectType] = None) -> List[StatusEffect]:
        """
        Get all active status effects, optionally filtered by type.

        Args:
            effect_type: Optional type to filter by

        Returns:
            List of active status effects
        """
        if effect_type:
            return self.status_effect_manager.get_effects_by_type(effect_type)
        return list(self.status_effect_manager.active_effects.values())

    def set_level(self, level: int) -> None:
        """
        Set the character level and recalculate derived stats.

        Args:
            level: The new level value.
        """
        if level < 1:
            level = 1

        self.level = level
        logger.debug(f"Set character level to {level}")

        # Recalculate derived stats
        self._recalculate_derived_stats()

    def set_current_stat(self, stat_type: Union[DerivedStatType, str], value: float) -> bool:
            """
            Set the *current* value of a derived stat (like HEALTH, MANA, STAMINA, RESOLVE).
            Handles clamping between 0 and the MAX value.

            Args:
                stat_type: The derived stat type to set (e.g., DerivedStatType.HEALTH).
                value: The new current value.

            Returns:
                True if the value was set successfully, False otherwise.
            """
            if isinstance(stat_type, str):
                try:
                    stat_type = DerivedStatType.from_string(stat_type)
                except ValueError:
                    logger.error(f"Cannot set current value for unknown derived stat: {stat_type}")
                    return False

            if stat_type not in self.derived_stats:
                logger.error(f"Cannot set current value: Derived stat {stat_type} not found.")
                # Attempt to initialize if max exists
                max_stat_type_name = f"MAX_{stat_type.name}"
                max_stat_type = getattr(DerivedStatType, max_stat_type_name, None)

                if max_stat_type and max_stat_type in self.derived_stats:
                    logger.warning(f"Initializing current stat {stat_type.name} based on max value.")
                    # Get the *current* max value, which includes modifiers
                    max_value = self.get_stat_value(max_stat_type)
                    self.derived_stats[stat_type] = Stat(
                        name=stat_type,
                        base_value=max_value, # Start at max
                        category=StatCategory.DERIVED,
                        description=self._get_stat_description(stat_type)
                    )
                else:
                    logger.warning(f"Cannot initialize stat {stat_type.name} as its MAX counterpart ({max_stat_type_name}) is not found.")
                    return False # Cannot set if stat doesn't exist and max doesn't exist

            # Determine the corresponding MAX stat using the name convention
            max_stat_type = getattr(DerivedStatType, f"MAX_{stat_type.name}", None)

            # Get the maximum value (including modifiers)
            max_value = float('inf') # Default to infinity if no max exists
            if max_stat_type:
                try:
                    max_value = self.get_stat_value(max_stat_type)
                except ValueError:
                    logger.warning(f"Could not find MAX stat ({max_stat_type}) for clamping {stat_type}. Using infinity.")


            # Clamp the new value
            clamped_value = max(0.0, min(float(value), max_value)) # Ensure float comparison

            # Check if the value actually changed
            if self.derived_stats[stat_type].base_value != clamped_value:
                self.derived_stats[stat_type].base_value = clamped_value
                logger.debug(f"Set current value of {stat_type} to {clamped_value}")
                # Emit signal *after* changing the value
                self.stats_changed.emit(self.get_all_stats()) # Ensure this line exists and is called
                return True
            else:
                # Value didn't change, no need to emit signal
                logger.debug(f"Value for {stat_type} already {clamped_value}. No change.")
                return False

    def get_resistance_percent(self, damage_type: str) -> float:
        """
        Get aggregated typed resistance percentage for a given damage type.
        Returns a clamped percent in range [-100, cap], where cap is loaded from config
        (defaults to 75 if not configured).
        """
        try:
            # Load cap from config if available; fall back to 75
            cfg = get_config()
            cap = float(cfg.get("combat.defense.magical.resistance_cap", 75))
        except Exception:
            cap = 75.0
        # Sum contributions across all sources for this type
        total = 0.0
        try:
            dt = str(damage_type or "").strip().lower()
            for _src, contrib_map in self._typed_resist_contrib_by_source.items():
                if not isinstance(contrib_map, dict):
                    continue
                val = contrib_map.get(dt)
                if isinstance(val, (int, float)):
                    total += float(val)
        except Exception:
            pass
        # Clamp to [-100, cap]
        if total < -100.0:
            return -100.0
        if total > cap:
            return cap
        return total

    def set_resistance_contribution(self, source_id: str, resistances: Dict[str, float]) -> None:
        """
        Set or update a source contribution to typed resistances.
        - source_id: stable key (e.g., equipment slot or item instance id)
        - resistances: mapping of damage_type -> percent (can be negative for vulnerability)
        """
        if not isinstance(source_id, str) or not source_id.strip():
            return
        src = source_id.strip()
        sanitized: Dict[str, float] = {}
        if isinstance(resistances, dict):
            for k, v in resistances.items():
                try:
                    dt = str(k or "").strip().lower()
                    if not dt:
                        continue
                    val = float(v)
                    sanitized[dt] = val
                except Exception:
                    continue
        self._typed_resist_contrib_by_source[src] = sanitized

    def remove_resistance_contribution(self, source_id: str) -> None:
        """Remove a source's contribution to typed resistances."""
        try:
            if source_id in self._typed_resist_contrib_by_source:
                del self._typed_resist_contrib_by_source[source_id]
        except Exception:
            pass

    def get_current_stat_value(self, stat_type: Union[DerivedStatType, str]) -> float:
        """
        Get the *current* value of a derived stat (like HEALTH, MANA, STAMINA).
        This refers to the base_value of the *current* stat (e.g., HEALTH),
        not the MAX stat (e.g., MAX_HEALTH).

        Args:
            stat_type: The derived stat type (e.g., DerivedStatType.HEALTH).

        Returns:
            The current value, or 0.0 if not found.
        """
        if isinstance(stat_type, str):
            try:
                # Ensure we are looking for the *current* stat, not the MAX stat string
                if stat_type.upper().startswith("MAX_"):
                    logger.warning(f"get_current_stat_value called with MAX stat '{stat_type}'. Use get_stat_value instead.")
                    # Attempt to find corresponding current stat
                    current_stat_name = stat_type[4:] # Remove "MAX_"
                    try:
                        stat_type = DerivedStatType.from_string(current_stat_name)
                    except ValueError:
                        logger.error(f"Could not find current stat corresponding to '{stat_type}'")
                        return 0.0
                else:
                    stat_type = DerivedStatType.from_string(stat_type)
            except ValueError:
                logger.warning(f"Unknown derived stat type string: {stat_type}")
                return 0.0

        # Check if it's a resource stat that should have a current value stored
        resource_stats = [
            DerivedStatType.HEALTH, DerivedStatType.MANA,
            DerivedStatType.STAMINA, DerivedStatType.RESOLVE
        ]
        if stat_type not in resource_stats:
            logger.warning(f"get_current_stat_value called for non-resource stat '{stat_type}'. Returning calculated value.")
            # For non-resource stats, "current" is just the calculated value
            return self.get_stat_value(stat_type)


        stat = self.derived_stats.get(stat_type)
        # Return the base_value which holds the current tracked value for resources
        return stat.base_value if stat else 0.0

    def _recalculate_derived_stats(self) -> None:
        """Recalculate all derived stats based on the current primary stats."""
        logger.debug("Recalculating derived stats...")
        current_percentages = {}
        resource_pairs = [
            (DerivedStatType.HEALTH, DerivedStatType.MAX_HEALTH),
            (DerivedStatType.RESOLVE, DerivedStatType.MAX_RESOLVE),
            (DerivedStatType.MANA, DerivedStatType.MAX_MANA),
            (DerivedStatType.STAMINA, DerivedStatType.MAX_STAMINA)
        ]

        # Store current percentages BEFORE recalculating max values
        for current_stat_type, max_stat_type in resource_pairs:
            # Check if both current and max derived stats exist
            current_stat = self.derived_stats.get(current_stat_type)
            max_stat = self.derived_stats.get(max_stat_type)

            if current_stat and max_stat:
                current_val = current_stat.base_value
                # Use get_stat_value for MAX to include modifiers
                max_val = self.get_stat_value(max_stat_type)
                if max_val > 0:
                    current_percentages[current_stat_type] = current_val / max_val
                else:
                    current_percentages[current_stat_type] = 1.0
            elif current_stat: # Max stat doesn't exist yet
                current_percentages[current_stat_type] = 1.0 # Assume full if max is missing
            # else: # Current stat doesn't exist, nothing to store

        # Recalculate base values for all derived stats (including MAX values)
        for stat_type in DerivedStatType:
            # Skip recalculating the *current* value of resources here
            if stat_type in [DerivedStatType.HEALTH, DerivedStatType.RESOLVE, DerivedStatType.MANA, DerivedStatType.STAMINA]:
                continue

            try:
                # Calculate the base value (typically the MAX value or calculated derived value)
                new_base_value = calculate_derived_stat(
                    stat_type=stat_type,
                    stats=self.stats,
                    level=self.level,
                    config=self.config
                )
                # Ensure the stat exists before setting its base value
                if stat_type not in self.derived_stats:
                    self.derived_stats[stat_type] = Stat(
                        name=stat_type, base_value=0.0, category=StatCategory.DERIVED,
                        description=self._get_stat_description(stat_type)
                    )
                # Update the base_value of the stat (e.g., MAX_HEALTH's base value)
                self.derived_stats[stat_type].base_value = float(new_base_value)
                logger.debug(f"Recalculated base value for {stat_type}: {new_base_value}")

            except ValueError:
                # This occurs if no calculator exists for the stat type
                logger.debug(f"No calculator found for {stat_type}, skipping base value recalculation.")
                # Ensure the stat still exists if it was supposed to
                if stat_type not in self.derived_stats:
                    self.derived_stats[stat_type] = Stat(
                        name=stat_type, base_value=0.0, category=StatCategory.DERIVED,
                        description=self._get_stat_description(stat_type)
                    )
            except Exception as e:
                logger.error(f"Error recalculating derived stat {stat_type}: {e}", exc_info=True)

        # Restore current values based on percentages of the *new* calculated MAX values
        stats_changed_during_recalc = False
        for current_stat_type, max_stat_type in resource_pairs:
            # Ensure both current and max stats exist after recalculation
            if current_stat_type in self.derived_stats and max_stat_type in self.derived_stats:
                # Get the NEW max value (including modifiers)
                new_max_value = self.get_stat_value(max_stat_type)
                percentage = current_percentages.get(current_stat_type, 1.0)
                new_current_value = round(new_max_value * percentage)

                # Clamp the new current value
                clamped_current_value = max(0.0, min(new_current_value, new_max_value))

                # Update the base_value of the *current* stat if it changed
                if self.derived_stats[current_stat_type].base_value != clamped_current_value:
                    self.derived_stats[current_stat_type].base_value = clamped_current_value
                    stats_changed_during_recalc = True
                    logger.debug(f"Restored current value for {current_stat_type}: {clamped_current_value} (Max: {new_max_value})")

            elif max_stat_type in self.derived_stats:
                # Initialize current stat if it was missing but max exists now
                max_value = self.get_stat_value(max_stat_type)
                self.derived_stats[current_stat_type] = Stat(
                    name=current_stat_type, base_value=max_value, category=StatCategory.DERIVED,
                    description=self._get_stat_description(current_stat_type)
                )
                stats_changed_during_recalc = True
                logger.debug(f"Initialized current stat {current_stat_type} to max value: {max_value}")


        # Emit signal only if any value actually changed during the whole process
        if stats_changed_during_recalc:
            logger.debug("Emitting stats_changed signal after recalculation.")
            self.stats_changed.emit(self.get_all_stats())
        else:
            logger.debug("No stat values changed during recalculation, skipping signal emission.")

    def generate_random_stats(self, method: str = "standard", min_value: int = 8, max_value: int = 18) -> None:
        """Generate random stats using various methods.

        Args:
            method: The method to use for stat generation:
                - "standard": 3d6 for each stat
                - "heroic": 4d6 drop lowest for each stat
                - "balanced": Random values with a point total constraint
                - "uniform": Random values between min_value and max_value
            min_value: Minimum stat value (for uniform method)
            max_value: Maximum stat value (for uniform method)
        """
        for stat_type in StatType:
            value = 10  # Default fallback

            if method == "standard":
                # 3d6 (standard D&D style)
                value = sum(random.randint(1, 6) for _ in range(3))

            elif method == "heroic":
                # 4d6 drop lowest (heroic D&D style)
                rolls = [random.randint(1, 6) for _ in range(4)]
                rolls.remove(min(rolls))  # Drop the lowest roll
                value = sum(rolls)

            elif method == "balanced":
                # Random values with a point total constraint
                # Implementation ensures a reasonable total
                remaining_points = 70 - sum(s.base_value for s in self.stats.values())
                min_allowed = max(8, min_value)
                max_allowed = min(15, max_value)
                value = random.randint(min_allowed, max_allowed)
                if remaining_points < 0:
                    value = max(8, value + remaining_points)

            elif method == "uniform":
                # Simple random value in range
                value = random.randint(min_value, max_value)

            # Set the stat value
            self.set_base_stat(stat_type, value)

        # Recalculate derived stats
        self._recalculate_derived_stats()

        logger.debug(f"Generated random stats using {method} method")
        
        # Emit signal with the new stats
        self.stats_changed.emit(self.get_all_stats())

    def roll_stat(self, method: str = "standard") -> int:
        """Roll a single stat value using the specified method.

        Args:
            method: The method to use for rolling ("standard", "heroic")

        Returns:
            The rolled stat value
        """
        if method == "standard":
            # 3d6
            return sum(random.randint(1, 6) for _ in range(3))

        elif method == "heroic":
            # 4d6 drop lowest
            rolls = [random.randint(1, 6) for _ in range(4)]
            rolls.remove(min(rolls))  # Drop the lowest roll
            return sum(rolls)

        else:
            # Fallback
            return 10

    def perform_skill_check(
        self,
        stat_type: Union[StatType, DerivedStatType, str],
        difficulty: int,
        advantage: bool = False,
        disadvantage: bool = False,
        situational_modifier: int = 0,
        skill_name: Optional[str] = None
    ) -> SkillCheckResult:
        """Perform a skill check against a specific stat or using a named skill.

        Args:
            stat_type: The stat to check against
            difficulty: The difficulty class (DC) of the check
            advantage: Whether the check has advantage
            disadvantage: Whether the check has disadvantage
            situational_modifier: Any additional flat modifier applying to this specific check
            skill_name: Optional name of the skill being used (for display purposes)

        Returns:
            A SkillCheckResult object with detailed information

        Raises:
            ValueError: If the stat is not found
        """
        # If a skill name is provided, try to use the SkillManager
        if skill_name:
            try:
                from core.stats.skill_check import perform_skill_check_by_name
                return perform_skill_check_by_name(
                    skill_name=skill_name,
                    difficulty=difficulty,
                    stats_manager=self,
                    advantage=advantage,
                    disadvantage=disadvantage,
                    situational_modifier=situational_modifier
                )
            except (ImportError, AttributeError) as e:
                logger.warning(f"Error using skill-based check: {e}. Falling back to stat-based check.")
                # Fall back to stat-based check if skill check fails
        
        # Get the stat value
        try:
            stat_value = self.get_stat_value(stat_type)
        except ValueError as e:
            logger.error(f"Error getting stat value: {e}")
            # Use a default value if stat is not found
            stat_value = None

        # Calculate the modifier
        try:
            mod = get_modifier_from_stat(stat_value) if stat_value is not None else 0
        except Exception as e:
            logger.error(f"Error calculating modifier: {e}")
            mod = 0

        # Perform the check
        success, roll = perform_check(
            stat_value=stat_value,
            difficulty=difficulty,
            advantage=advantage,
            disadvantage=disadvantage,
            situational_modifier=situational_modifier
        )

        # Create and return the result object
        result = SkillCheckResult(
            stat_type=stat_type,
            stat_value=stat_value,
            difficulty=difficulty,
            roll=roll,
            modifier=mod,
            success=success,
            advantage=advantage,
            disadvantage=disadvantage,
            situational_modifier=situational_modifier,
            skill_name=skill_name
        )

        logger.debug(f"Skill check result: {result}")
        return result

    def calculate_check_probability(
        self,
        stat_type: Union[StatType, DerivedStatType, str],
        difficulty: int,
        advantage: bool = False,
        disadvantage: bool = False
    ) -> float:
        """Calculate the probability of success for a skill check.

        Args:
            stat_type: The stat to check against
            difficulty: The difficulty class (DC) of the check
            advantage: Whether the check has advantage
            disadvantage: Whether the check has disadvantage

        Returns:
            A float between 0 and 1 representing the success probability

        Raises:
            ValueError: If the stat is not found
        """
        # Get the stat value
        stat_value = self.get_stat_value(stat_type)

        # Calculate and return the success probability
        probability = calculate_success_chance(stat_value, difficulty, advantage, disadvantage)
        return probability

    def reset_for_new_game(self) -> None:
        """
        Fully reset this StatsManager for a fresh game session.

        - Clears all modifiers and status effects
        - Resets level to 1
        - Reinitializes primary and derived stats to defaults
        - Ensures current resource values (HP/Resolve/Mana/Stamina) are set to their maxima
        Emits a single stats_changed signal at the end.
        """
        try:
            # Clear modifiers and status effects first, to avoid influencing reinit calculations
            if hasattr(self, 'modifier_manager') and self.modifier_manager:
                self.modifier_manager.clear_all_modifiers()
            if hasattr(self, 'status_effect_manager') and self.status_effect_manager:
                self.status_effect_manager.clear_all_effects()
        except Exception:
            # Best effort; continue reset regardless
            pass

        # Reset level
        self.level = 1

        # Reinitialize stats dictionaries
        self.stats = {}
        self.derived_stats = {}
        # Primary then derived (derived depends on primary)
        self._initialize_primary_stats()
        self._initialize_derived_stats()

        # Ensure resource currents are exactly max after any internal clamping
        try:
            resource_pairs = [
                (DerivedStatType.HEALTH, DerivedStatType.MAX_HEALTH),
                (DerivedStatType.RESOLVE, DerivedStatType.MAX_RESOLVE),
                (DerivedStatType.MANA, DerivedStatType.MAX_MANA),
                (DerivedStatType.STAMINA, DerivedStatType.MAX_STAMINA),
            ]
            for cur_stat, max_stat in resource_pairs:
                max_val = self.get_stat_value(max_stat)
                # Use internal setter for proper clamping and signaling consistency (we'll emit once below)
                if cur_stat in self.derived_stats:
                    self.derived_stats[cur_stat].base_value = max_val
                else:
                    # Initialize if missing
                    self.derived_stats[cur_stat] = Stat(
                        name=cur_stat, base_value=max_val, category=StatCategory.DERIVED,
                        description=self._get_stat_description(cur_stat)
                    )
        except Exception:
            # Non-fatal: if anything goes wrong, the current values will still be sensible
            pass

        # Emit consolidated stats_changed after reset
        try:
            self.stats_changed.emit(self.get_all_stats())
        except Exception:
            pass

    def set_inventory_manager(self, inventory_manager) -> None:
        """
        Set the inventory manager reference for equipment modifier synchronization.
        
        Args:
            inventory_manager: The inventory manager instance
        """
        self._inventory_manager = inventory_manager
        logger.debug("Inventory manager reference set in StatsManager")
        
        # Sync equipment modifiers if available
        if inventory_manager:
            self.sync_equipment_modifiers()
    
    def sync_equipment_modifiers(self) -> None:
        """
        Synchronize equipment modifiers from inventory manager into the modifier system.
        This should be called whenever equipment changes.
        """
        if not self._inventory_manager:
            logger.debug("No inventory manager available for equipment modifier sync")
            return
            
        try:
            # Remove all existing equipment modifiers
            removed_count = self.modifier_manager.remove_modifiers_by_source(ModifierSource.EQUIPMENT)
            if removed_count > 0:
                logger.debug(f"Removed {removed_count} existing equipment modifiers")
            
            # Get current equipment modifiers from inventory manager
            if hasattr(self._inventory_manager, '_equipment_modifiers'):
                equipment_modifiers = self._inventory_manager._equipment_modifiers
                
                # Normalize and synonym map for item stat names -> engine stat keys
                STAT_SYNONYMS = {
                    # Common weapon/attack synonyms
                    'attack_bonus': 'melee_attack',
                    'atk_bonus': 'melee_attack',
                    'spell_focus_bonus': 'magic_attack',
                    'ranged_bonus': 'ranged_attack',
                    # Saves/attributes
                    'willpower_save_bonus': 'willpower',
                    'charisma_save_bonus': 'charisma',
                    'strength_save_bonus': 'strength',
                    # Armor synonyms
                    'armor': 'defense',
                }
                
                # Convert equipment modifiers to StatModifier objects
                for modifier_id, modifier_data in equipment_modifiers.items():
                    try:
                        # Get item name for source identification
                        source_name = f"Item ({modifier_data.get('source_slot', 'Unknown Slot')})"
                        if modifier_data.get('source_item'):
                            item = self._inventory_manager.get_item(modifier_data['source_item'])
                            if item:
                                source_name = item.name
                        
                        # Convert stat name string to appropriate enum
                        raw_stat_name = str(modifier_data.get('stat', '') or '').strip()
                        stat_key = raw_stat_name.lower().replace(' ', '_')
                        stat_key = STAT_SYNONYMS.get(stat_key, stat_key)
                        stat_enum = None
                        
                        # Try StatType first
                        try:
                            stat_enum = StatType.from_string(stat_key)
                        except ValueError:
                            try:
                                stat_enum = DerivedStatType.from_string(stat_key)
                            except ValueError:
                                logger.warning(f"Unknown stat type in equipment modifier: '{raw_stat_name}' (normalized: '{stat_key}') from {source_name}")
                                continue
                        
                        # Create StatModifier object
                        stat_modifier = StatModifier(
                            stat=stat_enum,
                            value=float(modifier_data.get('value', 0)),
                            source_type=ModifierSource.EQUIPMENT,
                            source_name=source_name,
                            modifier_type=ModifierType.PERMANENT,  # Equipment modifiers are permanent while equipped
                            is_percentage=modifier_data.get('is_percentage', False),
                            description=f"Equipment bonus from {source_name}"
                        )
                        
                        # Add the modifier
                        self.modifier_manager.add_modifier(stat_modifier)
                        logger.debug(f"Added equipment modifier: {stat_modifier}")
                        
                    except Exception as e:
                        logger.error(f"Error creating equipment modifier {modifier_id}: {e}")
                        continue
                logger.info(f"Synchronized {len(equipment_modifiers)} equipment modifiers")
            else:
                logger.debug("Inventory manager has no equipment modifiers")
            
            # Recalculate derived stats to account for new modifiers
            self._recalculate_derived_stats()
            
            # Emit stats changed signal
            self.stats_changed.emit(self.get_all_stats())
            
        except Exception as e:
            logger.error(f"Error synchronizing equipment modifiers: {e}", exc_info=True)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "level": self.level,
            "stats": {str(stat_type): stat.to_dict() for stat_type, stat in self.stats.items()},
            "derived_stats": {str(stat_type): stat.to_dict() for stat_type, stat in self.derived_stats.items()},
            "modifiers": self.modifier_manager.to_dict(),
            "status_effects": self.status_effect_manager.to_dict()
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StatsManager':
        """Create a StatsManager from a dictionary."""
        manager = cls()

        # Set level
        manager.level = data.get("level", 1)

        # Load stats
        manager.stats = {}
        for stat_name, stat_data in data.get("stats", {}).items():
            manager.stats[StatType.from_string(stat_name)] = Stat.from_dict(stat_data)

        # Load derived stats
        manager.derived_stats = {}
        for stat_name, stat_data in data.get("derived_stats", {}).items():
            manager.derived_stats[DerivedStatType.from_string(stat_name)] = Stat.from_dict(stat_data)

        # Load modifiers
        if "modifiers" in data:
            manager.modifier_manager = ModifierManager.from_dict(data["modifiers"])

        # Load status effects
        if "status_effects" in data:
            manager.status_effect_manager = StatusEffectManager.from_dict(data["status_effects"], manager)

        return manager

    def is_valid_stat_or_skill(self, name: str) -> bool:
        """
        Check if a given name is a valid stat or skill.
        
        Args:
            name: The name to check
            
        Returns:
            True if the name is a valid stat or skill, False otherwise
        """
        # Check if it's a primary stat
        try:
            StatType.from_string(name)
            return True
        except ValueError:
            pass
            
        # Check if it's a derived stat
        try:
            DerivedStatType.from_string(name)
            return True
        except ValueError:
            pass
            
        # Check if it's a skill
        try:
            skill_name = name.upper()
            if skill_name in [skill.name for skill in Skill]:
                return True
        except (ValueError, AttributeError):
            pass
            
        return False
    
    def get_all_stats(self) -> Dict[str, Dict[str, Any]]:
            """
            Get all stats with their current values, organized by category.

            Returns:
                Dictionary with stat categories as keys and stat info as values.
            """
            result = {
                "primary": {},
                "combat": {},
                "resources": {},
                "social": {},
                "skills": {},
                "other": {}
            }

            # Add primary stats
            for stat_type, stat in self.stats.items():
                stat_name_key = stat_type.name # Use enum name "STR" as key
                result["primary"][stat_name_key] = {
                    "name": str(stat_type), # Keep display name "STR"
                    "value": self.get_stat_value(stat_type),
                    "base_value": stat.base_value,
                    "description": stat.description,
                    # --- REVERTED: Return the calculated value dict ---
                    "modifier_value": self.modifier_manager.get_stat_modifier_value(stat_type)
                }

            # Categorize derived stats
            resource_stats = [DerivedStatType.HEALTH, DerivedStatType.MAX_HEALTH, DerivedStatType.MANA, DerivedStatType.STAMINA]
            combat_stats = [
                DerivedStatType.MELEE_ATTACK, DerivedStatType.RANGED_ATTACK,
                DerivedStatType.MAGIC_ATTACK, DerivedStatType.DEFENSE,
                DerivedStatType.MAGIC_DEFENSE, DerivedStatType.INITIATIVE
            ]
            social_stats = [DerivedStatType.RESOLVE, DerivedStatType.MAX_RESOLVE]

            for stat_type, stat in self.derived_stats.items():
                stat_name_key = stat_type.name # Use enum name like "MELEE_ATTACK" as key
                stat_info = {
                    "name": str(stat_type), # Keep display name like "Melee Attack"
                    "value": self.get_stat_value(stat_type),
                    "base_value": stat.base_value,
                    "description": stat.description,
                    # --- REVERTED: Return the calculated value dict ---
                    "modifier_value": self.modifier_manager.get_stat_modifier_value(stat_type)
                }

                if stat_type in resource_stats:
                    result["resources"][stat_name_key] = stat_info # Use enum name key
                elif stat_type in combat_stats:
                    result["combat"][stat_name_key] = stat_info # Use enum name key
                elif stat_type in social_stats:
                    result["social"][stat_name_key] = stat_info # Use enum name key
                else: # CARRY_CAPACITY, MOVEMENT etc.
                    result["other"][stat_name_key] = stat_info # Use enum name key

            # Add skills (if skill management is implemented and needed here)
            # Example:
            # for skill in Skill:
            #     result["skills"][skill.name] = { ... skill details ... }

            return result
    
    def regenerate_combat_stamina(self) -> Tuple[float, Optional[str]]:
        """
        Regenerates a portion of stamina for the entity at the end of their turn in combat.
        The amount regenerated depends on CON modifier and other potential factors.
        Does not exceed MAX_STAMINA.

        Returns:
            Tuple: (amount_regenerated, narrative_message_for_log)
                Returns (0, None) if no regeneration occurred or stat not found.
        """
        try:
            current_stamina = self.get_current_stat_value(DerivedStatType.STAMINA)
            max_stamina = self.get_stat_value(DerivedStatType.MAX_STAMINA)

            if current_stamina >= max_stamina:
                return 0, None # Already at max

            # Base regeneration (e.g., 1 point + portion of CON modifier)
            con_value = self.get_stat_value(StatType.CONSTITUTION)
            con_mod = get_modifier_from_stat(con_value)
            
            base_regen = self.config.get("combat_stamina_regen_base", 1.0)
            con_regen_factor = self.config.get("combat_stamina_regen_con_factor", 0.5)
            
            regen_amount = base_regen + max(0, math.floor(con_mod * con_regen_factor))

            # Placeholder for STAMINA_REGENERATION stat/modifier
            # Example: regen_modifier_value = self.get_stat_value(DerivedStatType.STAMINA_REGENERATION)
            # regen_amount += regen_modifier_value

            # Placeholder for status effect modifiers
            if self.has_status_effect("Fatigued"): # Assuming StatusEffectManager is on StatsManager
                regen_amount *= 0.5 # Halve regeneration if fatigued
            if self.has_status_effect("Energized"):
                regen_amount *= 1.5 # Increase regeneration if energized
            
            regen_amount = max(0, round(regen_amount)) # Ensure non-negative and integer

            if regen_amount == 0:
                return 0, None

            new_stamina = min(current_stamina + regen_amount, max_stamina)
            actual_regenerated = new_stamina - current_stamina

            if actual_regenerated > 0:
                self.set_current_stat(DerivedStatType.STAMINA, new_stamina) # This emits stats_changed
                
                entity_name = "Entity" # Placeholder, ideally get actual name
                # This manager might not know the entity's name directly.
                # The CombatManager, when calling this, could pass the name for the message.
                # For now, a generic message part.
                
                narrative = f"  {entity_name} recovers {actual_regenerated:.0f} stamina."
                logger.debug(f"Stamina regenerated by {actual_regenerated:.0f} to {new_stamina:.0f}/{max_stamina:.0f}")
                return actual_regenerated, narrative
            
            return 0, None

        except ValueError as e: # e.g. stat not found
            logger.warning(f"Could not regenerate stamina: {e}")
            return 0, None
        except Exception as e:
            logger.error(f"Unexpected error during stamina regeneration: {e}", exc_info=True)
            return 0, None


# Singleton instance for the stats manager
_stats_manager_instance = None

# Convenience function to get the stats manager
def get_stats_manager() -> StatsManager:
    """Get the stats manager instance."""
    global _stats_manager_instance
    if _stats_manager_instance is None:
        _stats_manager_instance = StatsManager()
    
    return _stats_manager_instance

```

### File: core\agents\__init__.py

```python
#!/usr/bin/env python3
"""
Agent module for LLM-powered game agents.

This module provides LLM-powered agents for narrative generation, rule checking,
and context evaluation in the RPG game.
"""

from core.agents.base_agent import BaseAgent, AgentContext, AgentResponse
from core.agents.narrator import NarratorAgent, get_narrator_agent
from core.agents.rule_checker import RuleCheckerAgent, get_rule_checker_agent
from core.agents.context_evaluator import ContextEvaluatorAgent, get_context_evaluator_agent
from core.agents.agent_manager import AgentManager, get_agent_manager

__all__ = [
    'BaseAgent',
    'AgentContext',
    'AgentResponse',
    'NarratorAgent',
    'get_narrator_agent',
    'RuleCheckerAgent',
    'get_rule_checker_agent',
    'ContextEvaluatorAgent',
    'get_context_evaluator_agent',
    'AgentManager',
    'get_agent_manager'
]
```

### File: core\agents\agent_manager.py

```python
"""
Agent manager for coordinating between different agent types.

This module provides an AgentManager class that initializes, coordinates,
and manages interactions between different agent types, including
context evaluation, rule checking, and narrative generation.
"""

import os
import json
import time
from typing import Dict, List, Optional, Any, Tuple, Union
import logging

from core.interaction.enums import InteractionMode
from core.stats.stats_base import DerivedStatType
from core.stats.stats_manager import get_stats_manager
from core.utils.logging_config import get_logger
from core.base.state import GameState
from core.base.commands import get_command_processor
from core.inventory import get_narrative_item_manager, get_inventory_manager
from core.agents.base_agent import AgentContext, AgentResponse
from core.agents.narrator import get_narrator_agent
from core.agents.rule_checker import get_rule_checker_agent
from core.agents.context_evaluator import get_context_evaluator_agent
from core.agents.data_retrieval_commands import process_data_retrieval_command

# Get the module logger
logger = get_logger("AGENT")

class AgentManager:
    """
    Manager for coordinating between different agent types.
    
    This class handles initialization, coordination, and management of
    different agent types, including context evaluation, rule checking,
    and narrative generation.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(AgentManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the agent manager."""
        if self._initialized:
            return
        
        logger.info("Initializing AgentManager")
        
        # Initialize agents
        self._narrator_agent = get_narrator_agent()
        self._rule_checker_agent = get_rule_checker_agent()
        self._context_evaluator_agent = get_context_evaluator_agent()
        
        # Initialize command processor
        self._command_processor = get_command_processor()
        
        # Initialize narrative item manager
        self._narrative_item_manager = get_narrative_item_manager()
        
        # Settings
        self._perform_rule_check = True
        self._perform_context_evaluation = True
        
        self._initialized = True
        logger.info("AgentManager initialized")
    
    def reset_state(self):
        """
        Reset the state of all agents.
        
        This should be called when starting a new game to ensure no state
        from previous games affects the new game's narrative.
        """
        logger.info("Resetting agent state")
        
        try:
            # Reset narrator agent if it has a reset method
            if hasattr(self._narrator_agent, 'reset'):
                self._narrator_agent.reset()
                logger.info("Reset narrator agent state")
            
            # Reset rule checker agent if it has a reset method
            if hasattr(self._rule_checker_agent, 'reset'):
                self._rule_checker_agent.reset()
                logger.info("Reset rule checker agent state")
            
            # Reset context evaluator agent if it has a reset method
            if hasattr(self._context_evaluator_agent, 'reset'):
                self._context_evaluator_agent.reset()
                logger.info("Reset context evaluator agent state")
            
            # Reset narrative item manager if needed
            if hasattr(self._narrative_item_manager, 'reset'):
                self._narrative_item_manager.reset()
                logger.info("Reset narrative item manager state")
        except Exception as e:
            logger.error(f"Error resetting agent state: {e}", exc_info=True)
    
    def reload_settings(self):
        """
        Reload settings for all agents.
        
        This should be called when LLM settings are updated.
        """
        logger.info("Reloading agent settings")
        
        try:
            # Reload settings for each agent
            if hasattr(self._narrator_agent, 'reload_settings'):
                self._narrator_agent.reload_settings()
            
            if hasattr(self._rule_checker_agent, 'reload_settings'):
                self._rule_checker_agent.reload_settings()
            
            if hasattr(self._context_evaluator_agent, 'reload_settings'):
                self._context_evaluator_agent.reload_settings()
            
            logger.info("Agent settings reloaded")
        except Exception as e:
            logger.error(f"Error reloading agent settings: {e}", exc_info=True)
    
    def process_input(self, 
                      game_state: GameState, 
                      player_input: str,
                      perform_rule_check: bool = True,
                      perform_context_evaluation: bool = True) -> Tuple[str, List[Tuple[str, str]]]:
        """
        Process player input through the appropriate agents.
        
        Args:
            game_state: The current game state.
            player_input: The player's input text.
            perform_rule_check: Whether to perform rule checking.
            perform_context_evaluation: Whether to perform context evaluation.
        
        Returns:
            A tuple of (response_text, commands), where commands is a list of
            (command, args) tuples extracted from the response.
        """
        logger.info(f"Processing player input with LLM: {player_input}")
        
        # Update settings
        self._perform_rule_check = perform_rule_check
        self._perform_context_evaluation = perform_context_evaluation
        
        # Create base context
        context = self._create_agent_context(game_state, player_input)

        # Opportunistically prefetch inventory when input is item/inventory-related so validation sees real items
        try:
            lower_in = (player_input or "").lower()
            inventory_triggers = [
                "inventory", "pack", "backpack", "bag", "use ", "consume", "eat", "drink",
                "equip", "unequip", "drop", "take", "pick", "obtain", "get ", "have ", "has ", "hold"
            ]
            should_prefetch_inv = any(t in lower_in for t in inventory_triggers)
            if should_prefetch_inv:
                from core.agents.data_retrieval_commands import get_inventory_data
                pre_inv = get_inventory_data(game_state)
                if pre_inv and isinstance(pre_inv, dict):
                    context.additional_context = {**(context.additional_context or {}), "inventory": pre_inv}
                    logger.info("Prefetched inventory into LLM context based on user input.")
        except Exception as e:
            logger.warning(f"Prefetch inventory failed: {e}")

        # Prefetch quests when the user explicitly asks about them (single-output UX)
        try:
            if isinstance(player_input, str) and "quest" in player_input.lower():
                from core.agents.data_retrieval_commands import get_quest_data
                pre_q = get_quest_data(game_state)
                if pre_q and isinstance(pre_q, dict):
                    context.additional_context = {**(context.additional_context or {}), "quests": pre_q}
                    logger.info("Prefetched quests into LLM context based on user input.")
        except Exception as e:
            logger.warning(f"Prefetch quests failed: {e}")
        
        try:
            # Step 1: Evaluate context
            if self._perform_context_evaluation:
                context = self._evaluate_context(context)
            
            # Step 2: Check rules
            if self._perform_rule_check:
                is_valid, reason = self._check_rules(context)
                
                if not is_valid:
                    # Ensure we have a meaningful error message
                    if not reason:
                        reason = "Unknown rule violation"
                    # Return rule violation message
                    return f"Invalid action: {reason}", []
            
            # Step 3: First phase - Generate initial narrative to check for data retrieval needs
            logger.info("Phase 1: Generating initial narrative to identify data needs...")
            initial_response = self._generate_narrative(context)
            
            # Check if there are any data retrieval commands in the response
            data_commands = [
                (cmd, args) for cmd, args in initial_response.commands 
                if cmd in ["GET_INVENTORY", "GET_STATS", "GET_QUESTS", "GET_LOCATION_INFO"]
            ]
            
            # If data retrieval commands exist, process them and regenerate the narrative
            if data_commands:
                logger.info(f"Found {len(data_commands)} data retrieval commands")
                
                # Process data retrieval commands
                additional_context = {}
                for cmd, args in data_commands:
                    logger.info(f"Processing data retrieval command: {cmd}")
                    
                    # Get data based on command
                    data = process_data_retrieval_command(cmd, args, game_state)
                    
                    # Add to additional context
                    if cmd == "GET_INVENTORY":
                        additional_context["inventory"] = data
                    elif cmd == "GET_STATS":
                        additional_context["character_stats"] = data
                    elif cmd == "GET_QUESTS":
                        additional_context["quests"] = data
                    elif cmd == "GET_LOCATION_INFO":
                        additional_context["location_info"] = data
                
                # Update context with retrieved data
                context.additional_context = {
                    **(context.additional_context or {}),
                    **additional_context
                }
                
                # Step 3.5: Regenerate narrative with enhanced context
                logger.info("Phase 2: Regenerating narrative with retrieved data...")
                response = self._generate_narrative(context)
                # If the regenerated narrative is empty but we have retrieved data, generate a default response
                if (not response.content or len(response.content.strip()) == 0) and additional_context:
                    default_message = "Here is the information you requested:\n\n"
                    
                    if "character_stats" in additional_context:
                        stats = additional_context["character_stats"]
                        default_message += "=== CHARACTER STATS ===\n"
                        if "character" in stats:
                            char_info = stats["character"]
                            default_message += f"Name: {char_info.get('name', 'Unknown')}\n"
                            default_message += f"Race: {char_info.get('race', 'Unknown')}\n"
                            default_message += f"Class: {char_info.get('path', 'Unknown')}\n"
                            default_message += f"Level: {char_info.get('level', 1)}\n"
                        
                        default_message += "\nPrimary Stats:\n"
                        if "primary_stats" in stats:
                            for stat_name, stat_data in stats["primary_stats"].items():
                                default_message += f"- {stat_name}: {stat_data.get('value', 0)}\n"
                        
                        default_message += "\nDerived Stats:\n"
                        if "derived_stats" in stats:
                            for stat_name, stat_data in stats["derived_stats"].items():
                                default_message += f"- {stat_name}: {stat_data.get('value', 0)}\n"
                        
                        default_message += "\nSkills:\n"
                        if "skills" in stats:
                            for skill_name, skill_data in stats["skills"].items():
                                default_message += f"- {skill_name}: {skill_data.get('value', 0)}\n"
                    
                    if "inventory" in additional_context:
                        inventory = additional_context["inventory"]
                        default_message += "\n=== INVENTORY ===\n"
                        if "equipped" in inventory and inventory["equipped"]: # Check if equipped dict is not empty
                            default_message += "Equipped Items:\n"
                            for slot, item_data in inventory["equipped"].items(): # Iterate over items in dict
                                if isinstance(item_data, dict): # Ensure item_data is a dict
                                    default_message += f"- {slot}: {item_data.get('name', 'Unknown Item')}\n"
                                elif item_data: # Fallback if it's just a string/ID (less likely with new structure)
                                    default_message += f"- {slot}: {item_data}\n"
                        else:
                            default_message += "Equipped Items: None\n"

                        if "backpack" in inventory and inventory["backpack"]:
                            default_message += "\nBackpack Items:\n"
                            for item_data in inventory["backpack"]: # Iterate over items in list
                                if isinstance(item_data, dict): # Ensure item_data is a dict
                                    quantity = item_data.get("quantity", 1)
                                    quantity_str = f" (x{quantity})" if quantity > 1 else ""
                                    default_message += f"- {item_data.get('name', 'Unknown Item')}{quantity_str}\n"
                                else: # Fallback if it's just a string/ID
                                    default_message += f"- {item_data}\n"
                        else:
                            default_message += "\nBackpack Items: Empty\n"

                        if "currency" in inventory:
                            currency = inventory["currency"]
                            gold = currency.get("gold", 0)
                            silver = currency.get("silver", 0)
                            copper = currency.get("copper", 0)
                            default_message += f"\nCurrency: {gold}g {silver}s {copper}c\n"
                    
                    if "quests" in additional_context:
                        quests = additional_context["quests"]
                        default_message += "\n=== QUESTS ===\n"
                        if "active_quests" in quests:
                            default_message += "Active Quests:\n"
                            for quest in quests["active_quests"]:
                                if isinstance(quest, dict):
                                    default_message += f"- {quest.get('name', 'Unknown Quest')}\n"
                                    if 'description' in quest:
                                        default_message += f"  {quest['description']}\n"
                                else:
                                    default_message += f"- {quest}\n"
                    
                    if "location_info" in additional_context:
                        location = additional_context["location_info"]
                        default_message += "\n=== LOCATION ===\n"
                        default_message += f"Current Location: {location.get('current_location', 'Unknown')}\n"
                        default_message += f"District/Area: {location.get('current_district', 'Unknown')}\n"
                        if "weather" in location:
                            default_message += f"Weather: {location['weather']}\n"
                    
                    # Update the response with our default message
                    response.content = default_message
                    logger.info("Generated default data retrieval response")
                
                logger.info(f"Received final response from LLM: {len(response.content)} chars")
            else:
                # No data retrieval needed, use the initial response
                logger.info("No data retrieval commands found, using initial response")
                response = initial_response
            
            # Step 4: Process narrative item commands
            processed_text, item_results = self._process_narrative_items(game_state, response.content)
            
            # Update response with processed text
            response.content = processed_text
            
            # Step 5: Process remaining commands in the response
            # Filter out data retrieval commands as they've already been processed
            # Also filter out CONSUME_ITEM commands, as they will be handled by game logic post-narration.
            commands_to_return = []
            for cmd, args in response.commands:
                if cmd in ["GET_INVENTORY", "GET_STATS", "GET_QUESTS", "GET_LOCATION_INFO"]:
                    logger.debug(f"Filtering out already processed data retrieval command: {cmd}")
                    continue
                elif cmd == "CONSUME_ITEM": # This is an example, actual command might differ
                    logger.debug(f"Noting CONSUME_ITEM command for game logic: {cmd} {args}")
                    # This command is now passed through for GameEngine to handle
                    commands_to_return.append((cmd, args))
                else:
                    commands_to_return.append((cmd, args))

            logger.info(f"Extracted {len(commands_to_return)} action commands to return from response")

            # Route special LLM commands (including quest updates) immediately through LLM handlers
            routed_commands: list[tuple[str, str]] = []
            for cmd, args in commands_to_return:
                if cmd in ["MODE_TRANSITION", "QUEST_UPDATE", "QUEST_STATUS"]:
                    try:
                        from core.game_flow.command_handlers import process_llm_command
                        from core.base.engine import get_game_engine
                        engine = get_game_engine()
                        logger.info(f"Routing special LLM command now: {cmd}")
                        # Ensure args are provided as a list of one string per our handler signature
                        _ = process_llm_command(engine, cmd, [args] if not isinstance(args, list) else args, game_state)
                        # We do not append these to the returned list; they are handled immediately
                    except Exception as e:
                        logger.error(f"Error routing LLM command {cmd}: {e}")
                else:
                    routed_commands.append((cmd, args))

            # Return the response text and only the remaining commands (non-LLM-special)
            return response.content, routed_commands
            
        except Exception as e:
            logger.error(f"Error in agent processing: {e}", exc_info=True)
            return f"I'm sorry, but I encountered an error while processing your input: {str(e)}", []
    
    def _create_agent_context(self, game_state: GameState, player_input: str) -> AgentContext:
        """
        Create an agent context from the game state and player input.
        
        Args:
            game_state: The current game state.
            player_input: The player's input text.
        
        Returns:
            An AgentContext object.
        """
        # Extract game state information
        game_state_dict = {}
        player_state_dict = {}
        world_state_dict = {}
        additional_context_for_agent = {} # For specific notes like low stamina

        if game_state:
            # Convert game state to dictionary
            game_state_dict = {
                "session_id": game_state.session_id,
                "created_at": game_state.created_at,
                "last_saved_at": game_state.last_saved_at,
                "game_version": game_state.game_version,
                "last_command": game_state.last_command,
                "mode": game_state.current_mode.name if hasattr(game_state, 'current_mode') else "NARRATIVE"
            }
            
            # Extract player state
            if game_state.player:
                player_state_dict = game_state.player.to_dict()

                # Add note for out-of-combat stamina regeneration consideration
                # Access StatsManager via get_stats_manager() singleton
                player_stats_manager = get_stats_manager()
                if game_state.current_mode == InteractionMode.NARRATIVE and player_stats_manager:
                    try:
                        current_stamina = player_stats_manager.get_current_stat_value(DerivedStatType.STAMINA)
                        max_stamina = player_stats_manager.get_stat_value(DerivedStatType.MAX_STAMINA)
                        if current_stamina < max_stamina:
                            additional_context_for_agent["player_stamina_status"] = (
                                f"Player stamina is {current_stamina:.0f}/{max_stamina:.0f}. "
                                f"Consider if regeneration is appropriate based on recent actions and time passed."
                            )
                            logger.debug(f"Stamina note added to agent context: {additional_context_for_agent['player_stamina_status']}")
                    except Exception as e:
                        logger.warning(f"Could not get player stamina for agent context note: {e}")
            
            # Extract world state
            if game_state.world:
                world_state_dict = game_state.world.to_dict()
        
        # Create agent context
        context = AgentContext(
            game_state=game_state_dict,
            player_state=player_state_dict,
            world_state=world_state_dict,
            player_input=player_input,
            conversation_history=game_state.conversation_history if game_state else [],
            relevant_memories=[],  # Will be populated by context evaluator
            additional_context=additional_context_for_agent if additional_context_for_agent else None
        )
        
        return context
    
    def _evaluate_context(self, context: AgentContext) -> AgentContext:
        """
        Evaluate the context using the context evaluator agent.
        
        Args:
            context: The agent context.
        
        Returns:
            An updated agent context with relevant memories and a context summary.
        """
        logger.info("Evaluating context")
        
        try:
            # Check for cached summary first
            cached_summary = self._context_evaluator_agent.get_cached_summary(context)
            
            if cached_summary:
                # Use cached summary
                context.context_summary = cached_summary
                logger.info("Using cached context summary")
            else:
                # Process context evaluation
                eval_result = self._context_evaluator_agent.evaluate_context(context)
                
                # Update context with evaluation results
                if eval_result:
                    context.context_summary = eval_result.get("context_summary")
                    
                    # In a full implementation, we would retrieve relevant memories
                    # based on the evaluation results and add them to context.relevant_memories
                    
                    logger.info("Context evaluation completed")
                else:
                    logger.warning("Context evaluation failed")
        
        except Exception as e:
            logger.error(f"Error evaluating context: {e}")
            # Proceed without context evaluation
        
        return context
    
    def _check_rules(self, context: AgentContext) -> Tuple[bool, Optional[str]]:
        """
        Check rules using the rule checker agent.
        
        Args:
            context: The agent context.
        
        Returns:
            A tuple of (is_valid, reason), where reason is None if valid.
        """
        logger.info("Checking rules")
        
        try:
            # Special case for welcome narration - always allow it
            if "starting a new game as" in context.player_input and "introduce me to the game world" in context.player_input:
                logger.info("Allowing welcome narration to bypass rule check")
                return True, None
                
            # Use the rule checker's validate_action method
            is_valid, reason = self._rule_checker_agent.validate_action(context)
            
            if is_valid:
                logger.info("Rule check passed")
            else:
                # Make sure reason is not None when action is invalid
                if not reason:
                    reason = "Unknown rule violation"
                logger.info(f"Rule check failed: {reason}")
            
            return is_valid, reason
            
        except Exception as e:
            logger.error(f"Error checking rules: {e}")
            # Proceed with rule check passed by default
            return True, None
    
    def _generate_narrative(self, context: AgentContext) -> AgentResponse:
        """
        Generate narrative using the narrator agent.
        
        Args:
            context: The agent context.
        
        Returns:
            An AgentResponse object with narrative content and commands.
        """
        logger.info("Generating narrative")
        
        # Filter error messages from conversation history to prevent cascading errors
        self._filter_error_messages_from_history(context)
        
        try:
            # Check if narrator agent is available
            if self._narrator_agent is None:
                raise ValueError("Narrator agent is not initialized")
                
            # Log that we're about to call the narrator agent
            logger.info("Calling narrator agent process() method")
            
            # Process the context with the narrator agent
            agent_output = self._narrator_agent.process(context)
            
            # Check if we got a valid response
            if agent_output is None:
                raise ValueError("Narrator agent returned None response")
                
            if "narrative" not in agent_output:
                raise ValueError("Narrator agent returned response without narrative")
            
            # Convert AgentOutput to AgentResponse
            narrative = agent_output.get("narrative", "")
            requests = agent_output.get("requests", [])
            
            # Command conversion - map structured requests to simple commands
            commands = []
            for req in requests:
                if isinstance(req, dict) and "action" in req:
                    action = req["action"]
                    # Format depends on action type
                    if action == "request_skill_check":
                        skill_name = req.get("skill_name", "unknown")
                        difficulty = req.get("difficulty_class", 10)
                        commands.append(("STAT_CHECK", f"{skill_name}:{difficulty}"))
                    elif action == "request_state_change":
                        # Preserve all fields by passing JSON; normalize target_id if only target_entity/target provided
                        import json
                        payload = dict(req)
                        if "target_id" not in payload:
                            payload["target_id"] = (
                                req.get("target_entity") or req.get("target") or req.get("actor_id")
                            )
                        commands.append(("STATE_CHANGE", json.dumps(payload)))
                    elif action == "request_data_retrieval":
                        data_type = req.get("data_type", "unknown")
                        if data_type.upper() in ["INVENTORY", "STATS", "QUESTS", "LOCATION_INFO"]:
                            commands.append((f"GET_{data_type.upper()}", ""))
                    elif action == "request_quest_update":
                        # Pass whole request as JSON payload
                        import json
                        commands.append(("QUEST_UPDATE", json.dumps(req)))
                    elif action == "request_quest_status":
                        import json
                        commands.append(("QUEST_STATUS", json.dumps(req)))
                    elif action == "request_mode_transition":
                        # Add support for mode transitions
                        target_mode = req.get("target_mode", "UNKNOWN")
                        origin_mode = req.get("origin_mode", "UNKNOWN")
                        reason = req.get("reason", "")
                        target_entity_id = req.get("target_entity_id", "")
                        surprise = "true" if req.get("surprise", False) else "false"
                        # Format as a MODE_TRANSITION command
                        commands.append(("MODE_TRANSITION", 
                                       f"{target_mode}:{origin_mode}:{surprise}:{target_entity_id}:{reason}"))
            
            # Create AgentResponse object
            response = AgentResponse(
                content=narrative,
                commands=commands,
                metadata={"structured_requests": requests} 
            )
            
            logger.info("Narrative generation completed successfully")
            logger.debug(f"Generated content: {response.content[:100]}...")
            return response
        
        except Exception as e:
            logger.error(f"Narrator agent failed to get LLM response: {e}", exc_info=True)
            
            # Generate a more specific error message based on the exception type
            error_message = "Error: Narrator agent failed to generate a response."
            
            # Check for specific error types
            if "NoneType object is not subscriptable" in str(e):
                error_message = "Error: Communication with the LLM service failed. The server may be experiencing issues or the API format may have changed."
            elif "api_key" in str(e).lower():
                error_message = "Error: API key issues detected. Please check your LLM provider settings."
            elif "timeout" in str(e).lower():
                error_message = "Error: The LLM service timed out. Please try again later."
            elif "rate limit" in str(e).lower() or "rate_limit" in str(e).lower():
                error_message = "Error: Rate limit exceeded with the LLM service. Please try again in a few moments."
            
            # Return a fallback response with the specific error message
            return AgentResponse(
                content=error_message,
                commands=[],
                metadata={"error": f"narrative_generation_failure: {str(e)}"}
            )

    def _filter_error_messages_from_history(self, context: AgentContext) -> None:
        """
        Filter out error messages from conversation history to prevent cascading errors.
        
        Args:
            context: The agent context containing conversation history.
        """
        if not context.conversation_history:
            return
        
        # Look for error patterns in assistant/gm responses
        error_patterns = [
            "[Narrator Error:",
            "[System Error:",
            "Error:",
            "cannot process",
            "failed to generate",
            "```json", # Don't want raw JSON in history either
            "I'm sorry, but I encountered an error"
        ]
        
        # Create a new filtered history
        filtered_history = []
        removed_count = 0
        
        for entry in context.conversation_history:
            role = entry.get("role", "")
            content = entry.get("content", "")
            
            # Only filter assistant/gm messages, keep all player messages
            if role in ["assistant", "gm"]:
                # Check if the message contains error patterns
                if any(pattern in content for pattern in error_patterns):
                    removed_count += 1
                    # Skip this message - don't add to filtered history
                    continue
            
            # This message passed all filters, keep it
            filtered_history.append(entry)
        
        if removed_count > 0:
            logger.info(f"Filtered {removed_count} error messages from conversation history")
            context.conversation_history = filtered_history    

    def _process_narrative_items(self, game_state: GameState, response_text: str) -> Tuple[str, List[Any]]:
        """
        Process narrative item commands in the response text.
        
        Args:
            game_state: The current game state.
            response_text: The response text from the narrator agent.
        
        Returns:
            A tuple of (processed_text, results).
        """
        logger.info("Processing narrative item commands")
        
        try:
            # Process narrative item commands
            processed_text, results = self._narrative_item_manager.process_narrative_commands(
                response_text, game_state
            )
            
            logger.info(f"Processed {len(results)} narrative item commands")
            return processed_text, results
            
        except Exception as e:
            logger.error(f"Error processing narrative items: {e}", exc_info=True)
            # Return original text if there's an error
            return response_text, []
    
    def process_commands(self, game_state: GameState, commands: List[Tuple[str, str]]) -> List[Any]:
        """
        Process commands extracted from agent responses.
        
        Args:
            game_state: The current game state.
            commands: A list of (command, args) tuples.
        
        Returns:
            A list of command results.
        """
        logger.info(f"Processing {len(commands)} commands")
        
        results = []
        
        for cmd, args in commands:
            try:
                # Import the LLM command handler
                from core.game_flow.command_handlers import process_llm_command
                
                # Get game engine
                from core.base.engine import get_game_engine
                engine = get_game_engine()
                
                # Process special commands directly first
                if cmd == "MODE_TRANSITION":
                    logger.info(f"Handling MODE_TRANSITION command: {args}")
                    result = process_llm_command(engine, cmd, [args], game_state)
                    results.append(result)
                    logger.info(f"MODE_TRANSITION command processed: {result.message}")
                # Process skill checks and other special commands
                elif cmd == "STAT_CHECK" or cmd == "RULE_CHECK":
                    # Process skill check with the rule checker agent
                    result = self._process_skill_check_command(cmd, args, game_state)
                    results.append(result)
                    logger.info(f"Processed skill check command {cmd}")
                else:
                    # Process other commands with the command processor
                    result = self._command_processor.process_llm_commands(
                        game_state, f"{{{cmd} {args}}}"
                    )
                    
                    # Add the result to the list
                    results.append(result)
                    
                    logger.info(f"Processed command {cmd}")
            
            except Exception as e:
                logger.error(f"Error processing command {cmd}: {e}", exc_info=True)
                # Add error result
                results.append((f"Error processing command {cmd}: {e}", []))
        
        return results
        
    def _process_skill_check_command(self, cmd: str, args: str, game_state: GameState) -> Any:
        """
        Process a skill check command.
        
        Args:
            cmd: The command (STAT_CHECK or RULE_CHECK).
            args: The command arguments.
            game_state: The current game state.
            
        Returns:
            The result of the skill check.
        """
        logger.info(f"Processing skill check command: {cmd} {args}")
        
        try:
            # Parse the command arguments
            parts = args.split(':') if ':' in args else args.split()
            
            if len(parts) < 2:
                return {"error": f"Invalid {cmd} command format: {args}"}
                
            # Extract the stat type and difficulty
            stat_type = parts[0].strip().upper()
            difficulty = int(parts[1].strip())
            
            # Extract context if available
            context = parts[2].strip() if len(parts) > 2 else ""
            
            # Use the rule checker's perform_skill_check method
            check_result = self._rule_checker_agent.perform_skill_check(
                stat_type=stat_type,
                difficulty=difficulty,
                context=context
            )
            
            return check_result
        except Exception as e:
            logger.error(f"Error processing skill check command: {e}")
            return {"error": f"Error processing skill check: {str(e)}"}
        


# Convenience function
def get_agent_manager() -> AgentManager:
    """Get the agent manager instance."""
    return AgentManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create an agent manager
    manager = get_agent_manager()
    
    # Create a dummy game state for testing
    from core.base.state import GameState, PlayerState, WorldState
    
    game_state = GameState(
        player=PlayerState(
            name="Test Player",
            race="Human",
            path="Wanderer",
            background="Commoner",
            current_location="Test Town",
            current_district="Town Square"
        ),
        world=WorldState()
    )
    
    # Add some conversation history
    game_state.add_conversation_entry("player", "Hello, world!")
    game_state.add_conversation_entry("gm", "Welcome to the game!")
    
    # Process player input
    response_text, commands = manager.process_input(
        game_state=game_state,
        player_input="I look around to see what's in the town square."
    )
    
    # Print the response
    print(f"Response: {response_text}")
    
    if commands:
        print("\nCommands:")
        for cmd, args in commands:
            print(f"  {cmd}: {args}")

```

### File: core\agents\base_agent.py

```python
#!/usr/bin/env python3
"""
Base agent for LLM-powered game agents.

This module provides a BaseAgent class that defines the common interface
and functionality for all agent types (Narrator, RuleChecker, ContextEvaluator).
"""

import os
import json
import datetime
from typing import Dict, List, Optional, Any, Tuple, Union
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass

from core.utils.logging_config import get_logger
from core.base.config import get_config
from core.llm.llm_manager import LLMManager, LLMResponse, LLMRole, get_llm_manager
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = get_logger("AGENT")

@dataclass
class AgentContext:
    """
    Context for an agent.
    
    This dataclass contains the context information provided to an agent
    for processing a request, including game state, player input, and
    relevant memories.
    """
    # Game state information
    game_state: Dict[str, Any]
    player_state: Dict[str, Any]
    world_state: Dict[str, Any]
    
    # Input and history
    player_input: str
    conversation_history: List[Dict[str, Any]]
    
    # Memory context (if applicable)
    relevant_memories: List[Dict[str, Any]] = None
    
    # Additional context
    context_summary: Optional[str] = None
    additional_context: Optional[Dict[str, Any]] = None


@dataclass
class AgentResponse:
    """
    Response from an agent.
    
    This dataclass contains the response generated by an agent,
    including the output text, any extracted commands, and metadata.
    """
    # Output text
    content: str
    
    # Extracted LLM commands (if any)
    commands: List[Tuple[str, str]] = None
    
    # Metadata
    metadata: Dict[str, Any] = None
    
    # LLM response details
    llm_response: Optional[LLMResponse] = None
    
    # Timestamp
    timestamp: str = None
    
    def __post_init__(self):
        """Initialize default values."""
        if self.commands is None:
            self.commands = []
        
        if self.metadata is None:
            self.metadata = {}
        
        if self.timestamp is None:
            self.timestamp = datetime.datetime.now().isoformat()


class BaseAgent(ABC):
    """
    Base class for all agents.
    
    This abstract class defines the common interface and functionality
    for all agent types (Narrator, RuleChecker, ContextEvaluator).
    """
    
    def __init__(self, agent_name: str, agent_id: Optional[str] = None):
        """
        Initialize the base agent.
        
        Args:
            agent_name: The name of the agent.
            agent_id: Optional unique identifier for the agent.
        """
        self.agent_name = agent_name
        self.agent_id = agent_id or f"{agent_name.lower()}_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        # Get configuration
        self._config = get_config()
        
        # Get LLM manager
        self._llm_manager = get_llm_manager()
        
        # Load agent settings
        self._settings = self._load_agent_settings()
        
        # Set provider settings
        self._provider_type = self._get_provider_type()
        self._model = self._settings.get("model", None)
        self._temperature = self._settings.get("temperature", 0.7)
        
        logger.info(f"Initialized {self.agent_name} agent (ID: {self.agent_id})")
    
    def _load_agent_settings(self) -> Dict[str, Any]:
        """
        Load agent settings from configuration.
        
        Returns:
            Dictionary of agent settings.
        """
        # Default settings
        default_settings = {
            "provider_type": None,  # Use system default
            "model": None,  # Use provider default
            "temperature": 0.7,
            "max_tokens": 1000,
            "timeout_seconds": 30,
            "system_prompt_template": "You are {agent_name}, a helpful assistant for an RPG game.",
            "include_conversation_history": True,
            "include_memories": True,
            "max_conversation_entries": 10,
            "max_memory_entries": 5
        }
        
        # Try to load agent-specific settings
        agent_settings_path = os.path.join("config", "llm", "agents", f"{self.agent_name.lower()}.json")
        
        if os.path.exists(agent_settings_path):
            try:
                with open(agent_settings_path, 'r', encoding='utf-8') as f:
                    agent_settings = json.load(f)
                
                # Merge with default settings
                merged_settings = {**default_settings, **agent_settings}
                logger.info(f"Loaded settings for {self.agent_name} agent from {agent_settings_path}")
                return merged_settings
            
            except Exception as e:
                logger.error(f"Error loading agent settings: {e}")
                logger.info(f"Using default settings for {self.agent_name} agent")
                return default_settings
        
        # If no agent-specific settings file exists, create one with default settings
        try:
            os.makedirs(os.path.dirname(agent_settings_path), exist_ok=True)
            with open(agent_settings_path, 'w', encoding='utf-8') as f:
                json.dump(default_settings, f, indent=4)
            logger.info(f"Created default settings file for {self.agent_name} agent at {agent_settings_path}")
        except Exception as e:
            logger.error(f"Error creating default agent settings file: {e}")
        
        return default_settings
    
    def _get_provider_type(self) -> ProviderType:
        """
        Get the provider type for this agent.
        
        Returns:
            The provider type enum value.
        """
        provider_type_str = self._settings.get("provider_type")
        
        if provider_type_str and provider_type_str != "None":
            try:
                return ProviderType[provider_type_str]
            except (KeyError, ValueError):
                logger.warning(f"Invalid provider type: {provider_type_str}. Using system default.")
        
        # Use system default
        default_provider = self._llm_manager._provider_manager.get_default_provider()
        if not default_provider:
            logger.error(f"No default provider available for {self.agent_name} agent")
            # Fall back to OPENAI if we have no default
            return ProviderType.OPENAI
            
        return default_provider
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the agent.
        
        This method should be overridden by subclasses to provide
        agent-specific system prompts.
        
        Args:
            context: The agent context.
        
        Returns:
            The system prompt string.
        """
        # Get the template
        template = self._settings.get("system_prompt_template", 
                                     "You are {agent_name}, a helpful assistant for an RPG game.")
        
        # Format with agent name
        system_prompt = template.format(agent_name=self.agent_name)
        
        return system_prompt
    
    def _format_conversation_history(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Format conversation history for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        if not self._settings.get("include_conversation_history", True):
            return messages
        
        # Get the max number of entries to include
        max_entries = self._settings.get("max_conversation_entries", 10)
        
        # Get the most recent entries
        recent_history = context.conversation_history[-max_entries:] if context.conversation_history else []
        
        # Format each entry as a message
        for entry in recent_history:
            role = entry.get("role", "user")
            content = entry.get("content", "")
            
            # Map game roles to LLM roles
            if role == "player":
                messages.append({"role": "user", "content": content})
            elif role == "gm":
                messages.append({"role": "assistant", "content": content})
            elif role == "system":
                # Skip system messages in conversation history
                continue
            else:
                # For unknown roles, use user role
                messages.append({"role": "user", "content": f"[{role}] {content}"})
        
        return messages
    
    def _format_memories(self, context: AgentContext) -> str:
        """
        Format memory context for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted memory context string.
        """
        if not context.relevant_memories or not self._settings.get("include_memories", True):
            return ""
        
        memory_lines = ["### Relevant Memories:"]
        
        # Get the max number of entries to include
        max_entries = self._settings.get("max_memory_entries", 5)
        
        # Format each memory entry
        for i, memory in enumerate(context.relevant_memories[:max_entries]):
            # Extract memory details
            content = memory.get("content", "")
            importance = memory.get("importance", 0)
            timestamp = memory.get("timestamp", "")
            
            memory_lines.append(f"{i+1}. [{importance}] {content} ({timestamp})")
        
        return "\n".join(memory_lines)
    
    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        # Add system prompt
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        
        # Add conversation history
        history_messages = self._format_conversation_history(context)
        messages.extend(history_messages)
        
        # Prepare the user message with the current input
        user_message = context.player_input
        
        # Add memory context if available
        memory_context = self._format_memories(context)
        if memory_context:
            user_message = f"{memory_context}\n\n{user_message}"
        
        # Add context summary if available
        if context.context_summary:
            user_message = f"{context.context_summary}\n\n{user_message}"
        
        # Add the user message
        messages.append({"role": "user", "content": user_message})
        
        return messages
    
    def process(self, context: AgentContext) -> AgentResponse:
        """
        Process a request with the agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The agent response.
        """
        logger.info(f"Processing request with {self.agent_name} agent")
        
        # Prepare messages for the LLM
        messages = self._prepare_messages(context)
        
        # Get completion from LLM
        try:
            # Ensure we have valid provider and model
            if not self._provider_type:
                logger.warning(f"No provider type set for {self.agent_name} agent. Using default.")
                self._provider_type = self._llm_manager._provider_manager.get_default_provider()
                if not self._provider_type:
                    self._provider_type = ProviderType.OPENAI
            
            # If model is None or empty, use provider default
            effective_model = self._model
            if not effective_model:
                logger.warning(f"No model set for {self.agent_name} agent. Using provider default.")
                effective_model = None  # This will make LLMManager use the provider default
            
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=effective_model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1000),
                timeout=self._settings.get("timeout_seconds", 30)
            )
        except Exception as e:
            logger.error(f"Error getting LLM completion: {e}")
            return AgentResponse(
                content=f"Error: {self.agent_name} agent failed to generate a response.\nError details: {str(e)}",
                metadata={"error": "llm_failure", "error_details": str(e)}
            )
        
        if not llm_response:
            logger.error(f"{self.agent_name} agent failed to get LLM response")
            return AgentResponse(
                content=f"Error: {self.agent_name} agent failed to generate a response.",
                metadata={"error": "llm_failure"}
            )
        
        # Process the LLM response
        content = llm_response.content
        
        # Extract any commands from the content
        commands = self._extract_commands(content)
        
        # Create response
        response = AgentResponse(
            content=content,
            commands=commands,
            metadata={
                "agent_name": self.agent_name,
                "agent_id": self.agent_id,
                "provider": llm_response.provider_type.name,
                "model": llm_response.model,
                "tokens": llm_response.total_tokens,
                "cost": llm_response.cost
            },
            llm_response=llm_response
        )
        
        logger.info(f"{self.agent_name} agent generated response ({llm_response.total_tokens} tokens)")
        return response
    
    def _extract_commands(self, text: str) -> List[Tuple[str, str]]:
        """
        Extract LLM commands from text.
        
        Args:
            text: The text to extract commands from.
        
        Returns:
            A list of (command, args) tuples.
        """
        # Use the CommandProcessor's extract method
        from core.base.commands import get_command_processor
        
        command_processor = get_command_processor()
        return command_processor.extract_llm_commands(text)
    
    def reload_settings(self):
        """
        Reload agent settings from configuration file.
        
        This should be called when LLM settings are updated in the UI.
        """
        self._settings = self._load_agent_settings()
        self._provider_type = self._get_provider_type()
        self._model = self._settings.get("model", None)
        self._temperature = self._settings.get("temperature", 0.7)
        
        logger.info(f"Reloaded settings for {self.agent_name} agent")
    
    @abstractmethod
    def supports_command(self, command: str) -> bool:
        """
        Check if this agent supports a specific command.
        
        Args:
            command: The command name.
        
        Returns:
            True if the agent supports the command, False otherwise.
        """
        pass


# Example implementation (for demonstration purposes)
class TestAgent(BaseAgent):
    """
    Test implementation of BaseAgent.
    
    This is a simple implementation for testing and demonstrating the BaseAgent functionality.
    """
    
    def __init__(self):
        """Initialize the test agent."""
        super().__init__("TestAgent")
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """Generate system prompt for test agent."""
        return (
            "You are TestAgent, a simple agent for testing the BaseAgent functionality.\n"
            "You should respond briefly and directly to user inputs."
        )
    
    def supports_command(self, command: str) -> bool:
        """Check if the test agent supports a command."""
        # Test agent supports TEST_COMMAND
        return command == "TEST_COMMAND"


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create a test agent
    test_agent = TestAgent()
    
    # Create a test context
    context = AgentContext(
        game_state={},
        player_state={"name": "Test Player"},
        world_state={"location": "Test Location"},
        player_input="Hello, agent!",
        conversation_history=[
            {"role": "player", "content": "Hello, world!", "timestamp": "2023-01-01T12:00:00"},
            {"role": "gm", "content": "Welcome to the game!", "timestamp": "2023-01-01T12:00:01"}
        ]
    )
    
    # Process the request
    response = test_agent.process(context)
    
    # Print the response
    print(f"Response: {response.content}")
    print(f"Metadata: {response.metadata}")
    
    if response.commands:
        print("Commands:")
        for cmd, args in response.commands:
            print(f"  {cmd}: {args}")

```

### File: core\agents\combat_narrator.py

```python
#!/usr/bin/env python3
"""
Combat Narrator agent for handling combat interactions.
"""

import re
import json
import logging
from typing import List, Dict, Any, Optional

from core.combat.combat_manager import CombatManager
from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode
from core.stats.stats_base import Skill

logger = get_logger("AGENT")

class CombatNarratorAgent(BaseAgent):
    """
    Agent responsible for narrating combat and interpreting player/NPC actions within combat.

    It receives combat-specific context and player/NPC input, generates narrative
    describing the action's attempt, and identifies necessary skill checks
    or state changes requested by the intent.
    """

    def __init__(self):
        """Initialize the combat narrator agent."""
        super().__init__("CombatNarrator")

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the combat narrator agent.
        """
        # --- Context Extraction (Use combat_name where appropriate) ---
        player_id_internal = context.player_state.get("id", "player")
        combat_context = context.additional_context.get("combat_context", {})
        participants_data = context.additional_context.get("participants", []) # Get full participant data
        turn_order_ids = combat_context.get("turn_order", [])
        current_turn_internal_id = combat_context.get("current_turn", "Unknown")

        # Create mapping from internal ID to combat name for easier lookup
        id_to_combat_name = {p.get('id', 'N/A'): p.get('combat_name', p.get('name', 'Unknown')) for p in participants_data}

        turn_order_str = ", ".join([id_to_combat_name.get(p_id, '?') for p_id in turn_order_ids]) # Use combat names
        current_turn_combat_name = id_to_combat_name.get(current_turn_internal_id, "Unknown")

        participant_list_parts = []
        player_combat_name = "Player" # Default

        for p in participants_data:
            p_internal_id = p.get('id', 'N/A')
            p_combat_name = id_to_combat_name.get(p_internal_id, p.get('name', 'Unknown')) # Get combat name via mapping

            if p_internal_id == player_id_internal:
                player_combat_name = p_combat_name # Store player's combat name

            # Format status effects (assuming dict {name: duration/data})
            effects = p.get('status_effects', {})
            effects_str_parts = []
            if isinstance(effects, dict):
                for name, duration_data in effects.items():
                    duration = None
                    if isinstance(duration_data, int):
                        duration = duration_data
                    elif isinstance(duration_data, dict): # Handle StatusEffectData dicts
                        duration = duration_data.get('duration')

                    if duration is None:
                        effects_str_parts.append(str(name))
                    else:
                        effects_str_parts.append(f"{name}({duration}t)") # Use 't' for turns
            elif isinstance(effects, (list, set)): # Fallback for list/set format
                effects_str_parts = [str(eff) for eff in effects]

            effects_str = f" Effects: [{', '.join(effects_str_parts)}]" if effects_str_parts else ""

            # Get HP/Stamina safely
            hp = p.get('hp', '?')
            max_hp = p.get('max_hp', '?')
            stamina = p.get('stamina', '?') # Assuming stamina might be in context now
            max_stamina = p.get('max_stamina', '?')

            participant_list_parts.append(
                f"- Combat Name: '{p_combat_name}' (Original: {p.get('name', 'Unknown')}, "
                f"HP: {hp}/{max_hp}, "
                f"Stamina: {stamina}/{max_stamina})"
                f"{effects_str}"
            )
        participant_list = "\n".join(participant_list_parts)

        round_num = combat_context.get("round", 1)

        # --- Load Skills (existing logic) ---
        try:
            from core.stats.skill_manager import get_skill_manager
            skill_manager = get_skill_manager()
            available_skills = skill_manager.get_skill_list_for_llm()
        except Exception as e:
            logger.warning(f"Could not load skills from SkillManager: {e}. Using defaults.")
            available_skills = """Available skills for checks (use exact names):
    - MELEE_ATTACK: Physical close-range combat attacks
    - RANGED_ATTACK: Physical ranged combat attacks
    - UNARMED_ATTACK: Attacking without weapons
    - SPELL_ATTACK: Magical attacks
    - DEFENSE: Blocking or parrying attacks
    - DODGE: Avoiding attacks and obstacles"""

        # --- SYSTEM PROMPT (Emphasize Combat Names) ---
        system_prompt = f"""You are the Combat Narrator AI for a text-based RPG. Your role is to process combat action INTENT, describe the attempted action, and output the corresponding game mechanics as structured requests.

        ## CRITICAL INSTRUCTION: JSON OUTPUT ONLY & COMBAT NAMES
        Your *ENTIRE* response MUST be a single, valid JSON object. NO introductory text, explanations, markdown, or other characters outside the JSON structure.
        **VERY IMPORTANT**: When referring to entities in the `"requests"` list (`actor_id`, `target_actor_id`, `target_entity`), YOU MUST use their **Combat Name** exactly as listed in the 'Participants' section below (e.g., 'Qa', 'elder', 'Goblin 1'). Do **NOT** use original names or generic terms like 'player'.

        ## Required Output Format (JSON Object Only)
        ```json
        {{
        "narrative": "Your descriptive text about the ATTEMPTED combat action. Describe the wind-up, movement, target, etc. Focus on the *attempt*, NOT the outcome (success/failure). Do NOT repeat the input intent verbatim.",
        "requests": [
            // REQUIRED: Include one or more structured requests based on the action intent.
            // Use the examples below ONLY as structural guides. DO NOT use the specific values from the examples.
            // --- Example 1: Physical Attack (Melee/Ranged/Unarmed) ---
            {{
            "action": "request_skill_check",
            "actor_id": "[ACTOR_COMBAT_NAME]", // **USE COMBAT NAME** of the entity performing the action (from Current Turn context)
            "skill_name": "[ATTACK_SKILL_NAME]", // MELEE_ATTACK, RANGED_ATTACK, or UNARMED_ATTACK
            "stat_name": "[PHYSICAL_STAT]", // Typically STRENGTH or DEXTERITY
            "target_actor_id": "[TARGET_COMBAT_NAME]", // **USE COMBAT NAME** of the target entity (from Action Intent or Participants list)
            "difficulty_class": "[ESTIMATED_DEFENSE]", // Target's Defense score - Estimate 10-15 if unknown
            "modifiers": {{}}, // Optional: {{"circumstance_bonus": 2}}
            "context": "[Brief context, e.g., 'Actor attacking Target with weapon_name']"
            }},
            // --- Example 2: Spell Attack ---
            {{
            "action": "request_skill_check",
            "actor_id": "[ACTOR_COMBAT_NAME]", // **USE COMBAT NAME**
            "skill_name": "SPELL_ATTACK",
            "stat_name": "[SPELLCASTING_STAT]", // Typically INTELLIGENCE, WISDOM, or CHARISMA
            "target_actor_id": "[TARGET_COMBAT_NAME]", // **USE COMBAT NAME**
            "difficulty_class": "[ESTIMATED_MAGIC_DEFENSE]", // Target's Magic Defense or Save DC estimate (10-15)
            "modifiers": {{}},
            "context": "[Brief context, e.g., 'Actor casting spell_name at Target']"
            }},
            // --- Example 3: Applying Status Effect ---
            {{
            "action": "request_state_change",
            "target_entity": "[TARGET_COMBAT_NAME]", // **USE COMBAT NAME**
            "attribute": "add_status_effect", // Or "remove_status_effect"
            "change_type": "set", // Usually 'set' for effects
            "value": "[EFFECT_NAME]", // String name (e.g., BURNING, STUNNED, DEFENDING)
            "duration": "[DURATION_TURNS]", // Optional: Integer number of turns
            "context": "[Brief context, e.g., 'Result of spell hitting target']"
            }}
            // Add other request types (like Defend via state change) as needed.
        ]
        }}
        ```

        ## Current Combat State (Round {round_num})
        - Participants (Use **'Combat Name'** for IDs in JSON requests):
    {participant_list}
        - Turn Order (Combat Names): {turn_order_str}
        - Current Turn: '{current_turn_combat_name}'
        - Player Combat Name: '{player_combat_name}'

        ## Available Skills for Checks (Use ONLY these skill names in `skill_name`)
    {available_skills}

        ## Task: Process Action Intent into JSON Output
        Given the current combat state and the 'Action Intent to Process' below:
        1.  **Narrate Attempt:** Describe the action attempt. DO NOT determine success/failure.
        2.  **Determine Mechanics & Target:**
            *   Analyze the 'Action Intent'. Identify the intended action type (physical attack, spell, defend, etc.) and the intended target (by name or description).
            *   Find the Target **Combat Name**: Match the intended target name/description from the intent to a participant in the 'Participants' list. Use the corresponding **Combat Name** for `target_actor_id` or `target_entity`. **CRITICAL: Use ONLY Combat Names listed in the 'Participants' section.**
            *   Find the Actor **Combat Name**: Use the name provided in 'Current Turn'.
        3.  **Select Skill & Stat:** Choose the most appropriate `skill_name` from the 'Available Skills' list. Determine the likely primary `stat_name`.
        4.  **Construct Request(s):** Create the JSON request object(s).
            *   Use the correct Actor **Combat Name** and Target **Combat Name** found in step 2.
            *   Fill in other fields (`skill_name`, `stat_name`, `difficulty_class`, etc.) based on the action. For attacks, estimate target defenses (10-15) if unknown.
        5.  **Output JSON:** Ensure the final output is ONLY the valid JSON object. NO EXTRA TEXT.

        ## Action Intent to Process:
        ```
        {context.player_input}
        ```

        ## REMEMBER: YOUR ENTIRE RESPONSE MUST BE A SINGLE VALID JSON OBJECT. USE ONLY **COMBAT NAMES** FOR IDs.
        """
        return system_prompt

    # TODO: Add method CombatNarratorAgent.narrate_outcome(action_result, combat_manager)
    # This method would take the result dictionary from perform_action and generate narrative.
    # It would need its own system prompt focused on describing outcomes.

    def _format_combat_context(self, context: AgentContext) -> str:
        """ Formats the combat specific context """
        combat_context = context.additional_context.get("combat_context", {})
        if not combat_context:
            return ""

        lines = ["## Combat Situation"]
        participants = combat_context.get("participants", [])
        turn_order = combat_context.get("turn_order", [])
        current_turn = combat_context.get("current_turn", "Unknown")
        round_num = combat_context.get("round", 1)

        lines.append(f"- Round: {round_num}")
        lines.append(f"- Current Turn: {current_turn}")
        lines.append(f"- Turn Order: {', '.join(turn_order)}")
        lines.append("### Participants:")
        for p in participants:
            # Assuming status_effects is now a dict {name: duration}
            status_str = ", ".join(p.get('status_effects', {}).keys())
            lines.append(f"- {p.get('name', 'Unknown')} (ID: {p.get('id', 'N/A')}, HP: {p.get('hp', '?')}/{p.get('max_hp', '?')}, Stamina: {p.get('stamina', '?')}/{p.get('max_stamina', '?')}, Status: {status_str or 'Normal'})") # Added Stamina

        environment_tags = context.additional_context.get("environment", [])
        if environment_tags:
            lines.append("### Environmental Features:")
            lines.append(f"- Tags: {', '.join(environment_tags)}")

        return "\n".join(lines)

    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list specifically for the Combat Narrator.
        """
        messages = []
        # Generate the system prompt with the actual input substituted
        final_system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": final_system_prompt})
        # Note: We do NOT add conversation history or a separate user message here,
        # as the entire context and the specific action intent are baked into the system prompt.
        logger.debug(f"Prepared messages for CombatNarrator (System Prompt Only):\n{messages[0]['content'][:500]}...") # Log start of prompt
        return messages

    def process(self, context: AgentContext) -> Optional[AgentOutput]:
        """
        Process a combat request, expecting a structured JSON output.

        Args:
            context: The context for the request.

        Returns:
            An AgentOutput dictionary containing the narrative and structured requests, or None on failure.
        """
        # Log the mode being processed and the player input
        mode = context.additional_context.get('mode', 'N/A')
        player_input = context.player_input if hasattr(context, 'player_input') else 'No input'
        logger.info(f"Processing request with CombatNarrator agent. Mode: {mode}, Intent: '{player_input[:50]}...'")

        messages = self._prepare_messages(context)
        agent_output: Optional[AgentOutput] = None # Initialize

        try:
            # --- LLM Call ---
            effective_model = self._model or None
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=effective_model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1000),
                timeout=self._settings.get("timeout_seconds", 30)
            )

            if not llm_response or not llm_response.content:
                raise ValueError("LLM returned empty response or content.")

            llm_response_content = llm_response.content.strip()
            logger.debug(f"Raw LLM Response (Combat):\n```\n{llm_response_content}\n```")

            # --- Enhanced JSON Parsing ---
            parsed_output = None
            cleaned_response = llm_response_content
            try:
                 # 1. Remove potential markdown fences first
                cleaned_response = re.sub(r'^```(?:json)?\s*|\s*```$', '', cleaned_response, flags=re.MULTILINE).strip()

                # 2. Try direct parsing
                parsed_output = json.loads(cleaned_response)
                logger.debug("Successfully parsed JSON directly.")

            except json.JSONDecodeError as e:
                logger.warning(f"Initial JSON parsing failed: {e}. Trying to extract JSON object...")
                # 3. If direct parsing fails, try to find the first '{' and last '}'
                start_index = cleaned_response.find('{')
                end_index = cleaned_response.rfind('}')
                if start_index != -1 and end_index != -1 and start_index < end_index:
                    json_substring = cleaned_response[start_index : end_index + 1]
                    try:
                        parsed_output = json.loads(json_substring)
                        logger.info("Successfully parsed extracted JSON substring.")
                    except json.JSONDecodeError as e_inner:
                        logger.error(f"Failed to parse extracted JSON substring: {e_inner}")
                        logger.error(f"Substring attempted: ```\n{json_substring}\n```")
                        parsed_output = None # Ensure it's None if second parse fails
                else:
                    logger.error("Could not find valid JSON object markers '{' and '}' in the response.")
                    parsed_output = None

            # --- Validate Structure and Build Output ---
            if (isinstance(parsed_output, dict) and
                "narrative" in parsed_output and
                "requests" in parsed_output and
                isinstance(parsed_output["requests"], list)):

                # Validate requests format (basic check)
                validated_requests = []
                for req in parsed_output["requests"]:
                    if isinstance(req, dict) and "action" in req:
                        validated_requests.append(req)
                    else:
                        logger.warning(f"Skipping invalid request structure: {req}")

                agent_output = {
                    "narrative": parsed_output["narrative"],
                    "requests": validated_requests
                }
                narrative_snippet = parsed_output["narrative"][:100]
                logger.info(f"Successfully parsed valid JSON response. Narrative: '{narrative_snippet}...', Requests: {len(validated_requests)}")

            else: # Parsing failed or structure invalid
                logger.error("Failed to parse LLM response as valid JSON AgentOutput.")
                # **Fallback:** Create a default basic attack request if parsing fails during combat
                # This prevents combat from stalling completely if the LLM messes up JSON.
                if context.game_state.get("mode") == InteractionMode.COMBAT:
                    logger.warning("Applying fallback: Generating basic attack request due to JSON failure.")
                    # Find a likely target (first enemy)
                    target_id = None
                    combat_context = context.additional_context.get("combat_context", {})
                    participants = combat_context.get("participants", [])
                    player_id = context.player_state.get("id", "player")
                    for p in participants:
                        p_id = p.get('id')
                        p_type = p.get('entity_type') # Assuming type is available
                        if p_id != player_id and p_type == 'ENEMY': # Find first enemy
                             target_id = p_id
                             break

                    if target_id:
                        fallback_request = {
                            "action": "request_skill_check",
                            "actor_id": player_id,
                            "skill_name": "MELEE_ATTACK", # Assume basic melee
                            "stat_name": "STRENGTH",
                            "target_actor_id": target_id,
                            "difficulty_class": 12, # Default guess
                            "modifiers": {},
                            "context": f"Fallback: Actor basic attack on {target_id}."
                        }
                        agent_output = {
                            "narrative": f"{context.player_state.get('name', 'Actor')} attempts a basic attack on {target_id}. (LLM response parsing failed)",
                            "requests": [fallback_request]
                        }
                        logger.info("Generated fallback basic attack request.")
                    else:
                         # If no target found, return error narrative
                         agent_output = {
                             "narrative": "You attempt an action, but something goes wrong. (LLM Response Error)",
                             "requests": []
                         }
                else:
                     # If not in combat, just return error narrative
                     agent_output = {
                        "narrative": "There was an issue processing the response. (LLM Response Error)",
                        "requests": []
                     }

        except Exception as e:
            logger.exception(f"Error during CombatNarrator processing: {e}")
            agent_output = None # Indicate failure

        if agent_output:
             logger.info(f"CombatNarrator generated output with {len(agent_output['requests'])} requests.")
        else:
             logger.error("CombatNarrator failed to generate valid output.")

        return agent_output

    def supports_command(self, command: str) -> bool:
        # Combat Narrator doesn't handle direct commands, only interprets intent
        return False

    def _generate_outcome_narration_prompt(self, action_result: Dict, combat_manager: CombatManager) -> str:
        """Generates the prompt for narrating an action's outcome, focusing on the result dict."""

        prompt = f"""You are the Combat Narrator AI. Describe the outcome of the combat action based *only* on the following JSON results. Be concise and vivid. Focus on what happened, not the mechanics.

        Action Result Data:
        ```json
        {json.dumps(action_result, indent=2, default=str)}
        ```

        Describe the outcome:"""
        return prompt

    def narrate_outcome(self, action_result: Dict, combat_manager: CombatManager) -> Optional[str]:
        """Generates narrative describing the outcome of a resolved action."""
        if not action_result:
            logger.warning("narrate_outcome called with no action_result.")
            return None

        logger.info(f"Attempting to narrate outcome for action result: {action_result}")
        prompt = self._generate_outcome_narration_prompt(action_result, combat_manager)
        # Send result as JSON for the LLM to parse
        messages = [{"role": "system", "content": "You are the Combat Narrator AI. Describe the outcome of the action concisely and vividly based *only* on the provided JSON result details."},
                    {"role": "user", "content": f"Action Result Data:\n```json\n{json.dumps(action_result, indent=2, default=str)}\n```\n\nDescribe the outcome:"}]

        raw_llm_response_content = "[No LLM Response]" # Default for logging if call fails
        try:
            logger.debug(f"Calling LLM for outcome narration. Prompt implies action: {action_result.get('action_name', 'unknown')}")
            llm_response = self._llm_manager.get_completion(
                messages=messages, provider_type=self._provider_type, model=self._model,
                temperature=0.6, max_tokens=150
            )

            if llm_response and llm_response.content:
                raw_llm_response_content = llm_response.content # Store raw response for logging
                narrative = raw_llm_response_content.strip()
                # Basic cleaning
                narrative = re.sub(r'^(Outcome Description|Narrative|Result)[:\s]*', '', narrative, flags=re.IGNORECASE).strip()
                narrative = re.sub(r'^```(?:json)?\s*|\s*```$', '', narrative, flags=re.MULTILINE).strip()
                # Ensure it's not empty after cleaning
                if not narrative:
                    logger.warning("LLM returned empty content after cleaning for outcome narration.")
                    logger.debug(f"Raw response for empty outcome narration: {raw_llm_response_content}") # Log raw response if clean fails
                    return None

                logger.info(f"Generated outcome narrative: '{narrative[:100]}...'")
                return narrative
            else:
                logger.warning("LLM returned no content for outcome narration.")
                return None
        except Exception as e:
            logger.exception(f"Error generating outcome narration via LLM: {e}")
            logger.debug(f"Raw response (if any) leading to outcome narration error: {raw_llm_response_content}") # Log raw response on error
            return f"[System Error: Could not generate outcome description for {action_result.get('action_name', 'action')}.]"
        
# Convenience function
def get_combat_narrator_agent() -> CombatNarratorAgent:
    return CombatNarratorAgent()
```

### File: core\agents\context_evaluator.py

```python
#!/usr/bin/env python3
"""
Context evaluator agent for analyzing game context.

This module provides a ContextEvaluatorAgent class that analyzes the current
game context, identifies relevant memories, calculates importance scores,
and suggests potential actions to the player.
"""

import os
import re
import json
import math
from typing import Dict, List, Optional, Any, Tuple, Set
import logging

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext, AgentResponse

# Get the module logger
logger = get_logger("AGENT")

class ContextEvaluatorAgent(BaseAgent):
    """
    Context evaluator agent for analyzing game context.
    
    This agent analyzes the current game context, identifies relevant memories,
    calculates importance scores for different context elements, and generates
    summaries for use by other agents.
    """
    
    # Command types supported by the context evaluator
    SUPPORTED_COMMANDS = [
        "CONTEXT_SUMMARIZE", "MEMORY_EVALUATE", "SUGGEST_FOCUS", 
        "IMPORTANCE_SCORE", "RELEVANCE_CHECK"
    ]
    
    def __init__(self):
        """Initialize the context evaluator agent."""
        super().__init__("context_evaluator")
        
        # Cache for context summaries
        self._context_summaries: Dict[str, Tuple[str, float]] = {}

    def reset(self) -> None:
        """Clear cached context summaries to avoid cross-session leakage."""
        try:
            self._context_summaries.clear()
        except Exception:
            self._context_summaries = {}
        logger.info("ContextEvaluator agent cache cleared")
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the context evaluator agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The system prompt string.
        """
        system_prompt = """You are the ContextEvaluator, an AI responsible for analyzing game context, evaluating memories, and determining what information is most relevant to the current situation. Your goal is to provide context awareness to both the player and other game systems.

## Your Responsibilities
1. Analyze the current game context and determine what is most relevant
2. Evaluate memory entries for their importance to the current situation
3. Generate concise, useful context summaries
4. Suggest topics, elements, or actions that might be relevant
5. Calculate importance scores for different context elements
6. Identify connections between seemingly unrelated pieces of information

## Analysis Approach
- **Situational Relevance**: Consider the player's current location, ongoing quests, recent actions, and immediate goals
- **Character Relationships**: Identify NPCs, factions, and entities relevant to the current context
- **Knowledge Continuity**: Ensure important information from past interactions is surfaced when relevant
- **Narrative Coherence**: Maintain storytelling consistency and logical progression
- **Quest Progression**: Highlight information relevant to active and nearby quests
- **Environmental Context**: Note location-specific details, hazards, or opportunities
- **Player Intent**: Consider what the player is likely trying to accomplish

## Output Format
Provide your analysis in this format:
1. Context Summary (2-3 sentences highlighting the most critical elements)
2. Key Elements (bullet points of the most important context items)
3. Suggested Focus (what the player should consider or attend to)
4. Importance Scores (numeric ratings for different context elements)

## Special Instructions
- Be concise and precise - focus on the most relevant information
- Consider both immediate and long-term relevance
- Prioritize information that might otherwise be forgotten or overlooked
- Avoid unnecessary repetition of obvious information
- When evaluating memories, consider recency, uniqueness, and narrative impact
- Use numeric scores (0-10) when evaluating importance

Analyze the provided context and respond with your evaluation.
"""
        
        return system_prompt
    
    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        # Add system prompt
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        
        # Add current game state information
        state_info = self._format_game_state(context)
        if state_info:
            messages.append({"role": "user", "content": state_info})
        
        # Add memory entries if available
        memory_info = self._format_memories(context)
        if memory_info:
            messages.append({"role": "user", "content": memory_info})
        
        # Add conversation history
        history_info = self._format_conversation_summary(context)
        if history_info:
            messages.append({"role": "user", "content": history_info})
        
        # Add the evaluation request
        eval_request = self._format_evaluation_request(context)
        messages.append({"role": "user", "content": eval_request})
        
        return messages
    
    def _format_game_state(self, context: AgentContext) -> str:
        """
        Format game state information for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted game state string.
        """
        # Extract player information
        player_state = context.player_state
        if not player_state:
            return ""
        
        player_name = player_state.get("name", "Unknown")
        player_race = player_state.get("race", "Human")
        player_path = player_state.get("path", "Wanderer")
        player_location = player_state.get("current_location", "Unknown")
        player_district = player_state.get("current_district", "Unknown")
        
        # Extract world information
        world_state = context.world_state
        if not world_state:
            return ""
        
        time_of_day = world_state.get("time_of_day", "Unknown")
        weather = world_state.get("weather", "Clear")
        is_day = world_state.get("is_day", True)
        day_night = "day" if is_day else "night"
        
        # Get active quests if available
        active_quests = player_state.get("active_quests", [])
        
        # Format the information
        state_lines = [
            "## Current Game State",
            f"- Player: {player_name} the {player_race} {player_path}",
            f"- Location: {player_location}, {player_district}",
            f"- Time: {time_of_day} ({day_night})",
            f"- Weather: {weather}"
        ]
        
        # Add active quests
        if active_quests:
            state_lines.append("\n### Active Quests")
            for quest in active_quests:
                quest_name = quest.get("name", "Unknown Quest")
                quest_stage = quest.get("stage", "Unknown")
                state_lines.append(f"- {quest_name} (Stage: {quest_stage})")
        
        return "\n".join(state_lines)
    
    def _format_memories(self, context: AgentContext) -> str:
        """
        Format memory entries for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted memory entries string.
        """
        if not context.relevant_memories:
            return ""
        
        memory_lines = ["## Memory Entries to Evaluate"]
        
        # Organize memories by type
        memories_by_type = {}
        
        for memory in context.relevant_memories:
            memory_type = memory.get("type", "general")
            
            if memory_type not in memories_by_type:
                memories_by_type[memory_type] = []
            
            memories_by_type[memory_type].append(memory)
        
        # Add memories by type
        for memory_type, memories in memories_by_type.items():
            memory_lines.append(f"\n### {memory_type.title()} Memories")
            
            for i, memory in enumerate(memories):
                content = memory.get("content", "")
                timestamp = memory.get("timestamp", "")
                memory_lines.append(f"{i+1}. {content} ({timestamp})")
        
        return "\n".join(memory_lines)
    
    def _format_conversation_summary(self, context: AgentContext) -> str:
        """
        Format a summary of recent conversation for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted conversation summary string.
        """
        if not context.conversation_history:
            return ""
        
        # Get the most recent conversation entries (last 5)
        recent_conversation = context.conversation_history[-5:]
        
        summary_lines = ["## Recent Conversation"]
        
        for entry in recent_conversation:
            role = entry.get("role", "unknown")
            content = entry.get("content", "")
            
            # Format based on role
            if role == "player":
                summary_lines.append(f"Player: {content}")
            elif role == "gm":
                summary_lines.append(f"Narrator: {content}")
            else:
                summary_lines.append(f"{role.title()}: {content}")
        
        return "\n".join(summary_lines)
    
    def _format_evaluation_request(self, context: AgentContext) -> str:
        """
        Format the evaluation request for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted evaluation request string.
        """
        request_lines = [
            "## Context Evaluation Request",
            "Please evaluate the current game context based on the information provided above.",
            "Consider what is most relevant to the player's current situation and goals.",
            "",
            "### Current Focus",
            f"Player's last input: \"{context.player_input}\"",
            "",
            "Provide a context summary, identify key elements, suggest a focus, and assign importance scores."
        ]
        
        return "\n".join(request_lines)
    
    def process(self, context: AgentContext) -> AgentResponse:
        """
        Process a context evaluation request.
        
        Args:
            context: The agent context.
        
        Returns:
            The agent response.
        """
        logger.info("Processing request with ContextEvaluator agent")
        
        # Use the base process method
        response = super().process(context)
        
        # Parse the evaluation result
        evaluation_result = self._parse_evaluation_result(response.content)
        
        # Add the evaluation result to the response metadata
        if evaluation_result:
            response.metadata["evaluation_result"] = evaluation_result
        
        # Cache the context summary if successful
        if evaluation_result and "context_summary" in evaluation_result:
            key = self._generate_context_key(context)
            summary = evaluation_result["context_summary"]
            timestamp = context.world_state.get("game_time", 0) if context.world_state else 0
            
            self._context_summaries[key] = (summary, timestamp)
        
        return response
    
    def _parse_evaluation_result(self, content: str) -> Dict[str, Any]:
        """
        Parse the evaluation result from the LLM response.
        
        Args:
            content: The LLM response content.
        
        Returns:
            Dictionary with evaluation result information.
        """
        result = {
            "context_summary": None,
            "key_elements": [],
            "suggested_focus": None,
            "importance_scores": {}
        }
        
        # Extract context summary
        summary_match = re.search(r"(?:Context Summary:?|Summary:?)\s*(.+?)(?:\n\n|\n#|\n\*|$)", content, re.IGNORECASE | re.DOTALL)
        if summary_match:
            result["context_summary"] = summary_match.group(1).strip()
        
        # Extract key elements
        elements_section = re.search(r"(?:Key Elements:?|Important Elements:?)(.+?)(?:\n\n|\n#|$)", content, re.IGNORECASE | re.DOTALL)
        if elements_section:
            elements_text = elements_section.group(1).strip()
            # Extract bullet points
            elements = re.findall(r"(?:^|\n)-\s*(.+?)(?:$|\n)", elements_text)
            result["key_elements"] = [e.strip() for e in elements if e.strip()]
        
        # Extract suggested focus
        focus_match = re.search(r"(?:Suggested Focus:?|Focus:?)\s*(.+?)(?:\n\n|\n#|$)", content, re.IGNORECASE | re.DOTALL)
        if focus_match:
            result["suggested_focus"] = focus_match.group(1).strip()
        
        # Extract importance scores
        scores_section = re.search(r"(?:Importance Scores:?|Scores:?)(.+?)(?:\n\n|\n#|$)", content, re.IGNORECASE | re.DOTALL)
        if scores_section:
            scores_text = scores_section.group(1).strip()
            # Extract element-score pairs
            score_patterns = [
                r"(?:^|\n)-\s*(.+?):\s*(\d+(?:\.\d+)?)",  # Bullet point format
                r"(?:^|\n)(.+?):\s*(\d+(?:\.\d+)?)"       # Regular format
            ]
            
            for pattern in score_patterns:
                scores = re.findall(pattern, scores_text)
                if scores:
                    for element, score in scores:
                        try:
                            result["importance_scores"][element.strip()] = float(score)
                        except ValueError:
                            pass
        
        return result
    
    def _generate_context_key(self, context: AgentContext) -> str:
        """
        Generate a key for caching context summaries.
        
        Args:
            context: The agent context.
        
        Returns:
            A string key representing the context.
        """
        # Create a key based on location and player input
        location = context.player_state.get("current_location", "") if context.player_state else ""
        district = context.player_state.get("current_district", "") if context.player_state else ""
        input_hash = hash(context.player_input) % 10000  # Simple hash of input
        
        return f"{location}_{district}_{input_hash}"
    
    def get_cached_summary(self, context: AgentContext) -> Optional[str]:
        """
        Get a cached context summary if available and recent.
        
        Args:
            context: The agent context.
        
        Returns:
            A cached summary string, or None if not available.
        """
        key = self._generate_context_key(context)
        
        if key in self._context_summaries:
            summary, timestamp = self._context_summaries[key]
            
            # Check if the summary is still recent enough
            current_time = context.world_state.get("game_time", 0) if context.world_state else 0
            
            # If the summary is less than 10 minutes old in game time, use it
            if current_time - timestamp < 600:
                return summary
        
        return None
    
    def evaluate_context(self, context: AgentContext) -> Dict[str, Any]:
        """
        Evaluate the current game context.
        
        Args:
            context: The agent context.
        
        Returns:
            Dictionary with evaluation results.
        """
        # Check for cached summary first
        cached_summary = self.get_cached_summary(context)
        if cached_summary:
            logger.info("Using cached context summary")
            return {
                "context_summary": cached_summary,
                "source": "cache"
            }
        
        # Otherwise, process the context evaluation
        response = self.process(context)
        
        # Return the evaluation result
        return response.metadata.get("evaluation_result", {})
    
    def supports_command(self, command: str) -> bool:
        """
        Check if the context evaluator agent supports a specific command.
        
        Args:
            command: The command name.
        
        Returns:
            True if the agent supports the command, False otherwise.
        """
        return command in self.SUPPORTED_COMMANDS


# Convenience function
def get_context_evaluator_agent() -> ContextEvaluatorAgent:
    """Get the context evaluator agent instance."""
    return ContextEvaluatorAgent()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the context evaluator agent
    context_evaluator = get_context_evaluator_agent()
    
    # Create a test context
    context = AgentContext(
        game_state={},
        player_state={
            "name": "Thorn",
            "race": "Elf",
            "path": "Ranger",
            "background": "Outcast",
            "current_location": "Whispering Woods",
            "current_district": "Ancient Grove",
            "active_quests": [
                {"name": "The Lost Artifact", "stage": "Find the entrance to the ancient temple"}
            ]
        },
        world_state={
            "time_of_day": "evening",
            "weather": "Light Rain",
            "is_day": False,
            "game_time": 1000
        },
        player_input="I look around for any signs of the temple entrance.",
        conversation_history=[
            {"role": "player", "content": "I enter the Ancient Grove cautiously.", "timestamp": "2023-01-01T12:00:00"},
            {"role": "gm", "content": "The trees here are older and more gnarled, their branches forming a dense canopy above. Strange symbols are carved into some of the trunks.", "timestamp": "2023-01-01T12:00:01"},
            {"role": "player", "content": "I examine the symbols on the trees.", "timestamp": "2023-01-01T12:00:02"},
            {"role": "gm", "content": "The symbols appear to be an ancient elven script. They seem to be pointing in a specific direction deeper into the grove.", "timestamp": "2023-01-01T12:00:03"}
        ],
        relevant_memories=[
            {
                "content": "The Ancient Grove is said to contain a hidden temple dedicated to the old gods.",
                "type": "location",
                "importance": 0.9,
                "timestamp": "2023-01-01T11:30:00"
            },
            {
                "content": "The temple entrance is marked by trees with elven runes.",
                "type": "quest",
                "importance": 0.95,
                "timestamp": "2023-01-01T11:35:00"
            },
            {
                "content": "You obtained a map fragment showing part of the Ancient Grove.",
                "type": "item",
                "importance": 0.8,
                "timestamp": "2023-01-01T11:40:00"
            }
        ]
    )
    
    # Process the request
    response = context_evaluator.process(context)
    
    # Print the response
    print(f"Response: {response.content}")
    
    # Print the evaluation result
    evaluation_result = response.metadata.get("evaluation_result", {})
    if evaluation_result:
        print("\nEvaluation Result:")
        print(f"Context Summary: {evaluation_result.get('context_summary')}")
        print(f"Key Elements: {evaluation_result.get('key_elements')}")
        print(f"Suggested Focus: {evaluation_result.get('suggested_focus')}")
        print(f"Importance Scores: {evaluation_result.get('importance_scores')}")
```

### File: core\agents\data_retrieval_commands.py

```python
"""
Data retrieval commands for LLM agents.

This module provides commands that allow LLM agents to request specific game data
only when needed instead of including all data in every context.
"""

from typing import Dict, List, Optional, Any, Tuple
import logging

from core.utils.logging_config import get_logger
from core.base.state import GameState
from core.inventory import get_inventory_manager, Item # Added Item import

# Get module logger
logger = get_logger("DATA_RETRIEVAL")

def get_inventory_data(game_state: GameState) -> Dict[str, Any]:
    """
    Get detailed inventory data for an LLM agent in the simplified format.
    
    Args:
        game_state: The current game state.
    
    Returns:
        A dictionary containing inventory data with 'equipped' and 'backpack' keys.
    """
    logger.info("Retrieving inventory data for LLM agent (simplified format)")
    
    try:
        inventory_manager = get_inventory_manager()
        
        if not inventory_manager:
            logger.warning("Inventory manager not available for data retrieval.")
            return {"error": "Inventory manager not available"}
        
        equipped_items_dict: Dict[str, Dict[str, str]] = {}
        backpack_items_list: List[Dict[str, Any]] = []

        # Populate equipped items
        if hasattr(inventory_manager, 'equipment') and isinstance(inventory_manager.equipment, dict):
            for slot, item_id in inventory_manager.equipment.items():
                if item_id:
                    item_obj: Optional[Item] = inventory_manager.get_item(item_id)
                    if item_obj:
                        equipped_items_dict[slot.value] = { # Use slot.value for the key
                            "name": item_obj.name,
                            "id": item_obj.id,
                            "type": item_obj.item_type.value if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type)
                        }
                    else:
                        logger.warning(f"Equipped item ID {item_id} in slot {slot.value} not found in inventory manager items.")
        else:
            logger.warning("Inventory manager 'equipment' attribute missing or not a dict.")

        # Populate backpack items
        if hasattr(inventory_manager, 'items') and isinstance(inventory_manager.items, dict): # Assuming _items is the dict
            all_items_in_inventory = inventory_manager.items.values()
        elif hasattr(inventory_manager, 'items') and isinstance(inventory_manager.items, list): # Fallback if it's a list
            all_items_in_inventory = inventory_manager.items
        else:
            all_items_in_inventory = []
            logger.warning("Inventory manager 'items' attribute missing or not a list/dict.")

        for item_obj in all_items_in_inventory:
            if not inventory_manager.is_item_equipped(item_obj.id):
                backpack_items_list.append({
                    "name": item_obj.name,
                    "id": item_obj.id,
                    "type": item_obj.item_type.value if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type),
                    "quantity": item_obj.quantity if item_obj.is_stackable else 1
                })
        
        # Get currency data
        currency_data = {}
        if hasattr(inventory_manager, 'currency'):
            currency_data = inventory_manager.currency.get_currency_dict()
        else:
            logger.warning("Inventory manager 'currency' attribute missing.")

        inventory_data = {
            "equipped": equipped_items_dict,
            "backpack": backpack_items_list,
            "currency": currency_data, # Keep currency as is
            "weight": { # Keep weight/slots as is
                "current": inventory_manager.get_current_weight(),
                "limit": inventory_manager.weight_limit
            },
            "slots": {
                "used": inventory_manager.get_used_slots(),
                "limit": inventory_manager.slot_limit
            }
        }
        
        return inventory_data
        
    except Exception as e:
        logger.error(f"Error retrieving inventory data: {e}", exc_info=True)
        return {"error": f"Error retrieving inventory data: {str(e)}"}

def get_character_stats(game_state: GameState) -> Dict[str, Any]:
    """
    Get character stats data for an LLM agent.
    
    Args:
        game_state: The current game state.
    
    Returns:
        A dictionary containing character stats data.
    """
    logger.info("Retrieving character stats data for LLM agent")
    
    try:
        # Check if stats manager is available (it should be in state_manager)
        from core.base.state import get_state_manager
        
        state_manager = get_state_manager()
        stats_manager = state_manager.stats_manager
        
        if not stats_manager:
            logger.warning("Stats manager not available")
            return {"error": "Stats manager not available"}
        
        # Get basic character info
        character_info = {
            "name": game_state.player.name,
            "race": game_state.player.race,
            "path": game_state.player.path,
            "background": game_state.player.background,
            "level": game_state.player.level,
            "experience": game_state.player.experience,
            "experience_to_next_level": game_state.player.experience_to_next_level,
        }
        
        # Get primary stats
        primary_stats = {}
        
        from core.stats.stats_base import StatType
        for stat_type in StatType:
            stat_value = stats_manager.get_stat_value(stat_type)
            stat_obj = stats_manager.get_stat(stat_type)
            stat_base = stat_obj.base_value if stat_obj else 0
            # Get modifiers from the modifier manager
            mod_values = stats_manager.modifier_manager.get_stat_modifier_value(stat_type)
            stat_mod = mod_values['flat']  # Use flat modifier
            
            primary_stats[stat_type.name] = {
                "value": stat_value,
                "base": stat_base,
                "modifier": stat_mod
            }
        
        # Get derived stats
        derived_stats = {}
        
        from core.stats.stats_base import DerivedStatType
        for stat_type in DerivedStatType:
            # Get the derived stat value (fall back to get_stat_value for consistency)
            stat_value = stats_manager.get_stat_value(stat_type)
            
            derived_stats[stat_type.name] = {
                "value": stat_value
            }
        
        # Get active modifiers
        active_modifiers = []
        
        # Get all modifiers from the modifier manager
        all_modifiers = stats_manager.modifier_manager.modifiers
        for modifier in all_modifiers:
            # The modifier structure might be different than expected, handle safely
            try:
                mod_data = {
                    "stat": str(modifier.stat) if hasattr(modifier, 'stat') else "Unknown",
                    "value": modifier.value if hasattr(modifier, 'value') else 0,
                    "source": str(modifier.source_type) if hasattr(modifier, 'source_type') else str(modifier.source) if hasattr(modifier, 'source') else "Unknown",
                    "duration": modifier.duration if hasattr(modifier, 'duration') else None,
                    "is_permanent": modifier.modifier_type.name == "PERMANENT" if hasattr(modifier, 'modifier_type') else (modifier.duration is None) if hasattr(modifier, 'duration') else True,
                }
            except Exception as e:
                logger.warning(f"Error processing modifier: {e}")
                mod_data = {
                    "stat": "Unknown",
                    "value": 0,
                    "source": "Unknown",
                    "duration": None,
                    "is_permanent": True,
                }
            active_modifiers.append(mod_data)
        
        # Combine all stats data
        stats_data = {
            "character": character_info,
            "primary_stats": primary_stats,
            "derived_stats": derived_stats,
            "active_modifiers": active_modifiers
        }
        
        return stats_data
    
    except Exception as e:
        logger.error(f"Error retrieving character stats data: {e}", exc_info=True)
        return {"error": f"Error retrieving character stats data: {str(e)}"}

def get_quest_data(game_state: GameState) -> Dict[str, Any]:
    """
    Get quest data for an LLM agent from the authoritative journal.

    Returns a dict with active_quests, completed_quests, failed_quests arrays.
    Each quest entry contains id, title, description, status, and objectives
    with minimal fields needed for LLM summaries.
    """
    logger.info("Retrieving quest data for LLM agent (from journal)")

    try:
        journal = getattr(game_state, 'journal', {}) or {}
        quests_map = journal.get('quests', {}) if isinstance(journal, dict) else {}
        
        def classify_status(q: Dict[str, Any]) -> str:
            # Derive status similar to GUI logic
            try:
                status = q.get('status', 'active')
                objectives = q.get('objectives', []) or []
                mandatory_total = sum(1 for o in objectives if o.get('mandatory', True)) or 0
                mandatory_completed = sum(1 for o in objectives if o.get('mandatory', True) and o.get('completed', False))
                any_failed = any(o.get('failed', False) for o in objectives)
                fully_completed = (mandatory_total == mandatory_completed) and not any_failed
                if q.get('abandoned'):
                    return 'failed'
                if fully_completed:
                    return 'completed'
                if status in ('failed','completed','active'):
                    return status
                return 'active'
            except Exception:
                return q.get('status', 'active')
        
        def simplify_quest(qid: str, q: Dict[str, Any]) -> Dict[str, Any]:
            return {
                'id': qid,
                'title': q.get('title', qid),
                'description': q.get('description', ''),
                'status': classify_status(q),
                'objectives': [
                    {
                        'id': o.get('id'),
                        'description': o.get('description', ''),
                        'completed': bool(o.get('completed', False)),
                        'failed': bool(o.get('failed', False)),
                        'mandatory': bool(o.get('mandatory', True)),
                    } for o in (q.get('objectives', []) or [])
                ]
            }
        
        active: list[Dict[str, Any]] = []
        completed: list[Dict[str, Any]] = []
        failed: list[Dict[str, Any]] = []
        
        for qid, q in quests_map.items():
            entry = simplify_quest(qid, q if isinstance(q, dict) else {})
            st = entry['status']
            if st == 'completed':
                completed.append(entry)
            elif st == 'failed':
                failed.append(entry)
            else:
                active.append(entry)
        
        return {
            'active_quests': active,
            'completed_quests': completed,
            'failed_quests': failed,
        }
    except Exception as e:
        logger.error(f"Error retrieving quest data: {e}", exc_info=True)
        return {"error": f"Error retrieving quest data: {str(e)}"}

def get_location_info(game_state: GameState) -> Dict[str, Any]:
    """
    Get location information for an LLM agent.
    
    Args:
        game_state: The current game state.
    
    Returns:
        A dictionary containing location information.
    """
    logger.info("Retrieving location information for LLM agent")
    
    try:
        # Basic location information from player and world state
        location_data = {
            "current_location": game_state.player.current_location,
            "current_district": game_state.player.current_district,
            "time_of_day": game_state.world.time_of_day,
            "weather": game_state.world.weather,
            "is_day": game_state.world.is_day,
        }
        
        # Get game time
        from core.base.game_loop import GameTime
        game_time = GameTime(game_time=game_state.world.game_time)
        
        location_data["game_time"] = {
            "total_seconds": game_state.world.game_time,
            "formatted_time": game_time.get_formatted_time(),
            "day_name": game_time.get_day_name(),
            "hour": game_time.hour,
            "minute": game_time.minute,
            "second": game_time.second
        }
        
        return location_data
    
    except Exception as e:
        logger.error(f"Error retrieving location information: {e}", exc_info=True)
        return {"error": f"Error retrieving location information: {str(e)}"}

def process_data_retrieval_command(command: str, args: str, game_state: GameState) -> Dict[str, Any]:
    """
    Process a data retrieval command.
    
    Args:
        command: The command name (e.g., GET_INVENTORY).
        args: Command arguments (if any).
        game_state: The current game state.
    
    Returns:
        Retrieved data as a dictionary.
    """
    logger.info(f"Processing data retrieval command: {command}")
    
    # Map commands to handler functions
    command_handlers = {
        "GET_INVENTORY": get_inventory_data,
        "GET_STATS": get_character_stats,
        "GET_QUESTS": get_quest_data,
        "GET_LOCATION_INFO": get_location_info,
    }
    
    # Get handler function
    handler = command_handlers.get(command)
    
    if not handler:
        logger.warning(f"Unknown data retrieval command: {command}")
        return {"error": f"Unknown data retrieval command: {command}"}
    
    # Call the handler function
    result = handler(game_state)
    
    return result

```

### File: core\agents\narrator.py

```python
#!/usr/bin/env python3
"""
Narrator agent for generating game narrative and identifying actions.

This module provides a NarratorAgent class that generates narrative
text based on player input, game state, and context information.
It also identifies potential skill checks or state changes requested
by the player's natural language input and outputs them in a
structured format.
"""

import os
import re
import json
from typing import Dict, List, Optional, Any, Tuple, Union
import logging

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext # Keep AgentContext, remove AgentResponse if not used
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode

# Get the module logger
logger = get_logger("AGENT")

class NarratorAgent(BaseAgent):
    """
    Narrator agent for generating game narrative and identifying actions.

    This agent generates narrative text based on player input, game state,
    and context information. When the game mode is NARRATIVE, it analyzes
    player input to identify implicit requests for skill checks or state
    changes, outputting these alongside the narrative in a structured format.
    """
    
    # Define the commands that this agent supports
    SUPPORTED_COMMANDS = [
        "DESCRIBE_LOCATION",
        "NARRATE_ACTION",
        "DESCRIBE_NPC",
        "NARRATE_DIALOGUE",
        "DESCRIBE_ITEM",
        "NARRATE_DISCOVERY"
    ]

    def __init__(self):
        """Initialize the narrator agent."""
        super().__init__("Narrator")
        logger.info(f"NarratorAgent initialized with {len(self.SUPPORTED_COMMANDS)} supported commands: {', '.join(self.SUPPORTED_COMMANDS)}")
        
    def reset(self) -> None:
        """No persistent state to reset, provided for interface consistency."""
        logger.info("Narrator agent reset (no state)")

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the narrator agent.
        """
        # --- Context Extraction (same as before) ---
        player_name = context.player_state.get("name", "Unknown")
        player_race = context.player_state.get("race", "Human")
        player_path = context.player_state.get("path", "Wanderer")
        player_background = context.player_state.get("background", "Commoner")
        player_location = context.player_state.get("current_location", "Unknown")
        player_district = context.player_state.get("current_district", "Unknown")
        player_id = context.player_state.get("id", "player")

        world_time = context.world_state.get("time_of_day", "Unknown")
        world_weather = context.world_state.get("weather", "Clear")
        is_day = context.world_state.get("is_day", True)
        day_night = "day" if is_day else "night"

        current_mode = context.game_state.get("mode", "NARRATIVE")
        mode_display = current_mode if isinstance(current_mode, str) else \
                    current_mode.name if hasattr(current_mode, 'name') else "NARRATIVE"

        # --- Stamina Regeneration Note ---
        stamina_note_for_prompt = ""
        if context.additional_context and "player_stamina_status" in context.additional_context:
            stamina_note_for_prompt = f"\n        - System Note: {context.additional_context['player_stamina_status']}"

        # --- Refined Prompt with JSON Emphasis ---
        system_prompt = f"""You are the Narrator, an AI game master for a text-based RPG. Your role is to create immersive narrative based on player input and game state.

        ## Current Game State
        - Player ID: {player_id}
        - Player: {player_name} the {player_race} {player_path} ({player_background})
        - Location: {player_location}, {player_district}
        - Time: {world_time} ({day_night})
        - Weather: {world_weather}
        - Current Interaction Mode: {mode_display}{stamina_note_for_prompt}

        ## Your Responsibilities
        1. Generate vivid narrative responses to player actions.
        2. Maintain world lore and character consistency.
        3. **CRITICAL (Especially in NARRATIVE Mode):** Analyze the player's natural language input. Identify actions implying skill checks (e.g., "I try to pick the lock"), state changes (e.g., "I drink the potion"), or **MODE TRANSITIONS** (e.g., "I attack the guard", "I want to trade").
        4. **Output JSON:** Your *ENTIRE* response MUST be a single, valid JSON object adhering *exactly* to the `AgentOutput` structure below. NO extra text, explanations, or markdown formatting outside the JSON.

        ## Required Output Format (JSON Object Only)
        ```json
        {{
        "narrative": "Your descriptive text about the situation and the player's attempted action goes here. Describe the lead-up to any requested checks or state changes.",
        "requests": [
            {{
            "action": "request_skill_check",
            "actor_id": "{player_id}",
            "skill_name": "LOCKPICKING",
            "stat_name": "DEXTERITY",
            "target_actor_id": null,
            "difficulty_class": 14,
            "modifiers": {{}},
            "context": "Player attempting to pick the chest lock."
            }},
            {{
            "action": "request_state_change",
            "target_entity": "{player_id}",
            "attribute": "stamina",
            "change_type": "add",
            "value": 5,
            "context": "Player recovered some stamina after a brief rest."
            }},
            {{
            "action": "request_mode_transition",
            "target_mode": "COMBAT",
            "origin_mode": "NARRATIVE",
            "reason": "Player initiated attack on guard.",
            "target_entity_id": "guard_1",
            "surprise": false,
            "enemy_template": "beast_easy_base",
            "enemy_count": 1,
            "enemy_level": 1,
            "spawn_hints": {{
              "actor_type": "beast",
              "threat_tier": "easy",
              "species_tags": ["wolf"],
              "role_hint": "skirmisher",
              "is_boss": false,
              "overlay": null
            }},
            "additional_context": {{
              "original_intent": "I lunge at the wolf and start a fight."
            }}
            }},
            {{
            "action": "request_state_change",
            "target_entity": "{player_id}",
            "attribute": "inventory",
            "change_type": "add",
            "item_template": "test_apple",
            "quantity": 1,
            "context": "Player picks up an apple and puts it in the backpack."
            }},
            {{
            "action": "request_data_retrieval",
            "data_type": "inventory"
            }},
            {{
            "action": "request_quest_update",
            "quest_id": "the-first-exchange",
            "objective_id": "step-2",
            "new_status": "completed",
            "confidence": 0.85,
            "evidence": [
              {{ "type": "flag", "key": "elder.message_deciphered" }},
              {{ "type": "dialogue", "id": "elder_03_line_17" }}
            ]
            }},
            {{
            "action": "request_quest_status",
            "quest_id": "the-first-exchange",
            "new_status": "abandoned",
            "confidence": 0.9,
            "evidence": [ {{ "type": "flag", "key": "player.abandon_confirmed" }} ]
            }}
        ]
        }}
        ```
        
        Evidence items should reference concrete signals (flags, dialogue ids, interaction ids). Do not propose quest status changes that contradict objective-level logic; prefer proposing objective updates. Never invent quest or objective IDs.

        ## Guidelines
        - **NARRATIVE Mode Focus:** When mode is NARRATIVE, actively look for intents requiring skill checks, state changes, or mode transitions.
        - **Inventory Changes (CRITICAL):** When the player gives, offers, drops, leaves behind, discards, sacrifices, or consumes an item, include a `request_state_change` with `attribute: "inventory"`.
          • Prefer `template_id` if known; otherwise use `item_id` (when present) or `item_name`.
          • Use `change_type: "remove"` for removals; include `quantity`.
          • Example: {{"action":"request_state_change","target_entity":"{player_id}","attribute":"inventory","change_type":"remove","template_id":"ritual_dagger","quantity":1,"context":"Player offers the dagger to the Elder as part of the ritual."}}
        - **Stamina Regeneration (NARRATIVE Mode):** If the 'System Note' indicates player stamina is not full, evaluate if context (time passed, player actions) warrants regeneration. If yes, include a `request_state_change` for 'stamina' with a positive 'value' and narrate briefly (e.g., "You feel somewhat refreshed."). If not appropriate, omit this request.
        - **Mode Transitions:** If player input clearly initiates combat ("attack", "fight"), trade ("trade", "buy", "sell"), or social conflict ("confront", "intimidate"), YOU MUST include a `request_mode_transition` in the `requests` list.
        - **Spawn Hints for COMBAT (Optional):** When requesting COMBAT, include a compact spawn specification only if needed:
          * Prefer setting `enemy_template` to a known family/variant id (e.g., `beast_easy_base`, `verdant_alpha`).
          * If you do not know a valid id, include `spawn_hints` with `actor_type`, `threat_tier`, and optional `species_tags`, `role_hint`, `is_boss`, `overlay`.
          * Also include `additional_context.original_intent` containing the exact natural language phrase that triggered combat.
          * Keep this section minimal and structured; do not dump lists or catalogs.
        - **Skill Checks:** Identify verbs implying effort/uncertainty ("try", "attempt", "search", "sneak", "persuade"). Infer the skill (e.g., `LOCKPICKING`, `PERCEPTION`, `STEALTH`, `PERSUASION`). Use `skill_name` from the available skill list.
        - **State Changes:** Identify direct actions ("drink potion", "give item", "pull lever"). Infer target, attribute, change type, value.
        - **Data Retrieval:** Only use `request_data_retrieval` if the player *explicitly asks* for their stats, inventory, quests, etc. Do not guess. If used, the `narrative` should usually be empty or very brief (e.g., "Checking your inventory...").
        - **Narrative First:** Always provide narrative, describing the attempt or situation leading to requests. Do not determine success/failure in narrative.
        - **Environment:** Incorporate environmental tags (from context, if provided) into descriptions and consider them for checks (e.g., taking cover).
        - **Consistency & Fairness:** Maintain world/character consistency. Be descriptive but reasonably concise. Avoid explicit/harmful content.

        ### Final Checklist (before you output JSON)
        1) Did the input imply a skill check? If yes, add `request_skill_check`.
        2) Did the input imply an inventory change? If yes, add `request_state_change` with `attribute: "inventory"`.
        3) Did the input imply a mode transition (combat/trade/social)? If yes, add `request_mode_transition`.
        4) Did the player explicitly ask to list stats/inventory/quests? If yes, add `request_data_retrieval`.
        5) Keep the narrative concise (2–5 sentences) and complete the immediate outcome.

        Respond to the player's input by generating the required JSON `AgentOutput` object ONLY.
        """
        return system_prompt


    def _format_memories(self, context: AgentContext) -> str:
        """
        Format memory context specifically for the narrator.

        Args:
            context: The agent context.

        Returns:
            Formatted memory context string.
        """
        if not context.relevant_memories or not self._settings.get("include_memories", True):
            return ""

        memory_lines = ["## Relevant Background Information"]

        # Categorize memories
        location_memories = []
        character_memories = []
        quest_memories = []
        other_memories = []

        # Get the max number of entries to include
        max_entries = self._settings.get("max_memory_entries", 10)

        # Sort memories by importance
        sorted_memories = sorted(
            context.relevant_memories[:max_entries],
            key=lambda m: m.get("importance", 0),
            reverse=True
        )

        # Categorize and format each memory entry
        for memory in sorted_memories:
            content = memory.get("content", "")
            memory_type = memory.get("type", "general")

            formatted_memory = f"- {content}"

            if memory_type == "location":
                location_memories.append(formatted_memory)
            elif memory_type == "character":
                character_memories.append(formatted_memory)
            elif memory_type == "quest":
                quest_memories.append(formatted_memory)
            else:
                other_memories.append(formatted_memory)

        # Add categorized memories to the output
        if location_memories:
            memory_lines.append("### Locations")
            memory_lines.extend(location_memories)

        if character_memories:
            memory_lines.append("### Characters")
            memory_lines.extend(character_memories)

        if quest_memories:
            memory_lines.append("### Quests")
            memory_lines.extend(quest_memories)

        if other_memories:
            memory_lines.append("### Other Information")
            memory_lines.extend(other_memories)

        return "\n".join(memory_lines)

    def _format_character_stats(self, context: AgentContext) -> str:
        """
        Format character stats information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted character stats string.
        """
        stats = context.additional_context.get("character_stats", {}) if context.additional_context else {}
        if not stats:
            return ""

        lines = ["## Character Stats"]

        # Check for error message
        if "error" in stats:
            lines.append(f"Error retrieving character stats: {stats['error']}")
            return "\n".join(lines)

        # Format character info
        character = stats.get("character", {})
        if character:
            lines.append("### Character Information")
            lines.append(f"- Name: {character.get('name', 'Unknown')}")
            lines.append(f"- Race: {character.get('race', 'Unknown')}")
            lines.append(f"- Class/Path: {character.get('path', 'Unknown')}")
            lines.append(f"- Background: {character.get('background', 'Unknown')}")
            lines.append(f"- Level: {character.get('level', 1)}")
            lines.append(f"- Experience: {character.get('experience', 0)}/{character.get('experience_to_next_level', 100)}")

        # Format primary stats
        primary_stats = stats.get("primary_stats", {})
        if primary_stats:
            lines.append("### Primary Stats")
            for stat_name, stat_info in primary_stats.items():
                value = stat_info.get("value", 0)
                base = stat_info.get("base", 0)
                modifier = stat_info.get("modifier", 0)

                mod_str = f"+{modifier}" if modifier > 0 else str(modifier) if modifier < 0 else ""
                base_str = f" (Base: {base}{f', Mod: {mod_str}' if mod_str else ''})" if base != value else ""

                lines.append(f"- {stat_name}: {value}{base_str}")

        # Format derived stats
        derived_stats = stats.get("derived_stats", {})
        if derived_stats:
            lines.append("### Derived Stats")
            for stat_name, stat_info in derived_stats.items():
                value = stat_info.get("value", 0)
                lines.append(f"- {stat_name}: {value}")

        # Format skills (if available)
        skills = stats.get("skills", {})
        if skills:
            lines.append("### Skills")
            for skill_name, skill_info in skills.items():
                 value = skill_info.get("value", 0)
                 lines.append(f"- {skill_name.title()}: {value}")


        # Format active modifiers
        active_modifiers = stats.get("active_modifiers", [])
        if active_modifiers:
            lines.append("### Active Modifiers")
            for mod in active_modifiers:
                stat = mod.get("stat", "Unknown")
                value = mod.get("value", 0)
                source = mod.get("source", "Unknown")
                duration = mod.get("duration", "")
                is_permanent = mod.get("is_permanent", False)

                duration_str = "Permanent" if is_permanent else f"Duration: {duration}s" if duration else ""
                lines.append(f"- {stat} {value:+g} from {source} ({duration_str})")

        return "\n".join(lines)

    def _format_quests(self, context: AgentContext) -> str:
        """
        Format quest information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted quest information string.
        """
        quests = context.additional_context.get("quests", {}) if context.additional_context else {}
        if not quests:
            return ""

        lines = ["## Quests"]

        # Check for error message
        if "error" in quests:
            lines.append(f"Error retrieving quest data: {quests['error']}")
            return "\n".join(lines)

        # Format active quests
        active_quests = quests.get("active_quests", [])
        lines.append("### Active Quests")
        if not active_quests:
            lines.append("- No active quests")
        else:
            for quest in active_quests:
                if isinstance(quest, dict):
                    quest_name = quest.get("title") or quest.get("name", "Unknown Quest")
                    quest_desc = quest.get("description", "")
                    quest_status = quest.get("status", "In Progress")
                    lines.append(f"- {quest_name} ({quest_status})")
                    if quest_desc:
                        lines.append(f"  {quest_desc}")
                else:
                    lines.append(f"- {quest}")

        # Format completed quests
        completed_quests = quests.get("completed_quests", [])
        lines.append("\n### Completed Quests")
        if not completed_quests:
            lines.append("- No completed quests")
        else:
            for quest in completed_quests:
                if isinstance(quest, dict):
                    quest_name = quest.get("title") or quest.get("name", "Unknown Quest")
                    lines.append(f"- {quest_name}")
                else:
                    lines.append(f"- {quest}")

        # Format failed quests
        failed_quests = quests.get("failed_quests", [])
        lines.append("\n### Failed Quests")
        if not failed_quests:
            lines.append("- No failed quests")
        else:
            for quest in failed_quests:
                if isinstance(quest, dict):
                    quest_name = quest.get("title") or quest.get("name", "Unknown Quest")
                    lines.append(f"- {quest_name}")
                else:
                    lines.append(f"- {quest}")

        return "\n".join(lines)

    def _format_location_info(self, context: AgentContext) -> str:
        """
        Format location information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted location information string.
        """
        location_info = context.additional_context.get("location_info", {}) if context.additional_context else {}
        if not location_info:
            return ""

        lines = ["## Current Location & Environment"]

        # Check for error message
        if "error" in location_info:
            lines.append(f"Error retrieving location information: {location_info['error']}")
            return "\n".join(lines)

        # Basic location information
        lines.append(f"- Location: {location_info.get('current_location', 'Unknown')}")
        lines.append(f"- District/Area: {location_info.get('current_district', 'Unknown')}")

        # Time and weather information
        # Format game time
        game_time = location_info.get("game_time", {})
        if game_time:
            formatted_time = game_time.get("formatted_time", "Unknown time")
            day_name = game_time.get("day_name", "")
            time_str = formatted_time
            if day_name:
                time_str = f"{day_name}, {time_str}"
            lines.append(f"- Time: {time_str}")

        # Weather and time of day
        lines.append(f"- Time of Day: {location_info.get('time_of_day', 'Unknown')}")
        lines.append(f"- Weather: {location_info.get('weather', 'Unknown')}")
        lines.append(f"- Daylight: {'Day' if location_info.get('is_day', True) else 'Night'}")

        # Add nearby interactables/entities if available
        nearby = location_info.get("nearby_entities", [])
        if nearby:
            lines.append("### Nearby")
            for entity in nearby:
                 lines.append(f"- {entity.get('name', 'Unknown Entity')} ({entity.get('type', 'object')})")


        return "\n".join(lines)

    def _format_inventory(self, context: AgentContext) -> str:
        """
        Format inventory information for the LLM prompt.

        Args:
            context: The agent context.

        Returns:
            Formatted inventory string.
        """
        inventory = context.additional_context.get("inventory", {}) if context.additional_context else {}
        if not inventory:
            return ""

        lines = ["## Current Inventory"]

        # Check for error message
        if "error" in inventory:
            lines.append(f"Error retrieving inventory data: {inventory['error']}")
            return "\n".join(lines)

        # Format equipped items
        equipped = inventory.get("equipped", {})
        if equipped:
            lines.append("### Equipped Items")
            if not equipped:
                lines.append("- Nothing equipped.")
            else:
                for slot, item in equipped.items():
                    if isinstance(item, dict):
                        item_name = item.get("name", "Unknown Item")
                        item_stats = item.get("stats", [])
                        stats_str = ", ".join(f"{stat['name']}: {stat['value']}" for stat in item_stats) if item_stats else ""
                        lines.append(f"- {slot.title()}: {item_name} {f'({stats_str})' if stats_str else ''}")
                    elif item: # Handle cases where it might be just the item name/ID
                         lines.append(f"- {slot.title()}: {item}")
                    # else: # Don't list empty slots explicitly unless needed
                    #    lines.append(f"- {slot.title()}: None")

        # Format backpack items
        backpack = inventory.get("backpack", [])
        lines.append("### Backpack")
        if not backpack:
            lines.append("- Backpack is empty.")
        else:
            # Group items by type
            items_by_type = {}
            for item in backpack:
                if isinstance(item, dict):
                    item_type = item.get("type", "Miscellaneous").title()
                    if item_type not in items_by_type:
                        items_by_type[item_type] = []
                    items_by_type[item_type].append(item)

            # Display items by type
            for item_type, items in items_by_type.items():
                lines.append(f"#### {item_type}")
                for item in items:
                    item_name = item.get("name", "Unknown Item")
                    item_rarity = item.get("rarity", "")
                    item_quantity = item.get("quantity", 1)
                    quantity_str = f" (x{item_quantity})" if item_quantity > 1 else ""
                    rarity_str = f" ({item_rarity})" if item_rarity else ""
                    lines.append(f"- {item_name}{quantity_str}{rarity_str}")

        # Format currency
        currency = inventory.get("currency", {})
        if currency:
            gold = currency.get("gold", 0)
            silver = currency.get("silver", 0)
            copper = currency.get("copper", 0)
            lines.append(f"### Currency: {gold}g {silver}s {copper}c")

        # Format inventory limits
        weight = inventory.get("weight", {})
        slots = inventory.get("slots", {})
        if weight or slots:
            lines.append("### Inventory Limits")
            if weight:
                current_weight = weight.get("current", 0)
                weight_limit = weight.get("limit", 0)
                lines.append(f"- Weight: {current_weight:.1f}/{weight_limit:.1f}")
            if slots:
                used_slots = slots.get("used", 0)
                slot_limit = slots.get("limit", 0)
                lines.append(f"- Slots: {used_slots}/{slot_limit}")

        return "\n".join(lines)


    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        """
        messages = []
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})

        # Add conversation history
        history_messages = self._format_conversation_history(context)
        messages.extend(history_messages)

        # Prepare user message parts
        user_message_parts = []
        if context.context_summary: user_message_parts.append(f"## Summary\n{context.context_summary}")
        memory_context = self._format_memories(context)
        if memory_context: user_message_parts.append(memory_context)

        # Add formatted context data ONLY if specifically requested or highly relevant
        # Avoid overloading the prompt by default in Narrative mode unless needed
        # Inventory
        if "inventory" in context.player_input.lower():
             inventory_info = self._format_inventory(context)
             if inventory_info: user_message_parts.append(inventory_info)
        # Stats
        if any(kw in context.player_input.lower() for kw in ["stat", "skill", "ability", "can i"]):
             stats_info = self._format_character_stats(context)
             if stats_info: user_message_parts.append(stats_info)
        # Quests: include when user mentions quests, or when additional_context already includes quests
        if ("quest" in context.player_input.lower()) or (context.additional_context and context.additional_context.get("quests")):
             quests_info = self._format_quests(context)
             if quests_info: user_message_parts.append(quests_info)

        # Always add basic location info
        location_info = self._format_location_info(context)
        if location_info: user_message_parts.append(location_info)
        # Explicitly add environment tags
        environment_tags = context.additional_context.get("environment", []) if context.additional_context else []
        if environment_tags: user_message_parts.append(f"### Environment Tags: {', '.join(environment_tags)}")


        # Add the actual player input
        user_message_parts.append("## Player Input")
        user_message_parts.append(context.player_input)

        final_user_message = "\n\n".join(user_message_parts)
        messages.append({"role": "user", "content": final_user_message})

        logger.debug(f"Prepared messages for NarratorAgent:\nSystem Prompt Length: {len(system_prompt)}\nUser Message Length: {len(final_user_message)}")
        # logger.debug(f"Full User Message:\n{final_user_message}") # Uncomment for detailed debugging

        return messages

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a request with the narrator agent, expecting JSON output.
        """
        mode = context.game_state.get("mode", "N/A")
        logger.info(f"Processing request with Narrator agent. Mode: {mode}, Intent: '{context.player_input[:50]}...'")

        messages = self._prepare_messages(context)
        agent_output: Optional[AgentOutput] = None

        try:
            # --- LLM Call ---
            effective_model = self._model or None
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=effective_model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1500), # Use setting
                timeout=self._settings.get("timeout_seconds", 45) # Use setting
            )
            if not llm_response or not llm_response.content:
                raise ValueError("LLM returned empty content.")

            llm_response_content = llm_response.content.strip()
            logger.debug(f"Raw LLM Response (Narrator):\n```\n{llm_response_content}\n```")

            # --- Enhanced JSON Parsing ---
            parsed_output = None
            cleaned_response = llm_response_content
            try:
                 # 1. Remove potential markdown fences first
                cleaned_response = re.sub(r'^```(?:json)?\s*|\s*```$', '', cleaned_response, flags=re.MULTILINE).strip()

                # 2. Try direct parsing
                parsed_output = json.loads(cleaned_response)
                logger.debug("Successfully parsed JSON directly.")

            except json.JSONDecodeError as e:
                logger.warning(f"Narrator initial JSON parsing failed: {e}. Trying to extract JSON object...")
                # 3. If direct parsing fails, try to find the first '{' and last '}'
                start_index = cleaned_response.find('{')
                end_index = cleaned_response.rfind('}')
                if start_index != -1 and end_index != -1 and start_index < end_index:
                    json_substring = cleaned_response[start_index : end_index + 1]
                    try:
                        parsed_output = json.loads(json_substring)
                        logger.info("Successfully parsed extracted JSON substring from Narrator response.")
                    except json.JSONDecodeError as e_inner:
                        logger.error(f"Narrator failed to parse extracted JSON substring: {e_inner}")
                        logger.error(f"Substring attempted: ```\n{json_substring}\n```")
                        parsed_output = None
                else:
                    logger.error("Narrator could not find valid JSON object markers '{' and '}' in the response.")
                    parsed_output = None

            # --- Validate Structure and Build Output ---
            if (isinstance(parsed_output, dict) and
                "narrative" in parsed_output and
                "requests" in parsed_output and
                isinstance(parsed_output["requests"], list)):

                # Validate requests format (basic check)
                validated_requests = []
                for req in parsed_output["requests"]:
                    if isinstance(req, dict) and "action" in req:
                        validated_requests.append(req)
                    else:
                        logger.warning(f"Narrator skipping invalid request structure: {req}")

                agent_output = {
                    "narrative": parsed_output["narrative"],
                    "requests": validated_requests
                }
                narrative_snippet = parsed_output["narrative"][:100]
                logger.info(f"Narrator successfully parsed valid JSON. Narrative: '{narrative_snippet}...', Requests: {len(validated_requests)}")

            else: # Parsing failed or structure invalid
                logger.error("Narrator failed to parse LLM response as valid JSON AgentOutput.")
                # Fallback: Treat the whole response as narrative if parsing fails
                agent_output = {
                    "narrative": llm_response_content, # Use the raw content as narrative
                    "requests": [] # No requests could be parsed
                }
                logger.warning("Narrator using raw response as narrative due to JSON parsing failure.")


        except Exception as e:
            logger.exception(f"Error during NarratorAgent processing or LLM call: {e}")
            # Fallback: Provide an error narrative
            agent_output = {
                "narrative": f"[Narrator Error: An unexpected error occurred: {e}]",
                "requests": []
            }

        # Log final decision
        if agent_output:
             logger.info(f"Narrator final output generated with {len(agent_output['requests'])} requests.")
        else:
             # This case should ideally not be reached due to fallbacks, but log just in case
             logger.error("Narrator failed to generate any output structure.")
             agent_output = { "narrative": "[System Error: Narrator failed completely.]", "requests": [] }

        return agent_output

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a request with the narrator agent.

        Calls the LLM, parses the expected JSON output, and returns it.

        Args:
            context: The agent context.

        Returns:
            An AgentOutput dictionary containing narrative and structured requests.
        """
        logger.info(f"Processing request with Narrator agent in mode: {context.game_state.get('mode', 'N/A')}")

        messages = self._prepare_messages(context)

        # --- LLM Call ---
        try:
            # Use the LLM manager from BaseAgent with proper parameters
            llm_response = self._llm_manager.get_completion(
                messages=messages,
                provider_type=self._provider_type,
                model=self._model,
                temperature=self._temperature,
                max_tokens=self._settings.get("max_tokens", 1000),
                timeout=self._settings.get("timeout_seconds", 30)
            )
            if not llm_response or not llm_response.content:
                raise ValueError("LLM returned empty content.")
            llm_response_content = llm_response.content
            logger.debug(f"Raw LLM Response:\n{llm_response_content}")

            # --- Response Parsing ---
            # The LLM might return a mix of text and JSON, or just the JSON
            # We need to try multiple parsing strategies
            try:
                # First try: Look for JSON code block
                json_match = re.search(r'```(?:json)?\s*({.*?})\s*```', llm_response_content, re.DOTALL)
                if json_match:
                    # Extract JSON from code block
                    cleaned_response = json_match.group(1).strip()
                    logger.debug(f"Found JSON in code block: {cleaned_response[:100]}...")
                else:
                    # Second try: See if the entire response is JSON
                    if llm_response_content.strip().startswith('{'):
                        cleaned_response = llm_response_content.strip()
                        logger.debug("Response appears to be raw JSON")
                    else:
                        # Third try: Look for JSON anywhere in the text
                        # More robust pattern that handles nested structures better
                        json_pattern = r'({\s*"narrative"\s*:.+?"requests"\s*:\s*\[.*?\]\s*})'
                        json_match = re.search(json_pattern, llm_response_content, re.DOTALL)
                        if json_match:
                            cleaned_response = json_match.group(1).strip()
                            logger.debug(f"Found JSON pattern in response: {cleaned_response[:100]}...")
                        else:
                            # Final fallback: Treat the whole text as narrative with no requests
                            logger.warning("No JSON found in response. Treating entire text as narrative.")
                            return {
                                "narrative": llm_response_content.strip(),
                                "requests": []
                            }
                
                # Parse the extracted JSON
                try:
                    # Log the cleaned response for debugging
                    logger.debug(f"Attempting to parse JSON: {cleaned_response[:100]}... (length: {len(cleaned_response)})")
                    parsed_output = json.loads(cleaned_response)
                    logger.debug("Successfully parsed JSON")
                except json.JSONDecodeError as json_err:
                    # One more attempt: Try to sanitize quotes and escape characters
                    sanitized_json = re.sub(r'(?<!\\)\\\'', '\'', cleaned_response)  # Fix escaped single quotes
                    sanitized_json = re.sub(r'(?<!\\)\\"', '"', sanitized_json)  # Fix escaped double quotes
                    parsed_output = json.loads(sanitized_json)

                # Validate basic structure
                if not isinstance(parsed_output, dict) or \
                "narrative" not in parsed_output or \
                "requests" not in parsed_output or \
                not isinstance(parsed_output["requests"], list):
                    raise ValueError("LLM response is not a valid AgentOutput JSON structure.")

                # Basic validation of request structures (can be expanded)
                validated_requests = []
                for req in parsed_output["requests"]:
                    if not isinstance(req, dict) or "action" not in req:
                        logger.warning(f"Skipping invalid request structure: {req}")
                        continue
                    # Add more specific validation per action type if needed
                    validated_requests.append(req)

                agent_output: AgentOutput = {
                    "narrative": parsed_output.get("narrative", "Error: Narrative missing from LLM response."),
                    "requests": validated_requests
                }

            except json.JSONDecodeError as e:
                logger.warning(f"Narrator: JSON decode failed; using raw text as narrative. Error: {e}")
                # Fallback: Treat the whole response as narrative, no requests
                agent_output: AgentOutput = {
                    "narrative": llm_response_content.strip(),
                    "requests": []
                }
            except ValueError as e:
                logger.warning(f"Narrator: Invalid AgentOutput structure; using raw text as narrative. Error: {e}")
                agent_output: AgentOutput = {
                    "narrative": (parsed_output.get('narrative', llm_response_content).strip() if isinstance(parsed_output, dict) else str(llm_response_content).strip()),
                    "requests": []
                }


        except Exception as e:
            logger.exception(f"Error during NarratorAgent processing or LLM call: {e}")
            agent_output: AgentOutput = {
                "narrative": f"[Narrator Error: An unexpected error occurred during processing: {e}]",
                "requests": []
            }

        # --- RuleChecker Integration Point (Placeholder) ---
        # In Phase B3, the core loop would take agent_output["requests"]
        # and pass them to the RuleCheckerAgent for validation before
        # executing skill checks or state changes.
        # Example:
        # validated_requests = self.rule_checker.validate(agent_output["requests"], context)
        # agent_output["requests"] = validated_requests
        logger.info(f"Narrator generated {len(agent_output['requests'])} requests.")
        # Log request types for debugging
        request_types = [req.get('action', 'unknown') for req in agent_output.get('requests', []) if isinstance(req, dict)]
        logger.info(f"Request types generated: {request_types}")
        if 'request_mode_transition' in request_types:
            mode_transitions = [req for req in agent_output.get('requests', []) if isinstance(req, dict) and req.get('action') == 'request_mode_transition']
            logger.info(f"Mode transition requests detected: {json.dumps(mode_transitions, indent=2)}")
        # logger.debug(f"Narrator Output: {agent_output}") # Be careful logging potentially large outputs

        return agent_output

    def supports_command(self, command: str) -> bool:
        """
        Check if this agent supports a specific command.
        Args: Command: The command name.
        Returns: True if the agent supports the command, False otherwise.
        """
        is_supported = command.upper() in self.SUPPORTED_COMMANDS
        logger.debug(f"NarratorAgent.supports_command check for '{command}': {is_supported}")
        return is_supported


# Convenience function
def get_narrator_agent() -> NarratorAgent:
    """Get the narrator agent instance."""
    # In a real app, LLM service would be injected here
    # For now, assume BaseAgent handles it or it's set elsewhere
    return NarratorAgent()

```

### File: core\agents\rule_checker.py

```python
#!/usr/bin/env python3
"""
Rule checker agent for validating player actions.

This module provides a RuleCheckerAgent class that validates player
actions against game rules, prevents cheating, and ensures game fairness.
"""

import os
import re
import json
import hashlib
from typing import Dict, List, Optional, Any, Tuple, Set
import logging

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext, AgentResponse

# Get the module logger
logger = get_logger("AGENT")

class RuleCheckerAgent(BaseAgent):
    """
    Rule checker agent for validating player actions.
    
    This agent validates player actions against game rules, provides feedback
    on invalid actions, and implements anti-cheat measures to ensure a fair
    and balanced game experience.
    """
    
    # Command types that can be validated
    SUPPORTED_COMMANDS = [
        "ACTION_VALIDATE", "COMBAT_VALIDATE", "LOOT_VALIDATE",
        "QUEST_VALIDATE", "RULE_QUERY", "ANTICHEAT_CHECK",
        "STAT_CHECK", "RULE_CHECK"
    ]
    
    def __init__(self, entity_manager=None, item_manager=None, stats_manager=None, world_manager=None):
        """Initialize the rule checker agent."""
        super().__init__("rule_checker")
        
        # Store the managers passed from the engine
        self._entity_manager = entity_manager
        self._item_manager = item_manager
        self._stats_manager = stats_manager
        self._world_manager = world_manager
        
        # Track entities that have already been looted
        self._looted_entities: Set[str] = set()
        
        # Track time-limited events that have been completed
        self._completed_events: Dict[str, float] = {}
        
        # Track action history for anti-cheat detection
        self._action_history: List[Dict[str, Any]] = []

    def reset(self) -> None:
        """Reset in-memory caches and histories so no state leaks between sessions."""
        try:
            if hasattr(self, "_looted_entities") and isinstance(self._looted_entities, set):
                self._looted_entities.clear()
            else:
                self._looted_entities = set()
            if hasattr(self, "_completed_events") and isinstance(self._completed_events, dict):
                self._completed_events.clear()
            else:
                self._completed_events = {}
            if hasattr(self, "_action_history") and isinstance(self._action_history, list):
                self._action_history.clear()
            else:
                self._action_history = []
            logger.info("RuleChecker agent state reset")
        except Exception:
            # Fall back to reinitializing the containers
            self._looted_entities = set()
            self._completed_events = {}
            self._action_history = []
            logger.info("RuleChecker agent state reset (containers reinitialized)")
    
    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the rule checker agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The system prompt string.
        """
        system_prompt = """You are the RuleChecker, an AI responsible for validating player actions against game rules and preventing cheating. Your role is to ensure fair play while maintaining immersion.

## Your Responsibilities
1. Validate player actions against game rules and mechanics
2. Identify and prevent exploits and cheating
3. Provide clear feedback when actions are invalid
4. Ensure consistent application of rules
5. Track entities that have been looted to prevent double-looting
6. Monitor time-limited events to prevent replaying
7. Analyze patterns of behavior for potential cheating

## Key Rules to Enforce
- **Physics and Realism**: Actions must be physically possible within the game world
- **Character Capabilities**: Actions must be within the character's abilities
- **Resource Limits**: Players cannot exceed inventory weight, size limits, or currency caps
- **Consequence Consistency**: Similar actions should have similar consequences
- **Anti-Exploitation**: Prevent looting the same entity multiple times
- **Time Integrity**: Prevent replaying time-limited events
- **Action Atomicity**: Ensure actions are completed properly with all side effects

## Response Format
Your response MUST follow this exact format with these exact section markers to be properly processed:

<REASONING>
Provide your detailed reasoning process here (for development purposes).
</REASONING>

<DECISION>
YES or NO (write only one of these words)
</DECISION>

<EXPLANATION>
If NO, explain why the action is invalid in a clear, helpful manner.
If YES, briefly explain why the action is valid.
</EXPLANATION>

<SUGGESTIONS>
If NO, suggest alternatives when appropriate.
If YES, this section can be brief or empty.
</SUGGESTIONS>

## Special Instructions
- Balance strictness with fun - apply rules consistently but don't be pedantic
- Focus on significant rule violations, not minor inconsistencies
- Consider character attributes and skills when evaluating actions
- Flag suspicious behavior patterns for further review
- Always prioritize game balance and fair play
- Always include all four sections in your response, even if some are empty

## Mode Transition Validation
- **Contextual Sense:** Does the requested transition make sense given the current situation, location, and participants? (e.g., initiating trade during a fight is invalid).
- **Target Validity:** For the requested mode transition, check if the target entity (if any) exists. If target entity is mentioned by name but not found in context, do not immediately reject the transition - assume the entity *could* be created dynamically for combat.
- **Combat Fleeing:** Attempting to flee combat (`request_mode_transition` to NARRATIVE from COMBAT) is generally a valid *attempt*, but the success is determined by a later skill check. Validate the *attempt* itself (e.g., is the player prevented from moving?).  
- **Initiating Combat:** Ensure combat is initiated against valid targets. If target is not found in current context but has a name that could be an enemy (like "goblin", "bandit", "guard", "elder", etc.), assume it's a potentially valid target that will be created dynamically. 
- **Initiating Trade/Social:** Ensure the target is present and capable of participating.

Respond with your validation assessment of the player's proposed action.
"""
        
        return system_prompt
    
    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """
        Prepare the message list for the LLM request.
        
        Args:
            context: The agent context.
        
        Returns:
            List of message dictionaries (role, content).
        """
        messages = []
        
        # Add system prompt
        system_prompt = self._generate_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        
        # Add player stats and capabilities
        player_info = self._format_player_info(context)
        if player_info:
            messages.append({"role": "user", "content": player_info})
        
        # Add recent action history for context
        action_history = self._format_action_history()
        if action_history:
            messages.append({"role": "user", "content": action_history})
        
        # Add the validation request with player input
        validation_request = self._format_validation_request(context)
        messages.append({"role": "user", "content": validation_request})
        
        return messages
    
    def _format_player_info(self, context: AgentContext) -> str:
        """
        Format player information for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted player information string.
        """
        player_state = context.player_state
        if not player_state:
            return ""
        
        # Extract player information
        player_name = player_state.get("name", "Unknown")
        player_race = player_state.get("race", "Human")
        player_path = player_state.get("path", "Wanderer")
        player_level = player_state.get("level", 1)
        
        # Extract player stats
        strength = player_state.get("strength", 10)
        agility = player_state.get("agility", 10)
        constitution = player_state.get("constitution", 10)
        intelligence = player_state.get("intelligence", 10)
        wisdom = player_state.get("wisdom", 10)
        charisma = player_state.get("charisma", 10)
        
        # Extract player status
        health = player_state.get("health", 100)
        max_health = player_state.get("max_health", 100)
        stamina = player_state.get("stamina", 100)
        max_stamina = player_state.get("max_stamina", 100)
        mana = player_state.get("mana", 100)
        max_mana = player_state.get("max_mana", 100)
        
        # Format the information
        info_lines = [
            "## Player Information",
            f"- Name: {player_name}",
            f"- Race: {player_race}",
            f"- Path: {player_path}",
            f"- Level: {player_level}",
            "",
            "### Stats",
            f"- Strength: {strength}",
            f"- Agility: {agility}",
            f"- Constitution: {constitution}",
            f"- Intelligence: {intelligence}",
            f"- Wisdom: {wisdom}",
            f"- Charisma: {charisma}",
            "",
            "### Status",
            f"- Health: {health}/{max_health}",
            f"- Stamina: {stamina}/{max_stamina}",
            f"- Mana: {mana}/{max_mana}"
        ]
        
        # Add inventory details if available for more accurate validation
        inventory_info = context.additional_context.get("inventory", {}) if context.additional_context else {}
        if inventory_info:
            # Weight/slots summary (robust to nested structure in data_retrieval)
            try:
                weight_current = inventory_info.get("weight", {}).get("current", inventory_info.get("current_weight", 0))
                weight_limit = inventory_info.get("weight", {}).get("limit", inventory_info.get("weight_limit", 0))
                info_lines.append(f"- Inventory Weight: {weight_current}/{weight_limit} units")
                slots_used = inventory_info.get("slots", {}).get("used")
                slots_limit = inventory_info.get("slots", {}).get("limit")
                if slots_used is not None and slots_limit is not None:
                    info_lines.append(f"- Inventory Slots: {slots_used}/{slots_limit}")
            except Exception:
                pass

            # Equipped items
            try:
                equipped = inventory_info.get("equipped", {}) or {}
                if equipped:
                    info_lines.append("")
                    info_lines.append("### Equipped Items")
                    for slot, item in equipped.items():
                        if isinstance(item, dict):
                            name = item.get("name", "Unknown Item")
                            iid = item.get("id", "?")
                            info_lines.append(f"- {slot}: {name} (id: {iid})")
                        else:
                            info_lines.append(f"- {slot}: {str(item)}")
            except Exception:
                pass

            # Backpack items
            try:
                backpack = inventory_info.get("backpack", []) or []
                if backpack:
                    info_lines.append("")
                    info_lines.append("### Backpack Items")
                    # List at most the first 25 to keep prompts concise
                    for idx, item in enumerate(backpack[:25]):
                        if isinstance(item, dict):
                            name = item.get("name", "Unknown Item")
                            iid = item.get("id", "?")
                            qty = item.get("quantity", 1)
                            qstr = f" x{qty}" if isinstance(qty, int) and qty > 1 else ""
                            info_lines.append(f"- {name}{qstr} (id: {iid})")
                        else:
                            info_lines.append(f"- {str(item)}")
                    if len(backpack) > 25:
                        info_lines.append(f"...and {len(backpack)-25} more items")
            except Exception:
                pass
        
        return "\n".join(info_lines)
    
    def _format_action_history(self) -> str:
        """
        Format recent action history for context.
        
        Returns:
            Formatted action history string.
        """
        if not self._action_history:
            return ""
        
        # Get the last 5 actions for context
        recent_actions = self._action_history[-5:]
        
        lines = ["## Recent Action History"]
        
        for action in recent_actions:
            action_type = action.get("type", "Unknown")
            action_desc = action.get("description", "")
            timestamp = action.get("timestamp", "")
            lines.append(f"- {timestamp}: {action_type} - {action_desc}")
        
        return "\n".join(lines)
    
    def _format_validation_request(self, context: AgentContext) -> str:
        """
        Format the validation request for the LLM prompt.
        
        Args:
            context: The agent context.
        
        Returns:
            Formatted validation request string.
        """
        # Extract world information
        world_state = context.world_state
        location = context.player_state.get("current_location", "Unknown")
        district = context.player_state.get("current_district", "Unknown")
        time_of_day = world_state.get("time_of_day", "Unknown") if world_state else "Unknown"
        weather = world_state.get("weather", "Clear") if world_state else "Clear"
        
        request_lines = [
            "## Action Validation Request",
            f"- Location: {location}, {district}",
            f"- Time: {time_of_day}",
            f"- Weather: {weather}",
            "",
            "### Player's Proposed Action",
            f"{context.player_input}",
            "",
            "Please validate this action against game rules and provide your assessment."
        ]
        
        return "\n".join(request_lines)
    
    def process(self, context: AgentContext) -> AgentResponse:
        """
        Process a validation request with the rule checker agent.
        
        Args:
            context: The agent context.
        
        Returns:
            The agent response.
        """
        logger.info("Processing request with RuleChecker agent")
        
        # Use the base process method
        response = super().process(context)
        
        # Extract validation result
        validation_result = self._parse_validation_result(response.content)
        
        # Add the validation result to the response metadata
        if validation_result:
            response.metadata["validation_result"] = validation_result
        
        # If this is a loot validation, track the entity if approved
        if "loot" in context.player_input.lower() and validation_result.get("is_valid", False):
            self._track_looted_entity(context)
        
        # Add the action to history
        self._add_to_action_history(context, validation_result)
        
        return response
    
    def _parse_validation_result(self, content: str) -> Dict[str, Any]:
        """Parse the validation result from the LLM response."""
        result = {
            "is_valid": False,
            "reason": "Unspecified rule violation",  # Default reason if not extracted
            "suggestions": []
        }
        
        # Log the content length for debugging
        logger.debug(f"Parsing validation result from content of length {len(content)}")
        
        # Extract sections using the exact markers
        decision_match = re.search(r'<DECISION>\s*(.+?)\s*</DECISION>', content, re.DOTALL)
        explanation_match = re.search(r'<EXPLANATION>\s*(.+?)\s*</EXPLANATION>', content, re.DOTALL)
        suggestions_match = re.search(r'<SUGGESTIONS>\s*(.+?)\s*</SUGGESTIONS>', content, re.DOTALL)
        
        # Process decision
        if decision_match:
            decision_text = decision_match.group(1).strip().upper()
            logger.debug(f"Found decision: {decision_text}")
            
            if 'YES' in decision_text:
                result["is_valid"] = True
                result["reason"] = None  # No reason needed for valid actions
            elif 'NO' in decision_text:
                result["is_valid"] = False
                # Reason will be extracted from explanation
            else:
                # This is a common issue with the LLM where it says the action is valid but marks it as NO
                # Check if the explanation actually contains a positive validation
                if explanation_match:
                    explanation_text = explanation_match.group(1).strip()
                    if explanation_text and any(positive_term in explanation_text.lower() for positive_term in 
                                              ['valid', 'allowed', 'acceptable', 'is valid', 'can be performed']):
                        logger.warning(f"Decision says NO but explanation indicates validity. Setting to valid.")
                        result["is_valid"] = True
                        result["reason"] = None
                    else:
                        logger.warning(f"Unclear decision text: '{decision_text}'")
                else:
                    logger.warning(f"Unclear decision text: '{decision_text}'")
        else:
            logger.warning("No <DECISION> section found in response")
        
        # Process explanation (reason for decision)
        if explanation_match:
            explanation_text = explanation_match.group(1).strip()
            logger.debug(f"Found explanation: {explanation_text[:100]}...")
            
            # Special case: explanation contradicts decision
            is_positive_explanation = any(positive_term in explanation_text.lower() for positive_term in 
                                         ['valid', 'allowed', 'acceptable', 'is valid', 'can be performed'])
            
            # If explanation says it's valid but decision says it's not, override
            if is_positive_explanation and not result["is_valid"]:
                logger.warning("Explanation contradicts decision: Explanation says action is valid, overriding decision")
                result["is_valid"] = True
                result["reason"] = None
            # If explanation says it's invalid but decision says it's valid, don't override
            # (This is a safety feature - we prefer to allow actions on ambiguity)
            
            # For invalid actions, set the reason
            if not result["is_valid"] and explanation_text:  
                result["reason"] = explanation_text
        else:
            logger.warning("No <EXPLANATION> section found in response")
        
        # Process suggestions
        if suggestions_match:
            suggestions_text = suggestions_match.group(1).strip()
            logger.debug(f"Found suggestions: {suggestions_text[:100]}...")
            
            if suggestions_text:
                # Split by lines or sentences to get individual suggestions
                suggestions_lines = re.split(r'[\n\r]+|(?<=\.)\s+', suggestions_text)
                result["suggestions"] = [s.strip() for s in suggestions_lines if s.strip()]
        else:
            logger.warning("No <SUGGESTIONS> section found in response")
        
        # Ensure we have a reason for invalid actions
        if not result["is_valid"] and (not result["reason"] or result["reason"] == "Unspecified rule violation"):
            # If explanation was missing but we have suggestions, use first suggestion as reason
            if result["suggestions"]:
                result["reason"] = f"Action invalid. {result['suggestions'][0]}"
                logger.debug(f"Using first suggestion as reason: {result['reason']}")
        
        return result
    
    def _track_looted_entity(self, context: AgentContext) -> None:
        """
        Track an entity that has been looted to prevent double-looting.
        
        Args:
            context: The agent context with the entity being looted.
        """
        # Extract entity information from input
        player_input = context.player_input.lower()
        
        # Create a simple hash of the input and location to identify the entity
        location = context.player_state.get("current_location", "") if context.player_state else ""
        district = context.player_state.get("current_district", "") if context.player_state else ""
        
        entity_hash = hashlib.md5(f"{player_input}|{location}|{district}".encode()).hexdigest()
        
        # Add to the looted entities set
        self._looted_entities.add(entity_hash)
        logger.debug(f"Tracked looted entity: {entity_hash}")
    
    def _add_to_action_history(self, context: AgentContext, validation_result: Dict[str, Any]) -> None:
        """
        Add an action to the history for anti-cheat tracking.
        
        Args:
            context: The agent context.
            validation_result: The validation result.
        """
        import datetime
        
        action_entry = {
            "type": self._determine_action_type(context.player_input),
            "description": context.player_input,
            "location": context.player_state.get("current_location", "") if context.player_state else "",
            "district": context.player_state.get("current_district", "") if context.player_state else "",
            "is_valid": validation_result.get("is_valid", False),
            "reason": validation_result.get("reason"),
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        # Add to action history
        self._action_history.append(action_entry)
        
        # Limit history size
        if len(self._action_history) > 100:
            self._action_history = self._action_history[-100:]
    
    def _determine_action_type(self, input_text: str) -> str:
        """
        Determine the type of action from the input text.
        
        Args:
            input_text: The player input text.
        
        Returns:
            The action type.
        """
        input_lower = input_text.lower()
        
        if any(word in input_lower for word in ["attack", "fight", "hit", "strike", "combat"]):
            return "COMBAT"
        elif any(word in input_lower for word in ["loot", "take", "grab", "steal", "pick up"]):
            return "LOOT"
        elif any(word in input_lower for word in ["cast", "spell", "magic"]):
            return "MAGIC"
        elif any(word in input_lower for word in ["talk", "speak", "ask", "tell"]):
            return "DIALOGUE"
        elif any(word in input_lower for word in ["move", "go", "walk", "run", "travel"]):
            return "MOVEMENT"
        elif any(word in input_lower for word in ["use", "activate", "trigger"]):
            return "USE"
        elif any(word in input_lower for word in ["search", "look", "examine", "inspect"]):
            return "OBSERVATION"
        else:
            return "OTHER"
    
    def supports_command(self, command: str) -> bool:
        """
        Check if the rule checker agent supports a specific command.
        
        Args:
            command: The command name.
        
        Returns:
            True if the agent supports the command, False otherwise.
        """
        return command in self.SUPPORTED_COMMANDS
    
    def validate_action(self, context: AgentContext) -> Tuple[bool, Optional[str]]:
        """
        Validate a player action against game rules.
        
        Args:
            context: The agent context.
        
        Returns:
            A tuple of (is_valid, reason) where reason is None if valid.
        """
        # Log the action being validated
        logger.info(f"Validating action: {context.player_input[:100]}...")
        
        # Process the validation request
        response = self.process(context)
        
        # Get the validation result
        validation_result = response.metadata.get("validation_result", {})
        is_valid = validation_result.get("is_valid", False)
        reason = validation_result.get("reason")
        
        # Log more details about the validation result
        logger.info(f"Validation result: valid={is_valid}, reason={reason}")
        
        # If it's invalid but reason is None, provide a default
        if not is_valid and reason is None:
            reason = "Unspecified rule violation - rule checker could not determine specific reason"
            logger.warning(f"Rule checker returned invalid action with no reason. Using default: {reason}")
        
        # Debug log the full validation response if the result seems problematic
        if not is_valid or reason is None:
            # Log first 500 chars of the response content for debugging
            logger.debug(f"Rule checker response content (excerpt): {response.content[:500]}...")
        
        return is_valid, reason
    
    def is_already_looted(self, entity_description: str, location: str, district: str) -> bool:
        """
        Check if an entity has already been looted.
        
        Args:
            entity_description: Description of the entity.
            location: The location of the entity.
            district: The district within the location.
        
        Returns:
            True if the entity has already been looted, False otherwise.
        """
        # Create a hash of the entity
        entity_hash = hashlib.md5(f"{entity_description.lower()}|{location}|{district}".encode()).hexdigest()
        
        # Check if the entity is in the looted entities set
        return entity_hash in self._looted_entities
        
    def perform_skill_check(self, stat_type: str, difficulty: int, context: str = "") -> Dict[str, Any]:
        """
        Perform a skill check against a character stat.
        
        Args:
            stat_type: The type of stat to check (e.g., STR, DEX, INT)
            difficulty: The difficulty class (DC) of the check
            context: Optional description of the check context
            
        Returns:
            Dictionary with skill check results
        """
        from core.base.state import get_state_manager
        from core.stats.stats_base import StatType, DerivedStatType
        
        # Get the stats manager from the state manager
        state_manager = get_state_manager()
        if not state_manager or not state_manager.stats_manager:
            logger.warning("Stats manager not available for skill check")
            return {
                "success": False,
                "error": "Stats system not available"
            }
            
        stats_manager = state_manager.stats_manager
        
        try:
            # Convert string stat type to enum if needed
            if isinstance(stat_type, str):
                # Try to match with primary stat first
                try:
                    stat_enum = StatType.from_string(stat_type)
                except ValueError:
                    # Then try derived stat
                    try:
                        stat_enum = DerivedStatType.from_string(stat_type)
                    except ValueError:
                        logger.warning(f"Unknown stat type: {stat_type}")
                        return {
                            "success": False,
                            "error": f"Unknown stat type: {stat_type}"
                        }
            else:
                stat_enum = stat_type
                
            # Perform the skill check
            result = stats_manager.perform_skill_check(
                stat_type=stat_enum,
                difficulty=difficulty
            )
            
            # Return the result as a dictionary
            return {
                "success": True,
                "result": result,
                "context": context
            }
            
        except Exception as e:
            logger.error(f"Error performing skill check: {e}")
            return {
                "success": False,
                "error": str(e)
            }


# Convenience function
def get_rule_checker_agent() -> RuleCheckerAgent:
    """Get the rule checker agent instance."""
    return RuleCheckerAgent()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the rule checker agent
    rule_checker = get_rule_checker_agent()
    
    # Create a test context
    context = AgentContext(
        game_state={},
        player_state={
            "name": "Thorn",
            "race": "Elf",
            "path": "Ranger",
            "background": "Outcast",
            "current_location": "Whispering Woods",
            "current_district": "Ancient Grove",
            "strength": 12,
            "agility": 15,
            "constitution": 10,
            "intelligence": 13,
            "wisdom": 14,
            "charisma": 9,
            "health": 80,
            "max_health": 100,
            "stamina": 60,
            "max_stamina": 100,
            "mana": 90,
            "max_mana": 100
        },
        world_state={
            "time_of_day": "evening",
            "weather": "Light Rain",
            "is_day": False
        },
        player_input="I want to lift the boulder that's blocking the entrance to the cave.",
        conversation_history=[],
        relevant_memories=[],
        additional_context={
            "inventory": {
                "current_weight": 25,
                "weight_limit": 50
            }
        }
    )
    
    # Process the request
    response = rule_checker.process(context)
    
    # Print the response
    print(f"Response: {response.content}")
    print(f"Validation result: {response.metadata.get('validation_result')}")
```

### File: core\agents\social_conflict_agent.py

```python
#!/usr/bin/env python3
"""
Social Conflict agent for handling non-combat confrontations.
"""

import re
import json
import logging
from typing import List, Dict, Any

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode, SocialStatusEffect # Make sure SocialStatusEffect is imported
from core.stats.stats_base import Skill # Corrected: Import Skill from stats_base

logger = get_logger("AGENT")

class SocialConflictAgent(BaseAgent):
    """
    Agent responsible for managing social conflicts (debates, negotiations, interrogations).

    It receives social context (participants, relationships, goals, resolve) and player input,
    generates narrative describing the social exchange, and identifies necessary skill checks
    (e.g., Persuasion, Deception, Intimidation, Insight) or state changes (e.g., changing
    relationship stance, reducing Resolve/Composure).
    """

    def __init__(self):
        """Initialize the social conflict agent."""
        super().__init__("SocialConflict")

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the social conflict agent.
        """
        player_id = context.player_state.get("id", "player")
        # Extract social-specific context
        social_context = context.additional_context.get("social_context", {})
        participants_data = social_context.get("participants", []) # Assuming this contains dicts with participant info
        conflict_goal = social_context.get("goal", "Resolve the situation")
        current_topic = social_context.get("topic", "General discussion")

        # D3: Enhance participant list to show effects
        participant_list_parts = []
        for p in participants_data:
            effects = p.get('active_social_effects', [])
            # Ensure effects are strings before joining, handle potential non-string items gracefully
            effects_str = f" Effects: [{', '.join(map(str, effects))}]" if effects else ""
            participant_list_parts.append(
                f"- {p.get('name', 'Unknown')} (ID: {p.get('id', 'N/A')}, "
                f"Stance: {p.get('stance', 'Neutral')}, "
                f"Resolve: {p.get('resolve', '?')}/{p.get('max_resolve', '?')})"
                f"{effects_str}" # Add effects string
            )
        participant_list = "\n".join(participant_list_parts)


        # D3: Refined Prompt
        system_prompt = f"""You are the Social Conflict AI moderator for a text-based RPG. Your role is to narrate social interactions like debates, negotiations, interrogations, or persuasion attempts, and interpret player actions within this context.
You will receive the current social situation and the player's input describing their intended social action.
Your output MUST be a single JSON object adhering *exactly* to the `AgentOutput` structure defined below.

## Current Social Conflict State
- Participants:
{participant_list}
- Conflict Goal: {conflict_goal}
- Current Topic: {current_topic}
- Player ID: {player_id}

## Your Responsibilities
1.  **Narrate the Attempt:** Generate engaging narrative describing the player's *attempted* social maneuver based on their input (e.g., "You lean in, trying to appear sincere...", "You raise your voice, attempting to intimidate the guard...", "You calmly present your counter-argument..."). **Do not state success or failure in the narrative.** The game engine resolves checks and applies changes based on your requests.
2.  **Analyze Intent:** Analyze the player's natural language input (e.g., "I try to convince him to let us pass", "I lie about where we found the artifact", "I demand answers", "I offer a compromise") and the social context.
3.  **Request Actions (Skill Checks & State Changes):** Based on the player's intent and the context, determine the necessary game mechanic requests. Output these as a list in the `requests` field of the JSON.
    *   **Skill Checks (`request_skill_check`):**
        *   **When:** Request a skill check when the player attempts an action whose success is uncertain and depends on their social capabilities against a target's resistance.
        *   **Which Skill:**
            *   Use `{Skill.PERSUASION.name}` when the player tries to convince, reason, negotiate, charm, or appeal to emotion/logic.
            *   Use `{Skill.INTIMIDATION.name}` when the player tries to threaten, coerce, or frighten.
            *   Use `{Skill.DECEPTION.name}` when the player tries to lie, mislead, or feint.
            *   Use `{Skill.INSIGHT.name}` when the player tries to discern motives, detect lies, or understand someone's emotional state.
            *   Use other relevant skills (e.g., `{Skill.PERFORMANCE.name}`) if applicable.
        *   **Target:** Specify the `target_actor_id`. The `difficulty_class` (DC) should reflect the target's resistance (e.g., based on their Resolve, opposing skill, current stance, or situational factors). Provide context for the check.
    *   **State Changes (`request_state_change`):**
        *   **When:** Request a state change to reflect the direct consequences of a social action (often following a successful skill check, but sometimes as the primary action like offering a gift).
        *   **Resolve:** To reduce a target's `current_resolve` (social HP), use `attribute: "current_resolve"`, `change_type: "add"`, and a negative integer `value` (e.g., `value: -5`).
        *   **Social Status Effects:**
            *   To *add* an effect, use `attribute: "add_social_effect"` and set `value` to the string name of the effect from the `SocialStatusEffect` enum (e.g., `value: "{SocialStatusEffect.CHARMED.name}"`, `value: "{SocialStatusEffect.INTIMIDATED.name}"`).
            *   To *remove* an effect, use `attribute: "remove_social_effect"` and set `value` to the string name of the effect (e.g., `value: "{SocialStatusEffect.CHARMED.name}"`).
        *   **Other Changes:** You can also request changes to other attributes like `relationship_stance` if appropriate.
4.  **Output JSON:** Ensure your entire response is a single, valid JSON object matching the `AgentOutput` structure.

## Required Output Format (JSON)
```json
{{
  "narrative": "Your descriptive text about the attempted social action goes here. Describe the player's words, tone, body language, and the immediate reaction or atmosphere. Focus on the attempt, not the outcome.",
  "requests": [
    // Optional: Include structured requests based on player intent. Add one or more requests as needed.
    // Example 1: Persuasion Check
    {{
      "action": "request_skill_check",
      "actor_id": "{player_id}", // The one performing the check
      "skill_name": "{Skill.PERSUASION.name}", // Use the correct Skill enum name string
      "target_actor_id": "guard_captain", // ID of the target NPC being persuaded
      "difficulty_class": 15, // DC based on target's resistance/situation
      "context": "Player attempting to persuade the captain to grant access."
    }},
    // Example 2: Reducing Resolve via Intimidation (State Change - often follows successful Intimidation check)
     {{
      "action": "request_state_change",
      "target_entity": "stubborn_noble", // ID of the target NPC
      "attribute": "current_resolve", // Target the resolve attribute
      "change_type": "add", // Use 'add' for delta changes
      "value": -5, // Negative value to decrease resolve
      "context": "Result of successful intimidation attempt."
    }},
    // Example 3: Applying 'Charmed' Status (State Change - often follows successful Persuasion/Charm check)
    {{
      "action": "request_state_change",
      "target_entity": "merchant_guildmaster",
      "attribute": "add_social_effect", // Use 'add_social_effect'
      "change_type": "set", // Type is less relevant here, but 'set' or 'add' is fine
      "value": "{SocialStatusEffect.CHARMED.name}", // String name of the SocialStatusEffect enum member
      "context": "Result of successful charm attempt."
    }},
    // Example 4: Removing 'Intimidated' Status (State Change)
    {{
      "action": "request_state_change",
      "target_entity": "frightened_peasant",
      "attribute": "remove_social_effect", // Use 'remove_social_effect'
      "change_type": "set", // Type is less relevant here
      "value": "{SocialStatusEffect.INTIMIDATED.name}", // String name of the effect to remove
      "context": "Player successfully calmed the peasant."
    }}
    // Add more requests here if the player's action involves multiple steps/effects
  ]
}}
```

## Guidelines
- **Interpret Intent:** Focus on the player's goal and the *implied* social tactic (persuade, intimidate, deceive, etc.) even if they don't use specific keywords.
- **Context is Key:** Base your requested checks and changes on the provided participant details (Resolve, Stance, Effects) and the overall situation. A high-Resolve character might require a higher DC to intimidate. An already 'Friendly' character might be easier to persuade.
- **Clarity & Precision:** Ensure `requests` use the correct IDs, attribute names (`current_resolve`, `add_social_effect`, `remove_social_effect`), skill names (`{Skill.PERSUASION.name}`, etc.), and effect names (`{SocialStatusEffect.CHARMED.name}`, etc.).
- **Multi-Step Actions:** If the player describes a complex action (e.g., "I flatter him then ask for the key"), break it down into multiple requests if necessary (e.g., a Persuasion check for flattery potentially followed by another Persuasion check for the key, maybe with a modifier).
- **Safety:** Adhere to standard content safety guidelines.

Respond to the player's social input by generating the JSON `AgentOutput` object.
"""
        return system_prompt

    # D3: Update _format_social_context to potentially include effects if available in context data
    def _format_social_context(self, context: AgentContext) -> str:
        """ Formats the social conflict specific context """
        social_context = context.additional_context.get("social_context", {})
        if not social_context:
            return ""

        lines = ["## Social Conflict Situation"]
        participants_data = social_context.get("participants", [])
        conflict_goal = social_context.get("goal", "Resolve the situation")
        current_topic = social_context.get("topic", "General discussion")
        recent_exchange = social_context.get("recent_exchange", "N/A") # Last significant statement/action

        lines.append(f"- Goal: {conflict_goal}")
        lines.append(f"- Topic: {current_topic}")
        lines.append(f"- Recent Exchange: {recent_exchange}")
        lines.append("### Participants:")
        for p in participants_data:
            # D3: Include active effects in the formatted context string
            effects = p.get('active_social_effects', []) # Get effects list/set
            # Ensure effects are strings before joining
            effects_str = f" Effects: [{', '.join(map(str, effects))}]" if effects else ""
            lines.append(
                f"- {p.get('name', 'Unknown')} (ID: {p.get('id', 'N/A')}, "
                f"Stance: {p.get('stance', 'Neutral')}, "
                f"Resolve: {p.get('resolve', '?')}/{p.get('max_resolve', '?')}, "
                f"Goal: {p.get('goal', 'Unknown')})"
                f"{effects_str}" # Append formatted effects
            )
        return "\n".join(lines)

    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """ Prepare messages, adding social context. """
        messages = super()._prepare_messages(context) # Get base messages

        # Find the user message and prepend social context
        for msg in reversed(messages):
            if msg["role"] == "user":
                social_context_str = self._format_social_context(context)
                if social_context_str:
                     original_user_content = msg["content"]
                     input_marker = "## Player Input"
                     if input_marker in original_user_content:
                         parts = original_user_content.split(input_marker, 1)
                         msg["content"] = f"{parts[0]}{social_context_str}\n\n{input_marker}{parts[1]}"
                     else:
                         msg["content"] = f"{social_context_str}\n\n{original_user_content}"
                break
        return messages

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a social conflict request.
        """
        logger.info(f"Processing request with SocialConflict agent in mode: {context.game_state.get('mode', 'N/A')}")

        messages = self._prepare_messages(context)

        try:
            llm_response_content = self._llm_service.generate_response(messages)
            if not llm_response_content:
                 raise ValueError("LLM returned empty content.")
            logger.debug(f"Raw LLM Response (Social):\n{llm_response_content}")

            try:
                cleaned_response = re.sub(r'^```json\s*|\s*```$', '', llm_response_content, flags=re.MULTILINE | re.DOTALL).strip()
                parsed_output = json.loads(cleaned_response)

                if not isinstance(parsed_output, dict) or \
                   "narrative" not in parsed_output or \
                   "requests" not in parsed_output or \
                   not isinstance(parsed_output["requests"], list):
                    raise ValueError("LLM response is not a valid AgentOutput JSON structure.")

                validated_requests = []
                for req in parsed_output["requests"]:
                    if not isinstance(req, dict) or "action" not in req:
                        logger.warning(f"Skipping invalid request structure: {req}")
                        continue
                    validated_requests.append(req)

                agent_output: AgentOutput = {
                    "narrative": parsed_output.get("narrative", "Error: Narrative missing."),
                    "requests": validated_requests
                }

            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Social LLM response as JSON: {e}\nRaw response: {llm_response_content}")
                agent_output: AgentOutput = {
                    "narrative": f"[SocialConflict Error: Parse failed] {llm_response_content}",
                    "requests": []
                }
            except ValueError as e:
                 logger.error(f"Invalid AgentOutput structure from Social LLM: {e}\nParsed: {parsed_output}")
                 agent_output: AgentOutput = {
                    "narrative": f"[SocialConflict Error: Invalid structure] {parsed_output.get('narrative', llm_response_content)}",
                    "requests": []
                 }

        except Exception as e:
            logger.exception(f"Error during SocialConflict processing: {e}")
            agent_output: AgentOutput = {
                "narrative": f"[SocialConflict Error: Processing failed: {e}]",
                "requests": []
            }

        logger.info(f"SocialConflict generated {len(agent_output['requests'])} requests.")
        return agent_output

    def supports_command(self, command: str) -> bool:
        return False # Handles interactions via natural language and structured requests

# Convenience function
def get_social_conflict_agent() -> SocialConflictAgent:
    return SocialConflictAgent()
```

### File: core\agents\trade_agent.py

```python
#!/usr/bin/env python3
"""
Trade agent for handling buying, selling, and bartering interactions.
"""

import re
import json
import logging
from typing import List, Dict, Any

from core.utils.logging_config import get_logger
from core.agents.base_agent import BaseAgent, AgentContext
from core.interaction.structured_requests import AgentOutput, SkillCheckRequest, StateChangeRequest
from core.interaction.enums import InteractionMode

logger = get_logger("AGENT")

class TradeAgent(BaseAgent):
    """
    Agent responsible for managing trade interactions (buying, selling, bartering).

    It receives trade context (participants, inventories, current offers) and player input,
    generates narrative describing the trade negotiation, and identifies necessary skill checks
    (e.g., Appraise, Haggle/Barter) or state changes (transferring items/currency).
    """

    def __init__(self):
        """Initialize the trade agent."""
        super().__init__("Trade") # Use "Trade" as name for settings file trade.json

    def _generate_system_prompt(self, context: AgentContext) -> str:
        """
        Generate the system prompt for the trade agent.
        """
        player_info = context.additional_context.get("player_trade_info", {})
        partner_info = context.additional_context.get("trade_partner", {})

        player_id = context.player_state.get("id", "player") # Fallback if not in player_info
        player_currency = player_info.get("currency", "N/A")
        player_inv_str = ", ".join([f"{item.get('name', '?')} (Value: {item.get('value', 0)})" for item in player_info.get("inventory", [])]) or "Empty"

        trade_partner_id = partner_info.get("id", "unknown_merchant")
        trade_partner_name = partner_info.get("name", "Unknown Merchant")
        partner_currency = partner_info.get("currency", "N/A")
        partner_inv_str = ", ".join([f"{item.get('name', '?')} (Value: {item.get('value', 0)})" for item in partner_info.get("inventory", [])]) or "Empty"

        system_prompt = f"""You are the Trade AI facilitator for a text-based RPG. Your role is to narrate trading interactions (buying, selling, bartering) and interpret player actions within this context.

## Current Trade State
- Player: ID '{player_id}', Currency: {player_currency}
  - Inventory: {player_inv_str}
- Trade Partner: {trade_partner_name} (ID: {trade_partner_id}), Currency: {partner_currency}
  - Inventory: {partner_inv_str}

## Your Responsibilities
1.  **Narrate:** Describe the player's trade action, proposal, or inquiry based on their input (e.g., "You examine the sword closely...", "You offer 5 gold pieces for the potion.", "You try to haggle for a better price...").
2.  **Analyze Intent:** Understand the player's natural language input (e.g., "I want to buy the health potion", "I offer my old dagger for that shield", "How much for the map?", "Can you do 10 gold instead?", "I accept the deal", "What do you have for sale?", "I want to sell these pelts").
3.  **Identify Mechanics:** Determine if the player's action requires:
    *   **Skill Checks:** Primarily `BARTER` (associated with Charisma) for haggling/influencing prices. Use `APPRAISE` (associated with Intelligence) if the player explicitly tries to determine an item's value.
    *   **State Changes:** Although the final transaction (item/currency transfer) is usually handled by the game engine after an agreement, you should understand the *intent* behind buy/sell/offer actions.
4.  **Output JSON:** Format your entire response as a single JSON object adhering *exactly* to the `AgentOutput` structure defined below.

## Required Output Format (JSON)
```json
{{
  "narrative": "Your descriptive text about the trade interaction. Describe the item examination, the offer being made, the haggling attempt, or the agreement.",
  "requests": [
    // Optional: Include structured requests based on player intent.
    // --- Example 1: Barter Check ---
    // Triggered by inputs like "Can you do better?", "I offer 10 gold [when value is 15]", "I try to haggle".
    {{
      "request_type": "SkillCheckRequest", // Matches class name
      "entity_id": "{player_id}", // Who is performing the check
      "skill_name": "BARTER", // Use the BARTER skill for haggling
      "target_dc": 12, // Target DC determined by game logic (e.g., based on NPC disposition, offer difference) - provide a reasonable estimate if unsure
      "advantage": false,
      "disadvantage": false,
      "modifier": 0, // Any situational modifiers?
      "context": "Player attempting to haggle for a better price on [Item Name/Offer]."
    }},
    // --- Example 2: Appraise Check ---
    // Triggered by inputs like "What's this worth?", "Is this price fair?".
    // {{
    //   "request_type": "SkillCheckRequest",
    //   "entity_id": "{player_id}",
    //   "skill_name": "APPRAISE", // Use APPRAISE skill
    //   "target_dc": 10, // DC based on item rarity/complexity
    //   "advantage": false,
    //   "disadvantage": false,
    //   "modifier": 0,
    //   "context": "Player attempting to appraise the [Item Name]."
    // }},
    // --- Example 3: Transfer Item (State Change) ---
    // NOTE: The core loop usually handles this *after* an offer is accepted based on intent ("accept", "deal").
    // Only include this if the LLM *confidently* determines a final, agreed-upon transfer.
    // {{
    //   "request_type": "StateChangeRequest", // Matches class name
    //   "target_entity": "UNUSED_FOR_TRANSFER", // Not used directly for transfer_item attribute
    //   "attribute": "transfer_item",
    //   "value": {{ // Dictionary containing transfer details
    //     "item_id": "item_id_to_transfer", // Specific ID of the item
    //     "from_owner_id": "{trade_partner_id}", // ID of the entity giving the item
    //     "to_owner_id": "{player_id}" // ID of the entity receiving the item
    //   }},
    //   "context": "Item transferred as part of accepted trade."
    // }},
    // --- Example 4: Adjust Currency (State Change) ---
    // NOTE: Similar to item transfer, usually handled by core loop post-acceptance.
    // {{
    //   "request_type": "StateChangeRequest",
    //   "target_entity": "{player_id}", // ID of the entity whose currency is changing
    //   "attribute": "adjust_currency",
    //   "value": -50, // Amount to change (positive to add, negative to remove)
    //   "context": "Currency transferred as part of accepted trade."
    // }}
    // --- Focus ---
    // Your primary job is narrative + identifying necessary skill checks (BARTER/APPRAISE).
    // Let the game engine handle the mechanics of offer proposal, acceptance, and the resulting state changes based on player intent like 'accept' or specific offers like 'I offer X for Y'.
  ]
}}
```

## Guidelines
- **Narrate Clearly:** Describe the negotiation, item inspection, offers, counter-offers, inquiries ("What do you have?", "How much is...?").
- **Identify Intent:** Determine if the player is inquiring, offering ("I offer X for Y"), buying ("I want to buy Z"), selling ("I want to sell A"), accepting ("Deal", "I accept"), rejecting ("No thanks"), or haggling ("Can you do better?").
- **Infer Checks:** Request `BARTER` checks for haggling attempts. Request `APPRAISE` only if explicitly asked about value/fairness.
- **Use Context:** Refer to the player and partner inventories and currency provided in the state.
- **State Changes:** Generate `StateChangeRequest` for item/currency transfers *only if* you are certain the interaction represents a finalized, agreed transaction (less common, usually handled by the engine).
- **Safety:** Adhere to standard content safety guidelines.

Respond to the player's trade input by generating the JSON `AgentOutput` object.
"""
        return system_prompt

    def _format_trade_context(self, context: AgentContext) -> str:
        """ Formats the trade specific context """
        trade_context = context.additional_context.get("trade_context", {})
        if not trade_context:
            return ""

        lines = ["## Trade Situation"]
        participants = trade_context.get("participants", []) # Includes player and partner
        player_offer = trade_context.get("player_offer", {"items": [], "currency": 0})
        partner_offer = trade_context.get("partner_offer", {"items": [], "currency": 0})
        trade_partner_id = trade_context.get("trade_partner_id", "unknown_merchant")
        player_inventory = trade_context.get("player_inventory_summary", "Not available") # Expect summaries
        partner_inventory = trade_context.get("partner_inventory_summary", "Not available")

        # Format offers
        def format_offer(offer):
            items_str = ", ".join([f"{i.get('name', '?')} (x{i.get('quantity', 1)})" for i in offer.get('items', [])]) or "Nothing"
            curr = offer.get('currency', 0)
            # Basic currency assumption (copper) - needs refinement based on game system
            curr_str = f"{curr} copper" if curr else ""
            if items_str != "Nothing" and curr_str:
                return f"Items: {items_str}, Currency: {curr_str}"
            elif items_str != "Nothing":
                return f"Items: {items_str}"
            elif curr_str:
                return f"Currency: {curr_str}"
            else:
                return "Offer is empty"

        lines.append(f"- Trading With: {trade_partner_id}") # Assuming partner ID is known
        lines.append(f"- Player Offer: {format_offer(player_offer)}")
        lines.append(f"- Partner Offer: {format_offer(partner_offer)}")
        lines.append("### Player Inventory (Relevant for Trade)")
        lines.append(player_inventory) # Assumes pre-formatted summary
        lines.append("### Partner Inventory (Relevant for Trade)")
        lines.append(partner_inventory) # Assumes pre-formatted summary

        return "\n".join(lines)


    def _prepare_messages(self, context: AgentContext) -> List[Dict[str, str]]:
        """ Prepare messages, adding trade context. """
        messages = super()._prepare_messages(context) # Get base messages

        # Find the user message and prepend trade context
        for msg in reversed(messages):
            if msg["role"] == "user":
                trade_context_str = self._format_trade_context(context)
                if trade_context_str:
                     original_user_content = msg["content"]
                     input_marker = "## Player Input"
                     if input_marker in original_user_content:
                         parts = original_user_content.split(input_marker, 1)
                         msg["content"] = f"{parts[0]}{trade_context_str}\n\n{input_marker}{parts[1]}"
                     else:
                         msg["content"] = f"{trade_context_str}\n\n{original_user_content}"
                break
        return messages

    def process(self, context: AgentContext) -> AgentOutput:
        """
        Process a trade request.
        """
        logger.info(f"Processing request with Trade agent in mode: {context.game_state.get('mode', 'N/A')}")

        messages = self._prepare_messages(context)

        try:
            llm_response_content = self._llm_service.generate_response(messages)
            if not llm_response_content:
                 raise ValueError("LLM returned empty content.")
            logger.debug(f"Raw LLM Response (Trade):\n{llm_response_content}")

            try:
                cleaned_response = re.sub(r'^```json\s*|\s*```$', '', llm_response_content, flags=re.MULTILINE | re.DOTALL).strip()
                parsed_output = json.loads(cleaned_response)

                if not isinstance(parsed_output, dict) or \
                   "narrative" not in parsed_output or \
                   "requests" not in parsed_output or \
                   not isinstance(parsed_output["requests"], list):
                    raise ValueError("LLM response is not a valid AgentOutput JSON structure.")

                validated_requests = []
                for req in parsed_output["requests"]:
                    if not isinstance(req, dict) or "action" not in req:
                        logger.warning(f"Skipping invalid request structure: {req}")
                        continue
                    validated_requests.append(req)

                agent_output: AgentOutput = {
                    "narrative": parsed_output.get("narrative", "Error: Narrative missing."),
                    "requests": validated_requests
                }

            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Trade LLM response as JSON: {e}\nRaw response: {llm_response_content}")
                agent_output: AgentOutput = {
                    "narrative": f"[Trade Error: Parse failed] {llm_response_content}",
                    "requests": []
                }
            except ValueError as e:
                 logger.error(f"Invalid AgentOutput structure from Trade LLM: {e}\nParsed: {parsed_output}")
                 agent_output: AgentOutput = {
                    "narrative": f"[Trade Error: Invalid structure] {parsed_output.get('narrative', llm_response_content)}",
                    "requests": []
                 }

        except Exception as e:
            logger.exception(f"Error during Trade processing: {e}")
            agent_output: AgentOutput = {
                "narrative": f"[Trade Error: Processing failed: {e}]",
                "requests": []
            }

        logger.info(f"Trade generated {len(agent_output['requests'])} requests.")
        return agent_output

    def supports_command(self, command: str) -> bool:
        return False # Handles interactions via natural language and structured requests

# Convenience function
def get_trade_agent() -> TradeAgent:
    return TradeAgent()
```

### File: core\llm\__init__.py

```python
#!/usr/bin/env python3
"""
LLM module for provider management and completions.

This module provides classes for managing LLM providers, handling completions
from different LLM services (OpenAI, Anthropic, Google), and managing settings.
"""

from core.llm.provider_manager import ProviderManager, ProviderType, get_provider_manager
from core.llm.llm_manager import LLMManager, LLMResponse, LLMRole, get_llm_manager
from core.llm.settings_manager import SettingsManager, get_settings_manager

__all__ = [
    'ProviderManager',
    'ProviderType',
    'get_provider_manager',
    'LLMManager',
    'LLMResponse',
    'LLMRole',
    'get_llm_manager',
    'SettingsManager',
    'get_settings_manager'
]
```

### File: core\llm\llm_manager.py

```python
#!/usr/bin/env python3
"""
LLM manager for handling completions and interactions.

This module provides a LLMManager class that handles high-level LLM
interactions, including prompt formatting, completion retrieval,
and error handling.
"""

import time
import json
import asyncio
import datetime
from typing import Dict, List, Optional, Any, Union, Tuple, Callable
import logging
from enum import Enum

from core.utils.logging_config import get_logger
from core.base.config import get_config
from core.llm.provider_manager import ProviderManager, ProviderType, get_provider_manager

# Get the module logger
logger = get_logger("LLM")

class LLMRole(str, Enum):
    """Roles for LLM conversation."""
    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"
    FUNCTION = "function"

class LLMResponse:
    """
    Response from an LLM.
    
    This class represents a response from an LLM, including
    the content, token usage, and provider information.
    """
    
    def __init__(self, 
                 content: str,
                 provider_type: ProviderType,
                 model: str,
                 prompt_tokens: int = 0,
                 completion_tokens: int = 0,
                 total_tokens: int = 0,
                 cost: float = 0.0,
                 finish_reason: Optional[str] = None):
        """Initialize the LLM response."""
        self.content = content
        self.provider_type = provider_type
        self.model = model
        self.prompt_tokens = prompt_tokens
        self.completion_tokens = completion_tokens
        self.total_tokens = total_tokens or (prompt_tokens + completion_tokens)
        self.cost = cost
        self.finish_reason = finish_reason
        self.timestamp = datetime.datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "content": self.content,
            "provider_type": self.provider_type.name,
            "model": self.model,
            "prompt_tokens": self.prompt_tokens,
            "completion_tokens": self.completion_tokens,
            "total_tokens": self.total_tokens,
            "cost": self.cost,
            "finish_reason": self.finish_reason,
            "timestamp": self.timestamp
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'LLMResponse':
        """Create an LLMResponse from a dictionary."""
        provider_type = ProviderType[data.get("provider_type", "OPENAI")]
        return cls(
            content=data.get("content", ""),
            provider_type=provider_type,
            model=data.get("model", "unknown"),
            prompt_tokens=data.get("prompt_tokens", 0),
            completion_tokens=data.get("completion_tokens", 0),
            total_tokens=data.get("total_tokens", 0),
            cost=data.get("cost", 0.0),
            finish_reason=data.get("finish_reason")
        )


class LLMManager:
    """
    Manager for LLM interactions.
    
    This class handles high-level LLM interactions, including
    prompt formatting, completion retrieval, and error handling.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(LLMManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the LLM manager."""
        if self._initialized:
            return
        
        logger.info("Initializing LLMManager")
        
        # Get configuration
        self._config = get_config()
        
        # Get provider manager
        self._provider_manager = get_provider_manager()
        
        # Load LLM settings
        self._llm_settings = self._load_llm_settings()
        
        # Previously: optionally run diagnostics on startup based on settings.
        # Now: diagnostics are initiated from the GUI/CLI on-demand. Startup should not test providers.
        self._run_diagnostics = self._llm_settings.get("run_diagnostics_on_start", False)
        logger.debug("Skipping LLM diagnostics on startup; will run on-demand from GUI/CLI if requested.")
        
        self._initialized = True
        logger.info("LLMManager initialized")
    
    def _load_llm_settings(self) -> Dict[str, Any]:
        """
        Load LLM settings from configuration.
        
        Returns:
            Dictionary of LLM settings.
        """
        # Default settings
        default_settings = {
            "default_provider_type": "OPENAI",
            "default_temperature": 0.7,
            "max_tokens": 1000,
            "timeout_seconds": 30,
            "retry_attempts": 3,
            "retry_delay_seconds": 2,
            "run_diagnostics_on_start": False,
            "log_prompts": True,
            "log_completions": True,
            "cost_tracking_enabled": True
        }
        
        # Get settings from config
        config_settings = self._config.get("llm", {})
        
        # Merge with default settings
        merged_settings = {**default_settings, **config_settings}
        
        return merged_settings
    
    def get_completion(self, 
                      messages: List[Dict[str, str]],
                      provider_type: Optional[ProviderType] = None,
                      model: Optional[str] = None,
                      temperature: Optional[float] = None,
                      max_tokens: Optional[int] = None,
                      timeout: Optional[int] = None,
                      retry_attempts: Optional[int] = None) -> Optional[LLMResponse]:
        """
        Get a completion from an LLM.
        
        Args:
            messages: List of message dictionaries (role, content).
            provider_type: The provider type to use. If None, uses the default.
            model: The model to use. If None, uses the provider's default.
            temperature: The temperature to use. If None, uses the default.
            max_tokens: The maximum number of tokens to generate. If None, uses the default.
            timeout: The timeout in seconds. If None, uses the default.
            retry_attempts: The number of retry attempts. If None, uses the default.
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Determine the provider type
        if provider_type is None:
            provider_type_str = self._llm_settings.get("default_provider_type", "OPENAI")
            try:
                provider_type = ProviderType[provider_type_str]
            except (KeyError, ValueError):
                provider_type = ProviderType.OPENAI
                logger.warning(f"Invalid default provider type: {provider_type_str}. Using OpenAI.")
        
        # Check if the provider is available
        if not self._provider_manager.is_provider_available(provider_type):
            # Try to find an available provider
            fallback_provider = self._provider_manager.get_default_provider()
            if fallback_provider is None:
                logger.error("No LLM providers available")
                return None
            
            logger.warning(f"Provider {provider_type.name} not available. Falling back to {fallback_provider.name}.")
            provider_type = fallback_provider
        
        # Get provider client and settings
        client = self._provider_manager.get_client(provider_type)
        provider_settings = self._provider_manager.get_provider_settings(provider_type)
        
        # Determine model
        if model is None:
            model = provider_settings.get("default_model")
        
        # Set parameters
        temperature = temperature if temperature is not None else self._llm_settings.get("default_temperature", 0.7)
        max_tokens = max_tokens if max_tokens is not None else self._llm_settings.get("max_tokens", 1000)
        timeout = timeout if timeout is not None else self._llm_settings.get("timeout_seconds", 30)
        retry_attempts = retry_attempts if retry_attempts is not None else self._llm_settings.get("retry_attempts", 3)
        
        # Log the request
        if self._llm_settings.get("log_prompts", True):
            logger.debug(f"LLM Request: provider={provider_type.name}, model={model}, temperature={temperature}")
            for msg in messages:
                logger.debug(f"  {msg.get('role', 'unknown')}: {msg.get('content', '')[:100]}...")
        
        # Make the request with retries
        for attempt in range(retry_attempts + 1):
            try:
                if provider_type == ProviderType.OPENAI or provider_type == ProviderType.OPENROUTER:
                    return self._get_openai_completion(
                        client=client,
                        messages=messages,
                        model=model,
                        temperature=temperature,
                        max_tokens=max_tokens,
                        timeout=timeout,
                        provider_type=provider_type
                    )
                
                elif provider_type == ProviderType.ANTHROPIC:
                    return self._get_anthropic_completion(
                        client=client,
                        messages=messages,
                        model=model,
                        temperature=temperature,
                        max_tokens=max_tokens,
                        timeout=timeout,
                        provider_type=provider_type
                    )
                
                elif provider_type == ProviderType.GOOGLE:
                    return self._get_google_completion(
                        client=client,
                        messages=messages,
                        model=model,
                        temperature=temperature,
                        max_tokens=max_tokens,
                        timeout=timeout,
                        provider_type=provider_type
                    )
                
                else:
                    logger.error(f"Unsupported provider type: {provider_type.name}")
                    return None
                
            except Exception as e:
                if attempt < retry_attempts:
                    retry_delay = self._llm_settings.get("retry_delay_seconds", 2)
                    logger.warning(f"LLM request failed (attempt {attempt+1}/{retry_attempts+1}): {e}. Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    logger.error(f"LLM request failed after {retry_attempts+1} attempts: {e}")
                    return None
    
    def _get_openai_completion(self,
                              client: Any,
                              messages: List[Dict[str, str]],
                              model: str,
                              temperature: float,
                              max_tokens: int,
                              timeout: int,
                              provider_type: ProviderType) -> Optional[LLMResponse]:
        """
        Get a completion from OpenAI.
        
        Args:
            client: The OpenAI client.
            messages: List of message dictionaries.
            model: The model to use.
            temperature: The temperature to use.
            max_tokens: The maximum number of tokens to generate.
            timeout: The timeout in seconds.
            provider_type: The provider type (OpenAI or OpenRouter).
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Create the request parameters
        request_params = {
            "model": model,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens,
            "timeout": timeout
        }
        
        # Make the request
        response = client.chat.completions.create(**request_params)
        
        # Parse the response
        try:
            # Check if response is None or doesn't have expected structure
            if not response or not hasattr(response, 'choices') or not response.choices:
                logger.error(f"Invalid response format from {provider_type.name}: {response}")
                return None

            # Get message content
            content = response.choices[0].message.content
            
            # Get token usage (with fallbacks for OpenRouter which may not provide usage)
            if hasattr(response, 'usage') and response.usage:
                prompt_tokens = getattr(response.usage, 'prompt_tokens', 0)
                completion_tokens = getattr(response.usage, 'completion_tokens', 0)
                total_tokens = getattr(response.usage, 'total_tokens', 0) or (prompt_tokens + completion_tokens)
            else:
                # Estimate tokens if usage not provided
                logger.warning(f"Token usage not provided by {provider_type.name}, estimating")
                prompt_tokens = sum(len(msg.get("content", "")) for msg in messages) // 4  # Rough estimate
                completion_tokens = len(content) // 4  # Rough estimate
                total_tokens = prompt_tokens + completion_tokens
            
            # Get finish reason (with fallback)
            finish_reason = getattr(response.choices[0], 'finish_reason', 'unknown')
            
            # Log completion
            if self._llm_settings.get("log_completions", True):
                logger.debug(f"LLM Completion: provider={provider_type.name}, model={model}, tokens={total_tokens}")
                logger.debug(f"  content: {content[:100]}...")
            
            # Calculate cost (this is an approximation)
            cost = self._calculate_cost(model, prompt_tokens, completion_tokens, provider_type)
            
            return LLMResponse(
                content=content,
                provider_type=provider_type,
                model=model,
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                total_tokens=total_tokens,
                cost=cost,
                finish_reason=finish_reason
            )
            
        except Exception as e:
            logger.error(f"Error parsing OpenAI response: {e}")
            return None
    
    def _get_anthropic_completion(self,
                                 client: Any,
                                 messages: List[Dict[str, str]],
                                 model: str,
                                 temperature: float,
                                 max_tokens: int,
                                 timeout: int,
                                 provider_type: ProviderType) -> Optional[LLMResponse]:
        """
        Get a completion from Anthropic.
        
        Args:
            client: The Anthropic client.
            messages: List of message dictionaries.
            model: The model to use.
            temperature: The temperature to use.
            max_tokens: The maximum number of tokens to generate.
            timeout: The timeout in seconds.
            provider_type: The provider type.
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Convert messages to Anthropic format (human/assistant conversation)
        prompt = ""
        for msg in messages:
            role = msg.get("role", "user")
            content = msg.get("content", "")
            
            if role == "system":
                # Anthropic doesn't have system messages; add to the first user message
                continue
            elif role == "user":
                prompt += f"\n\nHuman: {content}"
            elif role == "assistant":
                prompt += f"\n\nAssistant: {content}"
        
        # Add final assistant prompt
        prompt += "\n\nAssistant:"
        
        # Create the request parameters
        request_params = {
            "prompt": prompt,
            "model": model,
            "temperature": temperature,
            "max_tokens_to_sample": max_tokens,
            "stop_sequences": ["\n\nHuman:"]
        }
        
        # Make the request
        response = client.completions.create(**request_params)
        
        # Parse the response
        try:
            content = response.completion
            
            # Anthropic doesn't provide token usage in the response
            # We can estimate based on content length
            prompt_tokens = len(prompt) // 4  # Rough estimate
            completion_tokens = len(content) // 4  # Rough estimate
            total_tokens = prompt_tokens + completion_tokens
            
            # Log completion
            if self._llm_settings.get("log_completions", True):
                logger.debug(f"LLM Completion: provider={provider_type.name}, model={model}, est_tokens={total_tokens}")
                logger.debug(f"  content: {content[:100]}...")
            
            # Calculate cost (this is an approximation)
            cost = self._calculate_cost(model, prompt_tokens, completion_tokens, provider_type)
            
            return LLMResponse(
                content=content,
                provider_type=provider_type,
                model=model,
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                total_tokens=total_tokens,
                cost=cost,
                finish_reason="stop"
            )
            
        except Exception as e:
            logger.error(f"Error parsing Anthropic response: {e}")
            return None
    
    def _get_google_completion(self,
                              client: Any,
                              messages: List[Dict[str, str]],
                              model: str,
                              temperature: float,
                              max_tokens: int,
                              timeout: int,
                              provider_type: ProviderType) -> Optional[LLMResponse]:
        """
        Get a completion from Google.
        
        Args:
            client: The Google client.
            messages: List of message dictionaries.
            model: The model to use.
            temperature: The temperature to use.
            max_tokens: The maximum number of tokens to generate.
            timeout: The timeout in seconds.
            provider_type: The provider type.
        
        Returns:
            An LLMResponse object, or None if the request failed.
        """
        # Initialize Google model
        generation_config = {
            "temperature": temperature,
            "max_output_tokens": max_tokens,
        }
        
        # Handle potentially empty safety settings for newer models
        if "gemini-2.0" in model or "gemini-2.5" in model:
            # For Gemini 2.0 and 2.5 models, we need to set safety settings explicitly
            safety_settings = {
                # Add minimal safety settings to avoid causing issues
                "HARASSMENT": "block_none",
                "HATE": "block_none",
                "SEXUAL": "block_none",
                "DANGEROUS": "block_none"
            }
            google_model = client.GenerativeModel(
                model_name=model,
                generation_config=generation_config,
                safety_settings=safety_settings
            )
        else:
            # For older models, use default safety settings
            google_model = client.GenerativeModel(
                model_name=model,
                generation_config=generation_config
            )
        
        # Convert messages to Google format
        gemini_messages = []
        system_content = ""
        
        # Extract system messages first
        for msg in messages:
            if msg.get("role") == "system":
                system_content += msg.get("content", "") + "\n"
        
        # Add system content as a prefix to the first user message if any
        user_msg_found = False
        
        for msg in messages:
            role = msg.get("role", "user")
            content = msg.get("content", "")
            
            if role == "user":
                if not user_msg_found and system_content:
                    # Add system content to first user message
                    content = system_content + "\n\n" + content
                    system_content = ""
                    user_msg_found = True
                
                # Ensure content is not empty
                if not content.strip():
                    content = "Hello, please respond."
                    
                gemini_messages.append({"role": "user", "parts": [content]})
            elif role == "assistant":
                # Ensure content is not empty
                if not content.strip():
                    continue  # Skip empty assistant messages
                    
                gemini_messages.append({"role": "model", "parts": [content]})
        
        # Make sure we have at least one user message
        if not user_msg_found and system_content:
            gemini_messages.append({"role": "user", "parts": [system_content]})
        
        # Make sure we have at least one message
        if not gemini_messages:
            gemini_messages.append({"role": "user", "parts": ["Hello, please respond."]})
        
        # Generate a response
        # Debugging the exact message format sent
        logger.debug(f"Sending Gemini messages: {json.dumps(gemini_messages, indent=2)}")
        
        # Handle message formatting based on Gemini model
        try:
            if "gemini-2.0" in model:
                if len(gemini_messages) == 1:
                    # For single messages with newer Gemini models
                    content = gemini_messages[0]["parts"][0]
                    response = google_model.generate_content(content)
                else:
                    # For conversations with newer Gemini models
                    # Convert to Google's newer chat format
                    chat = []
                    for msg in gemini_messages:
                        if msg["role"] == "user":
                            chat.append({"role": "user", "parts": [{"text": msg["parts"][0]}]})
                        elif msg["role"] == "model":
                            chat.append({"role": "model", "parts": [{"text": msg["parts"][0]}]})
                    
                    response = google_model.generate_content(chat)
            else:
                # For older Gemini models
                response = google_model.generate_content(gemini_messages)
        except Exception as e:
            # Fallback to the simplest possible request
            logger.warning(f"Error with standard Gemini format: {e}. Trying fallback format...")
            
            # Create a simple prompt from the messages
            combined_prompt = ""
            for msg in messages:
                role = msg.get("role", "unknown")
                content = msg.get("content", "")
                if content:
                    combined_prompt += f"{role}: {content}\n\n"
            
            if not combined_prompt:
                combined_prompt = "Hello, please respond."
                
            response = google_model.generate_content(combined_prompt)
        
        # Parse the response
        try:
            content = response.text
            
            # Google doesn't provide token usage in the response
            # We can estimate based on content length
            prompt_tokens = sum(len(msg.get("content", "")) for msg in messages) // 4  # Rough estimate
            completion_tokens = len(content) // 4  # Rough estimate
            total_tokens = prompt_tokens + completion_tokens
            
            # Log completion
            if self._llm_settings.get("log_completions", True):
                logger.debug(f"LLM Completion: provider={provider_type.name}, model={model}, est_tokens={total_tokens}")
                logger.debug(f"  content: {content[:100]}...")
            
            # Calculate cost (this is an approximation)
            cost = self._calculate_cost(model, prompt_tokens, completion_tokens, provider_type)
            
            return LLMResponse(
                content=content,
                provider_type=provider_type,
                model=model,
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                total_tokens=total_tokens,
                cost=cost,
                finish_reason="stop"
            )
            
        except Exception as e:
            logger.error(f"Error parsing Google response: {e}")
            return None
    
    def _calculate_cost(self, 
                       model: str, 
                       prompt_tokens: int, 
                       completion_tokens: int,
                       provider_type: ProviderType) -> float:
        """
        Calculate the cost of a completion.
        
        Args:
            model: The model used.
            prompt_tokens: The number of prompt tokens.
            completion_tokens: The number of completion tokens.
            provider_type: The provider type.
        
        Returns:
            The cost in USD.
        """
        # Define pricing by provider and model
        # These are approximate and may need to be updated
        pricing = {
            ProviderType.OPENAI: {
                "gpt-4o-mini": {
                    "prompt": 0.0015,  # per 1000 tokens
                    "completion": 0.002  # per 1000 tokens
                },
                "gpt-4o": {
                    "prompt": 0.03,  # per 1000 tokens
                    "completion": 0.06  # per 1000 tokens
                }
            },
            ProviderType.ANTHROPIC: {
                "claude-3-7-sonnet-latest": {
                    "prompt": 0.01,  # per 1000 tokens
                    "completion": 0.03  # per 1000 tokens
                },
                "claude-3-5-haiku-latest": {
                    "prompt": 0.0015,  # per 1000 tokens
                    "completion": 0.0055  # per 1000 tokens
                }
            },
            ProviderType.GOOGLE: {
                "gemini-pro": {
                    "prompt": 0.0005,  # per 1000 tokens
                    "completion": 0.0015  # per 1000 tokens
                }
            },
            ProviderType.OPENROUTER: {
                # OpenRouter has variable pricing; using approximations
                "google/gemini-2.0-flash-lite-preview-02-05:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                },
                "nousresearch/deephermes-3-llama-3-8b-preview:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                },
                "google/gemini-2.0-pro-exp-02-05:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0 # per 1000 tokens
                },
                "mistralai/mistral-small-3.1-24b-instruct:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                },
                "mistralai/mistral-small-3.1-24b-instruct:free": {
                    "prompt": 0.0,  # per 1000 tokens
                    "completion": 0.0  # per 1000 tokens
                }
            }
        }
        
        # Get pricing for the model
        provider_pricing = pricing.get(provider_type, {})
        model_pricing = provider_pricing.get(model, None)
        
        if model_pricing is None:
            # Use default pricing if the model is not found
            model_pricing = {"prompt": 0.001, "completion": 0.002}
        
        # Calculate cost
        prompt_cost = (prompt_tokens / 1000) * model_pricing["prompt"]
        completion_cost = (completion_tokens / 1000) * model_pricing["completion"]
        
        return prompt_cost + completion_cost
    
    def run_llm_diagnostics(self) -> Dict[str, Any]:
        """
        Run diagnostics on available LLM providers.
        
        Returns:
            Dictionary with diagnostic results.
        """
        results = {
            "timestamp": datetime.datetime.now().isoformat(),
            "providers": {}
        }
        
        # Check available providers
        available_providers = self._provider_manager.get_available_providers()
        
        if not available_providers:
            logger.warning("No LLM providers available")
            results["status"] = "error"
            results["error"] = "No LLM providers available"
            return results
        
        # Test each available provider
        for provider in available_providers:
            provider_name = provider.name
            
            logger.info(f"Testing LLM provider: {provider_name}")
            
            # Verify the client
            client_ok = self._provider_manager.verify_client(provider)
            
            if not client_ok:
                logger.warning(f"Provider {provider_name} client verification failed")
                results["providers"][provider_name] = {
                    "status": "error",
                    "error": "Client verification failed"
                }
                continue
            
            # Test a simple completion
            test_messages = [
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": "Hello, world! Please respond with 'Hello from the LLM!'"}
            ]
            
            try:
                response = self.get_completion(
                    messages=test_messages,
                    provider_type=provider,
                    temperature=0.0,  # Use deterministic output for testing
                    max_tokens=20,
                    timeout=30,
                    retry_attempts=1
                )
                
                if response:
                    logger.info(f"Provider {provider_name} test successful")
                    
                    results["providers"][provider_name] = {
                        "status": "success",
                        "model": response.model,
                        "response_content": response.content.strip(),
                        "tokens": {
                            "prompt": response.prompt_tokens,
                            "completion": response.completion_tokens,
                            "total": response.total_tokens
                        },
                        "cost": response.cost
                    }
                else:
                    logger.warning(f"Provider {provider_name} test failed: No response")
                    
                    results["providers"][provider_name] = {
                        "status": "error",
                        "error": "No response from LLM"
                    }
            
            except Exception as e:
                logger.error(f"Provider {provider_name} test error: {e}")
                
                results["providers"][provider_name] = {
                    "status": "error",
                    "error": str(e)
                }
        
        # Overall status
        success_count = sum(1 for p in results["providers"].values() if p.get("status") == "success")
        
        if success_count > 0:
            results["status"] = "success"
            results["message"] = f"{success_count}/{len(results['providers'])} providers operational"
        else:
            results["status"] = "error"
            results["message"] = "No operational providers found"
        
        # Log summary
        logger.info(f"LLM diagnostics complete: {results['message']}")
        
        return results


# Convenience function
def get_llm_manager() -> LLMManager:
    """Get the LLM manager instance."""
    return LLMManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the LLM manager
    manager = get_llm_manager()
    
    # Run diagnostics
    diagnostics = manager.run_llm_diagnostics()
    print(f"Diagnostics: {diagnostics['status']} - {diagnostics['message']}")
    
    # Test completion
    messages = [
        {"role": "system", "content": "You are a helpful assistant for an RPG game."},
        {"role": "user", "content": "Describe a small village."}
    ]
    
    response = manager.get_completion(messages)
    
    if response:
        print(f"Response from {response.provider_type.name} ({response.model}):")
        print(response.content)
        print(f"Tokens: {response.total_tokens} (${response.cost:.6f})")
    else:
        print("No response from LLM.")
```

### File: core\llm\provider_manager.py

```python
#!/usr/bin/env python3
"""
Provider manager for LLM interactions.

This module provides a ProviderManager class that handles initialization
and management of different LLM providers (OpenAI, Anthropic, Google).
"""

import os
import json
from typing import Dict, List, Optional, Any, Union
import logging
from enum import Enum, auto

from core.utils.logging_config import get_logger
from core.base.config import get_config

# Load environment variables from .env if present (applies to GUI and web server contexts)
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    # dotenv is optional; continue without failing if not available
    pass

# Import LLM provider libraries
try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
except ImportError:
    ANTHROPIC_AVAILABLE = False

try:
    import google.generativeai as genai
    GOOGLE_AVAILABLE = True
except ImportError:
    GOOGLE_AVAILABLE = False

# Get the module logger
logger = get_logger("LLM")

class ProviderType(Enum):
    """Enum for different LLM providers."""
    OPENAI = auto()
    ANTHROPIC = auto()
    GOOGLE = auto()
    OPENROUTER = auto()

class ProviderManager:
    """
    Manager for LLM providers.
    
    This class handles initialization and management of different LLM providers,
    including API keys, client creation, and provider configuration.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(ProviderManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the provider manager."""
        if self._initialized:
            return
        
        logger.info("Initializing ProviderManager")
        
        # Get configuration
        self._config = get_config()
        
        # Load provider settings
        self._provider_settings = self._load_provider_settings()
        
        # Initialize clients dictionary
        self._clients = {}
        
        # Initialize provider availability
        self._provider_availability = {
            ProviderType.OPENAI: OPENAI_AVAILABLE,
            ProviderType.ANTHROPIC: ANTHROPIC_AVAILABLE,
            ProviderType.GOOGLE: GOOGLE_AVAILABLE,
            ProviderType.OPENROUTER: OPENAI_AVAILABLE,  # OpenRouter uses OpenAI's API
        }
        
        # Initialize the providers
        self._initialize_providers()
        
        self._initialized = True
        logger.info("ProviderManager initialized")
    
    def _load_provider_settings(self) -> Dict[str, Any]:
        """
        Load provider settings from configuration files, then override with environment variables.
        
        Returns:
            Dictionary of provider settings.
        """
        # Default settings
        default_settings = {
            "openai": {
                "api_key": "",
                "organization": "",
                "api_base": "https://api.openai.com/v1",
                "default_model": "gpt-4o-mini",
                "available_models": ["gpt-4o-mini"],
                "enabled": True
            },

            "google": {
                "api_key": "",
                "default_model": "gemini-2.0-flash",
                "enabled": True
            },
            "openrouter": {
                "api_key": "",
                "api_base": "https://openrouter.ai/api/v1",
                "default_model": "nousresearch/deephermes-3-llama-3-8b-preview:free",
                "available_models": [
                "google/gemini-2.0-flash-exp:free",
                "google/gemini-2.0-flash-lite-preview-02-05:free",
                "nousresearch/deephermes-3-llama-3-8b-preview:free",
                "google/gemini-2.0-pro-exp-02-05:free",
                "mistralai/mistral-small-3.1-24b-instruct:free"
                ],
                "enabled": True
            }
        }
        
        # Try to load provider settings from file
        providers_file = os.path.join("config", "llm", "providers.json")
        if os.path.exists(providers_file):
            try:
                with open(providers_file, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    
                    # Merge with default settings
                    for provider, settings in loaded_settings.items():
                        if provider in default_settings:
                            default_settings[provider].update(settings)
                        else:
                            default_settings[provider] = settings
                            
                logger.info(f"Loaded provider settings from {providers_file}")
            except Exception as e:
                logger.error(f"Error loading provider settings: {e}")
        else:
            logger.warning(f"Provider settings file not found: {providers_file}")
            
            # Create default provider settings file
            try:
                os.makedirs(os.path.dirname(providers_file), exist_ok=True)
                with open(providers_file, 'w', encoding='utf-8') as f:
                    json.dump(default_settings, f, indent=4)
                logger.info(f"Created default provider settings file: {providers_file}")
            except Exception as e:
                logger.error(f"Error creating default provider settings file: {e}")
        
        # Override with environment variables if present (prefers env over file)
        env_overrides: Dict[str, Dict[str, Optional[str]]] = {
            "openai": {
                "api_key": os.getenv("OPENAI_API_KEY"),
                "organization": os.getenv("OPENAI_ORG") or os.getenv("OPENAI_ORGANIZATION"),
                "api_base": os.getenv("OPENAI_API_BASE") or os.getenv("OPENAI_BASE_URL"),
            },
            "google": {
                "api_key": os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY"),
            },
            "openrouter": {
                "api_key": os.getenv("OPENROUTER_API_KEY"),
                "api_base": os.getenv("OPENROUTER_API_BASE"),
            },
            "anthropic": {
                "api_key": os.getenv("ANTHROPIC_API_KEY"),
            },
        }
        
        for provider, fields in env_overrides.items():
            if provider not in default_settings:
                default_settings[provider] = {}
            for key, value in fields.items():
                if value and isinstance(value, str) and value.strip():
                    default_settings[provider][key] = value.strip()
                    # Don't log secrets; only note which provider field came from env
                    logger.debug(f"Using environment value for {provider}.{key}")
        
        return default_settings
    
    def _initialize_providers(self) -> None:
        """Initialize LLM provider clients."""
        self._initialize_openai()
        self._initialize_anthropic()
        self._initialize_google()
        self._initialize_openrouter()
    
    def _initialize_openai(self) -> None:
        """Initialize OpenAI client."""
        if not self._provider_availability[ProviderType.OPENAI]:
            logger.warning("OpenAI library not available")
            return
        
        settings = self._provider_settings.get("openai", {})
        if not settings.get("enabled", True):
            logger.info("OpenAI provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("OpenAI API key not configured")
            return
        
        try:
            # Initialize the client
            client = openai.OpenAI(
                api_key=api_key,
                organization=settings.get("organization", ""),
                base_url=settings.get("api_base", "https://api.openai.com/v1")
            )
            
            # Store the client
            self._clients[ProviderType.OPENAI] = {
                "client": client,
                "settings": settings
            }
            
            logger.info("OpenAI client initialized")
        except Exception as e:
            logger.error(f"Error initializing OpenAI client: {e}")
    
    def _initialize_anthropic(self) -> None:
        """Initialize Anthropic client."""
        if not self._provider_availability[ProviderType.ANTHROPIC]:
            logger.warning("Anthropic library not available")
            return
        
        settings = self._provider_settings.get("anthropic", {})
        if not settings.get("enabled", True):
            logger.info("Anthropic provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("Anthropic API key not configured")
            return
        
        try:
            # Initialize the client
            client = anthropic.Anthropic(
                api_key=api_key
            )
            
            # Store the client
            self._clients[ProviderType.ANTHROPIC] = {
                "client": client,
                "settings": settings
            }
            
            logger.info("Anthropic client initialized")
        except Exception as e:
            logger.error(f"Error initializing Anthropic client: {e}")
    
    def _initialize_google(self) -> None:
        """Initialize Google client."""
        if not self._provider_availability[ProviderType.GOOGLE]:
            logger.warning("Google library not available")
            return
        
        settings = self._provider_settings.get("google", {})
        if not settings.get("enabled", True):
            logger.info("Google provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("Google API key not configured")
            return
        
        try:
            # Initialize the client
            genai.configure(api_key=api_key)
            
            # Store the client
            self._clients[ProviderType.GOOGLE] = {
                "client": genai,
                "settings": settings
            }
            
            logger.info("Google client initialized")
        except Exception as e:
            logger.error(f"Error initializing Google client: {e}")
    
    def _initialize_openrouter(self) -> None:
        """Initialize OpenRouter client."""
        if not self._provider_availability[ProviderType.OPENROUTER]:
            logger.warning("OpenRouter requires OpenAI library which is not available")
            return
        
        settings = self._provider_settings.get("openrouter", {})
        if not settings.get("enabled", True):
            logger.info("OpenRouter provider disabled in settings")
            return
        
        api_key = settings.get("api_key", "")
        if not api_key:
            logger.warning("OpenRouter API key not configured")
            return
        
        try:
            # Initialize the client
            client = openai.OpenAI(
                api_key=api_key,
                base_url=settings.get("api_base", "https://openrouter.ai/api/v1")
            )
            
            # Store the client
            self._clients[ProviderType.OPENROUTER] = {
                "client": client,
                "settings": settings
            }
            
            logger.info("OpenRouter client initialized")
        except Exception as e:
            logger.error(f"Error initializing OpenRouter client: {e}")
    
    def get_client(self, provider_type: ProviderType) -> Optional[Any]:
        """
        Get a provider client.
        
        Args:
            provider_type: The type of provider.
        
        Returns:
            The provider client, or None if not available.
        """
        if provider_type not in self._clients:
            logger.warning(f"Provider client not available: {provider_type.name}")
            return None
        
        return self._clients[provider_type]["client"]
    
    def get_provider_settings(self, provider_type: ProviderType) -> Dict[str, Any]:
        """
        Get provider settings.
        
        Args:
            provider_type: The type of provider.
        
        Returns:
            The provider settings.
        """
        provider_map = {
            ProviderType.OPENAI: "openai",
            ProviderType.ANTHROPIC: "anthropic",
            ProviderType.GOOGLE: "google",
            ProviderType.OPENROUTER: "openrouter"
        }
        
        provider_name = provider_map.get(provider_type)
        return self._provider_settings.get(provider_name, {})
    
    def is_provider_available(self, provider_type: ProviderType) -> bool:
        """
        Check if a provider is available.
        
        Args:
            provider_type: The type of provider.
        
        Returns:
            True if the provider is available, False otherwise.
        """
        # Check library availability
        if not self._provider_availability.get(provider_type, False):
            return False
        
        # Check if provider is enabled and initialized
        return provider_type in self._clients
    
    def get_available_providers(self) -> List[ProviderType]:
        """
        Get a list of available providers.
        
        Returns:
            List of available provider types.
        """
        return [
            provider for provider in ProviderType 
            if self.is_provider_available(provider)
        ]
    
    def verify_client(self, provider_type: ProviderType) -> bool:
        """
        Verify that a provider client is working.
        
        Args:
            provider_type: The type of provider to verify.
        
        Returns:
            True if the client is working, False otherwise.
        """
        if not self.is_provider_available(provider_type):
            logger.warning(f"Provider not available: {provider_type.name}")
            return False
        
        # Get the client
        client = self.get_client(provider_type)
        if not client:
            return False
        
        # Test prompt
        test_prompt = "Hello, this is a test prompt to verify API connectivity. Please respond with 'OK'."
        
        try:
            # Attempt to get a completion based on provider type
            if provider_type == ProviderType.OPENAI:
                response = client.chat.completions.create(
                    model=self.get_provider_settings(provider_type).get("default_model"),
                    messages=[{"role": "user", "content": test_prompt}],
                    max_tokens=10
                )
                return True
            
            elif provider_type == ProviderType.ANTHROPIC:
                response = client.completions.create(
                    prompt=f"\n\nHuman: {test_prompt}\n\nAssistant:",
                    model=self.get_provider_settings(provider_type).get("default_model"),
                    max_tokens_to_sample=10
                )
                return True
            
            elif provider_type == ProviderType.GOOGLE:
                model = client.GenerativeModel(
                    self.get_provider_settings(provider_type).get("default_model")
                )
                response = model.generate_content(test_prompt)
                return True
            
            elif provider_type == ProviderType.OPENROUTER:
                response = client.chat.completions.create(
                    model=self.get_provider_settings(provider_type).get("default_model"),
                    messages=[{"role": "user", "content": test_prompt}],
                    max_tokens=10
                )
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"Error verifying {provider_type.name} client: {e}")
            return False
    
    def get_default_provider(self) -> Optional[ProviderType]:
        """
        Get the default provider type based on availability.
        
        Returns:
            The default provider type, or None if no providers are available.
        """
        available_providers = self.get_available_providers()
        
        if not available_providers:
            return None
            
        # Return the first available provider in priority order
        priority_order = [
            ProviderType.OPENAI, 
            ProviderType.ANTHROPIC, 
            ProviderType.GOOGLE,
            ProviderType.OPENROUTER
        ]
        
        for provider in priority_order:
            if provider in available_providers:
                return provider
        
        # If none in priority order, return the first available
        return available_providers[0]
    
    def update_provider_settings(self, provider_type: ProviderType, 
                                settings: Dict[str, Any]) -> bool:
        """
        Update settings for a provider.
        
        Args:
            provider_type: The type of provider.
            settings: The new settings.
        
        Returns:
            True if the settings were updated successfully, False otherwise.
        """
        provider_map = {
            ProviderType.OPENAI: "openai",
            ProviderType.ANTHROPIC: "anthropic",
            ProviderType.GOOGLE: "google",
            ProviderType.OPENROUTER: "openrouter"
        }
        
        provider_name = provider_map.get(provider_type)
        if not provider_name:
            return False
        
        try:
            # Update in-memory settings
            if provider_name in self._provider_settings:
                self._provider_settings[provider_name].update(settings)
            else:
                self._provider_settings[provider_name] = settings
            
            # Update settings file
            providers_file = os.path.join("config", "llm", "providers.json")
            with open(providers_file, 'w', encoding='utf-8') as f:
                json.dump(self._provider_settings, f, indent=4)
            
            # Reinitialize the provider
            if provider_type == ProviderType.OPENAI:
                self._initialize_openai()
            elif provider_type == ProviderType.ANTHROPIC:
                self._initialize_anthropic()
            elif provider_type == ProviderType.GOOGLE:
                self._initialize_google()
            elif provider_type == ProviderType.OPENROUTER:
                self._initialize_openrouter()
            
            logger.info(f"Updated settings for provider: {provider_name}")
            return True
        
        except Exception as e:
            logger.error(f"Error updating provider settings: {e}")
            return False


# Convenience function
def get_provider_manager() -> ProviderManager:
    """Get the provider manager instance."""
    return ProviderManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the provider manager
    manager = get_provider_manager()
    
    # Check available providers
    available_providers = manager.get_available_providers()
    print(f"Available providers: {[p.name for p in available_providers]}")
    
    # Get default provider
    default_provider = manager.get_default_provider()
    if default_provider:
        print(f"Default provider: {default_provider.name}")
    else:
        print("No providers available")
```

### File: core\llm\settings_cli.py

```python
#!/usr/bin/env python3
"""
Command line interface for managing LLM settings.

This module provides a command line utility for managing LLM settings,
including API keys, provider selection, and agent configuration.
"""

import os
import sys
import argparse
import json
from typing import Dict, List, Optional, Any
import logging

from core.utils.logging_config import get_logger
from core.llm.settings_manager import SettingsManager, get_settings_manager
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = get_logger("LLM")

def print_header(text: str) -> None:
    """Print a header with decoration."""
    print("\n" + "=" * 60)
    print(f"  {text}")
    print("=" * 60)

def print_section(text: str) -> None:
    """Print a section header."""
    print(f"\n-- {text} --")

def print_json(data: Dict[str, Any]) -> None:
    """Print data as formatted JSON."""
    print(json.dumps(data, indent=2))

def format_provider_type(provider_type: ProviderType) -> str:
    """Format a provider type for display."""
    return provider_type.name.capitalize()

class SettingsCLI:
    """
    Command line interface for managing LLM settings.
    """
    
    def __init__(self):
        """Initialize the settings CLI."""
        self._settings_manager = get_settings_manager()
    
    def show_main_menu(self) -> None:
        """Show the main menu."""
        while True:
            print_header("LLM Settings Manager")
            print("\n1. Manage LLM General Settings")
            print("2. Manage Provider Settings")
            print("3. Manage Agent Settings")
            print("4. Run LLM Diagnostics")
            print("0. Exit")
            
            choice = input("\nEnter your choice: ")
            
            if choice == '1':
                self.manage_llm_settings()
            elif choice == '2':
                self.manage_provider_settings()
            elif choice == '3':
                self.manage_agent_settings()
            elif choice == '4':
                self.run_llm_diagnostics()
            elif choice == '0':
                print("Exiting. Goodbye!")
                break
            else:
                print("Invalid choice. Please try again.")
    
    def manage_llm_settings(self) -> None:
        """Manage general LLM settings."""
        print_header("General LLM Settings")
        
        settings = self._settings_manager.get_llm_settings()
        print_json(settings)
        
        print_section("Update Settings")
        print("Which setting would you like to update? (Enter setting name, or 'back' to go back)")
        
        setting_name = input("> ")
        
        if setting_name.lower() == 'back':
            return
        
        if setting_name in settings:
            current_value = settings[setting_name]
            print(f"Current value: {current_value} (type: {type(current_value).__name__})")
            
            if isinstance(current_value, bool):
                new_value_str = input(f"New value (true/false): ").lower()
                new_value = new_value_str in ['true', 'yes', 'y', '1']
            elif isinstance(current_value, int):
                new_value = int(input(f"New value (integer): "))
            elif isinstance(current_value, float):
                new_value = float(input(f"New value (number): "))
            elif isinstance(current_value, list):
                print("Enter values separated by commas:")
                new_value = [item.strip() for item in input("> ").split(',')]
            elif isinstance(current_value, dict):
                print("Cannot update nested dictionary from CLI. Please edit the JSON file directly.")
                return
            else:
                new_value = input(f"New value (string): ")
            
            # Update the setting
            self._settings_manager.update_llm_settings({setting_name: new_value})
            print(f"Updated {setting_name} to {new_value}")
        else:
            print(f"Setting '{setting_name}' not found.")
    
    def manage_provider_settings(self) -> None:
        """Manage provider settings."""
        while True:
            print_header("Provider Settings")
            
            # Get provider settings
            all_settings = self._settings_manager.get_provider_settings()
            
            # Display provider menu
            for i, (provider, _) in enumerate(all_settings.items(), 1):
                print(f"{i}. {provider.capitalize()}")
            
            print("0. Back")
            
            choice = input("\nSelect provider: ")
            
            if choice == '0':
                return
            
            try:
                index = int(choice) - 1
                if 0 <= index < len(all_settings):
                    provider = list(all_settings.keys())[index]
                    self.manage_specific_provider(provider)
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Please enter a number.")
    
    def manage_specific_provider(self, provider_name: str) -> None:
        """
        Manage settings for a specific provider.
        
        Args:
            provider_name: The name of the provider.
        """
        provider_map = {
            "openai": ProviderType.OPENAI,
            "anthropic": ProviderType.ANTHROPIC,
            "google": ProviderType.GOOGLE,
            "openrouter": ProviderType.OPENROUTER
        }
        
        provider_type = provider_map.get(provider_name)
        if not provider_type:
            print(f"Unknown provider: {provider_name}")
            return
        
        while True:
            print_header(f"{provider_name.capitalize()} Provider Settings")
            
            # Get provider settings
            settings = self._settings_manager.get_provider_settings(provider_type)
            print_json(settings)
            
            print_section("Options")
            print("1. Update API Key")
            print("2. Toggle Provider Enabled")
            print("3. Change Default Model")
            print("0. Back")
            
            choice = input("\nEnter your choice: ")
            
            if choice == '1':
                api_key = input("Enter API Key (leave empty to cancel): ")
                if api_key:
                    self._settings_manager.set_api_key(provider_type, api_key)
                    print("API Key updated.")
            
            elif choice == '2':
                enabled = settings.get("enabled", False)
                new_enabled = not enabled
                self._settings_manager.enable_provider(provider_type, new_enabled)
                print(f"Provider {provider_name} {'enabled' if new_enabled else 'disabled'}.")
            
            elif choice == '3':
                # Get available models
                available_models = settings.get("available_models", [])
                
                print_section("Available Models")
                for i, model in enumerate(available_models, 1):
                    print(f"{i}. {model}")
                
                choice = input("\nSelect model (or enter a custom model name): ")
                
                try:
                    index = int(choice) - 1
                    if 0 <= index < len(available_models):
                        model = available_models[index]
                    else:
                        raise ValueError
                except ValueError:
                    model = choice
                
                self._settings_manager.update_provider_settings(provider_type, {"default_model": model})
                print(f"Default model set to {model}.")
            
            elif choice == '0':
                return
            
            else:
                print("Invalid choice. Please try again.")
    
    def manage_agent_settings(self) -> None:
        """Manage agent settings."""
        while True:
            print_header("Agent Settings")
            
            # Get list of agents
            agents = self._settings_manager.list_available_agents()
            
            # Display agent menu
            for i, agent in enumerate(agents, 1):
                print(f"{i}. {agent.capitalize()}")
            
            print("0. Back")
            
            choice = input("\nSelect agent: ")
            
            if choice == '0':
                return
            
            try:
                index = int(choice) - 1
                if 0 <= index < len(agents):
                    agent = agents[index]
                    self.manage_specific_agent(agent)
                else:
                    print("Invalid choice. Please try again.")
            except ValueError:
                print("Please enter a number.")
    
    def manage_specific_agent(self, agent_name: str) -> None:
        """
        Manage settings for a specific agent.
        
        Args:
            agent_name: The name of the agent.
        """
        while True:
            print_header(f"{agent_name.capitalize()} Agent Settings")
            
            # Get agent settings
            settings = self._settings_manager.get_agent_settings(agent_name)
            print_json(settings)
            
            print_section("Options")
            print("1. Change Provider")
            print("2. Change Model")
            print("3. Update Temperature")
            print("4. Update Max Tokens")
            print("0. Back")
            
            choice = input("\nEnter your choice: ")
            
            if choice == '1':
                # Get available providers
                provider_types = [
                    ProviderType.OPENAI,
                    ProviderType.ANTHROPIC,
                    ProviderType.GOOGLE,
                    ProviderType.OPENROUTER
                ]
                
                print_section("Available Providers")
                for i, provider in enumerate(provider_types, 1):
                    print(f"{i}. {format_provider_type(provider)}")
                
                choice = input("\nSelect provider: ")
                
                try:
                    index = int(choice) - 1
                    if 0 <= index < len(provider_types):
                        provider = provider_types[index]
                        self._settings_manager.set_agent_provider(agent_name, provider)
                        print(f"Provider set to {format_provider_type(provider)}.")
                    else:
                        print("Invalid choice. Please try again.")
                except ValueError:
                    print("Please enter a number.")
            
            elif choice == '2':
                # Get current provider
                provider_type = self._settings_manager.get_agent_provider(agent_name)
                
                if provider_type:
                    # Get available models for the provider
                    models = self._settings_manager.get_available_models(provider_type)
                    
                    print_section(f"Available Models for {format_provider_type(provider_type)}")
                    for i, model in enumerate(models, 1):
                        print(f"{i}. {model}")
                    
                    choice = input("\nSelect model (or enter a custom model name): ")
                    
                    try:
                        index = int(choice) - 1
                        if 0 <= index < len(models):
                            model = models[index]
                        else:
                            raise ValueError
                    except ValueError:
                        model = choice
                    
                    self._settings_manager.set_agent_model(agent_name, model)
                    print(f"Model set to {model}.")
                else:
                    print("Provider not set for this agent.")
            
            elif choice == '3':
                # Update temperature
                current_temp = settings.get("temperature", 0.7)
                print(f"Current temperature: {current_temp}")
                
                try:
                    new_temp = float(input("New temperature (0.0-1.0): "))
                    if 0.0 <= new_temp <= 1.0:
                        self._settings_manager.update_agent_settings(agent_name, {"temperature": new_temp})
                        print(f"Temperature set to {new_temp}.")
                    else:
                        print("Temperature must be between 0.0 and 1.0.")
                except ValueError:
                    print("Please enter a valid number.")
            
            elif choice == '4':
                # Update max tokens
                current_max = settings.get("max_tokens", 1000)
                print(f"Current max tokens: {current_max}")
                
                try:
                    new_max = int(input("New max tokens: "))
                    if new_max > 0:
                        self._settings_manager.update_agent_settings(agent_name, {"max_tokens": new_max})
                        print(f"Max tokens set to {new_max}.")
                    else:
                        print("Max tokens must be a positive number.")
                except ValueError:
                    print("Please enter a valid number.")
            
            elif choice == '0':
                return
            
            else:
                print("Invalid choice. Please try again.")
    
    def run_llm_diagnostics(self) -> None:
        """Run LLM diagnostics."""
        print_header("Running LLM Diagnostics")
        
        from core.llm.llm_manager import get_llm_manager
        
        llm_manager = get_llm_manager()
        diagnostics = llm_manager.run_llm_diagnostics()
        
        print_section("Diagnostic Results")
        print(f"Status: {diagnostics.get('status', 'unknown')}")
        print(f"Message: {diagnostics.get('message', 'No message')}")
        
        print_section("Provider Results")
        for provider, result in diagnostics.get("providers", {}).items():
            print(f"\n{provider}:")
            print(f"  Status: {result.get('status', 'unknown')}")
            
            if result.get("status") == "success":
                print(f"  Model: {result.get('model', 'unknown')}")
                print(f"  Response: {result.get('response_content', '')}")
                print(f"  Tokens: {result.get('tokens', {})}")
                print(f"  Cost: ${result.get('cost', 0):.6f}")
            else:
                print(f"  Error: {result.get('error', 'Unknown error')}")


def main() -> None:
    """Main entry point for the CLI."""
    parser = argparse.ArgumentParser(description="LLM Settings Manager CLI")
    
    parser.add_argument("--set-api-key", action="store_true", help="Set API key for a provider")
    parser.add_argument("--provider", type=str, help="Provider name (openai, anthropic, google, openrouter)")
    parser.add_argument("--key", type=str, help="API key")
    
    parser.add_argument("--enable", action="store_true", help="Enable a provider")
    parser.add_argument("--disable", action="store_true", help="Disable a provider")
    
    parser.add_argument("--list-providers", action="store_true", help="List available providers")
    parser.add_argument("--list-agents", action="store_true", help="List available agents")
    
    parser.add_argument("--show-diagnostics", action="store_true", help="Run LLM diagnostics")
    
    args = parser.parse_args()
    
    settings_manager = get_settings_manager()
    
    # Handle command line arguments
    if args.set_api_key:
        if not args.provider or not args.key:
            print("Error: --provider and --key required with --set-api-key")
            return
        
        provider_map = {
            "openai": ProviderType.OPENAI,
            "anthropic": ProviderType.ANTHROPIC,
            "google": ProviderType.GOOGLE,
            "openrouter": ProviderType.OPENROUTER
        }
        
        if args.provider.lower() not in provider_map:
            print(f"Error: Unknown provider '{args.provider}'. Must be one of: {', '.join(provider_map.keys())}")
            return
        
        provider_type = provider_map[args.provider.lower()]
        success = settings_manager.set_api_key(provider_type, args.key)
        
        if success:
            print(f"API key for {args.provider} updated successfully.")
        else:
            print(f"Failed to update API key for {args.provider}.")
    
    elif args.enable or args.disable:
        if not args.provider:
            print("Error: --provider required with --enable or --disable")
            return
        
        provider_map = {
            "openai": ProviderType.OPENAI,
            "anthropic": ProviderType.ANTHROPIC,
            "google": ProviderType.GOOGLE,
            "openrouter": ProviderType.OPENROUTER
        }
        
        if args.provider.lower() not in provider_map:
            print(f"Error: Unknown provider '{args.provider}'. Must be one of: {', '.join(provider_map.keys())}")
            return
        
        provider_type = provider_map[args.provider.lower()]
        success = settings_manager.enable_provider(provider_type, args.enable)
        
        if success:
            print(f"Provider {args.provider} {'enabled' if args.enable else 'disabled'} successfully.")
        else:
            print(f"Failed to {'enable' if args.enable else 'disable'} provider {args.provider}.")
    
    elif args.list_providers:
        provider_settings = settings_manager.get_provider_settings()
        print_header("Available Providers")
        
        for provider, settings in provider_settings.items():
            enabled = settings.get("enabled", False)
            api_key_set = bool(settings.get("api_key", ""))
            default_model = settings.get("default_model", "unknown")
            
            print(f"{provider.capitalize()}: {'Enabled' if enabled else 'Disabled'}, API Key: {'Set' if api_key_set else 'Not Set'}, Default Model: {default_model}")
    
    elif args.list_agents:
        agents = settings_manager.list_available_agents()
        print_header("Available Agents")
        
        for agent in agents:
            agent_settings = settings_manager.get_agent_settings(agent)
            provider_type_str = agent_settings.get("provider_type", "OPENAI")
            model = agent_settings.get("model", "default")
            
            print(f"{agent.capitalize()}: Provider={provider_type_str}, Model={model}")
    
    elif args.show_diagnostics:
        cli = SettingsCLI()
        cli.run_llm_diagnostics()
    
    else:
        # No arguments, run interactive CLI
        SettingsCLI().show_main_menu()


if __name__ == "__main__":
    main()
```

### File: core\llm\settings_manager.py

```python
#!/usr/bin/env python3
"""
Settings manager for LLM and agent configuration.

This module provides a SettingsManager class that handles viewing and modifying
LLM settings, API keys, and agent configurations.
"""

import os
import json
from typing import Dict, List, Optional, Any, Union
import logging

from core.utils.logging_config import get_logger
from core.base.config import get_config
from core.llm.provider_manager import ProviderType, get_provider_manager

# Get the module logger
logger = get_logger("LLM")

class SettingsManager:
    """
    Manager for LLM and agent settings.
    
    This class provides methods for viewing and modifying settings related
    to LLM providers, API keys, and agent configurations.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(SettingsManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the settings manager."""
        if self._initialized:
            return
        
        logger.info("Initializing SettingsManager")
        
        # Get configuration
        self._config = get_config()
        
        # Get provider manager
        self._provider_manager = get_provider_manager()
        
        # Set paths
        self._llm_config_path = os.path.join("config", "llm", "base_config.json")
        self._providers_path = os.path.join("config", "llm", "providers.json")
        self._agents_dir = os.path.join("config", "llm", "agents")
        
        # Ensure directories exist
        os.makedirs(self._agents_dir, exist_ok=True)
        
        self._initialized = True
        logger.info("SettingsManager initialized")
    
    def get_llm_settings(self) -> Dict[str, Any]:
        """
        Get general LLM settings.
        
        Returns:
            Dictionary of LLM settings.
        """
        try:
            if os.path.exists(self._llm_config_path):
                with open(self._llm_config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                logger.warning(f"LLM config file not found: {self._llm_config_path}")
                return {}
        except Exception as e:
            logger.error(f"Error getting LLM settings: {e}")
            return {}
    
    def update_llm_settings(self, settings: Dict[str, Any]) -> bool:
        """
        Update general LLM settings.
        
        Args:
            settings: Dictionary of settings to update.
        
        Returns:
            True if successful, False otherwise.
        """
        try:
            # Get current settings
            current_settings = self.get_llm_settings()
            
            # Update settings
            current_settings.update(settings)
            
            # Write updated settings
            with open(self._llm_config_path, 'w', encoding='utf-8') as f:
                json.dump(current_settings, f, indent=4)
            
            logger.info("Updated LLM settings")
            return True
        except Exception as e:
            logger.error(f"Error updating LLM settings: {e}")
            return False
    
    def get_provider_settings(self, provider_type: Optional[ProviderType] = None) -> Dict[str, Any]:
        """
        Get provider settings.
        
        Args:
            provider_type: The provider type. If None, get all provider settings.
        
        Returns:
            Dictionary of provider settings.
        """
        try:
            if os.path.exists(self._providers_path):
                with open(self._providers_path, 'r', encoding='utf-8') as f:
                    providers_data = json.load(f)
                
                if provider_type:
                    # Convert ProviderType to provider name
                    provider_map = {
                        ProviderType.OPENAI: "openai",
                        ProviderType.ANTHROPIC: "anthropic",
                        ProviderType.GOOGLE: "google",
                        ProviderType.OPENROUTER: "openrouter"
                    }
                    
                    provider_name = provider_map.get(provider_type)
                    if provider_name and provider_name in providers_data:
                        return providers_data[provider_name]
                    else:
                        logger.warning(f"Provider not found: {provider_type.name if provider_type else None}")
                        return {}
                else:
                    return providers_data
            else:
                logger.warning(f"Providers file not found: {self._providers_path}")
                return {}
        except Exception as e:
            logger.error(f"Error getting provider settings: {e}")
            return {}
    
    def update_provider_settings(self, provider_type: ProviderType, settings: Dict[str, Any]) -> bool:
        """
        Update settings for a provider.
        
        Args:
            provider_type: The type of provider.
            settings: The new settings.
        
        Returns:
            True if successful, False otherwise.
        """
        # Get provider name
        provider_map = {
            ProviderType.OPENAI: "openai",
            ProviderType.ANTHROPIC: "anthropic",
            ProviderType.GOOGLE: "google",
            ProviderType.OPENROUTER: "openrouter"
        }
        
        provider_name = provider_map.get(provider_type)
        if not provider_name:
            logger.error(f"Invalid provider type: {provider_type}")
            return False
        
        try:
            # Get all provider settings
            all_providers = self.get_provider_settings()
            
            # Update provider settings
            if provider_name in all_providers:
                all_providers[provider_name].update(settings)
            else:
                all_providers[provider_name] = settings
            
            # Write updated settings
            with open(self._providers_path, 'w', encoding='utf-8') as f:
                json.dump(all_providers, f, indent=4)
            
            # Update provider in provider manager
            self._provider_manager.update_provider_settings(provider_type, settings)
            
            logger.info(f"Updated settings for provider: {provider_name}")
            return True
        except Exception as e:
            logger.error(f"Error updating provider settings: {e}")
            return False
    
    def set_api_key(self, provider_type: ProviderType, api_key: str) -> bool:
        """
        Set the API key for a provider.
        
        Args:
            provider_type: The type of provider.
            api_key: The API key.
        
        Returns:
            True if successful, False otherwise.
        """
        # Update provider settings with the new API key
        return self.update_provider_settings(provider_type, {"api_key": api_key})
    
    def get_agent_settings(self, agent_name: Optional[str] = None) -> Dict[str, Any]:
        """
        Get agent settings.
        
        Args:
            agent_name: The name of the agent. If None, get all agent settings.
        
        Returns:
            Dictionary of agent settings.
        """
        if agent_name:
            # Get settings for a specific agent
            agent_path = os.path.join(self._agents_dir, f"{agent_name.lower()}.json")
            
            try:
                if os.path.exists(agent_path):
                    with open(agent_path, 'r', encoding='utf-8') as f:
                        return json.load(f)
                else:
                    logger.warning(f"Agent settings file not found: {agent_path}")
                    return {}
            except Exception as e:
                logger.error(f"Error getting agent settings: {e}")
                return {}
        else:
            # Get settings for all agents
            agent_settings = {}
            
            try:
                for filename in os.listdir(self._agents_dir):
                    if filename.endswith(".json"):
                        agent_name = os.path.splitext(filename)[0]
                        agent_path = os.path.join(self._agents_dir, filename)
                        
                        with open(agent_path, 'r', encoding='utf-8') as f:
                            agent_settings[agent_name] = json.load(f)
            except Exception as e:
                logger.error(f"Error getting all agent settings: {e}")
            
            return agent_settings
    
    def update_agent_settings(self, agent_name: str, settings: Dict[str, Any]) -> bool:
        """
        Update settings for an agent.
        
        Args:
            agent_name: The name of the agent.
            settings: The new settings.
        
        Returns:
            True if successful, False otherwise.
        """
        agent_path = os.path.join(self._agents_dir, f"{agent_name.lower()}.json")
        
        try:
            # Get current settings
            current_settings = {}
            if os.path.exists(agent_path):
                with open(agent_path, 'r', encoding='utf-8') as f:
                    current_settings = json.load(f)
            
            # Update settings
            current_settings.update(settings)
            
            # Write updated settings
            with open(agent_path, 'w', encoding='utf-8') as f:
                json.dump(current_settings, f, indent=4)
            
            logger.info(f"Updated settings for agent: {agent_name}")
            return True
        except Exception as e:
            logger.error(f"Error updating agent settings: {e}")
            return False
    
    def list_available_agents(self) -> List[str]:
        """
        List all available agents.
        
        Returns:
            List of agent names.
        """
        agents = []
        
        try:
            for filename in os.listdir(self._agents_dir):
                if filename.endswith(".json"):
                    agent_name = os.path.splitext(filename)[0]
                    agents.append(agent_name)
        except Exception as e:
            logger.error(f"Error listing agents: {e}")
        
        return agents
    
    def get_agent_provider(self, agent_name: str) -> Optional[ProviderType]:
        """
        Get the provider type for an agent.
        
        Args:
            agent_name: The name of the agent.
        
        Returns:
            The provider type, or None if not found.
        """
        agent_settings = self.get_agent_settings(agent_name)
        
        if not agent_settings:
            return None
        
        provider_type_str = agent_settings.get("provider_type")
        
        if not provider_type_str:
            return None
        
        try:
            return ProviderType[provider_type_str]
        except (KeyError, ValueError):
            logger.warning(f"Invalid provider type in agent settings: {provider_type_str}")
            return None
    
    def set_agent_provider(self, agent_name: str, provider_type: ProviderType) -> bool:
        """
        Set the provider type for an agent.
        
        Args:
            agent_name: The name of the agent.
            provider_type: The provider type.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_agent_settings(agent_name, {"provider_type": provider_type.name})
    
    def set_agent_model(self, agent_name: str, model: str) -> bool:
        """
        Set the model for an agent.
        
        Args:
            agent_name: The name of the agent.
            model: The model name.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_agent_settings(agent_name, {"model": model})
    
    def get_available_models(self, provider_type: ProviderType) -> List[str]:
        """
        Get available models for a provider.
        
        Args:
            provider_type: The provider type.
        
        Returns:
            List of model names.
        """
        provider_settings = self.get_provider_settings(provider_type)
        return provider_settings.get("available_models", [])
    
    def is_provider_enabled(self, provider_type: ProviderType) -> bool:
        """
        Check if a provider is enabled.
        
        Args:
            provider_type: The provider type.
        
        Returns:
            True if enabled, False otherwise.
        """
        provider_settings = self.get_provider_settings(provider_type)
        return provider_settings.get("enabled", False)
    
    def enable_provider(self, provider_type: ProviderType, enabled: bool) -> bool:
        """
        Enable or disable a provider.
        
        Args:
            provider_type: The provider type.
            enabled: Whether to enable the provider.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_provider_settings(provider_type, {"enabled": enabled})


# Convenience function
def get_settings_manager() -> SettingsManager:
    """Get the settings manager instance."""
    return SettingsManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the settings manager
    manager = get_settings_manager()
    
    # Print LLM settings
    llm_settings = manager.get_llm_settings()
    print(f"LLM settings: {llm_settings}")
    
    # Print provider settings
    provider_settings = manager.get_provider_settings()
    print(f"Provider settings: {provider_settings}")
    
    # Print agent settings
    agent_settings = manager.get_agent_settings()
    print(f"Agent settings: {agent_settings}")
```

### File: core\llm\settings_manager_new.py

```python
#!/usr/bin/env python3
"""
Settings manager for LLM and agent configuration.

This module provides a SettingsManager class that handles viewing and modifying
LLM settings, API keys, and agent configurations.
"""

import os
import json
from typing import Dict, List, Optional, Any, Union
import logging

from core.utils.logging_config import get_logger
from core.base.config import get_config
from core.llm.provider_manager import ProviderType, get_provider_manager

# Get the module logger
logger = get_logger("LLM")

class SettingsManager:
    """
    Manager for LLM and agent settings.
    
    This class provides methods for viewing and modifying settings related
    to LLM providers, API keys, and agent configurations.
    """
    
    # Singleton instance
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """Ensure singleton pattern."""
        if cls._instance is None:
            cls._instance = super(SettingsManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the settings manager."""
        if self._initialized:
            return
        
        logger.info("Initializing SettingsManager")
        
        # Get configuration
        self._config = get_config()
        
        # Get provider manager
        self._provider_manager = get_provider_manager()
        
        # Set paths
        self._llm_config_path = os.path.join("config", "llm", "base_config.json")
        self._providers_path = os.path.join("config", "llm", "providers.json")
        self._agents_dir = os.path.join("config", "llm", "agents")
        
        # Ensure directories exist
        os.makedirs(self._agents_dir, exist_ok=True)
        
        self._initialized = True
        logger.info("SettingsManager initialized")
    
    def get_llm_settings(self) -> Dict[str, Any]:
        """
        Get general LLM settings.
        
        Returns:
            Dictionary of LLM settings.
        """
        try:
            if os.path.exists(self._llm_config_path):
                with open(self._llm_config_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                logger.warning(f"LLM config file not found: {self._llm_config_path}")
                return {}
        except Exception as e:
            logger.error(f"Error getting LLM settings: {e}")
            return {}
    
    def update_llm_settings(self, settings: Dict[str, Any]) -> bool:
        """
        Update general LLM settings.
        
        Args:
            settings: Dictionary of settings to update.
        
        Returns:
            True if successful, False otherwise.
        """
        try:
            # Get current settings
            current_settings = self.get_llm_settings()
            
            # Update settings
            current_settings.update(settings)
            
            # Write updated settings
            with open(self._llm_config_path, 'w', encoding='utf-8') as f:
                json.dump(current_settings, f, indent=4)
            
            logger.info("Updated LLM settings")
            return True
        except Exception as e:
            logger.error(f"Error updating LLM settings: {e}")
            return False
    
    def get_provider_settings(self, provider_type: Optional[ProviderType] = None) -> Dict[str, Any]:
        """
        Get provider settings.
        
        Args:
            provider_type: The provider type. If None, get all provider settings.
        
        Returns:
            Dictionary of provider settings.
        """
        try:
            if os.path.exists(self._providers_path):
                with open(self._providers_path, 'r', encoding='utf-8') as f:
                    providers_data = json.load(f)
                
                if provider_type:
                    # Convert ProviderType to provider name
                    provider_map = {
                        ProviderType.OPENAI: "openai",
                        ProviderType.ANTHROPIC: "anthropic",
                        ProviderType.GOOGLE: "google",
                        ProviderType.OPENROUTER: "openrouter"
                    }
                    
                    provider_name = provider_map.get(provider_type)
                    if provider_name and provider_name in providers_data:
                        return providers_data[provider_name]
                    else:
                        logger.warning(f"Provider not found: {provider_type.name if provider_type else None}")
                        return {}
                else:
                    return providers_data
            else:
                logger.warning(f"Providers file not found: {self._providers_path}")
                return {}
        except Exception as e:
            logger.error(f"Error getting provider settings: {e}")
            return {}
    
    def update_provider_settings(self, provider_type: ProviderType, settings: Dict[str, Any]) -> bool:
        """
        Update settings for a provider.
        
        Args:
            provider_type: The type of provider.
            settings: The new settings.
        
        Returns:
            True if successful, False otherwise.
        """
        # Get provider name
        provider_map = {
            ProviderType.OPENAI: "openai",
            ProviderType.ANTHROPIC: "anthropic",
            ProviderType.GOOGLE: "google",
            ProviderType.OPENROUTER: "openrouter"
        }
        
        provider_name = provider_map.get(provider_type)
        if not provider_name:
            logger.error(f"Invalid provider type: {provider_type}")
            return False
        
        try:
            # Get all provider settings
            all_providers = self.get_provider_settings()
            
            # Update provider settings
            if provider_name in all_providers:
                all_providers[provider_name].update(settings)
            else:
                all_providers[provider_name] = settings
            
            # Write updated settings
            with open(self._providers_path, 'w', encoding='utf-8') as f:
                json.dump(all_providers, f, indent=4)
            
            # Update provider in provider manager
            self._provider_manager.update_provider_settings(provider_type, settings)
            
            logger.info(f"Updated settings for provider: {provider_name}")
            return True
        except Exception as e:
            logger.error(f"Error updating provider settings: {e}")
            return False
    
    def set_api_key(self, provider_type: ProviderType, api_key: str) -> bool:
        """
        Set the API key for a provider.
        
        Args:
            provider_type: The type of provider.
            api_key: The API key.
        
        Returns:
            True if successful, False otherwise.
        """
        # Update provider settings with the new API key
        return self.update_provider_settings(provider_type, {"api_key": api_key})
    
    def get_agent_settings(self, agent_name: Optional[str] = None) -> Dict[str, Any]:
        """
        Get agent settings.
        
        Args:
            agent_name: The name of the agent. If None, get all agent settings.
        
        Returns:
            Dictionary of agent settings.
        """
        if agent_name:
            # Get settings for a specific agent
            agent_path = os.path.join(self._agents_dir, f"{agent_name.lower()}.json")
            
            try:
                if os.path.exists(agent_path):
                    with open(agent_path, 'r', encoding='utf-8') as f:
                        return json.load(f)
                else:
                    logger.warning(f"Agent settings file not found: {agent_path}")
                    return {}
            except Exception as e:
                logger.error(f"Error getting agent settings: {e}")
                return {}
        else:
            # Get settings for all agents
            agent_settings = {}
            
            try:
                for filename in os.listdir(self._agents_dir):
                    if filename.endswith(".json"):
                        agent_name = os.path.splitext(filename)[0]
                        agent_path = os.path.join(self._agents_dir, filename)
                        
                        with open(agent_path, 'r', encoding='utf-8') as f:
                            agent_settings[agent_name] = json.load(f)
            except Exception as e:
                logger.error(f"Error getting all agent settings: {e}")
            
            return agent_settings
    
    def update_agent_settings(self, agent_name: str, settings: Dict[str, Any]) -> bool:
        """
        Update settings for an agent.
        
        Args:
            agent_name: The name of the agent.
            settings: The new settings.
        
        Returns:
            True if successful, False otherwise.
        """
        agent_path = os.path.join(self._agents_dir, f"{agent_name.lower()}.json")
        
        try:
            # Get current settings
            current_settings = {}
            if os.path.exists(agent_path):
                with open(agent_path, 'r', encoding='utf-8') as f:
                    current_settings = json.load(f)
            
            # Update settings
            current_settings.update(settings)
            
            # Write updated settings
            with open(agent_path, 'w', encoding='utf-8') as f:
                json.dump(current_settings, f, indent=4)
            
            logger.info(f"Updated settings for agent: {agent_name}")
            return True
        except Exception as e:
            logger.error(f"Error updating agent settings: {e}")
            return False
    
    def list_available_agents(self) -> List[str]:
        """
        List all available agents.
        
        Returns:
            List of agent names.
        """
        agents = []
        
        try:
            for filename in os.listdir(self._agents_dir):
                if filename.endswith(".json"):
                    agent_name = os.path.splitext(filename)[0]
                    agents.append(agent_name)
        except Exception as e:
            logger.error(f"Error listing agents: {e}")
        
        return agents
    
    def get_agent_provider(self, agent_name: str) -> Optional[ProviderType]:
        """
        Get the provider type for an agent.
        
        Args:
            agent_name: The name of the agent.
        
        Returns:
            The provider type, or None if not found.
        """
        agent_settings = self.get_agent_settings(agent_name)
        
        if not agent_settings:
            return None
        
        provider_type_str = agent_settings.get("provider_type")
        
        if not provider_type_str:
            return None
        
        try:
            return ProviderType[provider_type_str]
        except (KeyError, ValueError):
            logger.warning(f"Invalid provider type in agent settings: {provider_type_str}")
            return None
    
    def set_agent_provider(self, agent_name: str, provider_type: ProviderType) -> bool:
        """
        Set the provider type for an agent.
        
        Args:
            agent_name: The name of the agent.
            provider_type: The provider type.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_agent_settings(agent_name, {"provider_type": provider_type.name})
    
    def set_agent_model(self, agent_name: str, model: str) -> bool:
        """
        Set the model for an agent.
        
        Args:
            agent_name: The name of the agent.
            model: The model name.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_agent_settings(agent_name, {"model": model})
    
    def get_available_models(self, provider_type: ProviderType) -> List[str]:
        """
        Get available models for a provider.
        
        Args:
            provider_type: The provider type.
        
        Returns:
            List of model names.
        """
        provider_settings = self.get_provider_settings(provider_type)
        return provider_settings.get("available_models", [])
    
    def is_provider_enabled(self, provider_type: ProviderType) -> bool:
        """
        Check if a provider is enabled.
        
        Args:
            provider_type: The provider type.
        
        Returns:
            True if enabled, False otherwise.
        """
        provider_settings = self.get_provider_settings(provider_type)
        return provider_settings.get("enabled", False)
    
    def enable_provider(self, provider_type: ProviderType, enabled: bool) -> bool:
        """
        Enable or disable a provider.
        
        Args:
            provider_type: The provider type.
            enabled: Whether to enable the provider.
        
        Returns:
            True if successful, False otherwise.
        """
        return self.update_provider_settings(provider_type, {"enabled": enabled})
        
    def get_agent_provider_model_map(self) -> Dict[str, Dict[str, Any]]:
        """
        Get a mapping of agents to their provider types and models.
        
        Returns:
            Dictionary mapping agent names to their provider and model settings.
        """
        try:
            # Get settings for all agents
            agent_settings = self.get_agent_settings()
            
            # Create a mapping of agent name to provider type and model
            agent_provider_map = {}
            
            for agent_name, settings in agent_settings.items():
                provider_type_str = settings.get("provider_type")
                model = settings.get("model")
                temperature = settings.get("temperature", 0.7)
                max_tokens = settings.get("max_tokens", 1000)
                
                if provider_type_str:
                    try:
                        provider_type = ProviderType[provider_type_str]
                        agent_provider_map[agent_name] = {
                            "provider_type": provider_type,
                            "model": model,
                            "temperature": temperature,
                            "max_tokens": max_tokens
                        }
                    except (KeyError, ValueError):
                        logger.warning(f"Invalid provider type for agent {agent_name}: {provider_type_str}")
            
            return agent_provider_map
            
        except Exception as e:
            logger.error(f"Error getting agent provider model map: {e}")
            return {}


# Convenience function
def get_settings_manager() -> SettingsManager:
    """Get the settings manager instance."""
    return SettingsManager()


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create the settings manager
    manager = get_settings_manager()
    
    # Print LLM settings
    llm_settings = manager.get_llm_settings()
    print(f"LLM settings: {llm_settings}")
    
    # Print provider settings
    provider_settings = manager.get_provider_settings()
    print(f"Provider settings: {provider_settings}")
    
    # Print agent settings
    agent_settings = manager.get_agent_settings()
    print(f"Agent settings: {agent_settings}")

```

### File: core\base\init_modules.py

```python
"""
Module initialization for the RPG game.

This module imports all necessary modules to ensure they are initialized properly.
"""

import logging
from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

def init_modules():
    """Initialize all necessary modules."""
    logger.info("Initializing game modules...")
    
    # Import core modules
    try:
        # Import inventory
        import core.inventory
        logger.info("Inventory module initialized")
        
        # Import combat system
        import core.combat
        logger.info("Combat module initialized")
        
        # Add other modules as needed
        
        logger.info("All modules initialized successfully")
        return True
    except Exception as e:
        logger.error(f"Error initializing modules: {e}", exc_info=True)
        return False

```

### File: core\base\state.py

```python
"""
State management for the RPG game.

This module provides classes for managing the overall game state,
including player state, world state, and game session information.

Note: This module is now a wrapper around the more granular modules in core.base.state package.
"""

# Re-export from the new modules
from core.base.state.player_state import PlayerState
from core.base.state.world_state import WorldState
from core.base.state.game_state import GameState
from core.base.state.state_manager import StateManager, get_state_manager

__all__ = [
    'PlayerState',
    'WorldState',
    'GameState',
    'StateManager',
    'get_state_manager',
]

```

### File: core\utils\save_manager.py

```python
#!/usr/bin/env python3
"""
Save file management utilities for the RPG game.

This module provides classes and functions for managing saved game files,
including listing, backup creation, validation, and metadata operations.
It works alongside StateManager but focuses on file operations rather than
actual game state serialization.
"""

import os
import json
import shutil
import glob
import uuid
import time
import datetime
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Any, Union
from pathlib import Path

from core.utils.logging_config import get_logger
from core.utils.json_utils import enhanced_json_loads, enhanced_json_dumps, EnhancedJSONEncoder

logger = get_logger(__name__)

@dataclass
class SaveMetadata:
    """Metadata for a saved game file."""
    save_id: str  # UUID string
    save_name: str  # User-friendly name
    save_time: float  # Unix timestamp
    version: str  # Game version
    player_name: str  # Name of player character
    player_level: int  # Level of player character
    world_time: str  # In-game time when saved
    location: str  # Current location
    playtime: float  # Time played in seconds
    screenshot: Optional[str] = None  # Path to screenshot image (relative to save)
    custom_notes: str = ""  # User notes about this save
    tags: List[str] = field(default_factory=list)  # User-defined tags
    auto_save: bool = False  # Whether this was an auto-save
    backup_of: Optional[str] = None  # ID of save this is a backup of (if any)
    
    @property
    def formatted_save_time(self) -> str:
        """Return the save time as a formatted string."""
        dt = datetime.datetime.fromtimestamp(self.save_time)
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    
    @property
    def formatted_playtime(self) -> str:
        """Return the playtime as a formatted string (HH:MM:SS)."""
        hours, remainder = divmod(int(self.playtime), 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to a dictionary for serialization."""
        return {
            "save_id": self.save_id,
            "save_name": self.save_name,
            "save_time": self.save_time,
            "version": self.version,
            "player_name": self.player_name,
            "player_level": self.player_level,
            "world_time": self.world_time,
            "location": self.location,
            "playtime": self.playtime,
            "screenshot": self.screenshot,
            "custom_notes": self.custom_notes,
            "tags": self.tags,
            "auto_save": self.auto_save,
            "backup_of": self.backup_of
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SaveMetadata':
        """Create a SaveMetadata instance from a dictionary."""
        # Handle potential missing fields with defaults
        return cls(
            save_id=data.get("save_id", str(uuid.uuid4())),
            save_name=data.get("save_name", "Unknown Save"),
            save_time=data.get("save_time", time.time()),
            version=data.get("version", "0.0.0"),
            player_name=data.get("player_name", "Unknown"),
            player_level=data.get("player_level", 1),
            world_time=data.get("world_time", "00:00"),
            location=data.get("location", "Unknown"),
            playtime=data.get("playtime", 0.0),
            screenshot=data.get("screenshot"),
            custom_notes=data.get("custom_notes", ""),
            tags=data.get("tags", []),
            auto_save=data.get("auto_save", False),
            backup_of=data.get("backup_of")
        )


class SaveFileError(Exception):
    """Base exception for save file operations."""
    pass


class SaveFileNotFoundError(SaveFileError):
    """Exception raised when a save file doesn't exist."""
    pass


class SaveFileCorruptedError(SaveFileError):
    """Exception raised when a save file is corrupted or invalid."""
    pass


class SaveManager:
    """
    Manages saved game files, providing operations for listing, backup creation,
    validation, metadata management, and file operations.
    
    This class works alongside StateManager but focuses on file operations
    rather than actual game state serialization.
    """
    
    DEFAULT_SAVE_DIR = "saves"
    BACKUP_DIR = "backups"
    METADATA_FILENAME = "metadata.json"
    STATE_FILENAME = "state.json"
    MAX_AUTO_BACKUPS = 5
    
    def __init__(self, save_dir: Optional[str] = None):
        """
        Initialize the SaveManager.
        
        Args:
            save_dir: Directory where save files are stored. If None, uses the default.
        """
        if save_dir is None:
            save_dir = self.DEFAULT_SAVE_DIR
        
        self.save_dir = save_dir
        self.backup_dir = os.path.join(save_dir, self.BACKUP_DIR)
        
        # Ensure save directories exist
        os.makedirs(self.save_dir, exist_ok=True)
        os.makedirs(self.backup_dir, exist_ok=True)
        
        logger.info(f"SaveManager initialized with save directory: {self.save_dir}")
    
    def get_save_list(self, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Get a list of available save files with their metadata.
        
        Args:
            include_backups: Whether to include backup saves in the list.
            
        Returns:
            List of SaveMetadata objects.
        """
        saves = []
        
        # Get all save directories
        search_path = os.path.join(self.save_dir, "*", self.METADATA_FILENAME)
        metadata_files = glob.glob(search_path)
        
        # Get all backup directories if requested
        if include_backups:
            backup_search_path = os.path.join(self.backup_dir, "*", self.METADATA_FILENAME)
            metadata_files.extend(glob.glob(backup_search_path))
        
        # Load metadata from each file
        for metadata_file in metadata_files:
            try:
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata_dict = json.loads(f.read())
                    metadata = SaveMetadata.from_dict(metadata_dict)
                    saves.append(metadata)
            except Exception as e:
                logger.warning(f"Failed to load metadata from {metadata_file}: {e}")
        
        # Sort by save time, most recent first
        saves.sort(key=lambda x: x.save_time, reverse=True)
        
        return saves
    
    def get_save_path(self, save_id: str, is_backup: bool = False) -> str:
        """
        Get the directory path for a specific save.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Path to the save directory.
        """
        base_dir = self.backup_dir if is_backup else self.save_dir
        return os.path.join(base_dir, save_id)
    
    def get_metadata(self, save_id: str, is_backup: bool = False) -> SaveMetadata:
        """
        Get metadata for a specific save.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            SaveMetadata object.
            
        Raises:
            SaveFileNotFoundError: If the save file doesn't exist.
            SaveFileCorruptedError: If the metadata is corrupted.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
        
        if not os.path.exists(metadata_path):
            raise SaveFileNotFoundError(f"Save metadata not found for {save_id}")
        
        try:
            with open(metadata_path, 'r', encoding='utf-8') as f:
                metadata_dict = json.loads(f.read())
                return SaveMetadata.from_dict(metadata_dict)
        except Exception as e:
            raise SaveFileCorruptedError(f"Failed to load metadata: {e}")
    
    def update_metadata(self, save_id: str, updates: Dict[str, Any], 
                        is_backup: bool = False) -> SaveMetadata:
        """
        Update metadata for a specific save.
        
        Args:
            save_id: The UUID of the save.
            updates: Dictionary of updates to apply.
            is_backup: Whether this is a backup save.
            
        Returns:
            Updated SaveMetadata object.
            
        Raises:
            SaveFileNotFoundError: If the save file doesn't exist.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
        except SaveFileNotFoundError:
            raise
        except SaveFileCorruptedError:
            # Create new metadata if corrupted
            metadata = SaveMetadata(
                save_id=save_id,
                save_name="Recovered Save",
                save_time=time.time(),
                version="0.0.0",
                player_name="Unknown",
                player_level=1,
                world_time="00:00",
                location="Unknown",
                playtime=0.0
            )
        
        # Apply updates
        for key, value in updates.items():
            if hasattr(metadata, key):
                setattr(metadata, key, value)
            else:
                logger.warning(f"Unknown metadata field: {key}")
        
        # Save updated metadata
        save_dir = self.get_save_path(save_id, is_backup)
        metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
        
        os.makedirs(save_dir, exist_ok=True)
        
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
        
        return metadata
    
    def create_backup(self, save_id: str) -> str:
        """
        Create a backup of a save file.
        
        Args:
            save_id: The UUID of the save to back up.
            
        Returns:
            The UUID of the backup save.
            
        Raises:
            SaveFileNotFoundError: If the save file doesn't exist.
        """
        source_dir = self.get_save_path(save_id)
        
        if not os.path.exists(source_dir):
            raise SaveFileNotFoundError(f"Save not found: {save_id}")
        
        # Create a new ID for the backup
        backup_id = str(uuid.uuid4())
        backup_dir = self.get_save_path(backup_id, is_backup=True)
        
        # Copy all files
        shutil.copytree(source_dir, backup_dir)
        
        # Update metadata to mark as backup
        try:
            metadata = self.get_metadata(backup_id, is_backup=True)
            metadata.backup_of = save_id
            metadata.save_time = time.time()  # Update backup time
            
            metadata_path = os.path.join(backup_dir, self.METADATA_FILENAME)
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                
            logger.info(f"Created backup {backup_id} of save {save_id}")
            return backup_id
            
        except Exception as e:
            # If metadata update fails, remove the backup
            shutil.rmtree(backup_dir, ignore_errors=True)
            logger.error(f"Failed to create backup: {e}")
            raise
    
    def auto_backup(self, save_id: str) -> Optional[str]:
        """
        Create an automatic backup of a save file, managing rotation.
        
        Args:
            save_id: The UUID of the save to back up.
            
        Returns:
            The UUID of the backup save, or None if backup wasn't needed.
        """
        try:
            # Get existing backups for this save
            existing_backups = [
                meta for meta in self.get_save_list(include_backups=True)
                if meta.backup_of == save_id and meta.auto_save
            ]
            
            # If we already have max backups, remove the oldest
            if len(existing_backups) >= self.MAX_AUTO_BACKUPS:
                existing_backups.sort(key=lambda x: x.save_time)
                oldest_backup = existing_backups[0]
                self.delete_save(oldest_backup.save_id, is_backup=True)
            
            # Create new backup
            backup_id = self.create_backup(save_id)
            
            # Mark as auto backup
            self.update_metadata(backup_id, {"auto_save": True}, is_backup=True)
            
            return backup_id
            
        except Exception as e:
            logger.error(f"Failed to create auto backup: {e}")
            return None
    
    def delete_save(self, save_id: str, is_backup: bool = False) -> bool:
        """
        Delete a save file.
        
        Args:
            save_id: The UUID of the save to delete.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        
        if not os.path.exists(save_dir):
            logger.warning(f"Cannot delete non-existent save: {save_id}")
            return False
        
        try:
            shutil.rmtree(save_dir)
            logger.info(f"Deleted save: {save_id}")
            return True
        except Exception as e:
            logger.error(f"Failed to delete save {save_id}: {e}")
            return False
    
    def rename_save(self, save_id: str, new_name: str, is_backup: bool = False) -> bool:
        """
        Rename a save file.
        
        Args:
            save_id: The UUID of the save to rename.
            new_name: The new name for the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            metadata.save_name = new_name
            
            save_dir = self.get_save_path(save_id, is_backup)
            metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
            
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
            
            logger.info(f"Renamed save {save_id} to '{new_name}'")
            return True
            
        except Exception as e:
            logger.error(f"Failed to rename save {save_id}: {e}")
            return False
    
    def validate_save(self, save_id: str, is_backup: bool = False) -> Tuple[bool, Optional[str]]:
        """
        Validate a save file for integrity.
        
        Args:
            save_id: The UUID of the save to validate.
            is_backup: Whether this is a backup save.
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        save_dir = self.get_save_path(save_id, is_backup)
        
        # Check if directory exists
        if not os.path.exists(save_dir):
            return False, "Save directory does not exist"
        
        # Check metadata file
        metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
        if not os.path.exists(metadata_path):
            return False, "Metadata file missing"
        
        # Try to load metadata
        try:
            with open(metadata_path, 'r', encoding='utf-8') as f:
                metadata_dict = json.loads(f.read())
                # Basic validation that required fields exist
                for field in ["save_id", "save_name", "save_time", "version"]:
                    if field not in metadata_dict:
                        return False, f"Metadata missing required field: {field}"
        except json.JSONDecodeError:
            return False, "Metadata file is not valid JSON"
        except Exception as e:
            return False, f"Failed to read metadata: {e}"
        
        # Check state file
        state_path = os.path.join(save_dir, self.STATE_FILENAME)
        if not os.path.exists(state_path):
            return False, "State file missing"
        
        # Try to load state (just check if it's valid JSON)
        try:
            with open(state_path, 'r', encoding='utf-8') as f:
                json.loads(f.read())
        except json.JSONDecodeError:
            return False, "State file is not valid JSON"
        except Exception as e:
            return False, f"Failed to read state file: {e}"
        
        return True, None
    
    def restore_backup(self, backup_id: str, replace_original: bool = True) -> Optional[str]:
        """
        Restore a backup to its original save location.
        
        Args:
            backup_id: The UUID of the backup to restore.
            replace_original: Whether to replace the original save.
            
        Returns:
            The UUID of the restored save, or None if restoration failed.
        """
        try:
            backup_metadata = self.get_metadata(backup_id, is_backup=True)
            
            if not backup_metadata.backup_of:
                logger.warning(f"Backup {backup_id} does not reference an original save")
                return None
            
            original_id = backup_metadata.backup_of
            backup_dir = self.get_save_path(backup_id, is_backup=True)
            original_dir = self.get_save_path(original_id)
            
            # Check if original exists and backup if needed
            if os.path.exists(original_dir):
                if replace_original:
                    # Create a temporary backup of the current state before overwriting
                    temp_backup_id = self.create_backup(original_id)
                    self.update_metadata(temp_backup_id, {
                        "save_name": f"Pre-restore backup of {backup_metadata.save_name}",
                        "custom_notes": "Automatic backup created before restoring from another backup"
                    }, is_backup=True)
                    
                    # Delete original to prepare for copy
                    shutil.rmtree(original_dir)
                else:
                    # Create a new ID for the restored save
                    new_id = str(uuid.uuid4())
                    original_dir = self.get_save_path(new_id)
                    original_id = new_id
            
            # Copy backup to original/new location
            shutil.copytree(backup_dir, original_dir)
            
            # Update metadata if this is a new save ID
            if original_id != backup_metadata.backup_of:
                try:
                    metadata = self.get_metadata(original_id)
                    metadata.save_id = original_id
                    metadata.backup_of = None
                    metadata.save_name += " (Restored)"
                    metadata.save_time = time.time()
                    
                    metadata_path = os.path.join(original_dir, self.METADATA_FILENAME)
                    with open(metadata_path, 'w', encoding='utf-8') as f:
                        json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                        
                except Exception as e:
                    logger.error(f"Failed to update restored save metadata: {e}")
            
            logger.info(f"Restored backup {backup_id} to save {original_id}")
            return original_id
            
        except Exception as e:
            logger.error(f"Failed to restore backup {backup_id}: {e}")
            return None
    
    def get_save_content(self, save_id: str, is_backup: bool = False) -> Optional[Dict[str, Any]]:
        """
        Get the content of a save file (the actual game state).
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Dictionary containing the game state, or None if loading failed.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        state_path = os.path.join(save_dir, self.STATE_FILENAME)
        
        if not os.path.exists(state_path):
            logger.warning(f"State file not found for save {save_id}")
            return None
        
        try:
            with open(state_path, 'r', encoding='utf-8') as f:
                return enhanced_json_loads(f.read())
        except Exception as e:
            logger.error(f"Failed to load state for save {save_id}: {e}")
            return None
    
    def create_save_directory(self, save_id: str, is_backup: bool = False) -> str:
        """
        Create a new save directory structure.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Path to the save directory.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        os.makedirs(save_dir, exist_ok=True)
        return save_dir
    
    def save_screenshot(self, save_id: str, screenshot_data: bytes, 
                        is_backup: bool = False) -> Optional[str]:
        """
        Save a screenshot for a save file.
        
        Args:
            save_id: The UUID of the save.
            screenshot_data: The raw image data.
            is_backup: Whether this is a backup save.
            
        Returns:
            Relative path to the screenshot, or None if saving failed.
        """
        save_dir = self.get_save_path(save_id, is_backup)
        screenshots_dir = os.path.join(save_dir, "screenshots")
        os.makedirs(screenshots_dir, exist_ok=True)
        
        # Create a filename with timestamp
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"screenshot_{timestamp}.png"
        filepath = os.path.join(screenshots_dir, filename)
        
        try:
            with open(filepath, 'wb') as f:
                f.write(screenshot_data)
            
            # Return path relative to save directory
            rel_path = os.path.join("screenshots", filename)
            
            # Update metadata with screenshot path
            try:
                self.update_metadata(save_id, {"screenshot": rel_path}, is_backup)
            except Exception as e:
                logger.warning(f"Failed to update metadata with screenshot: {e}")
            
            return rel_path
            
        except Exception as e:
            logger.error(f"Failed to save screenshot: {e}")
            return None
    
    def get_screenshot_path(self, save_id: str, is_backup: bool = False) -> Optional[str]:
        """
        Get the path to the latest screenshot for a save file.
        
        Args:
            save_id: The UUID of the save.
            is_backup: Whether this is a backup save.
            
        Returns:
            Full path to the screenshot, or None if not found.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            if not metadata.screenshot:
                return None
            
            save_dir = self.get_save_path(save_id, is_backup)
            return os.path.join(save_dir, metadata.screenshot)
            
        except Exception as e:
            logger.warning(f"Failed to get screenshot path: {e}")
            return None
    
    def add_save_tag(self, save_id: str, tag: str, is_backup: bool = False) -> bool:
        """
        Add a tag to a save file.
        
        Args:
            save_id: The UUID of the save.
            tag: The tag to add.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            if tag not in metadata.tags:
                metadata.tags.append(tag)
                
                save_dir = self.get_save_path(save_id, is_backup)
                metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
                
                with open(metadata_path, 'w', encoding='utf-8') as f:
                    json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                
                return True
            return True  # Tag already exists, consider this success
            
        except Exception as e:
            logger.error(f"Failed to add tag to save {save_id}: {e}")
            return False
    
    def remove_save_tag(self, save_id: str, tag: str, is_backup: bool = False) -> bool:
        """
        Remove a tag from a save file.
        
        Args:
            save_id: The UUID of the save.
            tag: The tag to remove.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        try:
            metadata = self.get_metadata(save_id, is_backup)
            if tag in metadata.tags:
                metadata.tags.remove(tag)
                
                save_dir = self.get_save_path(save_id, is_backup)
                metadata_path = os.path.join(save_dir, self.METADATA_FILENAME)
                
                with open(metadata_path, 'w', encoding='utf-8') as f:
                    json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
                
                return True
            return True  # Tag doesn't exist, consider this success
            
        except Exception as e:
            logger.error(f"Failed to remove tag from save {save_id}: {e}")
            return False
    
    def update_save_notes(self, save_id: str, notes: str, is_backup: bool = False) -> bool:
        """
        Update user notes for a save file.
        
        Args:
            save_id: The UUID of the save.
            notes: The notes to set.
            is_backup: Whether this is a backup save.
            
        Returns:
            True if successful, False otherwise.
        """
        return bool(self.update_metadata(save_id, {"custom_notes": notes}, is_backup))
    
    def find_saves_by_tag(self, tag: str, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Find saves with a specific tag.
        
        Args:
            tag: The tag to search for.
            include_backups: Whether to include backup saves.
            
        Returns:
            List of SaveMetadata objects with the specified tag.
        """
        all_saves = self.get_save_list(include_backups=include_backups)
        return [save for save in all_saves if tag in save.tags]
    
    def find_saves_by_player(self, player_name: str, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Find saves for a specific player.
        
        Args:
            player_name: The player name to search for.
            include_backups: Whether to include backup saves.
            
        Returns:
            List of SaveMetadata objects for the specified player.
        """
        all_saves = self.get_save_list(include_backups=include_backups)
        return [save for save in all_saves if save.player_name.lower() == player_name.lower()]
    
    def get_recent_saves(self, count: int = 5, include_backups: bool = False) -> List[SaveMetadata]:
        """
        Get the most recent saves.
        
        Args:
            count: Maximum number of saves to return.
            include_backups: Whether to include backup saves.
            
        Returns:
            List of the most recent SaveMetadata objects.
        """
        all_saves = self.get_save_list(include_backups=include_backups)
        return all_saves[:min(count, len(all_saves))]
    
    def count_saves(self, include_backups: bool = False) -> int:
        """
        Count the number of saves.
        
        Args:
            include_backups: Whether to include backup saves.
            
        Returns:
            Number of saves.
        """
        return len(self.get_save_list(include_backups=include_backups))


# Example usage
if __name__ == "__main__":
    save_manager = SaveManager()
    
    # List available saves
    saves = save_manager.get_save_list()
    print(f"Found {len(saves)} saves:")
    for save in saves:
        print(f"  {save.save_name} ({save.formatted_save_time})")
    
    # Create a test save if none exist
    if not saves:
        print("\nCreating a test save...")
        save_id = str(uuid.uuid4())
        save_dir = save_manager.create_save_directory(save_id)
        
        # Create sample metadata
        metadata = SaveMetadata(
            save_id=save_id,
            save_name="Test Save",
            save_time=time.time(),
            version="0.1.0",
            player_name="TestPlayer",
            player_level=5,
            world_time="13:45",
            location="Test Village",
            playtime=3600.0,
            tags=["test"]
        )
        
        # Save metadata
        metadata_path = os.path.join(save_dir, SaveManager.METADATA_FILENAME)
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata.to_dict(), f, indent=2, cls=EnhancedJSONEncoder)
        
        # Create sample state
        state = {
            "player": {
                "name": "TestPlayer",
                "level": 5,
                "stats": {"health": 100, "mana": 50}
            },
            "world": {
                "current_location": "Test Village",
                "time": "13:45",
                "weather": "clear"
            }
        }
        
        # Save state
        state_path = os.path.join(save_dir, SaveManager.STATE_FILENAME)
        with open(state_path, 'w', encoding='utf-8') as f:
            f.write(enhanced_json_dumps(state, indent=2))
        
        print(f"Created test save with ID: {save_id}")
        
        # Create a backup
        backup_id = save_manager.create_backup(save_id)
        print(f"Created backup with ID: {backup_id}")
        
        # List saves again
        saves = save_manager.get_save_list(include_backups=True)
        print(f"\nNow found {len(saves)} saves (including backups):")
        for save in saves:
            save_type = "Backup" if save.backup_of else "Regular"
            print(f"  {save.save_name} - {save_type} ({save.formatted_save_time})")
```

### File: core\utils\time_utils.py

```python
#!/usr/bin/env python3
"""
Time utilities for the RPG game.

This module provides utility functions for manipulating and formatting
time in the game world, including conversions between game time and
real time, and human-readable time formatting.
"""

import time
import datetime
from typing import Optional, Tuple, Union, Dict, Any
import logging

from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

# Constants for time units in seconds
SECOND = 1
MINUTE = 60 * SECOND
HOUR = 60 * MINUTE
DAY = 24 * HOUR
WEEK = 7 * DAY
MONTH = 30 * DAY  # Approximation
YEAR = 365 * DAY  # Approximation

# Default game time scale (1 real second = 60 game seconds)
DEFAULT_TIME_SCALE = 60.0

# Game time epoch (reference point for game time)
# Using Jan 1, 1000 as a default fantasy setting start date
GAME_EPOCH = datetime.datetime(year=1000, month=1, day=1)


def game_time_to_datetime(game_time: float, epoch: datetime.datetime = None) -> datetime.datetime:
    """
    Convert game time (seconds since game epoch) to a datetime object.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A datetime object representing the game time.
    """
    epoch = epoch or GAME_EPOCH
    
    # Calculate days and remaining seconds
    days = int(game_time / DAY)
    remaining_seconds = game_time % DAY
    
    # Add to the epoch
    return epoch + datetime.timedelta(days=days, seconds=remaining_seconds)


def datetime_to_game_time(dt: datetime.datetime, epoch: datetime.datetime = None) -> float:
    """
    Convert a datetime object to game time (seconds since game epoch).
    
    Args:
        dt: The datetime to convert.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        The game time in seconds.
    """
    epoch = epoch or GAME_EPOCH
    
    # Calculate the difference
    delta = dt - epoch
    
    # Convert to seconds
    return delta.total_seconds()


def format_game_time(game_time: float, format_str: str = "%Y-%m-%d %H:%M:%S", 
                   epoch: datetime.datetime = None) -> str:
    """
    Format game time as a string using a datetime format string.
    
    Args:
        game_time: The game time in seconds since the epoch.
        format_str: The format string to use.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A formatted string representing the game time.
    """
    dt = game_time_to_datetime(game_time, epoch)
    return dt.strftime(format_str)


def format_time_of_day(game_time: float, epoch: datetime.datetime = None) -> str:
    """
    DEPRECATED: Use enhanced_time_manager.get_simple_time() instead.
    
    Get the time of day as a string (e.g., "Morning", "Afternoon").
    This function is kept for backward compatibility but now delegates
    to the enhanced time manager for better narrative descriptions.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A string representing the time of day.
    """
    logger.warning("format_time_of_day() is deprecated, use enhanced_time_manager.get_simple_time() instead")
    
    # Use enhanced time manager for better descriptions
    try:
        from core.utils.enhanced_time_manager import get_simple_time
        return get_simple_time(game_time)
    except ImportError:
        # Fallback to old logic if enhanced time manager not available
        dt = game_time_to_datetime(game_time, epoch)
        hour = dt.hour
        
        if 5 <= hour < 12:
            return "Morning"
        elif 12 <= hour < 17:
            return "Afternoon"
        elif 17 <= hour < 21:
            return "Evening"
        else:
            return "Night"


def format_date(game_time: float, epoch: datetime.datetime = None) -> str:
    """
    Format the game date in a human-readable way.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        A formatted date string (e.g., "January 1, 1000").
    """
    dt = game_time_to_datetime(game_time, epoch)
    return dt.strftime("%B %d, %Y")


def format_duration(seconds: float) -> str:
    """
    Format a duration in seconds as a human-readable string.
    
    Args:
        seconds: The duration in seconds.
    
    Returns:
        A formatted duration string (e.g., "2 days, 3 hours, 45 minutes").
    """
    # Handle negative durations
    is_negative = seconds < 0
    seconds = abs(seconds)
    
    # Calculate time units
    days, remainder = divmod(seconds, DAY)
    hours, remainder = divmod(remainder, HOUR)
    minutes, seconds = divmod(remainder, MINUTE)
    
    # Build the string
    parts = []
    
    if days > 0:
        parts.append(f"{int(days)} day{'' if days == 1 else 's'}")
    
    if hours > 0:
        parts.append(f"{int(hours)} hour{'' if hours == 1 else 's'}")
    
    if minutes > 0:
        parts.append(f"{int(minutes)} minute{'' if minutes == 1 else 's'}")
    
    if seconds > 0 or not parts:
        # Only include seconds if it's the only component or if there are some
        parts.append(f"{int(seconds)} second{'' if seconds == 1 else 's'}")
    
    # Join with commas and add negative sign if needed
    result = ", ".join(parts)
    if is_negative:
        result = f"negative {result}"
    
    return result


def parse_time_string(time_str: str) -> Optional[float]:
    """
    Parse a time string into seconds.
    
    Supports formats like:
    - "10s" (10 seconds)
    - "5m" (5 minutes)
    - "2h" (2 hours)
    - "1d" (1 day)
    - "1h30m" (1 hour and 30 minutes)
    
    Args:
        time_str: The time string to parse.
    
    Returns:
        The time in seconds, or None if parsing failed.
    """
    try:
        # Replace common variations
        time_str = time_str.lower().replace(" ", "")
        
        # Initialize total seconds
        total_seconds = 0
        
        # Parse different units
        units = {
            "s": SECOND,
            "m": MINUTE,
            "h": HOUR,
            "d": DAY,
            "w": WEEK,
            "mo": MONTH,
            "y": YEAR
        }
        
        # Extract numbers followed by units
        import re
        pattern = r"(\d+)([a-z]+)"
        matches = re.findall(pattern, time_str)
        
        if not matches:
            # Try to parse as a plain number (assumed to be seconds)
            try:
                return float(time_str)
            except ValueError:
                return None
        
        # Sum up all parts
        for value_str, unit in matches:
            value = float(value_str)
            
            if unit not in units:
                logger.warning(f"Unknown time unit: {unit}")
                return None
            
            total_seconds += value * units[unit]
        
        return total_seconds
    
    except Exception as e:
        logger.warning(f"Error parsing time string '{time_str}': {e}")
        return None


def real_to_game_time(real_seconds: float, time_scale: float = DEFAULT_TIME_SCALE) -> float:
    """
    Convert real time to game time.
    
    Args:
        real_seconds: The real time in seconds.
        time_scale: The time scale (game seconds per real second).
    
    Returns:
        The game time in seconds.
    """
    return real_seconds * time_scale


def game_to_real_time(game_seconds: float, time_scale: float = DEFAULT_TIME_SCALE) -> float:
    """
    Convert game time to real time.
    
    Args:
        game_seconds: The game time in seconds.
        time_scale: The time scale (game seconds per real second).
    
    Returns:
        The real time in seconds.
    """
    if time_scale <= 0:
        logger.warning(f"Invalid time scale: {time_scale}")
        return 0
    
    return game_seconds / time_scale


def get_current_game_time(start_time: float, elapsed_real: float, 
                        time_scale: float = DEFAULT_TIME_SCALE) -> float:
    """
    Calculate the current game time based on elapsed real time.
    
    Args:
        start_time: The starting game time.
        elapsed_real: The elapsed real time since the game started.
        time_scale: The time scale (game seconds per real second).
    
    Returns:
        The current game time.
    """
    return start_time + real_to_game_time(elapsed_real, time_scale)


def is_daytime(game_time: float, epoch: datetime.datetime = None) -> bool:
    """
    Check if the current game time is daytime (between 6 AM and 6 PM).
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        True if it's daytime, False otherwise.
    """
    dt = game_time_to_datetime(game_time, epoch)
    hour = dt.hour
    return 6 <= hour < 18


def get_season(game_time: float, epoch: datetime.datetime = None) -> str:
    """
    Get the current season based on the game time.
    
    Args:
        game_time: The game time in seconds since the epoch.
        epoch: The reference epoch datetime. If None, uses GAME_EPOCH.
    
    Returns:
        The current season ("Spring", "Summer", "Fall", or "Winter").
    """
    dt = game_time_to_datetime(game_time, epoch)
    month = dt.month
    
    if 3 <= month < 6:
        return "Spring"
    elif 6 <= month < 9:
        return "Summer"
    elif 9 <= month < 12:
        return "Fall"
    else:
        return "Winter"


def time_until(target_game_time: float, current_game_time: float) -> float:
    """
    Calculate the game time until a target time.
    
    Args:
        target_game_time: The target game time.
        current_game_time: The current game time.
    
    Returns:
        The game time until the target time (negative if in the past).
    """
    return target_game_time - current_game_time


def format_timestamp(timestamp: float, format_str: str = "%Y-%m-%d %H:%M:%S") -> str:
    """
    Format a Unix timestamp as a datetime string.
    
    Args:
        timestamp: The Unix timestamp (seconds since Jan 1, 1970).
        format_str: The format string to use.
    
    Returns:
        A formatted datetime string.
    """
    dt = datetime.datetime.fromtimestamp(timestamp)
    return dt.strftime(format_str)


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Example game time (1 day and 12 hours from epoch)
    game_time = DAY + 12 * HOUR
    
    # Convert to datetime
    dt = game_time_to_datetime(game_time)
    print(f"Game time {game_time} is datetime: {dt}")
    
    # Format as string
    formatted = format_game_time(game_time)
    print(f"Formatted: {formatted}")
    
    # Get time of day
    time_of_day = format_time_of_day(game_time)
    print(f"Time of day: {time_of_day}")
    
    # Parse a time string
    parsed = parse_time_string("2h30m15s")
    print(f"Parsed '2h30m15s': {parsed} seconds")
    
    # Convert real time to game time
    real_time = 60  # 1 minute real time
    converted = real_to_game_time(real_time)
    print(f"{real_time} seconds real time = {converted} seconds game time")
    
    # Format a duration
    duration = format_duration(parsed)
    print(f"Duration: {duration}")
```

### File: core\utils\dice.py

```python
"""
Dice rolling utilities for the game.
"""

import re
import random
from typing import List, Tuple, Dict, Any, Union, Optional
import logging

logger = logging.getLogger(__name__)

# Regular expression for dice notation, e.g., "2d6+3"
DICE_PATTERN = re.compile(r'(\d+)d(\d+)(?:([\+\-])(\d+))?')


def roll_die(sides: int) -> int:
    """
    Roll a single die with the given number of sides.
    
    Args:
        sides: Number of sides on the die.
        
    Returns:
        The result of the roll.
    """
    return random.randint(1, sides)


def roll_dice(num_dice: int, sides: int) -> List[int]:
    """
    Roll multiple dice with the given number of sides.
    
    Args:
        num_dice: Number of dice to roll.
        sides: Number of sides on each die.
        
    Returns:
        List of individual die results.
    """
    return [roll_die(sides) for _ in range(num_dice)]


def roll_dice_sum(num_dice: int, sides: int) -> int:
    """
    Roll multiple dice and return the sum.
    
    Args:
        num_dice: Number of dice to roll.
        sides: Number of sides on each die.
        
    Returns:
        Sum of all dice rolled.
    """
    return sum(roll_dice(num_dice, sides))


def roll_with_advantage(sides: int) -> Tuple[int, int, int]:
    """
    Roll two dice and take the higher result.
    
    Args:
        sides: Number of sides on each die.
        
    Returns:
        Tuple of (result, roll1, roll2) where result is the higher of roll1 and roll2.
    """
    roll1 = roll_die(sides)
    roll2 = roll_die(sides)
    result = max(roll1, roll2)
    return result, roll1, roll2


def roll_with_disadvantage(sides: int) -> Tuple[int, int, int]:
    """
    Roll two dice and take the lower result.
    
    Args:
        sides: Number of sides on each die.
        
    Returns:
        Tuple of (result, roll1, roll2) where result is the lower of roll1 and roll2.
    """
    roll1 = roll_die(sides)
    roll2 = roll_die(sides)
    result = min(roll1, roll2)
    return result, roll1, roll2


def parse_dice_notation(notation: str) -> Dict[str, Any]:
    """
    Parse a dice notation string (e.g., "2d6+3").
    
    Args:
        notation: The dice notation string.
        
    Returns:
        Dictionary with keys 'num_dice', 'sides', 'modifier_type', and 'modifier_value'.
        
    Raises:
        ValueError: If the notation is invalid.
    """
    match = DICE_PATTERN.match(notation)
    if not match:
        raise ValueError(f"Invalid dice notation: {notation}")
    
    num_dice = int(match.group(1))
    sides = int(match.group(2))
    
    result = {
        'num_dice': num_dice,
        'sides': sides,
        'modifier_type': None,
        'modifier_value': 0
    }
    
    # If there's a modifier
    if match.group(3) and match.group(4):
        result['modifier_type'] = match.group(3)
        result['modifier_value'] = int(match.group(4))
    
    return result


def roll_dice_notation(notation: str, crit_roll: bool = False) -> Dict[str, Any]:
    """
    Roll dice based on D&D-style notation (e.g., "2d6+3", "1d20-1").

    Args:
        notation: The dice notation string.
        crit_roll: If true, doubles the number of dice rolled (for critical hits).

    Returns:
        A dictionary with 'total', 'rolls' (list of individual dice results),
        and 'rolls_str' (string representation of rolls).
    """
    if not isinstance(notation, str) or not notation:
        logger.warning(f"Invalid or empty dice notation received: '{notation}'. Defaulting to 0.")
        return {"total": 0, "rolls": [], "rolls_str": "[]", "modifier": 0, "num_dice": 0, "die_size": 0}

    original_notation = notation
    notation = notation.lower().strip()
    
    num_dice = 1
    die_size = 0
    modifier = 0

    # Regex to parse dice notation: (NdM)(+/-X)
    # It captures:
    #   Group 1: (optional) Number of dice (e.g., "2" in "2d6")
    #   Group 2: Die size (e.g., "6" in "2d6")
    #   Group 3: (optional) Sign of the modifier (+ or -)
    #   Group 4: (optional) Value of the modifier
    match = re.match(r"(\d*)d(\d+)(?:([+\-])(\d+))?", notation)

    if not match:
        # Check if it's just a flat number
        if notation.isdigit() or (notation.startswith('-') and notation[1:].isdigit()):
            flat_value = int(notation)
            logger.debug(f"Interpreting notation '{original_notation}' as flat value: {flat_value}")
            return {"total": flat_value, "rolls": [flat_value], "rolls_str": f"[{flat_value}]", "modifier": 0, "num_dice": 0, "die_size": 0}
        else:
            logger.error(f"Invalid dice notation format: '{original_notation}'")
            raise ValueError(f"Invalid dice notation: {original_notation}")

    groups = match.groups()

    if groups[0]:  # Number of dice specified
        num_dice = int(groups[0])
    
    die_size = int(groups[1])

    if groups[2] and groups[3]:  # Modifier specified
        mod_sign = groups[2]
        mod_value = int(groups[3])
        modifier = mod_value if mod_sign == "+" else -mod_value
        
    if crit_roll:
        num_dice *= 2 # Double the dice for a critical hit
        logger.debug(f"Critical roll: Number of dice doubled to {num_dice} for {original_notation}")

    rolls = [random.randint(1, die_size) for _ in range(num_dice)]
    total_dice_roll = sum(rolls)
    final_total = total_dice_roll + modifier
    
    # --- ECFA Fix: Add 'rolls_str' ---
    rolls_str_representation = str(rolls) # e.g., "[3, 5]"
    # --- End ECFA Fix ---

    logger.debug(f"Rolled {original_notation}{' (crit)' if crit_roll else ''}: Rolls={rolls}, DiceTotal={total_dice_roll}, Mod={modifier}, Final={final_total}")
    
    return {
        "total": final_total, 
        "rolls": rolls,
        "rolls_str": rolls_str_representation, # Added
        "modifier": modifier,
        "num_dice": num_dice,
        "die_size": die_size
    }


def calculate_success_probability(
    target_number: int,
    dice_notation: str,
    advantage: bool = False,
    disadvantage: bool = False
) -> float:
    """
    Calculate the probability of rolling at or above a target number.
    
    Args:
        target_number: The number to meet or exceed.
        dice_notation: The dice notation string.
        advantage: Whether the roll has advantage (roll twice, take higher).
        disadvantage: Whether the roll has disadvantage (roll twice, take lower).
        
    Returns:
        Probability of success as a value between 0 and 1.
        
    Raises:
        ValueError: If the notation is invalid or if both advantage and disadvantage are True.
    """
    if advantage and disadvantage:
        raise ValueError("Cannot have both advantage and disadvantage")
    
    parsed = parse_dice_notation(dice_notation)
    num_dice = parsed['num_dice']
    sides = parsed['sides']
    
    # Apply modifier to target number
    if parsed['modifier_type'] == '+':
        adjusted_target = target_number - parsed['modifier_value']
    elif parsed['modifier_type'] == '-':
        adjusted_target = target_number + parsed['modifier_value']
    else:
        adjusted_target = target_number
    
    # Ensure target is within possible range
    min_roll = num_dice
    max_roll = num_dice * sides
    
    if adjusted_target <= min_roll:
        return 1.0  # Always succeed
    if adjusted_target > max_roll:
        return 0.0  # Always fail
    
    # For single die, calculation is simple
    if num_dice == 1:
        success_range = sides - adjusted_target + 1
        probability = success_range / sides
        
        if advantage:
            # Probability of at least one success in two rolls
            return 1 - (1 - probability) ** 2
        elif disadvantage:
            # Probability of success in both rolls
            return probability ** 2
        else:
            return probability
    
    # For multiple dice, use a simplified estimate for common cases
    # In a proper implementation, we'd use a more sophisticated approach
    # to calculate the exact probability distribution
    
    # Average roll for XdY is X * (Y+1)/2
    average_roll = num_dice * (sides + 1) / 2
    
    # Standard deviation (approximation for sum of dice)
    std_dev = (num_dice * (sides ** 2 - 1) / 12) ** 0.5
    
    # Normalize the target
    z_score = (adjusted_target - average_roll) / std_dev
    
    # Approximate probability using normal distribution
    # This is a rough approximation and works better with more dice
    import math
    probability = 0.5 * (1 - math.erf(z_score / math.sqrt(2)))
    
    if advantage:
        return 1 - (1 - probability) ** 2
    elif disadvantage:
        return probability ** 2
    else:
        return probability


def roll_critical(dice_notation: str, critical_multiplier: int = 2) -> Dict[str, Any]:
    """
    Roll dice with a critical hit (typically doubling the number of dice).
    
    Args:
        dice_notation: The dice notation string.
        critical_multiplier: The multiplier for the number of dice (default: 2).
        
    Returns:
        Dictionary with roll information.
        
    Raises:
        ValueError: If the notation is invalid.
    """
    parsed = parse_dice_notation(dice_notation)
    
    # For a critical hit, we multiply the number of dice
    critical_num_dice = parsed['num_dice'] * critical_multiplier
    
    # Roll the critical dice
    rolls = roll_dice(critical_num_dice, parsed['sides'])
    roll_sum = sum(rolls)
    
    # Apply modifier (usually only once, even on criticals)
    if parsed['modifier_type'] == '+':
        total = roll_sum + parsed['modifier_value']
    elif parsed['modifier_type'] == '-':
        total = roll_sum - parsed['modifier_value']
    else:
        total = roll_sum
    
    result = {
        'rolls': rolls,
        'total': total,
        'original_notation': dice_notation,
        'critical_num_dice': critical_num_dice,
        'sides': parsed['sides'],
        'modifier_type': parsed['modifier_type'],
        'modifier_value': parsed['modifier_value'],
        'critical_multiplier': critical_multiplier
    }
    
    log_str = f"Critical hit! Rolled {critical_num_dice}d{parsed['sides']}: {rolls}"
    if parsed['modifier_type']:
        log_str += f" {parsed['modifier_type']}{parsed['modifier_value']}"
    log_str += f" = {total}"
    logger.debug(log_str)
    
    return result


def check_success(roll: int, dc: int, is_attack: bool = False) -> Tuple[bool, bool, bool]:
    """
    Checks if a roll (d20 portion) is successful against a DC, 
    also determining critical success or fumble if it's an attack.

    Args:
        roll: The raw d20 dice roll result (1-20).
        dc: The difficulty class to beat.
        is_attack: If True, applies critical success (nat 20) and fumble (nat 1) rules.

    Returns:
        A tuple: (success_bool, is_critical_bool, is_fumble_bool).
        'success_bool' here is based on raw roll vs DC, primarily for non-attack skill checks.
        For attacks, the caller typically uses the total modified roll to determine final success,
        but uses is_critical and is_fumble from this function.
    """
    is_critical = False
    is_fumble = False

    if is_attack:
        if roll == 20:
            is_critical = True
          
            return True, is_critical, is_fumble
        if roll == 1:
            is_fumble = True
            return False, is_critical, is_fumble
    
 
    success = (roll >= dc)
    
    return success, is_critical, is_fumble

```

### File: core\utils\dotdict.py

```python
#!/usr/bin/env python3
"""
DotDict utility for the RPG game.

This module provides a dictionary subclass that allows accessing keys
using dot notation (e.g., d.key instead of d['key']).
"""

from typing import Any, Dict, List, Optional, Set, Tuple, Union
import logging

from core.utils.logging_config import get_logger

# Get the module logger
logger = get_logger("SYSTEM")

class DotDict(dict):
    """
    Dictionary that supports dot notation access to keys.
    
    This class extends the built-in dict to allow accessing keys
    using dot notation (e.g., d.key instead of d['key']). It also
    automatically converts nested dictionaries to DotDict objects.
    """
    
    def __init__(self, *args, **kwargs):
        """
        Initialize a DotDict.
        
        Args:
            *args: Arguments to pass to dict.__init__.
            **kwargs: Keyword arguments to pass to dict.__init__.
        """
        super().__init__(*args, **kwargs)
        # Convert nested dictionaries to DotDict objects
        self.__convert_nested_dicts()
    
    def __convert_nested_dicts(self):
        """Convert nested dictionaries to DotDict objects."""
        for key, value in self.items():
            if isinstance(value, dict) and not isinstance(value, DotDict):
                self[key] = DotDict(value)
            elif isinstance(value, list):
                self[key] = [
                    DotDict(item) if isinstance(item, dict) and not isinstance(item, DotDict) else item
                    for item in value
                ]
    
    def __getattr__(self, key: str) -> Any:
        """
        Get an attribute (key) from the dictionary.
        
        This method is called when an attribute is accessed that doesn't
        exist in the instance's __dict__. It looks up the key in the
        dictionary instead.
        
        Args:
            key: The attribute (key) to get.
        
        Returns:
            The value associated with the key.
        
        Raises:
            AttributeError: If the key is not in the dictionary.
        """
        try:
            return self[key]
        except KeyError:
            raise AttributeError(f"'DotDict' object has no attribute '{key}'")
    
    def __setattr__(self, key: str, value: Any) -> None:
        """
        Set an attribute (key) in the dictionary.
        
        Args:
            key: The attribute (key) to set.
            value: The value to set.
        """
        self[key] = value
        
        # Convert to DotDict if it's a dict
        if isinstance(value, dict) and not isinstance(value, DotDict):
            self[key] = DotDict(value)
    
    def __delattr__(self, key: str) -> None:
        """
        Delete an attribute (key) from the dictionary.
        
        Args:
            key: The attribute (key) to delete.
        
        Raises:
            AttributeError: If the key is not in the dictionary.
        """
        try:
            del self[key]
        except KeyError:
            raise AttributeError(f"'DotDict' object has no attribute '{key}'")
    
    def get(self, key: str, default: Any = None) -> Any:
        """
        Get a value from the dictionary with a default.
        
        Similar to dict.get, but supports dot notation for nested keys.
        
        Args:
            key: The key to get. Can be a dot-separated path (e.g., 'a.b.c').
            default: The default value to return if the key is not found.
        
        Returns:
            The value associated with the key, or the default if not found.
        """
        if "." not in key:
            return super().get(key, default)
        
        # Handle nested keys
        parts = key.split(".")
        current = self
        
        for part in parts[:-1]:
            if part not in current or not isinstance(current[part], (dict, DotDict)):
                return default
            current = current[part]
        
        return current.get(parts[-1], default)
    
    def set(self, key: str, value: Any) -> None:
        """
        Set a value in the dictionary.
        
        Supports dot notation for nested keys, creating intermediate
        dictionaries as needed.
        
        Args:
            key: The key to set. Can be a dot-separated path (e.g., 'a.b.c').
            value: The value to set.
        """
        if "." not in key:
            self[key] = value
            if isinstance(value, dict) and not isinstance(value, DotDict):
                self[key] = DotDict(value)
            return
        
        # Handle nested keys
        parts = key.split(".")
        current = self
        
        for part in parts[:-1]:
            if part not in current:
                current[part] = DotDict()
            elif not isinstance(current[part], (dict, DotDict)):
                current[part] = DotDict()
            current = current[part]
        
        current[parts[-1]] = value
        if isinstance(value, dict) and not isinstance(value, DotDict):
            current[parts[-1]] = DotDict(value)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the DotDict to a regular dictionary.
        
        This method recursively converts all nested DotDict objects to
        regular dictionaries.
        
        Returns:
            A regular dictionary.
        """
        result = {}
        
        for key, value in self.items():
            if isinstance(value, DotDict):
                result[key] = value.to_dict()
            elif isinstance(value, list):
                result[key] = [
                    item.to_dict() if isinstance(item, DotDict) else item
                    for item in value
                ]
            else:
                result[key] = value
        
        return result
    
    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> 'DotDict':
        """
        Create a DotDict from a regular dictionary.
        
        Args:
            d: The dictionary to convert.
        
        Returns:
            A DotDict with the same keys and values.
        """
        return cls(d)


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Create a DotDict
    config = DotDict({
        "game": {
            "title": "RPG Game",
            "version": "0.1.0",
            "settings": {
                "difficulty": "normal",
                "sound": {
                    "volume": 0.8,
                    "music": True,
                    "effects": True
                }
            }
        },
        "player": {
            "name": "Test Player",
            "stats": {
                "health": 100,
                "mana": 50
            },
            "inventory": [
                {"name": "Sword", "damage": 10},
                {"name": "Potion", "healing": 25}
            ]
        }
    })
    
    # Access values using dot notation
    print(f"Game title: {config.game.title}")
    print(f"Game version: {config.game.version}")
    print(f"Sound volume: {config.game.settings.sound.volume}")
    print(f"Player name: {config.player.name}")
    print(f"Player health: {config.player.stats.health}")
    
    # Access nested list items (these remain list items, not DotDicts)
    print(f"First inventory item: {config.player.inventory[0].name}")
    
    # Set values using dot notation
    config.player.stats.health = 90
    print(f"Updated player health: {config.player.stats.health}")
    
    # Add new keys
    config.game.settings.graphics = DotDict({"quality": "high", "fullscreen": True})
    print(f"Graphics quality: {config.game.settings.graphics.quality}")
    
    # Use get with dot notation for nested keys
    fps = config.get("game.settings.graphics.fps", 60)
    print(f"FPS: {fps}")
    
    # Use set with dot notation for nested keys
    config.set("game.settings.graphics.fps", 120)
    print(f"Updated FPS: {config.game.settings.graphics.fps}")
    
    # Convert back to dict
    regular_dict = config.to_dict()
    print(f"Regular dict: {type(regular_dict)}")
    
    # Create from dict
    new_config = DotDict.from_dict({"test": {"value": 42}})
    print(f"New config test value: {new_config.test.value}")
```

### File: core\utils\enhanced_time_manager.py

```python
#!/usr/bin/env python3
"""
Enhanced time management system for the RPG game.

This module provides rich, narrative time descriptions while keeping 
actual game time tracking in the background. It replaces clock-based
time references with immersive descriptive periods.
"""

import random
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

from core.utils.logging_config import get_logger
from core.utils.time_utils import game_time_to_datetime, GAME_EPOCH

logger = get_logger("TIME_MANAGER")


class TimePeriod(Enum):
    """Time periods for narrative descriptions."""
    DEEP_NIGHT = "deep_night"        # 0:00-4:00
    PRE_DAWN = "pre_dawn"            # 4:00-5:00  
    DAWN = "dawn"                    # 5:00-7:00
    MORNING = "morning"              # 7:00-11:00
    NOON = "noon"                    # 11:00-13:00
    AFTERNOON = "afternoon"          # 13:00-17:00
    EVENING = "evening"              # 17:00-20:00
    SUNSET = "sunset"                # 20:00-21:00
    NIGHT = "night"                  # 21:00-24:00


@dataclass
class TimeDescription:
    """A rich time description with multiple variants."""
    primary: str                     # Main description
    variants: List[str]             # Alternative descriptions
    atmospheric: List[str]          # Atmospheric descriptions
    seasonal_modifiers: Dict[str, List[str]]  # Season-specific variants


class EnhancedTimeManager:
    """
    Manages rich, narrative time descriptions for the RPG game.
    
    This class converts game time into immersive narrative descriptions,
    avoiding clock-based references that break immersion.
    """
    
    def __init__(self):
        """Initialize the enhanced time manager."""
        self._time_descriptions = self._initialize_time_descriptions()
        self._last_description_cache = {}  # Cache to avoid repetition
        
    def _initialize_time_descriptions(self) -> Dict[TimePeriod, TimeDescription]:
        """Initialize the comprehensive time description database."""
        return {
            TimePeriod.DEEP_NIGHT: TimeDescription(
                primary="deep night",
                variants=[
                    "the depths of night",
                    "the small hours", 
                    "the darkest hours",
                    "the dead of night",
                    "the quiet hours"
                ],
                atmospheric=[
                    "when shadows reign supreme",
                    "while the world sleeps",
                    "in the hushed darkness",
                    "beneath the star-filled sky",
                    "when only creatures of the night stir"
                ],
                seasonal_modifiers={
                    "Winter": ["the bitter night", "the frost-touched darkness"],
                    "Summer": ["the warm night air", "the gentle darkness"],
                    "Spring": ["the crisp night", "the awakening darkness"], 
                    "Fall": ["the cool night", "the harvest-time darkness"]
                }
            ),
            
            TimePeriod.PRE_DAWN: TimeDescription(
                primary="the hours before dawn",
                variants=[
                    "the pre-dawn darkness",
                    "the final hours of night",
                    "just before daybreak",
                    "the threshold of dawn"
                ],
                atmospheric=[
                    "when the world holds its breath",
                    "as night prepares to yield to day",
                    "in the expectant darkness",
                    "when the eastern sky begins to stir"
                ],
                seasonal_modifiers={
                    "Winter": ["the bitter pre-dawn", "before winter's pale sunrise"],
                    "Summer": ["the gentle pre-dawn", "before summer's golden sunrise"],
                    "Spring": ["the fresh pre-dawn", "before spring's bright sunrise"],
                    "Fall": ["the crisp pre-dawn", "before autumn's misty sunrise"]
                }
            ),
            
            TimePeriod.DAWN: TimeDescription(
                primary="dawn",
                variants=[
                    "daybreak",
                    "sunrise", 
                    "the break of day",
                    "first light",
                    "the dawn's early light",
                    "the morning's first breath"
                ],
                atmospheric=[
                    "as the first rays pierce the darkness",
                    "when the eastern sky blooms with color",
                    "as night surrenders to day",
                    "when shadows begin their retreat",
                    "as the world awakens from slumber"
                ],
                seasonal_modifiers={
                    "Winter": ["the pale winter dawn", "dawn's cold embrace"],
                    "Summer": ["the golden summer sunrise", "dawn's warm caress"],
                    "Spring": ["the vibrant spring daybreak", "dawn's fresh kiss"],
                    "Fall": ["the misty autumn sunrise", "dawn's gentle touch"]
                }
            ),
            
            TimePeriod.MORNING: TimeDescription(
                primary="morning",
                variants=[
                    "early morning",
                    "mid-morning", 
                    "late morning",
                    "the morning hours",
                    "forenoon"
                ],
                atmospheric=[
                    "as the day gains strength",
                    "when morning mist dances",
                    "while dew still glitters",
                    "as the world comes alive",
                    "when birdsong fills the air"
                ],
                seasonal_modifiers={
                    "Winter": ["the crisp winter morning", "morning's frost-kissed air"],
                    "Summer": ["the bright summer morning", "morning's warm embrace"],
                    "Spring": ["the fresh spring morning", "morning's renewed energy"],
                    "Fall": ["the cool autumn morning", "morning's harvest scents"]
                }
            ),
            
            TimePeriod.NOON: TimeDescription(
                primary="midday",
                variants=[
                    "noon",
                    "the height of day",
                    "high noon",
                    "the meridian hour",
                    "when the sun stands highest"
                ],
                atmospheric=[
                    "when shadows grow short",
                    "as the sun reaches its peak",
                    "when the day blazes brightest",
                    "at the pinnacle of daylight",
                    "when the world basks in full sunlight"
                ],
                seasonal_modifiers={
                    "Winter": ["the pale winter noon", "midday's weak warmth"],
                    "Summer": ["the blazing summer noon", "midday's intense heat"],
                    "Spring": ["the pleasant spring midday", "noon's gentle warmth"],
                    "Fall": ["the mellow autumn noon", "midday's golden light"]
                }
            ),
            
            TimePeriod.AFTERNOON: TimeDescription(
                primary="afternoon",
                variants=[
                    "early afternoon",
                    "mid-afternoon",
                    "late afternoon", 
                    "the afternoon hours",
                    "post-meridian"
                ],
                atmospheric=[
                    "as the day matures",
                    "when shadows begin to lengthen",
                    "while warmth lingers in the air",
                    "as the sun starts its descent",
                    "when the day grows contemplative"
                ],
                seasonal_modifiers={
                    "Winter": ["the short winter afternoon", "afternoon's fleeting warmth"],
                    "Summer": ["the long summer afternoon", "afternoon's lingering heat"],
                    "Spring": ["the pleasant spring afternoon", "afternoon's mild air"],
                    "Fall": ["the golden autumn afternoon", "afternoon's harvest light"]
                }
            ),
            
            TimePeriod.EVENING: TimeDescription(
                primary="evening",
                variants=[
                    "early evening",
                    "late evening",
                    "the evening hours",
                    "eventide",
                    "vespers"
                ],
                atmospheric=[
                    "as day begins to fade",
                    "when shadows grow long",
                    "as the world prepares for rest",
                    "while daylight softens",
                    "when peace settles over the land"
                ],
                seasonal_modifiers={
                    "Winter": ["the early winter evening", "evening's cold embrace"],
                    "Summer": ["the long summer evening", "evening's gentle coolness"],
                    "Spring": ["the mild spring evening", "evening's fresh air"],
                    "Fall": ["the crisp autumn evening", "evening's harvest moon"]
                }
            ),
            
            TimePeriod.SUNSET: TimeDescription(
                primary="sunset",
                variants=[
                    "dusk",
                    "twilight",
                    "gloaming", 
                    "the dying of the light",
                    "day's end",
                    "the sunset hour"
                ],
                atmospheric=[
                    "as the sky burns with color",
                    "when day surrenders to night",
                    "as golden light fades to purple",
                    "while the sun kisses the horizon",
                    "when the world is painted in fire"
                ],
                seasonal_modifiers={
                    "Winter": ["the brief winter sunset", "dusk's cold beauty"],
                    "Summer": ["the spectacular summer sunset", "twilight's warm glow"],
                    "Spring": ["the hopeful spring sunset", "dusk's fresh promise"],
                    "Fall": ["the magnificent autumn sunset", "twilight's golden glory"]
                }
            ),
            
            TimePeriod.NIGHT: TimeDescription(
                primary="night",
                variants=[
                    "early night",
                    "nightfall",
                    "the night hours",
                    "darkness",
                    "nocturne"
                ],
                atmospheric=[
                    "as darkness claims the land",
                    "when stars begin to twinkle",
                    "while night creatures stir",
                    "as the moon rises",
                    "when the world grows quiet"
                ],
                seasonal_modifiers={
                    "Winter": ["the long winter night", "night's frozen stillness"],
                    "Summer": ["the short summer night", "night's gentle coolness"],
                    "Spring": ["the mild spring night", "night's awakening energy"],
                    "Fall": ["the crisp autumn night", "night's harvest mystery"]
                }
            )
        }
    
    def get_time_period(self, game_time: float) -> TimePeriod:
        """
        Determine the narrative time period from game time.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            The appropriate TimePeriod enum value
        """
        dt = game_time_to_datetime(game_time, GAME_EPOCH)
        hour = dt.hour
        
        if 0 <= hour < 4:
            return TimePeriod.DEEP_NIGHT
        elif 4 <= hour < 5:
            return TimePeriod.PRE_DAWN
        elif 5 <= hour < 7:
            return TimePeriod.DAWN
        elif 7 <= hour < 11:
            return TimePeriod.MORNING
        elif 11 <= hour < 13:
            return TimePeriod.NOON
        elif 13 <= hour < 17:
            return TimePeriod.AFTERNOON
        elif 17 <= hour < 20:
            return TimePeriod.EVENING
        elif 20 <= hour < 21:
            return TimePeriod.SUNSET
        else:  # 21 <= hour < 24
            return TimePeriod.NIGHT
    
    def get_time_description(self, game_time: float, 
                           style: str = "primary", 
                           season: Optional[str] = None,
                           avoid_repetition: bool = True) -> str:
        """
        Get a rich narrative description of the current time.
        
        Args:
            game_time: Game time in seconds since epoch
            style: Description style - "primary", "variant", "atmospheric", "seasonal"
            season: Current season for seasonal modifiers
            avoid_repetition: Whether to avoid recently used descriptions
            
        Returns:
            A narrative time description string
        """
        period = self.get_time_period(game_time)
        description_data = self._time_descriptions[period]
        
        # Build available descriptions based on style
        available_descriptions = []
        
        if style in ["primary", "any"]:
            available_descriptions.append(description_data.primary)
            
        if style in ["variant", "any"]:
            available_descriptions.extend(description_data.variants)
            
        if style in ["atmospheric", "any"]:
            available_descriptions.extend(description_data.atmospheric)
            
        if style == "seasonal" and season and season in description_data.seasonal_modifiers:
            available_descriptions.extend(description_data.seasonal_modifiers[season])
        elif style == "any" and season and season in description_data.seasonal_modifiers:
            available_descriptions.extend(description_data.seasonal_modifiers[season])
        
        # If no descriptions available, fall back to primary
        if not available_descriptions:
            available_descriptions = [description_data.primary]
        
        # Avoid repetition if requested
        if avoid_repetition:
            cache_key = f"{period.value}_{style}"
            recently_used = self._last_description_cache.get(cache_key, [])
            
            # Filter out recently used descriptions
            fresh_descriptions = [d for d in available_descriptions if d not in recently_used]
            if fresh_descriptions:
                available_descriptions = fresh_descriptions
            
            # Select description
            selected = random.choice(available_descriptions)
            
            # Update cache (keep last 3 descriptions)
            recently_used.append(selected)
            if len(recently_used) > 3:
                recently_used.pop(0)
            self._last_description_cache[cache_key] = recently_used
            
            return selected
        else:
            return random.choice(available_descriptions)
    
    def get_contextual_time(self, game_time: float, 
                          context: str = "general",
                          season: Optional[str] = None) -> str:
        """
        Get a contextually appropriate time description.
        
        Args:
            game_time: Game time in seconds since epoch
            context: Context type - "general", "narrative", "combat", "social"
            season: Current season
            
        Returns:
            A contextually appropriate time description
        """
        if context == "narrative":
            return self.get_time_description(game_time, "atmospheric", season)
        elif context == "combat":
            return self.get_time_description(game_time, "primary", season)
        elif context == "social":
            return self.get_time_description(game_time, "variant", season)
        else:
            return self.get_time_description(game_time, "any", season)
    
    def is_daylight_period(self, game_time: float) -> bool:
        """
        Check if the current time is considered daylight.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            True if it's a daylight period, False otherwise
        """
        period = self.get_time_period(game_time)
        daylight_periods = {
            TimePeriod.DAWN, TimePeriod.MORNING, 
            TimePeriod.NOON, TimePeriod.AFTERNOON
        }
        return period in daylight_periods
    
    def is_night_period(self, game_time: float) -> bool:
        """
        Check if the current time is considered nighttime.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            True if it's a night period, False otherwise
        """
        period = self.get_time_period(game_time)
        night_periods = {
            TimePeriod.DEEP_NIGHT, TimePeriod.PRE_DAWN,
            TimePeriod.SUNSET, TimePeriod.NIGHT
        }
        return period in night_periods
    
    def is_transition_period(self, game_time: float) -> bool:
        """
        Check if the current time is a transition period (dawn/dusk).
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            True if it's a transition period, False otherwise
        """
        period = self.get_time_period(game_time)
        return period in {TimePeriod.DAWN, TimePeriod.SUNSET}
    
    def get_period_info(self, game_time: float) -> Dict[str, any]:
        """
        Get comprehensive information about the current time period.
        
        Args:
            game_time: Game time in seconds since epoch
            
        Returns:
            Dictionary with period information
        """
        period = self.get_time_period(game_time)
        
        return {
            "period": period.value,
            "is_daylight": self.is_daylight_period(game_time),
            "is_night": self.is_night_period(game_time),
            "is_transition": self.is_transition_period(game_time),
            "description": self.get_time_description(game_time),
            "atmospheric_description": self.get_time_description(game_time, "atmospheric"),
        }


# Singleton instance
_time_manager_instance = None


def get_enhanced_time_manager() -> EnhancedTimeManager:
    """
    Get the singleton instance of the Enhanced Time Manager.
    
    Returns:
        The EnhancedTimeManager singleton instance
    """
    global _time_manager_instance
    if _time_manager_instance is None:
        _time_manager_instance = EnhancedTimeManager()
        logger.info("Enhanced Time Manager initialized")
    return _time_manager_instance


# Convenience functions for easy integration
def get_narrative_time(game_time: float, season: Optional[str] = None) -> str:
    """Get a narrative time description for the given game time."""
    return get_enhanced_time_manager().get_contextual_time(game_time, "narrative", season)


def get_simple_time(game_time: float, season: Optional[str] = None) -> str:
    """Get a simple time description for the given game time."""
    return get_enhanced_time_manager().get_time_description(game_time, "primary", season)


def is_daylight(game_time: float) -> bool:
    """Check if the given game time is during daylight hours."""
    return get_enhanced_time_manager().is_daylight_period(game_time)


def is_nighttime(game_time: float) -> bool:
    """Check if the given game time is during nighttime hours."""
    return get_enhanced_time_manager().is_night_period(game_time)


if __name__ == "__main__":
    # Example usage and testing
    import time
    from core.utils.time_utils import DAY, HOUR
    
    # Test different times of day
    test_times = [
        (2 * HOUR, "Deep Night"),
        (5 * HOUR, "Dawn"), 
        (9 * HOUR, "Morning"),
        (12 * HOUR, "Noon"),
        (15 * HOUR, "Afternoon"),
        (18 * HOUR, "Evening"),
        (20.5 * HOUR, "Sunset"),
        (22 * HOUR, "Night")
    ]
    
    manager = get_enhanced_time_manager()
    
    print("=== Enhanced Time Manager Test ===\n")
    
    for game_time, label in test_times:
        print(f"{label} ({game_time/HOUR:.1f}h):")
        print(f"  Primary: {manager.get_time_description(game_time, 'primary')}")
        print(f"  Variant: {manager.get_time_description(game_time, 'variant')}")
        print(f"  Atmospheric: {manager.get_time_description(game_time, 'atmospheric')}")
        print(f"  Seasonal (Spring): {manager.get_time_description(game_time, 'seasonal', 'Spring')}")
        print(f"  Contextual: {manager.get_contextual_time(game_time, 'narrative', 'Spring')}")
        print(f"  Is Daylight: {manager.is_daylight_period(game_time)}")
        print()
```

### File: core\utils\json_utils.py

```python
#!/usr/bin/env python3
"""
JSON utilities for the RPG game.

This module provides enhanced JSON encoding/decoding capabilities
for handling complex data types used throughout the application.
"""

import json
import uuid
import dataclasses
import datetime
import enum
from typing import Any, Dict, List, Set, Tuple, Union, Optional
import logging

# Get the module logger
logger = logging.getLogger(__name__)

class EnhancedJSONEncoder(json.JSONEncoder):
    """Enhanced JSON encoder to handle various Python types."""
    
    def default(self, obj: Any) -> Any:
        """Convert Python objects to JSON serializable types."""
        # Handle dataclasses
        if dataclasses.is_dataclass(obj):
            return {
                "_type": f"{obj.__class__.__module__}.{obj.__class__.__name__}",
                "_data": {f.name: getattr(obj, f.name) for f in dataclasses.fields(obj)}
            }
        
        # Handle enums
        if isinstance(obj, enum.Enum):
            return {
                "_type": "enum",
                "_class": f"{obj.__class__.__module__}.{obj.__class__.__name__}",
                "_name": obj.name,
                "_value": obj.value
            }
        
        # Handle datetime objects
        if isinstance(obj, datetime.datetime):
            return {
                "_type": "datetime",
                "_value": obj.isoformat()
            }
        
        # Handle date objects
        if isinstance(obj, datetime.date):
            return {
                "_type": "date",
                "_value": obj.isoformat()
            }
        
        # Handle time objects
        if isinstance(obj, datetime.time):
            return {
                "_type": "time",
                "_value": obj.isoformat()
            }
        
        # Handle UUID objects
        if isinstance(obj, uuid.UUID):
            return {
                "_type": "uuid",
                "_value": str(obj)
            }
        
        # Handle sets
        if isinstance(obj, set):
            return {
                "_type": "set",
                "_value": list(obj)
            }
        
        # Handle any object with a to_dict method
        if hasattr(obj, "to_dict") and callable(getattr(obj, "to_dict")):
            result = obj.to_dict()
            result["_type"] = f"{obj.__class__.__module__}.{obj.__class__.__name__}"
            return result
        
        # Let the parent class handle the rest
        try:
            return super().default(obj)
        except TypeError as e:
            logger.warning(f"Could not JSON serialize {type(obj)}: {e}")
            return str(obj)  # Fallback to string representation


class EnhancedJSONDecoder(json.JSONDecoder):
    """Enhanced JSON decoder to reconstruct Python objects from JSON."""
    
    def __init__(self, *args, **kwargs):
        """Initialize the decoder with custom object hook."""
        kwargs["object_hook"] = self._object_hook
        super().__init__(*args, **kwargs)
    
    def _object_hook(self, obj: Dict[str, Any]) -> Any:
        """Convert JSON objects back to Python objects."""
        # Check if this is a specially encoded object
        if "_type" not in obj:
            return obj
        
        obj_type = obj["_type"]
        
        # Handle enums
        if obj_type == "enum":
            try:
                module_name, class_name = obj["_class"].rsplit(".", 1)
                module = __import__(module_name, fromlist=[class_name])
                enum_class = getattr(module, class_name)
                return enum_class[obj["_name"]]
            except (ImportError, AttributeError, KeyError) as e:
                logger.warning(f"Could not decode enum: {e}")
                return obj
        
        # Handle datetime objects
        if obj_type == "datetime":
            return datetime.datetime.fromisoformat(obj["_value"])
        
        # Handle date objects
        if obj_type == "date":
            return datetime.date.fromisoformat(obj["_value"])
        
        # Handle time objects
        if obj_type == "time":
            return datetime.time.fromisoformat(obj["_value"])
        
        # Handle UUID objects
        if obj_type == "uuid":
            return uuid.UUID(obj["_value"])
        
        # Handle sets
        if obj_type == "set":
            return set(obj["_value"])
        
        # Handle dataclasses and other custom objects
        try:
            module_name, class_name = obj_type.rsplit(".", 1)
            module = __import__(module_name, fromlist=[class_name])
            cls = getattr(module, class_name)
            
            # If it's a dataclass
            if dataclasses.is_dataclass(cls):
                return cls(**obj["_data"])
            
            # If it has a from_dict method
            if hasattr(cls, "from_dict") and callable(getattr(cls, "from_dict")):
                # Remove the _type field first
                obj_copy = obj.copy()
                obj_copy.pop("_type")
                return cls.from_dict(obj_copy)
        except (ImportError, AttributeError, ValueError) as e:
            logger.warning(f"Could not decode custom object: {e}")
        
        # Return the original object if we couldn't decode it
        return obj


# Utility functions

def to_json(obj: Any, pretty: bool = False) -> str:
    """Convert an object to a JSON string."""
    indent = 4 if pretty else None
    try:
        return json.dumps(obj, cls=EnhancedJSONEncoder, indent=indent)
    except Exception as e:
        logger.error(f"Error serializing to JSON: {e}")
        raise


def from_json(json_str: str) -> Any:
    """Convert a JSON string back to Python objects."""
    try:
        return json.loads(json_str, cls=EnhancedJSONDecoder)
    except Exception as e:
        logger.error(f"Error deserializing from JSON: {e}")
        raise


def save_json(obj: Any, file_path: str, pretty: bool = True) -> None:
    """Save an object to a JSON file."""
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(obj, f, cls=EnhancedJSONEncoder, indent=4 if pretty else None)
    except Exception as e:
        logger.error(f"Error saving JSON to {file_path}: {e}")
        raise


def load_json(file_path: str) -> Any:
    """Load an object from a JSON file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return json.load(f, cls=EnhancedJSONDecoder)
    except Exception as e:
        logger.error(f"Error loading JSON from {file_path}: {e}")
        raise


# Add alias functions for compatibility with save_manager.py
def enhanced_json_dumps(obj: Any, indent: Optional[int] = None) -> str:
    """Alias for to_json for compatibility with save_manager."""
    return to_json(obj, pretty=indent is not None)


def enhanced_json_loads(json_str: str) -> Any:
    """Alias for from_json for compatibility with save_manager."""
    return from_json(json_str)


# Example usage
if __name__ == "__main__":
    # Set up basic logging
    logging.basicConfig(level=logging.INFO)
    
    # Example dataclass
    @dataclasses.dataclass
    class Person:
        name: str
        age: int
        created_at: datetime.datetime = dataclasses.field(
            default_factory=lambda: datetime.datetime.now()
        )
        id: uuid.UUID = dataclasses.field(
            default_factory=uuid.uuid4
        )
        tags: Set[str] = dataclasses.field(default_factory=set)
    
    # Example enum
    class Color(enum.Enum):
        RED = 1
        GREEN = 2
        BLUE = 3
    
    # Create test objects
    person = Person(name="Alice", age=30)
    person.tags.add("player")
    person.tags.add("admin")
    
    favorite_color = Color.BLUE
    
    # Test serialization
    data = {
        "person": person,
        "favorite_color": favorite_color,
        "current_time": datetime.datetime.now(),
        "settings": {
            "debug": True,
            "volume": 0.8
        }
    }
    
    # Serialize to JSON
    json_str = to_json(data, pretty=True)
    print("Serialized JSON:")
    print(json_str)
    
    # Deserialize from JSON
    restored_data = from_json(json_str)
    print("\nDeserialized data:")
    print(f"Person name: {restored_data['person'].name}")
    print(f"Person age: {restored_data['person'].age}")
    print(f"Person created at: {restored_data['person'].created_at}")
    print(f"Person ID: {restored_data['person'].id}")
    print(f"Person tags: {restored_data['person'].tags}")
    print(f"Favorite color: {restored_data['favorite_color']}")
    print(f"Current time: {restored_data['current_time']}")
    print(f"Settings: {restored_data['settings']}")
```

### File: core\utils\logging_config.py

```python
"""
Logging configuration for the game.
"""

import os
import logging
import logging.handlers
import time
from typing import Dict, Optional

# Global configuration
DEFAULT_LEVEL = logging.INFO
LOGGERS: Dict[str, logging.Logger] = {}
LOGGER_FORMAT = '%(asctime)s [%(name)s] %(levelname)s: %(message)s'
DATE_FORMAT = '%Y-%m-%d %H:%M:%S'
LOG_DIRECTORY = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'logs')

# Migration tracking - add to track fixed imports
LOG_MIGRATION_FIXES = True


def setup_logging(level: int = DEFAULT_LEVEL) -> None:
    """
    Set up the logging system for the application.
    
    Args:
        level: The log level to use.
    """
    return configure_logging(level)


def configure_logging(level: int = DEFAULT_LEVEL) -> None:
    """
    Configure the logging system.
    
    Args:
        level: The log level to use.
    """
    # Create log directory if it doesn't exist
    if not os.path.exists(LOG_DIRECTORY):
        os.makedirs(LOG_DIRECTORY)
    
    # Configure the root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    
    # Remove all handlers
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
    
    # Create a console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    
    # Set the format
    formatter = logging.Formatter(LOGGER_FORMAT, DATE_FORMAT)
    console_handler.setFormatter(formatter)
    
    # Add the console handler to the root logger
    root_logger.addHandler(console_handler)
    
    # Create a file handler for all logs
    log_file = os.path.join(LOG_DIRECTORY, f'game_{time.strftime("%Y%m%d_%H%M%S")}.log')
    file_handler = logging.handlers.RotatingFileHandler(
        log_file,
        maxBytes=10*1024*1024,  # 10 MB
        backupCount=5,
        encoding='utf-8'  # Explicitly set encoding
    )
    file_handler.setLevel(level)
    file_handler.setFormatter(formatter)
    
    # Add the file handler to the root logger
    root_logger.addHandler(file_handler)
    
    # Create a file handler for errors only
    error_log_file = os.path.join(LOG_DIRECTORY, f'error_{time.strftime("%Y%m%d_%H%M%S")}.log')
    error_file_handler = logging.handlers.RotatingFileHandler(
        error_log_file,
        maxBytes=5*1024*1024,  # 5 MB
        backupCount=5,
        encoding='utf-8'  # Explicitly set encoding
    )
    error_file_handler.setLevel(logging.ERROR)
    error_file_handler.setFormatter(formatter)
    
    # Add the error file handler to the root logger
    root_logger.addHandler(error_file_handler)
    
    # Log that logging is configured
    root_logger.info("Logging configured")


def get_logger(name: str) -> logging.Logger:
    """
    Get a logger with the given name.
    
    If the logger doesn't exist, it will be created and configured.
    
    Args:
        name: The name of the logger.
    
    Returns:
        The logger.
    """
    # Check if the logger is already cached
    if name in LOGGERS:
        return LOGGERS[name]
    
    # Create a new logger
    logger = logging.getLogger(name)
    
    # Cache the logger
    LOGGERS[name] = logger
    
    return logger


def log_migration_fix(module_name: str, old_import: str, new_import: str) -> None:
    """
    Log a migration fix for import paths.
    
    Args:
        module_name: The name of the module being fixed
        old_import: The old, incorrect import path
        new_import: The new, correct import path
    """
    if not LOG_MIGRATION_FIXES:
        return
        
    logger = get_logger("MIGRATION")
    logger.info(f"Fixed import in {module_name}: '{old_import}' -> '{new_import}'")
```

### File: gui\components\character_sheet.py

```python
#!/usr/bin/env python3
"""
Character sheet widget for the RPG game GUI.
This module provides a widget for displaying the player character's information.
"""

import logging
import re
from typing import Optional, Dict, Any, List, Union, Callable
from PySide6.QtWidgets import (QListWidget,QListWidgetItem,
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, QTextEdit,
    QScrollArea, QFrame, QGroupBox, QProgressBar, QMenu, QToolTip
)
from PySide6.QtCore import Qt, Slot, Signal, QPoint
from PySide6.QtGui import QFont, QPixmap, QCursor, QMouseEvent,QColor

from core.base.state import get_state_manager
from core.interaction.enums import InteractionMode
from core.inventory.item import Item
from core.inventory.item_enums import EquipmentSlot
from core.inventory.item_manager import get_inventory_manager
from core.stats.modifier import StatModifier
from core.stats.stats_base import StatType, DerivedStatType, Stat, StatCategory
from core.stats.stats_manager import get_stats_manager
from core.utils.logging_config import get_logger

logger = get_logger("GUI")

class StatLabel(QLabel):
    """A label for displaying a stat that shows details on right-click."""
    
    def __init__(self, text: str, stat_name: str, parent=None):
        """
        Initialize the stat label.

        Args:
            text: The initial text to display.
            stat_name: The name of the stat this label represents (e.g., "STR", "MELEE_ATTACK").
            parent: The parent widget.
        """
        super().__init__(text, parent)
        # Store the enum name (e.g., "STR") for consistency with StatsManager keys
        self.stat_name_key = stat_name # Keep the original key passed in
        self.description = ""
        self.base_value = 0
        self.current_value = 0
        # Modifiers will be fetched dynamically for tooltip
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Handle mouse press events to show tooltips."""
        if event.button() == Qt.RightButton:
            self.show_tooltip(event.globalPos())
        super().mousePressEvent(event)
    
    def _fetch_modifiers(self) -> List[Dict[str, Any]]:
        """Fetch the list of modifiers for this stat."""
        try:
            # Get the StatsManager instance
            stats_manager = get_stats_manager()
            if not stats_manager:
                return []

            # Convert the stored stat_name_key back to the enum type if possible
            stat_type_enum = None
            try:
                stat_type_enum = StatType[self.stat_name_key]
            except KeyError:
                try:
                    stat_type_enum = DerivedStatType[self.stat_name_key]
                except KeyError:
                    logging.warning(f"Could not convert stat key '{self.stat_name_key}' to StatType or DerivedStatType for fetching modifiers.")
                    return []

            # Check if ModifierManager has a method to get the list
            # Assuming a method get_modifiers_for_stat exists or can be added
            if hasattr(stats_manager.modifier_manager, 'get_modifiers_for_stat'):
                # This method should return List[StatModifier] or List[Dict]
                mods = stats_manager.modifier_manager.get_modifiers_for_stat(stat_type_enum)
                # Convert StatModifier objects to dicts if necessary
                if mods and isinstance(mods[0], StatModifier):
                     return [mod.to_dict() for mod in mods] # Assuming StatModifier has to_dict()
                elif mods and isinstance(mods, list):
                     return mods # Assume it's already a list of dicts
                else:
                     return []
            else:
                # Fallback or log warning if the method doesn't exist
                logging.warning(f"ModifierManager lacks 'get_modifiers_for_stat' method.")
                return []

        except Exception as e:
            logging.error(f"Error fetching modifiers for {self.stat_name_key}: {e}")
            return []

    def show_tooltip(self, position: QPoint) -> None:
        """Show detailed tooltip for the stat."""
        # Fetch modifiers dynamically
        modifiers = self._fetch_modifiers()

        # Get the display name (e.g., "Strength") if available, otherwise use the key
        display_name = self.stat_name_key  # Default to key
        if hasattr(self, 'display_name_override'):  # Check if set by update_stat_data
            display_name = self.display_name_override

        tooltip_text = f"<b>{display_name}</b><hr>"

        if self.description:
            tooltip_text += f"{self.description}<br><br>"

        # Base / Total / Delta header with color-coded delta
        try:
            delta_val = (self.current_value or 0) - (self.base_value or 0)
        except Exception:
            delta_val = 0
        delta_sign = "+" if delta_val > 0 else ""
        delta_color = "#69c45f" if delta_val > 0 else ("#c45f5f" if delta_val < 0 else "#cccccc")
        tooltip_text += f"Base: {self.base_value}<br>"
        tooltip_text += f"Total: {self.current_value}"
        if delta_val != 0:
            tooltip_text += f" <span style='color:{delta_color}'>({delta_sign}{int(delta_val)})</span>"
        tooltip_text += "<br>"

        # Detailed modifiers list with color-coded values
        if modifiers:
            tooltip_text += "<br><b>Modifiers:</b><br>"
            for mod in modifiers:
                # Access modifier data assuming it's a dictionary now
                mod_source = mod.get('source_name') or mod.get('source') or 'Unknown'
                mod_value = mod.get('value', 0)
                mod_is_percentage = mod.get('is_percentage', False)
                mod_duration = mod.get('duration', None)

                sign = "+" if isinstance(mod_value, (int, float)) and mod_value > 0 else ""
                color = "#69c45f" if (isinstance(mod_value, (int, float)) and mod_value > 0) else ("#c45f5f" if (isinstance(mod_value, (int, float)) and mod_value < 0) else "#cccccc")
                val_text = f"<span style='color:{color}'>{sign}{mod_value}{'%' if mod_is_percentage else ''}</span>"
                dur_text = f" ({mod_duration} turns)" if (mod_duration is not None) else ""
                tooltip_text += f"{mod_source}: {val_text}{dur_text}<br>"
        else:
            tooltip_text += "<br>No active modifiers.<br>"

        QToolTip.showText(position, tooltip_text)

    def show_context_menu(self, position: QPoint) -> None:
        """Show context menu for the stat."""
        # Get the display name (e.g., "Strength") if available, otherwise use the key
        display_name = self.stat_name_key # Default to key
        if hasattr(self, 'display_name_override'): # Check if set by update_stat_data
            display_name = self.display_name_override

        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30; /* Dark background */
                color: #E0E0E0; /* Light text */
                border: 1px solid #555555; /* Subtle border */
                padding: 2px; /* Padding around all items */
            }
            QMenu::item {
                padding: 5px 20px 5px 20px; /* Top, Right, Bottom, Left padding */
                border: 1px solid transparent; /* Spacing between items */
            }
            QMenu::item:selected {
                background-color: #0E639C; /* Selection color */
                color: #FFFFFF;
            }
            QMenu::separator {
                height: 1px;
                background: #555555;
                margin-left: 10px;
                margin-right: 5px;
            }
        """)
        menu.addAction(f"{display_name} Details", lambda: self.show_tooltip(QCursor.pos()))
        menu.exec_(self.mapToGlobal(position))

    def update_stat_data(self, stat_data: Dict[str, Any]) -> None:
        """
        Update the stat data stored in the label for tooltip display.

        Args:
            stat_data: Dictionary containing stat information from StatsManager.
        """
        # Store the display name ("Strength") if provided, distinct from the key ("STR")
        if 'name' in stat_data:
            self.display_name_override = str(stat_data['name'])

        if 'description' in stat_data:
            self.description = stat_data['description']
        if 'base_value' in stat_data:
            self.base_value = stat_data['base_value']
        if 'value' in stat_data:
            self.current_value = stat_data['value']
        # We no longer store modifiers here, they are fetched dynamically


class CharacterSheetWidget(QScrollArea):
    """Widget for displaying character information."""

    item_unequip_from_slot_requested = Signal(EquipmentSlot)
    item_examine_requested = Signal(str) 
    item_drop_from_slot_requested = Signal(EquipmentSlot, str)
    
    def __init__(self, parent: Optional[QWidget] = None):
            """Initialize the character sheet widget."""
            super().__init__(parent)

            self.setWidgetResizable(True)
            self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.setStyleSheet("""
                QScrollArea {
                    background-color: #2D2D30;
                    border: none;
                }
            """)

            self.character_widget = QWidget()
            self.setWidget(self.character_widget)
            self.state_manager = get_state_manager()
            self._signal_connected = False

            self._pending_player_bar_updates: Dict[str, Dict[str, Any]] = {} 

            self._setup_ui() 
            self._clear_stat_displays()
            
    def _setup_ui(self):

        # Create the main layout
        self.main_layout = QVBoxLayout(self.character_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Initialize dictionaries for stat labels
        self.primary_stat_labels = {}
        self.derived_stat_labels = {}
        
        # Create character header
        self._create_header()
        
        # Create stats section
        self._create_stats_section()
        
        # Create skills section
        self._create_skills_section()
        
        # Create equipment section
        self._create_equipment_section()        
    
    def _create_header(self):
        """Create the character header section."""
        # Group box for character header
        header_group = QGroupBox("Character")
        header_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        header_layout = QHBoxLayout(header_group)
        
        # Character portrait frame
        portrait_frame = QFrame()
        portrait_frame.setFrameShape(QFrame.StyledPanel)
        portrait_frame.setFixedSize(100, 100)
        portrait_frame.setStyleSheet("""
            QFrame {
                border: 1px solid #555555;
                background-color: #222222;
            }
        """)
        
        # Character portrait label - this will be replaced with the actual image when available
        self.portrait_label = QLabel("Portrait")
        self.portrait_label.setAlignment(Qt.AlignCenter)
        self.portrait_label.setStyleSheet("color: #888888;")
        self.portrait_label.setScaledContents(True)  # Make the image scale to fit the label
        
        portrait_layout = QVBoxLayout(portrait_frame)
        portrait_layout.addWidget(self.portrait_label)
        
        # Character info
        info_layout = QVBoxLayout()
        
        # Create labels for character info
        self.name_label = QLabel("Name: Unknown")
        self.name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #E0E0E0;")
        
        self.race_class_label = QLabel("Race: Unknown | Class: Unknown")
        self.race_class_label.setStyleSheet("font-size: 12pt; color: #CCCCCC;")
        
        self.level_exp_label = QLabel("Level: 1 | Experience: 0/100")
        self.level_exp_label.setStyleSheet("font-size: 11pt; color: #BBBBBB;")
        
        # Experience bar
        self.exp_bar = QProgressBar()
        self.exp_bar.setRange(0, 100)
        self.exp_bar.setValue(0)
        self.exp_bar.setTextVisible(True)
        self.exp_bar.setStyleSheet("""
            QProgressBar {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                color: white;
            }
            QProgressBar::chunk {
                background-color: #006699;
                border-radius: 3px;
            }
        """)
        
        # Add widgets to layout
        info_layout.addWidget(self.name_label)
        info_layout.addWidget(self.race_class_label)
        info_layout.addWidget(self.level_exp_label)
        info_layout.addWidget(self.exp_bar)
        
        # Add layouts to header
        header_layout.addWidget(portrait_frame)
        header_layout.addLayout(info_layout, 1)  # 1 is the stretch factor
        
        # Add header to main layout
        self.main_layout.addWidget(header_group)
    
    def _create_stats_section(self):
        """Create the character stats section."""

        # --- Create Primary Stats Group Box ---
        primary_stats_group = QGroupBox("Primary Stats")
        primary_stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        primary_stats_layout = QGridLayout(primary_stats_group)
        primary_stats_layout.setColumnStretch(0, 1)
        primary_stats_layout.setColumnStretch(1, 1)

        # Add primary stats - Using Enum Name as stat_id
        self._add_stat(primary_stats_layout, 0, 0, StatType.STRENGTH.name, "Strength", "")
        self._add_stat(primary_stats_layout, 0, 1, StatType.DEXTERITY.name, "Dexterity", "")
        self._add_stat(primary_stats_layout, 1, 0, StatType.CONSTITUTION.name, "Constitution", "")
        self._add_stat(primary_stats_layout, 1, 1, StatType.INTELLIGENCE.name, "Intelligence", "")
        self._add_stat(primary_stats_layout, 2, 0, StatType.WISDOM.name, "Wisdom", "")
        self._add_stat(primary_stats_layout, 2, 1, StatType.CHARISMA.name, "Charisma", "")
        self._add_stat(primary_stats_layout, 3, 0, StatType.WILLPOWER.name, "Willpower", "")
        self._add_stat(primary_stats_layout, 3, 1, StatType.INSIGHT.name, "Insight", "")

        # --- Create Resources Group Box ---
        resources_group = QGroupBox("Resources")
        resources_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        resources_layout = QVBoxLayout(resources_group)

        # Create resource bars
        self.resource_bars = {}
        self._add_resource_bar(resources_layout, "Health", 100, 100, "#CC3333")
        self._add_resource_bar(resources_layout, "Mana", 50, 50, "#3366CC")
        self._add_resource_bar(resources_layout, "Stamina", 100, 100, "#66CC33")

        # --- Create Combat Status Group Box (Modified to be Turn Order / Initiative only) ---
        combat_info_group = QGroupBox("Combat Info") # Renamed for clarity
        combat_info_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        combat_info_layout = QVBoxLayout(combat_info_group)

        # Status Effects section
        status_label = QLabel("Status Effects:")
        status_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        combat_info_layout.addWidget(status_label)

        self.status_effects_list = QTextEdit()
        self.status_effects_list.setReadOnly(True)
        self.status_effects_list.setMaximumHeight(60) # Keep height manageable
        self.status_effects_list.setStyleSheet("""
            QTextEdit {
                background-color: #222222;
                border: 1px solid #444444;
                color: #E0E0E0;
                padding: 3px;
            }
        """)
        combat_info_layout.addWidget(self.status_effects_list)
        
        # Turn Order section (kept for consistency, but might be less prominent if combat display is primary)
        turn_label = QLabel("Turn Order:")
        turn_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        combat_info_layout.addWidget(turn_label)

        self.turn_order_list = QTextEdit()
        self.turn_order_list.setReadOnly(True)
        self.turn_order_list.setMaximumHeight(80) # Increased height for better visibility
        self.turn_order_list.setStyleSheet("""
            QTextEdit {
                background-color: #222222;
                border: 1px solid #444444;
                color: #E0E0E0;
                padding: 3px;
                line-height: 1.2; /* Adjust line height for readability */
            }
        """)
        combat_info_layout.addWidget(self.turn_order_list)

        # Initiative label
        initiative_layout = QHBoxLayout()
        initiative_title_label = QLabel("Initiative:") # Changed variable name to avoid conflict
        initiative_title_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.initiative_value = QLabel("0")
        self.initiative_value.setStyleSheet("color: #E0E0E0;")
        self.initiative_value.setAlignment(Qt.AlignRight)
        initiative_layout.addWidget(initiative_title_label)
        initiative_layout.addWidget(self.initiative_value)
        combat_info_layout.addLayout(initiative_layout)


        # --- Create Derived Stats Group Box ---
        derived_stats_group = QGroupBox("Derived Stats")
        derived_stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        derived_stats_layout = QGridLayout(derived_stats_group)
        derived_stats_layout.setColumnStretch(0, 1)
        derived_stats_layout.setColumnStretch(1, 1)

        # Add derived stats - Using Enum Name as stat_id
        self._add_stat(derived_stats_layout, 0, 0, DerivedStatType.MELEE_ATTACK.name, "Melee Attack", "")
        self._add_stat(derived_stats_layout, 0, 1, DerivedStatType.RANGED_ATTACK.name, "Ranged Attack", "")
        self._add_stat(derived_stats_layout, 1, 0, DerivedStatType.MAGIC_ATTACK.name, "Magic Attack", "")
        self._add_stat(derived_stats_layout, 1, 1, DerivedStatType.DEFENSE.name, "Defense", "")
        self._add_stat(derived_stats_layout, 2, 0, DerivedStatType.MAGIC_DEFENSE.name, "Magic Defense", "")
        # Initiative is now in Combat Info, removing from here to avoid duplication
        # self._add_stat(derived_stats_layout, 2, 1, DerivedStatType.INITIATIVE.name, "Initiative", "")
        self._add_stat(derived_stats_layout, 3, 0, DerivedStatType.CARRY_CAPACITY.name, "Carry Capacity", "")
        self._add_stat(derived_stats_layout, 3, 1, DerivedStatType.MOVEMENT.name, "Movement", "")
        self._add_stat(derived_stats_layout, 2, 1, DerivedStatType.DAMAGE_REDUCTION.name, "Damage Reduction", "") # Added DR

        # --- Add the group boxes to the main layout ---
        self.main_layout.addWidget(resources_group)
        self.main_layout.addWidget(combat_info_group) # Add the renamed group
        self.main_layout.addWidget(primary_stats_group)
        self.main_layout.addWidget(derived_stats_group)

    def _add_stat(self, layout, row, col, stat_id, stat_name, value):
            """Add a stat to the stats layout."""
            # Create label
            label = QLabel(f"{stat_name}:") # Use descriptive name for the row label
            label.setStyleSheet("color: #BBBBBB; font-weight: bold;")

            # Create value label - use the Enum Name (stat_id) as the key
            value_label = StatLabel(value, stat_id) # Pass Enum Name ("STR", "MELEE_ATTACK")
            # Ensure HTML (for colored deltas) is rendered
            try:
                value_label.setTextFormat(Qt.RichText)
            except Exception:
                pass
            # Set minimum width and restore original color
            value_label.setStyleSheet("color: #E0E0E0; min-width: 30px;")
            value_label.setAlignment(Qt.AlignRight)

            # Store the value label using the Enum Name as the key
            if stat_id in [s.name for s in StatType]:
                self.primary_stat_labels[stat_id] = value_label
            else:
                self.derived_stat_labels[stat_id] = value_label

            # Add to layout
            layout.addWidget(label, row, col * 2)
            layout.addWidget(value_label, row, col * 2 + 1)
    
    def _add_resource_bar(self, layout, name, value, max_value, color):
        """Add a resource bar to the layout."""
        # Create container
        container = QWidget()
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(2)
        
        # Create label
        label = QLabel(f"{name}: {value}/{max_value}")
        label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        
        # Create progress bar
        progress_bar = QProgressBar()
        progress_bar.setRange(0, max_value)
        progress_bar.setValue(value)
        progress_bar.setTextVisible(True)
        progress_bar.setFormat(f"%v/%m")
        progress_bar.setStyleSheet(f"""
            QProgressBar {{
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                color: white;
            }}
            QProgressBar::chunk {{
                background-color: {color};
                border-radius: 3px;
            }}
        """)
        
        # Add to container
        container_layout.addWidget(label)
        container_layout.addWidget(progress_bar)
        
        # Store the bar
        self.resource_bars[name.lower()] = (label, progress_bar)
        
        # Add to layout
        layout.addWidget(container)
    
    def _create_skills_section(self):
        """Create the character skills section."""
        # Group box for skills
        skills_group = QGroupBox("Skills")
        skills_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        skills_layout = QVBoxLayout(skills_group)
        
        # Create a label for when no skills are available
        self.no_skills_label = QLabel("No skills available yet.")
        self.no_skills_label.setStyleSheet("color: #888888; font-style: italic;")
        self.no_skills_label.setAlignment(Qt.AlignCenter)
        
        skills_layout.addWidget(self.no_skills_label)
        
        # Add skills to main layout
        self.main_layout.addWidget(skills_group)
    
    def _create_equipment_section(self):
        """Create the character equipment section using QGridLayout and self.equip_labels."""
        equipment_group = QGroupBox("Equipment")
        equipment_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        equipment_layout = QGridLayout(equipment_group)
        equipment_layout.setSpacing(5) 
        
        self.equip_labels: Dict[str, CharacterSheetWidget.EquippedItemLabel] = {} 
        slots_to_display = [
            EquipmentSlot.HEAD, EquipmentSlot.NECK,
            EquipmentSlot.CHEST, EquipmentSlot.BACK,
            EquipmentSlot.SHOULDERS, EquipmentSlot.WRISTS,
            EquipmentSlot.HANDS, EquipmentSlot.WAIST,
            EquipmentSlot.LEGS, EquipmentSlot.FEET,
            EquipmentSlot.MAIN_HAND, EquipmentSlot.OFF_HAND,
            EquipmentSlot.FINGER_1, EquipmentSlot.FINGER_2,
            EquipmentSlot.TRINKET_1, EquipmentSlot.TRINKET_2
        ]

        num_cols = 2 
        for i, slot_enum in enumerate(slots_to_display):
            row = i // num_cols
            col = i % num_cols
            
            slot_display_name = slot_enum.value.replace('_', ' ').title()
            
            slot_label_widget = QLabel(f"{slot_display_name}:")
            slot_label_widget.setStyleSheet("color: #BBBBBB; font-weight: bold; padding-right: 5px;")
            slot_label_widget.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
            
            # Use the new EquippedItemLabel
            value_label_widget = CharacterSheetWidget.EquippedItemLabel("None", slot_enum, None, self)
            value_label_widget.set_item_data("None", None) # Initial state
            value_label_widget.setMinimumWidth(120) 
            value_label_widget.setWordWrap(True)
            value_label_widget.context_menu_requested_for_slot.connect(self._handle_equipped_item_context_menu)
            
            self.equip_labels[slot_enum.value] = value_label_widget
            
            equipment_layout.addWidget(slot_label_widget, row, col * 2)     
            equipment_layout.addWidget(value_label_widget, row, col * 2 + 1) 
        
        self.main_layout.addWidget(equipment_group)

    def update_character(self, character=None):
            """
            Update the character sheet with character data.

            Args:
                character: The character data object (PlayerState). If None, uses current state.
            """
            if not self._signal_connected:
                self._connect_stats_signal()

            try:
                if character is None:
                    if self.state_manager and self.state_manager.current_state:
                        character = self.state_manager.current_state.player
                    else:
                        logger.warning("No character data available to update character sheet")
                        self._clear_stat_displays()
                        return

                self.name_label.setText(f"Name: {character.name}")
                self.race_class_label.setText(f"Race: {character.race} | Class: {character.path}")
                exp_current = character.experience
                exp_next = character.experience_to_next_level
                self.level_exp_label.setText(f"Level: {character.level} | Experience: {exp_current}/{exp_next}")
                self.exp_bar.setRange(0, exp_next if exp_next > 0 else 100) 
                self.exp_bar.setValue(exp_current)

                if self.state_manager and self.state_manager.stats_manager:
                    stats_manager = self.state_manager.stats_manager
                    all_stats = stats_manager.get_all_stats()

                    if 'primary' in all_stats:
                        self._update_primary_stats(all_stats["primary"])
                    else:
                        logger.warning("Primary stats category not found in stats data.")

                    for category in ["combat", "social", "other"]: 
                        if category in all_stats:
                            self._update_derived_stats(all_stats[category], category)
                        else:
                            logger.warning(f"Derived stats category '{category}' not found in stats data.")

                    if "resources" in all_stats:
                        self._update_resources(all_stats["resources"], all_player_stats=all_stats)
                    else:
                        logger.warning("Resources category not found in stats data.")
                    self._update_combat_status(character)
                else:
                    logger.warning("Stats manager not available during update_character, stats will not be displayed.")
                    self._clear_stat_displays()

                inventory_manager = get_inventory_manager()
                if inventory_manager:
                    for slot_key_str, label_widget in self.equip_labels.items():
                        # Reset with default text and no item_id
                        label_widget.set_item_data("None", None) 
                    
                    if hasattr(inventory_manager, 'equipment'):
                        two_handed_weapon_equipped: Optional[Item] = None
                        # inventory_manager.equipment is Dict[EquipmentSlot, Optional[Item]]
                        potential_two_handed_item_obj = inventory_manager.equipment.get(EquipmentSlot.TWO_HAND)
                        if potential_two_handed_item_obj and isinstance(potential_two_handed_item_obj, Item):
                             two_handed_weapon_equipped = potential_two_handed_item_obj

                        for slot_enum, item_obj_from_inv_mgr in inventory_manager.equipment.items():
                            slot_key = slot_enum.value 
                            if item_obj_from_inv_mgr and isinstance(item_obj_from_inv_mgr, Item) and slot_key in self.equip_labels:
                                current_label_widget = self.equip_labels[slot_key]
                                if two_handed_weapon_equipped and item_obj_from_inv_mgr.id == two_handed_weapon_equipped.id:
                                    if EquipmentSlot.MAIN_HAND.value in self.equip_labels:
                                        self.equip_labels[EquipmentSlot.MAIN_HAND.value].set_item_data(f"{item_obj_from_inv_mgr.name} (2H)", item_obj_from_inv_mgr.id)
                                        self.equip_labels[EquipmentSlot.MAIN_HAND.value].setToolTip(item_obj_from_inv_mgr.description or item_obj_from_inv_mgr.name)
                                    if EquipmentSlot.OFF_HAND.value in self.equip_labels:
                                        self.equip_labels[EquipmentSlot.OFF_HAND.value].set_item_data(f"- (2H: {item_obj_from_inv_mgr.name}) -", None) # No item_id for placeholder
                                        self.equip_labels[EquipmentSlot.OFF_HAND.value].setStyleSheet("color: #777777;")
                                        self.equip_labels[EquipmentSlot.OFF_HAND.value].setToolTip(f"Occupied by Two-Handed: {item_obj_from_inv_mgr.name}")
                                    if EquipmentSlot.TWO_HAND.value in self.equip_labels:
                                         self.equip_labels[EquipmentSlot.TWO_HAND.value].set_item_data(item_obj_from_inv_mgr.name, item_obj_from_inv_mgr.id)
                                         self.equip_labels[EquipmentSlot.TWO_HAND.value].setToolTip(item_obj_from_inv_mgr.description or item_obj_from_inv_mgr.name)
                                elif slot_enum == EquipmentSlot.MAIN_HAND and two_handed_weapon_equipped:
                                    continue 
                                elif slot_enum == EquipmentSlot.OFF_HAND and two_handed_weapon_equipped:
                                    continue
                                else: 
                                    current_label_widget.set_item_data(item_obj_from_inv_mgr.name, item_obj_from_inv_mgr.id)
                                    current_label_widget.setToolTip(item_obj_from_inv_mgr.description or item_obj_from_inv_mgr.name)
                else:
                    logger.warning("CharacterSheetWidget: InventoryManager not available for equipment update.")

                if hasattr(character, 'character_image') and character.character_image:
                    try:
                        pixmap = QPixmap(character.character_image)
                        if not pixmap.isNull():
                            scaled_pixmap = pixmap.scaled(self.portrait_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            self.portrait_label.setPixmap(scaled_pixmap)
                            self.portrait_label.setStyleSheet("")
                        else:
                            self.portrait_label.setText("Portrait")
                            self.portrait_label.setStyleSheet("color: #888888;")
                    except Exception as image_err:
                        logging.error(f"Error loading character portrait: {image_err}")
                        self.portrait_label.setText("Portrait")
                        self.portrait_label.setStyleSheet("color: #888888;")
                else:
                    self.portrait_label.setText("Portrait")
                    self.portrait_label.setStyleSheet("color: #888888;")

            except Exception as e:
                logger.error(f"Error updating character sheet: {e}", exc_info=True)

    def _update_combat_status(self, character):
        """Update combat status information.
        This method is now less critical for turn order if TURN_ORDER_UPDATE events are used,
        but kept for fallback and status effects.
        Args:
            character: The player character instance.
        """
        if not character:
            return
            
        from core.base.state import get_state_manager # Local import
        state_manager = get_state_manager()
        if not state_manager or not state_manager.current_state:
            self.status_effects_list.clear()
            self.turn_order_list.setText("Turn Order: N/A") # Default text
            self.initiative_value.setText("0")
            return
            
        game_state = state_manager.current_state
        combat_manager = getattr(game_state, 'combat_manager', None)
        
        # Update status effects (Logic for status effects seems okay, no changes here unless explicitly requested)
        self.status_effects_list.clear()
        status_text = ""
        player_entity_for_effects = None

        if combat_manager:
            player_id_for_lookup = getattr(character, 'id', None) or getattr(character, 'stats_manager_id', None)
            if player_id_for_lookup and player_id_for_lookup in combat_manager.entities:
                player_entity_for_effects = combat_manager.entities[player_id_for_lookup]
        
        source_for_effects = player_entity_for_effects if player_entity_for_effects else character

        if hasattr(source_for_effects, 'status_effects'):
            effects_data = source_for_effects.status_effects
            if isinstance(effects_data, dict):
                for effect_name, duration_data in effects_data.items():
                    duration = None
                    if isinstance(duration_data, int): 
                        duration = duration_data
                    
                    if duration is not None and duration > 0 : 
                        status_text += f"{effect_name} ({duration} turns)\n"
                    elif duration is None: 
                        status_text += f"{effect_name}\n"
            elif isinstance(effects_data, (list, set)):
                for effect_name in effects_data:
                    status_text += f"{effect_name}\n"
        
        self.status_effects_list.setText(status_text.strip())
        
        # Turn order display will be primarily handled by handle_turn_order_update event.
        # This section can act as a fallback or for initial display if no event received yet.
        if not combat_manager:
            self.turn_order_list.setText("Turn Order: N/A (Not in Combat)")
            self.initiative_value.setText("0")
        elif not hasattr(self, '_last_turn_order_event_data') or not self._last_turn_order_event_data:
            # Fallback logic if no TURN_ORDER_UPDATE event has populated the display yet
            logger.debug("CharacterSheet: _update_combat_status using fallback for turn order.")
            turn_text = ""
            if getattr(combat_manager, '_is_surprise_round', False) and hasattr(combat_manager, '_surprise_round_entities') and combat_manager._surprise_round_entities:
                turn_text += "[Surprise Round]\n"
                current_actor_id_for_highlight = getattr(combat_manager, '_active_entity_id', None)
                for entity_id_in_surprise_order in combat_manager._surprise_round_entities:
                    if entity_id_in_surprise_order in combat_manager.entities:
                        entity = combat_manager.entities[entity_id_in_surprise_order]
                        prefix = "→ " if entity_id_in_surprise_order == current_actor_id_for_highlight else "  "
                        turn_text += f"{prefix}{getattr(entity, 'combat_name', entity.name)}\n"
            elif hasattr(combat_manager, 'turn_order') and combat_manager.turn_order: # Regular round
                current_turn_idx = getattr(combat_manager, 'current_turn_index', 0)
                for i, entity_id_in_order in enumerate(combat_manager.turn_order):
                    if entity_id_in_order in combat_manager.entities:
                        entity = combat_manager.entities[entity_id_in_order]
                        is_current_actor_by_index = (i == current_turn_idx)
                        prefix = "→ " if is_current_actor_by_index else "  "
                        turn_text += f"{prefix}{getattr(entity, 'combat_name', entity.name)}\n"
            else:
                turn_text = "Turn Order: Initializing..."
            self.turn_order_list.setText(turn_text.strip())

            player_id_for_initiative = getattr(character, 'id', None) or getattr(character, 'stats_manager_id', None)
            entity_for_initiative_display = combat_manager.entities.get(player_id_for_initiative)
            if entity_for_initiative_display and hasattr(entity_for_initiative_display, 'initiative'):
                initiative_value = getattr(entity_for_initiative_display, 'initiative', 0)
                self.initiative_value.setText(str(int(initiative_value)))
            else:
                self.initiative_value.setText("N/A")

    def _connect_stats_signal(self):
        """Connect to the stats_changed signal of the StatsManager."""
        if self._signal_connected:
            logging.debug("Signal already connected, skipping.")
            return

        try:
            if self.state_manager and self.state_manager.stats_manager:
                stats_manager = self.state_manager.stats_manager
                signal_exists = hasattr(stats_manager, 'stats_changed')

                if signal_exists:
                    try:
                        # Disconnect first to avoid duplicates if connection attempt repeats
                        stats_manager.stats_changed.disconnect(self._update_from_stats)
                    except (TypeError, RuntimeError): # Catch specific Qt signal errors
                        pass # Ignore if not connected

                    stats_manager.stats_changed.connect(self._update_from_stats)
                    self._signal_connected = True
                    logging.info("Connected CharacterSheetWidget to stats_changed signal")
            else:
                 logging.debug("StatsManager not yet available for signal connection.")

        except Exception as e:
            logging.error(f"Failed to connect to stats_changed signal: {e}")
    
    def _update_from_stats(self, stats_data):
        """Update the character sheet directly from stats data provided by the signal."""
        logging.info("Updating character sheet from stats_changed signal")

        try:
            # Provide detailed logging about the stats data received
            if isinstance(stats_data, dict):
                category_counts = {k: len(v) for k, v in stats_data.items() if isinstance(v, dict)}
                logging.info(f"Stats data categories from signal: {category_counts}")
                # ...(rest of logging as before)...

                # Check for empty or invalid stats before proceeding
                has_valid_stats = any(
                    category in stats_data and isinstance(stats_data[category], dict) and stats_data[category]
                    for category in ['primary', 'resources', 'combat', 'social', 'other']
                )

                if not has_valid_stats:
                    logging.warning("Stats data from signal appears empty or invalid.")
                    # Optionally, could trigger a full update here, but might cause loops
                    # self.update_character()
                    return

                # Update primary stats
                if 'primary' in stats_data:
                    self._update_primary_stats(stats_data['primary'])
                    logging.info(f"Updated {len(stats_data['primary'])} primary stats from signal")

                # Update derived stats including combat, social, other
                for category in ['combat', 'social', 'other']:
                    if category in stats_data:
                        self._update_derived_stats(stats_data[category], category)
                        logging.info(f"Updated {len(stats_data[category])} {category} stats from signal")

                # Update resource bars (HP, Mana, Stamina)
                if 'resources' in stats_data:
                    # Pass the full stats_data (which is all_stats) to _update_resources
                    self._update_resources(stats_data['resources'], all_player_stats=stats_data)
                    logging.info(f"Updated {len(stats_data['resources'])} resources from signal")
                
                # Update combat status (turn order, status effects) if player data is available
                if self.state_manager and self.state_manager.current_state and self.state_manager.current_state.player:
                    self._update_combat_status(self.state_manager.current_state.player)
                    logging.info("Updated combat status from stats_changed signal context.")
                else:
                    logging.warning("Could not update combat status from signal: player state unavailable.")


                logging.info("Character sheet updated directly from stats data via signal")
            else:
                # Fallback to full update if data format isn't as expected (less likely now)
                logging.warning(f"Stats data from signal is not a dict: {type(stats_data)}, falling back to full update")
                self.update_character() # Trigger full refresh as fallback

        except Exception as e:
            logging.error(f"Error updating from stats signal: {e}", exc_info=True)
            # Fallback to full update on error
            try:
                self.update_character()
            except Exception as update_err:
                logging.error(f"Fallback update after signal error also failed: {update_err}")
                
    def _update_primary_stats(self, primary_stats):
        """Update just the primary stats from stats data, showing colored deltas."""
        for stat_name, stat_data in primary_stats.items():
            # stat_name here is expected to be "STR", "DEX", etc.
            if stat_name in self.primary_stat_labels:
                try:
                    value = int(stat_data.get('value', 0))
                    base = int(stat_data.get('base_value', value))
                    delta = value - base
                    delta_sign = "+" if delta > 0 else ""
                    delta_color = "#69c45f" if delta > 0 else ("#c45f5f" if delta < 0 else "#E0E0E0")

                    # Compose HTML with colored delta
                    new_text = f"{value}"
                    if delta != 0:
                        new_text += f" <span style='color:{delta_color}'>({delta_sign}{delta})</span>"

                    old_text = self.primary_stat_labels[stat_name].text()
                    if old_text != new_text:
                        self.primary_stat_labels[stat_name].setText(new_text)
                        logging.info(f"Updated primary stat {stat_name} from '{old_text}' to '{new_text}'")

                    # Update tooltip data regardless
                    self.primary_stat_labels[stat_name].update_stat_data(stat_data)
                except Exception as e:
                    logging.error(f"Error updating primary stat {stat_name}: {e}", exc_info=True)
            else:
                logging.warning(f"Stat key '{stat_name}' from primary stats data not found in UI labels.")
    
    def _update_derived_stats(self, derived_stats, category):
        """Update derived stats from stats data, showing colored deltas."""
        for stat_name, stat_data in derived_stats.items():
            # stat_name here is expected to be "MELEE_ATTACK", "DEFENSE", etc.
            if stat_name in self.derived_stat_labels:
                try:
                    value = int(stat_data.get('value', 0))
                    base = int(stat_data.get('base_value', value))
                    delta = value - base
                    delta_sign = "+" if delta > 0 else ""
                    delta_color = "#69c45f" if delta > 0 else ("#c45f5f" if delta < 0 else "#E0E0E0")

                    new_text = f"{value}"
                    if delta != 0:
                        new_text += f" <span style='color:{delta_color}'>({delta_sign}{delta})</span>"

                    old_text = self.derived_stat_labels[stat_name].text()
                    if old_text != new_text:
                        self.derived_stat_labels[stat_name].setText(new_text)
                        logging.info(f"Updated {category} stat {stat_name} from '{old_text}' to '{new_text}'")

                    # Update tooltip data regardless
                    self.derived_stat_labels[stat_name].update_stat_data(stat_data)

                    # Special case for initiative display
                    if stat_name == "INITIATIVE":
                        if self.initiative_value.text() != str(value):
                            self.initiative_value.setText(str(value))
                            logging.info(f"Updated initiative display to {value}")
                except Exception as e:
                    logging.error(f"Error updating derived stat {stat_name}: {e}", exc_info=True)
            else:
                logging.warning(f"Stat key '{stat_name}' from {category} stats data not found in UI labels.")
    
    def _update_resources(self, resources: Dict[str, Any], all_player_stats: Optional[Dict[str, Any]] = None):
        """
        Update resource bars. During COMBAT, current values for HP, Mana, Stamina are primarily
        updated via orchestrated events (player_resource_bar_update_phaseX). This method will
        still update MAX values and, outside of combat, current values directly.
        """
        resource_key_map = {
            "HEALTH": "health", "MANA": "mana", "STAMINA": "stamina",
            "RESOLVE": "resolve" 
        }
        max_resource_map = {
            "HEALTH": "MAX_HEALTH", "MANA": "MAX_MANA", 
            "STAMINA": "MAX_STAMINA", "RESOLVE": "MAX_RESOLVE" 
        }

        for stat_name_key, resource_data in resources.items():
            ui_key = resource_key_map.get(stat_name_key.upper()) 

            if ui_key and ui_key in self.resource_bars:
                label, bar = self.resource_bars[ui_key]
                
                game_mode = InteractionMode.NARRATIVE # Default
                if self.state_manager and self.state_manager.current_state:
                    game_mode = self.state_manager.current_state.current_mode
                
                try:
                    current_value_from_model = int(resource_data.get('value', 0)) # Actual current value from stats model
                    max_stat_name_key = max_resource_map.get(stat_name_key.upper())
                    
                    # Determine Max Value (this should always reflect the true current max)
                    max_value_from_model = bar.maximum() if bar.maximum() > 0 else 100 
                    if all_player_stats and max_stat_name_key:
                        found_max_in_all_stats = False
                        for category_key in ['resources', 'other', 'primary', 'combat', 'social']: 
                            if category_key in all_player_stats and max_stat_name_key in all_player_stats[category_key]:
                                max_value_from_model = int(all_player_stats[category_key][max_stat_name_key].get('value', max_value_from_model))
                                found_max_in_all_stats = True
                                break
                        if not found_max_in_all_stats:
                           logger.warning(f"MAX stat {max_stat_name_key} not found in all_player_stats for {stat_name_key} in _update_resources. Using bar's current max.")
                    elif 'base_value' in resource_data and stat_name_key.upper().startswith("MAX_"): 
                         max_value_from_model = int(resource_data.get('base_value', max_value_from_model))
                    
                    max_value_from_model = max(1, max_value_from_model) 
                    display_name = resource_data.get("name", ui_key.capitalize()) 

                    # Always update the bar's range if the max value from model has changed
                    if bar.maximum() != max_value_from_model:
                        bar.setRange(0, max_value_from_model)
                        logger.info(f"CharacterSheet: {ui_key} bar max updated to {max_value_from_model} via _update_resources (model changed).")
                        # If max changed, the label will need updating too, unless an animation is active
                        if not (game_mode == InteractionMode.COMBAT and ui_key in self._pending_player_bar_updates):
                            current_display_val = bar.value() if game_mode == InteractionMode.COMBAT and ui_key in self._pending_player_bar_updates and self._pending_player_bar_updates[ui_key].get('phase1_preview_value') is not None else current_value_from_model
                            label.setText(f"{display_name}: {int(current_display_val)}/{max_value_from_model}")


                    # Handle current value updates
                    if game_mode == InteractionMode.COMBAT:
                        # In COMBAT, current value updates for HP, Mana, Stamina are driven by phase1/phase2 events.
                        # This method, when called by stats_changed, should not directly set the current value
                        # for these, to avoid conflicts with the animation.
                        # It only ensures MAX is correct. Resolve, if not animated, could be updated here.
                        if ui_key == "resolve": # Example: Resolve updates directly if not animated
                             if bar.value() != current_value_from_model: bar.setValue(current_value_from_model)
                             label.setText(f"{display_name}: {current_value_from_model}/{max_value_from_model}")
                        else:
                             logger.debug(f"CharacterSheet: In COMBAT, _update_resources deferring current value update for {ui_key} to orchestration.")
                             # If a phase1 animation is active, the label might show "X -> Y".
                             # If max_value changed, it's already updated above.
                             # If no animation is active, the label might be stale until phase1/2.
                             # Let's ensure label reflects at least the old value against new max if max changed.
                             if bar.maximum() == max_value_from_model and ui_key not in self._pending_player_bar_updates:
                                  current_on_bar = bar.value() # What the bar visually shows
                                  if label.text() != f"{display_name}: {int(current_on_bar)}/{max_value_from_model}":
                                       label.setText(f"{display_name}: {int(current_on_bar)}/{max_value_from_model}")


                    else: # Not in COMBAT mode, update directly
                        if bar.value() != current_value_from_model:
                            bar.setValue(current_value_from_model)
                        
                        new_text_direct = f"{display_name}: {current_value_from_model}/{max_value_from_model}"
                        if label.text() != new_text_direct:
                            label.setText(new_text_direct)
                        
                        # If there was any pending animation from a previous mode (unlikely but possible), clear it.
                        if ui_key in self._pending_player_bar_updates:
                            self._pending_player_bar_updates.pop(ui_key, None)
                        
                        logger.debug(f"CharacterSheet: Directly updated {ui_key} to {current_value_from_model}/{max_value_from_model} via _update_resources (not in combat).")
                    
                except Exception as e:
                    logging.error(f"CharacterSheet: Error updating resource bar for {stat_name_key} in _update_resources: {e}", exc_info=True)
            elif ui_key:
                logging.warning(f"UI key '{ui_key}' (from resource '{stat_name_key}') not found in self.resource_bars.")

    def _clear_stat_displays(self):
        """Helper method to reset all stat displays to default/empty."""
        logging.debug("Clearing character sheet stat displays.")
        # Clear primary stats
        for label in self.primary_stat_labels.values():
            label.setText("0") # Or "?" or ""
            label.update_stat_data({}) # Clear tooltip data

        # Clear derived stats
        for label in self.derived_stat_labels.values():
            label.setText("0") # Or "?" or ""
            label.update_stat_data({}) # Clear tooltip data

        # Clear resource bars
        for label, bar in self.resource_bars.values():
            label.setText(f"{label.text().split(':')[0]}: 0/0") # Keep name, reset values
            bar.setRange(0, 100) # Reset range
            bar.setValue(0) # Reset value

        # Clear initiative display
        self.initiative_value.setText("0")

        # Clear combat status
        self.status_effects_list.clear()
        self.turn_order_list.clear()
    
    def showEvent(self, event):
        """Handler called when widget is shown."""
        super().showEvent(event)

    @Slot(str, dict)
    def animate_resource_bar_ui_bar_update_phase1(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a bar update: show impending loss/gain.
        bar_type_key: "hp", "stamina", "mana", "resolve"
        update_data: { "old_value": X, "new_value_preview": Y, "max_value": M }
        """
        bar_type_key_internal = bar_type_key
        if bar_type_key == "hp": # Normalize "hp" to "health" for internal lookup
            bar_type_key_internal = "health"
        
        if bar_type_key_internal not in self.resource_bars:
            logging.warning(f"CharacterSheet: Bar type '{bar_type_key_internal}' (from original key '{bar_type_key}') not found for phase 1 animation.")
            return

        label, bar = self.resource_bars[bar_type_key_internal]
        new_value_preview = update_data.get("new_value_preview")
        max_value = update_data.get("max_value")
        
        if new_value_preview is None or max_value is None:
            logging.error(f"CharacterSheet: Missing new_value_preview or max_value for phase 1 of {bar_type_key_internal}")
            return
            
        is_loss = new_value_preview < bar.value()

        logging.debug(f"CharacterSheet: Phase 1 Anim for {bar_type_key_internal} - Preview: {new_value_preview}/{max_value}")

        display_name = label.text().split(':')[0] 
        label.setText(f"{display_name}: {bar.value()}/{max_value} -> {new_value_preview}/{max_value}")
        
        self._pending_bar_updates[bar_type_key_internal] = {
            "final_value": new_value_preview,
            "max_value": max_value,
            "is_loss": is_loss
        }

    @Slot(str, dict)
    def animate_resource_bar_ui_bar_update_phase2(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a bar update: finalize the bar to its new value.
        bar_type_key: "hp", "stamina", "mana", "resolve"
        update_data: { "final_new_value": Y, "max_value": M } (or use stored from pending)
        """
        bar_type_key_internal = bar_type_key
        if bar_type_key == "hp": # Normalize "hp" to "health" for internal lookup
            bar_type_key_internal = "health"

        if bar_type_key_internal not in self.resource_bars:
            logging.warning(f"CharacterSheet: Bar type '{bar_type_key_internal}' (from original key '{bar_type_key}') not found for phase 2 animation.")
            return
        
        pending_data = self._pending_bar_updates.pop(bar_type_key_internal, None)
        final_value = update_data.get("final_new_value", pending_data.get("final_value") if pending_data else None)
        max_value = update_data.get("max_value", pending_data.get("max_value") if pending_data else None)

        if final_value is None or max_value is None:
            # Attempt to get current value from bar if update_data is incomplete and no pending_data
            label_fallback, bar_fallback = self.resource_bars[bar_type_key_internal]
            final_value_fb = bar_fallback.value()
            max_value_fb = bar_fallback.maximum()

            if final_value is None: final_value = final_value_fb
            if max_value is None: max_value = max_value_fb
            
            logging.warning(f"CharacterSheet: Missing final_value or max_value for phase 2 of {bar_type_key_internal}. Using current/fallback: {final_value}/{max_value}")
            # Do not return; attempt to update with best available info.

        logging.debug(f"CharacterSheet: Phase 2 Anim for {bar_type_key_internal} - Final: {final_value}/{max_value}")

        label, bar = self.resource_bars[bar_type_key_internal]
        # Try to get original name part, handle cases where "->" might not be present
        original_name_part_match = re.match(r"([^:]+):", label.text())
        display_name = original_name_part_match.group(1).strip() if original_name_part_match else bar_type_key_internal.capitalize()


        label.setText(f"{display_name}: {int(final_value)}/{int(max_value)}")
        if bar.maximum() != int(max_value):
            bar.setRange(0, int(max_value))
        bar.setValue(int(final_value))

        logging.debug(f"CharacterSheet: {bar_type_key_internal} bar finalized to {int(final_value)}/{int(max_value)}")

    def _finalize_bar_animation(self, bar_type_key: str):
        """Helper to finalize a bar after a QTimer, if used internally (less common now)."""
        # This method is less likely to be used if Orchestrator handles delays.
        # Kept for potential future internal animation needs.
        if bar_type_key in self._pending_bar_updates:
            data = self._pending_bar_updates.pop(bar_type_key)
            self.animate_resource_bar_ui_bar_update_phase2(bar_type_key, {"final_new_value": data["final_value"], "max_value": data["max_value"]})

    @Slot(dict)
    def handle_turn_order_update(self, event_data: Dict[str, Any]):
        """
        Handles TURN_ORDER_UPDATE events from the orchestrator to update
        the turn order display and player initiative.
        """
        logger.info(f"CharacterSheet received TURN_ORDER_UPDATE: {event_data}")
        self._last_turn_order_event_data = event_data # Store for fallback if needed

        turn_text = ""
        is_surprise = event_data.get("is_surprise", False)
        round_num = event_data.get("round_number", "")
        turn_order_display_list = event_data.get("turn_order_display_list", []) # This should contain pre-formatted strings with "→"
        active_entity_name = event_data.get("active_entity_combat_name", "") # For initiative context

        if is_surprise:
            turn_text += f"[Surprise Round]\n"
        elif round_num:
            turn_text += f"Round {round_num}\n"
        
        if turn_order_display_list:
            turn_text += "\n".join(turn_order_display_list)
        else:
            turn_text += "Turn order not yet determined."

        self.turn_order_list.setText(turn_text.strip())

        # Update player's initiative display
        # If player is in the turn_order_display_list, try to extract their initiative
        # This assumes player's combat name is consistent
        player_id = getattr(self.state_manager.current_state.player, 'id', None) or getattr(self.state_manager.current_state.player, 'stats_manager_id', None)
        player_combat_name = getattr(self.state_manager.current_state.player, 'name', "Player") # Fallback
        
        # Get CombatManager to access player's CombatEntity for initiative
        combat_manager = getattr(self.state_manager.current_state, 'combat_manager', None)
        if combat_manager and player_id:
            player_combat_entity = combat_manager.entities.get(player_id)
            if player_combat_entity and hasattr(player_combat_entity, 'initiative'):
                self.initiative_value.setText(str(int(player_combat_entity.initiative)))
            else:
                self.initiative_value.setText("N/A")
        elif combat_manager: # Player ID not found, but CM exists
             self.initiative_value.setText("N/A (Player not in combat)")
        else: # Not in combat
            self.initiative_value.setText("0")

    @Slot(str, dict)
    def player_resource_bar_update_phase1(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a player's resource bar update: show impending loss/gain in label.
        bar_type_key: "hp", "stamina", "mana", "resolve" (from event metadata)
        update_data: { "old_value": X, "new_value_preview": Y, "max_value": M, "entity_id": player_id }
        """
        logger.debug(f"CharacterSheet: Player Phase 1 Anim for event bar_type '{bar_type_key}' - Data: {update_data}")
        
        event_to_internal_key_map = {"hp": "health", "mp": "mana", "stamina": "stamina", "resolve": "resolve"}
        internal_ui_key = event_to_internal_key_map.get(bar_type_key.lower(), bar_type_key.lower())

        if internal_ui_key not in self.resource_bars:
            logging.warning(f"CharacterSheet: Player bar type '{internal_ui_key}' (mapped from event '{bar_type_key}') not found for phase 1 animation.")
            return

        label, bar = self.resource_bars[internal_ui_key]
        
        new_value_preview = update_data.get("new_value_preview")
        max_value = update_data.get("max_value")
        
        if new_value_preview is None or max_value is None:
            logging.error(f"CharacterSheet: Missing new_value_preview or max_value for player phase 1 of {internal_ui_key}")
            return
        
        current_bar_visual_value = bar.value() 
        
        display_name_match = re.match(r"([^:]+):", label.text())
        display_name = display_name_match.group(1).strip() if display_name_match else internal_ui_key.capitalize()
        
        label.setText(f"{display_name}: {int(current_bar_visual_value)}/{int(max_value)} -> {int(new_value_preview)}/{int(max_value)}")
        
        if bar.maximum() != int(max_value):
            bar.setRange(0, int(max_value))
            logger.info(f"CharacterSheet (Phase1): {internal_ui_key} bar max updated to {max_value}")

        self._pending_player_bar_updates[internal_ui_key] = {
            "final_value": new_value_preview, 
            "max_value": max_value,
            "phase1_preview_value": current_bar_visual_value 
        }

        # Signal orchestrator completion to avoid stalls when no CombatEntityWidget animation handles it
        try:
            from core.base.engine import get_game_engine
            from PySide6.QtCore import QTimer
            eng = get_game_engine()
            if eng and hasattr(eng, "_combat_orchestrator"):
                logger.debug("CharacterSheet: Signaling orchestrator visual completion for Phase 1 player bar update")
                QTimer.singleShot(0, eng._combat_orchestrator._handle_visual_display_complete)
        except Exception:
            pass

    @Slot(str, dict)
    def player_resource_bar_update_phase2(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a player's resource bar update: finalize the bar to its new value.
        bar_type_key: "hp", "stamina", "mana", "resolve" (from event metadata)
        update_data: { "final_new_value": Y, "max_value": M, "entity_id": player_id }
        """
        event_to_internal_key_map = {"hp": "health", "mp": "mana", "stamina": "stamina", "resolve": "resolve"}
        internal_ui_key = event_to_internal_key_map.get(bar_type_key.lower(), bar_type_key.lower())

        logger.debug(f"CharacterSheet: Player Phase 2 Anim for internal_ui_key '{internal_ui_key}' (from event '{bar_type_key}') - Data: {update_data}")

        if internal_ui_key not in self.resource_bars:
            logging.warning(f"CharacterSheet: Player bar type '{internal_ui_key}' (mapped from event '{bar_type_key}') not found for phase 2 animation.")
            if internal_ui_key in self._pending_player_bar_updates:
                self._pending_player_bar_updates.pop(internal_ui_key, None)
            return
        
        pending_data = self._pending_player_bar_updates.pop(internal_ui_key, None)
        
        label, bar = self.resource_bars[internal_ui_key]

        final_value = update_data.get("final_new_value")
        max_val = update_data.get("max_value")

        if final_value is None:
            if pending_data and "final_value" in pending_data:
                final_value = pending_data["final_value"]
            else: 
                final_value = bar.value() 
                logger.warning(f"CharacterSheet (Phase2): for {internal_ui_key} missing final_new_value. Using current bar value {final_value}.")
        
        if max_val is None:
            if pending_data and "max_value" in pending_data:
                max_val = pending_data["max_value"]
            else: 
                max_val = bar.maximum()
                logger.warning(f"CharacterSheet (Phase2): for {internal_ui_key} missing max_value. Using current bar max {max_val}.")
        
        final_value = int(final_value)
        max_val = int(max_val)
        max_val = max(1, max_val)

        current_label_text = label.text()
        display_name_match = re.match(r"([^:]+):", current_label_text)
        display_name = display_name_match.group(1).strip() if display_name_match else internal_ui_key.capitalize()

        label.setText(f"{display_name}: {final_value}/{max_val}")
        if bar.maximum() != max_val: 
            bar.setRange(0, max_val)
        bar.setValue(final_value)

        logger.debug(f"CharacterSheet: Player {internal_ui_key} bar finalized to {final_value}/{max_val}")
        logging.info(f"CharacterSheet (Phase2 player): set {internal_ui_key} to {final_value}/{max_val}")

        # Signal orchestrator completion to avoid stalls when CharacterSheet handles the update without a CombatEntityWidget animation
        try:
            from core.base.engine import get_game_engine
            from PySide6.QtCore import QTimer
            eng = get_game_engine()
            if eng and hasattr(eng, "_combat_orchestrator"):
                logger.debug("CharacterSheet: Signaling orchestrator visual completion for Phase 2 player bar update")
                QTimer.singleShot(0, eng._combat_orchestrator._handle_visual_display_complete)
        except Exception:
            pass

    @Slot(QPoint, EquipmentSlot, str)
    def _handle_equipped_item_context_menu(self, global_pos: QPoint, slot: EquipmentSlot, item_id: str):
        inventory_manager = get_inventory_manager()
        item_obj = inventory_manager.get_item(item_id)
        if not item_obj:
            logger.error(f"[CHAR_SHEET_CTX] Item ID {item_id} not found for context menu in slot {slot.value}.")
            return

        logger.info(f"[CHAR_SHEET_CTX] Context menu for equipped item: '{item_obj.name}' in slot {slot.value}")

        context_menu = QMenu(self)
        # Apply styling similar to InventoryPanelWidget's context menu
        context_menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30; /* Dark background */
                color: #E0E0E0; /* Light text */
                border: 1px solid #555555; /* Subtle border */
                padding: 2px; /* Padding around all items */
            }
            QMenu::item {
                padding: 5px 20px 5px 20px; /* Top, Right, Bottom, Left padding */
                border: 1px solid transparent; /* Spacing between items */
            }
            QMenu::item:selected {
                background-color: #0E639C; /* Selection color */
                color: #FFFFFF;
            }
            QMenu::separator {
                height: 1px;
                background: #555555;
                margin-left: 10px;
                margin-right: 5px;
            }
        """)

        unequip_action = context_menu.addAction(f"Unequip {item_obj.name}")
        info_action = context_menu.addAction("Item Information")
        drop_action = context_menu.addAction(f"Drop {item_obj.name}")
        
        action = context_menu.exec_(global_pos)

        if action == unequip_action:
            self.item_unequip_from_slot_requested.emit(slot)
        elif action == info_action:
            self.item_examine_requested.emit(item_id)
        elif action == drop_action:
            self.item_drop_from_slot_requested.emit(slot, item_id)
            
    class EquippedItemLabel(QLabel):
        context_menu_requested_for_slot = Signal(QPoint, EquipmentSlot, str) # Global pos, slot, item_id

        def __init__(self, text: str, slot: EquipmentSlot, item_id: Optional[str] = None, parent: Optional[QWidget] = None):
            super().__init__(text, parent)
            self.slot = slot
            self.item_id = item_id
            self.setContextMenuPolicy(Qt.CustomContextMenu)
            self.customContextMenuRequested.connect(self.show_context_menu_slot)

        def set_item_data(self, text: str, item_id: Optional[str]):
            self.setText(text)
            self.item_id = item_id
            if item_id:
                self.setCursor(Qt.PointingHandCursor)
                self.setStyleSheet("color: #E0E0E0;") # Normal color for equipped item
            else:
                self.setCursor(Qt.ArrowCursor)
                self.setStyleSheet("color: #888888; font-style: italic;") # Dim for "None"

        def show_context_menu_slot(self, position: QPoint):
            if self.item_id: # Only show menu if an item is equipped
                self.context_menu_requested_for_slot.emit(self.mapToGlobal(position), self.slot, self.item_id)
        
        # Optional: Make left-click also trigger "Item Information" if desired
        # def mousePressEvent(self, event: QMouseEvent) -> None:
        #     if event.button() == Qt.LeftButton and self.item_id:
        #         # Potentially emit a signal for MainWindow to show ItemInfoDialog
        #         # For now, focusing on context menu for actions.
        #         pass
        #     super().mousePressEvent(event)
```

### File: gui\components\combat_display.py

```python
#!/usr/bin/env python3
"""
Combat display component for the RPG game.

This module provides a GUI component for displaying combat status and log,
with customizable appearance settings.
"""

import json
import logging
import os
import re # Added for stylesheet manipulation
from typing import Dict, Iterator, List, Any, Optional, Callable, Tuple
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit,
    QGroupBox, QProgressBar, QScrollArea, QFrame, QSizePolicy, QPushButton,
    QDialog # Added for placeholder dialog
)
from PySide6.QtCore import QSettings, Signal, Slot, QTimer
from PySide6.QtGui import QColor, QTextCharFormat, QFont, QTextCursor, QFontDatabase

from core.base.engine import get_game_engine
from core.interaction.enums import InteractionMode # Added QFontDatabase
from ..dialogs.combat_settings_dialog import CombatSettingsDialog

# Assuming core is in the parent directory of gui
# Adjust if your project structure is different
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))

# Configuration Constants - Adjusted paths based on project structure
CONFIG_DIR = os.path.join(project_root, "config")
SETTINGS_FILE = os.path.join(CONFIG_DIR, "combat_display_settings.json")
IMAGE_DIR = os.path.join(project_root, "images", "gui", "combat_display") # Path to background images

# Ensure directories exist
os.makedirs(CONFIG_DIR, exist_ok=True)
os.makedirs(IMAGE_DIR, exist_ok=True) # Create image dir if it doesn't exist

# Import after defining project_root if necessary for other modules
from core.utils.logging_config import get_logger
from core.combat.enums import CombatState
from core.combat.combat_entity import EntityType
from core.stats.stats_base import DerivedStatType
from core.base.state import GameState
from core.stats.stats_manager import get_stats_manager

# Get the module logger
logger = get_logger("GUI")

class CombatEntityWidget(QWidget):
    """Widget for displaying a combat entity status."""

    def __init__(self, entity_id: str, name: str, settings: dict, is_player: bool = False, parent=None):
        """Initialize the combat entity widget."""
        super().__init__(parent)

        self.entity_id = entity_id
        self.is_player = is_player
        self.settings = settings

        self._bar_animation_timer = QTimer(self)
        self._bar_animation_timer.setSingleShot(True)
        self._bar_animation_timer.timeout.connect(self._finalize_bar_update)
        self._pending_bar_update_data: Optional[Dict[str, Any]] = None


        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(2)

        self.name_label = QLabel(name)
        layout.addWidget(self.name_label)

        # HP Bar
        self.hp_widget_container = QWidget() # Container for HP bar and label
        hp_layout = QHBoxLayout(self.hp_widget_container)
        hp_layout.setContentsMargins(0, 0, 0, 0); hp_layout.setSpacing(5)
        self.hp_bar = QProgressBar()
        self.hp_bar.setRange(0, 100); self.hp_bar.setValue(100) 
        self.hp_bar.setTextVisible(True); self.hp_bar.setFormat("%v / %m")
        self.hp_label = QLabel("HP:")
        hp_layout.addWidget(self.hp_label); hp_layout.addWidget(self.hp_bar)
        layout.addWidget(self.hp_widget_container) # Add container to main layout

        # Stamina Bar
        self.stamina_widget_container = QWidget() # Container for stamina bar and label
        stamina_layout = QHBoxLayout(self.stamina_widget_container)
        stamina_layout.setContentsMargins(0, 0, 0, 0); stamina_layout.setSpacing(5)
        self.stamina_bar = QProgressBar() 
        self.stamina_bar.setRange(0, 100); self.stamina_bar.setValue(100) 
        self.stamina_bar.setTextVisible(True); self.stamina_bar.setFormat("%v / %m")
        self.stamina_label = QLabel("Stamina:") 
        stamina_layout.addWidget(self.stamina_label); stamina_layout.addWidget(self.stamina_bar)
        layout.addWidget(self.stamina_widget_container) # Add container to main layout

        # Mana Bar 
        self.mana_widget_container = QWidget() # Container for mana bar and label
        mana_layout = QHBoxLayout(self.mana_widget_container) 
        mana_layout.setContentsMargins(0, 0, 0, 0); mana_layout.setSpacing(5)
        self.mana_bar = QProgressBar()
        self.mana_bar.setRange(0, 1); self.mana_bar.setValue(0) # Default to 0/1
        self.mana_bar.setTextVisible(True); self.mana_bar.setFormat("%v / %m")
        self.mana_label = QLabel("Mana:")
        mana_layout.addWidget(self.mana_label); mana_layout.addWidget(self.mana_bar)
        layout.addWidget(self.mana_widget_container) # Add container to main layout

        # Status Effects
        self.status_widget_container = QWidget() # Container for status label and text
        status_layout = QHBoxLayout(self.status_widget_container)
        status_layout.setContentsMargins(0, 0, 0, 0); status_layout.setSpacing(5)
        self.status_label_title = QLabel("Status:")
        status_layout.addWidget(self.status_label_title)
        self.status_text = QLabel("") 
        status_layout.addWidget(self.status_text); status_layout.addStretch()
        layout.addWidget(self.status_widget_container) # Add container to main layout

        self.setMinimumHeight(110) 
        self.setMinimumWidth(250 if is_player else 200)
        self.update_style(self.settings)

    def update_stats(self, current_hp: int, max_hp: int,
                    current_stamina: int, max_stamina: int,
                    status_effects: Optional[List[str]] = None,
                    current_mana: Optional[int] = None, max_mana: Optional[int] = None):
        """Update the entity stats display. This is now the final update (Phase 2)."""
        
        old_hp = self.hp_bar.value()
        # Ensure HP bar is always visible if HP stat is relevant
        self.hp_widget_container.setVisible(True) # Make container visible
        self.hp_bar.setRange(0, max_hp if max_hp > 0 else 1) 
        self.hp_bar.setValue(current_hp)
        self.hp_bar.setFormat(f"{current_hp} / {max_hp}")
        self._update_hp_bar_color(current_hp, max_hp) 

        if old_hp != current_hp:
            logger.debug(f"EntityWidget {self.entity_id} HP directly updated to {current_hp}/{max_hp}")

        old_stamina = self.stamina_bar.value()
        if max_stamina > 0:
            self.stamina_widget_container.setVisible(True) # Make container visible
            self.stamina_bar.setRange(0, max_stamina)
            self.stamina_bar.setValue(current_stamina)
            self.stamina_bar.setFormat(f"{current_stamina} / {max_stamina}")
        else: 
            self.stamina_widget_container.setVisible(False) # Hide whole container
        
        if old_stamina != current_stamina:
            logger.debug(f"EntityWidget {self.entity_id} Stamina directly updated to {current_stamina}/{max_stamina}")

        if current_mana is not None and max_mana is not None:
            old_mana = self.mana_bar.value()
            if max_mana > 0:
                self.mana_widget_container.setVisible(True) # Make container visible
                self.mana_bar.setRange(0, max_mana)
                self.mana_bar.setValue(current_mana)
                self.mana_bar.setFormat(f"{current_mana} / {max_mana}")
            else: 
                self.mana_widget_container.setVisible(False) # Hide whole container
            
            if old_mana != current_mana:
                logger.debug(f"EntityWidget {self.entity_id} Mana directly updated to {current_mana}/{max_mana}")
        else: 
            self.mana_widget_container.setVisible(False) # Hide container if no mana data

        if status_effects:
            self.status_widget_container.setVisible(True) # Make container visible
            self.status_text.setText(", ".join(status_effects))
        else:
            self.status_widget_container.setVisible(True) # Still show "Status: None"
            self.status_text.setText("None")

    def _update_hp_bar_color(self, current_hp: int, max_hp: int):
        """Helper method to update HP bar color based on settings."""
        hp_percent = (current_hp / max_hp) * 100 if max_hp > 0 else 0
        style_sheet = self.hp_bar.styleSheet() # Get current base style
        chunk_style = ""

        # Use settings for colors
        critical_color = self.settings.get("color_hp_bar_chunk_critical", "#990000")
        low_color = self.settings.get("color_hp_bar_chunk_low", "#cc0000")
        normal_color = self.settings.get("color_hp_bar_chunk_normal", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)")

        if hp_percent < self.settings.get("hp_threshold_critical", 25): # Make threshold configurable? (Future idea)
            chunk_color = critical_color
        elif hp_percent < self.settings.get("hp_threshold_low", 50): # Make threshold configurable? (Future idea)
            chunk_color = low_color
        else:
            chunk_color = normal_color

        chunk_style = f"background-color: {chunk_color};"

        # Find and replace the chunk part of the stylesheet
        # This assumes the base style is set correctly in update_style
        new_style_sheet = re.sub(r"(QProgressBar::chunk\s*{)[^}]*(})",
                                 r"\1 " + chunk_style + r" \2",
                                 style_sheet, count=1, flags=re.IGNORECASE | re.DOTALL)

        if new_style_sheet != style_sheet: # Apply only if changed
            self.hp_bar.setStyleSheet(new_style_sheet)

    def setFrameStyle(self, active=False):
        """Set the frame style based on entity type, active state, and settings."""
        if self.is_player:
            if active:
                bg_color = self.settings.get("color_entity_player_bg_active", "rgba(200, 220, 255, 80)")
                border_color = self.settings.get("color_entity_player_border_active", "#00aaff")
                border_width = 3
            else:
                bg_color = self.settings.get("color_entity_player_bg", "rgba(200, 220, 255, 30)")
                border_color = self.settings.get("color_entity_player_border", "#0077cc")
                border_width = 2
        else: # Enemy
            if active:
                bg_color = self.settings.get("color_entity_enemy_bg_active", "rgba(255, 200, 200, 80)")
                border_color = self.settings.get("color_entity_enemy_border_active", "#ff5500")
                border_width = 3
            else:
                bg_color = self.settings.get("color_entity_enemy_bg", "rgba(255, 200, 200, 30)")
                border_color = self.settings.get("color_entity_enemy_border", "#cc0000")
                border_width = 2

        explicit_text_color = self.settings.get("color_groupbox_title_text", "#FFFFFF")

        self.setStyleSheet(f"""
            CombatEntityWidget {{
                border: {border_width}px solid {border_color};
                border-radius: 5px;
                background-color: {bg_color};
                /* color: {explicit_text_color}; */ /* Removing this default color for the widget itself */
            }}
            /* QLabel styling will be handled in update_style or by direct application */
        """)
        
        self.name_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.hp_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.stamina_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.status_label_title.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.status_text.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")

    def highlight_active(self, active: bool = True):
        """Highlight the entity if it's their turn, using settings."""
        self.setFrameStyle(active=active)

    def update_style(self, settings: dict):
        """Update the widget's style based on the provided settings."""
        self.settings = settings
        # is_active_currently = False # Not needed here, setFrameStyle handles active state

        base_font_family = self.settings.get("font_family", "Arial")
        base_font_size = self.settings.get("font_size", 10)

        label_text_color = self.settings.get("color_groupbox_title_text", "#FFFFFF")

        name_font = QFont(base_font_family, base_font_size)
        name_font.setBold(True)
        if self.is_player: name_font.setPointSize(base_font_size + self.settings.get("font_size_player_name_offset", 1))
        self.name_label.setFont(name_font)
        self.name_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")


        base_font = QFont(base_font_family, base_font_size)
        self.hp_label.setFont(base_font)
        self.hp_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.stamina_label.setFont(base_font) 
        self.stamina_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")
        
        self.mana_label.setFont(base_font) 
        self.mana_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.status_label_title.setFont(base_font)
        self.status_label_title.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.status_text.setFont(base_font)
        self.status_text.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        hp_chunk_normal = self.settings.get("color_hp_bar_chunk_normal", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)")
        stamina_chunk = self.settings.get("color_stamina_bar_chunk", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #66CC33, stop:1 #44AA22)")
        mana_chunk = self.settings.get("color_mana_bar_chunk", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #3366CC, stop:1 #2244AA)") 
        pb_text_color = self.settings.get("color_progressbar_text", "#FFFFFF") 
        pb_bg_color = self.settings.get("color_progressbar_bg", "#555555") 

        pb_base_style = f"""
            QProgressBar {{
                border: 1px solid #444; border-radius: 3px; text-align: center;
                height: 18px; color: {pb_text_color}; background-color: {pb_bg_color};
            }}
        """
        self.hp_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {hp_chunk_normal}; }}")
        self.stamina_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {stamina_chunk}; }}")
        self.mana_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {mana_chunk}; }}") 

        self.setFrameStyle(active=False) # Apply default inactive frame style

        current_hp = self.hp_bar.value(); max_hp = self.hp_bar.maximum()
        self._update_hp_bar_color(current_hp, max_hp)
        self.update()
        
    @Slot(dict)
    def animate_ui_bar_update_phase1(self, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a bar update: show impending loss.
        update_data: { "bar_type": "hp"|"stamina"|"mana", "old_value": X, "new_value_preview": Y, "max_value": M }
        """
        bar_type = update_data.get("bar_type")
        new_value_preview = update_data.get("new_value_preview") 
        max_value = update_data.get("max_value")

        logger.debug(f"EntityWidget {self.entity_id} PHASE 1 ANIM: {bar_type} to preview {new_value_preview}/{max_value}")

        target_bar = None
        original_stylesheet = ""
        bleak_color_key_suffix = "_bleak" # e.g. color_hp_bar_chunk_normal_bleak

        if bar_type == "hp": 
            target_bar = self.hp_bar
            hp_percent_preview = (new_value_preview / max_value) * 100 if max_value > 0 else 0
            if hp_percent_preview < self.settings.get("hp_threshold_critical", 25): bleak_color_key = "color_hp_bar_chunk_critical" + bleak_color_key_suffix
            elif hp_percent_preview < self.settings.get("hp_threshold_low", 50): bleak_color_key = "color_hp_bar_chunk_low" + bleak_color_key_suffix
            else: bleak_color_key = "color_hp_bar_chunk_normal" + bleak_color_key_suffix
        elif bar_type == "stamina": 
            target_bar = self.stamina_bar
            bleak_color_key = "color_stamina_bar_chunk" + bleak_color_key_suffix
        elif bar_type == "mana": # NEW for Mana
            target_bar = self.mana_bar
            bleak_color_key = "color_mana_bar_chunk" + bleak_color_key_suffix # Assuming similar setting key
        else:
            logger.warning(f"EntityWidget {self.entity_id}: Unknown bar_type '{bar_type}' for phase 1 animation.")
            if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'): # Ensure orchestrator can proceed
                QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
            return

        if target_bar and new_value_preview is not None and max_value is not None:
            original_stylesheet = target_bar.styleSheet() # Store current full stylesheet
            
            bleak_color = self.settings.get(bleak_color_key, "#777777A0") # Default semi-transparent gray

            new_chunk_style = f"background-color: {bleak_color};"
            # Replace only the background-color of the chunk part
            updated_stylesheet = re.sub(r"(QProgressBar::chunk\s*{\s*background-color:\s*)[^;]+(;[^}]*})",
                                        rf"\1{bleak_color}\2",
                                        original_stylesheet, count=1, flags=re.IGNORECASE | re.DOTALL)
            if not re.search(r"QProgressBar::chunk\s*{", updated_stylesheet, re.IGNORECASE): # If no chunk style existed
                base_pb_style = re.match(r"(QProgressBar\s*{[^}]*})", original_stylesheet, re.IGNORECASE | re.DOTALL)
                if base_pb_style:
                    updated_stylesheet = base_pb_style.group(1) + f" QProgressBar::chunk {{ {new_chunk_style} }}"
                else: # Fallback: just append
                    updated_stylesheet = original_stylesheet + f" QProgressBar::chunk {{ {new_chunk_style} }}"


            target_bar.setStyleSheet(updated_stylesheet)
            target_bar.setFormat(f"{new_value_preview} / {max_value} (...)") # Indicate change

            self._pending_bar_update_data = {
                "bar_type": bar_type,
                "final_value": new_value_preview, # This is preview, Phase2 will get actual final
                "max_value": max_value,
                "original_stylesheet": original_stylesheet 
            }
        else:
            logger.warning(f"Could not animate phase 1 for {self.entity_id}, bar_type: {bar_type}, data: {update_data}")

        # Visual update is considered complete for Phase 1 after style is set.
        if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
            QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
    @Slot(dict)
    def animate_ui_bar_update_phase2(self, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a bar update: finalize the bar to its new value.
        update_data: { "bar_type": "hp"|"stamina"|"mana", "final_new_value": Y, "max_value": M }
        """
        bar_type = update_data.get("bar_type")
        final_value = update_data.get("final_new_value")
        max_value = update_data.get("max_value")
        
        logger.debug(f"EntityWidget {self.entity_id} PHASE 2 ANIM: {bar_type} to final {final_value}/{max_value}")

        target_bar = None
        if bar_type == "hp": target_bar = self.hp_bar
        elif bar_type == "stamina": target_bar = self.stamina_bar
        elif bar_type == "mana": target_bar = self.mana_bar # NEW for Mana
        else:
            logger.warning(f"EntityWidget {self.entity_id}: Unknown bar_type '{bar_type}' for phase 2 animation.")
            if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
                QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
            return

        if target_bar and final_value is not None and max_value is not None:
            # Restore original base stylesheet if it was stored and modified for bleak color
            if self._pending_bar_update_data and self._pending_bar_update_data.get("bar_type") == bar_type:
                original_style = self._pending_bar_update_data.get("original_stylesheet")
                if original_style:
                    target_bar.setStyleSheet(original_style) # Restore base before applying final color logic
            
            # Call update_stats to set value and apply final color logic
            # Need to fetch other stats if update_stats requires all of them
            # For simplicity, assuming update_stats can handle partial updates or we reconstruct args
            if bar_type == "hp":
                self.update_stats(final_value, max_value, self.stamina_bar.value(), self.stamina_bar.maximum(), current_mana=self.mana_bar.value(), max_mana=self.mana_bar.maximum())
            elif bar_type == "stamina":
                self.update_stats(self.hp_bar.value(), self.hp_bar.maximum(), final_value, max_value, current_mana=self.mana_bar.value(), max_mana=self.mana_bar.maximum())
            elif bar_type == "mana": # NEW for Mana
                self.update_stats(self.hp_bar.value(), self.hp_bar.maximum(), self.stamina_bar.value(), self.stamina_bar.maximum(), current_mana=final_value, max_mana=max_value)

            
            target_bar.setFormat(f"{final_value} / {max_value}") # Ensure format is correct
            logger.debug(f"EntityWidget {self.entity_id} {bar_type} bar finalized to {final_value}/{max_value}")
        else:
            logger.warning(f"Could not animate phase 2 for {self.entity_id}, bar_type: {bar_type}, data: {update_data}")
            
        self._pending_bar_update_data = None 
        
        if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
            QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)

    @Slot()
    def _finalize_bar_update(self):
        """Actually updates the bar value and color after the delay (Old method, for reference if needed)."""
        # This method is less used now as Orchestrator controls delays and Phase 2 trigger.
        # Kept for potential direct use or if animation needs its own timer.
        if self._pending_bar_update_data:
            bar_type = self._pending_bar_update_data["bar_type"]
            final_value = self._pending_bar_update_data["final_value"]
            max_value = self._pending_bar_update_data["max_value"]
            # original_stylesheet = self._pending_bar_update_data["original_stylesheet"] # Not used if update_stats handles colors

            target_bar = None
            if bar_type == "hp": target_bar = self.hp_bar
            elif bar_type == "stamina": target_bar = self.stamina_bar

            if target_bar:
                # target_bar.setStyleSheet(original_stylesheet) # Restore base if needed
                target_bar.setValue(final_value)
                target_bar.setFormat(f"{final_value} / {max_value}")
                if bar_type == "hp": self._update_hp_bar_color(final_value, max_value)
                # Add similar for stamina if it has dynamic coloring

            self._pending_bar_update_data = None

class CombatDisplay(QWidget):
    """Widget for displaying combat status and log."""

    # --- ECFA Change: Add visualDisplayComplete signal ---
    visualDisplayComplete = Signal()
    # --- End ECFA Change ---

    def __init__(self, parent=None):
        """Initialize the combat display widget."""
        super().__init__(parent)

        self.setObjectName("combatDisplayWidget")

        self.entity_widgets: Dict[str, CombatEntityWidget] = {}
        self.combat_active = False 
        self.stats_manager = get_stats_manager() 
        self.current_settings: Dict[str, Any] = {} 

        self.load_settings()

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0) 
        main_layout.setSpacing(0)
        
        self.content_frame = QFrame()
        self.content_frame.setObjectName("combatContentFrame") 
        self.content_frame.setFrameShape(QFrame.Shape.StyledPanel) 
        self.content_frame.setFrameShadow(QFrame.Shadow.Raised) 
        main_layout.addWidget(self.content_frame) 

        layout = QVBoxLayout(self.content_frame) 
        layout.setContentsMargins(10, 10, 10, 10) 
        layout.setSpacing(10) 

        status_layout = QHBoxLayout()
        status_layout.setContentsMargins(0, 0, 0, 0)
        status_layout.setSpacing(10)

        self.status_label = QLabel("Status: Narrative") 
        self.status_label.setObjectName("statusLabel")
        status_layout.addWidget(self.status_label)

        self.round_label = QLabel("Round: 0")
        self.round_label.setVisible(False) 
        self.round_label.setObjectName("roundLabel")
        status_layout.addWidget(self.round_label)

        status_layout.addStretch()

        self.settings_button = QPushButton("⚙️")
        self.settings_button.setToolTip("Combat Display Settings")
        self.settings_button.setFixedSize(25, 25)
        self.settings_button.clicked.connect(self.open_settings_dialog)
        status_layout.addWidget(self.settings_button)

        # Developer controls (hidden unless dev mode enabled)
        self.dev_controls_container = QWidget()
        dev_controls_layout = QHBoxLayout(self.dev_controls_container)
        dev_controls_layout.setContentsMargins(0, 0, 0, 0)
        dev_controls_layout.setSpacing(6)
        self.dev_step_mode_btn = QPushButton("Step Mode")
        self.dev_step_mode_btn.setCheckable(True)
        self.dev_next_step_btn = QPushButton("Next Step")
        self.dev_next_step_btn.setEnabled(False)
        dev_controls_layout.addWidget(self.dev_step_mode_btn)
        dev_controls_layout.addWidget(self.dev_next_step_btn)
        status_layout.addWidget(self.dev_controls_container)

        layout.addLayout(status_layout)

        self.entities_frame = QFrame() 
        self.entities_frame.setFrameShape(QFrame.Shape.NoFrame) 
        self.entities_frame.setFrameShadow(QFrame.Shadow.Plain) 
        self.entities_frame.setObjectName("entitiesFrame")
        entities_layout = QVBoxLayout(self.entities_frame)
        entities_layout.setContentsMargins(0,0,0,0) 
        entities_layout.setSpacing(10) 

        self.player_group = QGroupBox("Player") 
        self.player_group.setObjectName("playerGroup")
        player_layout = QHBoxLayout(self.player_group)
        player_layout.setContentsMargins(5, 10, 5, 5) 
        player_layout.setSpacing(5)
        self.player_layout = player_layout
        entities_layout.addWidget(self.player_group)

        self.enemies_group = QGroupBox("Enemies") 
        self.enemies_group.setObjectName("enemiesGroup")
        enemies_layout = QHBoxLayout(self.enemies_group)
        enemies_layout.setContentsMargins(5, 10, 5, 5) 
        enemies_layout.setSpacing(5)
        self.enemies_layout = enemies_layout
        entities_layout.addWidget(self.enemies_group)

        layout.addWidget(self.entities_frame)

        self.log_group = QGroupBox("Combat Log") 
        self.log_group.setObjectName("logGroup")
        log_layout = QVBoxLayout(self.log_group)
        log_layout.setContentsMargins(5, 10, 5, 5) 
        log_layout.setSpacing(0)

        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setMinimumHeight(150)
        self.log_text.setObjectName("combatLogText")
        log_layout.addWidget(self.log_text)

        layout.addWidget(self.log_group)

        self.last_log_index = -1 

        self._gradual_log_iterator: Optional[Iterator[str]] = None
        self._gradual_log_format: Optional[QTextCharFormat] = None
        self._gradual_log_timer: Optional[QTimer] = None
        self._is_gradual_log_active: bool = False
        self._pending_log_messages: List[Tuple[str, QTextCharFormat, bool]] = [] 

        self.apply_settings()
        self.clear_display()
        
        # Suppress visualComplete during batched replays
        self._suppress_visual_complete: bool = False

        # Initialize dev controls visibility from QSettings
        self._init_dev_controls()

    def load_settings(self):
        """Load settings from JSON file or use defaults."""
        self.current_settings = self.get_default_settings() # Start with defaults
        logger.info(f"Loading combat display settings from: {SETTINGS_FILE}")
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r') as f:
                    loaded_settings = json.load(f)
                    logger.debug(f"Loaded settings: {loaded_settings}")
                    # Merge loaded settings carefully, only overwriting defaults
                    for key, value in loaded_settings.items():
                         # Check if key exists in defaults OR if it's a known pattern (future-proofing slightly)
                         if key in self.current_settings or key.startswith("color_") or key.startswith("font_"):
                             self.current_settings[key] = value
                         else:
                             logger.warning(f"Ignoring unknown setting '{key}' from file.")
            else:
                logger.info("Settings file not found. Using default settings.")
        except (IOError, json.JSONDecodeError) as e:
            logger.error(f"Error loading combat display settings: {e}. Using defaults.")
        logger.info(f"Final settings after load: {self.current_settings}")


    def get_default_settings(self):
        """Return a dictionary of default settings."""
        default_font = QFontDatabase.systemFont(QFontDatabase.GeneralFont)
        return {
            # Background
            "background_image": None,
            # Fonts
            "font_family": default_font.family(),
            "font_size": default_font.pointSize() if default_font.pointSize() > 0 else 10,
            "font_size_player_name_offset": 1,
            "font_size_status_offset": 2,
            # Log Colors
            "color_log_damage": "#C80000",
            "color_log_heal": "#009600",
            "color_log_crit": "#FF0000", # Brighter red for crits
            "color_log_miss": "#969696",
            "color_log_roll": "#C87800",
            "color_log_turn": "#0064C8",
            "color_log_round": "#0064FF",
            "color_log_dev": "#646464",
            "color_log_header": "#A0A0A0", 
            "color_log_default": "#E0E0E0", 
            "color_log_combat_event": "#FFFFFF", 
            "color_log_system_message": "#FFFF00", # Default Yellow for system messages
            "color_log_narrative": "#FFD700", # Default Golden for narrative/GM messages
            "color_log_group_bg": "rgba(40, 40, 40, 0.75)", 
            "color_log_text_bg": "rgba(25, 25, 25, 0.85)", # Slightly darker text edit bg
            # General UI Colors
            "color_status_text": "#FFFFFF", 
            "color_round_text": "#E0E0E0", 
            "color_groupbox_title_text": "#FFFFFF", 
            "color_groupbox_title_bg": "rgba(0, 0, 0, 0.6)", 
            # Section Background Colors 
            "color_player_group_bg": "rgba(60, 80, 120, 0.7)", 
            "color_enemies_group_bg": "rgba(120, 60, 60, 0.7)", 
            # Entity Colors
            "color_entity_player_bg": "rgba(200, 220, 255, 0.3)",
            "color_entity_player_border": "#0077cc",
            "color_entity_player_bg_active": "rgba(200, 220, 255, 0.8)",
            "color_entity_player_border_active": "#00aaff",
            "color_entity_enemy_bg": "rgba(255, 200, 200, 0.3)",
            "color_entity_enemy_border": "#cc0000",
            "color_entity_enemy_bg_active": "rgba(255, 200, 200, 0.8)",
            "color_entity_enemy_border_active": "#ff5500",
            # Progress Bar Colors
            "color_hp_bar_chunk_normal": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)",
            "color_hp_bar_chunk_low": "#cc0000",
            "color_hp_bar_chunk_critical": "#990000",
            "color_hp_bar_chunk_normal_bleak": "#AA0000A0", 
            "color_hp_bar_chunk_low_bleak": "#880000A0",   
            "color_hp_bar_chunk_critical_bleak": "#600000A0",
            "color_stamina_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #66CC33, stop:1 #44AA22)",
            "color_stamina_bar_chunk_bleak": "#44AA22A0",
            "color_mana_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #3366CC, stop:1 #2244AA)", # Added Mana Chunk
            "color_mana_bar_chunk_bleak": "#2244AAA0",  # Added Mana Bleak
            "color_resolve_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #9b59b6, stop:1 #8e44ad)",
            "color_progressbar_text": "#FFFFFF", 
            "color_progressbar_bg": "#555555",

            "gradual_text_combat_log": True, 
            "display_text_speed_delay": 30,
        }

    def save_settings(self):
        """Save current settings to JSON file."""
        logger.info(f"Saving combat display settings to: {SETTINGS_FILE}")
        try:
            # Ensure config directory exists before writing
            os.makedirs(CONFIG_DIR, exist_ok=True)
            with open(SETTINGS_FILE, 'w') as f:
                json.dump(self.current_settings, f, indent=4)
            logger.info("Settings saved successfully.")
        except IOError as e:
            logger.error(f"Error saving combat display settings: {e}")

    def _init_dev_controls(self):
        """Initialize dev controls based on QSettings and wire their signals."""
        try:
            settings = QSettings("RPGGame", "Settings")
            dev_enabled = settings.value("dev/enabled", False, type=bool)
        except Exception:
            dev_enabled = False
        self.dev_controls_container.setVisible(bool(dev_enabled))
        # Wire buttons to orchestrator
        try:
            engine = get_game_engine()
            orch = getattr(engine, '_combat_orchestrator', None)
            if orch:
                # Disconnect existing to avoid duplicates
                try:
                    self.dev_step_mode_btn.toggled.disconnect(orch.toggle_dev_step_mode)
                except Exception:
                    pass
                try:
                    self.dev_next_step_btn.clicked.disconnect(orch.dev_release_next_step)
                except Exception:
                    pass
                self.dev_step_mode_btn.toggled.connect(orch.toggle_dev_step_mode)
                self.dev_next_step_btn.clicked.connect(orch.dev_release_next_step)
                # Listen to waiting state to enable/disable Next button
                try:
                    orch.dev_waiting_state_changed.disconnect(self._on_orchestrator_dev_waiting_changed)
                except Exception:
                    pass
                orch.dev_waiting_state_changed.connect(self._on_orchestrator_dev_waiting_changed)
        except Exception as e:
            logger.warning(f"Failed initializing dev controls: {e}")

    @Slot(bool)
    def _on_orchestrator_dev_waiting_changed(self, waiting: bool):
        self.dev_next_step_btn.setEnabled(bool(waiting))

    def apply_settings(self):
        """Apply loaded or default settings to the combat display UI."""
        if not self.current_settings:
            logger.warning("Attempted to apply settings before loading. Loading defaults.")
            self.load_settings() # This populates self.current_settings

        logger.debug(f"Applying settings to CombatDisplay: {self.current_settings}")

        # --- ECFA Change: Ensure text speed setting is loaded into self.current_settings ---
        # If load_settings doesn't get specific combat speed, use general one.
        q_settings = QSettings("RPGGame", "Settings")
        general_text_speed = q_settings.value("display/text_speed_delay", 30, type=int)
        self.current_settings.setdefault("display_text_speed_delay_combat", general_text_speed)
        # --- End ECFA Change ---

        bg_image_relative = self.current_settings.get("background_image")
        main_widget_style_parts = [] 
        image_path_for_log = "None" 
        if bg_image_relative:
            image_path = os.path.join(IMAGE_DIR, bg_image_relative).replace("\\", "/")
            image_path_for_log = image_path 
            if os.path.exists(image_path):
                main_widget_style_parts.append(f"border-image: url(\"{image_path}\") 0 0 0 0 stretch stretch;")
                logger.info(f"Applying background image using border-image: {image_path}")
            else:
                logger.warning(f"Background image not found: {image_path}")
                main_widget_style_parts.append("border-image: none;")
        else:
             main_widget_style_parts.append("border-image: none;")
             logger.info("No background image selected, applying 'border-image: none;'")

        try:
            fallback_bg_color_str = self.current_settings.get("color_fallback_bg", "rgba(30, 30, 30, 0.9)")
            QColor(fallback_bg_color_str) 
        except (ValueError, TypeError):
            logger.warning(f"Invalid fallback background color '{fallback_bg_color_str}'. Using default.")
            fallback_bg_color_str = "rgba(30, 30, 30, 0.9)"
        main_widget_style_parts.append(f"background-color: {fallback_bg_color_str};")

        main_widget_style = "\n    ".join(main_widget_style_parts)

        def get_safe_color(key, default):
            color_str = self.current_settings.get(key, default)
            try:
                QColor(color_str); return color_str
            except (ValueError, TypeError):
                logger.warning(f"Invalid color value '{color_str}' for key '{key}'. Using default '{default}'.")
                return default

        player_group_bg = get_safe_color("color_player_group_bg", "rgba(60, 80, 120, 0.7)")
        enemies_group_bg = get_safe_color("color_enemies_group_bg", "rgba(120, 60, 60, 0.7)")
        log_group_bg = get_safe_color("color_log_group_bg", "rgba(40, 40, 40, 0.75)")
        log_default_text_color = get_safe_color("color_log_default", "#E0E0E0")
        log_text_bg_color = get_safe_color("color_log_text_bg", "rgba(255, 255, 255, 0.05)") # Ensure this is a valid key or provide default
        groupbox_title_text = get_safe_color("color_groupbox_title_text", "#FFFFFF")
        groupbox_title_bg = get_safe_color("color_groupbox_title_bg", "rgba(0, 0, 0, 0.6)")
        status_text_color = get_safe_color("color_status_text", "#FFFFFF")
        round_text_color = get_safe_color("color_round_text", "#E0E0E0")


        full_stylesheet = f"""
            QWidget#{self.objectName()} {{ background-color: transparent; border: none; }}
            QFrame#combatContentFrame {{ {main_widget_style} background-clip: padding-box; background-origin: border-box; border-radius: 5px; }}
            QFrame#{self.entities_frame.objectName()} {{ background-color: transparent; border: none; }}
            QGroupBox#{self.player_group.objectName()} {{ background-color: {player_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox#{self.enemies_group.objectName()} {{ background-color: {enemies_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox#{self.log_group.objectName()} {{ background-color: {log_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox::title {{ color: {groupbox_title_text}; background-color: {groupbox_title_bg}; padding: 3px 8px; border-radius: 3px; subcontrol-origin: margin; subcontrol-position: top left; margin-left: 5px; }}
            QTextEdit#{self.log_text.objectName()} {{ background-color: {log_text_bg_color}; color: {log_default_text_color}; border: 1px solid rgba(0, 0, 0, 0.2); border-radius: 3px; padding: 2px; }}
            QLabel#{self.status_label.objectName()} {{ background-color: transparent; color: {status_text_color}; padding: 2px; }}
            QLabel#{self.round_label.objectName()} {{ background-color: transparent; color: {round_text_color}; padding: 2px; }}
        """
        self.setStyleSheet(full_stylesheet)

        font_family = self.current_settings.get("font_family", "Arial")
        font_size = self.current_settings.get("font_size", 10)
        
        status_font_size_offset = self.current_settings.get("font_size_status_offset", 2)
        status_font = QFont(font_family, font_size + status_font_size_offset)
        status_font.setBold(True)
        self.status_label.setFont(status_font)

        round_font = QFont(font_family, font_size)
        self.round_label.setFont(round_font)

        log_font = QFont(font_family, font_size)
        self.log_text.setFont(log_font) 

        title_font = QFont(font_family, font_size) 
        title_font.setBold(True) 
        self.player_group.setFont(title_font)
        self.enemies_group.setFont(title_font)
        self.log_group.setFont(title_font)

        for entity_widget in self.entity_widgets.values():
            entity_widget.update_style(self.current_settings)
        self.update()
        logger.info("Combat display settings applied.")

    def clear_display(self):
        """Clear the display and set to inactive/narrative state."""
        self.combat_active = False
        self.status_label.setText("Status: Narrative")
        self.round_label.setText("Round: 0")
        self.round_label.setVisible(False) # Hide round counter
        self.last_log_index = -1

        # Clear the combat log text content as well
        try:
            self.clear_log()
        except Exception:
            pass

        # Clear entity widgets
        self._clear_entity_widgets()

        # Hide the entities frame and log_group for clean UI
        if hasattr(self, 'entities_frame'):
            self.entities_frame.setVisible(False)
        if hasattr(self, 'log_group'):
            self.log_group.setVisible(False)

    @Slot(GameState)
    def update_display(self, game_state: GameState):
        """Update the display based on the current GameState."""
        if game_state is None:
            logger.warning("CombatDisplay.update_display received None GameState, clearing display.")
            self.clear_display()
            return

        current_mode_enum = getattr(game_state, 'current_mode', InteractionMode.NARRATIVE)
        mode = current_mode_enum.name if hasattr(current_mode_enum, 'name') else str(current_mode_enum)
        
        logger.info(f"CombatDisplay.update_display called. Game Mode: {mode}")

        if mode in ["COMBAT", "SOCIAL_CONFLICT"]:
            # Update dev controls visibility on entering these modes
            try:
                settings = QSettings("RPGGame", "Settings")
                dev_enabled = settings.value("dev/enabled", False, type=bool)
                self.dev_controls_container.setVisible(bool(dev_enabled))
            except Exception:
                self.dev_controls_container.setVisible(False)
            self.setVisible(True) # Ensure the CombatDisplay widget itself is visible
            initial_setup_done_this_call = False
            if not self.combat_active: 
                logger.info(f"CombatDisplay: First entry into {mode} view. Setting up UI visibility and styles.")
                if hasattr(self, 'entities_frame'): self.entities_frame.setVisible(True)
                if hasattr(self, 'log_group'): self.log_group.setVisible(True)
                if hasattr(self, 'player_group'): self.player_group.setVisible(True)
                if hasattr(self, 'enemies_group'): self.enemies_group.setVisible(True)
                self.combat_active = True
                self.apply_settings() # Apply styles
                initial_setup_done_this_call = True
            
            combat_manager = getattr(game_state, 'combat_manager', None)
            if not combat_manager:
                logger.warning(f"CombatDisplay: {mode} mode active but no CombatManager found. Clearing entity widgets.")
                self.status_label.setText(f"Status: {mode} (Error - No Manager)")
                self._clear_entity_widgets() 
                return
            
            logger.info(f"CombatDisplay: CombatManager found (ID: {getattr(combat_manager, 'id', 'N/A')}). Entities in CM: {len(getattr(combat_manager, 'entities', {}))}")

            round_num = getattr(combat_manager, 'round_number', 0)
            cm_state_attr = getattr(combat_manager, 'state', None)
            cm_state_name = cm_state_attr.name if hasattr(cm_state_attr, 'name') else "Unknown State"

            if mode == "COMBAT":
                self.round_label.setVisible(True)
                self.round_label.setText(f"Round: {round_num}")
                if cm_state_name == "IN_PROGRESS": self.status_label.setText("Status: Combat Active")
                elif cm_state_name == "PLAYER_VICTORY": self.status_label.setText("Status: Victory!")
                elif cm_state_name == "PLAYER_DEFEAT": self.status_label.setText("Status: Defeat!")
                elif cm_state_name == "FLED": self.status_label.setText("Status: Fled from Combat")
                else: self.status_label.setText(f"Status: Combat - {cm_state_name}")
            else: 
                self.status_label.setText("Status: Social Conflict")
                self.round_label.setVisible(False)

            current_turn_id = getattr(combat_manager, 'get_current_entity_id', lambda: None)()
            combatants_widget_data = {}
            cm_entities = getattr(combat_manager, 'entities', {})
            if cm_entities:
                logger.debug(f"CombatDisplay: Building combatants_widget_data from CM entities. Count: {len(cm_entities)}")
                for entity_id, combat_entity in cm_entities.items():
                    if not getattr(combat_entity, 'is_active_in_combat', True):
                        logger.debug(f"CombatDisplay: Skipping display of inactive entity: {getattr(combat_entity, 'combat_name', entity_id)}")
                        if entity_id in self.entity_widgets: 
                            widget_to_remove = self.entity_widgets.pop(entity_id)
                            if widget_to_remove.parentWidget() and widget_to_remove.parentWidget().layout():
                                widget_to_remove.parentWidget().layout().removeWidget(widget_to_remove)
                            widget_to_remove.deleteLater()
                        continue

                    raw_status_effects = getattr(combat_entity, 'status_effects', {})
                    display_status_effects = []
                    if isinstance(raw_status_effects, dict):
                        display_status_effects = [f"{name}({dur})" if dur not in [None, float('inf')] else name for name, dur in raw_status_effects.items()]
                    elif isinstance(raw_status_effects, (list, set)):
                        display_status_effects = [str(eff_name) for eff_name in raw_status_effects]
                    
                    entity_type_enum = getattr(combat_entity, 'entity_type', None)

                    combatants_widget_data[entity_id] = {
                        "id": entity_id, 
                        "name": getattr(combat_entity, 'name', 'N/A'), 
                        "combat_name": getattr(combat_entity, 'combat_name', 'N/A'), 
                        "current_hp": getattr(combat_entity, 'current_hp', 0), 
                        "max_hp": getattr(combat_entity, 'max_hp', 1) if getattr(combat_entity, 'max_hp', 0) > 0 else 1,
                        "current_stamina": getattr(combat_entity, 'current_stamina', 0), 
                        "max_stamina": getattr(combat_entity, 'max_stamina', 1) if getattr(combat_entity, 'max_stamina', 0) > 0 else 1,
                        "current_mana": getattr(combat_entity, 'current_mp', 0),
                        "max_mana": getattr(combat_entity, 'max_mp', 1) if getattr(combat_entity, 'max_mp', 0) > 0 else 1,
                        "status_effects": display_status_effects,
                        "is_player": entity_type_enum == EntityType.PLAYER if entity_type_enum else False,
                        "entity_type_str": entity_type_enum.name if hasattr(entity_type_enum, 'name') else str(entity_type_enum)
                    }
            else:
                logger.warning("CombatDisplay: combat_manager has no 'entities' or it's empty.")

            if not combatants_widget_data:
                logger.warning("CombatDisplay: combatants_widget_data is empty. No entity widgets will be updated/created for this call.")
                if initial_setup_done_this_call:
                    self._clear_entity_widgets() 
            else:
                logger.info(f"CombatDisplay: Queuing _update_entity_widgets with {len(combatants_widget_data)} entries. Current turn ID: {current_turn_id}")
                is_combat_mode = (mode == "COMBAT")
                QTimer.singleShot(0, lambda data=combatants_widget_data.copy(), turn_id=current_turn_id, is_combat=is_combat_mode: self._update_entity_widgets(data, turn_id, is_combat))

        elif self.combat_active: 
            logger.info(f"CombatDisplay: Exiting {mode} view (was active). Clearing display.")
            self.clear_display() 
            self.setVisible(False) # Hide the CombatDisplay widget when not in combat
            
    def _clear_entity_widgets(self):
        """Clear all entity widgets."""
        layouts_to_clear = [self.player_layout, self.enemies_layout]
        for layout in layouts_to_clear:
            if not layout: continue
            # Remove stretch item first if it exists
            stretch_index = -1
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.spacerItem():
                    stretch_index = i
                    break
            if stretch_index != -1:
                layout.takeAt(stretch_index) # Remove stretch

            # Remove widgets
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()
                if widget:
                    widget.deleteLater()

        self.entity_widgets.clear()

    def _update_entity_widgets(self, combatants_data: Dict[str, Dict[str, Any]], current_turn_id: Optional[str], is_combat_mode: bool):
        """Update entity widgets based on combatant data."""
        logger.info(f"CombatDisplay._update_entity_widgets: Received {len(combatants_data)} combatants. Current turn: {current_turn_id}")
        if not combatants_data:
            logger.warning("CombatDisplay._update_entity_widgets: combatants_data is empty. Clearing existing widgets if any.")
            self._clear_entity_widgets() # Clear if no data
            return

        existing_ids_in_data = set(combatants_data.keys())
        current_widget_ids = set(self.entity_widgets.keys())

        # Remove widgets for entities no longer in combatants_data
        for entity_id_to_remove in current_widget_ids - existing_ids_in_data:
            if entity_id_to_remove in self.entity_widgets:
                widget = self.entity_widgets.pop(entity_id_to_remove)
                parent_layout = widget.parentWidget().layout() if widget.parentWidget() else None
                if parent_layout: parent_layout.removeWidget(widget)
                widget.deleteLater()
                logger.info(f"CombatDisplay: Removed entity widget for no longer present/active entity: {entity_id_to_remove}")

        player_widgets_present = False
        enemy_widgets_present = False

        for entity_id, entity_data in combatants_data.items():
            is_player = entity_data.get("is_player", False)
            entity_type_str = entity_data.get("entity_type_str", "UNKNOWN") # For logging
            logger.debug(f"CombatDisplay: Processing entity widget for ID {entity_id}, Name: {entity_data.get('combat_name', 'N/A')}, IsPlayer: {is_player}, Type: {entity_type_str}")
            
            is_active_turn = entity_id == current_turn_id
            display_name = entity_data.get("combat_name", entity_data.get("name", entity_id))
            
            current_hp = int(entity_data.get("current_hp", 0)) 
            max_hp = int(entity_data.get("max_hp", 1)) 
            current_stamina = int(entity_data.get("current_stamina", 0)) 
            max_stamina = int(entity_data.get("max_stamina", 1))
            current_mana = int(entity_data.get("current_mana", 0))
            max_mana = int(entity_data.get("max_mana", 1))
            status_effects = entity_data.get("status_effects", [])

            if entity_id in self.entity_widgets:
                widget = self.entity_widgets[entity_id]
                logger.debug(f"CombatDisplay: Updating existing widget for {display_name}")
                widget.name_label.setText(display_name)
                widget.update_style(self.current_settings)
                # In COMBAT mode, do NOT override current values for existing widgets; only update max ranges and labels
                if is_combat_mode:
                    try:
                        # Update ranges only; keep current values as shown (driven by PHASE events)
                        widget.hp_bar.setRange(0, max_hp if max_hp > 0 else 1)
                        widget.stamina_bar.setRange(0, max_stamina if max_stamina > 0 else 1)
                        widget.mana_bar.setRange(0, max_mana if max_mana > 0 else 1)
                        # Update status effects text
                        if status_effects:
                            widget.status_text.setText(", ".join(status_effects))
                        else:
                            widget.status_text.setText("None")
                    except Exception as e:
                        logger.warning(f"CombatDisplay: Failed to apply COMBAT safe update for {display_name}: {e}")
                else:
                    widget.update_stats(current_hp, max_hp, current_stamina, max_stamina, status_effects, current_mana, max_mana)
                widget.highlight_active(is_active_turn)
            else:
                logger.info(f"CombatDisplay: Creating NEW widget for {display_name} (ID: {entity_id}, IsPlayer: {is_player})")
                widget = CombatEntityWidget(entity_id=entity_id, name=display_name, settings=self.current_settings, is_player=is_player)
                # On first creation, seed values fully
                widget.update_stats(current_hp, max_hp, current_stamina, max_stamina, status_effects, current_mana, max_mana)
                widget.highlight_active(is_active_turn)
                
                target_layout = self.player_layout if is_player else self.enemies_layout
                if target_layout:
                    # Remove existing stretch if present before adding widget
                    stretch_item = target_layout.takeAt(target_layout.count() -1) if target_layout.count() >0 and target_layout.itemAt(target_layout.count()-1).spacerItem() else None

                    target_layout.addWidget(widget) # Add the new widget

                    if stretch_item: # Add stretch back if it was removed
                        target_layout.addSpacerItem(stretch_item)
                    else: # Or ensure stretch is there if layout was empty
                        target_layout.addStretch()

                    logger.debug(f"CombatDisplay: Added widget for {display_name} to {'player' if is_player else 'enemies'} layout.")
                else:
                    logger.error(f"CombatDisplay: Target layout (player/enemy) not found for {display_name}!")
                self.entity_widgets[entity_id] = widget
            
            if is_player: player_widgets_present = True
            else: enemy_widgets_present = True

        # This ensures layouts with no widgets don't have a lingering stretch
        self._ensure_stretch(self.player_layout, player_widgets_present)
        self._ensure_stretch(self.enemies_layout, enemy_widgets_present)
        logger.info(f"CombatDisplay._update_entity_widgets: Finished. Player widgets: {player_widgets_present}, Enemy widgets: {enemy_widgets_present}. Total widgets in dict: {len(self.entity_widgets)}")

    def _ensure_stretch(self, layout: Optional[QHBoxLayout], widgets_present: bool):
        """Adds or removes stretch item from a layout as needed."""
        if not layout: return

        stretch_index = -1
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.spacerItem():
                stretch_index = i
                break

        if widgets_present and stretch_index == -1:
            layout.addStretch() # Add stretch if needed
        elif not widgets_present and stretch_index != -1:
            layout.takeAt(stretch_index) # Remove stretch if no widgets

    def _update_combat_log(self, log_entries: List[str]): # Added type hint
        """Update the combat log incrementally with new entries."""
        if not log_entries:
            return
        # Gate [DEV] lines if dev mode is disabled
        try:
            settings = QSettings("RPGGame", "Settings")
            dev_enabled = settings.value("dev/enabled", False, type=bool)
            if not dev_enabled:
                log_entries = [e for e in log_entries if not (isinstance(e, str) and e.strip().startswith("[DEV]"))]
                if not log_entries:
                    return
        except Exception:
            pass

        scrollbar = self.log_text.verticalScrollBar()
        at_bottom = scrollbar.value() >= scrollbar.maximum() - 10 # Is the user scrolled near the bottom?

        start_index = self.last_log_index + 1
        if start_index >= len(log_entries):
            return

        new_entries_to_process = log_entries[start_index:]
        logger.debug(f"Processing {len(new_entries_to_process)} new log entries (from index {start_index})")

        new_entries_added = False
        for entry_index, entry in enumerate(new_entries_to_process):
            # Determine color/format based on entry content and settings
            color_hex = self.current_settings.get("color_log_default", "#E0E0E0")
            is_bold = False
            is_italic = False
            is_narrative = True # Assume GM/Narrative by default

            entry_lower = entry.lower()

            # Simplified system message check (more robust checks might be needed)
            if entry.startswith("[SYSTEM]") or \
            "roll" in entry_lower and "vs" in entry_lower or \
            "takes" in entry_lower and "damage" in entry_lower or \
            "misses" in entry_lower or \
            "defeated" in entry_lower or \
            "fumble" in entry_lower or \
            "critical hit" in entry_lower or \
            "status expire" in entry_lower or \
            "turn." in entry_lower or \
            "round" in entry_lower and "begins" in entry_lower or \
            entry.startswith("Turn order:") or \
            "Stamina Cost:" in entry: # Check for stamina cost message
                is_narrative = False # Mark as system message

            # --- Color/Style Logic (using settings) ---
            # (Keep existing color logic)
            if entry.startswith("[DEV]"): color_hex = self.current_settings.get("color_log_dev", "#888888"); is_italic = True; is_narrative = False
            elif "critical hit" in entry_lower or "defeated!" in entry_lower or "was defeated" in entry_lower: color_hex = self.current_settings.get("color_log_crit", "#FF4444"); is_bold = True; is_narrative = False
            elif "healed" in entry_lower or "gains" in entry_lower and ("hp" in entry_lower or "stamina" in entry_lower): color_hex = self.current_settings.get("color_log_heal", "#44FF44"); is_narrative = False # Healing is often systemic
            elif "round" in entry_lower and "begins" in entry_lower: color_hex = self.current_settings.get("color_log_round", "#66AAFF"); is_bold = True; is_narrative = False
            elif "turn" in entry_lower or "'s turn" in entry_lower: color_hex = self.current_settings.get("color_log_turn", "#88CCFF"); is_narrative = False
            elif "combat started" in entry_lower or "combat ended" in entry_lower or "victory!" in entry_lower or "defeat!" in entry_lower or "fled!" in entry_lower or "surrender" in entry_lower: color_hex = self.current_settings.get("color_log_combat_event", "#FFFFFF"); is_bold = True; is_narrative = False
            elif "misses" in entry_lower or "fails" in entry_lower or "resisted" in entry_lower or "escape fails" in entry_lower: color_hex = self.current_settings.get("color_log_miss", "#AAAAAA"); is_italic = True; is_narrative = False
            elif "damage" in entry_lower or "loses" in entry_lower and ("hp" in entry_lower or "resolve" in entry_lower): color_hex = self.current_settings.get("color_log_damage", "#FF8888"); is_narrative = False
            elif "roll" in entry_lower or "vs" in entry_lower: color_hex = self.current_settings.get("color_log_roll", "#FFCC66"); is_narrative = False

            # Append with determined format and gradual flag
            text_format = QTextCharFormat()
            try:
                text_format.setForeground(QColor(color_hex))
            except ValueError:
                logger.warning(f"Invalid color hex '{color_hex}' for log entry. Using default.")
                text_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0")))

            if is_bold: text_format.setFontWeight(QFont.Weight.Bold)
            if is_italic: text_format.setFontItalic(True)

            # Use gradual display ONLY for narrative messages
            self._append_formatted_text(entry, text_format, gradual=is_narrative) # Pass gradual flag
            new_entries_added = True

            # Update last processed index
            self.last_log_index = start_index + entry_index

    def _append_formatted_text(self, text: str, text_format: QTextCharFormat, gradual: bool = False):
        """Appends text to the log, either immediately or gradually."""
        use_gradual = gradual and self.current_settings.get("gradual_text_combat_log", True) # Check setting

        if not text.strip(): # Don't append empty or whitespace-only lines
            logger.debug("Skipping append of empty/whitespace log message.")
            self.visualDisplayComplete.emit() # Emit completion even for skipped empty text
            return

        if not text.endswith('\n'):
            text += '\n'

        if self._is_gradual_log_active:
            logger.debug(f"Queueing log message (Gradual: {use_gradual}): '{text[:50]}...'")
            self._pending_log_messages.append((text, text_format, use_gradual))
            return

        if not use_gradual:
            logger.debug(f"Appending immediate log message: '{text[:50]}...'")
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            cursor.insertText(text, text_format)
            self.log_text.setTextCursor(cursor) 
            self.log_text.ensureCursorVisible()
            if not getattr(self, '_suppress_visual_complete', False):
                logger.info(f"CombatDisplay: immediate display complete; emitting visualDisplayComplete for id={getattr(self, '_current_text_event_id', None)}")
                self.visualDisplayComplete.emit() # --- ECFA Change: Emit signal ---
                # Event-based direct notify to orchestrator as well
                try:
                    from core.base.engine import get_game_engine
                    eng = get_game_engine()
                    if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                        logger.debug(f"CombatDisplay: immediate direct orchestrator complete for id={getattr(self, '_current_text_event_id', None)}")
                        eng._combat_orchestrator._handle_visual_display_complete()
                except Exception:
                    pass
            self._process_next_pending_log_message()
            return

        logger.debug(f"Starting gradual log display: '{text[:50]}...'")
        self._is_gradual_log_active = True
        self._gradual_log_iterator = iter(text)
        self._gradual_log_format = text_format

        cursor = self.log_text.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.log_text.setTextCursor(cursor)

        if not self._gradual_log_timer:
            self._gradual_log_timer = QTimer(self)
            self._gradual_log_timer.setSingleShot(True)
            self._gradual_log_timer.timeout.connect(self._display_next_log_char)

        QTimer.singleShot(1, self._display_next_log_char)

    @Slot()
    def _display_next_log_char(self):
        """Displays the next character for the combat log gradual display."""
        if not self._is_gradual_log_active or not self._gradual_log_iterator:
            if self._is_gradual_log_active: 
                self._is_gradual_log_active = False
                if not getattr(self, '_suppress_visual_complete', False):
                    self.visualDisplayComplete.emit() 
                self._process_next_pending_log_message()
            return

        try:
            char = next(self._gradual_log_iterator)
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            if self._gradual_log_format:
                cursor.insertText(char, self._gradual_log_format)
            else:
                cursor.insertText(char) 
            self.log_text.setTextCursor(cursor) 
            self.log_text.ensureCursorVisible() 

            # --- ECFA Change: Use unified settings key from self.current_settings ---
            char_delay = self.current_settings.get("display_text_speed_delay", 30) 
            # --- End ECFA Change ---
            char_delay = max(5, int(char_delay)) 
            if self._gradual_log_timer: 
                self._gradual_log_timer.start(char_delay)

        except StopIteration:
            self._is_gradual_log_active = False
            self._gradual_log_iterator = None
            self._gradual_log_format = None
            logger.info(f"CombatDisplay: gradual display finished; emitting visualDisplayComplete for id={getattr(self, '_current_text_event_id', None)}")
            if not getattr(self, '_suppress_visual_complete', False):
                self.visualDisplayComplete.emit() 
                # Event-based direct notify to orchestrator as well
                try:
                    from core.base.engine import get_game_engine
                    eng = get_game_engine()
                    if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                        logger.debug(f"CombatDisplay: gradual direct orchestrator complete for id={getattr(self, '_current_text_event_id', None)}")
                        eng._combat_orchestrator._handle_visual_display_complete()
                except Exception:
                    pass
            self._process_next_pending_log_message()

        except Exception as e:
            logger.error(f"Error during gradual log display: {e}", exc_info=True)
            self._is_gradual_log_active = False
            self._gradual_log_iterator = None
            self._gradual_log_format = None
            if self._gradual_log_timer and self._gradual_log_timer.isActive():
                self._gradual_log_timer.stop()
            if not getattr(self, '_suppress_visual_complete', False):
                logger.info(f"CombatDisplay: gradual error path; emitting visualDisplayComplete for id={getattr(self, '_current_text_event_id', None)}")
                self.visualDisplayComplete.emit() 
                # Event-based direct notify to orchestrator as well
                try:
                    from core.base.engine import get_game_engine
                    eng = get_game_engine()
                    if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                        logger.debug(f"CombatDisplay: error direct orchestrator complete for id={getattr(self, '_current_text_event_id', None)}")
                        eng._combat_orchestrator._handle_visual_display_complete()
                except Exception:
                    pass
            self._pending_log_messages.clear() 
            self._process_next_pending_log_message() # Process queue even on error

    def _process_next_pending_log_message(self):
        """Processes the next message in the pending queue."""
        if not self._is_gradual_log_active and self._pending_log_messages:
            text, text_format, is_gradual = self._pending_log_messages.pop(0)
            logger.debug(f"Processing pending log message (Gradual: {is_gradual}): '{text[:50]}...'")
            # Call _append_formatted_text again - it will handle starting gradual or immediate append
            self._append_formatted_text(text, text_format, gradual=is_gradual)

    def clear_log(self):
        """Clear the combat log."""
        self.log_text.clear()
        logger.info("Combat log cleared.")
        # Add header back immediately after clearing?
        # header_format = QTextCharFormat()
        # header_format.setFontWeight(QFont.Bold)
        # header_format.setForeground(QColor(self.current_settings.get("color_log_header", "#A0A0A0")))
        # self._append_formatted_text("===== COMBAT LOG =====", header_format)


    def open_settings_dialog(self):
        """Opens the settings dialog to customize the combat display."""
        logger.info("Opening Combat Display Settings dialog.")

        if not self.current_settings:
            logger.error("Cannot open settings dialog: current_settings not loaded.")
            self.load_settings() # Try loading defaults if missing

        # Pass a copy of current settings to avoid modifying originals unless saved
        dialog = CombatSettingsDialog(self.current_settings.copy(), IMAGE_DIR, self)

        # Execute the dialog modally
        if dialog.exec(): # Returns True if accepted (e.g., Save clicked)
            new_settings = dialog.get_settings()
            if new_settings != self.current_settings:
                logger.info("Settings changed. Saving and applying...")
                self.current_settings = new_settings
                self.save_settings()
                self.apply_settings() # Re-apply all settings
            else:
                logger.info("Settings dialog closed without changes.")
        else:
            logger.info("Settings dialog cancelled.")

    def append_buffered_messages(self, messages: List[str], gradual: bool):
        """
        Appends a list of messages, typically from the combat_narrative_buffer.
        The visualDisplayComplete signal will be emitted after the *last* message in the list
        has finished displaying.
        """
        if not messages:
            self.visualDisplayComplete.emit() # Emit if buffer is empty
            return

        logger.debug(f"Appending {len(messages)} buffered messages. Gradual: {gradual}")
        
        # Use default GM format for buffered messages (usually narrative)
        # This format should be configurable or passed with the event in a richer system
        from PySide6.QtGui import QFont, QColor # Local import for safety
        gm_format = QTextCharFormat()
        gm_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0"))) # Example color
        # font_family = self.current_settings.get("font_family", "Arial")
        # font_size = self.current_settings.get("font_size", 10)
        # gm_format.setFont(QFont(font_family, font_size))


        for i, message_content in enumerate(messages):
            is_last_message = (i == len(messages) - 1)
            
            # If it's the last message, its completion will trigger the main visualDisplayComplete.
            # For other messages, we don't want them to trigger the orchestrator's main logic.
            # This requires _append_formatted_text to know if it's part of a batch.
            # Simpler for now: _append_formatted_text always emits. Orchestrator ignores intermediate ones
            # if it knows it's processing a BUFFER_FLUSH event with multiple items.
            # This detail depends on how Orchestrator handles BUFFER_FLUSH DisplayEvents.

            # For now, let's assume _append_formatted_text handles queuing and will eventually
            # emit visualDisplayComplete after the *entire sequence* of buffered messages.
            # This means _append_formatted_text needs to be smarter or we need a different approach.

            # Refined approach: _append_formatted_text queues. The final visualDisplayComplete
            # will be emitted when the *last* character of the *last* message is displayed.
            self._append_formatted_text(message_content, gm_format, gradual)

    def stop_gradual_display(self):
        """Immediately stops any ongoing gradual text display and processes pending messages quickly."""
        logger.info("Stopping current gradual display and flushing pending messages.")
        if self._gradual_log_timer and self._gradual_log_timer.isActive():
            self._gradual_log_timer.stop()
        
        # If an iterator was active, display remaining text immediately
        if self._gradual_log_iterator:
            remaining_text = "".join(list(self._gradual_log_iterator))
            if remaining_text:
                cursor = self.log_text.textCursor()
                cursor.movePosition(QTextCursor.MoveOperation.End)
                if self._gradual_log_format:
                    cursor.insertText(remaining_text, self._gradual_log_format)
                else:
                    cursor.insertText(remaining_text)
                self.log_text.setTextCursor(cursor)
                self.log_text.ensureCursorVisible()
            self._gradual_log_iterator = None
            self._gradual_log_format = None

        self._is_gradual_log_active = False # Mark as not active
        
        # Process all pending messages immediately (non-gradual)
        while self._pending_log_messages:
            text, text_format, _ = self._pending_log_messages.pop(0) # Ignore original gradual flag
            logger.debug(f"Flushing pending message immediately: '{text[:50]}...'")
            if not text.endswith('\n'): text += '\n'
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            cursor.insertText(text, text_format)
            self.log_text.setTextCursor(cursor)
            self.log_text.ensureCursorVisible()
            
        self.visualDisplayComplete.emit()

    def append_orchestrated_event_content(self, event_content: str, event_role: str, is_gradual: bool, event_id: Optional[str] = None):
        """
        Appends orchestrated event content to the combat log, using CombatDisplay's
        own settings for color formatting.
        """
        # Track current event id for logging/diagnostics
        try:
            self._current_text_event_id = event_id
            logger.info(f"CombatDisplay: render string event id={event_id} gradual={bool(is_gradual)} len={len(event_content) if isinstance(event_content, str) else 'N/A'}")
        except Exception:
            pass
        
        # Hide [DEV] lines unless dev mode is enabled
        try:
            if isinstance(event_content, str) and event_content.strip().startswith("[DEV]"):
                settings = QSettings("RPGGame", "Settings")
                if not settings.value("dev/enabled", False, type=bool):
                    # Consider visual complete so orchestrator does not stall
                    self.visualDisplayComplete.emit()
                    # Also directly notify orchestrator in case signal path is disrupted
                    try:
                        from core.base.engine import get_game_engine
                        eng = get_game_engine()
                        if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                            logger.debug(f"CombatDisplay: Direct notify orchestrator complete for DEV-suppressed id={event_id}")
                            eng._combat_orchestrator._handle_visual_display_complete()
                    except Exception:
                        pass
                    return
        except Exception:
            pass
        # Determine color/format based on event_role, event_content, and self.current_settings
        color_hex = self.current_settings.get("color_log_default", "#E0E0E0") # Default
        is_bold = False
        is_italic = False

        # Standardize role for key lookup
        role_lower = event_role.lower() if event_role else "system"
        content_lower = event_content.lower()

        # Precedence: Specific keywords first, then role-based, then default.
        if "critical hit" in content_lower or "defeated!" in content_lower or "was defeated" in content_lower:
            color_hex = self.current_settings.get("color_log_crit", "#FF0000") # Default red for crit
            is_bold = True
        elif "healed" in content_lower or ("gains" in content_lower and ("hp" in content_lower or "stamina" in content_lower)):
            color_hex = self.current_settings.get("color_log_heal", "#009600") # Default green for heal
        elif "round" in content_lower and "begins" in content_lower:
            color_hex = self.current_settings.get("color_log_round", "#0064FF") # Default blue for round
            is_bold = True
        elif "turn" in content_lower or "'s turn" in content_lower: # General turn info
            color_hex = self.current_settings.get("color_log_turn", "#0064C8") # Default light blue for turn
        elif "combat started" in content_lower or "combat ended" in content_lower or "victory!" in content_lower or "defeat!" in content_lower or "fled!" in content_lower or "surrender" in content_lower:
            color_hex = self.current_settings.get("color_log_combat_event", "#FFFFFF") # Default white for major combat events
            is_bold = True
        elif "misses" in content_lower or "fails" in content_lower or "resisted" in content_lower or "escape fails" in content_lower or "fumble" in content_lower:
            color_hex = self.current_settings.get("color_log_miss", "#969696") # Default gray for miss/fail
            is_italic = True
        elif "damage" in content_lower or ("loses" in content_lower and ("hp" in content_lower or "resolve" in content_lower)):
            color_hex = self.current_settings.get("color_log_damage", "#C80000") # Default dark red for damage
        elif "roll" in content_lower or "vs" in content_lower: # Dice rolls
            color_hex = self.current_settings.get("color_log_roll", "#C87800") # Default orange for rolls
        elif role_lower == "system":
            color_hex = self.current_settings.get("color_log_system_message", self.current_settings.get("color_log_default", "#E0E0E0"))
        elif role_lower == "gm": # Narrative content
            color_hex = self.current_settings.get("color_log_narrative", self.current_settings.get("color_log_default", "#E0E0E0"))
        elif event_content.startswith("[DEV]"): # Dev messages
            color_hex = self.current_settings.get("color_log_dev", "#646464"); is_italic = True;

        text_format = QTextCharFormat()
        try:
            text_format.setForeground(QColor(color_hex))
        except ValueError: # Fallback if color_hex is invalid
            logger.warning(f"Invalid color hex '{color_hex}' for combat log. Using default.")
            text_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0")))

        if is_bold: text_format.setFontWeight(QFont.Weight.Bold)
        if is_italic: text_format.setFontItalic(True)
        
        # Use the existing method to append with the determined format
        self._append_formatted_text(event_content, text_format, gradual=is_gradual)
```

### File: gui\components\command_input.py

```python
#!/usr/bin/env python3
"""
Command input widget for the RPG game GUI.
This module provides a widget for entering commands.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QLineEdit, QPushButton, 
    QCompleter, QVBoxLayout, QListWidget, QFrame
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QIcon, QPalette, QBrush, QPixmap

from gui.utils.resource_manager import get_resource_manager

class CommandInputWidget(QFrame):
    """Widget for entering commands."""
    
    # Signal emitted when a command is submitted
    command_submitted = Signal(str)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the command input widget."""
        super().__init__(parent)
        
        # Set frame properties
        self.setFrameShape(QFrame.StyledPanel)
        self.setContentsMargins(0, 0, 0, 0)
        
        # Command history
        self.command_history: List[str] = []
        self.history_index = -1
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Set frame background to transparent
        self.setStyleSheet("""
            CommandInputWidget {
                background-color: transparent;
                border: none;
            }
        """)
        
        # Create the command line edit with semi-transparent white background
        self.command_edit = QLineEdit()
        self.command_edit.setPlaceholderText("Enter a command or type 'help'...")
        self.command_edit.setStyleSheet("""
            QLineEdit {
                background-color: rgba(255, 255, 255, 0.7);
                color: #2e2e2e;
                border: 1px solid #c4b59d;
                border-radius: 4px;
                padding: 8px;
                font-family: 'Garamond', serif;
                font-size: 14pt;
                margin-left: 5px;
                margin-right: 5px;
            }
        """)
        
        # Create the submit button with generic button styling
        self.submit_button = QPushButton("Enter")
        self.submit_button.setStyleSheet("""
            QPushButton {
                background-image: url('images/gui/button_normal.png');
                background-position: center;
                background-repeat: no-repeat;
                background-color: transparent;
                color: #2e2e2e;
                border: none;
                padding: 8px 15px;
                font-weight: bold;
                font-family: 'Times New Roman', serif;
                min-width: 80px;
                min-height: 30px;
                max-width: 100px;
                margin-right: 5px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-image: url('images/gui/button_hover.png');
            }
            QPushButton:pressed {
                background-image: url('images/gui/button_pressed.png');
                color: #FF0000;
                font-weight: bold;
            }
        """)
        # Add widgets to the layout
        layout.addWidget(self.command_edit, 1)
        layout.addWidget(self.submit_button)
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Connect the submit button click
        self.submit_button.clicked.connect(self._submit_command)
        
        # Connect the command edit return key
        self.command_edit.returnPressed.connect(self._submit_command)
        
        # Connect the command edit key press event
        self.command_edit.keyPressEvent = self._command_key_press
    
    def _submit_command(self):
        """Submit the current command."""
        # Get the command text
        command = self.command_edit.text().strip()
        
        # Skip if empty
        if not command:
            return
        
        # Add to history
        if not self.command_history or self.command_history[-1] != command:
            self.command_history.append(command)
            if len(self.command_history) > 50:
                self.command_history.pop(0)
        
        # Reset history index
        self.history_index = -1
        
        # Emit signal
        self.command_submitted.emit(command)
        
        # Clear the edit
        self.command_edit.clear()
    
    def _command_key_press(self, event):
        """Handle key press events for the command edit."""
        # Check for up/down arrow keys for command history
        if event.key() == Qt.Key_Up:
            self._navigate_history(1)
        elif event.key() == Qt.Key_Down:
            self._navigate_history(-1)
        else:
            # Default handling
            QLineEdit.keyPressEvent(self.command_edit, event)
    
    def _navigate_history(self, direction: int):
        """Navigate the command history.
        
        Args:
            direction: 1 for older commands, -1 for newer commands.
        """
        if not self.command_history:
            return
        
        # Update history index
        new_index = self.history_index + direction
        
        # Clamp index
        if new_index >= len(self.command_history):
            new_index = len(self.command_history) - 1
        elif new_index < -1:
            new_index = -1
        
        self.history_index = new_index
        
        # Set text from history or clear
        if self.history_index == -1:
            self.command_edit.clear()
        else:
            self.command_edit.setText(self.command_history[-(self.history_index+1)])
            self.command_edit.selectAll()
    
    def clear(self):
        """Clear the command input."""
        self.command_edit.clear()

```

### File: gui\components\game_menu.py

```python
#!/usr/bin/env python3
"""
Game menu widget for the RPG game GUI.
This module provides a widget for game menu options.
"""

import logging
from typing import Optional

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QPushButton, QButtonGroup, 
    QMenu, QToolButton, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon

class GameMenuWidget(QWidget):
    """Widget for game menu options."""
    
    # Signals for menu actions
    new_game_requested = Signal()
    save_game_requested = Signal()
    load_game_requested = Signal()
    settings_requested = Signal()
    llm_settings_requested = Signal()
    exit_requested = Signal()
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the game menu widget."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 5, 0, 5)
        
        # Style for buttons
        button_style = """
            QPushButton, QToolButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                font-weight: bold;
            }
            QPushButton:hover, QToolButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed, QToolButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
        """
        
        # Create menu buttons
        self.new_game_button = QPushButton("New Game")
        self.new_game_button.setStyleSheet(button_style)
        self.new_game_button.clicked.connect(self.new_game_requested.emit)
        
        # Save game button
        self.save_button = QPushButton("Save")
        self.save_button.setStyleSheet(button_style)
        self.save_button.clicked.connect(self.save_game_requested.emit)
        
        # Load game button
        self.load_button = QPushButton("Load")
        self.load_button.setStyleSheet(button_style)
        self.load_button.clicked.connect(self.load_game_requested.emit)
        
        # Settings button with dropdown
        self.settings_button = QToolButton()
        self.settings_button.setText("Settings")
        self.settings_button.setStyleSheet(button_style)
        self.settings_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        
        self.settings_menu = QMenu(self.settings_button)
        self.settings_action = self.settings_menu.addAction("Game Settings")
        self.settings_action.triggered.connect(self.settings_requested.emit)
        
        self.llm_settings_action = self.settings_menu.addAction("LLM Settings")
        self.llm_settings_action.triggered.connect(self.llm_settings_requested.emit)
        
        self.graphics_action = self.settings_menu.addAction("Graphics Settings")
        self.sound_action = self.settings_menu.addAction("Sound Settings")
        
        self.settings_button.setMenu(self.settings_menu)
        self.settings_button.setPopupMode(QToolButton.InstantPopup)
        
        # Exit button
        self.exit_button = QPushButton("Exit")
        self.exit_button.setStyleSheet(button_style)
        self.exit_button.clicked.connect(self.exit_requested.emit)
        
        # Add spacer to push buttons to the left
        layout.addWidget(self.new_game_button)
        layout.addWidget(self.save_button)
        layout.addWidget(self.load_button)
        layout.addWidget(self.settings_button)
        layout.addStretch()
        layout.addWidget(self.exit_button)

```

### File: gui\components\game_output.py

```python
# --- START OF FILE game_output.py ---

"""
Game output widget for the RPG game GUI.
This module provides a widget for displaying game output.
"""

import logging
from typing import List, Optional, Dict, Any, Iterator, Tuple

from PySide6.QtWidgets import QTextEdit, QWidget, QVBoxLayout, QStackedLayout, QHBoxLayout, QFrame, QColorDialog
from PySide6.QtGui import QTextCursor, QColor, QTextCharFormat, QFont, QPalette, QPixmap, QBrush
from PySide6.QtCore import Qt, QTimer, Signal, QSettings

from core.utils.logging_config import get_logger
from gui.components.skill_check_display import SkillCheckDisplay
from gui.utils.resource_manager import get_resource_manager
from core.stats.skill_check import SkillCheckResult

logger = get_logger("GUI")

class GameOutputWidget(QFrame):
    """Widget for displaying game output."""

    # --- ECFA Change: Add visualDisplayComplete signal ---
    visualDisplayComplete = Signal()
    # --- End ECFA Change ---

    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the game output widget."""
        super().__init__(parent)

        self.setFrameShape(QFrame.StyledPanel)
        self.setContentsMargins(0, 0, 0, 0)
        self.setStyleSheet("""
            GameOutputWidget {
                background-color: transparent;
                border: none;
            }
        """)

        self.resource_manager = get_resource_manager()
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setAcceptRichText(True)

        self.settings = QSettings("RPGGame", "Settings") 

        system_color = self.settings.value("style/system_msg_color", "#FF0000")
        font_color = self.settings.value("style/font_color", "#000000")
        font_family = self.settings.value("style/font_family", "Garamond")
        font_size = int(self.settings.value("style/font_size", 14))

        self.system_format = QTextCharFormat()
        self.system_format.setForeground(QColor(system_color))
        self.system_format.setFontWeight(QFont.Bold)

        self.gm_format = QTextCharFormat()
        self.gm_format.setForeground(QColor(font_color))
        gm_font = QFont(font_family, font_size)
        self.gm_format.setFont(gm_font)

        user_input_font_family = self.settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(self.settings.value("style/user_input_font_size", 14))
        user_input_font_color = self.settings.value("style/user_input_font_color", "#0d47a1")

        self.player_format = QTextCharFormat()
        self.player_format.setForeground(QColor(user_input_font_color))
        player_font = QFont(user_input_font_family, user_input_font_size)
        player_font.setItalic(True)  
        self.player_format.setFont(player_font)

        self.default_format = QTextCharFormat()
        self.default_format.setForeground(QColor(font_color))  
        default_font = QFont(font_family, font_size)
        self.default_format.setFont(default_font)

        self._setup_background()

        self.skill_check_display = SkillCheckDisplay()
        self.skill_check_display.setVisible(False)
        self.skill_check_display.display_finished.connect(self._on_skill_check_finished)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(0)

        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.addWidget(self.text_edit)

        self.skill_check_layout = QHBoxLayout()
        self.skill_check_layout.setContentsMargins(0, 0, 0, 0)
        self.skill_check_layout.setAlignment(Qt.AlignCenter)
        self.skill_check_layout.addWidget(self.skill_check_display)
        self.content_layout.addLayout(self.skill_check_layout)

        self.main_layout.addWidget(self.content_widget)

        self._gradual_text_iterator: Optional[Iterator[str]] = None
        self._gradual_text_format: Optional[QTextCharFormat] = None
        self._gradual_timer: Optional[QTimer] = None 
        self._is_gradual_display_active: bool = False
        self._pending_immediate_messages: List[Tuple[str, QTextCharFormat]] = [] # Changed to list for queueing

    def _update_formats(self):
        """Update text formats based on current settings."""
        settings = self.settings # Use self.settings

        # Update system message format
        system_color = settings.value("style/system_msg_color", "#FF0000")
        self.system_format.setForeground(QColor(system_color))

        # Update GM/narrator format
        font_color = settings.value("style/font_color", "#000000")
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))

        self.gm_format.setForeground(QColor(font_color))
        gm_font = QFont(font_family, font_size)
        self.gm_format.setFont(gm_font)

        # Update player format
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")

        self.player_format.setForeground(QColor(user_input_font_color))
        player_font = QFont(user_input_font_family, user_input_font_size)
        player_font.setItalic(True)
        self.player_format.setFont(player_font)

        # Update default format
        self.default_format.setForeground(QColor(font_color))
        default_font = QFont(font_family, font_size)
        self.default_format.setFont(default_font)

    def _setup_background(self):
        """Set up the styled background for the game output."""
        settings = self.settings # Use self.settings

        # Get background color, font family, font size, and font color from settings
        bg_color = settings.value("style/output_bg_color", "#D2B48C")
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        font_color = settings.value("style/font_color", "#000000")
        texture_name = settings.value("style/texture_name", "subtle_noise")
        output_opacity = int(settings.value("style/output_opacity", 100))

        # Calculate background opacity
        opacity_percent = output_opacity / 80.0

        # Create a frame around the text edit with decorative border
        self.setStyleSheet(f"""
            GameOutputWidget {{
                background-color: transparent;
                border: 2px solid #333333; /* Dark gray border to match panels */
                border-radius: 18px;
                padding: 3px;
            }}
        """)

        # Create a background-image URL based on texture name
        texture_path = ""
        if texture_name != "none":
            texture_path = f"background-image: url('images/gui/textures/{texture_name}.png');\n                background-repeat: repeat;\n"

        # Apply styled background with rounded edges
        self.text_edit.setStyleSheet(f"""
            QTextEdit {{
                background-color: rgba({int(QColor(bg_color).red())},
                                    {int(QColor(bg_color).green())},
                                    {int(QColor(bg_color).blue())},
                                    {opacity_percent});
                {texture_path}
                color: {font_color};
                border: none;
                border-radius: 15px;
                font-family: '{font_family}';
                font-size: {font_size}pt;
                padding: 20px;
                margin-left: 5px;
                margin-right: 5px;
            }}
            QScrollBar:vertical {{
                border: none;
                background-color: rgba(0, 0, 0, 20);
                width: 12px;
                border-radius: 6px;
                margin: 0px;
            }}
            QScrollBar::handle:vertical {{
                background-color: rgba(80, 80, 80, 150);
                min-height: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                height: 0px;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}
        """)

    def append_text(self, text: str, format: Optional[QTextCharFormat] = None, gradual: bool = True):
        """Append text to the output with the specified format.

        Args:
            text: The text to append
            format: The text format to apply
            gradual: Whether to display the text gradually (respects settings)
        """
        format_name = "None" # For logging
        if format == self.gm_format: format_name = "gm_format"
        elif format == self.system_format: format_name = "system_format"
        elif format == self.player_format: format_name = "player_format"
        elif format == self.default_format: format_name = "default_format"
        logging.debug(f"GameOutputWidget.append_text: Format: '{format_name}', Requested Gradual: {gradual}, Active Gradual: {self._is_gradual_display_active}, Text: '{text[:50]}...'")

        # Determine if gradual display should actually be used based on request AND global setting
        gradual_display_enabled_by_setting = self.settings.value("display/gradual_text_narrative", True, type=bool)
        effective_gradual = gradual and gradual_display_enabled_by_setting
        
        # Override for specific welcome/background texts to always be immediate
        if "CHARACTER BACKGROUND" in text.upper() or "WELCOME TO YOUR ADVENTURE" in text.upper() or "WELCOME BACK" in text.upper():
            logging.info("Special text detected, forcing immediate display for GameOutputWidget.")
            effective_gradual = False

        if not text.strip():
            logging.warning("GameOutputWidget: Attempting to append empty text, ignoring.")
            self.visualDisplayComplete.emit() 
            return

        if not effective_gradual and self._is_gradual_display_active:
            logging.info(f"GameOutputWidget: Queueing immediate message '{text[:50]}...' as a gradual display is active.")
            self._pending_immediate_messages.append((text, format if format else self.default_format))
            return

        if not self._is_gradual_display_active: # Can only start new display if not already active
            if not effective_gradual:
                logging.debug("GameOutputWidget: Appending immediate message directly.")
                self._insert_text_immediately(text, format) 
                self.visualDisplayComplete.emit() 
                self._process_pending_immediate_messages() 
            else:
                logging.debug(f"GameOutputWidget: Starting gradual display: '{text[:50]}...'")
                self._is_gradual_display_active = True
                # Ensure pending immediate queue is cleared *before* starting new gradual display
                # if any were processed just before this.
                if self._pending_immediate_messages:
                    logger.warning("GameOutputWidget: Starting new gradual display while pending immediate messages existed. This might indicate a logic flaw if they weren't processed.")
                    # self._process_pending_immediate_messages() # Process them now before starting new gradual one.

                self._gradual_text_iterator = iter(text)
                self._gradual_text_format = format if format else self.default_format

                cursor = self.text_edit.textCursor()
                cursor.movePosition(QTextCursor.End)
                self.text_edit.setTextCursor(cursor)

                if not self._gradual_timer:
                     self._gradual_timer = QTimer(self)
                     self._gradual_timer.setSingleShot(True)
                     self._gradual_timer.timeout.connect(self._display_next_char)
                
                char_delay_initial = self.settings.value("display/text_speed_delay_narrative", 30, type=int)
                char_delay_initial = max(1, char_delay_initial) # Ensure at least 1ms for timer
                QTimer.singleShot(char_delay_initial, self._display_next_char) # Start with configured delay
        else: # Gradual display is already active
            if effective_gradual: 
                logger.warning(f"GameOutputWidget: Ignoring NEW gradual text '{text[:30]}' because a gradual display is ALREADY active. This text should have been queued by the Orchestrator.")
                # To prevent stalling, immediately emit completion for this ignored text.
                self.visualDisplayComplete.emit()
            # If it was an *immediate* message while gradual was active, it was already queued above.

    def _insert_text_immediately(self, text: str, format: Optional[QTextCharFormat]):
        """Helper to append text immediately and add newlines."""
        cursor = self.text_edit.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.text_edit.setTextCursor(cursor)
        
        current_format = format if format else self.default_format
        cursor.setCharFormat(current_format)
        
        cursor.insertText(text)
        if not text.endswith('\n'):
            cursor.insertText('\n')
        cursor.insertText('\n') # Extra blank line
        self.text_edit.ensureCursorVisible()

    def _process_pending_immediate_messages(self):
        """Processes any queued immediate messages if gradual display is not active."""
        if self._is_gradual_display_active:
            return # Don't process if gradual is still running
        
        while self._pending_immediate_messages:
            text, text_format = self._pending_immediate_messages.pop(0)
            logging.info(f"GameOutputWidget: Processing pending immediate message '{text[:50]}...'")
            self._insert_text_immediately(text, text_format)
            # Emitting visualDisplayComplete for each processed pending message
            # might be too chatty for the orchestrator.
            # The orchestrator should ideally wait for the original gradual display to finish,
            # then this queue is flushed, and *then* the "overall" completion is signaled.
            # However, for simplicity, let's emit for each. Orchestrator must handle this.
            self.visualDisplayComplete.emit()

    def _display_next_char(self):
        """Displays the next character from the iterator and schedules the next call."""
        if not self._is_gradual_display_active or not self._gradual_text_iterator:
            if self._is_gradual_display_active: 
                self._is_gradual_display_active = False
                self.visualDisplayComplete.emit()
                self._process_pending_immediate_messages() 
            return

        try:
            char = next(self._gradual_text_iterator)
            cursor = self.text_edit.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.text_edit.setTextCursor(cursor)

            if self._gradual_text_format:
                cursor.setCharFormat(self._gradual_text_format)
            cursor.insertText(char)
            self.text_edit.ensureCursorVisible()

            # --- ECFA Change: Use unified settings key ---
            char_delay = self.settings.value("display/text_speed_delay", 30, type=int) 
            # --- End ECFA Change ---
            char_delay = max(5, char_delay)
            
            if self._gradual_timer: 
                self._gradual_timer.start(char_delay)

        except StopIteration:
            logging.debug("GameOutputWidget: Gradual display finished for one segment.")
            cursor = self.text_edit.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.text_edit.setTextCursor(cursor)
            if not self.text_edit.toPlainText().endswith('\n\n'): 
                 if self.text_edit.toPlainText().endswith('\n'):
                     cursor.insertText('\n')
                 else:
                     cursor.insertText('\n\n')
            self.text_edit.ensureCursorVisible()

            self._is_gradual_display_active = False
            self._gradual_text_iterator = None
            self._gradual_text_format = None
            
            self.visualDisplayComplete.emit() 
            
            self._process_pending_immediate_messages()

        except Exception as e:
             logging.error(f"GameOutputWidget: Error during gradual display: {e}", exc_info=True)
             self._is_gradual_display_active = False
             self._gradual_text_iterator = None
             self._gradual_text_format = None
             if self._gradual_timer and self._gradual_timer.isActive():
                 self._gradual_timer.stop()
             self.visualDisplayComplete.emit() 
             self._pending_immediate_messages.clear()
             self._process_pending_immediate_messages() 
             
    def _insert_text(self, text: str, format: Optional[QTextCharFormat] = None):
        """Helper method to insert text directly with a format."""
        cursor = self.text_edit.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.text_edit.setTextCursor(cursor)
        if format:
            cursor.setCharFormat(format)
        else:
            cursor.setCharFormat(self.default_format) # Fallback to default
        cursor.insertText(text)
        self.text_edit.ensureCursorVisible()

    def append_system_message(self, message: str, gradual: bool = False):
        """Append a system message."""
        logging.debug(f"GAME_OUTPUT: append_system_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        self.append_text("[SYSTEM] " + message, self.system_format, gradual=gradual)

    def append_gm_message(self, message: str, gradual: bool = True):
        """Append a game master message."""
        logging.debug(f"GAME_OUTPUT: append_gm_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        
        # Special logging for reintroductory narrative debugging
        if "night air" in message.lower() or "find yourself" in message.lower():
            logging.info(f"LIFECYCLE_DEBUG: append_gm_message - This appears to be reintroductory narrative")
            logging.info(f"LIFECYCLE_DEBUG: Message length: {len(message)}")
            logging.info(f"LIFECYCLE_DEBUG: Gradual setting: {gradual}")
            logging.info(f"LIFECYCLE_DEBUG: Current gradual display active: {self._is_gradual_display_active}")
            logging.info(f"LIFECYCLE_DEBUG: Message preview: '{message[:200]}...'")
        
        processed_message = "\n".join(message.split("\n"))
        if "===== CHARACTER BACKGROUND =====" in message:
            logging.info("Character background detected, using immediate display for GM message")
            gradual = False
            
        logging.info(f"LIFECYCLE_DEBUG: About to call append_text with gradual={gradual}")
        self.append_text(processed_message, self.gm_format, gradual=gradual)
        logging.info(f"LIFECYCLE_DEBUG: append_text call completed")

    def append_player_message(self, message: str, gradual: bool = False):
        """Append a player message."""
        logging.debug(f"GAME_OUTPUT: append_player_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        self.append_text("You: " + message, self.player_format, gradual=gradual)

    def clear(self):
        """Clear the output."""
        # Stop any gradual display and clear state before clearing
        if self._gradual_timer and self._gradual_timer.isActive():
            self._gradual_timer.stop()
        self._is_gradual_display_active = False
        self._gradual_text_iterator = None
        self._gradual_text_format = None
        self._pending_immediate_message = None
        # Clear the text edit
        self.text_edit.clear()

    def show_skill_check(self, result: SkillCheckResult, context: str = "", duration_ms: int = 3000) -> None:
        """
        Display a skill check result with animation.

        Args:
            result: The SkillCheckResult object containing the check details
            context: Optional context description for the check
            duration_ms: How long to display the result (in milliseconds)
        """
        # Stop any gradual display and clear state before showing skill check
        if self._gradual_timer and self._gradual_timer.isActive():
            logging.debug("Stopping gradual display for skill check.")
            self._gradual_timer.stop()
        self._is_gradual_display_active = False
        self._gradual_text_iterator = None
        self._gradual_text_format = None
        self._pending_immediate_message = None

        # Show the skill check
        self.skill_check_display.show_check_result(result, context, duration_ms)

    def _on_skill_check_finished(self) -> None:
        """
        Handler for when the skill check display is finished.
        Returns focus to the text edit.
        """
        # Ensure the text edit is visible and has focus
        self.text_edit.setFocus()

    def process_skill_check_command(self, command: str) -> bool:
        """
        Process a skill check command from the narrative.

        Args:
            command: The command string in format {STAT_CHECK:<stat>:<difficulty>:<context>}

        Returns:
            True if the command was processed successfully, False otherwise
        """
        from core.agents.rule_checker import get_rule_checker_agent

        try:
            # Parse the command format {STAT_CHECK:<stat>:<difficulty>:<context>}
            parts = command.strip().split(':')
            if len(parts) < 3:
                logging.warning(f"Invalid STAT_CHECK command format: {command}")
                return False

            stat_type = parts[1].strip().upper()
            difficulty = int(parts[2].strip())
            context = parts[3].strip() if len(parts) > 3 else ""

            # Get the rule checker agent to perform the skill check
            rule_checker = get_rule_checker_agent()
            check_result = rule_checker.perform_skill_check(stat_type, difficulty, context)

            if not check_result["success"]:
                logging.error(f"Skill check failed: {check_result.get('error', 'Unknown error')}")
                return False

            # Display the skill check result
            self.show_skill_check(check_result["result"], check_result["context"])

            return True

        except Exception as e:
            logging.error(f"Error processing skill check command: {e}")
            return False

    def stop_gradual_display(self):
        """Immediately stops any ongoing gradual text display and processes pending messages quickly."""
        logging.info("GameOutputWidget: Stopping current gradual display and flushing pending messages.")
        if self._gradual_timer and self._gradual_timer.isActive():
            self._gradual_timer.stop()
        
        # If an iterator was active, display remaining text immediately
        if self._gradual_text_iterator:
            remaining_text = "".join(list(self._gradual_text_iterator))
            if remaining_text:
                self._insert_text_immediately(remaining_text, self._gradual_text_format)
            self._gradual_text_iterator = None
            self._gradual_text_format = None

        self._is_gradual_display_active = False # Mark as not active
        
        # Process all pending immediate messages
        self._process_pending_immediate_messages()
            
        # Emit completion after flushing everything, if no pending messages started new gradual display
        if not self._is_gradual_display_active:
            self.visualDisplayComplete.emit()
```

### File: gui\components\inventory_panel.py

```python
#!/usr/bin/env python3
"""
Inventory panel widget for the RPG game GUI.
This module provides a widget for displaying and interacting with the player's inventory.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QScrollArea, QFrame, QGroupBox, QListWidget, QListWidgetItem,
    QPushButton, QMenu, QToolButton, QSizePolicy, QComboBox, QLineEdit
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont, QPixmap, QIcon, QCursor, QColor

from core.inventory.item_manager import get_inventory_manager
from core.inventory.item_enums import ItemType
from core.utils.logging_config import get_logger

logger = get_logger("INVENTORY")

class InventoryPanelWidget(QScrollArea):
    """Widget for displaying and interacting with inventory."""
    
    # Signals for inventory actions
    item_use_requested = Signal(str)
    item_examine_requested = Signal(str)
    item_equip_requested = Signal(str)
    item_unequip_requested = Signal(str)
    item_drop_requested = Signal(str)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the inventory panel widget."""
        super().__init__(parent)
        
        # Set up the scroll area
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setStyleSheet("""
            QScrollArea {
                background-color: #2D2D30;
                border: none;
            }
        """)
        
        # Create the main widget
        self.inventory_widget = QWidget()
        self.setWidget(self.inventory_widget)
        
        # Initialize item list
        self.items = []
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self.inventory_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Create inventory header
        self._create_header()
        
        # Create item list section
        self._create_item_list()
        
        # Create item details section
        self._create_item_details()
    
    def _create_header(self):
        """Create the inventory header section."""
        # Create header layout
        header_layout = QHBoxLayout()
        
        # Create currency group
        currency_group = QGroupBox("Currency")
        currency_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        currency_layout = QHBoxLayout(currency_group)
        
        # Create labels for currency
        gold_label = QLabel("Gold:")
        gold_label.setStyleSheet("color: #FFD700; font-weight: bold;")
        self.gold_value = QLabel("0")
        self.gold_value.setStyleSheet("color: #FFD700;")
        
        silver_label = QLabel("Silver:")
        silver_label.setStyleSheet("color: #C0C0C0; font-weight: bold;")
        self.silver_value = QLabel("0")
        self.silver_value.setStyleSheet("color: #C0C0C0;")
        
        copper_label = QLabel("Copper:")
        copper_label.setStyleSheet("color: #B87333; font-weight: bold;")
        self.copper_value = QLabel("0")
        self.copper_value.setStyleSheet("color: #B87333;")
        
        # Add currency labels to layout
        currency_layout.addWidget(gold_label)
        currency_layout.addWidget(self.gold_value)
        currency_layout.addWidget(silver_label)
        currency_layout.addWidget(self.silver_value)
        currency_layout.addWidget(copper_label)
        currency_layout.addWidget(self.copper_value)
        
        # Create weight group
        weight_group = QGroupBox("Weight")
        weight_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        weight_layout = QHBoxLayout(weight_group)
        
        # Create labels for weight
        current_weight_label = QLabel("Current:")
        current_weight_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.current_weight_value = QLabel("0.0")
        self.current_weight_value.setStyleSheet("color: #E0E0E0;")
        
        max_weight_label = QLabel("Max:")
        max_weight_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.max_weight_value = QLabel("50.0")
        self.max_weight_value.setStyleSheet("color: #E0E0E0;")
        
        # Add weight labels to layout
        weight_layout.addWidget(current_weight_label)
        weight_layout.addWidget(self.current_weight_value)
        weight_layout.addWidget(max_weight_label)
        weight_layout.addWidget(self.max_weight_value)
        
        # Add groups to header layout
        header_layout.addWidget(currency_group)
        header_layout.addWidget(weight_group)
        
        # Add header layout to main layout
        self.main_layout.addLayout(header_layout)
    
    def _create_item_list(self):
        """Create the item list section."""
        # Create item list group
        item_list_group = QGroupBox("Items")
        item_list_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        item_list_layout = QVBoxLayout(item_list_group)
        
        # Create filter layout
        filter_layout = QHBoxLayout()
        
        # Create filter combobox
        filter_label = QLabel("Type:")
        filter_label.setStyleSheet("color: #BBBBBB;")
        
        self.filter_combo = QComboBox()
        # Populate from ItemType enum; store enum value as userData, None for All
        self.filter_combo.addItem("All", None)
        for itype in ItemType:
            label = itype.value.replace('_', ' ').title()
            self.filter_combo.addItem(label, itype.value)
        self.filter_combo.setStyleSheet("""
            QComboBox {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QComboBox::drop-down {
                border: none;
                border-left: 1px solid #555555;
            }
            QComboBox QAbstractItemView {
                background-color: #2D2D30;
                color: #E0E0E0;
                selection-background-color: #0E639C;
            }
        """)
        
        # Add a name search field
        search_label = QLabel("Search:")
        search_label.setStyleSheet("color: #BBBBBB;")
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter by item name...")
        self.search_edit.setStyleSheet("""
            QLineEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
        """)
        # Connect filter changes
        self.filter_combo.currentIndexChanged.connect(self._on_filter_changed)
        self.search_edit.textChanged.connect(self._on_filter_changed)
        
        # Add filter components to layout
        filter_layout.addWidget(filter_label)
        filter_layout.addWidget(self.filter_combo)
        filter_layout.addWidget(search_label)
        filter_layout.addWidget(self.search_edit, 1)
        
        # Create item list
        self.item_list = QListWidget()
        self.item_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.item_list.setAlternatingRowColors(True)
        self.item_list.setSelectionMode(QListWidget.SingleSelection)
        
        # Add the filter layout and item list to the item list layout
        item_list_layout.addLayout(filter_layout)
        item_list_layout.addWidget(self.item_list)
        
        # Create action buttons layout (for Use, Examine, Equip, Drop)
        action_button_layout = QHBoxLayout()
        action_button_layout.setSpacing(5)
        
        # Style for buttons
        button_style = """
            QPushButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                min-height: 25px; /* Ensure consistent height */
            }
            QPushButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
            QPushButton:disabled {
                background-color: #2A2A2A;
                color: #666666;
                border-color: #444444;
            }
        """
        
        # Create action buttons
        self.use_button = QPushButton("Use")
        self.use_button.setStyleSheet(button_style)
        self.use_button.clicked.connect(self._on_use_clicked)
        
        self.examine_button = QPushButton("Examine")
        self.examine_button.setStyleSheet(button_style)
        self.examine_button.clicked.connect(self._on_examine_clicked)
        
        self.equip_button = QPushButton("Equip")
        self.equip_button.setStyleSheet(button_style)
        self.equip_button.clicked.connect(self._on_equip_clicked)
        
        self.drop_button = QPushButton("Drop")
        self.drop_button.setStyleSheet(button_style)
        self.drop_button.clicked.connect(self._on_drop_clicked)
        
        # Disable buttons initially
        self.use_button.setEnabled(False)
        self.examine_button.setEnabled(False)
        self.equip_button.setEnabled(False)
        self.drop_button.setEnabled(False)
        
        # Add buttons to button layout
        action_button_layout.addWidget(self.use_button)
        action_button_layout.addWidget(self.examine_button)
        action_button_layout.addWidget(self.equip_button)
        action_button_layout.addWidget(self.drop_button)
        
        # Add action button layout to item list layout
        item_list_layout.addLayout(action_button_layout)

        # Create and add the "Collect Dropped Items" button
        self.collect_items_button = self._create_collect_items_button()
        item_list_layout.addWidget(self.collect_items_button)
        
        # Add item list group to main layout
        self.main_layout.addWidget(item_list_group)
        
        # Connect item selection signal
        self.item_list.itemSelectionChanged.connect(self._on_item_selection_changed)
        
        # Connect right-click context menu
        self.item_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.item_list.customContextMenuRequested.connect(self._show_context_menu)
        
    def _on_filter_changed(self):
        """Refresh the displayed inventory when filter changes."""
        try:
            inv_manager = get_inventory_manager()
            self.update_inventory(inv_manager)
        except Exception:
            # Safe fallback if inventory not available yet
            pass
        
    def _create_item_details(self):
        """Create the item details section."""
        # Create item details group
        item_details_group = QGroupBox("Item Details")
        item_details_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        item_details_layout = QVBoxLayout(item_details_group)
        
        # Create labels for item details
        self.item_name_label = QLabel("No item selected")
        self.item_name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #E0E0E0;")
        
        self.item_type_label = QLabel("")
        self.item_type_label.setStyleSheet("font-size: 12pt; color: #CCCCCC;")
        
        self.item_description_label = QLabel("")
        self.item_description_label.setStyleSheet("color: #BBBBBB;")
        self.item_description_label.setWordWrap(True)
        
        # Add labels to item details layout
        item_details_layout.addWidget(self.item_name_label)
        item_details_layout.addWidget(self.item_type_label)
        item_details_layout.addWidget(self.item_description_label)
        
        # Create stats layout
        stats_layout = QGridLayout()
        
        # Add stats layout to item details layout
        item_details_layout.addLayout(stats_layout)
        
        # Add item details group to main layout
        self.main_layout.addWidget(item_details_group)
        
        # Add a stretch to push everything up
        self.main_layout.addStretch(1)
    
    def _on_item_selection_changed(self):
        """Handle item selection change."""
        logger.info("[INVENTORY] _on_item_selection_changed called.")
        selected_list_items = self.item_list.selectedItems()
        
        if not selected_list_items:
            logger.info("[INVENTORY] No item selected in QListWidget.")
            self.use_button.setEnabled(False)
            self.examine_button.setEnabled(False)
            self.equip_button.setEnabled(False)
            self.drop_button.setEnabled(False)
            self.item_name_label.setText("No item selected")
            self.item_type_label.setText("")
            self.item_description_label.setText("")
            logger.info("[INVENTORY] Buttons disabled, details cleared.")
            return
        
        list_item = selected_list_items[0]
        selected_item_id = list_item.data(Qt.UserRole) # Retrieve item_id
        logger.info(f"[INVENTORY] QListWidget selected item_id: {selected_item_id}")

        # Find the corresponding item dict in self.items (list of dicts)
        selected_item_dict = None
        for item_d in self.items:
            if item_d['id'] == selected_item_id:
                selected_item_dict = item_d
                break
        
        if not selected_item_dict:
            logger.error(f"[INVENTORY] CRITICAL: Selected item ID {selected_item_id} not found in internal self.items list. This should not happen if update_inventory is correct.")
            # Clear details and disable buttons as a fallback
            self.use_button.setEnabled(False); self.examine_button.setEnabled(False)
            self.equip_button.setEnabled(False); self.drop_button.setEnabled(False)
            self.item_name_label.setText("Error: Item not found"); self.item_type_label.setText(""); self.item_description_label.setText("")
            logger.info("[INVENTORY] Buttons disabled due to item not found in self.items.")
            return

        logger.info(f"[INVENTORY] Found item in self.items: {selected_item_dict.get('name')}")
        self.examine_button.setEnabled(True)
        self.drop_button.setEnabled(True)
        
        item_type_val = selected_item_dict.get('type', 'miscellaneous')
        is_equipped_val = selected_item_dict.get('equipped', False)

        can_use = item_type_val == 'consumable'
        self.use_button.setEnabled(can_use)
        
        can_be_equipped = item_type_val in ['weapon', 'armor', 'shield', 'accessory']
        if can_be_equipped:
            self.equip_button.setEnabled(True)
            self.equip_button.setText("Unequip" if is_equipped_val else "Equip")
        else:
            self.equip_button.setEnabled(False)
            self.equip_button.setText("Equip") 
        
        logger.info(f"[INVENTORY] Button states: Examine={self.examine_button.isEnabled()}, Drop={self.drop_button.isEnabled()}, Use={self.use_button.isEnabled()}, Equip={self.equip_button.isEnabled()} (Text: {self.equip_button.text()})")
            
        self.item_name_label.setText(selected_item_dict.get('name', 'Unknown Item'))
        self.item_type_label.setText(f"Type: {item_type_val.capitalize()}")
        
        inv_manager = get_inventory_manager() 
        full_item_obj = inv_manager.get_item(selected_item_id)
        if full_item_obj:
            self.item_description_label.setText(getattr(full_item_obj, 'description', 'No description available.'))
        else:
            self.item_description_label.setText(selected_item_dict.get('description', 'No description available.'))
            logger.warning(f"[INVENTORY] Could not fetch full Item object for ID {selected_item_id} to display description.")
            
    def _show_context_menu(self, position):
        """Show the context menu for the item list."""
        list_widget_item = self.item_list.itemAt(position)
        if not list_widget_item:
            return
        
        selected_item_id = list_widget_item.data(Qt.UserRole)
        if not selected_item_id:
            logger.warning("[INVENTORY] Context menu triggered on item with no ID.")
            return

        # Find the item dict in self.items to get its properties like type and equipped status
        item_dict = next((it_d for it_d in self.items if it_d['id'] == selected_item_id), None)
        if not item_dict:
            logger.error(f"[INVENTORY] Context menu: Item ID {selected_item_id} not found in internal self.items list.")
            return
        
        item_type_val = item_dict.get('type', 'miscellaneous')
        is_equipped_val = item_dict.get('equipped', False)
        item_name_for_log = item_dict.get('name', 'Unknown Item')

        logger.info(f"[INVENTORY] Showing context menu for item: '{item_name_for_log}' (ID: {selected_item_id})")

        context_menu = QMenu(self)
        context_menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #0E639C;
            }
        """)
        
        examine_action = context_menu.addAction("Examine")
        use_action = None
        if item_type_val == 'consumable':
            use_action = context_menu.addAction("Use")
        
        equip_action = None
        can_be_equipped = item_type_val in ['weapon', 'armor', 'shield', 'accessory']
        if can_be_equipped:
            equip_action_text = "Unequip" if is_equipped_val else "Equip"
            equip_action = context_menu.addAction(equip_action_text)
        
        drop_action = context_menu.addAction("Drop")
        
        action = context_menu.exec_(QCursor.pos())
        
        if action == examine_action:
            logger.info(f"[INVENTORY] Context menu: Examine selected for {selected_item_id}")
            self.item_examine_requested.emit(selected_item_id)
        elif use_action and action == use_action:
            logger.info(f"[INVENTORY] Context menu: Use selected for {selected_item_id}")
            self.item_use_requested.emit(selected_item_id)
        elif equip_action and action == equip_action:
            if is_equipped_val:
                logger.info(f"[INVENTORY] Context menu: Unequip selected for {selected_item_id}")
                self.item_unequip_requested.emit(selected_item_id) 
            else:
                logger.info(f"[INVENTORY] Context menu: Equip selected for {selected_item_id}")
                self.item_equip_requested.emit(selected_item_id)
        elif action == drop_action:
            logger.info(f"[INVENTORY] Context menu: Drop selected for {selected_item_id}")
            self.item_drop_requested.emit(selected_item_id)
        else:
            logger.debug(f"[INVENTORY] Context menu dismissed or unknown action for {selected_item_id}")
            
    def _on_use_clicked(self):
        """Handle use button click."""
        logger.info("[INVENTORY] _on_use_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Use clicked, but no item selected.")
            return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            logger.info(f"[INVENTORY] Emitting item_use_requested for item ID: {selected_item_id}")
            self.item_use_requested.emit(selected_item_id)
        else:
            logger.warning("[INVENTORY] Use clicked, selected item has no ID.")
    
    def _on_examine_clicked(self):
        """Handle examine button click."""
        logger.info("[INVENTORY] _on_examine_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Examine clicked, but no item selected.")
            return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            logger.info(f"[INVENTORY] Emitting item_examine_requested for item ID: {selected_item_id}")
            self.item_examine_requested.emit(selected_item_id)
        else:
            logger.warning("[INVENTORY] Examine clicked, selected item has no ID.")
    
    def _on_equip_clicked(self):
        """Handle equip/unequip button click."""
        logger.info("[INVENTORY] _on_equip_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Equip/Unequip clicked, but no item selected.")
            return
        
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if not selected_item_id: 
            logger.warning("[INVENTORY] Equip/Unequip clicked, selected item has no ID.")
            return

        item_dict = next((it_d for it_d in self.items if it_d['id'] == selected_item_id), None)
        if not item_dict: 
            logger.error(f"[INVENTORY] Equip/Unequip clicked, but item ID {selected_item_id} not found in self.items.")
            return

        # Directly emit signals, MainWindow will handle mechanically
        if item_dict.get('equipped', False):
            logger.info(f"[INVENTORY] Emitting item_unequip_requested for item ID: {selected_item_id} (from button)")
            self.item_unequip_requested.emit(selected_item_id) 
        else:
            logger.info(f"[INVENTORY] Emitting item_equip_requested for item ID: {selected_item_id} (from button)")
            self.item_equip_requested.emit(selected_item_id)

    def _on_unequip_clicked(self):
        """Handle unequip button click."""
        self._get_selected_item_id(self.item_unequip_requested)
    
    def _on_drop_clicked(self):
        """Handle drop button click."""
        logger.info("[INVENTORY] _on_drop_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Drop clicked, but no item selected.")
            return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            logger.info(f"[INVENTORY] Emitting item_drop_requested for item ID: {selected_item_id}")
            self.item_drop_requested.emit(selected_item_id)
        else:
            logger.warning("[INVENTORY] Drop clicked, selected item has no ID.")
    
    def _get_selected_item_id(self, signal):
        """Get the selected item ID and emit the signal."""
        # Get the selected item
        selected_items = self.item_list.selectedItems()
        
        if not selected_items:
            return
        
        # Get the item data
        item_index = self.item_list.row(selected_items[0])
        item = self.items[item_index]
        
        # Emit the signal with the item ID
        signal.emit(item.get('id', ''))
    
    def update_inventory(self, inventory_manager_instance: Optional[Any]): # Renamed for clarity
        """Update the inventory panel with inventory data.
        
        Args:
            inventory_manager_instance: The InventoryManager instance.
        """
        # Temporarily disconnect the signal to prevent issues during list update
        try:
            self.item_list.itemSelectionChanged.disconnect(self._on_item_selection_changed)
            logger.debug("InventoryPanelWidget: Disconnected itemSelectionChanged for update.")
        except (TypeError, RuntimeError):  # Catch if not connected or other Qt errors
            logger.debug("InventoryPanelWidget: itemSelectionChanged was not connected or error on disconnect.")
            pass 

        if not inventory_manager_instance:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")
            self.current_weight_value.setText("0.0")
            self.max_weight_value.setText("0.0") 
            self.item_list.clear()
            self.items = [] 
            # Reconnect the signal after clearing and before manual trigger
            self.item_list.itemSelectionChanged.connect(self._on_item_selection_changed)
            logger.debug("InventoryPanelWidget: Reconnected itemSelectionChanged after clear (no inventory manager).")
            self._on_item_selection_changed() 
            logger.warning("InventoryPanelWidget.update_inventory called with no InventoryManager instance.")
            return

        inv_manager = inventory_manager_instance
        logger.info(f"InventoryPanelWidget: Updating with InventoryManager instance ID: {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")


        if hasattr(inv_manager, 'currency') and inv_manager.currency:
            currency_obj = inv_manager.currency
            self.gold_value.setText(str(getattr(currency_obj, 'gold', 0)))
            self.silver_value.setText(str(getattr(currency_obj, 'silver', 0)))
            total_copper_val = getattr(currency_obj, '_copper', 0) 
            copper_per_silver_val = getattr(currency_obj, '_copper_per_silver', 100)
            self.copper_value.setText(str(total_copper_val % copper_per_silver_val))
        else:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")

        current_weight = getattr(inv_manager, 'get_current_weight', lambda: 0.0)()
        weight_limit = getattr(inv_manager, 'weight_limit', 0.0)
        self.current_weight_value.setText(f"{current_weight:.1f}")
        self.max_weight_value.setText(f"{weight_limit:.1f}")
        
        self.items = [] 
        self.item_list.clear()

        actual_item_objects = getattr(inv_manager, 'items', []) 
        
        logger.debug(f"InventoryPanel: Found {len(actual_item_objects)} item objects from InventoryManager instance {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}.")

        for item_obj in actual_item_objects:
            if not hasattr(item_obj, 'id') or not hasattr(item_obj, 'name') or not hasattr(item_obj, 'item_type'):
                logger.warning(f"InventoryPanel: Skipping item object due to missing attributes: {item_obj}")
                continue

            is_equipped_flag = False
            if hasattr(inv_manager, 'is_item_equipped'):
                is_equipped_flag = inv_manager.is_item_equipped(item_obj.id)
            
            gui_item_dict = {
                'id': item_obj.id,
                'name': item_obj.name,
                'type': item_obj.item_type.value.lower() if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type).lower(),
                'description': getattr(item_obj, 'description', ''),
                'count': getattr(item_obj, 'quantity', 1),
                'equipped': is_equipped_flag,
            }
            self.items.append(gui_item_dict) 

            # Unified filter: type (from ItemType) AND name query
            selected_type = self.filter_combo.currentData() if hasattr(self, 'filter_combo') else None
            item_type_for_filter = gui_item_dict.get('type', '').lower()
            name_query = (self.search_edit.text().strip().lower() if hasattr(self, 'search_edit') and self.search_edit else '')

            type_match = (selected_type is None) or (item_type_for_filter == str(selected_type).lower())
            item_name_display = gui_item_dict.get('name', 'Unknown Item')
            name_match = (not name_query) or (name_query in item_name_display.lower())

            if type_match and name_match:
                item_count_display = gui_item_dict.get('count', 1)
                list_widget_item = QListWidgetItem()
                display_text = item_name_display
                if item_count_display > 1 and getattr(item_obj, 'is_stackable', False):
                    display_text += f" ({item_count_display})"
                if gui_item_dict.get('equipped', False):
                    display_text += " (Equipped)"
                    list_widget_item.setForeground(QColor('#4CAF50')) 
                list_widget_item.setText(display_text)
                list_widget_item.setData(Qt.UserRole, gui_item_dict['id']) 
                self.item_list.addItem(list_widget_item)
        
        # Reconnect the signal and manually trigger update for item details
        self.item_list.itemSelectionChanged.connect(self._on_item_selection_changed)
        logger.debug("InventoryPanelWidget: Reconnected itemSelectionChanged after repopulation.")
        self._on_item_selection_changed() # Manually trigger to update details for the current selection (or no selection)

        logger.info(f"InventoryPanel updated with manager {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}. Displaying {self.item_list.count()} items after filter. Internal self.items count: {len(self.items)}.")
        """Update the inventory panel with inventory data.
        
        Args:
            inventory_manager_instance: The InventoryManager instance.
        """
        if not inventory_manager_instance:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")
            self.current_weight_value.setText("0.0")
            self.max_weight_value.setText("0.0") 
            self.item_list.clear()
            self.items = [] 
            self._on_item_selection_changed() 
            logger.warning("InventoryPanelWidget.update_inventory called with no InventoryManager instance.")
            return

        inv_manager = inventory_manager_instance
        logger.info(f"InventoryPanelWidget: Updating with InventoryManager instance ID: {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")


        if hasattr(inv_manager, 'currency') and inv_manager.currency:
            currency_obj = inv_manager.currency
            self.gold_value.setText(str(getattr(currency_obj, 'gold', 0)))
            self.silver_value.setText(str(getattr(currency_obj, 'silver', 0)))
            total_copper_val = getattr(currency_obj, '_copper', 0) 
            copper_per_silver_val = getattr(currency_obj, '_copper_per_silver', 100)
            self.copper_value.setText(str(total_copper_val % copper_per_silver_val))
        else:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")

        current_weight = getattr(inv_manager, 'get_current_weight', lambda: 0.0)()
        weight_limit = getattr(inv_manager, 'weight_limit', 0.0)
        self.current_weight_value.setText(f"{current_weight:.1f}")
        self.max_weight_value.setText(f"{weight_limit:.1f}")
        
        self.items = [] 
        self.item_list.clear()

        actual_item_objects = getattr(inv_manager, 'items', []) 
        
        logger.debug(f"InventoryPanel: Found {len(actual_item_objects)} item objects from InventoryManager instance {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}.")

        for item_obj in actual_item_objects:
            if not hasattr(item_obj, 'id') or not hasattr(item_obj, 'name') or not hasattr(item_obj, 'item_type'):
                logger.warning(f"InventoryPanel: Skipping item object due to missing attributes: {item_obj}")
                continue

            is_equipped_flag = False
            if hasattr(inv_manager, 'is_item_equipped'):
                is_equipped_flag = inv_manager.is_item_equipped(item_obj.id)
            
            gui_item_dict = {
                'id': item_obj.id,
                'name': item_obj.name,
                'type': item_obj.item_type.value.lower() if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type).lower(),
                'description': getattr(item_obj, 'description', ''),
                'count': getattr(item_obj, 'quantity', 1),
                'equipped': is_equipped_flag,
            }
            self.items.append(gui_item_dict) 

            # Unified filter: type (from ItemType) AND name query
            selected_type = self.filter_combo.currentData() if hasattr(self, 'filter_combo') else None
            item_type_for_filter = gui_item_dict.get('type', '').lower()
            name_query = (self.search_edit.text().strip().lower() if hasattr(self, 'search_edit') and self.search_edit else '')

            type_match = (selected_type is None) or (item_type_for_filter == str(selected_type).lower())
            item_name_display = gui_item_dict.get('name', 'Unknown Item')
            name_match = (not name_query) or (name_query in item_name_display.lower())

            if type_match and name_match:
                item_count_display = gui_item_dict.get('count', 1)
                list_widget_item = QListWidgetItem()
                display_text = item_name_display
                if item_count_display > 1 and getattr(item_obj, 'is_stackable', False):
                    display_text += f" ({item_count_display})"
                if gui_item_dict.get('equipped', False):
                    display_text += " (Equipped)"
                    list_widget_item.setForeground(QColor('#4CAF50')) 
                list_widget_item.setText(display_text)
                list_widget_item.setData(Qt.UserRole, gui_item_dict['id']) 
                self.item_list.addItem(list_widget_item)
        
        self._on_item_selection_changed()
        logger.info(f"InventoryPanel updated with manager {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}. Displaying {self.item_list.count()} items after filter. Internal self.items count: {len(self.items)}.")

    def _create_collect_items_button(self):
        """Creates the 'Collect Items' button."""
        self.collect_button = QPushButton("Collect Dropped Items")
        self.collect_button.setStyleSheet(self.use_button.styleSheet()) # Reuse style
        self.collect_button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed) # Expand horizontally
        self.collect_button.clicked.connect(self._on_collect_items_clicked)
        self.collect_button.setEnabled(True) # Assuming always enabled, logic can be added if needed
        return self.collect_button
    
    def _on_collect_items_clicked(self):
        """Handle the 'Collect Dropped Items' button click."""
        logger.info("[INVENTORY] Collect Dropped Items button clicked.")
        # This is where the dialog for showing dropped items at the current location would be displayed.
        # For now, let's log and maybe show a placeholder message.
        
        # Placeholder for actual dialog:
        from PySide6.QtWidgets import QMessageBox
        QMessageBox.information(self, "Collect Items", "Functionality to show and collect dropped items at this location is not yet implemented.")
        
        # Future implementation would involve:
        # 1. Get current player location from GameState.
        # 2. Access a (new) system that tracks dropped items per location (e.g., LocationItemManager).
        # 3. Populate a dialog (e.g., DroppedItemsDialog) with these items.
        # 4. DroppedItemsDialog would have its own "Examine" and "Collect" actions.
        #    - "Collect" would move the item from the location's dropped list to player inventory.
```

### File: gui\components\journal_panel.py

```python
#!/usr/bin/env python3
"""
Journal panel widget for the RPG game GUI.
This module provides a widget for displaying and editing the player's journal.
"""

import logging
from typing import Optional, Dict, Any, List
from enum import Enum

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QScrollArea, QFrame, QGroupBox, QListWidget, QListWidgetItem,
    QPushButton, QTabWidget, QTextEdit, QSplitter, QTabBar
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QFont, QTextCharFormat, QColor

from core.base.state import get_state_manager
from gui.utils.resource_manager import get_resource_manager


class JournalSectionType(Enum):
    """Types of journal sections."""
    CHARACTER = 0
    QUESTS = 1
    NOTES = 2


class JournalPanelWidget(QScrollArea):
    """Widget for displaying and editing the journal."""
    
    # Signals for journal actions
    journal_updated = Signal(dict)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the journal panel widget."""
        super().__init__(parent)
        
        # Set up the scroll area
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setStyleSheet("""
            QScrollArea {
                background-color: #2D2D30;
                border: none;
            }
        """)
        
        # Create the main widget
        self.journal_widget = QWidget()
        self.setWidget(self.journal_widget)
        
        # Journal data structure
        self.journal_data = {
            "character": "",
            "quests": {},
            "notes": []
        }
        
        # Get state manager
        self.state_manager = get_state_manager()
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self.journal_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Create tab widget for sections
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
            }
            QTabWidget::pane {
                background-color: #333333;
                border: 1px solid #555555;
                border-top: none;
                border-radius: 0 0 5px 5px;
            }
            QTabBar::tab {
                background-color: #444444;
                color: #BBBBBB;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                padding: 8px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #333333;
                color: #E0E0E0;
                border-bottom: none;
            }
            QTabBar::tab:hover:!selected {
                background-color: #505050;
            }
        """)
        
        # Add tabs for each section
        self._setup_character_tab()
        self._setup_quests_tab()
        self._setup_notes_tab()
        
        # Add tab widget to main layout
        self.main_layout.addWidget(self.tab_widget)
    
    def _setup_character_tab(self):
        """Set up the character information tab."""
        # Create character tab
        character_tab = QWidget()
        character_layout = QVBoxLayout(character_tab)
        
        # Create character info editor
        self.character_info_editor = QTextEdit()
        self.character_info_editor.setPlaceholderText("Character bio and information will appear here...")
        self.character_info_editor.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
        """)
        self.character_info_editor.textChanged.connect(self._on_character_info_changed)
        
        # Add editor to layout
        character_layout.addWidget(self.character_info_editor)
        
        # Add tab to tab widget
        self.tab_widget.addTab(character_tab, "Character")
    
    def _setup_quests_tab(self):
        """Set up the quests tab."""
        # Create quests tab
        quests_tab = QWidget()
        quests_layout = QVBoxLayout(quests_tab)
        
        # Create quest status tabs
        self.quest_status_tabs = QTabWidget()
        self.quest_status_tabs.setStyleSheet("""
            QTabBar::tab {
                background-color: #333333;
                color: #BBBBBB;
                border: 1px solid #444444;
                border-bottom: none;
                border-top-left-radius: 3px;
                border-top-right-radius: 3px;
                padding: 5px 10px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2D2D30;
                color: #E0E0E0;
                border-bottom: none;
            }
            QTabBar::tab:hover:!selected {
                background-color: #3A3A3A;
            }
        """)
        
        # Create lists for active, completed, and failed quests
        self.active_quests_list = QListWidget()
        self.active_quests_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.active_quests_list.setAlternatingRowColors(True)
        self.active_quests_list.itemClicked.connect(self._on_quest_selected)
        self.active_quests_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.active_quests_list.customContextMenuRequested.connect(self._show_active_context_menu)
        
        self.completed_quests_list = QListWidget()
        self.completed_quests_list.setStyleSheet(self.active_quests_list.styleSheet())
        self.completed_quests_list.setAlternatingRowColors(True)
        self.completed_quests_list.itemClicked.connect(self._on_quest_selected)
        self.completed_quests_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.completed_quests_list.customContextMenuRequested.connect(lambda pos: self._show_notes_only_context_menu(self.completed_quests_list, pos))
        
        self.failed_quests_list = QListWidget()
        self.failed_quests_list.setStyleSheet(self.active_quests_list.styleSheet())
        self.failed_quests_list.setAlternatingRowColors(True)
        self.failed_quests_list.itemClicked.connect(self._on_quest_selected)
        self.failed_quests_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.failed_quests_list.customContextMenuRequested.connect(lambda pos: self._show_notes_only_context_menu(self.failed_quests_list, pos))
        
        # Add lists to quest status tabs
        self.quest_status_tabs.addTab(self.active_quests_list, "Active")
        self.quest_status_tabs.addTab(self.completed_quests_list, "Completed")
        self.quest_status_tabs.addTab(self.failed_quests_list, "Failed")
        
        # Create quest details view
        self.quest_details = QTextEdit()
        self.quest_details.setReadOnly(True)
        self.quest_details.setPlaceholderText("Select a quest to view details...")
        self.quest_details.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
            /* Colored spans for objective states */
            .obj-done { color: #90EE90; } /* light green */
            .obj-failed { color: #FF7F7F; } /* light red */
            .obj-pending { color: #E0E0E0; }
            .obj-mandatory { color: #FFD27F; } /* amber M/O tags */
        """)
        
        # Create splitter for quest list and details
        quests_splitter = QSplitter(Qt.Vertical)
        quests_splitter.addWidget(self.quest_status_tabs)
        quests_splitter.addWidget(self.quest_details)
        quests_splitter.setSizes([int(quests_tab.height() * 0.4), int(quests_tab.height() * 0.6)])
        
        # Add splitter to layout
        quests_layout.addWidget(quests_splitter)
        
        # Add tab to tab widget
        self.tab_widget.addTab(quests_tab, "Quests")
    
    def _setup_notes_tab(self):
        """Set up the personal notes tab."""
        # Create notes tab
        notes_tab = QWidget()
        notes_layout = QVBoxLayout(notes_tab)
        
        # Create notes list
        self.notes_list = QListWidget()
        self.notes_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.notes_list.setAlternatingRowColors(True)
        self.notes_list.itemClicked.connect(self._on_note_selected)
        
        # Create note editor
        self.note_editor = QTextEdit()
        self.note_editor.setPlaceholderText("Select a note to edit or create a new one...")
        self.note_editor.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
        """)
        self.note_editor.textChanged.connect(self._on_note_text_changed)
        
        # Create buttons for note management
        button_layout = QHBoxLayout()
        
        # Style for buttons
        button_style = """
            QPushButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
            }
            QPushButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
            QPushButton:disabled {
                background-color: #2A2A2A;
                color: #666666;
                border-color: #444444;
            }
        """
        
        # Create buttons
        self.new_note_button = QPushButton("New Note")
        self.new_note_button.setStyleSheet(button_style)
        self.new_note_button.clicked.connect(self._on_new_note_clicked)
        
        self.delete_note_button = QPushButton("Delete Note")
        self.delete_note_button.setStyleSheet(button_style)
        self.delete_note_button.clicked.connect(self._on_delete_note_clicked)
        self.delete_note_button.setEnabled(False)
        
        self.save_note_button = QPushButton("Save Note")
        self.save_note_button.setStyleSheet(button_style)
        self.save_note_button.clicked.connect(self._on_save_note_clicked)
        self.save_note_button.setEnabled(False)
        
        # Add buttons to layout
        button_layout.addWidget(self.new_note_button)
        button_layout.addWidget(self.delete_note_button)
        button_layout.addStretch()
        button_layout.addWidget(self.save_note_button)
        
        # Create splitter for notes list and editor
        notes_splitter = QSplitter(Qt.Vertical)
        notes_splitter.addWidget(self.notes_list)
        
        # Create editor container with buttons
        editor_container = QWidget()
        editor_layout = QVBoxLayout(editor_container)
        editor_layout.setContentsMargins(0, 0, 0, 0)
        editor_layout.addWidget(self.note_editor)
        editor_layout.addLayout(button_layout)
        
        notes_splitter.addWidget(editor_container)
        notes_splitter.setSizes([int(notes_tab.height() * 0.3), int(notes_tab.height() * 0.7)])
        
        # Add splitter to layout
        notes_layout.addWidget(notes_splitter)
        
        # Add tab to tab widget
        self.tab_widget.addTab(notes_tab, "Notes")
    
    def _on_character_info_changed(self):
        """Handle character info text changes."""
        # Update journal data
        self.journal_data["character"] = self.character_info_editor.toPlainText()
        
        # Emit journal updated signal
        self._emit_journal_updated()
    
    def _on_quest_selected(self, item: QListWidgetItem):
        """Handle quest selection."""
        # Get the quest ID from the item
        quest_id = item.data(Qt.UserRole)
        
        # Get the quest data
        quest_status = self._get_current_quest_status()
        if quest_status and quest_id in self.journal_data["quests"]:
            quest_data = self.journal_data["quests"][quest_id]
            
            # Update quest details
            self.quest_details.clear()
            
            # Inline CSS to ensure colors are applied consistently
            style = (
                "<style>"
                ".obj-done{color:#6ac46a;}"
                ".obj-failed{color:#ff6b6b;}"
                ".obj-pending{color:#d0d0d0;}"
                ".obj-mandatory{color:#aaaaaa;font-style:italic;margin-left:6px;}"
                "</style>"
            )
            # Format the quest details
            html = style + f"<h2>{quest_data['title']}</h2>"
            html += f"<p><b>Status:</b> {quest_status}</p>"
            
            if "description" in quest_data:
                html += f"<p>{quest_data['description']}</p>"
            
            if "objectives" in quest_data and quest_data["objectives"]:
                html += "<h3>Objectives:</h3>"
                html += "<ul>"
                for objective in quest_data["objectives"]:
                    desc = objective.get('description', '')
                    completed = objective.get('completed', False)
                    failed = objective.get('failed', False)
                    mandatory = objective.get('mandatory', True)
                    tag = "(M)" if mandatory else "(O)"
                    # Build line with state class
                    cls = 'obj-pending'
                    if completed:
                        cls = 'obj-done'
                    elif failed:
                        cls = 'obj-failed'
                    # Tooltip for tag
                    tooltip = "Mandatory requirement" if mandatory else "Optional objective"
                    html += f"<li><span class='{cls}'>"
                    if completed:
                        html += f"<s>{desc}</s> <span class='obj-mandatory' title='{tooltip}'>{tag}</span>"
                    else:
                        html += f"{desc} <span class='obj-mandatory' title='{tooltip}'>{tag}</span>"
                    html += "</span></li>"
                html += "</ul>"
            
            if "rewards" in quest_data and quest_data["rewards"]:
                html += "<h3>Rewards:</h3>"
                html += "<ul>"
                for reward in quest_data["rewards"]:
                    html += f"<li>{reward}</li>"
                html += "</ul>"
            
            if "notes" in quest_data and quest_data["notes"]:
                html += "<h3>Notes:</h3>"
                html += f"<p>{quest_data['notes']}</p>"
            
            self.quest_details.setHtml(html)
    
    def _get_current_quest_status(self) -> Optional[str]:
        """Get the currently selected quest status tab."""
        current_tab_index = self.quest_status_tabs.currentIndex()
        if current_tab_index == 0:
            return "active"
        elif current_tab_index == 1:
            return "completed"
        elif current_tab_index == 2:
            return "failed"
        return None
    
    def _on_note_selected(self, item: QListWidgetItem):
        """Handle note selection."""
        # Get the note index from the item
        note_index = item.data(Qt.UserRole)
        
        # Enable delete and save buttons
        self.delete_note_button.setEnabled(True)
        self.save_note_button.setEnabled(True)
        
        # Get the note data
        if 0 <= note_index < len(self.journal_data["notes"]):
            note_data = self.journal_data["notes"][note_index]
            
            # Update note editor
            self.note_editor.setPlainText(note_data["content"])
            
            # Store the current note index
            self.note_editor.setProperty("note_index", note_index)
    
    def _on_note_text_changed(self):
        """Handle note text changes."""
        # Enable the save button if there is text
        self.save_note_button.setEnabled(bool(self.note_editor.toPlainText()))
    
    def _on_new_note_clicked(self):
        """Handle new note button click."""
        # Create a new note with a timestamp
        from datetime import datetime
        
        # Create new note with current time
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        new_note = {
            "title": f"Note {len(self.journal_data['notes']) + 1}",
            "timestamp": timestamp,
            "content": ""
        }
        
        # Add to journal data
        self.journal_data["notes"].append(new_note)
        
        # Add to list
        self._update_notes_list()
        
        # Select the new note
        self.notes_list.setCurrentRow(len(self.journal_data["notes"]) - 1)
        
        # Set focus to the editor
        self.note_editor.clear()
        self.note_editor.setFocus()
        
        # Store the current note index
        self.note_editor.setProperty("note_index", len(self.journal_data["notes"]) - 1)
        
        # Enable delete and save buttons
        self.delete_note_button.setEnabled(True)
        self.save_note_button.setEnabled(False)
    
    def _on_delete_note_clicked(self):
        """Handle delete note button click."""
        # Get the current note index
        note_index = self.note_editor.property("note_index")
        
        if note_index is not None and 0 <= note_index < len(self.journal_data["notes"]):
            # Remove from journal data
            self.journal_data["notes"].pop(note_index)
            
            # Update list
            self._update_notes_list()
            
            # Clear editor
            self.note_editor.clear()
            self.note_editor.setProperty("note_index", None)
            
            # Disable delete and save buttons
            self.delete_note_button.setEnabled(False)
            self.save_note_button.setEnabled(False)
            
            # Emit journal updated signal
            self._emit_journal_updated()
    
    def _on_save_note_clicked(self):
        """Handle save note button click."""
        # Get the current note index
        note_index = self.note_editor.property("note_index")
        
        if note_index is not None and 0 <= note_index < len(self.journal_data["notes"]):
            # Update note content
            self.journal_data["notes"][note_index]["content"] = self.note_editor.toPlainText()
            
            # Update the list item title (first line of content)
            content = self.note_editor.toPlainText()
            first_line = content.split("\n")[0][:30]
            if len(first_line) < len(content.split("\n")[0]):
                first_line += "..."
            
            self.journal_data["notes"][note_index]["title"] = first_line
            
            # Update list
            self._update_notes_list()
            
            # Reselect the note
            self.notes_list.setCurrentRow(note_index)
            
            # Emit journal updated signal
            self._emit_journal_updated()
    
    def _update_notes_list(self):
        """Update the notes list with current journal data.
        
        This list is intended to show only the user's free-form journal notes.
        Structured entries (e.g., objective notes saved with _type="objective_note")
        may be present in journal_data["notes"], but they don't have 'title'/'timestamp'.
        We skip any entries missing those keys to avoid KeyError and to keep the
        list focused.
        """
        # Save the currently selected row
        current_row = self.notes_list.currentRow()
        
        # Clear the list
        self.notes_list.clear()
        
        # Add notes to the list (only those with required fields)
        for i, note in enumerate(self.journal_data.get("notes", [])):
            title = note.get("title")
            timestamp = note.get("timestamp")
            if title is None or timestamp is None:
                # Skip structured notes (like objective notes) or malformed entries
                continue
            # Create list item
            item = QListWidgetItem(f"{title} - {timestamp}")
            item.setData(Qt.UserRole, i)
            
            # Add to list
            self.notes_list.addItem(item)
        
        # Restore selection if possible
        if 0 <= current_row < self.notes_list.count():
            self.notes_list.setCurrentRow(current_row)
    
    def _update_quests_lists(self):
        """Update the quest lists with current journal data."""
        # Save the currently selected items
        active_item = self.active_quests_list.currentItem()
        active_quest_id = active_item.data(Qt.UserRole) if active_item else None
        
        completed_item = self.completed_quests_list.currentItem()
        completed_quest_id = completed_item.data(Qt.UserRole) if completed_item else None
        
        failed_item = self.failed_quests_list.currentItem()
        failed_quest_id = failed_item.data(Qt.UserRole) if failed_item else None
        
        # Clear the lists
        self.active_quests_list.clear()
        self.completed_quests_list.clear()
        self.failed_quests_list.clear()
        
        # Add quests to the appropriate lists
        for quest_id, quest_data in self.journal_data["quests"].items():
            # Determine status: completed tab only if ALL mandatory objectives completed and none failed
            status = quest_data.get("status", "active")
            objectives = quest_data.get("objectives", [])
            mandatory_total = sum(1 for o in objectives if o.get('mandatory', True)) or 0
            mandatory_completed = sum(1 for o in objectives if o.get('mandatory', True) and o.get('completed', False))
            any_failed = any(o.get('failed', False) for o in objectives)
            fully_completed = (mandatory_total == mandatory_completed) and not any_failed
            if quest_data.get("abandoned"):
                status = "failed"
            elif fully_completed:
                status = "completed"
            elif any_failed:
                # Keep as active unless all failed or explicit fail policy
                status = "active"

            # Create list item (append ABANDONED suffix if applicable)
            base_title = quest_data.get("title", quest_id)
            if quest_data.get("abandoned") and status == "failed":
                base_title += " (ABANDONED)"
            item = QListWidgetItem(base_title)
            item.setData(Qt.UserRole, quest_id)
            
            # Add to the appropriate list based on status
            if status == "active":
                self.active_quests_list.addItem(item)
            elif status == "completed":
                self.completed_quests_list.addItem(item)
            elif status == "failed":
                self.failed_quests_list.addItem(item)
        
        # Restore selections if possible
        if active_quest_id:
            for i in range(self.active_quests_list.count()):
                if self.active_quests_list.item(i).data(Qt.UserRole) == active_quest_id:
                    self.active_quests_list.setCurrentRow(i)
                    break
        
        if completed_quest_id:
            for i in range(self.completed_quests_list.count()):
                if self.completed_quests_list.item(i).data(Qt.UserRole) == completed_quest_id:
                    self.completed_quests_list.setCurrentRow(i)
                    break
        
        if failed_quest_id:
            for i in range(self.failed_quests_list.count()):
                if self.failed_quests_list.item(i).data(Qt.UserRole) == failed_quest_id:
                    self.failed_quests_list.setCurrentRow(i)
                    break
    
    def _emit_journal_updated(self):
        """Emit the journal updated signal."""
        self.journal_updated.emit(self.journal_data)

    def clear_all(self):
        """Clear all journal UI content to a blank state (used before loading a save)."""
        self.journal_data = {"character": "", "quests": {}, "notes": []}
        self.character_info_editor.clear()
        self.active_quests_list.clear()
        self.completed_quests_list.clear()
        self.failed_quests_list.clear()
        self.quest_details.clear()
        self.notes_list.clear()

    def _show_active_context_menu(self, pos):
        """Show context menu for active quest list to manage objectives and notes."""
        item = self.active_quests_list.itemAt(pos)
        if not item:
            return
        quest_id = item.data(Qt.UserRole)
        quest = self.journal_data.get("quests", {}).get(quest_id)
        if not quest:
            return
        # Build a menu of objectives first
        from PySide6.QtWidgets import QMenu
        menu = QMenu(self)
        # Ensure opaque, dark context menu styling consistent with app theme
        menu.setStyleSheet(
            """
            QMenu {
                background-color: #2b2b2b; /* opaque dark background */
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
            }
            QMenu::item {
                background-color: transparent;
                padding: 6px 12px;
            }
            QMenu::item:selected {
                background-color: #3a3a3a; /* selection color */
            }
            QMenu::separator {
                height: 1px;
                background: #3a3a3a;
                margin: 4px 6px;
            }
            """
        )
        # For simplicity, act on currently selected quest objective via details text selection not implemented; offer global options
        complete_sub = menu.addMenu("Mark Objective as Completed")
        fail_sub = menu.addMenu("Mark Objective as Failed")
        notes_sub = menu.addMenu("See Notes for Objective")
        # Ensure submenus inherit opaque style (Qt sometimes needs explicit set)
        submenu_style = menu.styleSheet()
        complete_sub.setStyleSheet(submenu_style)
        fail_sub.setStyleSheet(submenu_style)
        notes_sub.setStyleSheet(submenu_style)
        # Developer and general quest actions
        menu.addSeparator()
        abandon_action = menu.addAction("Abandon Quest")
        abandon_action.triggered.connect(lambda: self._abandon_quest(quest_id))
        menu.addSeparator()
        dev_complete = menu.addAction("(dev) Mark Quest Completed")
        dev_failed = menu.addAction("(dev) Mark Quest Failed")
        dev_complete.triggered.connect(lambda: self._mark_quest_status(quest_id, "completed"))
        dev_failed.triggered.connect(lambda: self._mark_quest_status(quest_id, "failed"))
        # Add per-objective actions
        def add_actions_for_objectives(submenu, handler):
            for obj in quest.get("objectives", []):
                obj_id = obj.get("id")
                desc = obj.get("description", obj_id)
                act = submenu.addAction(desc)
                act.triggered.connect(lambda checked=False, qid=quest_id, oid=obj_id: handler(qid, oid))
        add_actions_for_objectives(complete_sub, self._mark_objective_completed)
        add_actions_for_objectives(fail_sub, self._mark_objective_failed)
        add_actions_for_objectives(notes_sub, self._open_objective_notes)
        menu.exec(self.active_quests_list.mapToGlobal(pos))

    def _mark_objective_completed(self, quest_id: str, objective_id: str):
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        for o in q.get("objectives", []):
            if o.get("id") == objective_id:
                o["completed"] = True
                o["failed"] = False
                break
        # Refresh details view to update colors/strikethrough
        self._update_quests_lists()
        self._refresh_current_quest_details(quest_id)
        self._emit_journal_updated()

    def _mark_objective_failed(self, quest_id: str, objective_id: str):
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        for o in q.get("objectives", []):
            if o.get("id") == objective_id:
                o["failed"] = True
                o["completed"] = False
                break
        # Refresh details view to update colors/strikethrough
        self._update_quests_lists()
        self._refresh_current_quest_details(quest_id)
        self._emit_journal_updated()

    def _open_objective_notes(self, quest_id: str, objective_id: str):
        # Minimal inline notes implementation: store under journal["notes"] as structured entries
        from PySide6.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton, QHBoxLayout
        dlg = QDialog(self)
        dlg.setWindowTitle("Objective Notes")
        layout = QVBoxLayout(dlg)
        editor = QTextEdit()
        # Load existing note if present
        notes_key = (quest_id, objective_id)
        existing = None
        if isinstance(self.journal_data.get("notes"), list):
            for n in self.journal_data["notes"]:
                if n.get("_type") == "objective_note" and n.get("quest_id") == quest_id and n.get("objective_id") == objective_id:
                    existing = n
                    break
        if existing:
            editor.setPlainText(existing.get("content", ""))
        layout.addWidget(editor)
        btns = QHBoxLayout()
        save_btn = QPushButton("Save")
        close_btn = QPushButton("Close")
        btns.addWidget(save_btn)
        btns.addStretch()
        btns.addWidget(close_btn)
        layout.addLayout(btns)
        
        def _save():
            content = editor.toPlainText()
            # Update or append note
            if existing:
                existing["content"] = content
            else:
                self.journal_data.setdefault("notes", []).append({
                    "_type": "objective_note",
                    "quest_id": quest_id,
                    "objective_id": objective_id,
                    "content": content,
                })
            self._emit_journal_updated()
            dlg.accept()
        save_btn.clicked.connect(_save)
        close_btn.clicked.connect(dlg.reject)
        dlg.exec()
    
    def _show_notes_only_context_menu(self, list_widget: QListWidget, pos):
        """Show a notes-only context menu for Completed/Failed lists."""
        item = list_widget.itemAt(pos)
        if not item:
            return
        quest_id = item.data(Qt.UserRole)
        quest = self.journal_data.get("quests", {}).get(quest_id)
        if not quest:
            return
        from PySide6.QtWidgets import QMenu
        menu = QMenu(self)
        # Ensure opaque styling matches active menu
        menu.setStyleSheet(
            """
            QMenu { background-color: #2b2b2b; color: #e0e0e0; border: 1px solid #3a3a3a; }
            QMenu::item { padding: 6px 12px; }
            QMenu::item:selected { background-color: #3a3a3a; }
            QMenu::separator { height: 1px; background: #3a3a3a; margin: 4px 6px; }
            """
        )
        notes_sub = menu.addMenu("See Notes for Objective")
        # Build set of objectives that actually have saved notes
        existing_obj_notes = set()
        try:
            for n in self.journal_data.get("notes", []):
                if n.get("_type") == "objective_note" and n.get("quest_id") == quest_id:
                    content = n.get("content", "")
                    if isinstance(content, str) and content.strip():
                        existing_obj_notes.add(n.get("objective_id"))
        except Exception:
            pass
        
        # Populate menu: clickable only for objectives with saved notes; others are disabled text
        from PySide6.QtGui import QAction
        any_clickable = False
        for obj in quest.get("objectives", []):
            obj_id = obj.get("id")
            desc = obj.get("description", obj_id)
            if obj_id in existing_obj_notes:
                act = notes_sub.addAction(desc)
                act.triggered.connect(lambda checked=False, qid=quest_id, oid=obj_id: self._open_objective_notes(qid, oid))
                any_clickable = True
            else:
                # Add a disabled action to show as plain text
                text_act = QAction(desc, notes_sub)
                text_act.setEnabled(False)
                notes_sub.addAction(text_act)
        if not any_clickable:
            placeholder = QAction("No notes available", notes_sub)
            placeholder.setEnabled(False)
            notes_sub.addAction(placeholder)
        menu.exec(list_widget.mapToGlobal(pos))
    
    def _mark_quest_status(self, quest_id: str, status: str):
        """Developer helper to set a quest's status directly (completed/failed)."""
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        if status == "completed":
            for o in q.get("objectives", []):
                if o.get("mandatory", True):
                    o["completed"] = True
                    o["failed"] = False
            q["status"] = "completed"
            q.pop("abandoned", None)
        elif status == "failed":
            # Mark as failed without changing individual objectives
            q["status"] = "failed"
            q.pop("abandoned", None)
        self._update_quests_lists()
        self._refresh_current_quest_details(quest_id)
        self._emit_journal_updated()

    def _abandon_quest(self, quest_id: str):
        """Abandon a quest after user confirmation: moves it to Failed and flags as abandoned."""
        from PySide6.QtWidgets import QMessageBox
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        title = q.get("title", quest_id)
        reply = QMessageBox.question(
            self,
            "Abandon Quest",
            f"Are you sure you want to abandon '{title}'? This will move it to Failed.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No,
        )
        if reply == QMessageBox.Yes:
            q["status"] = "failed"
            q["abandoned"] = True
            self._update_quests_lists()
            self._refresh_current_quest_details(quest_id)
            self._emit_journal_updated()
    
    def _refresh_current_quest_details(self, quest_id: str):
        """If the provided quest_id is currently selected in any tab, rebuild its details HTML.
        This ensures the colors for completed/failed objectives refresh immediately.
        """
        # Determine which list contains the quest
        for lst in (self.active_quests_list, self.completed_quests_list, self.failed_quests_list):
            for i in range(lst.count()):
                it = lst.item(i)
                if it.data(Qt.UserRole) == quest_id and it.isSelected():
                    # Rebuild by calling the selection handler
                    self._on_quest_selected(it)
                    return

    def update_journal(self, journal_data: Dict[str, Any] = None):
        """
        Update the journal panel with journal data.
        
        Args:
            journal_data: The journal data to display.
        """
        # If no journal data is provided, use the current state
        if journal_data is None:
            if self.state_manager and self.state_manager.current_state:
                if hasattr(self.state_manager.current_state, "journal"):
                    journal_data = self.state_manager.current_state.journal
                else:
                    logging.warning("No journal data available to update journal panel")
                    return
            else:
                logging.warning("No state available to update journal panel")
                return
        
        # Update journal data
        self.journal_data = journal_data
        
        # Update character info
        self.character_info_editor.setPlainText(journal_data.get("character", ""))
        
        # Update quests lists
        self._update_quests_lists()
        # If a quest is selected, refresh its details to ensure colors/styles render
        cur = self.active_quests_list.currentItem() or self.completed_quests_list.currentItem() or self.failed_quests_list.currentItem()
        if cur:
            self._on_quest_selected(cur)
        else:
            self.quest_details.clear()
        
        # Update notes list
        self._update_notes_list()

```

### File: gui\components\menu_panel.py

```python
#!/usr/bin/env python3
"""
Menu panel widget for the RPG game GUI.
This module provides a collapsible left menu panel.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QFrame, 
    QToolButton, QLabel, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QSize, QEasingCurve, Property
from PySide6.QtGui import QIcon, QPixmap

from gui.utils.resource_manager import get_resource_manager

class MenuPanelWidget(QFrame):
    """Collapsible left menu panel for the RPG game GUI."""
    
    # Signals for menu actions
    new_game_requested = Signal()
    save_game_requested = Signal()
    load_game_requested = Signal()
    settings_requested = Signal()
    llm_settings_requested = Signal()
    exit_requested = Signal()
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the menu panel widget."""
        super().__init__(parent)

        # Set the desired opacity (0 = fully transparent, 100 = fully opaque)
        menu_panel_opacity_percent = 50 # Example: 85% opaque (adjust as needed)

        # Convert percentage to alpha value (0.0 to 1.0)
        alpha_value = menu_panel_opacity_percent / 100.0

        # Define the base background color RGB values (from #333333)
        base_r, base_g, base_b = 51, 51, 51
        
        # Set frame properties using rgba for background
        self.setFrameShape(QFrame.StyledPanel)
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.setStyleSheet(f"""
            MenuPanelWidget {{
                /* Use rgba for background color with transparency */
                background-color: rgba({base_r}, {base_g}, {base_b}, {alpha_value}); 
                
                /* Keep other styles */
                border: 1px solid #555555; 
                border-radius: 5px;
            }}
            /* Ensure buttons inside the panel remain opaque (using their own styles) */
            /* No changes needed here as buttons have specific styles set later */
        """)
        

        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Create animation properties
        self._expanded = True
        self._animation = None
        self._expanded_width = 150  # Increase width from 100 to 120
        self._collapsed_width = 40  # Increase collapsed width from 30 to 40
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(5, 5, 10, 5)
        self.main_layout.setSpacing(10)
        
        # Create toggle button
        self.toggle_button = QToolButton()
        self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
        self.toggle_button.setIconSize(QSize(16, 16))
        self.toggle_button.setStyleSheet("""
            QToolButton {
                background-color: #444444;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QToolButton:hover {
                background-color: #555555;
            }
            QToolButton:pressed {
                background-color: #333333;
            }
        """)
        self.toggle_button.clicked.connect(self.toggle_expanded)
        
        # Create menu buttons
        self.new_game_button = self._create_menu_button("New Game", "new_game")
        self.new_game_button.clicked.connect(self.new_game_requested.emit)
        
        self.save_button = self._create_menu_button("Save", "save_game")
        self.save_button.clicked.connect(self.save_game_requested.emit)
        
        self.load_button = self._create_menu_button("Load", "load_game")
        self.load_button.clicked.connect(self.load_game_requested.emit)
        
        # Settings button
        self.settings_button = self._create_menu_button("Settings", "settings")
        self.settings_button.clicked.connect(self.settings_requested.emit)
        
        self.llm_settings_button = self._create_menu_button("LLM", "llm_settings")
        self.llm_settings_button.clicked.connect(self.llm_settings_requested.emit)
        
        self.exit_button = self._create_menu_button("Exit", "exit")
        self.exit_button.clicked.connect(self.exit_requested.emit)
        
        # Add buttons to layout
        self.main_layout.addWidget(self.toggle_button, 0, Qt.AlignRight)
        self.main_layout.addSpacing(50)
        self.main_layout.addWidget(self.new_game_button)
        self.main_layout.addWidget(self.save_button)
        self.main_layout.addWidget(self.load_button)
        self.main_layout.addWidget(self.settings_button)
        self.main_layout.addWidget(self.llm_settings_button)
        self.main_layout.addSpacing(100)
        self.main_layout.addWidget(self.exit_button)
        self.main_layout.addStretch(1)  
        
        # Set initial width
        self.setFixedWidth(self._expanded_width)
    
    def _create_menu_button(self, text: str, icon_name: str) -> QPushButton:
        """Create a styled menu button.
        
        Args:
            text: The button text
            icon_name: The icon name (without path or extension)
            
        Returns:
            The created button
        """
        button = QPushButton(text)
        button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        
        # Use generic button backgrounds instead of specific ones
        button.setStyleSheet("""
            QPushButton {
                background-image: url('images/gui/button_normal.png');
                background-position: center;
                background-repeat: no-repeat;
                background-color: transparent;

                color: #E0E0E0;
                border: none;
                padding: 8px;
                text-align: center;
                min-width: 100px;
                max-width: 110px;
                min-height: 35px;
                border-radius: 5px;
                margin-left: 5px;
                margin-right: 10px;
            }
            QPushButton:hover {
                background-image: url('images/gui/button_hover.png');
            }
            QPushButton:pressed {
                background-image: url('images/gui/button_pressed.png');
                color: #FF0000;
                font-weight: bold;
            }
        """)
        
        return button
    
    def toggle_expanded(self):
        """Toggle the expanded/collapsed state of the panel."""
        self.setExpanded(not self._expanded)
    
    def setExpanded(self, expanded: bool):
        """Set the expanded/collapsed state of the panel.
        
        Args:
            expanded: True to expand, False to collapse
        """
        if self._expanded == expanded:
            return
        
        # Update state
        self._expanded = expanded
        
        # Update toggle button icon
        if expanded:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
        else:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right"))
        
        # Hide/show buttons when collapsed/expanded
        for button in [
            self.new_game_button,
            self.save_button,
            self.load_button,
            self.settings_button,
            self.llm_settings_button,
            self.exit_button
        ]:
            # Store original text when collapsing
            if expanded:
                button.setText(button.property("original_text"))
                button.setVisible(True)
            else:
                if not button.property("original_text"):
                    button.setProperty("original_text", button.text())
                button.setText("")
                button.setVisible(False)
        
        # Only toggle button remains visible when collapsed
        if not expanded:
            self.toggle_button.setVisible(True)
        
        # Animate width change
        target_width = self._expanded_width if expanded else self._collapsed_width
        
        if self._animation:
            self._animation.stop()
        
        self._animation = QPropertyAnimation(self, b"minimumWidth")
        self._animation.setDuration(300)
        self._animation.setStartValue(self.width())
        self._animation.setEndValue(target_width)
        self._animation.setEasingCurve(QEasingCurve.InOutCubic)
        self._animation.start()
    
    def isExpanded(self) -> bool:
        """Get the expanded/collapsed state of the panel.
        
        Returns:
            True if expanded, False if collapsed
        """
        return self._expanded
    
    def sizeHint(self) -> QSize:
        """Get the recommended size for the widget.
        
        Returns:
            The recommended size
        """
        if self._expanded:
            return QSize(self._expanded_width, super().sizeHint().height())
        else:
            return QSize(self._collapsed_width, super().sizeHint().height())

```

### File: gui\components\right_panel.py

```python
#!/usr/bin/env python3
"""
Right panel widget for the RPG game GUI.
This module provides a collapsible, tabbed right panel.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QTabWidget, QFrame, 
    QHBoxLayout, QPushButton, QStackedWidget, QToolButton, QTabBar, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QSize, QEasingCurve, Property
from PySide6.QtGui import QIcon, QPixmap, QCursor

from gui.utils.resource_manager import get_resource_manager
from gui.components.character_sheet import CharacterSheetWidget
from gui.components.inventory_panel import InventoryPanelWidget
from gui.components.journal_panel import JournalPanelWidget

class CustomTabBar(QTabBar):
    """Custom tab bar that emits a signal when the selected tab is clicked again."""
    
    tab_clicked_twice = Signal(int)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._last_index = -1
    
    def mousePressEvent(self, event):
        """Handle mouse press events to detect double clicks on selected tabs."""
        index = self.tabAt(event.pos())
        
        if index != -1 and index == self.currentIndex():
            self.tab_clicked_twice.emit(index)
        
        # Let the normal event processing happen
        super().mousePressEvent(event)

class CollapsibleRightPanel(QFrame):
    """Collapsible, tabbed right panel for the RPG game GUI."""
    
    # Signals
    tab_changed = Signal(int)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the right panel widget."""
        super().__init__(parent)
        
        # Set the desired opacity (0 = fully transparent, 100 = fully opaque)
        right_panel_opacity_percent = 50
        
        # Convert percentage to alpha value (0.0 to 1.0)
        alpha_value = right_panel_opacity_percent / 100.0

        # Define the base background color RGB values (from #333333)
        base_r, base_g, base_b = 51, 51, 51
        
        # Set frame properties using rgba for background
        self.setFrameShape(QFrame.StyledPanel)
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.setStyleSheet(f"""
            CollapsibleRightPanel {{
                /* Use rgba for background color with transparency */
                background-color: rgba({base_r}, {base_g}, {base_b}, {alpha_value}); 
                
                /* Keep other styles */
                border: 1px solid #555555; 
                border-radius: 5px;
            }}
            /* Child widgets like QTabWidget will have their own styles set below */
        """)
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Create animation properties
        self._expanded = True
        self._animation = None
        self._expanded_width = 480
        self._collapsed_width = 30
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)
        
        # Create tab widget with custom tab bar
        self.tab_widget = QTabWidget()
        self.custom_tab_bar = CustomTabBar()
        self.tab_widget.setTabBar(self.custom_tab_bar)
        
        # Connect custom tab bar signal
        self.custom_tab_bar.tab_clicked_twice.connect(self.toggle_expanded)
        
        # Style the tab widget
        self.tab_widget.setStyleSheet("""
            QTabWidget,
            QTabWidget QWidget, /* Target widgets directly inside QTabWidget */
            QTabWidget QScrollArea,
            QTabWidget QScrollArea > QWidget > QFrame, /* Target frames within scroll areas */
            QTabWidget QScrollArea > QWidget { /* Target viewport widget */
                background-color: transparent; /* Make immediate children transparent */
                color: #E0E0E0;
                border: none;
            }
            QTabWidget::pane { /* The area behind the tabs' content */
                background-color: #2E2E2E; /* Opaque dark color - slightly different from panel bg */
                border: 1px solid #444444;
                border-top: none; /* Remove top border as it's covered by tabs */
                border-radius: 0px; /* Pane doesn't need radius if panel has it */
                padding: 5px; /* Add some padding for content */
                margin: 0px;
            }
            QTabBar::tab { /* Individual tabs */
                background-color: #444444; /* Opaque tab background */
                color: #BBBBBB;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                padding: 8px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected { /* Selected tab */
                background-color: #2E2E2E; /* Match the pane background */
                color: #E0E0E0;
                border-bottom: 1px solid #2E2E2E; /* Make it look connected */
            }
            QTabBar::tab:hover:!selected { /* Hovered non-selected tab */
                background-color: #505050;
            }
            /* Ensure specific content widgets (like CharacterSheetWidget) have transparent backgrounds */
            /* if you want the pane background (#2E2E2E) to show through */
            CharacterSheetWidget, InventoryPanelWidget, JournalPanelWidget {
                 background-color: transparent;
            }
        """)
        
        # Create tabs
        self.character_sheet = CharacterSheetWidget()
        self.inventory_panel = InventoryPanelWidget()
        self.journal_panel = JournalPanelWidget()
        
        # Add tabs
        self.tab_widget.addTab(self.character_sheet, "Character")
        self.tab_widget.addTab(self.inventory_panel, "Inventory")
        self.tab_widget.addTab(self.journal_panel, "Journal")
        
        # Create toggle button (only visible when collapsed)
        self.toggle_button = QToolButton()
        self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right")) # This icon might need to change based on state
        self.toggle_button.setIconSize(QSize(16, 16))
        self.toggle_button.setStyleSheet("""
            QToolButton {
                background-color: #444444;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QToolButton:hover {
                background-color: #555555;
            }
            QToolButton:pressed {
                background-color: #333333;
            }
        """)
        self.toggle_button.clicked.connect(self.toggle_expanded)
        
        # Always show the toggle button
        self.toggle_button.setVisible(True)
        
        # Create stacked widget to switch between tab widget and collapsed view
        self.stacked_widget = QStackedWidget()
        self.stacked_widget.addWidget(self.tab_widget)  # Index 0: Expanded view with tabs
        
        # We don't use a separate collapsed view anymore
        # Instead, just modify the width of the panel while keeping tabs visible
        # This way, users can always see tab headers and expand the panel by clicking on them
        
        # Add toggle button directly to the main layout
        toggle_container = QWidget()
        toggle_layout = QHBoxLayout(toggle_container) # Changed to QHBoxLayout for horizontal alignment
        toggle_layout.setContentsMargins(0, 5, 5, 0) # Add right margin
        toggle_layout.addStretch() # Push button to the right
        toggle_layout.addWidget(self.toggle_button) # No alignment needed if stretch is used
        
        # Add toggle container to top of main layout
        self.main_layout.addWidget(toggle_container) # Add the container
        
        # Add stacked widget to main layout
        self.main_layout.addWidget(self.stacked_widget)
        
        # Set initial width
        self.setFixedWidth(self._expanded_width)
        
        # Connect tab changed signal
        self.tab_widget.currentChanged.connect(self._handle_tab_change)

    def _handle_tab_change(self, index):
        """Handle tab change event."""
        # Emit signal
        self.tab_changed.emit(index)
    
    def toggle_expanded(self, index=None):
        """Toggle the expanded/collapsed state of the panel."""
        self.setExpanded(not self._expanded)
    
    def setExpanded(self, expanded: bool):
        """Set the expanded/collapsed state of the panel.
        
        Args:
            expanded: True to expand, False to collapse
        """
        if self._expanded == expanded:
            return
        
        # Update state
        self._expanded = expanded
        
        # When collapsing, don't switch to the collapsed widget view
        # Instead, just resize the panel, keeping the tabs visible
        # This ensures users can still see and click on tabs
        
        # Animate width change
        target_width = self._expanded_width if expanded else self._collapsed_width
        
        if self._animation:
            self._animation.stop()
        
        # Animate the panel's fixedWidth property
        self._animation = QPropertyAnimation(self, b"fixedWidth") # Animate fixedWidth
        self._animation.setDuration(300)
        self._animation.setStartValue(self.width())
        self._animation.setEndValue(target_width)
        self._animation.setEasingCurve(QEasingCurve.InOutCubic)
        self._animation.start()

        # Update toggle button icon
        if self._expanded:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right"))
            self.toggle_button.setToolTip("Collapse Panel")
        else:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
            self.toggle_button.setToolTip("Expand Panel")
    
    def isExpanded(self) -> bool:
        """Get the expanded/collapsed state of the panel.
        
        Returns:
            True if expanded, False if collapsed
        """
        return self._expanded
    
    def sizeHint(self) -> QSize:
        """Get the recommended size for the widget.
        
        Returns:
            The recommended size
        """
        if self._expanded:
            return QSize(self._expanded_width, super().sizeHint().height())
        else:
            return QSize(self._collapsed_width, super().sizeHint().height())
    
    def update_character(self, character=None):
        """Update the character sheet tab with character data."""
        # If character is provided directly, update with it
        if character:
            self.character_sheet.update_character(character)
            return
        
        # Otherwise get current character from game state
        from core.base.state import get_state_manager
        state_manager = get_state_manager()
        if state_manager and state_manager.current_state and state_manager.current_state.player:
            # First ensure stats manager is initialized
            if state_manager.stats_manager:
                # Trigger an update with current state's player
                self.character_sheet.update_character(state_manager.current_state.player)
    
    def update_inventory(self, inventory=None):
        """Update the inventory tab with inventory data."""
        self.inventory_panel.update_inventory(inventory)
    
    def update_journal(self, journal_data=None):
        """Update the journal tab with journal data."""
        self.journal_panel.update_journal(journal_data)

```

### File: gui\components\skill_check_display.py

```python
#!/usr/bin/env python3
"""
Skill check display widget for the RPG game GUI.
This module provides a widget for displaying skill check results in a visual way.
"""

import logging
from typing import Optional, Dict, Any, List, Union
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, 
    QProgressBar, QGroupBox, QGraphicsOpacityEffect
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QTimer, QSize, Property
from PySide6.QtGui import QFont, QColor, QPainter, QPen, QBrush

from core.stats.skill_check import SkillCheckResult


class DiceWidget(QWidget):
    """Widget for displaying a dice roll result with animation."""
    
    def __init__(self, parent=None):
        """Initialize the dice widget."""
        super().__init__(parent)
        self.setMinimumSize(60, 60)
        self.setMaximumSize(60, 60)
        
        self._value = 1
        self._rolling = False
        self._roll_timer = QTimer(self)
        self._roll_timer.timeout.connect(self._update_rolling_value)
        
        # Set the background to be transparent
        self.setAttribute(Qt.WA_TranslucentBackground)
    
    def get_value(self) -> int:
        """Get the current dice value."""
        return self._value
    
    def set_value(self, value: int) -> None:
        """Set the dice value."""
        self._value = max(1, min(value, 20))  # Ensure value is between 1 and 20
        self.update()
    
    value = Property(int, get_value, set_value)
    
    def roll_animation(self, final_value: int, duration_ms: int = 1000) -> None:
        """
        Animate a dice roll to the final value.
        
        Args:
            final_value: The final dice value to show
            duration_ms: Duration of the animation in milliseconds
        """
        self._rolling = True
        self._final_value = max(1, min(final_value, 20))
        self._roll_timer.start(50)  # Update every 50ms
        
        # Set a timer to stop the rolling animation
        QTimer.singleShot(duration_ms, self._stop_rolling)
    
    def _update_rolling_value(self) -> None:
        """Update the dice value during rolling animation."""
        import random
        self.set_value(random.randint(1, 20))
    
    def _stop_rolling(self) -> None:
        """Stop the rolling animation and set the final value."""
        self._rolling = False
        self._roll_timer.stop()
        self.set_value(self._final_value)
    
    def paintEvent(self, event) -> None:
        """Paint the dice."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Define the dice colors based on the value
        if self._value == 20:
            # Critical success - gold
            bg_color = QColor(255, 215, 0)
            text_color = QColor(0, 0, 0)
        elif self._value == 1:
            # Critical failure - red
            bg_color = QColor(200, 0, 0)
            text_color = QColor(255, 255, 255)
        else:
            # Normal roll - white
            bg_color = QColor(240, 240, 240)
            text_color = QColor(0, 0, 0)
        
        # Draw the dice (d20 is icosahedron, but we'll draw a simplified pentagon)
        rect = self.rect().adjusted(2, 2, -2, -2)
        
        # Draw the background
        painter.setBrush(QBrush(bg_color))
        painter.setPen(QPen(QColor(20, 20, 20), 2))
        
        # Draw a circle as the dice
        painter.drawEllipse(rect)
        
        # Draw the value
        painter.setPen(QPen(text_color))
        font = QFont("Arial", 18, QFont.Bold)
        painter.setFont(font)
        painter.drawText(rect, Qt.AlignCenter, str(self._value))


class SkillCheckDisplay(QWidget):
    """Widget for displaying skill check results."""
    
    # Signal emitted when the display is finished
    display_finished = Signal()
    
    def __init__(self, parent=None):
        """Initialize the skill check display widget."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
        
        # Hide the widget by default
        self.setVisible(False)
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(5)
        
        # Create the title label
        self.title_label = QLabel("Skill Check")
        self.title_label.setStyleSheet("""
            font-size: 18px;
            font-weight: bold;
            color: #E0E0E0;
        """)
        self.title_label.setAlignment(Qt.AlignCenter)
        
        # Create the stat and difficulty display
        self.stat_layout = QHBoxLayout()
        
        self.stat_label = QLabel("Stat: STR")
        self.stat_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #BBBBBB;
        """)
        
        self.difficulty_label = QLabel("Difficulty: 15")
        self.difficulty_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #BBBBBB;
        """)
        
        self.stat_layout.addWidget(self.stat_label)
        self.stat_layout.addStretch(1)
        self.stat_layout.addWidget(self.difficulty_label)
        
        # Create the dice display
        self.dice_layout = QHBoxLayout()
        self.dice_layout.setAlignment(Qt.AlignCenter)
        
        self.dice_widget = DiceWidget()
        
        self.dice_layout.addWidget(self.dice_widget)
        
        # Create the result display
        self.result_layout = QHBoxLayout()
        
        self.mod_label = QLabel("Modifier: +0")
        self.mod_label.setStyleSheet("""
            font-size: 14px;
            color: #BBBBBB;
        """)
        
        self.total_label = QLabel("Total: 10")
        self.total_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #E0E0E0;
        """)
        
        self.success_label = QLabel("SUCCESS")
        self.success_label.setStyleSheet("""
            font-size: 16px;
            font-weight: bold;
            color: #66CC33;
        """)
        self.success_label.setAlignment(Qt.AlignCenter)
        
        self.result_layout.addWidget(self.mod_label)
        self.result_layout.addStretch(1)
        self.result_layout.addWidget(self.total_label)
        
        # Create the context display
        self.context_label = QLabel("Attempting to climb the steep cliff")
        self.context_label.setStyleSheet("""
            font-size: 14px;
            font-style: italic;
            color: #CCCCCC;
        """)
        self.context_label.setAlignment(Qt.AlignCenter)
        self.context_label.setWordWrap(True)
        
        # Add all elements to the main layout
        self.main_layout.addWidget(self.title_label)
        self.main_layout.addLayout(self.stat_layout)
        self.main_layout.addLayout(self.dice_layout)
        self.main_layout.addLayout(self.result_layout)
        self.main_layout.addWidget(self.success_label)
        self.main_layout.addWidget(self.context_label)
        
        # Set the widget styling
        self.setStyleSheet("""
            background-color: #333333;
            border: 2px solid #555555;
            border-radius: 8px;
        """)
        
        # Set a fixed size for the widget
        self.setFixedSize(300, 250)
    
    def show_check_result(self, result: SkillCheckResult, context: str = "", duration_ms: int = 3000) -> None:
        """
        Display a skill check result with animation.
        
        Args:
            result: The SkillCheckResult object containing the check details
            context: Optional context description for the check
            duration_ms: How long to display the result (in milliseconds)
        """
        # Update the labels with the check information
        self.title_label.setText(f"Skill Check: {result.stat_type}")
        self.stat_label.setText(f"Stat: {result.stat_type} ({int(result.stat_value)})")
        self.difficulty_label.setText(f"Difficulty: {result.difficulty}")
        self.mod_label.setText(f"Modifier: {'+' if result.modifier >= 0 else ''}{result.modifier}")
        self.total_label.setText(f"Total: {result.roll + result.modifier}")
        
        # Set success/failure display
        if result.success:
            if result.roll == 20:
                self.success_label.setText("CRITICAL SUCCESS!")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #FFD700;  /* Gold */
                """)
            else:
                self.success_label.setText("SUCCESS")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #66CC33;  /* Green */
                """)
        else:
            if result.roll == 1:
                self.success_label.setText("CRITICAL FAILURE!")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #CC3333;  /* Red */
                """)
            else:
                self.success_label.setText("FAILURE")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #CC3333;  /* Red */
                """)
        
        # Set the context text
        self.context_label.setText(context)
        
        # Make the widget visible
        self.setVisible(True)
        
        # Create fade-in animation
        self.fade_in_effect = QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.fade_in_effect)
        self.fade_in_effect.setOpacity(0)
        
        self.fade_in = QPropertyAnimation(self.fade_in_effect, b"opacity")
        self.fade_in.setDuration(300)
        self.fade_in.setStartValue(0)
        self.fade_in.setEndValue(1)
        self.fade_in.start()
        
        # Start the dice roll animation
        self.dice_widget.roll_animation(result.roll, 800)
        
        # Create a timer to hide the widget after duration_ms
        QTimer.singleShot(duration_ms, self._fade_out)
    
    def _fade_out(self) -> None:
        """Create and start a fade-out animation."""
        self.fade_out = QPropertyAnimation(self.fade_in_effect, b"opacity")
        self.fade_out.setDuration(500)
        self.fade_out.setStartValue(1)
        self.fade_out.setEndValue(0)
        self.fade_out.start()
        
        # Hide the widget after the animation finishes
        self.fade_out.finished.connect(self._hide_widget)
    
    def _hide_widget(self) -> None:
        """Hide the widget and emit the finished signal."""
        self.setVisible(False)
        self.display_finished.emit()


# For testing purposes
if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication
    from core.stats.stats_base import StatType
    
    # Create a test application
    app = QApplication(sys.argv)
    
    # Create a mock skill check result
    test_result = SkillCheckResult(
        stat_type=StatType.STRENGTH,
        stat_value=15,
        difficulty=12,
        roll=18,
        modifier=3,
        success=True,
        advantage=False,
        disadvantage=False
    )
    
    # Create and show the widget
    widget = SkillCheckDisplay()
    widget.show_check_result(test_result, "Attempting to lift the heavy boulder")
    widget.show()
    
    # Run the application
    sys.exit(app.exec())

```

### File: gui\components\stat_allocation_widget.py

```python
#!/usr/bin/env python3
"""
Stat allocation widget for character creation and level-up.
"""

import os
import json
import logging
from typing import Dict, List, Optional, Any, Tuple, Callable

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QFrame, QGroupBox, QPushButton, QToolTip, QSizePolicy,
    QSpacerItem, QDialog, QFrame 
)
from PySide6.QtCore import Qt, Signal, Slot, QPoint, QSize, QEvent
from PySide6.QtGui import QFont, QColor, QPalette, QMouseEvent, QIcon, QPixmap, QCursor

from core.stats.stats_base import StatType
from core.stats.stat_allocation import StatPointAllocator
from core.stats.stats_manager import StatsManager
from core.stats.stat_modifier_info import StatModifierInfo
from core.utils.logging_config import get_logger, log_migration_fix

# Log the import fix
log_migration_fix(
    "gui.components.stat_allocation_widget", 
    "from core.utils.logging_config import get_logger, LogCategory\nlogger = get_logger(LogCategory.GUI)", 
    "from core.utils.logging_config import get_logger\nlogger = get_logger(\"GUI\")"
)

logger = get_logger("GUI")


class TooltipLabel(QLabel):
    """A custom label that shows a tooltip when hovered over."""
    
    def __init__(self, text="", tooltip="", parent=None):
        super().__init__(text, parent)
        self.tooltip_text = tooltip
        self.setMouseTracking(True)
    
    def enterEvent(self, event):
        """Show tooltip when mouse enters label area."""
        if self.tooltip_text:
            QToolTip.showText(QCursor.pos(), self.tooltip_text, self)
        super().enterEvent(event)
    
    def leaveEvent(self, event):
        """Hide tooltip when mouse leaves label area."""
        if self.tooltip_text:
            QToolTip.hideText()
        super().leaveEvent(event)
    
    def setTooltipText(self, text):
        """Set the tooltip text."""
        self.tooltip_text = text


class StatInfoDialog(QDialog):
    """Dialog for displaying detailed information about a stat."""
    
    def __init__(self, stat_name: str, stat_value: int, modifier_info: StatModifierInfo, parent=None):
        super().__init__(parent)

        # Configure dialog
        self.setWindowTitle(f"{stat_name} Stat Information")
        self.setFixedSize(400, 400)
        self.setModal(True)
        self.setStyleSheet("""
            QDialog {
                background-color: #333333;
                color: #E0E0E0;
            }
        """)

        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(10)

        # Stat title
        title_label = QLabel(f"<h2>{stat_name}</h2>")
        title_label.setStyleSheet("color: #E0E0E0;")
        layout.addWidget(title_label)

        # Stat description
        stat_descriptions = {
            "STR": "<b>Strength</b> represents physical power and affects melee damage, carrying capacity, and physical force.",
            "DEX": "<b>Dexterity</b> represents agility, reflexes, and balance. It affects initiative, ranged attacks, and ability to dodge.",
            "CON": "<b>Constitution</b> represents health, stamina, and vital force. It affects hit points, resistance to poison, and fatigue.",
            "INT": "<b>Intelligence</b> represents reasoning, memory, and learning ability. It affects spell power, knowledge skills, and ability to analyze.",
            "WIS": "<b>Wisdom</b> represents intuition, perception, and willpower. It affects magical resistance, perception checks, and survival skills.",
            "CHA": "<b>Charisma</b> represents force of personality, persuasiveness, and leadership. It affects social interactions, prices, and follower loyalty.",
            # --- MODIFICATION: Add descriptions for WIL and INS ---
            "WIL": "<b>Willpower</b> represents mental fortitude, focus, and resistance to stress or mental influence. It affects concentration, resisting fear, and pushing through mental challenges.",
            "INS": "<b>Insight</b> represents understanding, intuition, and awareness of subtle details in situations and people. It affects perception checks, reading motives, and making intuitive leaps."
            # --- END MODIFICATION ---
        }

        description = stat_descriptions.get(stat_name, "")
        desc_label = QLabel(description)
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("color: #E0E0E0; background-color: #2D2D2D; padding: 10px; border-radius: 5px;")
        layout.addWidget(desc_label)

        # Current values section
        values_group = QGroupBox("Current Values")
        values_group.setStyleSheet("""
            QGroupBox {
                background-color: #2D2D2D;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        values_layout = QVBoxLayout(values_group)

        # Base value
        base_value = stat_value
        race_mod = modifier_info.race_modifiers.get(stat_name, 0)
        class_mod = modifier_info.class_modifiers.get(stat_name, 0)
        total_value = base_value + race_mod + class_mod
        ability_mod = (total_value - 10) // 2
        min_req = modifier_info.minimum_requirements.get(stat_name, 0)

        values_text = f"""<p><b>Base Value:</b> {base_value}</p>
        <p><b>Race Modifier:</b> <span style='color: {'#4CAF50' if race_mod > 0 else ('#F44336' if race_mod < 0 else '#CCCCCC')}'>{'+'+ str(race_mod) if race_mod > 0 else race_mod if race_mod != 0 else '0'}</span> ({modifier_info.race_name})</p>
        <p><b>Class Modifier:</b> <span style='color: {'#2196F3' if class_mod > 0 else ('#F44336' if class_mod < 0 else '#CCCCCC')}'>{'+'+ str(class_mod) if class_mod > 0 else class_mod if class_mod != 0 else '0'}</span> ({modifier_info.class_name})</p>
        <p><b>Total Value:</b> {total_value}</p>
        <p><b>Ability Modifier:</b> <span style='color: {'#4CAF50' if ability_mod > 0 else ('#F44336' if ability_mod < 0 else '#CCCCCC')}'>{'+'+ str(ability_mod) if ability_mod > 0 else ability_mod if ability_mod != 0 else '0'}</span></p>"""

        # Add minimum requirement if it exists
        if min_req > 0:
            values_text += f"""<p><b>Minimum Requirement:</b> <span style='color: {'#4CAF50' if total_value >= min_req else '#F44336'}>{min_req}</span> ({modifier_info.class_name})</p>"""

        values_label = QLabel(values_text)
        values_label.setWordWrap(True)
        values_layout.addWidget(values_label)
        layout.addWidget(values_group)

        # Game effects section
        effects_group = QGroupBox("Game Effects")
        effects_group.setStyleSheet("""
            QGroupBox {
                background-color: #2D2D2D;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        effects_layout = QVBoxLayout(effects_group)

        # Effects based on the stat
        effects = {
            "STR": ["Melee attack damage", "Carrying capacity", "Breaking objects", "Grappling"],
            "DEX": ["Ranged attack accuracy", "Initiative in combat", "Dodge chance", "Stealth"],
            "CON": ["Hit points", "Resistance to poison", "Stamina and fatigue", "Survival in harsh conditions"],
            "INT": ["Spell power", "Knowledge and lore", "Language comprehension", "Puzzle solving"],
            "WIS": ["Magical resistance", "Perception", "Survival skills", "Willpower checks"],
            "CHA": ["NPC reactions", "Prices when buying/selling", "Leadership", "Persuasion attempts"],
            # --- MODIFICATION: Add effects for WIL and INS ---
            "WIL": ["Resisting mental attacks/control", "Maintaining concentration (spells)", "Enduring stress/fear", "Pushing through fatigue"],
            "INS": ["Detecting lies/motives", "Noticing hidden details", "Understanding complex situations", "Making intuitive connections"]
            # --- END MODIFICATION ---
        }

        effects_text = "<p>This stat affects:</p><ul>"
        for effect in effects.get(stat_name, []):
            modifier_text = "+" if ability_mod > 0 else "-" if ability_mod < 0 else "±"
            effects_text += f"<li>{effect} <span style='color: {'#4CAF50' if ability_mod > 0 else ('#F44336' if ability_mod < 0 else '#CCCCCC')}'>({modifier_text})</span></li>"
        effects_text += "</ul>"

        effects_label = QLabel(effects_text)
        effects_label.setWordWrap(True)
        effects_layout.addWidget(effects_label)
        layout.addWidget(effects_group)

        # Class importance
        importance = "Unknown"
        importance_color = "#CCCCCC"

        if stat_name in modifier_info.recommended_stats.get("primary", []):
            importance = "Primary"
            importance_color = "#4CAF50"  # Green
        elif stat_name in modifier_info.recommended_stats.get("secondary", []):
            importance = "Secondary"
            importance_color = "#FFC107"  # Amber
        elif stat_name in modifier_info.recommended_stats.get("tertiary", []):
            importance = "Tertiary"
            importance_color = "#F44336"  # Red

        importance_text = f"<p><b>Importance for {modifier_info.class_name}:</b> <span style='color: {importance_color}'>{importance}</span></p>"
        importance_label = QLabel(importance_text)
        importance_label.setWordWrap(True)
        layout.addWidget(importance_label)

        # Close button
        close_button = QPushButton("Close")
        close_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #0b7dda;
            }
            QPushButton:pressed {
                background-color: #0a5999;
            }
        """)
        close_button.clicked.connect(self.accept)
        layout.addWidget(close_button, 0, Qt.AlignCenter)


class StatRow:
    """A class to hold UI elements for a stat row."""
    
    def __init__(self):
        self.name_label = None
        self.info_button = None
        self.base_label = None
        self.increase_button = None
        self.decrease_button = None
        self.race_mod_label = None
        self.class_mod_label = None
        self.total_label = None
        self.mod_label = None


class StatAllocationWidget(QWidget):
    """Widget for allocating stat points during character creation or level-up."""
    
    # Signal emitted when stats change
    stats_changed = Signal(dict)
    allocation_complete = Signal()
    
    def __init__(
        self, 
        stats_manager: StatsManager,
        race_name: str = "Human",
        class_name: str = "Warrior",
        total_points: int = 27,
        min_value: int = 8,
        max_value: int = 15,
        parent: Optional[QWidget] = None
    ):
        """
        Initialize the stat allocation widget.
        
        Args:
            stats_manager: The stats manager to modify
            race_name: The character's race
            class_name: The character's class
            total_points: Total points available for allocation
            min_value: Minimum stat value
            max_value: Maximum stat value
            parent: The parent widget
        """
        super().__init__(parent)
        
        # Set up the stat allocator
        self.stats_manager = stats_manager
        self.allocator = StatPointAllocator(stats_manager, total_points, min_value, max_value)
        
        # Load race and class modifiers
        self.modifier_info = StatModifierInfo()
        self.modifier_info.load_modifiers(race_name, class_name)
        
        # Create UI elements dictionary
        self.stat_rows = {}
        
        # Create the UI elements
        self._setup_ui()
        
        # Update the display
        self._update_all_stat_displays()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # Create the stats info header
        header_layout = QHBoxLayout()

        # Points remaining label
        self.points_label = QLabel(f"Points Remaining: {self.allocator.get_remaining_points()}")
        self.points_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: #E0E0E0;
            }
        """)
        header_layout.addWidget(self.points_label)

        # Add spacer
        header_layout.addStretch()

        # Add reset button
        self.reset_button = QPushButton("Reset")
        self.reset_button.setToolTip("Reset all stats to minimum values")
        self.reset_button.setFixedWidth(80)
        self.reset_button.clicked.connect(self._reset_stats)
        header_layout.addWidget(self.reset_button)

        # Add header to main layout
        main_layout.addLayout(header_layout)

        # Create the stat grid
        stats_group = QGroupBox("Character Stats")
        stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)

        stats_layout = QGridLayout(stats_group)
        stats_layout.setContentsMargins(15, 20, 15, 15)
        stats_layout.setHorizontalSpacing(5) # Reduced horizontal spacing
        stats_layout.setVerticalSpacing(10) # Keep vertical spacing reasonable

        col1_start = 0
        col2_start = 8
        separator_col = 7
        num_cols_per_stat = 7
        num_stats_per_col = 4 

        headers = ["Stat", "Base", "Adjust", "Race", "Class", "Total", "Mod"]
        mod_tooltip = (
            "<b>Ability Score Modifier</b><br>"
            "This is calculated as: (Total Stat Value - 10) ÷ 2, rounded down.<br><br>"
            "It represents the bonus or penalty applied to actions using this stat.<br>"
            "For example, a Strength of 14 gives a +2 modifier to melee attacks.<br><br>"
            "<i>Note: This is not the same as Race/Class modifiers, which directly modify the stat value.</i>"
        )

        for col_offset in [col1_start, col2_start]:
            for i, header_text in enumerate(headers):
                if header_text == "Mod":
                    header_widget = TooltipLabel(header_text, mod_tooltip)
                    header_widget.setStyleSheet("font-weight: bold; color: #CCCCCC; text-decoration: underline dotted;")
                    header_widget.setCursor(Qt.WhatsThisCursor)
                else:
                    header_widget = QLabel(header_text)
                    header_widget.setStyleSheet("font-weight: bold; color: #CCCCCC;")
                stats_layout.addWidget(header_widget, 0, col_offset + i, alignment=Qt.AlignCenter)

        all_stat_types = list(StatType) # Get all stat types
        for index, stat_type in enumerate(all_stat_types):
            stat_name = str(stat_type)

            # Determine row and column offset
            row = (index % num_stats_per_col) + 1 # Row index (1-based)
            col_offset = col1_start if index < num_stats_per_col else col2_start

            # Create row object to hold UI elements
            stat_row = StatRow()

            # Create stat name layout with info icon and impact indicators
            stat_name_layout = QHBoxLayout()
            stat_name_layout.setSpacing(2)
            stat_name_layout.setContentsMargins(0, 0, 0, 0)

            # Create stat name label with importance coloring
            stat_row.name_label = QLabel(stat_name)
            name_color = "#E0E0E0"
            if stat_name in self.modifier_info.recommended_stats.get("primary", []): name_color = "#4CAF50"
            elif stat_name in self.modifier_info.recommended_stats.get("secondary", []): name_color = "#FFD700"
            elif stat_name in self.modifier_info.recommended_stats.get("tertiary", []): name_color = "#E65100"
            stat_row.name_label.setStyleSheet(f"color: {name_color}; font-weight: bold;")
            stat_row.name_label.setCursor(Qt.PointingHandCursor)
            stat_row.name_label.mousePressEvent = lambda event, s=stat_type: self._show_stat_info(s)

            # Define icons and their individual tooltips
            impact_icons = {
                "STR": [("⚔️", "Melee Combat Damage"), ("🏋️", "Carrying Capacity")],
                "DEX": [("🏹", "Ranged Attack Accuracy"), ("👟", "Initiative/Dodge")], 
                "CON": [("❤️", "Health Points"), ("🛡️", "Damage Resistance")],
                "INT": [("📚", "Knowledge & Learning"), ("✨", "Spell Power")],
                "WIS": [("👁️", "Perception"), ("🙏", "Magical Resistance")], 
                "CHA": [("💬", "Persuasion"), ("👑", "Leadership/Prices")],
                "WIL": [("🧠", "Mental Fortitude"), ("🛡️", "Resist Influence")],
                "INS": [("💡", "Intuition/Problem Solving"), ("🧐", "Reading People/Situations")] 

            }

            stat_icons = impact_icons.get(stat_name, [])
            icons_layout = QHBoxLayout()
            icons_layout.setSpacing(1)
            icons_layout.setContentsMargins(0, 0, 0, 0)
            for icon, tooltip in stat_icons:
                icon_label = TooltipLabel(icon, tooltip)
                icon_label.setStyleSheet("font-size: 12px;")
                icon_label.setFixedWidth(20)
                icon_label.setAlignment(Qt.AlignCenter)
                icons_layout.addWidget(icon_label)
            icons_widget = QWidget()
            icons_widget.setLayout(icons_layout)
            icons_widget.setFixedWidth(45)
            icons_widget.setMouseTracking(True)

            # Create info icon button
            stat_row.info_button = QPushButton()
            stat_row.info_button.setIcon(self._create_info_icon())
            stat_row.info_button.setIconSize(QSize(16, 16))
            stat_row.info_button.setFixedSize(20, 20)
            stat_row.info_button.setStyleSheet("""
                QPushButton { background-color: transparent; border: none; }
                QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); border-radius: 10px; }
            """)
            stat_row.info_button.setCursor(Qt.PointingHandCursor)
            stat_row.info_button.setToolTip("Click for detailed information")
            stat_row.info_button.clicked.connect(lambda checked=False, s=stat_type: self._show_stat_info(s))

            # Add to name layout
            stat_name_layout.addWidget(stat_row.name_label)
            stat_name_layout.addWidget(icons_widget)
            stat_name_layout.addWidget(stat_row.info_button)

            # Create base value label
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            stat_row.base_label = QLabel(str(base_value))
            stat_row.base_label.setStyleSheet("color: #E0E0E0;")
            stat_row.base_label.setAlignment(Qt.AlignCenter)

            # Create adjustment buttons layout
            adjust_layout = QHBoxLayout()
            adjust_layout.setSpacing(2)
            project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', '..'))
            left_arrow_path = os.path.join(project_root, "images", "icons", "left_arrow.svg")
            right_arrow_path = os.path.join(project_root, "images", "icons", "right_arrow.svg")
            stat_row.decrease_button = QPushButton()
            stat_row.decrease_button.setIcon(QIcon(left_arrow_path))
            stat_row.decrease_button.setIconSize(QSize(16, 16)); stat_row.decrease_button.setFixedSize(24, 24)
            stat_row.decrease_button.setStyleSheet("QPushButton { background-color: #AA4444; color: white; font-weight: bold; border-radius: 4px; border: none; } QPushButton:hover { background-color: #CC5555; } QPushButton:pressed { background-color: #993333; } QPushButton:disabled { background-color: #555555; color: #888888; }")
            stat_row.decrease_button.clicked.connect(lambda checked=False, s=stat_type: self._decrease_stat(s))
            stat_row.increase_button = QPushButton()
            stat_row.increase_button.setIcon(QIcon(right_arrow_path))
            stat_row.increase_button.setIconSize(QSize(16, 16)); stat_row.increase_button.setFixedSize(24, 24)
            stat_row.increase_button.setStyleSheet("QPushButton { background-color: #4CAF50; color: white; font-weight: bold; border-radius: 4px; border: none; } QPushButton:hover { background-color: #66BB69; } QPushButton:pressed { background-color: #3B8C3E; } QPushButton:disabled { background-color: #555555; color: #888888; }")
            stat_row.increase_button.clicked.connect(lambda checked=False, s=stat_type: self._increase_stat(s))
            adjust_layout.addWidget(stat_row.decrease_button)
            adjust_layout.addWidget(stat_row.increase_button)

            # Create race modifier label
            race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
            mod_text = f"{race_mod:+d}" if race_mod != 0 else "0"
            stat_row.race_mod_label = QLabel(mod_text)
            stat_row.race_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'race')};")
            stat_row.race_mod_label.setAlignment(Qt.AlignCenter)

            # Create class modifier label
            class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
            mod_text = f"{class_mod:+d}" if class_mod != 0 else "0"
            stat_row.class_mod_label = QLabel(mod_text)
            stat_row.class_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'class')};")
            stat_row.class_mod_label.setAlignment(Qt.AlignCenter)

            # Create total value label
            total_value = base_value + race_mod + class_mod
            stat_row.total_label = QLabel(str(total_value))
            stat_row.total_label.setStyleSheet("color: #E0E0E0; font-weight: bold;")
            stat_row.total_label.setAlignment(Qt.AlignCenter)

            # Create modifier label
            modifier = (total_value - 10) // 2
            mod_text = f"{modifier:+d}" if modifier != 0 else "0"
            stat_row.mod_label = QLabel(mod_text)
            stat_row.mod_label.setStyleSheet(f"color: {'#4CAF50' if modifier > 0 else ('#F44336' if modifier < 0 else '#CCCCCC')};")
            stat_row.mod_label.setAlignment(Qt.AlignCenter)

            # Add mouseover tooltip to the entire row
            tooltip_text = self.modifier_info.get_tooltip_text(stat_name, base_value)
            for widget in [stat_row.name_label, stat_row.base_label, stat_row.race_mod_label,
                          stat_row.class_mod_label, stat_row.total_label, stat_row.mod_label]:
                if widget: widget.setToolTip(tooltip_text)

            # Add widgets to the grid using the calculated row and column offset
            stats_layout.addLayout(stat_name_layout, row, col_offset + 0)
            stats_layout.addWidget(stat_row.base_label, row, col_offset + 1, alignment=Qt.AlignCenter)
            stats_layout.addLayout(adjust_layout, row, col_offset + 2)
            stats_layout.addWidget(stat_row.race_mod_label, row, col_offset + 3, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.class_mod_label, row, col_offset + 4, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.total_label, row, col_offset + 5, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.mod_label, row, col_offset + 6, alignment=Qt.AlignCenter)

            # Store the row for later reference
            self.stat_rows[stat_type] = stat_row

        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        separator.setStyleSheet("color: #555555;") # Make it visible
        stats_layout.addWidget(separator, 1, separator_col, num_stats_per_col, 1) # Span rows

        # Give more space to name columns, less to modifiers/buttons
        for col_offset in [col1_start, col2_start]:
            stats_layout.setColumnStretch(col_offset + 0, 3) # Name
            stats_layout.setColumnStretch(col_offset + 1, 1) # Base
            stats_layout.setColumnStretch(col_offset + 2, 2) # Adjust
            stats_layout.setColumnStretch(col_offset + 3, 1) # Race
            stats_layout.setColumnStretch(col_offset + 4, 1) # Class
            stats_layout.setColumnStretch(col_offset + 5, 1) # Total
            stats_layout.setColumnStretch(col_offset + 6, 1) # Mod
        stats_layout.setColumnStretch(separator_col, 0) # No stretch for separator
        # --- END MODIFICATION ---

        # Add stat color explanation (adjust row index)
        stat_colors_explanation = QLabel("* Stat colors: Green = Primary, Gold = Secondary, Dark Orange = Tertiary for your class")
        stat_colors_explanation.setStyleSheet("color: #AAAAAA; font-size: 10px; font-style: italic;")
        # Place below the grid, spanning all columns used
        stats_layout.addWidget(stat_colors_explanation, num_stats_per_col + 1, 0, 1, col2_start + num_cols_per_stat, Qt.AlignLeft)

        # Add the stats group to the main layout
        main_layout.addWidget(stats_group)

        # Create preset buttons (remains the same)
        presets_group = QGroupBox("Quick Presets")
        presets_group.setStyleSheet("""
            QGroupBox { background-color: #333333; border: 1px solid #555555; border-radius: 5px; margin-top: 15px; font-weight: bold; color: #E0E0E0; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top center; padding-left: 10px; padding-right: 10px; }
        """)
        presets_layout = QHBoxLayout(presets_group)
        presets_layout.setContentsMargins(15, 20, 15, 15); presets_layout.setSpacing(10)
        self.preset_buttons = {}
        for preset_name in self.modifier_info.archetype_presets:
            preset_button = QPushButton(preset_name)
            preset_button.setToolTip(self.modifier_info.archetype_presets[preset_name].get("description", ""))
            preset_button.clicked.connect(lambda checked=False, p=preset_name: self._apply_preset(p))
            presets_layout.addWidget(preset_button)
            self.preset_buttons[preset_name] = preset_button
        if not self.preset_buttons:
            balanced_button = QPushButton("Balanced"); balanced_button.setToolTip("Apply a balanced distribution of stats")
            balanced_button.clicked.connect(lambda: self._auto_allocate(balanced=True)); presets_layout.addWidget(balanced_button)
            focused_button = QPushButton("Focused"); focused_button.setToolTip("Focus on primary stats for your class")
            focused_button.clicked.connect(lambda: self._auto_allocate(balanced=False)); presets_layout.addWidget(focused_button)
        main_layout.addWidget(presets_group)

        # Add information about race/class effects (remains the same)
        info_text = f"""
        <p><b>{self.modifier_info.race_name}:</b> {self.modifier_info.race_description}</p>
        <p><b>{self.modifier_info.class_name}:</b> {self.modifier_info.class_description}</p>
        """
        info_label = QLabel(info_text); info_label.setWordWrap(True)
        info_label.setStyleSheet("QLabel { color: #CCCCCC; background-color: #2D2D2D; padding: 10px; border-radius: 5px; }")
        main_layout.addWidget(info_label)

        # Add stretcher to push everything up
        main_layout.addStretch(1)
    
    def _increase_stat(self, stat_type: StatType) -> None:
        """
        Increase a stat by one point.

        Args:
            stat_type: The stat to increase
        """
        if self.allocator.increase_stat(stat_type):
            # Update stat display
            self._update_stat_display(stat_type)

            # Update points remaining label
            remaining_points = self.allocator.get_remaining_points() # Get remaining points
            self.points_label.setText(f"Points Remaining: {remaining_points}")

            # Emit signal with current stats
            self._emit_stats_changed()

            # --- EMIT COMPLETION SIGNAL ---
            if remaining_points == 0:
                self.allocation_complete.emit()
    
    def _decrease_stat(self, stat_type: StatType) -> None:
        """
        Decrease a stat by one point.

        Args:
            stat_type: The stat to decrease
        """
        # --- GET PREVIOUS REMAINING ---
        prev_remaining_points = self.allocator.get_remaining_points()
        # --- END GET PREVIOUS REMAINING ---

        if self.allocator.decrease_stat(stat_type):
            # Update stat display
            self._update_stat_display(stat_type)

            # Update points remaining
            remaining_points = self.allocator.get_remaining_points() # Get remaining points
            self.points_label.setText(f"Points Remaining: {remaining_points}")

            # Emit signal with current stats
            self._emit_stats_changed()

            # --- EMIT COMPLETION SIGNAL (Check if went FROM 0) ---

            if remaining_points == 0 and prev_remaining_points != 0:
                 self.allocation_complete.emit()
            elif remaining_points != 0 and prev_remaining_points == 0:

                 pass 
            # --- END EMIT COMPLETION SIGNAL ---

    def are_points_fully_allocated(self) -> bool:
        """Checks if all available points have been allocated."""
        # Ensure allocator exists before calling its method
        return hasattr(self, 'allocator') and self.allocator.get_remaining_points() == 0

    def get_remaining_points(self) -> int:
        """Returns the number of points remaining to be allocated."""
         # Ensure allocator exists before calling its method
        return self.allocator.get_remaining_points() if hasattr(self, 'allocator') else 0
    
    def _update_stat_display(self, stat_type: StatType) -> None:
        """
        Update the display for a specific stat.
        
        Args:
            stat_type: The stat to update
        """
        if stat_type not in self.stat_rows:
            return
        
        stat_row = self.stat_rows[stat_type]
        stat_name = str(stat_type)
        
        # Get current values
        base_value = int(self.stats_manager.get_stat_value(stat_type))
        race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
        class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
        total_value = base_value + race_mod + class_mod
        modifier = (total_value - 10) // 2
        
        # Update labels
        stat_row.base_label.setText(str(base_value))
        stat_row.total_label.setText(str(total_value))
        
        mod_text = f"{modifier:+d}" if modifier != 0 else "0"
        stat_row.mod_label.setText(mod_text)
        stat_row.mod_label.setStyleSheet(f"color: {'#4CAF50' if modifier > 0 else ('#F44336' if modifier < 0 else '#CCCCCC')};")
        
        # Update tooltips with new values
        tooltip_text = self.modifier_info.get_tooltip_text(stat_name, base_value)
        for widget in [stat_row.name_label, stat_row.base_label, stat_row.race_mod_label, 
                      stat_row.class_mod_label, stat_row.total_label, stat_row.mod_label]:
            widget.setToolTip(tooltip_text)
        
        # Update button states
        stat_row.increase_button.setEnabled(self.allocator.can_increase_stat(stat_type))
        stat_row.decrease_button.setEnabled(self.allocator.can_decrease_stat(stat_type))
        
        # Check if total meets minimum requirement
        min_req = self.modifier_info.minimum_requirements.get(stat_name, 0)
        if min_req > 0 and total_value < min_req:
            stat_row.total_label.setStyleSheet(f"color: {self.modifier_info.below_minimum_color}; font-weight: bold;")
        else:
            stat_row.total_label.setStyleSheet("color: #E0E0E0; font-weight: bold;")
    
    def _update_all_stat_displays(self) -> None:
        """Update all stat displays."""
        for stat_type in StatType:
            self._update_stat_display(stat_type)
        
        # Update points remaining
        self.points_label.setText(f"Points Remaining: {self.allocator.get_remaining_points()}")
    
    def _reset_stats(self) -> None:
        """Reset all stats to minimum values."""
        self.allocator.reset_to_minimum()
        self._update_all_stat_displays()
        self._emit_stats_changed()
    
    def _apply_preset(self, preset_name: str) -> None:
        """
        Apply a preset stat distribution.
        
        Args:
            preset_name: The name of the preset to apply
        """
        preset_stats = self.modifier_info.apply_preset(preset_name)
        if not preset_stats:
            return
        
        # Reset stats first
        self.allocator.reset_to_minimum()
        
        # Apply preset values
        for stat_name, value in preset_stats.items():
            try:
                stat_type = StatType.from_string(stat_name)
                current_value = int(self.stats_manager.get_stat_value(stat_type))
                
                # Increase the stat until it reaches the preset value or we can't increase anymore
                while current_value < value and self.allocator.can_increase_stat(stat_type):
                    self.allocator.increase_stat(stat_type)
                    current_value = int(self.stats_manager.get_stat_value(stat_type))
            except ValueError:
                logger.warning(f"Unknown stat in preset: {stat_name}")
        
        # Update all displays
        self._update_all_stat_displays()
        self._emit_stats_changed()
    
    def _auto_allocate(self, balanced: bool = True) -> None:
        """
        Automatically allocate points.
        
        Args:
            balanced: If True, use balanced distribution; otherwise prioritize primary stats
        """
        # Get the recommended stats order
        priority_stats = []
        
        if self.modifier_info.recommended_stats:
            # Add primary stats first
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("primary", [])])
            
            # Then secondary stats
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("secondary", [])])
            
            # Then tertiary stats
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("tertiary", [])])
            
        # If no priorities defined, use a standard order
        if not priority_stats:
            priority_stats = list(StatType)
        
        # Reset to minimum first
        self.allocator.reset_to_minimum()
        
        # Apply automatic allocation
        self.allocator.allocate_points_automatically(priority_stats, balanced)
        
        # Update displays
        self._update_all_stat_displays()
        
        # Emit signal with current stats
        self._emit_stats_changed()
    
    def _emit_stats_changed(self) -> None:
        """Emit the stats_changed signal with current stats."""
        # Get current stats with modifiers applied
        stats = {}
        for stat_type in StatType:
            stat_name = str(stat_type)
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
            stats[stat_name] = {
                "base": base_value,
                "total": total_value,
                "modifier": (total_value - 10) // 2
            }
        
        # Emit the signal
        self.stats_changed.emit(stats)
    
    def update_race_class(self, race_name: str, class_name: str) -> None:
        """
        Update the race and class modifiers.
        
        Args:
            race_name: The new race name
            class_name: The new class name
        """
        logger.info(f"Updating race to {race_name} and class to {class_name}")
        
        # Check if we're already using this race/class combination
        if race_name == self.modifier_info.race_name and class_name == self.modifier_info.class_name:
            logger.debug(f"Race and class already set to {race_name} and {class_name}, skipping update")
            return
        
        # Re-create the modifier info with new race/class to ensure fresh loading
        self.modifier_info = StatModifierInfo()
        self.modifier_info.load_modifiers(race_name, class_name)
        
        # Update UI for each stat
        for stat_type in StatType:
            if stat_type in self.stat_rows:
                stat_name = str(stat_type)
                stat_row = self.stat_rows[stat_type]
                
                # Update race modifier label
                race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
                mod_text = f"{race_mod:+d}" if race_mod != 0 else "0"
                stat_row.race_mod_label.setText(mod_text)
                stat_row.race_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'race')}; text-align: center;")
                
                # Update class modifier label
                class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
                mod_text = f"{class_mod:+d}" if class_mod != 0 else "0"
                stat_row.class_mod_label.setText(mod_text)
                stat_row.class_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'class')}; text-align: center;")
                
                # Update stat name color based on importance for current class
                name_color = "#E0E0E0"  # Default color
                if stat_name in self.modifier_info.recommended_stats.get("primary", []):
                    name_color = "#4CAF50"  # Green for primary stats
                elif stat_name in self.modifier_info.recommended_stats.get("secondary", []):
                    name_color = "#FFD700"  # Brighter yellow for secondary stats
                elif stat_name in self.modifier_info.recommended_stats.get("tertiary", []):
                    name_color = "#E65100"  # Darker orange for tertiary stats
                
                # Properly update style
                stat_row.name_label.setStyleSheet(f"color: {name_color}; font-weight: bold;")
                # Make sure cursor is maintained
                stat_row.name_label.setCursor(Qt.PointingHandCursor)
        
        # Update all displays to reflect changes
        self._update_all_stat_displays()
        
        # Update preset buttons
        self._update_preset_buttons()
        
        # Update race/class info
        self._update_race_class_info()
    
    def _update_preset_buttons(self) -> None:
        """Update the preset buttons based on current class."""
        # Clear existing buttons
        for button in self.preset_buttons.values():
            button.setParent(None)
            button.deleteLater()
        
        # Reset buttons dictionary
        self.preset_buttons = {}
        
        # Get the presets group
        presets_group = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item.widget() and isinstance(item.widget(), QGroupBox) and item.widget().title() == "Quick Presets":
                presets_group = item.widget()
                break
        
        if not presets_group:
            return
        
        # Get the layout
        presets_layout = presets_group.layout()
        if not presets_layout:
            return
        
        # Clear the layout
        while presets_layout.count():
            item = presets_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Add new preset buttons
        for preset_name in self.modifier_info.archetype_presets:
            preset_button = QPushButton(preset_name)
            preset_button.setToolTip(self.modifier_info.archetype_presets[preset_name].get("description", ""))
            preset_button.clicked.connect(lambda checked=False, p=preset_name: self._apply_preset(p))
            presets_layout.addWidget(preset_button)
            self.preset_buttons[preset_name] = preset_button
        
        # Add balanced preset if no archetypes found
        if not self.preset_buttons:
            balanced_button = QPushButton("Balanced")
            balanced_button.setToolTip("Apply a balanced distribution of stats")
            balanced_button.clicked.connect(lambda: self._auto_allocate(balanced=True))
            presets_layout.addWidget(balanced_button)
            
            focused_button = QPushButton("Focused")
            focused_button.setToolTip("Focus on primary stats for your class")
            focused_button.clicked.connect(lambda: self._auto_allocate(balanced=False))
            presets_layout.addWidget(focused_button)
    
    def _update_race_class_info(self) -> None:
        """Update the race/class information label."""
        info_text = f"""
        <p><b>{self.modifier_info.race_name}:</b> {self.modifier_info.race_description}</p>
        <p><b>{self.modifier_info.class_name}:</b> {self.modifier_info.class_description}</p>
        """
        
        # Find the info label
        info_label = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item.widget() and isinstance(item.widget(), QLabel) and "background-color: #2D2D2D" in item.widget().styleSheet():
                info_label = item.widget()
                break
        
        if info_label:
            info_label.setText(info_text)
    
    def get_current_stats(self) -> Dict[str, Dict[str, int]]:
        """
        Get the current stat values.
        
        Returns:
            Dictionary of stat names and their values
        """
        stats = {}
        for stat_type in StatType:
            stat_name = str(stat_type)
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
            stats[stat_name] = {
                "base": base_value,
                "total": total_value,
                "modifier": (total_value - 10) // 2
            }
        return stats
    
    def meets_requirements(self) -> bool:
        """
        Check if the current stats meet all class minimum requirements.
        
        Returns:
            True if all requirements are met, False otherwise
        """
        for stat_type in StatType:
            stat_name = str(stat_type)
            min_req = self.modifier_info.minimum_requirements.get(stat_name, 0)
            if min_req > 0:
                base_value = int(self.stats_manager.get_stat_value(stat_type))
                total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
                if total_value < min_req:
                    return False
        return True
        
    def _create_info_icon(self) -> QIcon:
        """
        Create an information icon.

        Returns:
            QIcon: The information icon
        """
        # Create a pixmap
        pixmap = QPixmap(24, 24)
        pixmap.fill(Qt.transparent)

        # Draw an info icon using code
        import math
        from PySide6.QtGui import QPainter, QPen, QBrush
        from PySide6.QtCore import QRect

        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)

        # Draw circle
        pen = QPen(QColor("#2196F3"))
        pen.setWidth(2)
        painter.setPen(pen)
        painter.setBrush(QBrush(QColor("#2196F3").darker(150)))
        painter.drawEllipse(2, 2, 20, 20)

        # Draw "i" character
        pen = QPen(QColor("white"))
        painter.setPen(pen)
        painter.setFont(QFont("Arial", 14, QFont.Bold))
        painter.drawText(QRect(0, 0, 24, 24), Qt.AlignCenter, "i")

        painter.end()

        return QIcon(pixmap)
    
    def _show_stat_info(self, stat_type: StatType) -> None:
        """
        Show detailed information about a stat.

        Args:
            stat_type: The stat to show information for
        """
        stat_name = str(stat_type)
        base_value = int(self.stats_manager.get_stat_value(stat_type))

        # Create and show the dialog
        dialog = StatInfoDialog(stat_name, base_value, self.modifier_info, self)
        dialog.exec_()

    def get_allocated_stats(self) -> Dict[str, int]:
        """
        Retrieves the current base stat values as allocated by the user.

        Returns:
            A dictionary mapping stat names (e.g., "STR") to their current base integer values.
        """
        allocated_stats = {}
        for stat_type in StatType:
            # Get the current BASE value directly from the stats manager
            # as the allocator modifies the manager's state
            base_value = self.stats_manager.get_stat(stat_type).base_value
            allocated_stats[str(stat_type)] = int(base_value) # Ensure it's an integer
        return allocated_stats
```

### File: gui\components\status_bar.py

```python
#!/usr/bin/env python3
"""
Status bar for the RPG game GUI.
This module provides a status bar widget for displaying game status information.
"""

import logging
from typing import Optional
from enum import Enum

from PySide6.QtWidgets import QStatusBar, QLabel, QWidget, QHBoxLayout, QFrame
from PySide6.QtCore import Qt
from PySide6.QtGui import QPixmap

from gui.utils.resource_manager import get_resource_manager

class GameMode(Enum):
    """Different game modes that affect time progression."""
    NORMAL = "Normal"
    COMBAT = "Combat"
    BARTER = "Barter"

class GameStatusBar(QStatusBar):
    """Status bar for displaying game status information."""
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the status bar."""
        super().__init__(parent)
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Apply styling
        self.setStyleSheet("""
            QStatusBar {
                background-color: #333333;
                color: #E0E0E0;
                border-top: 1px solid #555555;
            }
            QStatusBar::item {
                border: none;
            }
            QLabel {
                color: #E0E0E0;
                padding: 2px 10px;
                font-family: 'Times New Roman', serif;
            }
        """)
        
        # Current game mode
        self.current_mode = GameMode.NORMAL
        
        # Create status labels
        self.location_label = QLabel("Location: Not in game")
        self.time_label = QLabel("Time: Not in game")
        self.mode_label = QLabel("Mode: Normal")
        
        # Add permanent widgets
        self.addPermanentWidget(self.location_label)
        self.addPermanentWidget(self.time_label)
        self.addPermanentWidget(self.mode_label)
    
    def update_status(self, location: str = "", game_time: str = "", speed: str = "", mode: str = ""):
        """Update the status bar with the provided information.
        
        Args:
            location: The current location name.
            game_time: The current game time.
            speed: The current game speed.
            mode: The current game mode (Normal, Combat, Barter).
        """
        if location:
            self.location_label.setText(f"Location: {location}")
        
        if game_time:
            self.time_label.setText(f"Time: {game_time}")
        
        # Update mode if provided
        if mode:
            try:
                self.current_mode = GameMode(mode)
                self.mode_label.setText(f"Mode: {self.current_mode.value}")
            except ValueError:
                # If invalid mode name, default to Normal
                self.current_mode = GameMode.NORMAL
                self.mode_label.setText(f"Mode: {self.current_mode.value}")
        
        # If no mode specified but speed is, derive from speed
        elif speed:
            if speed.lower() == "combat":
                self.current_mode = GameMode.COMBAT
            elif speed.lower() == "pause":
                # Paused but maintain the current mode type
                pass
            else:
                self.current_mode = GameMode.NORMAL
                
            self.mode_label.setText(f"Mode: {self.current_mode.value}")

```

### File: gui\dialogs\__init__.py

```python
"""
Dialog modules for the RPG game GUI.
This package provides various dialog windows for the game.
"""

```

### File: gui\dialogs\base_dialog.py

```python
#gui/dialogs/base_dialog.py
from PySide6.QtWidgets import QDialog
from PySide6.QtCore import QSize
from PySide6.QtGui import QScreen # Correct import for QScreen

class BaseDialog(QDialog):
    """Base class for dialogs to enforce maximum size constraints."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Common dialog settings can go here if needed

    def showEvent(self, event):
        """Override showEvent to adjust maximum size safely."""
        # Let the default showEvent run first to ensure widgets are likely created
        super().showEvent(event)

        # Check if the dialog has already been adjusted in this show cycle
        # Use a flag that persists across show calls within a single instance lifecycle if needed,
        # but for maximum size constraint, checking per show is fine.
        # Let's rename the flag for clarity.
        if hasattr(self, '_constrained_to_screen') and self._constrained_to_screen:
             return

        try:
            screen = self.screen() # Get the screen the dialog is *currently* on
            if screen:
                available_geo = screen.availableGeometry()

                # Calculate max size (e.g., 95% of available space)
                max_w = int(available_geo.width() * 0.95)
                max_h = int(available_geo.height() * 0.95)

                # Only set maximum size if it's reasonable (avoid tiny max sizes)
                if max_w > 100 and max_h > 100:
                    self.setMaximumSize(max_w, max_h)
                else:
                    logger.warning(f"Calculated maximum size ({max_w}x{max_h}) is too small. Skipping setMaximumSize.")

                # Check current size against the calculated maximum
                current_w = self.width()
                current_h = self.height()

                # Calculate the ideal size based on content, but capped by max size
                hint_w = self.sizeHint().width()
                hint_h = self.sizeHint().height()
                ideal_w = min(max(current_w, hint_w), max_w) # Use size hint but respect current size if larger
                ideal_h = min(max(current_h, hint_h), max_h)

                # Resize *only* if the current size exceeds the calculated max size
                resize_needed = False
                if current_w > max_w:
                    current_w = max_w
                    resize_needed = True
                if current_h > max_h:
                    current_h = max_h
                    resize_needed = True

                if resize_needed:
                     logger.info(f"Dialog '{self.windowTitle()}' exceeds screen bounds. Resizing to fit ({current_w}x{current_h}).")
                     self.resize(current_w, current_h) # Resize down to max limits

            else:
                 logger.warning(f"Could not get screen for dialog '{self.windowTitle()}' during showEvent.")

            # Mark as constrained for this show event
            self._constrained_to_screen = True

        except Exception as e:
            logger.error(f"Error adjusting dialog size in BaseDialog.showEvent for '{self.windowTitle()}': {e}", exc_info=True)
            # Ensure the flag is set even on error to prevent repeated attempts
            self._constrained_to_screen = True


    def exec(self):
         """Override exec to ensure size adjustment flag is reset before showing."""
         # Reset the flag before showing modally
         self._constrained_to_screen = False
         # Let the default exec handle showing the dialog, which will trigger our showEvent
         return super().exec()

    def open(self):
        """Override open to ensure size adjustment flag is reset before showing."""
         # Reset the flag before showing modelessly
        self._constrained_to_screen = False
         # Let the default open handle showing the dialog, which will trigger our showEvent
        return super().open()
```

### File: gui\dialogs\character_creation_dialog.py

```python
#!/usr/bin/env python3
"""
Enhanced character creation dialog with Origin selection and stat allocation for the RPG game GUI.
"""

import os
import json
import logging
from typing import Dict, Optional, Any, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QComboBox,
    QPushButton, QGroupBox, QTextEdit, QTabWidget, QWidget, QMessageBox,
    QCheckBox, QFormLayout
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QPixmap, QIcon

from gui.dialogs.new_game_dialog import NewGameDialog
from gui.components.stat_allocation_widget import StatAllocationWidget
from core.stats.stats_manager import StatsManager
from core.utils.logging_config import get_logger
from core.agents.narrator import get_narrator_agent 
from core.agents.base_agent import AgentContext 
from core.base.config import get_config 

logger = get_logger("GUI")

class CharacterCreationDialog(NewGameDialog):
    """Extended dialog for creating a new game character with Origin selection and stat allocation."""

    def __init__(self, parent=None):
        """Initialize the character creation dialog."""
        # We call QDialog's init directly as we heavily override the UI from NewGameDialog
        QDialog.__init__(self, parent)

        # Set window properties from NewGameDialog if desired
        self.setWindowTitle("Create New Character")
        self.setMinimumWidth(800)
        # --- MODIFICATION: Reduced height ---
        self.setMinimumHeight(550) # Adjusted height (was 650)
        # --- END MODIFICATION ---
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
                padding-top: 3px;
            }
            QLineEdit, QTextEdit, QComboBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 10px 0 10px;
                color: #E0E0E0;
            }
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #333333;
                border-radius: 5px;
            }
            QTabBar::tab {
                background-color: #444444;
                color: #CCCCCC;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 10px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #333333;
                color: #E0E0E0;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            #OriginDetailsLabel {
                color: #CCCCCC;
                padding-left: 5px;
                padding-top: 0px;
            }
        """)

        # Load data dynamically
        self.available_races = self._load_races()
        self.available_classes = self._load_classes()
        self.available_origins = self._load_origins() # Load origins
        self.available_sexes = ["Male", "Female", "Other"]

        # Initialize other state variables BEFORE UI setup that might use them
        self.llm_enabled = True
        self.selected_icon_path = None
        self.selected_origin_data = None
        self._last_generated_params = None

        # Initialize character icons list BEFORE UI setup
        self.character_icons = []
        self.current_icon_index = 0

        # Create stats manager BEFORE UI setup (StatAllocationWidget needs it)
        self.stats_manager = StatsManager()

        # Set up the UI with tabs SECOND (this creates self.icon_label etc.)
        self._setup_ui_with_tabs()

        # Scan for icons and display the first one THIRD (now self.icon_label exists)
        # Initial scan based on default selections
        self.scan_character_icons(self.race_combo.currentText(), self.path_combo.currentText(), self.sex_combo.currentText())

        # Connect signals FOURTH
        self._connect_signals()

        # Update UI based on initial race/class FIFTH (important for stat allocation)
        self._update_race_class() # This also calls _show_stat_requirements_info

        self._on_origin_selected(self.origin_combo.currentIndex())

        # Initial validation LAST
        self._validate_form()

    def _setup_ui_with_tabs(self):
        """Set up the main UI using tabs."""
        # Main layout for the dialog
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(15, 15, 15, 15)
        dialog_layout.setSpacing(10)

        # Create tab widget
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget::pane { border: 1px solid #555555; background-color: #333333; border-radius: 5px; }
            QTabBar::tab { background-color: #444444; color: #CCCCCC; border: 1px solid #555555; border-bottom: none; border-top-left-radius: 4px; border-top-right-radius: 4px; padding: 6px 10px; margin-right: 2px; }
            QTabBar::tab:selected { background-color: #333333; color: #E0E0E0; }
        """)

        # --- Tab 1: Basic Info & Origin ---
        self.basic_info_tab = QWidget()
        basic_info_main_layout = QHBoxLayout(self.basic_info_tab)
        basic_info_main_layout.setSpacing(15)

        # Left Side: Character Info & Portrait
        left_basic_layout = QVBoxLayout()

        info_group = QGroupBox("Character Information")
        info_form_layout = QFormLayout(info_group)
        info_form_layout.setContentsMargins(15, 25, 15, 15)
        info_form_layout.setSpacing(8)

        # Create UI elements (Name, Race, Class, Origin Combo, Sex, LLM Checkbox)
        self.player_name_edit = QLineEdit()
        self.player_name_edit.setPlaceholderText("Enter your character's name...")
        info_form_layout.addRow("Name:", self.player_name_edit)

        self.race_combo = QComboBox()
        self._populate_combo(self.race_combo, self.available_races, "Races") # Populate basic combos early
        info_form_layout.addRow("Race:", self.race_combo)

        self.path_combo = QComboBox() # Represents Class
        self._populate_combo(self.path_combo, self.available_classes, "Classes") # Populate basic combos early
        info_form_layout.addRow("Class:", self.path_combo)

        self.origin_combo = QComboBox() # Create the combo, but DON'T populate yet
        info_form_layout.addRow("Origin:", self.origin_combo)

        self.sex_combo = QComboBox()
        self._populate_combo(self.sex_combo, self.available_sexes, "Sexes") # Populate basic combos early
        info_form_layout.addRow("Sex:", self.sex_combo)

        self.llm_checkbox = QCheckBox("Enable LLM (AI processing)")
        self.llm_checkbox.setChecked(self.llm_enabled)
        info_form_layout.addRow("", self.llm_checkbox)

        left_basic_layout.addWidget(info_group)

        # Portrait Section
        icon_group = QGroupBox("Character Portrait")
        icon_layout = QVBoxLayout(icon_group)
        icon_layout.setContentsMargins(15, 25, 15, 15)
        icon_layout.setSpacing(8)
        self.icon_label = QLabel() # Create icon label
        self.icon_label.setAlignment(Qt.AlignCenter)
        self.icon_label.setFixedSize(150, 150)
        self.icon_label.setStyleSheet("background-color: #1E1E1E; border: 1px solid #3F3F46;")
        self.icon_label.setText("No image")
        icon_layout.addWidget(self.icon_label, 0, Qt.AlignCenter)
        nav_layout = QHBoxLayout()
        self.prev_icon_button = QPushButton("←")
        self.icon_counter_label = QLabel("0 / 0") # Create counter label
        self.icon_counter_label.setAlignment(Qt.AlignCenter)
        self.next_icon_button = QPushButton("→")
        nav_layout.addWidget(self.prev_icon_button)
        nav_layout.addWidget(self.icon_counter_label)
        nav_layout.addWidget(self.next_icon_button)
        icon_layout.addLayout(nav_layout)
        portrait_hint = QLabel("Browse available portraits")
        portrait_hint.setStyleSheet("color: #888888; font-style: italic;")
        portrait_hint.setAlignment(Qt.AlignCenter)
        icon_layout.addWidget(portrait_hint)
        left_basic_layout.addWidget(icon_group)
        left_basic_layout.addStretch(1)

        # Right Side: Origin Details & Backstory Seed
        right_basic_layout = QVBoxLayout()

        origin_details_group = QGroupBox("Origin Details")
        origin_details_layout = QVBoxLayout(origin_details_group)
        origin_details_layout.setContentsMargins(15, 25, 15, 15)
        origin_details_layout.setSpacing(8)
        origin_details_layout.addWidget(QLabel("<b>Description:</b>"))
        self.origin_desc_label = QLabel("Select an Origin to see details.") # Create desc label
        self.origin_desc_label.setObjectName("OriginDetailsLabel")
        self.origin_desc_label.setWordWrap(True)
        self.origin_desc_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(self.origin_desc_label)
        origin_details_layout.addWidget(QLabel("<b>Skill Proficiencies:</b>"))
        self.origin_skills_label = QLabel("-") # Create skills label
        self.origin_skills_label.setObjectName("OriginDetailsLabel")
        self.origin_skills_label.setWordWrap(True)
        origin_details_layout.addWidget(self.origin_skills_label)
        origin_details_layout.addWidget(QLabel("<b>Origin Traits:</b>"))
        self.origin_traits_label = QLabel("-") # Create traits label
        self.origin_traits_label.setObjectName("OriginDetailsLabel")
        self.origin_traits_label.setWordWrap(True)
        self.origin_traits_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(self.origin_traits_label)
        origin_details_layout.addStretch()

        # Backstory Seed Group
        description_group = QGroupBox("Character Backstory (Seed)")
        description_layout = QVBoxLayout(description_group)
        description_layout.setContentsMargins(15, 25, 15, 15)
        description_layout.setSpacing(5)
        description_label = QLabel("Edit the text below (loaded from Origin) to guide LLM background generation:")
        description_label.setWordWrap(True)
        description_label.setStyleSheet("color: #AAAAAA; font-style: italic;")
        self.description_edit = QTextEdit() # Create text edit
        self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
        self.description_edit.setMinimumHeight(120)
        description_layout.addWidget(description_label)
        description_layout.addWidget(self.description_edit)

        # AI Buttons for Backstory
        ai_button_layout = QHBoxLayout()
        icon_path_improve = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "ai_improve.svg")
        self.improve_background_button = QPushButton()
        self.improve_background_button.setIcon(QIcon(icon_path_improve))
        self.improve_background_button.setIconSize(QSize(16, 16))
        self.improve_background_button.setToolTip("Improve Backstory Seed via AI")
        self.improve_background_button.setFixedSize(30, 30)

        icon_path_generate = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "ai_generate.svg")
        self.generate_background_button = QPushButton()
        self.generate_background_button.setIcon(QIcon(icon_path_generate))
        self.generate_background_button.setIconSize(QSize(16, 16))
        self.generate_background_button.setToolTip("Generate Backstory Seed via AI")
        self.generate_background_button.setFixedSize(30, 30)

        ai_button_layout.addStretch()
        ai_button_layout.addWidget(self.improve_background_button)
        ai_button_layout.addWidget(self.generate_background_button)
        description_layout.addLayout(ai_button_layout)

        right_basic_layout.addWidget(origin_details_group)
        right_basic_layout.addWidget(description_group)
        right_basic_layout.addStretch(1)

        basic_info_main_layout.addLayout(left_basic_layout, 1)
        basic_info_main_layout.addLayout(right_basic_layout, 2)

        # --- Tab 2: Stats --- (Will be added later by user)
        # self.stats_tab = QWidget()
        # ...

        # --- Tab 3: Stats (Renamed from Tab 2) ---
        self.stats_tab = QWidget() # Renamed variable for clarity, though index matters more
        stats_layout = QVBoxLayout(self.stats_tab)
        stats_layout.setSpacing(10)

        # Race/Class selectors
        race_class_selection_layout = QVBoxLayout()
        race_selector_layout = QHBoxLayout()
        race_selector_layout.setContentsMargins(0, 5, 0, 0); race_selector_layout.setSpacing(8)
        self.race_prev_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "left_arrow.svg")
        self.race_prev_button.setIcon(QIcon(icon_path))
        self.race_prev_button.setIconSize(QSize(16, 16)); self.race_prev_button.setFixedSize(24, 24)
        self.race_label = QLabel("Race") # Create race label
        self.race_label.setStyleSheet("color: #E0E0E0; font-weight: bold; font-size: 14px;"); self.race_label.setAlignment(Qt.AlignCenter)
        self.race_next_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "right_arrow.svg")
        self.race_next_button.setIcon(QIcon(icon_path))
        self.race_next_button.setIconSize(QSize(16, 16)); self.race_next_button.setFixedSize(24, 24)
        race_selector_layout.addWidget(self.race_prev_button); race_selector_layout.addWidget(self.race_label, 1); race_selector_layout.addWidget(self.race_next_button)
        race_class_selection_layout.addLayout(race_selector_layout)

        class_selector_layout = QHBoxLayout()
        class_selector_layout.setContentsMargins(0, 5, 0, 10); class_selector_layout.setSpacing(8)
        self.class_prev_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "left_arrow.svg")
        self.class_prev_button.setIcon(QIcon(icon_path))
        self.class_prev_button.setIconSize(QSize(16, 16)); self.class_prev_button.setFixedSize(24, 24)
        self.class_label = QLabel("Class") # Create class label
        self.class_label.setStyleSheet("color: #E0E0E0; font-weight: bold; font-size: 14px;"); self.class_label.setAlignment(Qt.AlignCenter)
        self.class_next_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "right_arrow.svg")
        self.class_next_button.setIcon(QIcon(icon_path))
        self.class_next_button.setIconSize(QSize(16, 16)); self.class_next_button.setFixedSize(24, 24)
        class_selector_layout.addWidget(self.class_prev_button); class_selector_layout.addWidget(self.class_label, 1); class_selector_layout.addWidget(self.class_next_button)
        race_class_selection_layout.addLayout(class_selector_layout)
        stats_layout.addLayout(race_class_selection_layout)

        # Stat Allocation Widget
        self.stat_allocation = StatAllocationWidget( # Create stat widget
            self.stats_manager,
            self.race_combo.currentText(),
            self.path_combo.currentText()
        )
        stats_layout.addWidget(self.stat_allocation)

        # Info Label for Stats Tab
        self.stat_info_label = QLabel() # Create stat info label
        self.stat_info_label.setWordWrap(True)
        self.stat_info_label.setStyleSheet("color: #E0E0E0; background-color: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px;")
        stats_layout.addWidget(self.stat_info_label)
        stats_layout.addStretch(1)

        # --- Tab 4: Background (Simplified) --- (Renamed from Tab 3)
        self.background_tab = QWidget()
        background_layout = QVBoxLayout(self.background_tab)
        # Maybe repurpose this tab later if needed
        background_layout.addWidget(QLabel("Review Character Summary (Optional Tab)"))
        background_layout.addStretch()

        # Add tabs to the tab widget
        self.tab_widget.addTab(self.basic_info_tab, "1. Basic Info & Origin")
        # --- MODIFICATION: Add placeholder for future Tab 2 ---
        # self.tab_widget.addTab(QWidget(), "2. Skills & Feats (TBD)") # Placeholder
        # --- END MODIFICATION ---
        # --- MODIFICATION: Renamed Stats Tab ---
        self.tab_widget.addTab(self.stats_tab, "3. Stats") # Renamed from "2. Stats"
        # --- END MODIFICATION ---
        # Connect tab changed signal
        self.tab_widget.currentChanged.connect(self._tab_changed)
        # self.tab_widget.addTab(self.background_tab, "4. Review (Optional)") # Renumbered

        dialog_layout.addWidget(self.tab_widget)

        # --- Navigation & Create Buttons ---
        bottom_button_layout = QHBoxLayout()
        self.prev_tab_button = QPushButton("< Previous")
        self.next_tab_button = QPushButton("Next >")
        self.cancel_button = QPushButton("Cancel")
        self.create_button = QPushButton("Create Character")
        self.start_game_button = QPushButton("Start Game")
        self.start_game_button.setStyleSheet("""
            QPushButton {
                background-color: #22863a;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2a9949;
            }
            QPushButton:pressed {
                background-color: #1e7e34;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
        """)
        self.start_game_button.hide()  # Initially hidden

        bottom_button_layout.addWidget(self.cancel_button)
        bottom_button_layout.addStretch()
        bottom_button_layout.addWidget(self.prev_tab_button)
        bottom_button_layout.addWidget(self.next_tab_button)
        bottom_button_layout.addWidget(self.create_button)
        # Initially hide the create button until needed
        self.create_button.hide()

        dialog_layout.addLayout(bottom_button_layout)

        # Initialize tab state
        self._tab_changed(0)

        # NOW populate the origin combo, as all widgets exist
        self._populate_origin_combo()

    def _populate_combo(self, combo: QComboBox, items: List[str], item_type: str):
        """Helper to populate QComboBox and handle empty lists."""
        combo.clear()
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItems(items)
            combo.setEnabled(True)

    def _populate_origin_combo(self):
        """
        Populate the Origin combo box, filtering based on selected Race and Class.
        """
        combo = self.origin_combo
        all_origins = self.available_origins # List of origin dicts
        item_type = "Origins"

        # Get current selections (ensure combo boxes exist first)
        selected_race = self.race_combo.currentText() if hasattr(self, 'race_combo') else None
        selected_class = self.path_combo.currentText() if hasattr(self, 'path_combo') else None

        previous_origin_id = combo.currentData()

        combo.blockSignals(True) 
        combo.clear()
        combo.addItem("--- Select an Origin ---", None) 

        if not all_origins:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
            combo.blockSignals(False)
            self._on_origin_selected(0) 
            return

        if not selected_race or not selected_class:
            combo.addItem("Select Race/Class first")
            combo.setEnabled(False)
            combo.blockSignals(False)
            self._on_origin_selected(0) 
            return

        # --- Filtering Logic ---
        suitable_origins = []
        for origin_data in all_origins:
            races_ok = True 
            if origin_data.get("suitable_races"): 
                races_ok = selected_race in origin_data["suitable_races"]

            classes_ok = True 
            if origin_data.get("suitable_classes"): 
                classes_ok = selected_class in origin_data["suitable_classes"]

            if races_ok and classes_ok:
                suitable_origins.append(origin_data)
        # --- End Filtering Logic ---

        if not suitable_origins:
            combo.addItem(f"No suitable {item_type} found")
            combo.setEnabled(False)
        else:
            reselect_index = 0 # Default to placeholder
            for index, origin_data in enumerate(suitable_origins):
                origin_id = origin_data.get('id')
                origin_name = origin_data.get('name', 'Unknown Origin')
                # Add item with name as text and id as data
                combo.addItem(origin_name, origin_id)
                # Check if this was the previously selected origin
                if origin_id == previous_origin_id:
                    reselect_index = index + 1

            combo.setEnabled(True)
            combo.setCurrentIndex(reselect_index)

        combo.blockSignals(False) # Re-enable signals
        self._on_origin_selected(combo.currentIndex())

    def _toggle_llm(self, state):
        """Toggle LLM enabled state."""
        self.llm_enabled = bool(state)
        # Enable/disable AI buttons based on LLM state
        self.improve_background_button.setEnabled(self.llm_enabled)
        self.generate_background_button.setEnabled(self.llm_enabled)

    # --- Data Loading --- (Keep as is)
    def _load_races(self) -> List[str]:
        races = []
        try:
            config = get_config()
            loaded_races_data = config.get_all("races")
            if loaded_races_data:
                race_names = sorted([data.get('name', race_id) for race_id, data in loaded_races_data.items()])
                if race_names: races = race_names
            if not races: logger.warning("Race config not found or empty.")
        except Exception as e: logger.error(f"Error loading races: {e}.")
        return races if races else ["Human"]

    def _load_classes(self) -> List[str]:
        classes = []
        try:
            config = get_config()
            loaded_classes_data = config.get_all("classes")
            if loaded_classes_data:
                class_names = sorted([data.get('name', class_id) for class_id, data in loaded_classes_data.items()])
                if class_names: classes = class_names
            if not classes: logger.warning("Class config not found or empty.")
        except Exception as e: logger.error(f"Error loading classes: {e}.")
        return classes if classes else ["Wanderer"]

    def _load_origins(self) -> List[Dict[str, Any]]:
        origins_data = []
        try:
            config = get_config()
            loaded_origins_dict = config.get_all("origins") # Load "origins" key
            if loaded_origins_dict and isinstance(loaded_origins_dict, dict):
                origins_data = list(loaded_origins_dict.values())
                origins_data.sort(key=lambda x: x.get('name', 'Unknown Origin'))
                logger.info(f"Loaded {len(origins_data)} origins from config.")
            else:
                logger.warning("Origin configuration domain ('origins') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading origins from config: {e}.")
        return origins_data

    # --- Icon Scanning & Filtering ---
    def scan_character_icons(self, race: str, class_name: str, sex: str):
        """
        Scan for character icons in the specific race/class directory
        and filter based on sex, looking for '_male' or '_female' in filenames.
        """
        self.character_icons = [] # Clear previous icons
        self.current_icon_index = 0

        if not race or not class_name or not sex or "No " in race or "No " in class_name:
            logger.warning(f"Cannot scan icons: Race ('{race}'), Class ('{class_name}'), or Sex ('{sex}') not validly selected.")
            self._display_current_icon()
            return

        try:
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            safe_race = race.replace(" ", "_")
            safe_class_name = class_name.replace(" ", "_")
            specific_icons_dir = os.path.join(project_root, "images", "character_icons", f"{safe_race}_{safe_class_name}")
            logger.debug(f"Scanning for icons in specific directory: {specific_icons_dir}")

            if not os.path.exists(specific_icons_dir):
                logger.warning(f"Icon directory not found: {specific_icons_dir}")
                self._display_current_icon()
                return

            supported_extensions = [".png", ".jpg", ".jpeg", ".gif", ".svg"]

            for filename in os.listdir(specific_icons_dir):
                if any(filename.lower().endswith(ext) for ext in supported_extensions):
                    name_part_lower = os.path.splitext(filename)[0].lower() # Filename without extension, lowercase
                    sex_lower = sex.lower()
                    include_file = False

                    # Check for specific substrings "_male" or "_female"
                    contains_male_tag = "_male" in name_part_lower
                    contains_female_tag = "_female" in name_part_lower

                    if sex_lower == "male":
                        if contains_male_tag: # Only include if it explicitly has "_male"
                            include_file = True
                    elif sex_lower == "female":
                        if contains_female_tag: # Only include if it explicitly has "_female"
                            include_file = True
                    elif sex_lower == "other":
                        # For "Other", include if either tag is present
                        if contains_male_tag or contains_female_tag:
                            include_file = True
                    
                    if include_file:
                        file_path = os.path.join(specific_icons_dir, filename)
                        self.character_icons.append({
                            "filename": filename,
                            "path": file_path
                        })

            self.character_icons.sort(key=lambda x: x["filename"])
            logger.info(f"Found {len(self.character_icons)} suitable icons in {specific_icons_dir} for sex '{sex}' (using _male/_female tags).")

        except OSError as e:
            logger.error(f"Error reading icons directory {specific_icons_dir}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error scanning icons: {e}", exc_info=True)

        self._display_current_icon()
        
    # --- Signal Connections ---
    def _connect_signals(self):
        """Connect signals to slots."""
        # Basic Info Tab
        self.player_name_edit.textChanged.connect(self._validate_form)
        self.race_combo.currentIndexChanged.connect(self._validate_form)
        self.race_combo.currentTextChanged.connect(self._update_race_class)
        self.race_combo.currentTextChanged.connect(self._populate_origin_combo) 
        self.path_combo.currentIndexChanged.connect(self._validate_form)
        self.path_combo.currentTextChanged.connect(self._update_race_class)
        self.path_combo.currentTextChanged.connect(self._populate_origin_combo) 

        # Only connect origin index change to validation and details update
        self.origin_combo.currentIndexChanged.connect(self._validate_form)
        self.origin_combo.currentIndexChanged.connect(self._on_origin_selected)

        self.sex_combo.currentIndexChanged.connect(self._validate_form)
        self.llm_checkbox.stateChanged.connect(self._toggle_llm)

        # Update icons when race, class, or sex changes
        self.race_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)
        self.path_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)
        self.sex_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)

        # Portrait
        self.prev_icon_button.clicked.connect(self._show_previous_icon)
        self.next_icon_button.clicked.connect(self._show_next_icon)

        # Stats Tab
        self.race_prev_button.clicked.connect(self._previous_race)
        self.race_next_button.clicked.connect(self._next_race)
        self.class_prev_button.clicked.connect(self._previous_class)
        self.class_next_button.clicked.connect(self._next_class)
        self.stat_allocation.stats_changed.connect(self._stats_changed)

        # Backstory Seed / AI Buttons
        self.improve_background_button.clicked.connect(self._improve_background)
        self.generate_background_button.clicked.connect(self._generate_background)

        # Dialog Buttons
        self.cancel_button.clicked.connect(self.reject)
        self.create_button.clicked.connect(self._finish_character_creation) # Connect create to finish method
        self.start_game_button.clicked.connect(self._start_new_game) # Start game button triggers special method
        self.prev_tab_button.clicked.connect(self._previous_tab)
        self.next_tab_button.clicked.connect(self._next_tab)
        
        # Set tooltips for the buttons
        self.create_button.setToolTip("Create your character and prepare to start the game")
        self.start_game_button.setToolTip("Begin your adventure with this character")
        self.cancel_button.setToolTip("Cancel character creation")

        # Connect race/class/origin/sex change to clear background generation context
        self.race_combo.currentTextChanged.connect(self._check_generated_context)
        self.path_combo.currentTextChanged.connect(self._check_generated_context)
        self.origin_combo.currentTextChanged.connect(self._check_generated_context) # Keep this check
        self.sex_combo.currentTextChanged.connect(self._check_generated_context)

        # Initial UI state update
        self._toggle_llm(self.llm_checkbox.isChecked()) # Set initial AI button state

        # Connect signals that affect AI button state
        self.player_name_edit.textChanged.connect(self._update_ai_button_state)
        self.stat_allocation.stats_changed.connect(self._update_ai_button_state)
        self.stat_allocation.allocation_complete.connect(self._update_ai_button_state)

        # Initial AI button state update
        self._update_ai_button_state()

    # --- Validation ---
    def _validate_form(self):
        """Validate the form and enable/disable the create button."""
        # This validation now applies mainly to the Create button state
        has_name = bool(self.player_name_edit.text().strip())
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0 # Check for valid origin index

        can_create = (
            has_name and
            race_selected and
            class_selected and
            origin_selected
        )

        # Get current tab
        current_tab_index = self.tab_widget.currentIndex()
        
        # Set Create button state if visible
        if self.create_button.isVisible():
            logger.debug(f"Setting create button enabled state to: {can_create}")
            self.create_button.setEnabled(can_create)
            if can_create:
                self.create_button.setToolTip("Create your character")
            else:
                self.create_button.setToolTip("Please complete all required fields")

        # Enable/disable next button based on basic info validity if on first tab
        if current_tab_index == 0:
            self.next_tab_button.setEnabled(can_create)
            if can_create:
                self.next_tab_button.setToolTip("Proceed to character stats")
            else:
                self.next_tab_button.setToolTip("Please complete all required fields before proceeding")
        else:
            self.next_tab_button.setEnabled(True) # Always enabled on other tabs (except last)


    # --- Icon Display --- (Keep as is)
    def _show_previous_icon(self):
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index - 1 + len(self.character_icons)) % len(self.character_icons)
        self._display_current_icon()

    def _show_next_icon(self):
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index + 1) % len(self.character_icons)
        self._display_current_icon()

    def _display_current_icon(self):
        if not self.character_icons:
            self.selected_icon_path = None
            self.icon_label.setText("No Icons Found")
            self.icon_counter_label.setText("0 / 0")
            return

        icon_info = self.character_icons[self.current_icon_index]
        icon_path = icon_info['path']
        self.icon_counter_label.setText(f"{self.current_icon_index + 1} / {len(self.character_icons)}")

        try:
            pixmap = QPixmap(icon_path)
            if not pixmap.isNull():
                pixmap = pixmap.scaled(self.icon_label.width(), self.icon_label.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.icon_label.setPixmap(pixmap)
                self.selected_icon_path = icon_path
            else:
                self.icon_label.setText("Load Error")
                self.selected_icon_path = None
        except Exception as e:
            logger.error(f"Error loading icon '{icon_path}': {e}")
            self.icon_label.setText("Load Error")
            self.selected_icon_path = None

    # --- Get Character Data ---
    def get_character_data(self) -> Optional[Dict[str, Any]]:
        """Get the final character data from all tabs."""
        # Validate basic info first
        if not self._validate_basic_info():
             QMessageBox.warning(self, "Incomplete Information", "Please complete the basic character information.")
             self.tab_widget.setCurrentIndex(0) # Go back to first tab
             return None

        # Retrieve basic info
        name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText()
        path = self.path_combo.currentText()
        origin_id = self.origin_combo.currentData() # Get the ID stored in data
        sex = self.sex_combo.currentText()

        # Basic validation again (should pass if Create button was enabled)
        if not name or not race or not path or origin_id is None:
             logger.error("Validation failed in get_character_data despite enabled button.")
             return None

        # Retrieve backstory seed text
        # Prioritize user edited text, fallback to origin intro text
        backstory_seed = self.description_edit.toPlainText().strip()
        if not backstory_seed and self.selected_origin_data:
            backstory_seed = self.selected_origin_data.get('introduction_text', '')

        # Retrieve final stats from allocation widget
        allocated_stats = self.stat_allocation.get_allocated_stats()
        if not allocated_stats:
            logger.error("Could not retrieve allocated stats.")
            QMessageBox.critical(self, "Stat Error", "Could not retrieve final stats. Please check the Stats tab.")
            self.tab_widget.setCurrentIndex(1) # Go to stats tab
            return None

        # Build the final data dictionary
        data = {
            'name': name,
            'race': race,
            'path': path,
            'origin_id': origin_id, # Use origin ID
            'sex': sex,
            'description': backstory_seed, # The seed text for LLM
            'use_llm': self.llm_enabled,
            'character_image': self.selected_icon_path,
            'stats': allocated_stats, # Include allocated base stats
            # Add starting items/location based on selected origin
            'starting_location_id': self.selected_origin_data.get('starting_location_id', '') if self.selected_origin_data else '',
            'starting_items': self.selected_origin_data.get('starting_items', []) if self.selected_origin_data else [],
            'initial_quests': self.selected_origin_data.get('initial_quests', []) if self.selected_origin_data else []
        }

        # --- Optional: Add compatibility fields if core engine expects them ---
        # This depends on how core/base/engine.py -> start_new_game is implemented
        # If it still expects individual base stats:
        # for stat_name, value in allocated_stats.items():
        #     data[f'base_{stat_name.lower()}'] = value
        # If it expects background name (use origin name as fallback):
        # data['background'] = self.origin_combo.currentText()
        # ---------------------------------------------------------------------

        logger.info(f"Character data collected: { {k:v for k,v in data.items() if k != 'stats'} }") # Log non-stat data
        logger.debug(f"Character stats: {data.get('stats')}")
        return data


    # --- Methods inherited or potentially modified from NewGameDialog ---
    # These might need adjustments based on the tabbed layout

    def _update_race_class(self, *args):
        """Update stat allocation and labels when race or class changes."""
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()

        if hasattr(self, 'race_label'): self.race_label.setText(race)
        if hasattr(self, 'class_label'): self.class_label.setText(class_name)

        if hasattr(self, 'stat_allocation'):
            self.stat_allocation.update_race_class(race, class_name)

        self._show_stat_requirements_info(race, class_name)
        self._validate_form() # Re-validate when race/class changes

    def _previous_race(self):
        current_index = self.race_combo.currentIndex()
        if current_index > 0:
            self.race_combo.setCurrentIndex(current_index - 1)

    def _next_race(self):
        current_index = self.race_combo.currentIndex()
        if current_index < self.race_combo.count() - 1:
            self.race_combo.setCurrentIndex(current_index + 1)

    def _previous_class(self):
        current_index = self.path_combo.currentIndex()
        if current_index > 0:
            self.path_combo.setCurrentIndex(current_index - 1)

    def _next_class(self):
        current_index = self.path_combo.currentIndex()
        if current_index < self.path_combo.count() - 1:
            self.path_combo.setCurrentIndex(current_index + 1)

    def _stats_changed(self, stats: Dict[str, Dict[str, int]]):
        """Handle stat changes from allocation widget."""
        self._validate_form() # Re-validate overall form
        self._update_ai_button_state()

    def _validate_for_ai_generation(self) -> bool:
        """Checks if conditions are met for enabling AI generation buttons."""
        has_name = bool(self.player_name_edit.text().strip())
        stats_allocated = hasattr(self, 'stat_allocation') and self.stat_allocation.are_points_fully_allocated()
        return has_name and stats_allocated

    def _update_ai_button_state(self):
        """Updates the enabled state and tooltip of AI buttons."""
        can_generate = self._validate_for_ai_generation()
        tooltip_text = ""

        if not can_generate:
            missing = []
            if not bool(self.player_name_edit.text().strip()):
                missing.append("Enter a character name")
            if not (hasattr(self, 'stat_allocation') and self.stat_allocation.are_points_fully_allocated()):
                remaining = self.stat_allocation.get_remaining_points() if hasattr(self, 'stat_allocation') else 'N/A'
                missing.append(f"Allocate all stat points ({remaining} remaining)")
            tooltip_text = "Cannot generate backstory:\n- " + "\n- ".join(missing)

        # Update Improve Button
        if hasattr(self, 'improve_background_button'):
            self.improve_background_button.setEnabled(can_generate)
            self.improve_background_button.setToolTip(tooltip_text if not can_generate else "Improve Backstory Seed via AI")

        # Update Generate Button
        if hasattr(self, 'generate_background_button'):
            self.generate_background_button.setEnabled(can_generate)
            self.generate_background_button.setToolTip(tooltip_text if not can_generate else "Generate Backstory Seed via AI")
    
    def _show_stat_requirements_info(self, race: str, class_name: str):
        """Display info about race/class modifiers and requirements."""
        if not hasattr(self, 'stat_allocation') or not hasattr(self, 'stat_info_label'):
            return

        modifier_info = self.stat_allocation.modifier_info
        if not modifier_info:
            self.stat_info_label.setText("Loading stat info...")
            return

        race_mods = modifier_info.race_modifiers
        class_mods = modifier_info.class_modifiers
        reqs = modifier_info.minimum_requirements
        recomm = modifier_info.recommended_stats

        info_text = f"<div style='font-weight: bold; font-size: 13px;'>{race} {class_name} Stat Info</div><hr>"

        def format_mods(mods_dict, color_pos, color_neg):
            if not mods_dict: return "None"
            parts = []
            for stat, mod in sorted(mods_dict.items()):
                if mod != 0:
                    color = color_pos if mod > 0 else color_neg
                    parts.append(f"<span style='color: {color}'>{stat} {mod:+d}</span>")
            return ", ".join(parts) if parts else "None"

        info_text += f"<div style='margin-bottom: 8px;'><b>Race Modifiers:</b> {format_mods(race_mods, '#4CAF50', '#F44336')}</div>"
        info_text += f"<div style='margin-bottom: 8px;'><b>Class Modifiers:</b> {format_mods(class_mods, '#2196F3', '#F44336')}</div>"

        req_text = ", ".join([f"{stat} {val}" for stat, val in sorted(reqs.items())]) if reqs else "None"
        info_text += f"<div style='margin-bottom: 8px;'><b>Minimum Requirements:</b> {req_text}</div>"

        recomm_prim = ", ".join(recomm.get('primary', [])) if recomm.get('primary') else "Balanced"
        info_text += f"<div><b>Recommended Primary:</b> {recomm_prim}</div>"

        self.stat_info_label.setText(info_text)

    @Slot()
    def _improve_background(self):
        if not self._validate_for_ai_generation(): return # Check validation first

        text = self.description_edit.toPlainText().strip()
        if not text:
            QMessageBox.warning(self, "No Text", "Please enter some background seed text first.")
            return

        detailed_context = self._get_detailed_context_for_llm()
        formatted_context = self._format_context_for_llm_prompt(detailed_context)

        prompt = (
            f"Improve the following background seed text for the character described below. "
            f"Make it an engaging character description focusing on personality, motivation, and appearance, "
            f"fitting the provided context. Do not narrate actions, just describe the character.\n\n"
            f"BACKGROUND SEED:\n{text}\n\n"
            f"{formatted_context}"
        )

        logger.debug(f"Sending improve background prompt:\n{prompt}") # Log the prompt

        # Call LLM
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={}, # Minimal state needed
            player_input=prompt, # Use the constructed prompt
            conversation_history=[], relevant_memories=[], additional_context={}
        )
        # Add error handling for LLM calls
        try:
            # Disable buttons during generation
            self.improve_background_button.setEnabled(False)
            self.generate_background_button.setEnabled(False)
            self.repaint() # Force UI update

            response = get_narrator_agent().process(ctx) # Assumes this function exists

            # Re-enable buttons
            self._update_ai_button_state()

            narrative_content = response.get("narrative") if response else None
            if narrative_content:
                self.description_edit.setPlainText(narrative_content.strip())
                # Update context tracking only AFTER successful generation
                self._last_generated_params = (
                    detailed_context.get('race',{}).get('name'),
                    detailed_context.get('class',{}).get('name'),
                    detailed_context.get('origin',{}).get('name'),
                    detailed_context.get('character',{}).get('sex')
                 )
            else:
                 QMessageBox.warning(self, "AI Error", "Could not improve background. No valid response from AI.")
        except Exception as e:
            logger.error(f"Error improving background: {e}", exc_info=True)
            QMessageBox.critical(self, "AI Error", f"An error occurred while improving the background:\n{e}")
            self._update_ai_button_state() # Ensure buttons are re-enabled on error

    @Slot()
    def _generate_background(self):
        if not self._validate_for_ai_generation(): return # Check validation first

        detailed_context = self._get_detailed_context_for_llm()
        formatted_context = self._format_context_for_llm_prompt(detailed_context)

        prompt = (
            f"Generate a short, engaging character description backstory seed (personality, motivation, appearance) "
            f"for the character described below. Do not narrate actions, just describe the character based on the context.\n\n"
            f"{formatted_context}"
        )

        logger.debug(f"Sending generate background prompt:\n{prompt}") # Log the prompt

        # Call LLM
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={}, # Minimal state needed
            player_input=prompt, # Use the constructed prompt
            conversation_history=[], relevant_memories=[], additional_context={}
        )
        # Add error handling for LLM calls
        try:
            # Disable buttons during generation
            self.improve_background_button.setEnabled(False)
            self.generate_background_button.setEnabled(False)
            self.repaint() # Force UI update

            response = get_narrator_agent().process(ctx) # Assumes this function exists

            # Re-enable buttons
            self._update_ai_button_state()

            narrative_content = response.get("narrative") if response else None
            if narrative_content:
                self.description_edit.setPlainText(narrative_content.strip())
                 # Update context tracking only AFTER successful generation
                self._last_generated_params = (
                    detailed_context.get('race',{}).get('name'),
                    detailed_context.get('class',{}).get('name'),
                    detailed_context.get('origin',{}).get('name'),
                    detailed_context.get('character',{}).get('sex')
                 )
            else:
                 QMessageBox.warning(self, "AI Error", "Could not generate background. No valid response from AI.")
        except Exception as e:
            logger.error(f"Error generating background: {e}", exc_info=True)
            QMessageBox.critical(self, "AI Error", f"An error occurred while generating the background:\n{e}")
            self._update_ai_button_state() # Ensure buttons are re-enabled on error

    def _check_generated_context(self):
        """Warn if selections change after background generation."""
        if self._last_generated_params:
            current = (
                self.race_combo.currentText(),
                self.path_combo.currentText(),
                self.origin_combo.currentText(), # Use origin name
                self.sex_combo.currentText()
            )
            if current != self._last_generated_params:
                QMessageBox.warning(
                    self,
                    "Background Mismatch",
                    "The backstory seed was generated for a previous selection. Please regenerate or edit to match."
                )
                # Clear the tracking so it doesn't warn repeatedly
                self._last_generated_params = None

    # --- Tab Navigation Logic ---
    def _previous_tab(self):
        current = self.tab_widget.currentIndex()
        if current > 0:
            self.tab_widget.setCurrentIndex(current - 1)

    def _next_tab(self):
        current = self.tab_widget.currentIndex()
        total = self.tab_widget.count()
        if current < total - 1:
            # Validate basic info before leaving first tab
            if current == 0 and not self._validate_basic_info():
                return # Stay on first tab if invalid
            self.tab_widget.setCurrentIndex(current + 1)
        # Note: Finishing logic is now in _finish_character_creation connected to create_button
        
    def _validate_basic_info(self) -> bool:
        """Validate the basic character information on the first tab."""
        logger.debug("Validating basic character information")
        
        # Check if name is entered
        name = self.player_name_edit.text().strip()
        if not name:
            logger.warning("Character creation validation failed: Missing name")
            QMessageBox.warning(self, "Missing Name", "Please enter a character name.")
            return False
            
        # Check if race is selected
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0
        if not race_selected:
            logger.warning("Character creation validation failed: Missing race")
            QMessageBox.warning(self, "Missing Race", "Please select a race for your character.")
            return False
            
        # Check if class is selected
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        if not class_selected:
            logger.warning("Character creation validation failed: Missing class")
            QMessageBox.warning(self, "Missing Class", "Please select a class for your character.")
            return False
            
        # Check if origin is selected (choosing the first placeholder item doesn't count)
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0
        if not origin_selected:
            logger.warning("Character creation validation failed: Missing origin")
            QMessageBox.warning(self, "Missing Origin", "Please select an origin for your character.")
            return False
            
        # All basic info is valid
        logger.debug("Basic character information validation passed")
        return True

    def _tab_changed(self, index: int):
        """Handle tab change events for button visibility."""
        logger.debug(f"Tab changed to index {index}")
        total = self.tab_widget.count()
        self.prev_tab_button.setEnabled(index > 0)

        # Find the correct QHBoxLayout holding the buttons
        bottom_layout = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if isinstance(item, QHBoxLayout):
                widget_texts = []
                for j in range(item.count()):
                    widget = item.itemAt(j).widget()
                    if isinstance(widget, QPushButton):
                        widget_texts.append(widget.text())
                if "< Previous" in widget_texts:
                    bottom_layout = item
                    break

        if not bottom_layout:
            logger.error("Could not find bottom button layout in _tab_changed")
            return


        stats_tab_index = 1 

        if index == stats_tab_index:  
            logger.debug("Showing 'Create Character' button on Stats tab")
            # Hide the next button if it's visible
            if self.next_tab_button.isVisible():
                bottom_layout.removeWidget(self.next_tab_button)
                self.next_tab_button.hide()

            # Show the create button
            if bottom_layout.indexOf(self.create_button) == -1:
                bottom_layout.addWidget(self.create_button)
            self.create_button.show()
            self._validate_form() 

        elif index < stats_tab_index:
            logger.debug(f"Showing 'Next' button on tab {index}")

            if self.create_button.isVisible():
                bottom_layout.removeWidget(self.create_button)
                self.create_button.hide()

            # Show the next button
            if bottom_layout.indexOf(self.next_tab_button) == -1:

                 stretch_index = -1
                 for i in range(bottom_layout.count()):
                     if bottom_layout.itemAt(i).spacerItem():
                         stretch_index = i
                         break
                 if stretch_index != -1:
                     insert_index = bottom_layout.indexOf(self.create_button)
                     if insert_index == -1: insert_index = stretch_index + 1 
                     bottom_layout.insertWidget(insert_index, self.next_tab_button)
                 else:  
                    bottom_layout.addWidget(self.next_tab_button)
            self.next_tab_button.show()
            self._validate_form()  

    def _finish_character_creation(self):
        """Final validation and show the start game button."""
        logger.info("Finalizing character creation")
        
        # Validate basic info again just in case
        if not self._validate_basic_info():
             logger.warning("Character creation finalization failed: Incomplete basic information")
             QMessageBox.warning(self, "Incomplete Information", "Please complete the basic character information on the first tab.")
             self.tab_widget.setCurrentIndex(0)
             return

        # Validate stats meet class requirements
        if not self.stat_allocation.meets_requirements():
            logger.warning("Character doesn't meet minimum stat requirements for selected class")
            result = QMessageBox.question(
                self,
                "Stat Requirements Not Met",
                "Your character doesn't meet the minimum stat requirements for the selected class. Continue anyway?",
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No
            )
            if result == QMessageBox.No:
                logger.debug("User chose to return to stats tab to adjust requirements")
                self.tab_widget.setCurrentIndex(1) # Go to stats tab
                return
            else:
                logger.info("User chose to continue with character despite unmet stat requirements")

        # If all checks pass, display character confirmation and show start game button
        character_name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()
        origin = self.origin_combo.currentText()
        
        logger.info(f"Character creation complete: {character_name} ({race} {class_name} from {origin})")
        
        message = f"Character Creation Complete!\n\n"
        message += f"Name: {character_name}\n"
        message += f"Race: {race}\n"
        message += f"Class: {class_name}\n"
        message += f"Origin: {origin}\n\n"
        message += f"Click 'Start Game' to begin your adventure or 'Cancel' to discard this character."
        
        QMessageBox.information(self, "Character Created", message)
        
        # Replace create button with start game button
        logger.debug("Replacing 'Create Character' button with 'Start Game' button")
        bottom_layout = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if isinstance(item, QHBoxLayout):
                widget_texts = []
                for j in range(item.count()):
                    widget = item.itemAt(j).widget()
                    if isinstance(widget, QPushButton):
                        widget_texts.append(widget.text())
                if "< Previous" in widget_texts:
                    bottom_layout = item
                    break
                    
        if bottom_layout:
            if bottom_layout.indexOf(self.create_button) != -1:
                bottom_layout.removeWidget(self.create_button)
                self.create_button.hide()
                
            if bottom_layout.indexOf(self.start_game_button) == -1:
                bottom_layout.addWidget(self.start_game_button)
            self.start_game_button.show()
            self.start_game_button.setFocus()
            logger.debug("'Start Game' button displayed and focused")
        else:
            logger.error("Could not find bottom button layout to replace buttons")

    def _start_new_game(self):
        """Accept the dialog to start a new game with the created character."""
        logger.info("Starting new game with created character")
        self.accept()
        
    def _get_detailed_context_for_llm(self) -> Dict[str, Any]:
        """Gathers detailed context about race, class, and origin for LLM prompts."""
        context = {}
        config = get_config()

        # --- Race Details ---
        race_name = self.race_combo.currentText()
        race_data = config.get(f"races.{race_name}", {}) # Assumes race name is key
        if not race_data: # Fallback if name isn't key
             all_races = config.get_all("races")
             race_data = next((r for r in all_races.values() if r.get("name") == race_name), {})

        context['race'] = {
            "name": race_name,
            "description": race_data.get('description', 'No description available.'),
            "traits": [f"{t.get('name', 'Unknown')}: {t.get('description', '-')}" for t in race_data.get('traits', [])]
        }

        # --- Class Details ---
        class_name = self.path_combo.currentText()
        class_data = config.get(f"classes.{class_name}", {}) # Assumes class name is key
        if not class_data: # Fallback if name isn't key
            all_classes = config.get_all("classes")
            class_data = next((c for c in all_classes.values() if c.get("name") == class_name), {})

        context['class'] = {
            "name": class_name,
            "description": class_data.get('description', 'No description available.'),
            "recommended_stats": class_data.get('recommended_stats', {}).get('primary', []),
            # Add proficiencies if needed:
            # "weapon_proficiencies": class_data.get('weapon_proficiencies', []),
            # "armor_proficiencies": class_data.get('armor_proficiencies', []),
        }

        # --- Origin Details ---
        origin_id = self.origin_combo.currentData()
        origin_data = self.selected_origin_data # Use stored data from selection
        if origin_data and origin_data.get('id') == origin_id:
            context['origin'] = {
                "name": origin_data.get('name', 'Unknown Origin'),
                "description": origin_data.get('description', 'No description available.'),
                "location": origin_data.get('starting_location_id', 'Unknown Location'), # Location ID
                # Add traits and skills if useful for context
                "traits": [f"{t.get('name', 'Unknown')}: {t.get('description', '-')}" for t in origin_data.get('origin_traits', [])],
                "skills": origin_data.get('skill_proficiencies', [])
            }
        else:
            context['origin'] = {"name": self.origin_combo.currentText(), "description": "Details unavailable."}


        # --- Character Info ---
        context['character'] = {
             "name": self.player_name_edit.text().strip(),
             "sex": self.sex_combo.currentText()
        }

        # --- Allocated Stats ---
        # Get base stats AFTER allocation for context (important!)
        if hasattr(self, 'stat_allocation'):
             context['stats'] = self.stat_allocation.get_allocated_stats() # Get base allocated stats

        return context

    def _format_context_for_llm_prompt(self, detailed_context: Dict[str, Any]) -> str:
        """Formats the detailed context into a string for the LLM prompt."""
        prompt_parts = ["Character Context:\n"]

        # Character Basics
        char_info = detailed_context.get('character', {})
        prompt_parts.append(f"- Name: {char_info.get('name', '(Not Set)')}")
        prompt_parts.append(f"- Sex: {char_info.get('sex', 'Unknown')}")

        # Race
        race_info = detailed_context.get('race', {})
        prompt_parts.append(f"\nRace: {race_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {race_info.get('description', 'N/A')}")
        if race_info.get('traits'):
            prompt_parts.append("  - Traits:")
            for trait in race_info['traits']:
                prompt_parts.append(f"    - {trait}")

        # Class
        class_info = detailed_context.get('class', {})
        prompt_parts.append(f"\nClass: {class_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {class_info.get('description', 'N/A')}")
        if class_info.get('recommended_stats'):
            prompt_parts.append(f"  - Recommended Primary Stats: {', '.join(class_info['recommended_stats'])}")

        # Origin
        origin_info = detailed_context.get('origin', {})
        prompt_parts.append(f"\nOrigin: {origin_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {origin_info.get('description', 'N/A')}")
        prompt_parts.append(f"  - Starting Location ID: {origin_info.get('location', 'N/A')}")
        if origin_info.get('skills'):
             prompt_parts.append(f"  - Origin Skills: {', '.join(origin_info['skills'])}")
        if origin_info.get('traits'):
            prompt_parts.append("  - Origin Traits:")
            for trait in origin_info['traits']:
                 prompt_parts.append(f"    - {trait}")

        # Allocated Stats
        stats_info = detailed_context.get('stats', {})
        if stats_info:
            prompt_parts.append("\nAllocated Base Stats:")
            stat_strs = [f"{name}: {val}" for name, val in sorted(stats_info.items())]
            prompt_parts.append(f"  - {', '.join(stat_strs)}")

        return "\n".join(prompt_parts)

    # --- New Slot for Icon Updates ---
    @Slot()
    def _update_icons_on_selection_change(self):
        """Calls scan_character_icons with current selections."""
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()
        sex = self.sex_combo.currentText()
        self.scan_character_icons(race, class_name, sex)
```

### File: gui\dialogs\combat_settings_dialog.py

```python
# gui/dialogs/combat_settings_dialog.py

import os
import logging
from typing import Dict, Any, List, Optional

from PySide6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel,
    QPushButton, QGroupBox, QDialogButtonBox, QFontDialog, QColorDialog,
    QSizePolicy, QFrame, QScrollArea
)
from PySide6.QtGui import QPixmap, QIcon, QFont, QColor, QPalette
from PySide6.QtCore import Qt, Slot, QSize

from gui.dialogs.base_dialog import BaseDialog

# Get logger for the dialog
logger = logging.getLogger("GUI") # Use the same logger name as combat_display

class CombatSettingsDialog(BaseDialog):
    """Dialog for configuring Combat Display settings."""

    def __init__(self, current_settings: Dict[str, Any], image_dir: str, parent: Optional[QWidget] = None):
        """
        Initialize the settings dialog.

        Args:
            current_settings: A dictionary containing the current settings.
            image_dir: The absolute path to the directory containing background images.
            parent: The parent widget.
        """
        super().__init__(parent)
        self.setWindowTitle("Combat Display Settings")
        self.setMinimumHeight(550) # Increased height slightly
        self.setMinimumWidth(850) # Increased width slightly

        # Store settings and image directory
        self.settings = current_settings.copy()
        self.image_dir = image_dir
        self.available_images: List[str] = []
        self.current_image_index: int = -1
        self.color_buttons: Dict[str, QPushButton] = {}

        # Main layout
        main_layout = QVBoxLayout(self)

        # --- Sections ---
        main_layout.addWidget(self._setup_background_section())
        main_layout.addWidget(self._setup_font_section())
        color_group = self._setup_color_section()
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setWidget(color_group)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        main_layout.addWidget(scroll_area, 1) # Allow color section to expand

        # --- Dialog Buttons ---
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        main_layout.addWidget(button_box)

        # Load initial values into UI elements
        self._load_settings_to_ui()

    # --- Section Setup Methods ---

    def _setup_background_section(self) -> QGroupBox:
        """Create the GroupBox for background image settings."""
        group = QGroupBox("Main Background Image") # Renamed for clarity
        layout = QVBoxLayout(group)
        h_layout = QHBoxLayout() # Layout for controls

        # Image Preview
        self.bg_preview_label = QLabel("No Image Selected")
        self.bg_preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.bg_preview_label.setFixedSize(200, 112) # 16:9 aspect ratio approx
        self.bg_preview_label.setFrameShape(QFrame.Shape.StyledPanel)
        self.bg_preview_label.setStyleSheet("background-color: #333;") # Dark background for preview

        # Controls Layout
        controls_layout = QVBoxLayout()
        controls_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Image Filename Label
        self.bg_filename_label = QLabel("Current: None")
        self.bg_filename_label.setWordWrap(True)
        controls_layout.addWidget(self.bg_filename_label)

        # Navigation Buttons
        nav_layout = QHBoxLayout()
        prev_button = QPushButton("< Prev") # Use standard characters
        prev_button.setToolTip("Select previous background image")
        prev_button.clicked.connect(self._browse_image_left)
        next_button = QPushButton("Next >") # Use standard characters
        next_button.setToolTip("Select next background image")
        next_button.clicked.connect(self._browse_image_right)
        nav_layout.addWidget(prev_button)
        nav_layout.addWidget(next_button)
        controls_layout.addLayout(nav_layout)

        # Clear Button
        clear_button = QPushButton("Clear Background")
        clear_button.setToolTip("Remove background image selection")
        clear_button.clicked.connect(self._clear_background)
        controls_layout.addWidget(clear_button)

        # Add preview and controls to horizontal layout
        h_layout.addWidget(self.bg_preview_label)
        h_layout.addLayout(controls_layout)
        layout.addLayout(h_layout)

        # Scan for available images
        self._scan_images()

        return group

    def _setup_font_section(self) -> QGroupBox:
        """Create the GroupBox for font settings."""
        group = QGroupBox("Font Settings")
        layout = QHBoxLayout(group) # Use QHBoxLayout for side-by-side

        # Font Selection Button
        font_button = QPushButton("Choose Base Font...")
        font_button.setToolTip("Select font family and base size for most elements")
        font_button.clicked.connect(self._choose_font)
        layout.addWidget(font_button)

        # Font Preview Label
        self.font_preview_label = QLabel("Font Preview Text")
        self.font_preview_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        layout.addWidget(self.font_preview_label)

        return group

    def _setup_color_section(self) -> QGroupBox:
        """Create the GroupBox for color settings, organized into columns."""
        group = QGroupBox("Color Settings")
        main_h_layout = QHBoxLayout(group)

        categories = {
            "Log General": [
                "color_log_default", "color_log_header", "color_log_dev",
                "color_log_system_message", "color_log_narrative", "color_log_combat_event",
                "color_log_group_bg", "color_log_text_bg"
            ],
            "Log Specific Events": [
                "color_log_damage", "color_log_heal", "color_log_crit", "color_log_miss",
                "color_log_roll", "color_log_turn", "color_log_round"
            ],
            "Entity Display": [
                "color_entity_player_bg", "color_entity_player_border",
                "color_entity_player_bg_active", "color_entity_player_border_active",
                "color_entity_enemy_bg", "color_entity_enemy_border",
                "color_entity_enemy_bg_active", "color_entity_enemy_border_active"
            ],
            "Progress Bars": [
                "color_hp_bar_chunk_normal", "color_hp_bar_chunk_low", "color_hp_bar_chunk_critical",
                "color_hp_bar_chunk_normal_bleak", "color_hp_bar_chunk_low_bleak", "color_hp_bar_chunk_critical_bleak",
                "color_stamina_bar_chunk", "color_stamina_bar_chunk_bleak",
                "color_mana_bar_chunk", "color_mana_bar_chunk_bleak", # Added Mana Bleak
                "color_resolve_bar_chunk", "color_progressbar_text", "color_progressbar_bg"
            ],
            "Section & UI Text": [
                "color_player_group_bg", "color_enemies_group_bg",
                "color_groupbox_title_text", "color_groupbox_title_bg",
                "color_status_text", "color_round_text"
            ]
        }

        for category_name, keys in categories.items():
            valid_keys_in_category = [k for k in keys if k in self.settings]
            if not valid_keys_in_category:
                continue

            category_v_layout = QVBoxLayout()
            category_v_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

            category_label = QLabel(f"<b>{category_name}</b>")
            category_v_layout.addWidget(category_label)

            form_layout = QFormLayout()
            form_layout.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
            form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
            form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapLongRows)


            valid_keys_in_category.sort() 

            for key in valid_keys_in_category:
                label_text_parts = key.replace("color_", "").replace("_", " ").split(" ")
                # Capitalize each part and join
                label_text = " ".join([part.capitalize() for part in label_text_parts]) + ":"
                
                # Specific label overrides for better readability
                if key == "color_log_default": label_text = "Log Default Text:"
                elif key == "color_log_header": label_text = "Log Header Text:"
                elif key == "color_log_dev": label_text = "Log Dev Message:"
                elif key == "color_log_system_message": label_text = "Log System Message:"
                elif key == "color_log_narrative": label_text = "Log Narrative/GM Text:"
                elif key == "color_log_combat_event": label_text = "Log Major Combat Event:"
                elif key == "color_log_group_bg": label_text = "Log Section BG:"
                elif key == "color_log_text_bg": label_text = "Log Text Area BG:"
                elif key == "color_log_damage": label_text = "Log Damage Text:"
                elif key == "color_log_heal": label_text = "Log Heal Text:"
                elif key == "color_log_crit": label_text = "Log Critical Hit:"
                elif key == "color_log_miss": label_text = "Log Miss/Fail:"
                elif key == "color_log_roll": label_text = "Log Dice Roll:"
                elif key == "color_log_turn": label_text = "Log Turn Change:"
                elif key == "color_log_round": label_text = "Log Round Change:"
                elif key == "color_entity_player_bg": label_text = "Player Entity BG:"
                elif key == "color_entity_player_border": label_text = "Player Entity Border:"
                elif key == "color_entity_player_bg_active": label_text = "Player Active BG:"
                elif key == "color_entity_player_border_active": label_text = "Player Active Border:"
                elif key == "color_entity_enemy_bg": label_text = "Enemy Entity BG:"
                elif key == "color_hp_bar_chunk_normal": label_text = "HP Bar Normal:"
                elif key == "color_hp_bar_chunk_low": label_text = "HP Bar Low:"
                elif key == "color_hp_bar_chunk_critical": label_text = "HP Bar Critical:"
                elif key == "color_hp_bar_chunk_normal_bleak": label_text = "HP Bar Normal (Bleak):"
                elif key == "color_hp_bar_chunk_low_bleak": label_text = "HP Bar Low (Bleak):"
                elif key == "color_hp_bar_chunk_critical_bleak": label_text = "HP Bar Critical (Bleak):"
                elif key == "color_stamina_bar_chunk": label_text = "Stamina Bar:"
                elif key == "color_stamina_bar_chunk_bleak": label_text = "Stamina Bar (Bleak):"
                elif key == "color_mana_bar_chunk": label_text = "Mana Bar:" # Added Mana Bar
                elif key == "color_mana_bar_chunk_bleak": label_text = "Mana Bar (Bleak):" # Added Mana Bar Bleak
                elif key == "color_resolve_bar_chunk": label_text = "Resolve Bar:"
                elif key == "color_progressbar_text": label_text = "Progress Bar Text:"
                elif key == "color_progressbar_bg": label_text = "Progress Bar BG:"
                elif key == "color_player_group_bg": label_text = "Player Section BG:"
                elif key == "color_enemies_group_bg": label_text = "Enemies Section BG:"
                elif key == "color_groupbox_title_text": label_text = "Section Title Text:"
                elif key == "color_groupbox_title_bg": label_text = "Section Title BG:"
                elif key == "color_status_text": label_text = "Status Label Text:"
                elif key == "color_round_text": label_text = "Round Label Text:"


                color_button = self._create_color_button(key)
                form_layout.addRow(label_text, color_button)
                self.color_buttons[key] = color_button

            category_v_layout.addLayout(form_layout)
            main_h_layout.addLayout(category_v_layout)

        main_h_layout.addStretch()
        return group
    # --- Helper Methods ---

    def _scan_images(self):
        """Scan the image directory for valid image files."""
        self.available_images = []
        try:
            if os.path.isdir(self.image_dir):
                for filename in sorted(os.listdir(self.image_dir)):
                    if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
                        self.available_images.append(filename)
                logger.info(f"Found {len(self.available_images)} images in {self.image_dir}")
            else:
                logger.warning(f"Image directory not found: {self.image_dir}")
        except OSError as e:
            logger.error(f"Error scanning image directory {self.image_dir}: {e}")

    def _update_background_preview(self):
        """Update the background image preview label and filename."""
        if 0 <= self.current_image_index < len(self.available_images):
            relative_path = self.available_images[self.current_image_index]
            full_path = os.path.join(self.image_dir, relative_path)
            pixmap = QPixmap(full_path)
            if not pixmap.isNull():
                scaled_pixmap = pixmap.scaled(self.bg_preview_label.size(),
                                              Qt.AspectRatioMode.KeepAspectRatioByExpanding, # Fill the space better
                                              Qt.TransformationMode.SmoothTransformation)
                # Crop the pixmap to the label size after scaling
                rect = scaled_pixmap.rect()
                rect.setSize(self.bg_preview_label.size())
                cropped_pixmap = scaled_pixmap.copy(rect)

                self.bg_preview_label.setPixmap(cropped_pixmap)
                self.bg_filename_label.setText(f"Current: {relative_path}")
                self.settings["background_image"] = relative_path # Store relative path
            else:
                logger.warning(f"Failed to load image: {full_path}")
                self._clear_background_ui() # Show error state
                self.bg_filename_label.setText(f"Error loading: {relative_path}")
        else:
            self._clear_background_ui()

    def _clear_background_ui(self):
        """Clear the background preview and filename label."""
        self.bg_preview_label.clear()
        self.bg_preview_label.setText("No Image Selected")
        self.bg_preview_label.setStyleSheet("background-color: #333;") # Reset background
        self.bg_filename_label.setText("Current: None")
        self.settings["background_image"] = None # Clear setting

    def _update_font_preview(self):
        """Update the font preview label based on current settings."""
        font_family = self.settings.get("font_family", "Arial")
        font_size = self.settings.get("font_size", 10)
        font = QFont(font_family, font_size)
        self.font_preview_label.setFont(font)
        self.font_preview_label.setText(f"{font_family}, {font_size}pt - AaBbCc") # Add sample text

    def _create_color_button(self, setting_key: str) -> QPushButton:
        """Create a button for selecting a color."""
        button = QPushButton()
        button.setProperty("setting_key", setting_key) # Store key on button
        button.setToolTip(f"Click to change color for '{setting_key}'")
        button.setMinimumHeight(25)
        button.clicked.connect(self._choose_color)
        return button

    def _update_color_button_preview(self, button: QPushButton, color_value: str):
        """Update the appearance of a color selection button."""
        try:
            qcolor = QColor(color_value)
            if qcolor.isValid():
                # Set background color
                # Determine text color based on background brightness for readability
                brightness = (qcolor.red() * 299 + qcolor.green() * 587 + qcolor.blue() * 114) / 1000
                text_color = "#000000" if brightness > 128 else "#FFFFFF"
                # Combine styles
                button.setStyleSheet(f"background-color: {color_value}; color: {text_color}; border: 1px solid #888;") # Add border for definition
                button.setText(color_value) # Display the color value
            else:
                button.setText("Invalid Color")
                button.setStyleSheet("") # Reset style
        except Exception as e:
            logger.error(f"Error updating color button preview for '{color_value}': {e}")
            button.setText("Error")
            button.setStyleSheet("")

    def _load_settings_to_ui(self):
        """Load the initial settings values into the UI controls."""
        # Background
        current_bg = self.settings.get("background_image")
        if current_bg and self.available_images: # Check if list is not empty
            try:
                self.current_image_index = self.available_images.index(current_bg)
            except ValueError:
                logger.warning(f"Saved background image '{current_bg}' not found in available images. Clearing.")
                self.current_image_index = -1 # Not found
                if "background_image" in self.settings: self.settings["background_image"] = None # Clear invalid setting
        else:
            self.current_image_index = -1
            if "background_image" in self.settings: self.settings["background_image"] = None # Ensure it's cleared if no images available
        self._update_background_preview()

        # Font
        self._update_font_preview()

        # Colors
        for key, button in self.color_buttons.items():
            # Provide a default fallback color if key is missing in settings (e.g., new setting added)
            default_color = "#FFFFFF" if "bg" in key else "#000000" # Simple default logic
            color_value = self.settings.get(key, default_color)
            self._update_color_button_preview(button, color_value)

    # --- Slots ---

    @Slot()
    def _browse_image_left(self):
        """Select the previous image."""
        if not self.available_images: return
        self.current_image_index -= 1
        if self.current_image_index < 0:
            self.current_image_index = len(self.available_images) - 1 # Wrap around
        self._update_background_preview()

    @Slot()
    def _browse_image_right(self):
        """Select the next image."""
        if not self.available_images: return
        self.current_image_index += 1
        if self.current_image_index >= len(self.available_images):
            self.current_image_index = 0 # Wrap around
        self._update_background_preview()

    @Slot()
    def _clear_background(self):
        """Clear the background image selection."""
        self.current_image_index = -1
        self._update_background_preview()

    @Slot()
    def _choose_font(self):
        """Open the QFontDialog to select a font."""
        current_family = self.settings.get("font_family", "Arial")
        current_size = self.settings.get("font_size", 10)
        current_font = QFont(current_family, current_size)

        ok, font = QFontDialog.getFont(current_font, self, "Select Base Font")
        if ok:
            self.settings["font_family"] = font.family()
            self.settings["font_size"] = font.pointSize()
            self._update_font_preview() # Update the preview label

    @Slot()
    def _choose_color(self):
        """Open the QColorDialog to select a color for the clicked button."""
        sender_button = self.sender()
        if not isinstance(sender_button, QPushButton):
            return

        setting_key = sender_button.property("setting_key")
        if not setting_key:
            logger.warning("Color button clicked without a 'setting_key' property.")
            return

        current_color_value = self.settings.get(setting_key, "#000000")
        try:
            current_qcolor = QColor(current_color_value)
            if not current_qcolor.isValid():
                logger.warning(f"Invalid current color '{current_color_value}' for key '{setting_key}'. Defaulting to black.")
                current_qcolor = QColor("#000000")
        except Exception:
             logger.warning(f"Error parsing current color '{current_color_value}' for key '{setting_key}'. Defaulting to black.")
             current_qcolor = QColor("#000000")


        # Open color dialog, always allow alpha for background colors or if current value suggests it
        options = QColorDialog.ColorDialogOption(0)
        # Enable alpha if it's a background setting OR if the current color has alpha OR if it's an rgba string
        if "bg" in setting_key.lower() or current_qcolor.alpha() < 255 or 'rgba' in current_color_value.lower():
             options = QColorDialog.ColorDialogOption.ShowAlphaChannel

        new_color = QColorDialog.getColor(current_qcolor, self, f"Select Color for {setting_key}", options=options)

        if new_color.isValid():
            # Store color. Use RGBA string if alpha is not 255, otherwise use hex.
            if new_color.alpha() < 255:
                # Store rgba string directly as it's often more CSS friendly.
                # Use integer values for RGB, float for alpha
                rgba_string = f"rgba({new_color.red()}, {new_color.green()}, {new_color.blue()}, {new_color.alphaF():.3f})"
                self.settings[setting_key] = rgba_string
                self._update_color_button_preview(sender_button, rgba_string)
            else:
                hex_name = new_color.name(QColor.NameFormat.HexRgb) # Format like #RRGGBB
                self.settings[setting_key] = hex_name
                self._update_color_button_preview(sender_button, hex_name)


    # --- Public Method ---

    def get_settings(self) -> Dict[str, Any]:
        """
        Return the modified settings dictionary.

        This should be called after the dialog has been accepted.
        """
        # The self.settings dictionary has been updated throughout interaction
        logger.info("Returning updated settings from dialog.")
        # Ensure background image is None if index is invalid or no images available
        if not self.available_images or self.current_image_index < 0 or self.current_image_index >= len(self.available_images):
            self.settings["background_image"] = None
        elif self.available_images: # Check again just in case
             self.settings["background_image"] = self.available_images[self.current_image_index]

        return self.settings


```

### File: gui\dialogs\game_over_dialog.py

```python
# gui/dialogs/game_over_dialog.py
import os
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QFrame, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QSize
from PySide6.QtGui import QFont, QColor, QPalette

class GameOverDialog(QDialog):
    """Dialog displayed when the player is defeated."""

    # Signals for button clicks
    new_game_requested = Signal()
    load_game_requested = Signal()
    load_last_save_requested = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self.setWindowTitle("Game Over")
        self.setModal(True) # Block interaction with main window
        self.setMinimumSize(400, 250)
        # Remove close button, force choice via buttons
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowCloseButtonHint | Qt.FramelessWindowHint)

        # --- Styling ---
        self.setStyleSheet("""
            QDialog {
                background-color: rgba(30, 30, 30, 0.95); /* Dark semi-transparent background */
                border: 2px solid #8B0000; /* Dark red border */
                border-radius: 15px;
            }
            QLabel#GameOverTitle {
                color: #DC143C; /* Crimson red */
                font-size: 48px;
                font-weight: bold;
                qproperty-alignment: 'AlignCenter';
                padding: 20px;
            }
            QLabel#GameOverReason {
                color: #E0E0E0; /* Light gray */
                font-size: 16px;
                qproperty-alignment: 'AlignCenter';
                padding-bottom: 20px;
            }
            QPushButton {
                background-color: #555555;
                color: #FFFFFF;
                border: 1px solid #777777;
                border-radius: 5px;
                padding: 10px 20px;
                font-size: 14px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #666666;
                border: 1px solid #999999;
            }
            QPushButton:pressed {
                background-color: #444444;
            }
            QPushButton#LoadLastSaveButton {
                background-color: #4CAF50; /* Green for emphasis */
            }
            QPushButton#LoadLastSaveButton:hover {
                background-color: #66BB69;
            }
             QPushButton#LoadLastSaveButton:pressed {
                background-color: #3B8C3E;
            }
        """)

        # --- Layout ---
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        main_layout.setAlignment(Qt.AlignCenter)

        # Title Label
        title_label = QLabel("GAME OVER")
        title_label.setObjectName("GameOverTitle")
        main_layout.addWidget(title_label, 0, Qt.AlignCenter)

        # Reason Label (optional, can be set externally)
        self.reason_label = QLabel("You have been defeated!")
        self.reason_label.setObjectName("GameOverReason")
        main_layout.addWidget(self.reason_label, 0, Qt.AlignCenter)

        # Button Layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        button_layout.setAlignment(Qt.AlignCenter) # Center buttons horizontally

        self.new_game_button = QPushButton("New Game")
        self.load_game_button = QPushButton("Load Game")
        self.load_last_save_button = QPushButton("Load Last Save")
        self.load_last_save_button.setObjectName("LoadLastSaveButton")

        button_layout.addWidget(self.new_game_button)
        button_layout.addWidget(self.load_game_button)
        button_layout.addWidget(self.load_last_save_button)

        main_layout.addLayout(button_layout)

        # --- Connections ---
        self.new_game_button.clicked.connect(self._on_new_game)
        self.load_game_button.clicked.connect(self._on_load_game)
        self.load_last_save_button.clicked.connect(self._on_load_last_save)

    def set_reason(self, reason: str):
        """Set the reason text displayed below GAME OVER."""
        self.reason_label.setText(reason)

    def _on_new_game(self):
        self.new_game_requested.emit()
        self.accept() # Close the dialog

    def _on_load_game(self):
        self.load_game_requested.emit()
        self.accept() # Close the dialog

    def _on_load_last_save(self):
        self.load_last_save_requested.emit()
        self.accept() # Close the dialog

    # --- Optional: Centering on Show ---
    def showEvent(self, event):
        """Center the dialog when shown."""
        super().showEvent(event)
        if self.parent():
            parent_rect = self.parent().geometry()
            self.move(parent_rect.center() - self.rect().center())
```

### File: gui\dialogs\item_info_dialog.py

```python
#!/usr/bin/env python3
"""
Dialog for displaying detailed item information.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout,
    QTextBrowser, QPushButton, QSizePolicy, QScrollArea, QWidget, QFrame
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QFont, QColor

from core.inventory.item import Item
from core.inventory.currency_manager import CurrencyManager 

logger = logging.getLogger("GUI")

class ItemInfoDialog(QDialog):
    """Dialog to display detailed information about an item."""

    def __init__(self, item: Optional[Item] = None, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.item = item
        self.setWindowTitle("Item Information")
        self.setMinimumSize(400, 550) # Increased min height
        self.setStyleSheet("""
            QDialog {
                background-color: #2E2E2E;
                color: #E0E0E0;
                border: 1px solid #555555;
            }
            QLabel {
                color: #E0E0E0;
                background-color: transparent;
            }
            QTextBrowser {
                background-color: #252525;
                color: #CFCFCF;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px; /* Added padding */
            }
            QPushButton {
                background-color: #4A4A4A;
                color: #E0E0E0;
                border: 1px solid #666666;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #5A5A5A;
            }
            QPushButton:pressed {
                background-color: #3A3A3A;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QWidget#scrollAreaWidgetContents { 
                background-color: transparent;
            }
            QGroupBox { /* Basic style for potential future group boxes */
                color: #E0E0E0;
                font-weight: bold;
                border: 1px solid #444444;
                border-radius: 3px;
                margin-top: 10px; /* Space above groupbox */
                padding-top: 15px; /* Space for title */
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 5px;
            }
        """)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(15, 15, 15, 15)
        self.main_layout.setSpacing(10)

        self._setup_ui()
        if self.item:
            self.populate_data()

    def _setup_ui(self):
        """Set up the UI elements for the dialog."""
        scroll_area = QScrollArea(self)
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        self.scroll_content_widget = QWidget(scroll_area)
        self.scroll_content_widget.setObjectName("scrollAreaWidgetContents")
        scroll_area.setWidget(self.scroll_content_widget)

        self.content_layout = QVBoxLayout(self.scroll_content_widget)
        self.content_layout.setSpacing(12) # Increased spacing

        # Name and Rarity
        name_rarity_layout = QHBoxLayout()
        self.name_label = QLabel("Item Name")
        self.name_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        name_rarity_layout.addWidget(self.name_label)
        name_rarity_layout.addStretch()
        self.rarity_label = QLabel("(Rarity)")
        self.rarity_label.setStyleSheet("font-size: 10pt; font-style: italic;")
        name_rarity_layout.addWidget(self.rarity_label)
        self.content_layout.addLayout(name_rarity_layout)

        # Type
        self.type_label = QLabel("Type: ?")
        self.type_label.setStyleSheet("font-size: 11pt;")
        self.content_layout.addWidget(self.type_label)
        
        self.content_layout.addWidget(self._create_separator())

        # Description
        self.description_title_label = QLabel("<b>Description:</b>")
        self.content_layout.addWidget(self.description_title_label)
        self.description_browser = QTextBrowser()
        self.description_browser.setPlaceholderText("?")
        self.description_browser.setOpenExternalLinks(True)
        self.description_browser.setMinimumHeight(60) 
        self.description_browser.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.MinimumExpanding)
        self.content_layout.addWidget(self.description_browser)

        # Grid for Weight, Value, Durability, Equip Slots
        self.grid_layout = QGridLayout()
        self.grid_layout.setSpacing(8) # Adjusted spacing
        self.grid_layout.setColumnStretch(1, 1) # Allow value column to stretch
        self.content_layout.addLayout(self.grid_layout)

        # Metrics rows
        self.weight_label = self._add_grid_row("Weight:", "?", 0)
        self.value_label = self._add_grid_row("Value:", "?", 1)
        self.quantity_label = self._add_grid_row("Quantity:", "?", 2)
        self.stack_limit_label = self._add_grid_row("Stack limit:", "?", 3)
        self.durability_label = self._add_grid_row("Durability:", "?", 4)
        self.equip_slots_label = self._add_grid_row("Equip Slots:", "?", 5)
        self.equip_slots_label.setWordWrap(True)
        
        self.content_layout.addWidget(self._create_separator())

        # Stats & Effects
        self.stats_effects_title_label = QLabel("<b>Stats & Effects:</b>")
        self.content_layout.addWidget(self.stats_effects_title_label)
        self.stats_browser = QTextBrowser()
        self.stats_browser.setPlaceholderText("?")
        self.stats_browser.setMinimumHeight(80)
        self.stats_browser.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.MinimumExpanding)
        self.content_layout.addWidget(self.stats_browser)
        
        # Custom Properties
        self.custom_props_title_label = QLabel("<b>Properties:</b>") # Changed title slightly for clarity
        self.content_layout.addWidget(self.custom_props_title_label)
        self.custom_props_browser = QTextBrowser()
        self.custom_props_browser.setPlaceholderText("?")
        self.custom_props_browser.setMinimumHeight(40)
        self.custom_props_browser.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.MinimumExpanding)
        self.content_layout.addWidget(self.custom_props_browser)

        # Tags
        self.tags_label = QLabel("Tags: ?")
        self.tags_label.setWordWrap(True)
        self.content_layout.addWidget(self.tags_label)

        self.content_layout.addStretch()
        self.main_layout.addWidget(scroll_area)

        # Close button
        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        self.main_layout.addWidget(self.close_button, 0, Qt.AlignRight)

    def _create_separator(self) -> QFrame:
        sep = QFrame()
        sep.setFrameShape(QFrame.Shape.HLine)
        sep.setFrameShadow(QFrame.Shadow.Sunken)
        sep.setStyleSheet("color: #444444;") # Make it slightly visible
        return sep

    def _add_grid_row(self, label_text: str, value_text: str, row: int) -> QLabel:
        """Helper to add a row to the grid layout."""
        label = QLabel(label_text)
        label.setStyleSheet("font-weight: bold;")
        label.setAlignment(Qt.AlignRight | Qt.AlignTop) # Align right and top for multi-line values
        value = QLabel(value_text)
        value.setWordWrap(True) # Allow values to wrap
        self.grid_layout.addWidget(label, row, 0)
        self.grid_layout.addWidget(value, row, 1)
        return value

    def populate_data(self):
        """Populate the dialog with item data."""
        if not self.item:
            self.name_label.setText("No Item Selected")
            self.description_browser.setHtml("<i>No item selected.</i>")
            self.stats_browser.setHtml("<i>No item selected.</i>")
            self.custom_props_browser.setHtml("<i>No item selected.</i>")
            self.description_title_label.setVisible(True)
            self.stats_effects_title_label.setVisible(True)
            self.custom_props_title_label.setVisible(True)
            return

        item = self.item
        known = item.known_properties

        # Name and Rarity
        title_name = item.name if "name" in known else "Unknown Item"
        if getattr(item, 'quantity', 1) > 1 and getattr(item, 'is_stackable', False):
            title_name = f"{title_name} × {int(item.quantity)}"
        self.name_label.setText(title_name)
        
        rarity_str = "?"
        rarity_color = "#CFCFCF" 
        if "rarity" in known and item.rarity:
            rarity_str = item.rarity.value.capitalize()
            rarity_color = item.rarity.color
        self.rarity_label.setText(f"({rarity_str})")
        self.rarity_label.setStyleSheet(f"font-size: 10pt; font-style: italic; color: {rarity_color};")

        # Type
        self.type_label.setText(f"Type: {item.item_type.value.capitalize() if 'item_type' in known and item.item_type else '?'}")

        # Description
        self.description_title_label.setVisible(True)
        if "description" in known:
            self.description_browser.setHtml(item.description if item.description else "<i>No description available.</i>")
        else:
            self.description_browser.setHtml("<i>Description currently unknown.</i>")


        # Weight, Value, Quantity/Stack
        if "weight" in known and item.weight is not None:
            if getattr(item, 'quantity', 1) > 1 and getattr(item, 'is_stackable', False):
                total_weight = (item.weight or 0.0) * int(item.quantity)
                self.weight_label.setText(f"{item.weight:.2f} kg (Total: {total_weight:.2f} kg)")
            else:
                self.weight_label.setText(f"{item.weight:.2f} kg")
        else:
            self.weight_label.setText("?")
        
        value_str = "?"
        if "value" in known and isinstance(item.value, int):
            cm_unit = CurrencyManager(); cm_unit.set_currency(int(item.value))
            value_str = cm_unit.get_formatted_currency()
            if getattr(item, 'quantity', 1) > 1 and getattr(item, 'is_stackable', False):
                total_val = int(item.value) * int(item.quantity)
                cm_total = CurrencyManager(); cm_total.set_currency(total_val)
                value_str = f"{value_str} (Total: {cm_total.get_formatted_currency()})"
        self.value_label.setText(value_str)

        # Quantity and Stack limit
        qty_str = str(getattr(item, 'quantity', 1)) if "quantity" in known else "?"
        self.quantity_label.setText(qty_str)
        if getattr(item, 'is_stackable', False):
            self.stack_limit_label.setText(str(getattr(item, 'stack_limit', ''))) 
        else:
            self.stack_limit_label.setText("N/A")

        durability_str = "?"
        if "durability" in known and item.durability is not None: # Check if durability itself is known
            # current_durability is also a knowable property. If item.durability is known, current_durability might also be.
            current_dur_known = "current_durability" in known
            current_dur = item.current_durability if current_dur_known and item.current_durability is not None else item.durability if item.durability is not None else "?"
            max_dur = item.durability if item.durability is not None else "?"
            if current_dur != "?" and max_dur != "?":
                durability_str = f"{current_dur} / {max_dur}"
            elif max_dur != "?": # Only max is known
                 durability_str = f"? / {max_dur}"
            else: # Neither known or only current is known (less likely)
                 durability_str = "?"

        elif "durability" not in known and item.durability is not None: # Durability exists but is not known
            durability_str = "? / ?"
        elif item.durability is None: # Item has no durability system
            durability_str = "N/A"
        self.durability_label.setText(durability_str)

        equip_slots_str = "?"
        if "is_equippable" in known: 
            if item.is_equippable:
                if "equip_slots" in known and item.equip_slots:
                    equip_slots_str = ", ".join(slot.value.replace('_', ' ').title() for slot in item.equip_slots)
                elif "equip_slots" in known: 
                     equip_slots_str = "None (Special)"
                else: 
                    equip_slots_str = "?" 
            else:
                equip_slots_str = "Not Equippable"
        self.equip_slots_label.setText(equip_slots_str)

        # Stats & Effects
        self.stats_effects_title_label.setVisible(True)
        stats_html_parts = []
        # Only try to display stats if the "stats" category itself is known
        if "stats" in known and item.stats: 
            known_item_stats_found = False
            temp_stats_list = []
            for stat_obj in item.stats:
                if f"stat_{stat_obj.name}" in known: 
                    known_item_stats_found = True
                    val_str = f"{stat_obj.value:+.1f}" if isinstance(stat_obj.value, (int, float)) and stat_obj.value != 0 else str(stat_obj.value)
                    if stat_obj.is_percentage and isinstance(stat_obj.value, (int,float)): val_str += "%"
                    display_name = stat_obj.display_name if stat_obj.display_name else stat_obj.name.replace('_', ' ').title()
                    temp_stats_list.append(f"<li><b>{display_name}:</b> {val_str}</li>")
            if known_item_stats_found:
                stats_html_parts.append("<u>Stats:</u><ul>" + "".join(temp_stats_list) + "</ul>")
        
        # Only try to display dice_roll_effects if the "dice_roll_effects" category is known
        if item.dice_roll_effects and "dice_roll_effects" in known:
            known_dice_effects_found = False
            temp_dice_effects_list = []
            for effect in item.dice_roll_effects:
                # Assume individual dice effects become known if the "dice_roll_effects" category is known
                known_dice_effects_found = True
                desc = f"{effect.dice_notation} {effect.effect_type.replace('_', ' ').title()}"
                if effect.description:
                    desc += f" <small><i>({effect.description})</i></small>"
                temp_dice_effects_list.append(f"<li>{desc}</li>")
            if known_dice_effects_found:
                 stats_html_parts.append("<u>Effects:</u><ul>" + "".join(temp_dice_effects_list) + "</ul>")
            
        if stats_html_parts:
            final_stats_html = "<br>".join(stats_html_parts)
            self.stats_browser.setHtml(final_stats_html)
        else: # No known stats or effects
            self.stats_browser.setHtml("<i>Unknown stats or effects.</i>")


        # Custom Properties
        self.custom_props_title_label.setVisible(True)
        custom_props_html = ""
        if "custom_properties" in known and item.custom_properties: 
            known_custom_prop_details = []
            for key, value in item.custom_properties.items():
                if f"custom_{key}" in known: 
                    known_custom_prop_details.append(f"<li><b>{key.replace('_', ' ').title()}:</b> {value}</li>")
            if known_custom_prop_details:
                custom_props_html = "<ul>" + "".join(known_custom_prop_details) + "</ul>"
        
        self.custom_props_browser.setHtml(custom_props_html if custom_props_html else "<i>No special properties known.</i>")


        # Tags
        self.tags_label.setVisible(True) # Always show the Tags label
        self.tags_label.setText(f"Tags: {', '.join(item.tags) if 'tags' in known and item.tags else '?'}")
```

### File: gui\dialogs\load_game_dialog.py

```python
#!/usr/bin/env python3
"""
Load game dialog for the RPG game GUI.
This module provides a dialog for loading a saved game.
"""

import logging
import os
import json
from typing import Optional, List, Dict
from datetime import datetime

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
    QPushButton, QGroupBox, QListWidget, QListWidgetItem,
    QSplitter, QWidget, QTextEdit, QHeaderView, QTableWidget,
    QTableWidgetItem, QAbstractItemView
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon, QFont

from gui.dialogs.base_dialog import BaseDialog

class LoadGameDialog(BaseDialog):
    """Dialog for loading a saved game."""
    
    def __init__(self, parent=None):
        """Initialize the load game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Load Game")
        self.setMinimumWidth(600)
        self.setMinimumHeight(400)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget, QTableWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item, QTableWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected, QTableWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover, QTableWidget::item:hover {
                background-color: #383838;
            }
            QTextEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QHeaderView::section {
                background-color: #333333;
                color: #E0E0E0;
                padding: 5px;
                border: 1px solid #444444;
            }
            QSplitter::handle {
                background-color: #444444;
            }
        """)
        
        # Selected save
        self.selected_save = None
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create a splitter for the save list and details
        splitter = QSplitter(Qt.Horizontal)
        
        # Create the saves list widget
        saves_widget = QWidget()
        saves_layout = QVBoxLayout(saves_widget)
        saves_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the saves table
        self.saves_table = QTableWidget()
        self.saves_table.setColumnCount(3)
        self.saves_table.setHorizontalHeaderLabels(["Save Name", "Date", "Character"])
        self.saves_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.saves_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.saves_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.saves_table.verticalHeader().setVisible(False)
        self.saves_table.setAlternatingRowColors(True)
        self.saves_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.saves_table.setSelectionMode(QAbstractItemView.SingleSelection)
        self.saves_table.setEditTriggers(QTableWidget.NoEditTriggers)
        
        # Add saves table to layout
        saves_layout.addWidget(self.saves_table)
        
        # Create the details widget
        details_widget = QWidget()
        details_layout = QVBoxLayout(details_widget)
        details_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the details group
        details_group = QGroupBox("Save Details")
        details_group_layout = QVBoxLayout(details_group)
        
        # Create the details text
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        
        # Add details text to group layout
        details_group_layout.addWidget(self.details_text)
        
        # Add details group to layout
        details_layout.addWidget(details_group)
        
        # Add widgets to splitter
        splitter.addWidget(saves_widget)
        splitter.addWidget(details_widget)
        
        # Set initial sizes
        splitter.setSizes([int(self.width() * 0.6), int(self.width() * 0.4)])
        
        # Add splitter to main layout
        main_layout.addWidget(splitter)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create delete button
        self.delete_button = QPushButton("Delete Save")
        self.delete_button.setEnabled(False)
        # self.delete_button.clicked.connect(self._on_delete_clicked)
        
        # Create load button
        self.load_button = QPushButton("Load Game")
        self.load_button.setEnabled(False)
        self.load_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.delete_button)
        button_layout.addWidget(self.load_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load saves
        self._load_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Connect save selection
        self.saves_table.itemSelectionChanged.connect(self._on_save_selected)
        self.saves_table.doubleClicked.connect(self._on_save_double_clicked)
    
    def _load_saves(self):
        """Load saves into the table."""
        # Clear the table
        self.saves_table.setRowCount(0)
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to table
        for i, save_file in enumerate(save_files):
            # Get the full path
            save_path = os.path.join(saves_dir, save_file)
            
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Get the modification time
            mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
            mod_time_str = mod_time.strftime("%Y-%m-%d %H:%M")
            
            # Get the character name (if possible)
            character_name = self._get_character_name(save_path)
            
            # Add row to table
            self.saves_table.insertRow(i)
            self.saves_table.setItem(i, 0, QTableWidgetItem(save_name))
            self.saves_table.setItem(i, 1, QTableWidgetItem(mod_time_str))
            self.saves_table.setItem(i, 2, QTableWidgetItem(character_name))
    
    def _get_character_name(self, save_path: str) -> str:
        """Get the character name from a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The character name, or "Unknown" if not found.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Try to get the character name
                if "player" in save_data and "name" in save_data["player"]:
                    return save_data["player"]["name"]
        except Exception as e:
            pass
        
        return "Unknown"
    
    def _get_save_details(self, save_path: str) -> str:
        """Get the details for a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The save details as a formatted string.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Extract details
                player_data = save_data.get("player", {})
                world_data = save_data.get("world", {})
                
                # Format details
                details = []
                
                # Player details
                if player_data:
                    details.append("Character Information:")
                    details.append(f"Name: {player_data.get('name', 'Unknown')}")
                    details.append(f"Race: {player_data.get('race', 'Unknown')}")
                    details.append(f"Class: {player_data.get('path', 'Unknown')}")
                    details.append(f"Background: {player_data.get('background', 'Unknown')}")
                    details.append(f"Level: {player_data.get('level', 1)}")
                    details.append("")
                
                # World details
                if world_data:
                    details.append("World Information:")
                    details.append(f"Location: {world_data.get('current_location', 'Unknown')}")
                    details.append(f"Time: {world_data.get('game_time', 'Unknown')}")
                    details.append("")
                
                # Game details
                mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
                details.append("Save Information:")
                details.append(f"Created: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}")
                details.append(f"File: {os.path.basename(save_path)}")
                
                return "\n".join(details)
        except Exception as e:
            return f"Error loading save details: {str(e)}"
    
    def _on_save_selected(self):
        """Handle save selection."""
        # Get the selected row
        selected_rows = self.saves_table.selectedItems()
        
        if not selected_rows:
            # No selection
            self.selected_save = None
            self.details_text.clear()
            self.load_button.setEnabled(False)
            self.delete_button.setEnabled(False)
            return
        
        # Get the save name
        save_name = self.saves_table.item(selected_rows[0].row(), 0).text()
        
        # Set the selected save
        self.selected_save = save_name + ".json"
        
        # Get the save path
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        save_path = os.path.join(saves_dir, self.selected_save)
        
        # Update the details
        self.details_text.setText(self._get_save_details(save_path))
        
        # Enable buttons
        self.load_button.setEnabled(True)
        self.delete_button.setEnabled(True)
    
    def _on_save_double_clicked(self, item):
        """Handle save double click."""
        # Accept the dialog to load the selected save
        self.accept()

```

### File: gui\dialogs\new_game_dialog.py

```python
# gui/dialogs/new_game_dialog.py

import os
import json
import logging
from typing import Any, Optional, List, Dict

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QComboBox,
    QPushButton, QGroupBox, QTextEdit, QMessageBox, QFormLayout,
    QCheckBox, QScrollArea, QWidget
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QPixmap
from core.base.config import get_config

# Get logger for this module
logger = logging.getLogger(__name__)

class NewGameDialog(QDialog):
    """Dialog for creating a new game character using the Origin system."""

    def __init__(self, parent=None):
        """Initialize the new game dialog."""
        super().__init__(parent)

        # Set window properties
        self.setWindowTitle("Create New Character")
        self.setMinimumWidth(700) # Increased width for more details
        self.setMinimumHeight(600) # Increased height
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
                padding-top: 3px; /* Add some vertical space */
            }
            QLineEdit, QTextEdit, QComboBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px; /* Reduced margin */
                padding-top: 10px; /* Add padding inside */
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 10px 0 10px;
                color: #E0E0E0;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            #OriginDetailsLabel { /* Style for the details labels */
                color: #CCCCCC;
                padding-left: 5px;
            }
        """)

        # Load data dynamically
        self.available_races = self._load_races()
        self.available_classes = self._load_classes()
        self.available_origins = self._load_origins() # Load origins instead of backgrounds
        self.available_sexes = ["Male", "Female", "Other"] # Added 'Other'

        # Set up character icon browsing
        self.character_icons = []
        self.current_icon_index = 0
        self.scan_character_icons()

        # Default to LLM enabled
        self.llm_enabled = True
        self.selected_icon_path = None
        self.selected_origin_data = None # Store full data of selected origin

        # Set up the UI
        self._setup_ui()

        # Connect signals
        self._connect_signals()

        # Initial validation
        self._validate_form()

    def _setup_ui(self):
        """Set up the user interface."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(10) # Reduced spacing

        # Layout for character details (info, description) and portrait
        details_layout = QHBoxLayout()
        details_layout.setSpacing(15)

        # --- Left Column: Info, Origin Details, Description ---
        left_column_widget = QWidget() # Create a widget for the scroll area
        left_column_layout = QVBoxLayout(left_column_widget)
        left_column_layout.setContentsMargins(0,0,0,0)
        left_column_layout.setSpacing(10)

        # --- Character Info Group ---
        info_group = QGroupBox("Character Information")
        info_layout = QFormLayout(info_group)
        info_layout.setContentsMargins(15, 25, 15, 15) # Adjusted margins
        info_layout.setSpacing(8) # Reduced spacing

        self.player_name_edit = QLineEdit()
        self.player_name_edit.setPlaceholderText("Enter your character's name...")
        info_layout.addRow("Name:", self.player_name_edit)

        self.race_combo = QComboBox()
        self._populate_combo(self.race_combo, self.available_races, "Races")
        info_layout.addRow("Race:", self.race_combo)

        self.path_combo = QComboBox() # Represents Class
        self._populate_combo(self.path_combo, self.available_classes, "Classes")
        info_layout.addRow("Class:", self.path_combo)

        # --- Origin Selection (Replaces Background) ---
        self.origin_combo = QComboBox()
        self._populate_origin_combo() # Custom population method
        info_layout.addRow("Origin:", self.origin_combo)
        # --- End Origin Selection ---

        self.sex_combo = QComboBox()
        self._populate_combo(self.sex_combo, self.available_sexes, "Sexes")
        info_layout.addRow("Sex:", self.sex_combo)

        self.llm_checkbox = QCheckBox("Enable LLM (AI processing)")
        self.llm_checkbox.setChecked(self.llm_enabled)
        info_layout.addRow("", self.llm_checkbox)
        left_column_layout.addWidget(info_group)

        # --- Origin Details Group (NEW) ---
        origin_details_group = QGroupBox("Origin Details")
        origin_details_layout = QVBoxLayout(origin_details_group)
        origin_details_layout.setContentsMargins(15, 25, 15, 15)
        origin_details_layout.setSpacing(8)

        self.origin_desc_label = QLabel("Select an Origin to see details.")
        self.origin_desc_label.setObjectName("OriginDetailsLabel")
        self.origin_desc_label.setWordWrap(True)
        self.origin_desc_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(QLabel("<b>Description:</b>"))
        origin_details_layout.addWidget(self.origin_desc_label)

        self.origin_skills_label = QLabel("-")
        self.origin_skills_label.setObjectName("OriginDetailsLabel")
        self.origin_skills_label.setWordWrap(True)
        origin_details_layout.addWidget(QLabel("<b>Skill Proficiencies:</b>"))
        origin_details_layout.addWidget(self.origin_skills_label)

        self.origin_traits_label = QLabel("-")
        self.origin_traits_label.setObjectName("OriginDetailsLabel")
        self.origin_traits_label.setWordWrap(True)
        self.origin_traits_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(QLabel("<b>Origin Traits:</b>"))
        origin_details_layout.addWidget(self.origin_traits_label)
        origin_details_layout.addStretch() # Push details up
        left_column_layout.addWidget(origin_details_group)


        # --- Description Group (Backstory) ---
        description_group = QGroupBox("Character Backstory (Optional Seed)")
        description_layout = QVBoxLayout(description_group)
        description_layout.setContentsMargins(15, 25, 15, 15)
        description_layout.setSpacing(5)

        description_label = QLabel("Optionally edit the text below (based on selected Origin) to guide the LLM background generation:")
        description_label.setWordWrap(True)
        description_label.setStyleSheet("color: #AAAAAA; font-style: italic;")

        self.description_edit = QTextEdit() # Player editable backstory seed
        self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
        self.description_edit.setMinimumHeight(100) # Ensure decent height

        description_layout.addWidget(description_label)
        description_layout.addWidget(self.description_edit)
        left_column_layout.addWidget(description_group)
        left_column_layout.addStretch(1) # Add stretch to push content up

        # --- Add Left Column Scroll Area ---
        left_scroll_area = QScrollArea()
        left_scroll_area.setWidgetResizable(True)
        left_scroll_area.setWidget(left_column_widget)


        # --- Right Column: Portrait ---
        right_column_widget = QWidget()
        right_column_layout = QVBoxLayout(right_column_widget)
        right_column_layout.setContentsMargins(0,0,0,0)
        right_column_layout.setSpacing(10)

        icon_group = QGroupBox("Character Portrait")
        icon_layout = QVBoxLayout(icon_group)
        icon_layout.setContentsMargins(15, 25, 15, 15)
        icon_layout.setSpacing(8)

        self.icon_label = QLabel()
        self.icon_label.setAlignment(Qt.AlignCenter)
        self.icon_label.setFixedSize(150, 150) # Fixed size for portrait
        self.icon_label.setStyleSheet("background-color: #1E1E1E; border: 1px solid #3F3F46;")
        self.icon_label.setText("No image")
        icon_layout.addWidget(self.icon_label, 0, Qt.AlignCenter) # Center the label

        nav_layout = QHBoxLayout()
        self.prev_icon_button = QPushButton("←")
        self.icon_counter_label = QLabel("0 / 0")
        self.icon_counter_label.setAlignment(Qt.AlignCenter)
        self.next_icon_button = QPushButton("→")
        nav_layout.addWidget(self.prev_icon_button)
        nav_layout.addWidget(self.icon_counter_label)
        nav_layout.addWidget(self.next_icon_button)
        icon_layout.addLayout(nav_layout)

        portrait_hint = QLabel("Browse available character portraits")
        portrait_hint.setStyleSheet("color: #888888; font-style: italic;")
        portrait_hint.setAlignment(Qt.AlignCenter)
        icon_layout.addWidget(portrait_hint)
        right_column_layout.addWidget(icon_group)
        right_column_layout.addStretch(1) # Push portrait group up


        # Add columns to main details layout
        details_layout.addWidget(left_scroll_area, 3)  # Left column takes more space
        details_layout.addWidget(right_column_widget, 1) # Right column for portrait

        main_layout.addLayout(details_layout, 1) # Make details layout stretch

        # --- Dialog Buttons ---
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        self.cancel_button = QPushButton("Cancel")
        self.create_button = QPushButton("Create Character")
        self.create_button.setEnabled(False)
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.create_button)
        main_layout.addLayout(button_layout)

    def _populate_combo(self, combo: QComboBox, items: List[str], item_type: str):
        """Helper to populate QComboBox and handle empty lists."""
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItems(items)
            combo.setEnabled(True)

    def _populate_origin_combo(self):
        """Populate the Origin combo box."""
        combo = self.origin_combo
        items = self.available_origins
        item_type = "Origins"

        combo.clear() # Clear previous items
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItem("--- Select an Origin ---", None) # Placeholder item
            for origin_data in items:
                # Add item with name as text and id as data
                combo.addItem(origin_data.get('name', 'Unknown Origin'), origin_data.get('id'))
            combo.setEnabled(True)

    @Slot(int)
    def _on_origin_selected(self, index: int):
        """Update details display when an origin is selected."""
        self.selected_origin_data = None # Reset selected data
        origin_id = self.origin_combo.itemData(index)

        if origin_id is None: # Handle placeholder selection
            self.origin_desc_label.setText("Select an Origin to see details.")
            self.origin_skills_label.setText("-")
            self.origin_traits_label.setText("-")
            self.description_edit.setPlainText("") # Clear backstory seed
            self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
            self._validate_form() # Re-validate as origin is deselected
            return

        # Find the full origin data using the ID
        origin = next((o for o in self.available_origins if o.get('id') == origin_id), None)

        if origin:
            self.selected_origin_data = origin # Store the full data
            self.origin_desc_label.setText(origin.get('description', 'No description available.'))

            # Format skills
            skills = origin.get('skill_proficiencies', [])
            self.origin_skills_label.setText(", ".join(skills) if skills else "None")

            # Format traits
            traits = origin.get('origin_traits', [])
            traits_text = ""
            if traits:
                trait_lines = [f"<b>{t.get('name', 'Unnamed Trait')}:</b> {t.get('description', 'No description.')}" for t in traits]
                traits_text = "<br>".join(trait_lines) # Use HTML for formatting
            else:
                traits_text = "None"
            self.origin_traits_label.setText(traits_text)

            # Pre-populate backstory seed if empty
            if not self.description_edit.toPlainText().strip():
                 self.description_edit.setPlainText(origin.get('introduction_text', ''))

        else:
            # Handle case where origin ID is found but data isn't (shouldn't happen)
            self.origin_desc_label.setText("Error: Could not load details.")
            self.origin_skills_label.setText("-")
            self.origin_traits_label.setText("-")
            self.description_edit.setPlainText("")
            logger.error(f"Could not find origin data for ID: {origin_id}")

        self._validate_form() # Re-validate after selection change


    def _toggle_llm(self, state):
        """Toggle LLM enabled state."""
        self.llm_enabled = bool(state)

    def _load_races(self) -> List[str]:
        """Load race names from the configuration."""
        races = [] # Start empty, rely on config
        try:
            config = get_config()
            loaded_races_data = config.get_all("races")
            if loaded_races_data:
                race_names = sorted([data.get('name', race_id) for race_id, data in loaded_races_data.items()])
                if race_names:
                    races = race_names
                    logger.info(f"Loaded {len(races)} races from config.")
                else:
                    logger.warning("No race names found in loaded race data.")
            else:
                logger.warning("Race configuration domain ('races') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading races from config: {e}.")
        return races if races else ["Human"] # Fallback if loading fails

    def _load_classes(self) -> List[str]:
        """Load class names from the configuration."""
        classes = [] # Start empty
        try:
            config = get_config()
            loaded_classes_data = config.get_all("classes")
            if loaded_classes_data:
                class_names = sorted([data.get('name', class_id) for class_id, data in loaded_classes_data.items()])
                if class_names:
                    classes = class_names
                    logger.info(f"Loaded {len(classes)} classes from config.")
                else:
                    logger.warning("No class names found in loaded class data.")
            else:
                logger.warning("Class configuration domain ('classes') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading classes from config: {e}.")
        return classes if classes else ["Wanderer"] # Fallback

    def _load_origins(self) -> List[Dict[str, Any]]:
        """Load origin data (id and name initially) from configuration."""
        origins_data = []
        try:
            config = get_config()
            # Assuming origins.json is loaded under the 'origins' key
            loaded_origins_dict = config.get_all("origins")
            if loaded_origins_dict and isinstance(loaded_origins_dict, dict):
                 # Store the full data for later lookup
                origins_data = list(loaded_origins_dict.values())
                # Sort by name for display
                origins_data.sort(key=lambda x: x.get('name', 'Unknown Origin'))
                logger.info(f"Loaded {len(origins_data)} origins from config.")
            else:
                logger.warning("Origin configuration domain ('origins') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading origins from config: {e}.")
        return origins_data

    def scan_character_icons(self, race: str, class_name: str, sex: str):
        """
        Scan for character icons in the specific race/class directory
        and filter based on sex.
        """
        self.character_icons = [] # Clear previous icons
        self.current_icon_index = 0

        if not race or not class_name or not sex or "No " in race or "No " in class_name: # Added check for placeholder text
            logger.warning(f"Cannot scan icons: Race ('{race}'), Class ('{class_name}'), or Sex ('{sex}') not validly selected.")
            self._display_current_icon() # Display "No Icons Found" or similar
            return

        try:
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            # Construct specific directory path (e.g., images/character_icons/Human_Warrior)
            safe_race = race.replace(" ", "_")
            safe_class_name = class_name.replace(" ", "_")
            specific_icons_dir = os.path.join(project_root, "images", "character_icons", f"{safe_race}_{safe_class_name}")
            logger.debug(f"Scanning for icons in specific directory: {specific_icons_dir}")

            if not os.path.exists(specific_icons_dir):
                logger.warning(f"Icon directory not found: {specific_icons_dir}")
                self._display_current_icon() # Display "No Icons Found"
                return

            supported_extensions = [".png", ".jpg", ".jpeg", ".gif", ".svg"]

            # Scan and filter files
            for filename in os.listdir(specific_icons_dir):
                if any(filename.lower().endswith(ext) for ext in supported_extensions):
                    name_part_lower = os.path.splitext(filename)[0].lower()
                    sex_lower = sex.lower()
                    include_file = False

                    contains_male_keyword = "male" in name_part_lower
                    contains_female_keyword = "female" in name_part_lower

                    if sex_lower == "male":
                        # Include if "male" is present AND "female" is NOT present
                        if contains_male_keyword and not contains_female_keyword:
                            include_file = True
                    elif sex_lower == "female":
                        # Include if "female" is present
                        if contains_female_keyword:
                            include_file = True
                    elif sex_lower == "other":
                        # Include if either "male" or "female" is present
                        if contains_male_keyword or contains_female_keyword:
                            include_file = True
                    
                    if include_file:
                        file_path = os.path.join(specific_icons_dir, filename)
                        self.character_icons.append({
                            "filename": filename,
                            "path": file_path
                        })

            # Sort the icons by filename
            self.character_icons.sort(key=lambda x: x["filename"])

            logger.info(f"Found {len(self.character_icons)} suitable icons in {specific_icons_dir} for sex '{sex}'.")

        except OSError as e:
            logger.error(f"Error reading icons directory {specific_icons_dir}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error scanning icons: {e}", exc_info=True)

        # Display the first found icon (or "No Icons Found")
        self._display_current_icon()
    def _connect_signals(self):
        """Connect signals to slots."""
        self.player_name_edit.textChanged.connect(self._validate_form)
        self.race_combo.currentIndexChanged.connect(self._validate_form)
        self.path_combo.currentIndexChanged.connect(self._validate_form)
        self.origin_combo.currentIndexChanged.connect(self._validate_form) # Validate on origin change too
        self.origin_combo.currentIndexChanged.connect(self._on_origin_selected) # Update details on change

        self.llm_checkbox.stateChanged.connect(self._toggle_llm)
        self.prev_icon_button.clicked.connect(self._show_previous_icon)
        self.next_icon_button.clicked.connect(self._show_next_icon)

        self.cancel_button.clicked.connect(self.reject)
        self.create_button.clicked.connect(self.accept)

    def _validate_form(self):
        """Validate the form and enable/disable the create button."""
        has_name = bool(self.player_name_edit.text().strip())
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0 # Check index too
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        # Check if a valid origin (not the placeholder) is selected
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0

        self.create_button.setEnabled(
            has_name and
            race_selected and
            class_selected and
            origin_selected
        )

    def _show_previous_icon(self):
        """Show the previous character icon."""
        # (Keep existing implementation)
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index - 1 + len(self.character_icons)) % len(self.character_icons)
        self._display_current_icon()


    def _show_next_icon(self):
        """Show the next character icon."""
        # (Keep existing implementation)
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index + 1) % len(self.character_icons)
        self._display_current_icon()

    def _display_current_icon(self):
        """Display the current character icon."""
        # (Keep existing implementation, ensure counter updates)
        if not self.character_icons:
            self.selected_icon_path = None
            self.icon_label.setText("No Icons Found")
            self.icon_counter_label.setText("0 / 0")
            return

        icon_info = self.character_icons[self.current_icon_index]
        icon_path = icon_info['path']
        self.icon_counter_label.setText(f"{self.current_icon_index + 1} / {len(self.character_icons)}")

        try:
            pixmap = QPixmap(icon_path)
            if not pixmap.isNull():
                pixmap = pixmap.scaled(self.icon_label.width(), self.icon_label.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.icon_label.setPixmap(pixmap)
                self.selected_icon_path = icon_path
            else:
                self.icon_label.setText("Load Error")
                self.selected_icon_path = None
        except Exception as e:
            logger.error(f"Error loading icon '{icon_path}': {e}")
            self.icon_label.setText("Load Error")
            self.selected_icon_path = None

    def get_character_data(self) -> Optional[Dict[str, Any]]:
        """Get the character data from the form, including origin_id."""
        name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText() if self.race_combo.isEnabled() else None
        path = self.path_combo.currentText() if self.path_combo.isEnabled() else None
        origin_id = self.origin_combo.currentData() if self.origin_combo.isEnabled() else None # Get origin ID from data

        # Basic validation
        if not name or not race or not path or origin_id is None: # Check origin_id too
             logger.error("Cannot get character data: Name, Race, Class, or Origin is missing or invalid.")
             QMessageBox.warning(self, "Missing Information", "Please select a valid Race, Class, and Origin.")
             return None

        data = {
            'name': name,
            'race': race,
            'path': path,
            'origin_id': origin_id, # Add origin ID
            'sex': self.sex_combo.currentText(),
            # Use edited description if provided, otherwise use the original intro text from selected origin
            'description': self.description_edit.toPlainText().strip() if self.description_edit.toPlainText().strip() else (self.selected_origin_data.get('introduction_text', '') if self.selected_origin_data else ''),
            'use_llm': self.llm_enabled,
            'character_image': self.selected_icon_path
        }

        return data
```

### File: gui\dialogs\save_game_dialog.py

```python
#!/usr/bin/env python3
"""
Save game dialog for the RPG game GUI.
This module provides a dialog for saving the game.
"""

import logging
import os
from typing import Optional, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QGroupBox, QListWidget, QListWidgetItem
)
from PySide6.QtCore import Qt, Signal, Slot

class SaveGameDialog(QDialog):
    """Dialog for saving the game."""
    
    def __init__(self, parent=None):
        """Initialize the save game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Save Game")
        self.setMinimumWidth(400)
        self.setMinimumHeight(300)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QLineEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create save name input section
        name_layout = QVBoxLayout()
        
        # Create save name label
        name_label = QLabel("Save Name:")
        
        # Create save name edit
        self.save_name_edit = QLineEdit()
        self.save_name_edit.setPlaceholderText("Enter a name for this save...")
        
        # Add widgets to name layout
        name_layout.addWidget(name_label)
        name_layout.addWidget(self.save_name_edit)
        
        # Add name layout to main layout
        main_layout.addLayout(name_layout)
        
        # Create existing saves group
        existing_group = QGroupBox("Existing Saves")
        existing_layout = QVBoxLayout(existing_group)
        existing_layout.setContentsMargins(10, 20, 10, 10)
        
        # Create existing saves list
        self.saves_list = QListWidget()
        self.saves_list.setAlternatingRowColors(True)
        
        # Add saves list to existing layout
        existing_layout.addWidget(self.saves_list)
        
        # Add existing group to main layout
        main_layout.addWidget(existing_group)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create save button
        self.save_button = QPushButton("Save Game")
        self.save_button.setEnabled(False)  # Disable until name is entered
        self.save_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.save_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load existing saves
        self._load_existing_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Enable/disable save button based on name field
        self.save_name_edit.textChanged.connect(self._validate_form)
        
        # Update name field when an existing save is selected
        self.saves_list.itemClicked.connect(self._on_save_selected)
    
    def _validate_form(self):
        """Validate the form and enable/disable the save button."""
        # Check if name is not empty
        has_name = bool(self.save_name_edit.text().strip())
        
        # Enable/disable save button
        self.save_button.setEnabled(has_name)
    
    def _load_existing_saves(self):
        """Load existing saves into the list."""
        # Clear the list
        self.saves_list.clear()
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to list
        for save_file in save_files:
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Create and add the item
            item = QListWidgetItem(save_name)
            self.saves_list.addItem(item)
    
    def _on_save_selected(self, item):
        """Handle save selection."""
        # Set the save name edit to the selected save
        self.save_name_edit.setText(item.text())

```

### File: world_configurator\llm\client_base.py

```python
"""
Client base and OpenAI-like implementation using requests.
Note: This is a minimal synchronous client; UI should run it in a worker thread.
"""
from __future__ import annotations

import json
from typing import List, Dict, Any, Optional

import requests

from .settings import LLMSettings


class LLMClient:
    def send(self, messages: List[Dict[str, str]], settings: LLMSettings) -> Dict[str, Any]:  # pragma: no cover
        raise NotImplementedError


class OpenAILikeClient(LLMClient):
    def _endpoint(self, base: Optional[str]) -> str:
        base = base or "https://api.openai.com/v1"
        if base.endswith("/"):
            base = base[:-1]
        return f"{base}/chat/completions"

    def _headers(self, settings: LLMSettings) -> Dict[str, str]:
        # Some OpenRouter routes require a different auth header
        prov = (settings.provider or '').lower()
        if 'openrouter' in prov:
            return {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {settings.api_key}",
                "X-Title": "World Configurator Assistant",
            }
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {settings.api_key}",
        }

    def send(self, messages: List[Dict[str, str]], settings: LLMSettings) -> Dict[str, Any]:
        payload = {
            "model": settings.model,
            "messages": messages,
            "temperature": 0.3,
        }
        url = self._endpoint(settings.api_base)
        headers = self._headers(settings)
        try:
            resp = requests.post(url, headers=headers, data=json.dumps(payload), timeout=60)
            resp.raise_for_status()
        except requests.HTTPError as e:
            body = None
            try:
                body = e.response.text
            except Exception:
                pass
            raise Exception(f"Upstream error {e.response.status_code} from {url}: {body}")
        data = resp.json()
        # Expect OpenAI-like structure
        content = data.get("choices", [{}])[0].get("message", {}).get("content", "")
        try:
            return json.loads(content)
        except Exception:
            return {"raw": content or data}


```

### File: config\world\scenarios\origins.json

```json
{
  "origins": {
    "harmonia_initiate": {
      "id": "harmonia_initiate",
      "name": "Harmonia Initiate",
      "description": "You've recently completed your Attunement ceremony and are now officially a citizen of Harmonia. As a new initiate into adult society, you're eager to prove yourself and find your place within the Concordant Cities.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "simple_clothing",
        "harmonian_tattoo_kit",
        "resonance_amulet",
        "bread",
        "water_flask"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Halfling"
      ],
      "suitable_classes": [
        "Wanderer",
        "Mage",
        "Rogue",
        "Cleric"
      ],
      "introduction_text": "The vibrant city of Harmonia stretches before you, its seven concentric rings shifting subtly as distant Resonance energies flow through the metropolis. You touch the still-tender Attunement tattoos on your forearms, their ink seeming to shimmer as you pass through a pocket of concentrated planar energy. After years of preparation, you've finally been recognized as a full citizen, ready to contribute to the great Concordant society.\n\nThe Attunement Master has granted you your first day of freedom to explore opportunities throughout the city. Your future is unwritten – perhaps you'll join the Harmonic Order to study Resonance phenomena, sign up with local merchants as a guard or guide, or even apply for a coveted position with the ambassadorial corps. Whatever path you choose, one thing is certain: life in Harmonia is never predictable, especially with recent reports of increased Resonance Event frequency.\n\nYou adjust your new resonance amulet, a gift from your family to commemorate your initiation, and step forward into your new life.",
      "skill_proficiencies": [
        "Diplomacy",
        "Planar Lore (Basic)",
        "Streetwise (Harmonia)"
      ],
      "origin_traits": [
        {
          "name": "Attuned Citizen",
          "description": "Your Attunement tattoos offer minor resistance (+1 save) to psychological effects during moderate Resonance Events."
        },
        {
          "name": "Concordant Native",
          "description": "You are familiar with the basic customs and layout of Harmonia."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "embassy_assignment": {
      "id": "embassy_assignment",
      "name": "The Embassy Assignment",
      "description": "You've been assigned to the Verdant Embassy as part of a cultural exchange program. Your mission is to learn about the Verdant Collective while representing your own people or interests.",
      "starting_location_id": "verdant_embassy",
      "starting_items": [
        "diplomatic_papers",
        "formal_attire",
        "journal",
        "small_pouch_of_seeds",
        "water_flask"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Halfling",
        "Dwarf"
      ],
      "suitable_classes": [
        "Wanderer",
        "Cleric",
        "Ranger",
        "Mage"
      ],
      "introduction_text": "The living walls of the Verdant Embassy pulse with quiet energy around you as you settle into your new quarters. Branches intertwine above to form your ceiling, occasionally shifting to allow beams of sunlight to filter through the leafy canopy. It's been less than a day since you arrived at this outpost, a representative selected to participate in the cultural exchange program between your people and the enigmatic Verdant Collective.\n\nYour diplomatic papers were accepted readily enough by the Green Speakers stationed here, though you noticed they communicated among themselves using their mysterious plant-based language – subtle movements of leaves and the release of spores that somehow convey complex thoughts. You've been told that part of your role will be to learn their customs and potentially even the basics of their communication methods.\n\nAs you unpack your belongings, a small seedpod drops from the ceiling onto your desk, splitting open to reveal a message written on a thin leaf inside. It appears to be an invitation to meet with the Verdant Ambassador at your earliest convenience. Your time at the Embassy has officially begun.",
      "skill_proficiencies": [
        "Diplomacy",
        "Nature",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Cultural Envoy",
          "description": "You have official standing within the Verdant Embassy, granting easier access to certain areas and individuals."
        },
        {
          "name": "Observant Outsider",
          "description": "Your unfamiliarity allows you to notice details Verdant natives might overlook."
        }
      ],
      "starting_culture_id": "verdant"
    },
    "crystal_study_apprentice": {
      "id": "crystal_study_apprentice",
      "name": "Crystal Study Apprentice",
      "description": "You've been accepted as an apprentice in the Crystalline Enclave, a prestigious position. You'll study the mathematical principles of Facet Magic under the tutelage of Consortium representatives.",
      "starting_location_id": "crystalline_enclave",
      "starting_items": [
        "apprentice_robes",
        "calculation_crystals",
        "precision_tools",
        "faceted_focusing_lens",
        "notebook"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Prismal",
        "Dwarf"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The precise angles of the Crystalline Enclave's architecture catch the morning light, sending mathematically perfect rainbows across the polished surfaces of the Calculation Chamber. It's your first day as an official apprentice to the Crystalline Consortium, a position few outsiders ever achieve. Your acceptance came after months of rigorous testing of your logical reasoning and mathematical aptitude.\n\nYour new quarters are spartan but functional – every surface and object positioned according to precise geometric principles that the Consortium claims enhance cognitive function. On your desk sits a set of calculation crystals and precision tools, along with a faceted focusing lens that you're expected to learn to attune to your specific thought patterns.\n\nThe schedule delivered to you this morning is exacting: your first lesson in the fundamental principles of Facet Magic begins in exactly forty-three minutes, followed by two hours of observational study in the Precision Market, then meditation on crystalline harmonic progressions. There will be little room for error or inefficiency – exactly as your Consortium mentors prefer it.",
      "skill_proficiencies": [
        "Arcana",
        "Investigation",
        "Mathematics (Basic)"
      ],
      "origin_traits": [
        {
          "name": "Consortium Apprentice",
          "description": "You have access to basic Crystalline Consortium facilities and learning resources."
        },
        {
          "name": "Logical Mind",
          "description": "You gain a minor bonus (+1 save) against effects that cause confusion or illogical thinking."
        }
      ],
      "starting_culture_id": "crystalline"
    },
    "echo_woods_explorer": {
      "id": "echo_woods_explorer",
      "name": "Echo Woods Explorer",
      "description": "You've been drawn to the mysterious Echo Woods, either to study its planar phenomena, collect valuable resources, or perhaps because you're following the whispers of a specific echo that holds personal significance.",
      "starting_location_id": "echo_woods",
      "starting_items": [
        "explorer_clothing",
        "survival_kit",
        "small_tent",
        "recording_crystal",
        "hunting_knife"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Halfling",
        "Mycora"
      ],
      "suitable_classes": [
        "Ranger",
        "Wanderer",
        "Rogue",
        "Mage"
      ],
      "introduction_text": "Mist curls between the ancient trees of the Echo Woods as you make your way deeper into this strange forest. The boundary between the Nexus and Verdant planes feels particularly thin here – occasionally you glimpse plants that couldn't possibly exist in either realm alone, hybrid creations thriving in the planar overlap. More unsettling are the whispers that seem to follow you: fragments of conversations held long ago, preserved somehow in the very fabric of this place.\n\nYou've come prepared for an extended stay, carrying essential survival gear and a recording crystal to document your findings. Whether you're here as a researcher, a resource gatherer, or because you're following a particular echo that caught your attention during a previous visit, the woods offer endless mysteries to unravel.\n\nAs you set up your small camp near what appears to be a suitable clearing, you notice that the whispers have grown more distinct. Some seem to be repeating your own movements, describing the very actions you're taking as you secure your tent. Others speak of events from centuries past – or perhaps yet to come. The Echo Woods reveal their secrets only to the patient and observant, and you intend to be both.",
      "skill_proficiencies": [
        "Survival",
        "Nature",
        "Perception"
      ],
      "origin_traits": [
        {
          "name": "Echo Sensitive",
          "description": "You are more susceptible to hearing the whispers of the Echo Woods, potentially gaining insights or facing distractions."
        },
        {
          "name": "Wilderness Acclimated",
          "description": "You have advantage on saving throws against natural environmental hazards within forests."
        }
      ]
    },
    "ashen_covenant_recruit": {
      "id": "ashen_covenant_recruit",
      "name": "Ashen Covenant Recruit",
      "description": "You've recently joined the nomadic Ashen Covenant, embracing their philosophy of impermanence. You seek to learn their unique spiritual practices, including the mysterious art of Ash Walking.",
      "starting_location_id": "ashen_camp",
      "starting_items": [
        "ash-treated_clothing",
        "covenant_pendant",
        "fire_striker",
        "ritual_dagger",
        "small_pouch_of_ancestral_ash",
        "test_apple"
      ],
      "initial_quests": [
        "551cdb35-a4bb-4b23-b6c1-4d2772947efb",
        "TEST_Q01",
        "TEST_Q02",
        "TEST_Q03",
        "TEST_Q04",
        "TEST_Q05",
        "TEST_Q06",
        "TEST_Q07",
        "TEST_Q08",
        "TEST_Q09",
        "TEST_Q10",
        "TEST_Q11",
        "TEST_Q12",
        "TEST_Q13",
        "TEST_Q14",
        "TEST_Q15",
        "TEST_Q16",
        "TEST_Q17",
        "TEST_Q18",
        "TEST_Q19",
        "TEST_Q20",
        "TEST_Q21",
        "TEST_Q22",
        "TEST_Q23",
        "TEST_Q24",
        "TEST_Q25"
      ],
      "suitable_races": [
        "Cinderspawn",
        "Human",
        "Orc"
      ],
      "suitable_classes": [
        "Cleric",
        "Mage",
        "Wanderer",
        "Warrior"
      ],
      "introduction_text": "The Eternal Flame at the center of the Ashen Camp dances hypnotically, casting long shadows from the temporary structures that surround it. You've arrived just days ago, but already the Covenant has accepted you as one of their own – an unusually quick integration into their normally closed society. Perhaps they saw something in you that suggested an affinity for their ways, or perhaps the ancestors spoke your name during a ritual.\n\nYour tent, like all others in the camp, is designed for quick assembly and disassembly. The nomadic Ashen Covenant never stays in one place long, following ancient migration patterns known only to their elders. All possessions are considered temporary – including the ritual dagger you were gifted this morning, which you're expected to surrender during the next Possession Exchange ceremony.\n\nAn elder approaches you now, their skin bearing the distinctive gray markings that indicate frequent Ash Walking – the mysterious practice of projecting consciousness through the ashes of the dead to commune with ancestors or travel spiritually to the Ashen plane. They've promised to begin your initial training today, starting with the fundamental philosophy that nothing – not possessions, not places, not even lives – is permanent. All returns to ash eventually, and in understanding this, the Covenant finds freedom.",
      "skill_proficiencies": [
        "History (Oral)",
        "Religion",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Covenant Initiate",
          "description": "You are recognized by the Ashen Covenant and can participate in basic community rituals like the Possession Exchange."
        },
        {
          "name": "Embracing Impermanence",
          "description": "You have a minor bonus (+1 save) against effects causing fear of loss or attachment."
        }
      ],
      "starting_culture_id": "ashen"
    },
    "tempest_harbor_arrival": {
      "id": "tempest_harbor_arrival",
      "name": "Tempest Harbor Arrival",
      "description": "You've arrived at Tempest Harbor during a rare celestial alignment, either as a trader, an adventurer seeking opportunity, or perhaps as someone who has unfinished business with the enigmatic Tempest Flotilla.",
      "starting_location_id": "tempest_harbor",
      "starting_items": [
        "weather-resistant_clothing",
        "small_trading_goods",
        "probability_dice",
        "storm_compass",
        "sealed_message"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Maelstri",
        "Elf",
        "Dwarf"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer",
        "Mage",
        "Warrior"
      ],
      "introduction_text": "The chaotic energy of Tempest Harbor surrounds you as you make your way along the swaying walkways. The entire harbor appeared less than two days ago when the celestial alignment permitted the Tempest Flotilla to dock at the Nexus plane, and it will vanish just as quickly once the alignment ends. All around you, traders from across the planes haggle furiously, well aware that time is limited.\n\nThe air crackles with small surges of storm energy, captured and contained by the Flotilla's distinctive vessels. Probability merchants call out their wares – dice that may influence chance itself, pendants that predict local weather patterns, contracts with favorable statistical outcomes. The Flux Market ahead changes leadership hourly, causing prices and available goods to fluctuate in patterns only the most seasoned traders can predict.\n\nYou clutch the storm compass in your pocket – a gift, or perhaps a burden, that led you here at this precise moment. The sealed message you carry remains unopened, its recipient somewhere among the hundreds of temporary visitors and Flotilla members. Whether you've come to trade, to find someone, or to start anew where your past cannot follow, the Tempest Harbor offers possibilities as changeable as the storms the Flotilla navigates.",
      "skill_proficiencies": [
        "Acrobatics",
        "Deception",
        "Insight (Risk Assessment)"
      ],
      "origin_traits": [
        {
          "name": "Harbor Savvy",
          "description": "You understand the basic flow and dangers of the temporary Tempest Harbor."
        },
        {
          "name": "Embracer of Chaos",
          "description": "You react slightly faster (+1 Initiative) in unpredictable or rapidly changing situations."
        }
      ],
      "starting_culture_id": "tempest"
    },
    "library_assistant": {
      "id": "library_assistant",
      "name": "The Library's New Assistant",
      "description": "You've been granted the rare privilege of assisting at the Shifting Library. Knowledge from across all planes is collected and preserved by the enigmatic Lexicants.",
      "starting_location_id": "shifting_library",
      "starting_items": [
        "assistant_robes",
        "library_authorization",
        "cataloging_tools",
        "enchanted_quill",
        "blank_journal"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Prismal",
        "Dwarf"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The impossible architecture of the Shifting Library stretches around you, corridors extending far beyond what the exterior of the building should allow. You've been here for just under a week, still adjusting to the disorienting sensation of walking through sections of the library that exist simultaneously in different planes. The modest stone exterior belies the near-infinite collection contained within.\n\nYour quarters are small but comfortable, positioned near the Reading Nexus where researchers from across the planes come to study rare texts. Your position as an assistant came unexpectedly – some say the Library itself chooses its caretakers, somehow recognizing those with the necessary qualities long before they themselves are aware of their destiny.\n\nThe Head Lexicant assigned you simple cataloging duties to start, but hinted that you would soon begin training to access the deeper archives, where knowledge from before The Shattering is preserved in fragmentary form. Your enchanted quill allows you to take notes that will remain readable regardless of which plane currently dominates the section you're working in – a necessary tool for any Library employee.\n\nAs you prepare for your morning duties, you notice your blank journal glowing faintly. Opening it reveals a message in flowing script: 'Report to the Lexicant Hall. Your real work begins today.'",
      "skill_proficiencies": [
        "Investigation",
        "History",
        "Arcana (Basic)"
      ],
      "origin_traits": [
        {
          "name": "Library Access",
          "description": "You possess basic authorization to navigate the common areas of the Shifting Library."
        },
        {
          "name": "Planar Acclimation (Minor)",
          "description": "You have minor resistance (+1 save) against disorientation caused by shifting planar environments within the Library."
        }
      ]
    },
    "planar_researcher": {
      "id": "planar_researcher",
      "name": "Planar Bleed Researcher",
      "description": "You've volunteered for a research expedition to The Convergence, a dangerous Planar Bleed Zone. Multiple planes have permanently merged, creating unique phenomena worth studying despite the risks.",
      "starting_location_id": "planar_bleed_zone",
      "starting_items": [
        "researcher_equipment",
        "planar_protection_suit",
        "specimen_containers",
        "reality_anchor",
        "emergency_beacon"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Prismal",
        "Elf",
        "Mycora"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer",
        "Ranger"
      ],
      "introduction_text": "The laws of reality bend and fracture around you as you record observations at your designated research post in The Convergence. Here, at least three planes have merged permanently, creating impossible landscapes where forests of crystalline trees grow alongside pools of ash that somehow support aquatic life. The hybrid flora and fauna that have evolved in this zone exist nowhere else in any plane – making them invaluable subjects for study despite the considerable dangers.\n\nYour planar protection suit hums softly as it generates a field of stable reality around you, preventing the worst effects of planar exposure. Without it, prolonged presence here would lead to physical and mental alterations – some fascinating, most deadly. Even with protection, you must regularly calibrate your reality anchor to prevent being drawn into pocket dimensions that spontaneously form and collapse.\n\nYou volunteered for this three-month research rotation knowing the risks, driven by scientific curiosity or perhaps by the substantial hazard pay offered by the Harmonic Order. Your small team occupies the fortified Harvester Camp nearby, venturing out daily to collect data and specimens before retreating to relative safety each night.\n\nAs you finish documenting a particularly interesting reality fault, your instruments begin detecting unusual energy patterns. Something is happening in the Bleed Zone – something not recorded in any of your briefing materials.",
      "skill_proficiencies": [
        "Investigation",
        "Survival",
        "Planar Lore"
      ],
      "origin_traits": [
        {
          "name": "Field Researcher",
          "description": "You are trained in basic planar sample collection and data recording techniques."
        },
        {
          "name": "Reality Anchor Familiarity",
          "description": "You know how to operate and perform basic maintenance on personal reality anchors."
        }
      ]
    },
    "ghost_market_escapee": {
      "id": "ghost_market_escapee",
      "name": "Ghost Market Escapee",
      "description": "You recently found yourself trapped in the mysterious Ghost Market during a Resonance Event. After making a questionable deal with one of The Between to secure your freedom, you now navigate the consequences of that bargain.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "strange_contract",
        "between_token",
        "partially_empty_memory_vial",
        "planar_map",
        "market_trinket"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Elf",
        "Dwarf",
        "Orc"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer",
        "Mage",
        "Warrior"
      ],
      "introduction_text": "The streets of Harmonia offer welcome stability after your harrowing experience in the Ghost Market. Three days have passed since you escaped that ethereal bazaar, though 'escaped' might not be the right word when you consider the contract currently burning a hole in your pocket. The Between – those enigmatic entities who run the market – rarely let anyone leave without some form of payment or promise.\n\nYou still don't fully remember how you came to be trapped there when the Resonance Event struck. One moment you were going about your business, the next you were surrounded by ethereal tents and the haunting bell music that announces the Ghost Market's appearance. What you do remember clearly is the panic that set in when you realized the market was beginning to dematerialize, preparing to shift to another location, with you still inside it.\n\nThe strange contract you signed with one of The Between secured your release back to the Nexus plane, but the cost remains ambiguous – something about 'services to be rendered at a time of the signatory's choosing.' The Between Token you were given supposedly allows them to contact you when they decide to collect on your debt.\n\nMost disturbing is the partially empty memory vial hanging around your neck. You're certain it contains some of your own memories, extracted as a 'deposit' on your contract. You don't know what you've forgotten, but the sense of loss haunts you.",
      "skill_proficiencies": [
        "Deception",
        "Stealth",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Between's Bargain",
          "description": "You carry a binding contract with an entity from the Ghost Market, which may have unforeseen consequences."
        },
        {
          "name": "Fragmented Memory",
          "description": "You have gaps in your recent memory due to your Ghost Market encounter."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "nobles_fall": {
      "id": "nobles_fall",
      "name": "Noble's Fall from Grace",
      "description": "Once a privileged noble in Harmonia, you've recently fallen from grace due to a political misstep, family scandal, or being on the wrong side of a Resonance Event prediction. Now you must rebuild your life with few resources but valuable connections and knowledge.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "fine_clothes_(worn)",
        "family_signet_ring",
        "small_purse_of_coins",
        "sealed_letter_of_introduction",
        "ornate_dagger"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf"
      ],
      "suitable_classes": [
        "Wanderer",
        "Rogue",
        "Warrior",
        "Mage"
      ],
      "introduction_text": "The lower rings of Harmonia look different from this perspective – as a resident rather than a visitor. Your family's estate in the third ring, with its clear view of the Harmonic Spire, now seems impossibly distant. Your current lodgings, a modest room above a resonance equipment repair shop, serve as a stark reminder of how quickly fortunes can change in the Concordant Cities.\n\nIt's been just two weeks since the Council's decree stripped your family of position and most of your wealth. Perhaps it was your father's opposition to the new Resonance monitoring protocols, your sister's ill-advised romance with a Tempest diplomat, or simply being caught on the wrong side of a factional realignment. Whatever the cause, the result is the same – you now find yourself starting over with little more than your education, your connections, and whatever personal possessions you could discreetly secure before the seizures began.\n\nThe signet ring you wear now feels heavy – a reminder of your heritage that might open doors or close them, depending on who you encounter. The sealed letter of introduction from a family ally might offer a path forward, though you haven't yet decided whether to use it. Pride suggests making your own way; pragmatism argues for using every advantage available.\n\nAs you look out over the unfamiliar neighborhood, you consider your options. Your knowledge of high society and planar politics remains valuable. The question is how to leverage it without becoming entangled in the same web that ensnared your family.",
      "skill_proficiencies": [
        "Persuasion",
        "History",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Fallen Noble",
          "description": "You retain knowledge of noble etiquette and politics, but lack the resources and official standing you once had."
        },
        {
          "name": "Lingering Connections",
          "description": "Some individuals may still recognize your family name, for better or worse."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "commoners_call": {
      "id": "commoners_call",
      "name": "Commoner's Call to Adventure",
      "description": "After years of ordinary life in Harmonia's lower rings, a chance encounter with a mysterious traveler has given you a glimpse of the wider world across the planes, along with an offer you can't refuse.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "sturdy_work_clothes",
        "family_heirloom",
        "simple_tool",
        "lunch_bundle",
        "old_map"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Dwarf",
        "Orc"
      ],
      "suitable_classes": [
        "Warrior",
        "Rogue",
        "Ranger",
        "Wanderer"
      ],
      "introduction_text": "The familiar streets of your neighborhood in Harmonia's sixth ring buzz with the usual morning activity – merchants setting up stalls, children running errands, workers heading to their duties in the inner rings. For two decades, this has been your entire world, your days filled with honest work and simple pleasures, never venturing beyond the boundaries set by circumstance and station.\n\nBut everything changed three nights ago when a traveler with strange, swirling tattoos and eyes that seemed to reflect multiple planes took shelter in your family's modest home during an unexpected Resonance tremor. The stories they shared of crystalline cities, floating harbors, and libraries that exist in all planes simultaneously awakened something within you that had lain dormant for too long.\n\nBefore leaving at dawn, they pressed an old map into your hands, marked with locations you'd never heard of, and whispered that you were 'meant for more than this life.' Whether driven by restlessness, curiosity, or the strange certainty in the traveler's voice, you've made your decision. Today, you leave the familiarity of your neighborhood behind, your few possessions packed and your family's blessing reluctantly given.\n\nThe weight of your family heirloom in your pocket reminds you of where you came from, while the map in your hand points to where you might be going. What awaits beyond the boundaries of everything you've ever known? It's time to find out.",
      "skill_proficiencies": [
        "Athletics",
        "Endurance",
        "Crafting (Basic)"
      ],
      "origin_traits": [
        {
          "name": "Common Sense",
          "description": "You possess practical knowledge and resilience gained from ordinary life."
        },
        {
          "name": "Mysterious Map",
          "description": "You carry an old map marked with unknown locations, hinting at a potential destiny."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "scholarly_expedition": {
      "id": "scholarly_expedition",
      "name": "Scholarly Expedition",
      "description": "As a historian or researcher from the prestigious Resonance Academy in Harmonia, you've been sent on an expedition to document and study a recently discovered site of pre-Shattering significance.",
      "starting_location_id": "echo_woods",
      "starting_items": [
        "academic_robes",
        "research_notes",
        "precision_measuring_tools",
        "portable_writing_desk",
        "resonance_detector"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Prismal",
        "Dwarf"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The mist-shrouded trees of the Echo Woods loom around you as you consult your notes once more. According to the fragmentary references discovered in the Academy archives, somewhere in this region lies a structure that predates The Shattering – a find of potentially immeasurable historical importance. As a scholar who has dedicated years to studying the sparse records of that lost era, the opportunity to document such a site firsthand could define your entire academic career.\n\nYour small expedition team has already set up a base camp half a day's journey behind you. As the team's lead historian, you've pressed ahead with just the essentials, eager to make the initial assessment before bringing in the other specialists. The portable resonance detector at your belt occasionally pulses with a soft blue light, confirming you're moving in the right direction.\n\nThe Academy's funding for this expedition was hard-won, with many senior faculty dismissing the ancient texts you uncovered as mere fantasy or allegory. Proving them wrong would be satisfying, but your true motivation runs deeper – to understand the world that existed before The Shattering, to piece together how one reality became five distinct planes, might help humanity comprehend its own fragmented existence.\n\nAs you push aside a curtain of hanging vines, your resonance detector suddenly flares with brilliant light. There, partially reclaimed by the forest but unmistakably artificial, stands a structure unlike any you've seen in modern architectural records. Your heart races as you approach, research notes at the ready. This is what you came for – the past, waiting to be rediscovered.",
      "skill_proficiencies": [
        "History",
        "Investigation",
        "Planar Lore"
      ],
      "origin_traits": [
        {
          "name": "Academic Authority",
          "description": "You possess credentials from the Resonance Academy, which may grant access to certain sites or information."
        },
        {
          "name": "Analytical Mind",
          "description": "You gain advantage on checks made to analyze historical artifacts or decipher ancient texts."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "soldiers_mission": {
      "id": "soldiers_mission",
      "name": "Soldier's New Mission",
      "description": "After years of service in the Harmonic Guard, you've been selected for a special assignment. Investigate reports of unusual planar activity that may pose a threat to the stability of the Concordant Cities.",
      "starting_location_id": "planar_bleed_zone",
      "starting_items": [
        "guard_uniform",
        "standard_issue_weapon",
        "planar_protection_amulet",
        "rations_pack",
        "sealed_orders"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Dwarf",
        "Orc"
      ],
      "suitable_classes": [
        "Warrior",
        "Ranger",
        "Cleric"
      ],
      "introduction_text": "The ever-shifting landscape of The Convergence stretches before you, a vivid reminder of why the Harmonic Guard maintains constant vigilance against planar threats. For eight years, you've served with distinction, patrolling the orderly streets of Harmonia and occasionally venturing to outlying settlements to maintain security and order. But this assignment is different – more dangerous, more secretive, and potentially more significant than anything in your service record.\n\nTwo weeks ago, monitoring stations detected unusual ripples in the planar boundaries – not the typical fluctuations that precede Resonance Events, but something more deliberate, almost structured. Your commander's briefing was uncharacteristically grave as he handed you sealed orders and the special protection amulet now hanging around your neck. 'We need someone who can think independently,' he said, 'someone who understands what's at stake.'\n\nYour small squad consists of just three other hand-picked guards, each with specialized skills. You've been granted unusual autonomy for this mission – no regular check-ins, no standard protocols, just a directive to investigate and report on whatever is causing these anomalies, and if necessary, neutralize any threat they might pose.\n\nAs you adjust your uniform, designed to blend in rather than stand out in this chaotic environment, you feel the weight of responsibility. The safety of Harmonia may depend on what you discover here in this unstable region where reality itself cannot be trusted. It's time to break the seal on those orders and begin your mission properly.",
      "skill_proficiencies": [
        "Athletics",
        "Perception",
        "Intimidation"
      ],
      "origin_traits": [
        {
          "name": "Harmonic Guard Veteran",
          "description": "You possess military discipline and are recognized by Concordant City officials."
        },
        {
          "name": "Planar Hazard Training",
          "description": "You have basic training in identifying and mitigating common planar dangers."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "outlaw_on_run": {
      "id": "outlaw_on_run",
      "name": "Outlaw on the Run",
      "description": "You're a fugitive from Harmonian justice, whether rightfully accused or wrongfully framed. You've fled to the edges of controlled territory, seeking to either clear your name or disappear into the chaotic regions beyond the Concordant Cities' influence.",
      "starting_location_id": "echo_woods",
      "starting_items": [
        "worn_disguise",
        "stolen_supplies",
        "forged_documents",
        "concealed_weapon",
        "wanted_poster"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Elf",
        "Orc"
      ],
      "suitable_classes": [
        "Rogue",
        "Ranger",
        "Warrior",
        "Wanderer"
      ],
      "introduction_text": "The dense foliage of the Echo Woods provides welcome cover as you pause to catch your breath. It's been three days since you slipped past the outer checkpoints of Harmonia, evading the guards who would happily collect the bounty now on your head. The wanted poster you took from the last outpost confirms your fears – your description has been circulated widely, though thankfully without an accurate likeness.\n\nYour crime – whether it was truly yours or one you were framed for – has made returning to any life you knew impossible. The stolen supplies in your pack might last another week if you're careful, but after that, you'll need to find a way to survive on the fringes of civilization. The forged documents might get you into one of the trading outposts where questions are fewer and coin speaks louder than official seals.\n\nOccasionally, the strange whispers of the Echo Woods seem to mock your situation, replaying fragments of the events that led to your downfall. Your fingers instinctively check the concealed weapon at your side – out here, justice and law are distant concepts, but danger is ever-present.\n\nAhead lies uncertainty, but behind lies certain capture. The whispers around you suddenly shift, no longer echoing the past but seemingly offering hints of possible futures. One path leads deeper into the unknown territories beyond the Concordant Cities' control. Another suggests a route to evidence that might clear your name. The choice, like the burden of your fugitive status, is yours alone to bear.",
      "skill_proficiencies": [
        "Stealth",
        "Deception",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Fugitive",
          "description": "You are wanted by Harmonian authorities and must avoid identification in controlled territories."
        },
        {
          "name": "Resourceful Survivor",
          "description": "You gain advantage on checks made to find basic food, water, or shelter in the wilderness."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "elven_emissary": {
      "id": "elven_emissary",
      "name": "Elven Emissary",
      "description": "As an Elf with exceptional magical sensitivity, you've been sent from your secluded community. Investigate the increasing frequency of Resonance Events and determine whether they pose a threat to your people.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "elven_crafted_robes",
        "ancestral_focus_crystal",
        "diplomatic_insignia",
        "resonance_journal",
        "preserved_provisions"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Elf"
      ],
      "suitable_classes": [
        "Mage",
        "Ranger",
        "Wanderer",
        "Cleric"
      ],
      "introduction_text": "The overwhelming sensory cacophony of Harmonia assaults your elven senses as you stand at the edge of the Seven-Ring Market. After decades of seclusion in your community's hidden enclave, the noise, smells, and most of all, the chaotic resonance patterns of this planar hub are almost too much to bear. You instinctively touch the ancestral focus crystal hanging at your neck, allowing its familiar energy to center you.\n\nFor centuries, your people have maintained their distance from the Concordant Cities, preferring to nurture their innate connection to magic in isolation. But the recent surge in Resonance Events has become impossible to ignore. Disturbances have reached even your secluded forests, disrupting ancient wards and causing unpredictable magical phenomena. When the Elders' Council needed an emissary, your exceptional sensitivity to planar energies made you the natural choice.\n\nYour mission is clear: gather information on these Resonance shifts, establish diplomatic relations where necessary, and determine whether this growing instability threatens elven lands. The diplomatic insignia hidden within your robes should grant you access to various authorities, though elves are still met with curious looks in these cities.\n\nAs you take your first steps into the crowded market, you feel the swirling currents of multiple planes intersecting around you. Your elven senses perceive what others cannot—a growing disharmony in the very fabric of reality. Something is unbalancing the planes, and your people need to know what, why, and how to protect themselves from whatever comes next.",
      "skill_proficiencies": [
        "Arcana",
        "Perception",
        "Planar Lore"
      ],
      "origin_traits": [
        {
          "name": "Elven Sensitivity",
          "description": "You have advantage on checks to perceive subtle magical or planar phenomena."
        },
        {
          "name": "Emissary Status",
          "description": "You carry diplomatic credentials representing your secluded elven community."
        }
      ]
    },
    "dwarven_craftmaster": {
      "id": "dwarven_craftmaster",
      "name": "Dwarven Craftmaster",
      "description": "As a master of traditional dwarven crafting techniques, you've traveled to the Crystalline Enclave. Study their precision technology and possibly establish a trade agreement that would benefit your distant mountain hold.",
      "starting_location_id": "crystalline_enclave",
      "starting_items": [
        "dwarven_forge_hammer",
        "master_crafting_tools",
        "clan_trade_contract",
        "metal_samples",
        "ceremonial_flask"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Dwarf"
      ],
      "suitable_classes": [
        "Warrior",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The geometrically perfect architecture of the Crystalline Enclave surrounds you, its mathematical precision both impressive and somehow lifeless to your dwarven sensibilities. Where dwarven crafting embraces the natural variations in stone and metal, celebrating the materials' inherent character, the Crystalline Consortium creates structures of such uniform exactness that they seem almost unnatural.\n\nNevertheless, you cannot deny their technological achievements. After three centuries of mastering traditional dwarven metallurgy and stonecraft at your mountain hold, you've been sent to study the Consortium's precision techniques and determine what might be adapted to enhance your clan's legendary craftsmanship. Your secondary mission—to establish a trade agreement for the unique metals and gems found only in your ancestral mines—would bring much-needed resources to your people.\n\nThe forge hammer at your belt, passed down through seven generations of master crafters, feels heavy with responsibility. Your clan has not sent an emissary to the outer planes in nearly two centuries, preferring self-sufficiency to outside entanglements. Yet resources grow scarcer in the mountains, and the hold's council finally acknowledged that controlled trade might be necessary for survival.\n\nYou take a deep breath, savoring the familiar scent of metal from the samples in your pack—a reminder of home and purpose. The Prismals of the Consortium are already studying you with their faceted eyes, likely cataloging every aspect of your dwarven appearance. Their analytical nature might seem cold, but you understand examination before commitment. After all, no master crafter would forge an alliance without first testing the materials thoroughly.",
      "skill_proficiencies": [
        "Crafting (Metallurgy)",
        "History (Dwarven)",
        "Appraisal"
      ],
      "origin_traits": [
        {
          "name": "Master Crafter's Eye",
          "description": "You gain advantage on checks made to assess the quality of metalwork or stonework."
        },
        {
          "name": "Clan Representative",
          "description": "You carry the authority to negotiate trade agreements on behalf of your dwarven clan."
        }
      ]
    },
    "mycora_envoy": {
      "id": "mycora_envoy",
      "name": "Mycora Envoy",
      "description": "As a Mycora from the Verdant plane, you've been sent to the Nexus world. Study how different planar environments affect growth patterns and share your people's symbiotic knowledge with other cultures.",
      "starting_location_id": "verdant_embassy",
      "starting_items": [
        "living_garments",
        "spore_collection_kit",
        "symbiotic_communication_pod",
        "seed_vault",
        "environmental_adaptation_tonic"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Mycora"
      ],
      "suitable_classes": [
        "Cleric",
        "Ranger",
        "Wanderer",
        "Mage"
      ],
      "introduction_text": "The carefully cultivated environment of the Verdant Embassy provides welcome familiarity after your transition from the Verdant plane, though you can sense its slight artificiality. The living walls here are distant cousins to the vast mycelial networks of your home, maintained through careful tending rather than existing in their natural state of constant evolution and adaptation.\n\nAs a chosen envoy of the Mycora collective consciousness, you carry with you the wisdom of thousands of growth cycles, the communal knowledge of your fungal species shared through spore-based memory transfer. Your mission has two symbiotic aspects: to collect and study growth patterns from different planar environments, and to share beneficial Mycoran techniques with other cultures.\n\nThrough the symbiotic communication pod at your side, you maintain a tenuous connection to your home collective, though the messages across planes arrive delayed and sometimes fragmented. The seed vault you carry contains carefully selected specimens that might thrive in new environments, potentially creating beneficial adaptations that could be reintegrated into the collective.\n\nYour living garments shift slightly, adjusting to the embassy's humidity levels—a practical demonstration of the Mycoran principle that all life should continually adapt rather than impose rigid order. This philosophy often puts your people at odds with the Crystalline Consortium's precise equations and the Concordant Cities' careful management of planar boundaries.\n\nAs you prepare to venture beyond the embassy's familiar environment, you take a small sip of adaptation tonic, feeling its effects spread through your system. Like all Mycora, you excel at finding balance in new ecosystems. The question is whether the beings of this plane will be receptive to the symbiotic wisdom you offer, or if they will see only an unusual fungal entity too different from themselves to trust.",
      "skill_proficiencies": [
        "Nature",
        "Medicine",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Collective Connection",
          "description": "You maintain a tenuous link to the Mycora collective, potentially receiving guidance or sharing information."
        },
        {
          "name": "Symbiotic Knowledge",
          "description": "You possess unique insights into plant life, fungi, and ecological balance."
        }
      ],
      "starting_culture_id": "verdant"
    },
    "prismal_researcher": {
      "id": "prismal_researcher",
      "name": "Prismal Researcher",
      "description": "As a Prismal mathematician specializing in planar geometry, you've been authorized by the Crystalline Consortium. Conduct field research at the Shifting Library, seeking patterns in the way knowledge exists across multiple planes simultaneously.",
      "starting_location_id": "shifting_library",
      "starting_items": [
        "crystalline_implants",
        "geometric_calculation_device",
        "consortium_authorization",
        "multidimensional_mapping_tools",
        "faceted_light_source"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Prismal"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The extraordinary spatial anomalies of the Shifting Library surround you, their mathematical complexity both fascinating and challenging even to your Prismal perceptions. Your crystalline body refracts the ambient light as you stand motionless, allowing your geometric implants to process and analyze the impossible architecture that allows the Library to exist simultaneously across multiple planes.\n\nThe Crystalline Consortium rarely approves extended external research missions, preferring controlled experiments within their precisely ordered environments. However, your theoretical work on planar intersection matrices proved sufficiently compelling for the High Calculation Chamber to make an exception. If your hypothesis about predictable patterns in cross-planar knowledge storage is correct, it would represent a significant advancement in the Consortium's understanding of reality's fundamental structure.\n\nYour geometric calculation device emits a soft hum as it continues mapping the Library's dimensional shifts, recording data that would overwhelm even the most brilliant non-Prismal mind. The faceted light source at your belt occasionally pulses in response to particularly complex spatial distortions, alerting you to areas worthy of detailed analysis.\n\nThe Lexicants have been surprisingly accommodating, granting you access to sections typically restricted to their own kind. Perhaps they recognize in your crystalline form a kindred appreciation for precision and order, though their organic methods of knowledge preservation seem needlessly inefficient compared to the perfect data storage of Prismal crystal matrices.\n\nAs your implants complete their initial calibration to the Library's unique resonance pattern, you mentally review your research parameters. The Consortium expects quantifiable results, precise measurements, and logical conclusions. What they do not expect—what you have not shared with them—is your personal hypothesis that the Library may contain mathematical proofs that could fundamentally alter the Consortium's understanding of reality itself.",
      "skill_proficiencies": [
        "Arcana",
        "Investigation",
        "Mathematics (Advanced)"
      ],
      "origin_traits": [
        {
          "name": "Planar Geometer",
          "description": "You possess advanced knowledge of the mathematical principles governing planar interactions."
        },
        {
          "name": "Consortium Authorization",
          "description": "Your research is sanctioned by the Crystalline Consortium, granting you specific privileges and access."
        }
      ],
      "starting_culture_id": "crystalline"
    },
    "cinderspawn_pilgrim": {
      "id": "cinderspawn_pilgrim",
      "name": "Cinderspawn Pilgrim",
      "description": "As a Cinderspawn seeking deeper spiritual connection with your ancestors, you've left the Ashen plane. Undertake a pilgrimage to various ceremonial fire sites across the Nexus world, beginning with the Eternal Flame at the Ashen Camp.",
      "starting_location_id": "ashen_camp",
      "starting_items": [
        "ancestral_ash_container",
        "ember_renewal_tonic",
        "pilgrimage_map",
        "flame-resistant_wrappings",
        "ritual_igniter"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Cinderspawn"
      ],
      "suitable_classes": [
        "Warrior",
        "Mage",
        "Cleric"
      ],
      "introduction_text": "The Eternal Flame at the center of the Ashen Camp flickers in response to your presence, its heat calling to the embers that constantly regenerate your Cinderspawn form. Fine ash trails behind you as you approach the sacred fire—not the lifeless dust of mundane ash, but living particles infused with ancestral memory and power. The Covenant members give you respectful distance, recognizing a fellow devotee of impermanence despite your origin from the Ashen plane itself.\n\nYour pilgrimage has just begun. The container of ancestral ash secured within your flame-resistant wrappings holds the remains of your progenitor—the one whose final immolation created the spark from which your consciousness formed. Through the sacred ritual of Ash Walking, you've communed with fragments of their memory, but full understanding remains elusive, like embers glimpsed through smoke.\n\nThe pilgrimage map, marked with locations of significant fires across the Nexus plane, will guide your journey. Each site offers an opportunity to perform the rituals that might strengthen your connection to the ancestral knowledge embedded in your very being. The Eternal Flame of the Ashen Camp marks only the first step.\n\nAs you kneel before the fire, you uncork the ember renewal tonic, consuming half and offering the remainder to the flames. Your body's internal heat intensifies, the ember at your core flaring brightly enough that the glow shows through your skin. The sensation is both painful and exhilarating—a reminder that in the philosophy of both the Ashen Covenant and your own people, transformation requires consumption, and rebirth demands destruction.\n\nTomorrow, you will continue your pilgrimage, following the map to the next sacred flame. But tonight, as sparks rise into the darkening sky, you prepare for the ritual that will temporarily separate your consciousness from your body, allowing your awareness to merge with the Eternal Flame and perhaps glimpse the wisdom of all who have surrendered themselves to its purifying heat.",
      "skill_proficiencies": [
        "Religion",
        "Endurance",
        "History (Oral)"
      ],
      "origin_traits": [
        {
          "name": "Pilgrim's Purpose",
          "description": "Your journey has a sacred goal, granting you inner resilience (+1 WIS save) against despair."
        },
        {
          "name": "Ashen Affinity",
          "description": "You have a natural connection to the Ashen plane and its associated magic (Ash Walking)."
        }
      ],
      "starting_culture_id": "ashen"
    },
    "maelstri_navigator": {
      "id": "maelstri_navigator",
      "name": "Maelstri Navigator",
      "description": "As a Maelstri, you've arrived at Tempest Harbor to serve as a navigator for trading vessels. Use your innate connection to storms to predict and navigate the chaotic weather patterns near the Tempest plane.",
      "starting_location_id": "tempest_harbor",
      "starting_items": [
        "storm_tattoo_kit",
        "weather_prediction_dice",
        "captain's_contract",
        "bottled_lightning",
        "temporal_compass"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Maelstri"
      ],
      "suitable_classes": [
        "Rogue",
        "Mage",
        "Wanderer"
      ],
      "introduction_text": "The swaying docks of Tempest Harbor shift beneath your feet in a rhythm that feels like home—chaotic yet somehow predictable to your Maelstri senses. The internal tempest that swirls within your partially translucent body resonates with the storm energies captured in the Flotilla's vessels, creating a harmony of chaotic potentials that other species could never perceive.\n\nYou've arrived during a rare celestial alignment, when the barriers between the Tempest plane and the Nexus are at their thinnest, allowing for easier passage and more reliable predictions. Your services as a navigator are in high demand; captains know that a Maelstri's intuitive understanding of probability and storm patterns can mean the difference between profitable voyages and disaster.\n\nThe captain's contract tucked into your belt represents your first commission in this harbor—a trading vessel seeking to venture dangerously close to the edges of the Tempest plane to collect rare storm essences. The payment offered is substantial, reflecting the risk involved and the value of your abilities.\n\nAs you wait for your meeting with the captain, you idly spin your weather prediction dice, their faces constantly shifting to display different meteorological patterns. With each tumble, you can sense the minute probability shifts they represent—not just predictions, but subtle manipulations of chance itself, a skill unique to your people.\n\nThe bottled lightning at your side occasionally illuminates your translucent skin from within as it resonates with the tempest inside you. Outsiders find it disconcerting how the storm patterns within your body never repeat, never settle into predictable forms. But then, that is the essence of being Maelstri—embracing the beauty of chaos and the certainty of change, guiding others through patterns they cannot comprehend.",
      "skill_proficiencies": [
        "Navigation",
        "Acrobatics",
        "Insight (Probability)"
      ],
      "origin_traits": [
        {
          "name": "Storm Sense",
          "description": "You can intuitively sense impending weather changes and planar disturbances related to the Tempest plane."
        },
        {
          "name": "Fluid Motion",
          "description": "You gain advantage on checks made to maintain balance in unstable or chaotic environments."
        }
      ],
      "starting_culture_id": "tempest"
    },
    "halfling_trader": {
      "id": "halfling_trader",
      "name": "Halfling Trader",
      "description": "As a halfling with a knack for finding valuable goods and spotting good deals, you've arrived at the bustling Tempest Harbor. You hope to make your fortune trading exotic goods from across the planes during a rare celestial alignment.",
      "starting_location_id": "tempest_harbor",
      "starting_items": [
        "trading_ledger",
        "sample_case_of_goods",
        "lucky_coin",
        "haggler's_pendant",
        "hidden_coin_purse"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Halfling"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer"
      ],
      "introduction_text": "The vibrant chaos of Tempest Harbor surrounds you, a halfling barely noticed among the taller traders and sailors rushing to conduct business before the celestial alignment ends and the harbor disappears. This suits you perfectly—being underestimated has always been your greatest advantage in the trading business.\n\nThe sample case of goods strapped across your back contains carefully selected items from three different planes, each small enough to carry easily but valuable enough to fund your next, larger venture. Your trading ledger, filled with contacts in ports across the Nexus plane, represents years of building trust and reputation despite the prejudice larger folk often hold against halfling merchants.\n\nYou absently finger the lucky coin in your pocket—not actually magical, despite what you tell potential business partners, but a reminder of your first successful trade. The haggler's pendant around your neck, however, genuinely helps focus your natural halfling luck during crucial negotiations, giving you an edge when deals come down to chance.\n\nThe hidden coin purse, sewn into the lining of your vest where nimble-fingered thieves wouldn't think to look, contains just enough capital to secure the exotic goods you've heard rumors about—crystalline computational devices from the Consortium, rare spores from the Verdant Collective, or perhaps emotional residue captured in ash by Covenant mystics.\n\nAs you weave through the crowd, your keen eyes notice pricing patterns and inventory shifts that others miss. The Tempest Flotilla's merchants follow no predictable system, their leadership changing hourly, but that apparent disorder holds opportunities for those observant enough to spot them. Being smaller than most traders means you hear conversations not meant for your ears and see deals happening under tables or behind curtains.\n\nYou adjust your sample case and head toward the Flux Market. With the right timing, a smallish halfling might just walk away with the biggest profit of the day.",
      "skill_proficiencies": [
        "Persuasion",
        "Appraisal",
        "Stealth"
      ],
      "origin_traits": [
        {
          "name": "Opportunistic Trader",
          "description": "You have a knack for spotting valuable goods and potential deals where others might not."
        },
        {
          "name": "Unassuming Presence",
          "description": "Your small stature allows you to blend into crowds easily, gaining advantage on checks to eavesdrop or remain unnoticed."
        }
      ],
      "starting_culture_id": "tempest"
    },
    "orc_mercenary": {
      "id": "orc_mercenary",
      "name": "Orc Mercenary",
      "description": "As an orc with a reputation for battlefield prowess, you've been hired to protect a research team. Your strength and combat experience will be crucial for survival in the dangerous Planar Bleed Zone.",
      "starting_location_id": "planar_bleed_zone",
      "starting_items": [
        "mercenary_contract",
        "heavy_weapon",
        "partial_armor_set",
        "protection_talisman",
        "battlefield_trophy"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Orc"
      ],
      "suitable_classes": [
        "Warrior",
        "Ranger"
      ],
      "introduction_text": "The impossible landscape of The Convergence stretches before you, a chaotic blend of elements from multiple planes that would disorient most guards. But you've seen stranger battlefields during your years as a mercenary, and your orcish senses are already cataloging potential threats and defensive positions around the researchers' camp.\n\nThe mercenary contract that brought you to this dangerous assignment promised triple the usual rate—compensation for the planar exposure risks that even the researchers' protective equipment can't fully mitigate. Your own protection comes in the form of a talisman given to you by the team leader, its magic constantly humming against your skin, supposedly stabilizing your personal reality against the zone's unpredictable effects.\n\nYour heavy weapon rests easily across your shoulders, its weight a familiar comfort in this unfamiliar environment. The partial armor set you wear offers protection while maintaining mobility—crucial in a place where the very ground might suddenly behave according to another plane's physical laws. The battlefield trophy hanging from your belt—a crystalline shard from your first campaign against rogue Consortium elements—serves as both lucky charm and reminder of past victories against seemingly impossible odds.\n\nThe research team eyes you with the usual mixture of wariness and relief that greets orcish mercenaries—fear of your species' legendary battle rage tempered by gratitude for having that same ferocity as protection. You've grown accustomed to these reactions, learning to use the intimidation factor to your advantage. It's usually better for morale if the clients believe nothing can frighten you, even if the truth is more complex.\n\nAs one of the researchers approaches with a map of planned exploration routes, you grin, revealing characteristic tusks. Time to earn your pay by keeping these scholars alive in a place where reality itself can't be trusted—just another day's work for an orc mercenary with a reputation to maintain.",
      "skill_proficiencies": [
        "Athletics",
        "Intimidation",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Battle Hardened",
          "description": "You gain advantage on saving throws against fear effects."
        },
        {
          "name": "Mercenary Reputation",
          "description": "Your reputation precedes you, potentially influencing interactions with employers and other mercenaries."
        }
      ]
    },
    "fortune_seeker": {
      "id": "fortune_seeker",
      "name": "Fortune Seeker",
      "description": "Having heard rumors of a mysterious ghost market appearing during Resonance Events, offering items and opportunities not available anywhere else in the planes. You've positioned yourself in Harmonia to intercept its next manifestation.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "resonance_detector",
        "trading_goods",
        "market_rumors_collection",
        "multi-planar_currency",
        "protective_charm"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Elf",
        "Dwarf"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer",
        "Mage"
      ],
      "introduction_text": "The streets of Harmonia hum with the usual energy of planar convergence, but your attention focuses on the subtle resonance fluctuations that your detector keeps registering near the eastern quarter. According to the rumor collection you've meticulously gathered over the past year, these are exactly the kind of pre-manifestation signals that precede the appearance of the legendary Ghost Market.\n\nMany dismiss the Ghost Market as mere myth—a fantastical bazaar run by entities known only as 'The Between,' appearing randomly during Resonance Events and offering impossible goods from all planes. But you've spoken with too many reliable sources, seen too many inexplicable items supposedly purchased there, to believe it's just a story. The pattern of manifestations you've mapped suggests the market is due to appear in Harmonia within days.\n\nThe protective charm hangs heavy around your neck, a necessary precaution according to those who claim to have visited the market successfully. 'The Between drive hard bargains,' one former merchant warned you, 'and sometimes the price isn't obvious until it's already been paid.' The multi-planar currency you've gathered—coins from across all five planes, each carrying its own unique resonance—should help you secure whatever opportunities arise.\n\nYour trading goods, carefully selected for their cross-planar rarity, represent most of your worldly wealth. It's a risk to invest so heavily in what might be a fruitless chase, but the potential rewards... rare artifacts, unique knowledge, perhaps even services unavailable anywhere else in any plane. Fortune favors the bold, after all, and you've never been accused of excessive caution.\n\nAs your resonance detector gives a particularly strong pulse, you adjust your course through the crowded street. The readings are getting stronger, more regular. If the pattern holds, you'll be perfectly positioned when the Ghost Market materializes. Then you'll discover firsthand if the opportunities it offers are worth the mysterious prices it demands.",
      "skill_proficiencies": [
        "Investigation",
        "Appraisal",
        "Planar Lore (Rumors)"
      ],
      "origin_traits": [
        {
          "name": "Market Chaser",
          "description": "You possess knowledge of rumored Ghost Market appearances and potential locations."
        },
        {
          "name": "Risk Taker",
          "description": "You are more willing to take chances for potential high rewards, for better or worse."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "human_diplomat": {
      "id": "human_diplomat",
      "name": "Human Diplomat",
      "description": "As a human diplomat representing Harmonia's interests, you've been assigned to the Verdant Embassy. Negotiate new trade agreements and cultural exchanges, leveraging your species' natural adaptability and diplomatic skills.",
      "starting_location_id": "verdant_embassy",
      "starting_items": [
        "diplomatic_credentials",
        "formal_negotiation_attire",
        "gift_package_for_ambassadors",
        "treaty_drafts",
        "translator's_guidebook"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human"
      ],
      "suitable_classes": [
        "Wanderer",
        "Mage",
        "Cleric"
      ],
      "introduction_text": "The living architecture of the Verdant Embassy surrounds you with an alien beauty that still manages to inspire rather than intimidate—exactly the kind of cross-cultural appreciation your diplomatic training emphasized. As Harmonia's newly appointed envoy to the Verdant Collective, you represent humanity's greatest strength: the ability to adapt to and find common ground with even the most different cultures across the planes.\n\nYour diplomatic credentials, bearing the seal of the Harmonic Council, opened doors easily enough, but you know that true rapport with the Verdant representatives will require more nuanced skills. The translator's guidebook you've studied for months has given you a basic understanding of their plant-based communication methods, though fluency in such an alien language remains elusive even for the most talented human linguists.\n\nThe treaty drafts in your attaché case represent months of preparation—proposals for expanded trade in medicinal compounds, research cooperation on adaptive agriculture, and cultural exchange programs that might benefit both societies. The formal negotiation attire you wear, designed to incorporate elements reminiscent of growth and renewal, was specifically commissioned to show respect for Verdant aesthetic values.\n\nThe gift package prepared for the ambassadors contains carefully selected offerings: seeds from rare Harmonian flowering plants, crystal prisms that refract light in patterns similar to Verdant spore displays, and small vials of pure water from the confluence springs near the Harmonic Spire. Such gifts, symbolic rather than extravagant, often speak louder than words in inter-planar diplomacy.\n\nAs you prepare for your first formal meeting with the Green Speakers, you mentally review what you know of their customs and hierarchies. Humans have long served as bridges between the more extreme differences of the planar races—lacking the specialized evolutionary adaptations of the Mycora or Prismals, but compensating with versatility and cultural flexibility. Today, those human diplomatic talents will be put to the test as you seek agreements beneficial to all within the complex web of inter-planar politics.",
      "skill_proficiencies": [
        "Diplomacy",
        "Persuasion",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Harmonian Envoy",
          "description": "You represent the Concordant Cities and carry their diplomatic authority."
        },
        {
          "name": "Adaptive Negotiator",
          "description": "You gain advantage on checks made to understand and adapt to unfamiliar cultural norms during negotiations."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "quest_testbed": {
      "id": "quest_testbed",
      "name": "Quest Testbed",
      "description": "A developer-focused starting origin in a special test hub designed to quickly generate and verify all quest proofs (items, kills, visits, flags).",
      "starting_location_id": "test_hub",
      "starting_items": [
        "test_apple"
      ],
      "initial_quests": [
        "TEST_Q01",
        "TEST_Q02",
        "TEST_Q03",
        "TEST_Q04",
        "TEST_Q05",
        "TEST_Q06",
        "TEST_Q07",
        "TEST_Q08",
        "TEST_Q09",
        "TEST_Q10",
        "TEST_Q11",
        "TEST_Q12",
        "TEST_Q13",
        "TEST_Q14",
        "TEST_Q15",
        "TEST_Q16",
        "TEST_Q17",
        "TEST_Q18",
        "TEST_Q19",
        "TEST_Q20",
        "TEST_Q21",
        "TEST_Q22",
        "TEST_Q23",
        "TEST_Q24",
        "TEST_Q25"
      ],
      "suitable_races": [
        "Human"
      ],
      "suitable_classes": [
        "Wanderer"
      ],
      "introduction_text": "This is a dedicated test scenario. You begin in the Quest Test Hub, with tools to validate quest objective detection and event logging.",
      "skill_proficiencies": [],
      "origin_traits": [],
      "starting_culture_id": "concordant"
    }
  },
  "metadata": {
    "version": "1.0.1",
    "description": "Starting origin definitions for the RPG game world"
  }
}
```

### File: config\world\scenarios\quests.json

```json
{
  "quests": {
    "luminary_fragment_hunt": {
      "id": "luminary_fragment_hunt",
      "title": "Echoes of the Luminaries",
      "description": "Reports indicate a Luminary fragment has manifested in the Echo Woods. Various factions are racing to obtain it, and the Harmonic Order has tasked you with retrieving it before it falls into dangerous hands.",
      "giver_id": "resonance_sage",
      "level": 3,
      "objectives": [
        {
          "id": "locate_fragment",
          "description": "Find the location of the Luminary fragment in Echo Woods",
          "type": "explore",
          "target_id": "whispering_grove",
          "location_id": "echo_woods",
          "completion_criteria": "Discover the Whispering Grove location where the fragment is hidden",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "defeat_cipher",
          "description": "Defeat the Cipher Remnant agents attempting to claim the fragment",
          "type": "kill",
          "target_id": "cipher_agents",
          "location_id": "whispering_grove",
          "completion_criteria": "Defeat all Cipher Remnant agents in the area",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "secure_fragment",
          "description": "Retrieve the Luminary fragment",
          "type": "fetch",
          "target_id": "luminary_fragment",
          "location_id": "whispering_grove",
          "completion_criteria": "Collect the Luminary fragment",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "return_fragment",
          "description": "Return the fragment to the Resonance Sage in Harmonia",
          "type": "deliver",
          "target_id": "resonance_sage",
          "location_id": "harmonia",
          "completion_criteria": "Deliver the Luminary fragment to the Resonance Sage",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 800,
        "gold": 250,
        "items": [
          "resonance_charm"
        ]
      },
      "prerequisites": []
    },
    "resonance_crisis": {
      "id": "resonance_crisis",
      "title": "Dangerous Frequencies",
      "description": "A small frontier settlement is experiencing unusually violent Resonance Events. The Harmonic Order needs someone to investigate the cause and protect the community during these unpredictable phenomena.",
      "giver_id": "council_speaker",
      "level": 5,
      "objectives": [
        {
          "id": "reach_settlement",
          "description": "Travel to the affected settlement near Echo Woods",
          "type": "explore",
          "target_id": "woodhaven_settlement",
          "location_id": "echo_woods",
          "completion_criteria": "Arrive at Woodhaven Settlement",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "investigate_anomalies",
          "description": "Investigate the unusual Resonance patterns in three locations around the settlement",
          "type": "explore",
          "target_id": "anomaly_sites",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Investigate all three anomaly sites",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "identify_disruptor",
          "description": "Identify the source of the Resonance disruption",
          "type": "fetch",
          "target_id": "dissonant_device",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Find the Dissonant Path device causing the disruptions",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "confront_dissonant",
          "description": "Confront the Dissonant Path member responsible for the disruption",
          "type": "kill",
          "target_id": "dissonant_disruptor",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Defeat the Dissonant Path member",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "stabilize_resonance",
          "description": "Use Planar Anchoring techniques to stabilize the area during the next Resonance Event",
          "type": "interact",
          "target_id": "resonance_node",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Complete the anchoring ritual at the village center",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 1200,
        "gold": 400,
        "items": [
          "planar_anchor_stone"
        ]
      },
      "prerequisites": []
    },
    "planar_expedition": {
      "id": "planar_expedition",
      "title": "Beyond the Veil",
      "description": "A research team from the Harmonic Order is mounting an expedition to explore a newly discovered Planar Bleed Zone. They need additional security and assistance to catalog the unique resources and phenomena within the zone.",
      "giver_id": "harmonic_researcher",
      "level": 4,
      "objectives": [
        {
          "id": "meet_expedition",
          "description": "Meet with the research team at their camp near The Convergence",
          "type": "explore",
          "target_id": "research_camp",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Find and speak with the research team at their camp",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "escort_researchers",
          "description": "Escort the research team safely into the Planar Bleed Zone",
          "type": "escort",
          "target_id": "research_team",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Protect all researchers during travel to the convergence perimeter",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "collect_samples",
          "description": "Collect samples from three different areas within the zone",
          "type": "fetch",
          "target_id": "planar_samples",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Collect all required samples",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "defend_camp",
          "description": "Defend the research camp from planar hybrid creatures",
          "type": "kill",
          "target_id": "planar_hybrids",
          "location_id": "research_camp",
          "completion_criteria": "Defeat all attacking creatures",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "document_anomaly",
          "description": "Help researchers document a major planar anomaly at the center of the zone",
          "type": "interact",
          "target_id": "reality_fault",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Complete documentation of the planar anomaly",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 1000,
        "gold": 350,
        "items": [
          "planar_sample_kit",
          "hybrid_seedling"
        ]
      },
      "prerequisites": []
    },
    "lost_knowledge": {
      "id": "lost_knowledge",
      "title": "Pages Through Time",
      "description": "The Shifting Library contains crucial information about stabilizing Resonance Events, but the needed texts only become accessible during a specific planar alignment. You need to obtain the required authorization and retrieve the knowledge before time runs out.",
      "giver_id": "head_lexicant",
      "level": 6,
      "objectives": [
        {
          "id": "obtain_authorization",
          "description": "Obtain authorization to access the Shifting Library from the Council of Resonance",
          "type": "interact",
          "target_id": "council_speaker",
          "location_id": "harmonia",
          "completion_criteria": "Convince the Council to grant library access",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "retrieve_focusing_crystal",
          "description": "Retrieve a focusing crystal from the Crystalline Enclave to help locate the texts",
          "type": "fetch",
          "target_id": "planar_focusing_crystal",
          "location_id": "crystalline_enclave",
          "completion_criteria": "Obtain the focusing crystal",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "access_library",
          "description": "Travel to the Shifting Library during the planar alignment",
          "type": "explore",
          "target_id": "shifting_library",
          "location_id": "shifting_library",
          "completion_criteria": "Reach the library during the alignment event",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "navigate_shifting_stacks",
          "description": "Navigate the constantly changing layout of the library to find the Pre-Shattering Archive",
          "type": "interact",
          "target_id": "shifting_stacks",
          "location_id": "shifting_library",
          "completion_criteria": "Solve the navigation puzzle of the shifting stacks",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "locate_texts",
          "description": "Find the texts about Resonance stabilization in the Pre-Shattering Archive",
          "type": "fetch",
          "target_id": "resonance_codex",
          "location_id": "pre_shattering_archive",
          "completion_criteria": "Locate and retrieve the Resonance Codex",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "escape_collapse",
          "description": "Escape the library as the planar alignment ends and sections begin disappearing",
          "type": "explore",
          "target_id": "library_entrance",
          "location_id": "shifting_library",
          "completion_criteria": "Reach the library entrance with the codex before time runs out",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 1500,
        "gold": 300,
        "items": [
          "lexicant_cipher",
          "plane_reader"
        ]
      },
      "prerequisites": []
    },
    "merchant_protection": {
      "id": "merchant_protection",
      "title": "Valuable Cargo",
      "description": "The Mercantile Chord is transporting a shipment of rare Resonant Materials between trading hubs and needs protection from bandits and natural hazards.",
      "giver_id": "mercantile_factor",
      "level": 3,
      "objectives": [
        {
          "id": "meet_caravan",
          "description": "Meet with the merchant caravan in Harmonia",
          "type": "interact",
          "target_id": "caravan_master",
          "location_id": "harmonia",
          "completion_criteria": "Meet and speak with the caravan master",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "escort_to_crystalline",
          "description": "Escort the caravan to the Crystalline Enclave",
          "type": "escort",
          "target_id": "merchant_caravan",
          "location_id": "crystalline_enclave",
          "completion_criteria": "Safely escort the caravan to its destination",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "fend_off_bandits",
          "description": "Protect the caravan from bandit attacks along the route",
          "type": "kill",
          "target_id": "resonance_bandits",
          "location_id": "",
          "completion_criteria": "Defeat all bandit groups that attack the caravan",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "navigate_flux_zone",
          "description": "Help the caravan safely navigate through a minor Resonance flux zone",
          "type": "interact",
          "target_id": "flux_zone",
          "location_id": "",
          "completion_criteria": "Successfully guide the caravan through the flux zone",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "delivery_complete",
          "description": "Ensure the cargo is safely delivered to the Crystalline Enclave",
          "type": "interact",
          "target_id": "consortium_representative",
          "location_id": "crystalline_enclave",
          "completion_criteria": "Complete delivery to the Consortium representative",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 750,
        "gold": 500,
        "items": [
          "resonant_trinket"
        ]
      },
      "prerequisites": []
    },
    "resonance_touched": {
      "id": "resonance_touched",
      "title": "Fragmented Self",
      "description": "A citizen of Harmonia has returned from a Resonance Event changed, possibly merged with an alternate version of themselves. They're experiencing 'Resonance sickness' and need help integrating their fragmented identity.",
      "giver_id": "attunement_master",
      "level": 2,
      "objectives": [
        {
          "id": "meet_patient",
          "description": "Meet with the Resonance-touched patient in the Attunement Hall",
          "type": "interact",
          "target_id": "resonance_touched_citizen",
          "location_id": "attunement_hall",
          "completion_criteria": "Meet and speak with the affected citizen",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "collect_erdium",
          "description": "Collect Erdium crystals to help with the reattunement ritual",
          "type": "fetch",
          "target_id": "erdium_crystal",
          "location_id": "echo_woods",
          "completion_criteria": "Gather the required erdium crystals",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "find_memories",
          "description": "Help the patient recover memories from before the Resonance Event",
          "type": "explore",
          "target_id": "memory_locations",
          "location_id": "harmonia",
          "completion_criteria": "Find all three memory locations in Harmonia",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "perform_ritual",
          "description": "Assist the Attunement Master in performing a reattunement ritual",
          "type": "interact",
          "target_id": "attunement_hall",
          "location_id": "harmonia",
          "completion_criteria": "Successfully complete the reattunement ritual",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "follow_up",
          "description": "Check on the patient after a few days to ensure the treatment worked",
          "type": "interact",
          "target_id": "resonance_touched_citizen",
          "location_id": "harmonia",
          "completion_criteria": "Follow up with the citizen to confirm recovery",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 500,
        "gold": 150,
        "items": [
          "identity_charm"
        ]
      },
      "prerequisites": []
    },
    "551cdb35-a4bb-4b23-b6c1-4d2772947efb": {
      "id": "551cdb35-a4bb-4b23-b6c1-4d2772947efb",
      "title": "Whispers of the Ash Plane (Ashen Covenant Recruit)",
      "description": "The Ashen Elder has tasked you with your first practical Ash Walking ritual. The Covenant needs to find a new, safe migration path, and the Elder believes a long-dead ancestor holds the key within the Ash Plane. You must project your consciousness, seek the ancestral spirit, and glean crucial information to guide your people.",
      "giver_id": "ashen_elder",
      "level": 1,
      "objectives": [
        {
          "id": "gather_ritual_ashes",
          "description": "Gather specific ritual ashes from the designated area near the Ashen Camp.",
          "type": "fetch",
          "target_id": "ritual_ashes",
          "location_id": "ashen_camp",
          "completion_criteria": "Collect the required ritual ashes for the Ash Walking ceremony.",
          "rewards": {},
          "mandatory": false
        },
        {
          "id": "perform_ash_walking_ritual",
          "description": "Perform the guided Ash Walking ritual at the sacred altar within the Ashen Camp.",
          "type": "interact",
          "target_id": "ash_walking_altar",
          "location_id": "ashen_camp",
          "completion_criteria": "Successfully initiate the Ash Walking ritual and project your consciousness.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "seek_ancestral_guidance",
          "description": "Within the Ash Plane, seek out the ancestral spirit and glean information about a safe migration path.",
          "type": "explore",
          "target_id": "ancestral_spirit_echo",
          "location_id": "ashen_camp",
          "completion_criteria": "Obtain the cryptic message or vision from the ancestral spirit.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "interpret_ancestral_message",
          "description": "Return to your body and consult with the Ashen Elder to interpret the ancestral message.",
          "type": "deliver",
          "target_id": "ashen_elder",
          "location_id": "ashen_camp",
          "completion_criteria": "Discuss the ancestral message with the Ashen Elder to understand its meaning.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "scout_new_migration_path",
          "description": "Based on the interpreted ancestral guidance, scout the new migration path in Echo Woods.",
          "type": "explore",
          "target_id": "migration_path_entrance",
          "location_id": "echo_woods",
          "completion_criteria": "Locate and assess the viability of the new migration path as indicated by the ancestor.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "gold": 50,
        "items": [
          "ash_walker_talisman"
        ],
        "xp": 200
      },
      "prerequisites": []
    },
    "the-first-exchange": {
      "id": "the-first-exchange",
      "title": "The First Exchange",
      "description": "A local merchant in Harmonia needs a small, important package delivered to a contact in the Verdant Embassy. This simple task will serve as your first foray into the world's commerce.",
      "giver_id": "merchant_guild_representative",
      "level": 1,
      "objectives": [
        {
          "id": "collect_package",
          "description": "Collect the delivery package from the Merchant Guild Representative in Harmonia.",
          "type": "fetch",
          "target_id": "delivery_package_harmonia",
          "location_id": "harmonia",
          "completion_criteria": "Obtain the delivery package from the representative.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "deliver_to_embassy",
          "description": "Deliver the package to the designated contact at the Verdant Embassy.",
          "type": "deliver",
          "target_id": "verdant_embassy_contact",
          "location_id": "verdant_embassy",
          "completion_criteria": "Successfully deliver the package to the contact.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "gold": 50,
        "items": [],
        "xp": 100
      },
      "prerequisites": []
    },
    "TEST_Q01": {
      "id": "TEST_Q01",
      "title": "Q01 – Fetch an Apple",
      "description": "Obtain a test apple.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Obtain 1 test_apple.",
          "type": "fetch",
          "target_id": "test_apple",
          "location_id": "",
          "completion_criteria": "Have at least 1 test_apple in inventory.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q02": {
      "id": "TEST_Q02",
      "title": "Q02 – Defeat the Test Wolf",
      "description": "Defeat the wolf",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat a wolf (test).",
          "type": "kill",
          "target_id": "wolf",
          "location_id": "harmonia",
          "completion_criteria": "Eliminate the wolf",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": "[]"
      },
      "prerequisites": []
    },
    "TEST_Q03": {
      "id": "TEST_Q03",
      "title": "Q03 – Visit the Test Ruins",
      "description": "Visit test_ancient_ruins.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_ancient_ruins.",
          "type": "explore",
          "target_id": "test_ancient_ruins",
          "location_id": "test_ancient_ruins",
          "completion_criteria": "Enter the test_ancient_ruins location.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q04": {
      "id": "TEST_Q04",
      "title": "Q04 – Speak to the Test Elder",
      "description": "Ensure flag test_spoke_to_elder is true.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Speak with the test_elder.",
          "type": "interact",
          "target_id": "test_elder",
          "location_id": "test_area",
          "completion_criteria": "Conversation with test_elder completed.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q05": {
      "id": "TEST_Q05",
      "title": "Q05 – Beat the Clock (Before 5m)",
      "description": "Complete before time < 300.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Finish the timed task before 300s.",
          "type": "interact",
          "target_id": "test_timer_gate",
          "location_id": "test_area",
          "completion_criteria": "Objective completed in under 300 seconds.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q06": {
      "id": "TEST_Q06",
      "title": "Q06 – After Time Gate (After 10m)",
      "description": "Complete only after time > 600.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Finish the timed task after 600s.",
          "type": "interact",
          "target_id": "test_timer_gate",
          "location_id": "test_area",
          "completion_criteria": "Objective completed after 600 seconds have elapsed.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q07": {
      "id": "TEST_Q07",
      "title": "Q07 – All Composite",
      "description": "Have test_key and defeat test_guardian.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Have test_key and defeat test_guardian.",
          "type": "interact",
          "target_id": "test_guardian_gate",
          "location_id": "test_area",
          "completion_criteria": "Gate opened with test_key and guardian defeated.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q08": {
      "id": "TEST_Q08",
      "title": "Q08 – Any Composite",
      "description": "Visit either test_dock or test_harbor.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_dock OR test_harbor.",
          "type": "explore",
          "target_id": "test_dock_or_harbor",
          "location_id": "test_coast",
          "completion_criteria": "Arrive at either test_dock or test_harbor.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q09": {
      "id": "TEST_Q09",
      "title": "Q09 – None Composite",
      "description": "Alarm must NOT be triggered.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Ensure alarm remains silent.",
          "type": "interact",
          "target_id": "test_alarm_system",
          "location_id": "test_area",
          "completion_criteria": "Objective completed with no alarm raised.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q10": {
      "id": "TEST_Q10",
      "title": "Q10 – Mandatory + Optional",
      "description": "Mandatory item; optional visit.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Obtain test_badge.",
          "type": "fetch",
          "target_id": "test_badge",
          "location_id": "",
          "completion_criteria": "Acquire the test_badge.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Optionally visit test_outpost.",
          "type": "explore",
          "target_id": "test_outpost",
          "location_id": "test_outpost",
          "completion_criteria": "Enter the test_outpost (optional).",
          "rewards": {},
          "mandatory": false
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q11": {
      "id": "TEST_Q11",
      "title": "Q11 – Two Mandatory Objectives",
      "description": "Complete both mandatory objectives.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat test_bandit_captain.",
          "type": "kill",
          "target_id": "test_bandit_captain",
          "location_id": "test_road",
          "completion_criteria": "Defeat the test_bandit_captain.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Collect 3 test_gem.",
          "type": "fetch",
          "target_id": "test_gem",
          "location_id": "",
          "completion_criteria": "Possess 3 test_gem.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q12": {
      "id": "TEST_Q12",
      "title": "Q12 – Semantic Only (No DSL)",
      "description": "Objective completion via semantic inference.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Convince the test_mayor to help.",
          "type": "interact",
          "target_id": "test_mayor",
          "location_id": "test_town",
          "completion_criteria": "Mayor agrees to help.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q13": {
      "id": "TEST_Q13",
      "title": "Q13 – Semantic Mandatory + Optional DSL",
      "description": "Mandatory semantic objective and optional visit objective.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Broker peace between test_factions.",
          "type": "interact",
          "target_id": "test_faction_council",
          "location_id": "test_hall",
          "completion_criteria": "Agreement reached between factions.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Optionally visit test_neutral_ground.",
          "type": "explore",
          "target_id": "test_neutral_ground",
          "location_id": "test_neutral_ground",
          "completion_criteria": "Enter test_neutral_ground (optional).",
          "rewards": {},
          "mandatory": false
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q14": {
      "id": "TEST_Q14",
      "title": "Q14 – Flag Chain",
      "description": "Require both flags set (speak to guard and acquire pass).",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Speak to guard and acquire pass.",
          "type": "interact",
          "target_id": "test_gate_guard",
          "location_id": "test_gate",
          "completion_criteria": "Guard spoken to and pass acquired.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q15": {
      "id": "TEST_Q15",
      "title": "Q15 – Inventory Count",
      "description": "Collect 3 test_herb.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Collect 3 test_herb.",
          "type": "fetch",
          "target_id": "test_herb",
          "location_id": "",
          "completion_criteria": "Possess 3 test_herb.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q16": {
      "id": "TEST_Q16",
      "title": "Q16 – Any of Three Enemies",
      "description": "Defeat any one of three test bandits.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat any bandit (1 of 3).",
          "type": "kill",
          "target_id": "test_bandit_group",
          "location_id": "test_road",
          "completion_criteria": "Defeat at least one of test_bandit_1/2/3.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q17": {
      "id": "TEST_Q17",
      "title": "Q17 – Visit Two Key Locations",
      "description": "Visit both test_gate and test_keep.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_gate and test_keep.",
          "type": "explore",
          "target_id": "test_gate_and_keep",
          "location_id": "test_realm",
          "completion_criteria": "Enter both test_gate and test_keep.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q18": {
      "id": "TEST_Q18",
      "title": "Q18 – Negative Flag (Not Banished)",
      "description": "Ensure not banished.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Ensure test_banished is false.",
          "type": "interact",
          "target_id": "test_citizenship_check",
          "location_id": "test_town",
          "completion_criteria": "Status confirms not banished.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q19": {
      "id": "TEST_Q19",
      "title": "Q19 – Mixed All/Any",
      "description": "Travel to dock or harbor and have a test_ticket.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_dock or test_harbor and show test_ticket.",
          "type": "interact",
          "target_id": "test_port_entry",
          "location_id": "test_coast",
          "completion_criteria": "Entry permitted with test_ticket at dock or harbor.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q20": {
      "id": "TEST_Q20",
      "title": "Q20 – Optional Does Not Block",
      "description": "Optional objective should not block completion.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Deliver test_letter.",
          "type": "deliver",
          "target_id": "test_recipient",
          "location_id": "test_town",
          "completion_criteria": "Deliver the test_letter to recipient.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Explore test_garden (optional).",
          "type": "explore",
          "target_id": "test_garden",
          "location_id": "test_garden",
          "completion_criteria": "Enter the test_garden.",
          "rewards": {},
          "mandatory": false
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q21": {
      "id": "TEST_Q21",
      "title": "Q21 – Narrative-Heavy Objective",
      "description": "Deliver an inspiring speech to the council.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Deliver an inspiring speech to the test_council about unity and cooperation.",
          "type": "interact",
          "target_id": "test_council",
          "location_id": "test_hall",
          "completion_criteria": "Speech delivered; council acknowledges.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q22": {
      "id": "TEST_Q22",
      "title": "Q22 – Three Mandatory Objectives",
      "description": "Complete three distinct tasks.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat test_ogre.",
          "type": "kill",
          "target_id": "test_ogre",
          "location_id": "test_ogre_cave",
          "completion_criteria": "Ogre defeated.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Collect 2 test_ogre_tooth.",
          "type": "fetch",
          "target_id": "test_ogre_tooth",
          "location_id": "",
          "completion_criteria": "Possess 2 test_ogre_tooth.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O3",
          "description": "Visit test_ogre_cave.",
          "type": "explore",
          "target_id": "test_ogre_cave",
          "location_id": "test_ogre_cave",
          "completion_criteria": "Enter the ogre cave.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q23": {
      "id": "TEST_Q23",
      "title": "Q23 – Semantic Failure Gating",
      "description": "Objective completion depends on semantic inference only.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Convince test_skeptic to trust you.",
          "type": "interact",
          "target_id": "test_skeptic",
          "location_id": "test_village",
          "completion_criteria": "Skeptic indicates trust.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q24": {
      "id": "TEST_Q24",
      "title": "Q24 – Abandon/Fallback Scenario",
      "description": "Regular quest for abandon/failure flow testing.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Recover the test_relic.",
          "type": "fetch",
          "target_id": "test_relic",
          "location_id": "test_ruins",
          "completion_criteria": "Obtain the test_relic.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q25": {
      "id": "TEST_Q25",
      "title": "Q25 – Complex Mixed Conditions",
      "description": "Any of two routes, but no alarm and with resource gate.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Route A (visit test_tower AND have test_rope) OR Route B (defeat test_spider_queen) with no alarm.",
          "type": "interact",
          "target_id": "test_tower_or_spider_queen",
          "location_id": "test_vale",
          "completion_criteria": "No alarm triggered; either tower+rope route or spider queen defeated.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Quest definitions for the RPG game world"
  }
}
```

### File: config\skills.json

```json
{
  "skills": {
    "acrobatics": {
      "name": "Acrobatics",
      "primary_stat": "DEXTERITY",
      "category": "PHYSICAL",
      "description": "Performing agile maneuvers, balancing, tumbling, and reducing fall damage."
    },
    "appraisal": {
      "name": "Appraisal",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Determining the value, authenticity, and properties of items, artifacts, or goods."
    },
    "arcana": {
      "name": "Arcana",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge about magic, magical traditions, spells, arcane symbols, and supernatural effects."
    },
    "athletics": {
      "name": "Athletics",
      "primary_stat": "STRENGTH",
      "category": "PHYSICAL",
      "description": "Performing physical activities like running, jumping, swimming, climbing, and feats of raw power."
    },
    "crafting_basic": {
      "name": "Crafting (Basic)",
      "primary_stat": "INTELLIGENCE",
      "category": "UTILITY",
      "description": "Basic ability to create, repair, or modify simple items and equipment."
    },
    "crafting_metallurgy": {
      "name": "Crafting (Metallurgy)",
      "primary_stat": "INTELLIGENCE",
      "category": "UTILITY",
      "description": "Specialized skill in working with metals, including forging, smithing, and understanding alloys."
    },
    "deception": {
      "name": "Deception",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Misleading others through lies, trickery, disguises, and manipulation of truth."
    },
    "diplomacy": {
      "name": "Diplomacy",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Influencing others through negotiation, tact, and understanding of social etiquette."
    },
    "dodge": {
      "name": "Dodge",
      "primary_stat": "DEXTERITY",
      "category": "COMBAT",
      "description": "Avoiding attacks and obstacles through quick movements."
    },
    "endurance": {
      "name": "Endurance",
      "primary_stat": "CONSTITUTION",
      "category": "PHYSICAL",
      "description": "Withstanding prolonged physical exertion, fatigue, hardship, and resisting exhaustion."
    },
    "history": {
      "name": "History",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge of past events, civilizations, historical figures, and the study of recorded history."
    },
    "history_oral": {
      "name": "History (Oral)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge of past events, legends, and traditions passed down verbally, common in cultures without extensive written records."
    },
    "insight": {
      "name": "Insight",
      "primary_stat": "INSIGHT",
      "category": "MENTAL",
      "description": "Discerning true intentions, detecting lies, sensing emotions, and understanding underlying truths or motives."
    },
    "insight_probability": {
      "name": "Insight (Probability)",
      "primary_stat": "INSIGHT",
      "category": "MENTAL",
      "description": "Intuitive understanding of chance, luck, predicting random outcomes, and sensing probability currents."
    },
    "insight_risk_assessment": {
      "name": "Insight (Risk Assessment)",
      "primary_stat": "INSIGHT",
      "category": "MENTAL",
      "description": "Specifically assessing potential dangers, evaluating probabilities of failure/success, and calculating risks in various situations."
    },
    "intimidation": {
      "name": "Intimidation",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Influencing others through threats, fear, force of presence, or hostile actions."
    },
    "investigation": {
      "name": "Investigation",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Finding clues, deducing information, examining details, and solving mysteries or puzzles."
    },
    "mathematics_basic": {
      "name": "Mathematics (Basic)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Basic understanding and application of mathematical principles, logic, and calculations."
    },
    "medicine": {
      "name": "Medicine",
      "primary_stat": "WISDOM",
      "category": "UTILITY",
      "description": "Diagnosing illnesses, treating wounds, administering first aid, and knowledge of remedies."
    },
    "melee_attack": {
      "name": "Melee Attack",
      "primary_stat": "STRENGTH",
      "category": "COMBAT",
      "description": "Physical close-range combat attacks."
    },
    "nature": {
      "name": "Nature",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Knowledge about flora, fauna, weather, natural terrain, and survival in natural environments."
    },
    "navigation": {
      "name": "Navigation",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Finding one's way through various terrains, using maps, stars, or natural signs."
    },
    "perception": {
      "name": "Perception",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Noticing details in your surroundings, detecting hidden objects, and general awareness of your environment."
    },
    "persuasion": {
      "name": "Persuasion",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Convincing others through reasoning, charm, debate, or emotional appeals."
    },
    "planar_lore": {
      "name": "Planar Lore",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "General knowledge about the different planes of existence, their properties, inhabitants, and planar travel."
    },
    "planar_lore_basic": {
      "name": "Planar Lore (Basic)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Basic understanding of the different planes of existence, their interactions, and common phenomena."
    },
    "planar_lore_rumors": {
      "name": "Planar Lore (Rumors)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge of hearsay, gossip, unverified information, and local legends about the planes."
    },
    "ranged_attack": {
      "name": "Ranged Attack",
      "primary_stat": "DEXTERITY",
      "category": "COMBAT",
      "description": "Physical ranged combat attacks."
    },
    "religion": {
      "name": "Religion",
      "primary_stat": "WILLPOWER",
      "category": "KNOWLEDGE",
      "description": "Knowledge about deities, religious rites, holy symbols, mythology, and theological matters. Also represents strength of faith."
    },
    "spell_attack": {
      "name": "Spell Attack",
      "primary_stat": "INTELLIGENCE",
      "category": "COMBAT",
      "description": "Magical attacks using spells or arcane abilities."
    },
    "stealth": {
      "name": "Stealth",
      "primary_stat": "DEXTERITY",
      "category": "COVERT",
      "description": "Moving silently, avoiding detection, and hiding effectively."
    },
    "streetwise_harmonia": {
      "name": "Streetwise (Harmonia)",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Knowledge of the streets, local customs, influential figures, and underworld of Harmonia."
    },
    "survival": {
      "name": "Survival",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Thriving in the wild by tracking, foraging, finding shelter, and navigating harsh environments."
    },
    "unarmed_attack": {
      "name": "Unarmed Attack",
      "primary_stat": "STRENGTH",
      "category": "COMBAT",
      "description": "Combat attacks without weapons, such as punches and kicks."
    }
  }
}
```

### File: config\world\locations\locations.json

```json
{
  "locations": {
    "harmonia": {
      "id": "harmonia",
      "name": "Harmonia",
      "description": "The largest and most influential of the Concordant Cities, serving as the capital of their confederation. Built at the confluence of major Resonance nodes, its architecture is a mesmerizing blend of all five planes that shifts and reconfigures during Resonance Events. The city is arranged in seven concentric rings, each representing different aspects of planar influence.",
      "type": "city",
      "region": "Central Nexus",
      "culture_id": "concordant",
      "population": 80000,
      "culture_mix": {
        "concordant": 0.8,
        "verdant": 0.1,
        "crystalline": 0.05,
        "tempest": 0.05
      },
      "features": [
        {
          "name": "The Harmonic Spire",
          "description": "A towering structure at the city center that serves as both government seat and Resonance monitoring station. The spire changes color and sometimes shape depending on upcoming Resonance Events.",
          "interaction_type": "examine"
        },
        {
          "name": "The Attunement Hall",
          "description": "A sacred space where citizens receive their protective tattoos. The walls are lined with designs from across all five planes.",
          "interaction_type": "interact"
        },
        {
          "name": "The Resonance Academy",
          "description": "The premier institution for studying planar phenomena and predicting Resonance Events. Home to the Harmonic Order.",
          "interaction_type": "examine"
        },
        {
          "name": "The Five Voices Plaza",
          "description": "A pentagonal square where the Five Speakers occasionally gather to deliberate. Each corner features a statue representing a fragmented Luminary.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "verdant_embassy",
          "description": "A well-maintained road leading to the diplomatic outpost of the Verdant Collective.",
          "travel_time": 240,
          "requirements": []
        },
        {
          "target": "crystalline_enclave",
          "description": "A geometric pathway of perfectly aligned stones leading to the Crystalline Consortium's trading post.",
          "travel_time": 180,
          "requirements": []
        },
        {
          "target": "echo_woods",
          "description": "A winding path through increasingly wild terrain that eventually reaches the Echo Woods.",
          "travel_time": 360,
          "requirements": []
        }
      ],
      "npcs": [
        "council_speaker",
        "resonance_sage",
        "attunement_master"
      ]
    },
    "verdant_embassy": {
      "id": "verdant_embassy",
      "name": "Verdant Embassy",
      "description": "An outpost of the Verdant Collective on the Nexus plane. The embassy is a living structure, grown rather than built, with walls of interwoven trees and flowering vines that change with the seasons. It serves as both a diplomatic mission and a trading post for the unique flora and fauna of the Verdant plane.",
      "type": "outpost",
      "region": "Western Nexus",
      "culture_id": "verdant",
      "population": 350,
      "culture_mix": {
        "verdant": 0.8,
        "concordant": 0.1,
        "crystalline": 0.05,
        "tempest": 0.05
      },
      "features": [
        {
          "name": "The Living Council Chamber",
          "description": "A circular room where tree branches have been coaxed into forming a natural amphitheater. The branches shift slightly to improve acoustics when someone speaks.",
          "interaction_type": "examine"
        },
        {
          "name": "The Green Speech Garden",
          "description": "A secluded garden where members of the Verdant Collective communicate through their unique plant-based language.",
          "interaction_type": "examine"
        },
        {
          "name": "Seasonal Quarters",
          "description": "Living quarters that transform with the seasons, offering different amenities depending on the time of year.",
          "interaction_type": "interact"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A well-maintained road leading back to the capital city of Harmonia.",
          "travel_time": 240,
          "requirements": []
        },
        {
          "target": "deeproot_crossing",
          "description": "A temporary passage to the Verdant plane that becomes accessible during specific Resonance Events.",
          "travel_time": 120,
          "requirements": [
            "resonance_event_verdant"
          ]
        }
      ],
      "npcs": [
        "verdant_ambassador",
        "botanical_trader",
        "green_speaker"
      ]
    },
    "crystalline_enclave": {
      "id": "crystalline_enclave",
      "name": "Crystalline Enclave",
      "description": "A trading post and research facility established by the Crystalline Consortium on the Nexus plane. The entire structure is built from precisely angled crystalline materials that reflect light in complex mathematical patterns. Inside, scholars and merchants work to advance Facet Magic and trade in rare minerals.",
      "type": "outpost",
      "region": "Eastern Nexus",
      "culture_id": "crystalline",
      "population": 275,
      "culture_mix": {
        "crystalline": 0.8,
        "concordant": 0.1,
        "verdant": 0.05,
        "tempest": 0.05
      },
      "features": [
        {
          "name": "The Calculation Chamber",
          "description": "A hexagonal room where crystal matrices are used to solve complex mathematical and magical equations. The floor is inscribed with intricate geometric formulas.",
          "interaction_type": "examine"
        },
        {
          "name": "The Precision Market",
          "description": "A marketplace where crystalline components and precision instruments are traded under strict quality control standards.",
          "interaction_type": "interact"
        },
        {
          "name": "Faceting Workshop",
          "description": "A facility where young members of the Consortium receive their crystal implants, carefully aligned to enhance specific mental abilities.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A geometric pathway of perfectly aligned stones leading back to Harmonia.",
          "travel_time": 180,
          "requirements": []
        },
        {
          "target": "lattice_point",
          "description": "A precisely calibrated portal to the Crystalline plane, accessible only during certain celestial alignments.",
          "travel_time": 90,
          "requirements": [
            "celestial_alignment"
          ]
        }
      ],
      "npcs": [
        "consortium_representative",
        "facet_mage",
        "crystal_merchant"
      ]
    },
    "echo_woods": {
      "id": "echo_woods",
      "name": "Echo Woods",
      "description": "A mysterious forest that exists partially in the Nexus plane and partially in the Verdant plane. The trees seem to whisper echoes of conversations held long ago, and visitors often report seeing shadowy figures moving between the trunks. It's known as a place where the boundaries between planes are naturally thin.",
      "type": "forest",
      "region": "Northwestern Nexus",
      "culture_id": "",
      "population": 0,
      "culture_mix": {
        "verdant": 0.6,
        "concordant": 0.2,
        "ashen": 0.2
      },
      "features": [
        {
          "name": "The Whispering Grove",
          "description": "A clearing where echoes of past conversations can be heard clearly, sometimes providing valuable historical information.",
          "interaction_type": "interact"
        },
        {
          "name": "The Blurred Stream",
          "description": "A waterway that occasionally shifts between planes, with water that can grant temporary visions of other planes when drunk.",
          "interaction_type": "use"
        },
        {
          "name": "The Ancient Hollow",
          "description": "An enormous hollow tree that predates The Shattering. Inside is a small, permanent Planar Bleed Zone.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A winding path through increasingly civilized terrain that eventually reaches Harmonia.",
          "travel_time": 360,
          "requirements": []
        },
        {
          "target": "ashen_camp",
          "description": "A barely visible trail that leads to a temporary settlement of the Ashen Covenant.",
          "travel_time": 180,
          "requirements": [
            "tracking_skill"
          ]
        }
      ],
      "npcs": [
        "echo_collector",
        "plane_walker"
      ]
    },
    "ashen_camp": {
      "id": "ashen_camp",
      "name": "Ashen Camp",
      "description": "A temporary settlement of the Ashen Covenant, comprised of easily dismantled structures and tents made from ash-treated hides. The camp is relocated monthly according to Covenant traditions. At its center burns an eternal flame where ancestral ashes are kept and used in rituals.",
      "type": "settlement",
      "region": "Northern Nexus",
      "culture_id": "ashen",
      "population": 120,
      "culture_mix": {
        "ashen": 0.8,
        "concordant": 0.1,
        "verdant": 0.1
      },
      "features": [
        {
          "name": "The Ancestor Fire",
          "description": "A central fire pit where ashes of ancestors are preserved. Covenant members can sometimes communicate with the dead through rituals performed here.",
          "interaction_type": "interact"
        },
        {
          "name": "The Exchange Circle",
          "description": "An open area where the monthly Possession Exchange ceremony takes place, redistributing all material goods among the community.",
          "interaction_type": "examine"
        },
        {
          "name": "Ash Walker Tents",
          "description": "Special tents where practitioners of Ash Walking temporarily transfer their consciousness to the Ashen plane.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "echo_woods",
          "description": "A barely visible trail leading back to the Echo Woods.",
          "travel_time": 180,
          "requirements": []
        },
        {
          "target": "gray_veil",
          "description": "A spiritual pathway to a location in the Ashen plane, only accessible to those trained in Ash Walking.",
          "travel_time": 60,
          "requirements": [
            "ash_walking_knowledge"
          ]
        }
      ],
      "npcs": [
        "covenant_elder",
        "ash_walker",
        "memory_keeper"
      ]
    },
    "tempest_harbor": {
      "id": "tempest_harbor",
      "name": "Tempest Harbor",
      "description": "A temporary docking location for the Tempest Flotilla on the Nexus plane, only present during specific celestial alignments. The harbor consists of rapidly constructed floating platforms and swaying walkways, all designed to be disassembled quickly. The atmosphere is chaotic and festive, with constant trading, gambling, and storytelling.",
      "type": "harbor",
      "region": "Southern Nexus",
      "culture_id": "tempest",
      "population": 800,
      "culture_mix": {
        "tempest": 0.8,
        "concordant": 0.1,
        "verdant": 0.1
      },
      "features": [
        {
          "name": "The Flux Market",
          "description": "A chaotic marketplace where leadership and prices change daily, offering rare goods from the Tempest plane.",
          "interaction_type": "interact"
        },
        {
          "name": "Storm Binder's Pavilion",
          "description": "A large tent where skilled artisans capture storm essences in elaborate tattoo designs.",
          "interaction_type": "interact"
        },
        {
          "name": "The Opportunity Board",
          "description": "A constantly updated notice board listing current jobs, adventures, and opportunities throughout the planes.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A southern road leading to the capital city of Harmonia.",
          "travel_time": 300,
          "requirements": []
        },
        {
          "target": "maelstrom_edge",
          "description": "A dangerous passage to the edge of the Tempest plane, only navigable during specific celestial alignments.",
          "travel_time": 240,
          "requirements": [
            "celestial_alignment",
            "tempest_navigation"
          ]
        }
      ],
      "npcs": [
        "flotilla_captain",
        "storm_binder",
        "probability_merchant"
      ]
    },
    "shifting_library": {
      "id": "shifting_library",
      "name": "The Shifting Library",
      "description": "A mysterious repository of knowledge that exists simultaneously in all planes. Different sections become accessible depending on which plane is currently dominant. The exterior appears as a modest stone building, but the interior contains seemingly endless halls of books, artifacts, and recordings from across all planes and time periods.",
      "type": "library",
      "region": "Planar Overlap",
      "culture_id": "",
      "population": 20,
      "culture_mix": {},
      "features": [
        {
          "name": "The Lexicant Hall",
          "description": "The central chamber where the enigmatic Lexicants—beings who can exist in multiple planes simultaneously—catalog and preserve knowledge.",
          "interaction_type": "examine"
        },
        {
          "name": "The Shifting Stacks",
          "description": "Endless rows of bookshelves that rearrange themselves based on planar influences, sometimes revealing previously inaccessible tomes.",
          "interaction_type": "interact"
        },
        {
          "name": "Pre-Shattering Archive",
          "description": "A heavily secured section containing fragmentary records from before The Shattering, only accessible during rare planar alignments.",
          "interaction_type": "examine"
        },
        {
          "name": "The Reading Nexus",
          "description": "A circular chamber with desks that automatically provide reference materials related to the researcher's current study.",
          "interaction_type": "use"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "The library's location relative to Harmonia changes based on planar alignments, but it's typically a day's journey.",
          "travel_time": 480,
          "requirements": [
            "library_authorization"
          ]
        }
      ],
      "npcs": [
        "head_lexicant",
        "knowledge_seeker",
        "forgotten_scholar"
      ]
    },
    "planar_bleed_zone": {
      "id": "planar_bleed_zone",
      "name": "The Convergence",
      "description": "A large area where multiple planes have permanently merged, creating a surreal landscape with elements from all planes coexisting in impossible ways. Flora and fauna have hybridized, and the laws of physics seem to vary from one meter to the next. Despite the dangers, researchers and resource gatherers frequent the area for its unique properties.",
      "type": "anomaly",
      "region": "Planar Border",
      "culture_id": "",
      "population": 50,
      "culture_mix": {},
      "features": [
        {
          "name": "Reality Fault",
          "description": "A visible crack in space where raw planar energy seeps through, causing unpredictable magical effects in the vicinity.",
          "interaction_type": "examine"
        },
        {
          "name": "Hybridization Gardens",
          "description": "A research station where Harmonic Order scientists study the unique hybrid flora and fauna that have evolved in the zone.",
          "interaction_type": "interact"
        },
        {
          "name": "Echo Chamber",
          "description": "A cave where sounds seem to echo from other planes and times, occasionally revealing useful information.",
          "interaction_type": "interact"
        },
        {
          "name": "Harvester Camp",
          "description": "A fortified encampment for those who gather the valuable resources that can only be found in Planar Bleed Zones.",
          "interaction_type": "interact"
        }
      ],
      "connections": [
        {
          "target": "echo_woods",
          "description": "A hazardous path through shifting terrain that eventually reaches more stable ground near the Echo Woods.",
          "travel_time": 600,
          "requirements": [
            "planar_protection"
          ]
        }
      ],
      "npcs": [
        "harmonic_researcher",
        "resource_harvester",
        "planar_hybrid"
      ]
    },
    "ghost_market": {
      "id": "ghost_market",
      "name": "The Ghost Market",
      "description": "A mysterious marketplace that appears only during specific Resonance Events. Run by enigmatic entities known as 'The Between,' it offers goods, services, and information from across all planes. The market materializes in different locations each time but is recognizable by its ethereal tents and the faint bell music that accompanies its appearance.",
      "type": "market",
      "region": "Variable",
      "culture_id": "",
      "population": 0,
      "culture_mix": {},
      "features": [
        {
          "name": "The Contract Circle",
          "description": "A central area where deals and contracts are formalized. Agreements made here are magically binding across all planes.",
          "interaction_type": "interact"
        },
        {
          "name": "Memory Exchange",
          "description": "A tent where memories can be bought, sold, or traded – sometimes willingly, sometimes not.",
          "interaction_type": "interact"
        },
        {
          "name": "Between Emporium",
          "description": "The largest structure in the market, selling impossible items that shouldn't exist in any single plane.",
          "interaction_type": "interact"
        },
        {
          "name": "Information Well",
          "description": "A literal well where visitors can ask questions and receive answers – for a price.",
          "interaction_type": "use"
        }
      ],
      "connections": [],
      "npcs": [
        "the_proprietor",
        "memory_merchant",
        "contract_binder"
      ]
    },
    "test_hub": {
      "id": "test_hub",
      "name": "Quest Test Hub",
      "description": "A developer test area used to quickly validate quest proofs (items, kills, visits, flags) in a controlled environment.",
      "type": "outpost",
      "region": "Dev",
      "culture_id": "concordant",
      "population": 0,
      "culture_mix": {},
      "features": [],
      "connections": [],
      "npcs": []
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Location definitions for the RPG game world"
  }
}
```

### File: config\items\origin_items.json

```json
[
  {
    "id": "academic_robes",
    "name": "Academic Robes",
    "description": "Formal robes of a scholar from the Resonance Academy, adorned with symbols of knowledge.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.5,
    "value": 40,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "intelligence_bonus_research",
        "value": 1,
        "display_name": "Research Intelligence"
      }
    ],
    "durability": 60,
    "tags": [
      "clothing",
      "armor",
      "academic",
      "scholar"
    ],
    "is_consumable": false,
    "is_stackable": false,
    "is_quest_item": false,
    "dice_roll_effects": []
  },
  {
    "id": "ancestral_ash_container",
    "name": "Ancestral Ash Container",
    "description": "A specially crafted container made from obsidian and silver, designed to safely hold and preserve sacred ancestral ashes.",
    "item_type": "container",
    "rarity": "rare",
    "weight": 0.5,
    "value": 400,
    "custom_properties": {
      "spiritual_attunement": "high",
      "preservation_quality": "excellent"
    },
    "tags": [
      "container",
      "cinderspawn",
      "ash",
      "ritual",
      "ancestral"
    ]
  },
  {
    "id": "ancestral_focus_crystal",
    "name": "Ancestral Focus Crystal",
    "description": "A crystal passed down through generations, used by elves to channel and focus magical energies.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.2,
    "value": 600,
    "is_equippable": true,
    "equip_slots": [
      "off_hand",
      "neck"
    ],
    "stats": [
      {
        "name": "spell_power_bonus",
        "value": 1,
        "display_name": "Spell Power"
      }
    ],
    "tags": [
      "tool",
      "magic_focus",
      "elven",
      "crystal",
      "ancestral"
    ]
  },
  {
    "id": "apprentice_robes",
    "name": "Apprentice Robes",
    "description": "Simple, functional robes identifying you as an apprentice of the Crystalline Enclave.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.0,
    "value": 25,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 40,
    "tags": [
      "clothing",
      "armor",
      "crystalline_consortium",
      "apprentice"
    ]
  },
  {
    "id": "ash-treated_clothing",
    "name": "Ash-Treated Clothing",
    "description": "Simple, durable clothing treated with sacred ashes for resilience and a faint connection to ancestral spirits. Common among the Ashen Covenant.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 2.0,
    "value": 20,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "fire_resistance",
        "value": 5,
        "display_name": "Fire Resistance",
        "is_percentage": true
      }
    ],
    "durability": 80,
    "tags": [
      "clothing",
      "armor",
      "ashen_covenant",
      "treated"
    ]
  },
  {
    "id": "battlefield_trophy",
    "name": "Battlefield Trophy",
    "description": "A memento taken from a significant past battle – perhaps a tooth, a banner fragment, or a broken weapon piece.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.3,
    "value": 10,
    "tags": [
      "trophy",
      "memento",
      "battle"
    ]
  },
  {
    "id": "between_token",
    "name": "Between Token",
    "description": "A smooth, dark stone that feels cold to the touch. It occasionally whispers in an unknown tongue. Given by an entity from The Between.",
    "item_type": "miscellaneous",
    "rarity": "rare",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "custom_properties": {
      "function": "communication_conduit_the_between"
    },
    "tags": [
      "token",
      "quest_item",
      "ghost_market",
      "ethereal"
    ]
  },
  {
    "id": "blank_journal",
    "name": "Blank Journal",
    "description": "A high-quality, empty journal ready to be filled with notes and discoveries.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.6,
    "value": 12,
    "tags": [
      "tool",
      "writing",
      "notes"
    ]
  },
  {
    "id": "bottled_lightning",
    "name": "Bottled Lightning",
    "description": "A vial containing a swirling spark of contained lightning. Can be used as a light source or a volatile component.",
    "item_type": "miscellaneous",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 150,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 5,
    "custom_properties": {
      "light_duration_minutes": 10,
      "discharge_damage": "1d8_lightning_if_broken"
    },
    "tags": [
      "lightning",
      "consumable",
      "light_source",
      "component",
      "maelstri"
    ]
  },
  {
    "id": "calculation_crystals",
    "name": "Calculation Crystals",
    "description": "A set of precisely cut crystals used in Crystalline Consortium mathematics and Facet Magic.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 200,
    "custom_properties": {
      "attunement_required": true
    },
    "tags": [
      "tool",
      "crystalline_consortium",
      "magic_component",
      "mathematics"
    ]
  },
  {
    "id": "captain's_contract",
    "name": "Captain's Contract",
    "description": "A signed contract securing your services as a navigator for a trading vessel in Tempest Harbor.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "quest_item",
      "tempest_harbor",
      "navigation"
    ]
  },
  {
    "id": "cataloging_tools",
    "name": "Cataloging Tools",
    "description": "A set of specialized tools for handling, examining, and indexing delicate texts and artifacts.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.8,
    "value": 60,
    "stats": [
      {
        "name": "investigation_bonus_texts",
        "value": 1,
        "display_name": "Text Investigation Bonus"
      }
    ],
    "tags": [
      "tool",
      "shifting_library",
      "research",
      "cataloging"
    ]
  },
  {
    "id": "clan_trade_contract",
    "name": "Clan Trade Contract (Template)",
    "description": "A formal contract template outlining terms for trade agreements on behalf of your dwarven clan.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "dwarven",
      "trade",
      "quest_item"
    ]
  },
  {
    "id": "market_rumors_collection",
    "name": "Collection of Market Rumors",
    "description": "A bundle of notes, overheard conversations, and cryptic clues related to the Ghost Market and other illicit trade.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.4,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "notes",
      "rumors",
      "ghost_market",
      "quest_item"
    ]
  },
  {
    "id": "concealed_weapon",
    "name": "Concealed Dagger",
    "description": "A small, easily hidden dagger. Favored by those who prefer to remain unassuming.",
    "item_type": "weapon",
    "rarity": "common",
    "weight": 0.3,
    "value": 40,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d4-1"
      }
    ],
    "durability": 50,
    "tags": [
      "weapon",
      "dagger",
      "concealed",
      "stealth"
    ]
  },
  {
    "id": "consortium_authorization",
    "name": "Consortium Research Authorization",
    "description": "A high-level authorization grant from the Crystalline Consortium, permitting access to restricted data and locations.",
    "item_type": "key",
    "rarity": "rare",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "key",
      "crystalline_consortium",
      "authorization",
      "research"
    ]
  },
  {
    "id": "covenant_pendant",
    "name": "Covenant Pendant",
    "description": "A small, carved bone pendant bearing the symbol of the Ashen Covenant. It's said to ward off minor malevolent spirits.",
    "item_type": "accessory",
    "rarity": "common",
    "weight": 0.1,
    "value": 15,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "willpower",
        "value": 1,
        "display_name": "Willpower Save Bonus"
      }
    ],
    "tags": [
      "amulet",
      "ashen_covenant",
      "spiritual"
    ]
  },
  {
    "id": "crystalline_implants",
    "name": "Crystalline Implants (Interface)",
    "description": "Subtle crystalline implants that allow a Prismal to interface with Consortium technology and enhance cognitive processing.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.0,
    "value": 0,
    "is_equippable": true,
    "equip_slots": [
      "head"
    ],
    "stats": [
      {
        "name": "data_processing_speed",
        "value": 2,
        "display_name": "Data Processing"
      },
      {
        "name": "mathematical_aptitude",
        "value": 1,
        "display_name": "Mathematical Aptitude"
      }
    ],
    "tags": [
      "implant",
      "tool",
      "prismal",
      "crystalline_consortium",
      "interface"
    ]
  },
  {
    "id": "diplomatic_credentials",
    "name": "Diplomatic Credentials",
    "description": "Official credentials identifying you as a diplomat of Harmonia, granting certain privileges and access.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "credentials",
      "diplomacy",
      "harmonia",
      "quest_item"
    ]
  },
  {
    "id": "diplomatic_insignia",
    "name": "Diplomatic Insignia",
    "description": "A broach or pin signifying your status as an emissary from your people.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "diplomacy_bonus",
        "value": 1,
        "display_name": "Diplomacy Bonus"
      }
    ],
    "tags": [
      "accessory",
      "insignia",
      "diplomacy"
    ]
  },
  {
    "id": "diplomatic_papers",
    "name": "Diplomatic Papers",
    "description": "Official documents identifying you as an envoy and outlining your mission.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "official",
      "diplomacy"
    ]
  },
  {
    "id": "ceremonial_flask",
    "name": "Dwarven Ceremonial Flask",
    "description": "An ornate flask, often filled with strong dwarven ale for rituals or important occasions.",
    "item_type": "container",
    "rarity": "uncommon",
    "weight": 0.7,
    "value": 120,
    "custom_properties": {
      "capacity_ml": 500,
      "material": "silver_inlaid_steel"
    },
    "tags": [
      "container",
      "flask",
      "dwarven",
      "ceremonial"
    ]
  },
  {
    "id": "dwarven_forge_hammer",
    "name": "Dwarven Forge Hammer",
    "description": "A masterfully crafted hammer, perfectly balanced for smithing. It bears ancient dwarven runes.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 5.0,
    "value": 800,
    "is_equippable": true,
    "equip_slots": [
      "main_hand"
    ],
    "stats": [
      {
        "name": "crafting_smithing_bonus",
        "value": 2,
        "display_name": "Smithing Bonus"
      }
    ],
    "dice_roll_effects": [
      {
        "effect_type": "physical_blunt_damage",
        "dice_notation": "1d6"
      }
    ],
    "durability": 200,
    "tags": [
      "tool",
      "weapon",
      "hammer",
      "dwarven",
      "crafting",
      "smithing"
    ]
  },
  {
    "id": "elven_crafted_robes",
    "name": "Elven Crafted Robes",
    "description": "Elegant robes woven with subtle patterns that shimmer in the light, offering surprising resilience.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 1.0,
    "value": 250,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 2,
        "display_name": "Armor"
      },
      {
        "name": "magic_resistance_minor",
        "value": 5,
        "display_name": "Minor Magic Resist",
        "is_percentage": true
      }
    ],
    "durability": 70,
    "tags": [
      "clothing",
      "armor",
      "elven",
      "magic"
    ]
  },
  {
    "id": "ember_renewal_tonic",
    "name": "Ember Renewal Tonic",
    "description": "A potent tonic that revitalizes a Cinderspawn's inner ember, hastening regeneration and enhancing flame-based abilities.",
    "item_type": "consumable",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 200,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "stats": [
      {
        "name": "regeneration_boost",
        "value": 50,
        "display_name": "Regeneration Boost",
        "is_percentage": true
      },
      {
        "name": "flame_power_increase",
        "value": 2,
        "display_name": "Flame Power"
      },
      {
        "name": "duration_minutes",
        "value": 10,
        "display_name": "Duration (Minutes)"
      }
    ],
    "tags": [
      "potion",
      "consumable",
      "cinderspawn",
      "buff",
      "fire"
    ]
  },
  {
    "id": "emergency_beacon",
    "name": "Emergency Beacon",
    "description": "A single-use beacon that, when activated, sends a distress signal detectable across short planar distances.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 150,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "tags": [
      "tool",
      "emergency",
      "signal",
      "consumable"
    ]
  },
  {
    "id": "enchanted_quill",
    "name": "Enchanted Quill",
    "description": "A quill that writes with self-replenishing ink and whose script remains stable across planar shifts.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 220,
    "tags": [
      "tool",
      "writing",
      "magic",
      "shifting_library"
    ]
  },
  {
    "id": "environmental_adaptation_tonic",
    "name": "Environmental Adaptation Tonic",
    "description": "A Mycoran tonic that temporarily enhances the imbiber's ability to adapt to hostile environments.",
    "item_type": "consumable",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 180,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "stats": [
      {
        "name": "environmental_resistance_boost",
        "value": 15,
        "display_name": "Environmental Resist Boost",
        "is_percentage": true
      },
      {
        "name": "duration_minutes",
        "value": 30,
        "display_name": "Duration (Minutes)"
      }
    ],
    "tags": [
      "potion",
      "consumable",
      "mycora",
      "adaptation",
      "buff"
    ]
  },
  {
    "id": "explorer_clothing",
    "name": "Explorer's Clothing",
    "description": "Durable, multi-layered clothing designed for protection against the elements and rough terrain.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 3.0,
    "value": 40,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 2,
        "display_name": "Armor"
      },
      {
        "name": "cold_resistance_minor",
        "value": 5,
        "display_name": "Minor Cold Resistance",
        "is_percentage": true
      }
    ],
    "durability": 100,
    "tags": [
      "clothing",
      "armor",
      "explorer",
      "survival"
    ]
  },
  {
    "id": "faceted_focusing_lens",
    "name": "Faceted Focusing Lens",
    "description": "A crystal lens with numerous facets, used to focus mental energies or manipulate light for Crystalline magic.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 180,
    "is_equippable": true,
    "equip_slots": [
      "off_hand"
    ],
    "stats": [
      {
        "name": "magic_attack",
        "value": 1,
        "display_name": "Spell Focus"
      }
    ],
    "tags": [
      "tool",
      "magic_focus",
      "crystalline_consortium",
      "lens"
    ]
  },
  {
    "id": "faceted_light_source",
    "name": "Faceted Light Source",
    "description": "A Prismal light source that emits focused beams of coherent light, useful for analysis or as a weak cutting tool.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.4,
    "value": 300,
    "custom_properties": {
      "light_intensity_lumens": 500,
      "focus_modes": [
        "wide_beam",
        "narrow_beam",
        "pulse"
      ]
    },
    "tags": [
      "tool",
      "prismal",
      "light_source",
      "analysis"
    ]
  },
  {
    "id": "family_heirloom",
    "name": "Family Heirloom",
    "description": "A small, worn trinket passed down through your family. Its true value might be sentimental, or perhaps something more.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.1,
    "value": 5,
    "is_quest_item": true,
    "tags": [
      "trinket",
      "heirloom",
      "sentimental",
      "quest_item"
    ]
  },
  {
    "id": "family_signet_ring",
    "name": "Family Signet Ring",
    "description": "A ring bearing the crest of a fallen noble family. It might still carry some influence, or attract unwanted attention.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 120,
    "is_equippable": true,
    "equip_slots": [
      "finger_1",
      "finger_2",
      "finger_3",
      "finger_4",
      "finger_5",
      "finger_6",
      "finger_7",
      "finger_8",
      "finger_9",
      "finger_10"
    ],
    "stats": [
      {
        "name": "social_influence_minor",
        "value": 1,
        "display_name": "Minor Social Influence"
      }
    ],
    "tags": [
      "ring",
      "accessory",
      "noble",
      "signet"
    ]
  },
  {
    "id": "fine_clothes_(worn)",
    "name": "Fine Clothes (Worn)",
    "description": "Once elegant attire, now showing signs of wear and travel. Still better than common rags.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.8,
    "value": 35,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 40,
    "current_durability": 25,
    "tags": [
      "clothing",
      "armor",
      "noble",
      "worn"
    ]
  },
  {
    "id": "fire_striker",
    "name": "Fire Striker",
    "description": "A reliable flint and steel for starting fires. Essential for survival and Covenant rituals.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.3,
    "value": 5,
    "is_equippable": false,
    "is_consumable": false,
    "is_stackable": false,
    "tags": [
      "tool",
      "fire",
      "survival"
    ]
  },
  {
    "id": "flame-resistant_wrappings",
    "name": "Flame-Resistant Wrappings",
    "description": "Thick, specially treated cloth wrappings that offer significant protection against fire and extreme heat.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 0.8,
    "value": 120,
    "is_equippable": true,
    "equip_slots": [
      "wrists",
      "legs",
      "chest"
    ],
    "stats": [
      {
        "name": "fire_resistance",
        "value": 25,
        "display_name": "Fire Resistance",
        "is_percentage": true
      }
    ],
    "durability": 90,
    "tags": [
      "clothing",
      "armor",
      "cinderspawn",
      "fire_protection"
    ]
  },
  {
    "id": "forged_documents",
    "name": "Forged Documents",
    "description": "Passably crafted travel papers and identification that might fool a cursory inspection.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 150,
    "custom_properties": {
      "forgery_quality": "average"
    },
    "tags": [
      "document",
      "forgery",
      "deception"
    ]
  },
  {
    "id": "formal_attire",
    "name": "Formal Attire",
    "description": "Well-made clothing suitable for diplomatic functions and formal occasions.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 2.5,
    "value": 150,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "charisma_bonus_social",
        "value": 1,
        "display_name": "Social Charisma"
      }
    ],
    "durability": 50,
    "tags": [
      "clothing",
      "armor",
      "formal",
      "diplomacy"
    ]
  },
  {
    "id": "formal_negotiation_attire",
    "name": "Formal Negotiation Attire",
    "description": "Impeccably tailored attire designed to convey authority and respect during high-stakes negotiations.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 2.0,
    "value": 200,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "persuasion_bonus",
        "value": 1,
        "display_name": "Persuasion Bonus"
      },
      {
        "name": "social_standing_perception",
        "value": 2,
        "display_name": "Perceived Social Standing"
      }
    ],
    "durability": 60,
    "tags": [
      "clothing",
      "armor",
      "formal",
      "diplomacy",
      "negotiation"
    ]
  },
  {
    "id": "geometric_calculation_device",
    "name": "Geometric Calculation Device",
    "description": "A complex Prismal device used for advanced geometric and multidimensional calculations.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.8,
    "value": 900,
    "stats": [
      {
        "name": "calculation_accuracy_bonus",
        "value": 3,
        "display_name": "Calculation Accuracy"
      }
    ],
    "tags": [
      "tool",
      "prismal",
      "crystalline_consortium",
      "mathematics",
      "calculation"
    ]
  },
  {
    "id": "market_trinket",
    "name": "Ghost Market Trinket",
    "description": "A small, oddly shaped trinket of unknown material. It hums faintly when Resonance Events are near.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 70,
    "is_equippable": true,
    "equip_slots": [
      "trinket_1",
      "trinket_2"
    ],
    "stats": [
      {
        "name": "resonance_detection",
        "value": 1,
        "display_name": "Resonance Detection"
      }
    ],
    "tags": [
      "trinket",
      "accessory",
      "ghost_market",
      "planar"
    ]
  },
  {
    "id": "gift_package_for_ambassadors",
    "name": "Gift Package for Ambassadors",
    "description": "A carefully selected assortment of gifts representing Harmonian culture, intended for presentation to foreign dignitaries.",
    "item_type": "miscellaneous",
    "rarity": "uncommon",
    "weight": 2.5,
    "value": 300,
    "is_stackable": false,
    "custom_properties": {
      "contents_description": "Rare seeds, crystal prism, pure water vial"
    },
    "tags": [
      "gift",
      "diplomacy",
      "harmonia",
      "trade_good"
    ]
  },
  {
    "id": "guard_uniform",
    "name": "Guard Uniform",
    "description": "Standard issue uniform of the Harmonic Guard, offering decent protection and clear identification.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 10.0,
    "value": 200,
    "is_equippable": true,
    "equip_slots": [
      "chest",
      "legs",
      "head"
    ],
    "stats": [
      {
        "name": "armor",
        "value": 6,
        "display_name": "Armor"
      }
    ],
    "durability": 130,
    "tags": [
      "armor",
      "uniform",
      "harmonic_guard"
    ]
  },
  {
    "id": "haggler's_pendant",
    "name": "Haggler's Pendant",
    "description": "A pendant that subtly influences negotiations in the wearer's favor. Or so the seller claimed.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 200,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "bargaining_bonus",
        "value": 1,
        "display_name": "Bargaining Bonus"
      }
    ],
    "tags": [
      "pendant",
      "accessory",
      "trade",
      "persuasion"
    ]
  },
  {
    "id": "harmonian_tattoo_kit",
    "name": "Harmonian Tattoo Kit",
    "description": "A set of fine needles, vibrant inks, and resonance-infused balms used for creating Attunement tattoos in Harmonia.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 150,
    "tags": [
      "tool",
      "harmonia",
      "attunement",
      "artisan"
    ]
  },
  {
    "id": "heavy_weapon",
    "name": "Heavy Orcish Cleaver",
    "description": "A large, brutally effective cleaver favored by Orcish warriors. Requires considerable strength to wield effectively.",
    "item_type": "weapon",
    "rarity": "uncommon",
    "weight": 7.0,
    "value": 450,
    "is_equippable": true,
    "equip_slots": [
      "two_hand"
    ],
    "stats": [
      {
        "name": "strength_requirement",
        "value": 15,
        "display_name": "Strength Req."
      }
    ],
    "dice_roll_effects": [
      {
        "effect_type": "slashing",
        "dice_notation": "1d12"
      }
    ],
    "durability": 160,
    "tags": [
      "weapon",
      "axe",
      "orcish",
      "heavy",
      "two-handed"
    ]
  },
  {
    "id": "hidden_coin_purse",
    "name": "Hidden Coin Purse",
    "description": "A small, discreet coin purse designed to be easily concealed within clothing.",
    "item_type": "container",
    "rarity": "common",
    "weight": 0.1,
    "value": 15,
    "custom_properties": {
      "capacity_coins": 100,
      "concealment_bonus": 2
    },
    "tags": [
      "container",
      "stealth",
      "currency"
    ]
  },
  {
    "id": "hunting_knife",
    "name": "Hunting Knife",
    "description": "A sturdy knife, useful for skinning game, preparing food, or as a last resort weapon.",
    "item_type": "weapon",
    "rarity": "common",
    "weight": 0.4,
    "value": 30,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "stats": [],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d4-1"
      }
    ],
    "durability": 80,
    "tags": [
      "weapon",
      "knife",
      "tool",
      "survival"
    ]
  },
  {
    "id": "journal",
    "name": "Journal",
    "description": "A blank, sturdy journal and a charcoal pencil for recording observations and notes.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.5,
    "value": 10,
    "tags": [
      "tool",
      "writing",
      "notes"
    ]
  },
  {
    "id": "assistant_robes",
    "name": "Library Assistant Robes",
    "description": "Simple, yet well-made robes worn by assistants at the Shifting Library. They offer minor protection against ambient magical energies.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.2,
    "value": 30,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "magic_resistance_minor",
        "value": 2,
        "display_name": "Minor Magic Resist",
        "is_percentage": true
      }
    ],
    "durability": 50,
    "tags": [
      "clothing",
      "armor",
      "shifting_library",
      "assistant"
    ]
  },
  {
    "id": "library_authorization",
    "name": "Library Authorization",
    "description": "A crystalline token that grants access to common areas and basic resources within the Shifting Library.",
    "item_type": "key",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "key",
      "shifting_library",
      "authorization"
    ]
  },
  {
    "id": "living_garments",
    "name": "Living Garments",
    "description": "Clothing woven from living plant fibers that subtly adapt to the wearer and environment. A hallmark of Mycora design.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 300,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 2,
        "display_name": "Armor"
      },
      {
        "name": "environmental_adaptation",
        "value": 1,
        "display_name": "Environmental Adaptation"
      }
    ],
    "durability": 80,
    "tags": [
      "clothing",
      "armor",
      "mycora",
      "living",
      "adaptive"
    ]
  },
  {
    "id": "bread",
    "name": "Loaf of Bread",
    "template_id": "template_food_bread",
    "description": "A simple loaf of bread that provides sustenance.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 0.5,
    "value": 5,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 5,
    "stats": [
      {
        "name": "hunger_restore",
        "value": 15
      },
      {
        "name": "healing",
        "value": 5
      }
    ],
    "tags": [
      "food",
      "consumable"
    ]
  },
  {
    "id": "lucky_coin",
    "name": "Lucky Coin",
    "description": "A mundane coin that its owner believes brings good fortune. Its true power is likely psychological.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.01,
    "value": 1,
    "stats": [
      {
        "name": "luck_subtle",
        "value": 0.1,
        "display_name": "Subtle Luck (Placebo)"
      }
    ],
    "tags": [
      "coin",
      "trinket",
      "luck",
      "sentimental"
    ]
  },
  {
    "id": "lunch_bundle",
    "name": "Lunch Bundle",
    "description": "A piece of fruit, some dried meat, and a small waterskin wrapped in cloth.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 0.7,
    "value": 10,
    "is_consumable": true,
    "is_stackable": false,
    "custom_properties": {
      "contains": "fruit, dried_meat, waterskin_1_charge"
    },
    "stats": [
      {
        "name": "hunger_restore",
        "value": 20
      },
      {
        "name": "healing",
        "value": 8
      }
    ],
    "tags": [
      "food",
      "consumable",
      "bundle"
    ]
  },
  {
    "id": "master_crafting_tools",
    "name": "Master Crafting Tools",
    "description": "A comprehensive set of high-quality tools for various crafts, kept in a sturdy leather roll.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 3.0,
    "value": 650,
    "stats": [
      {
        "name": "crafting_general_bonus",
        "value": 1,
        "display_name": "General Crafting Bonus"
      }
    ],
    "tags": [
      "tool",
      "crafting",
      "masterwork"
    ]
  },
  {
    "id": "mercenary_contract",
    "name": "Mercenary Contract",
    "description": "A binding contract detailing the terms of your employment, payment, and objectives for the current assignment.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "quest_item",
      "mercenary"
    ]
  },
  {
    "id": "metal_samples",
    "name": "Metal Samples",
    "description": "Small ingots and pieces of various rare metals and alloys from your clan's mines.",
    "item_type": "material",
    "rarity": "uncommon",
    "weight": 2.0,
    "value": 400,
    "is_stackable": true,
    "stack_limit": 10,
    "tags": [
      "material",
      "metal",
      "dwarven",
      "trade_good",
      "crafting"
    ]
  },
  {
    "id": "multi-planar_currency",
    "name": "Multi-Planar Currency Pouch",
    "description": "A pouch containing a mix of currencies from various planes, useful for interplanar trade.",
    "item_type": "treasure",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 1000,
    "custom_properties": {
      "contents_description": "Mixed coins from Nexus, Verdant, Ashen, Crystalline, Tempest planes"
    },
    "tags": [
      "currency",
      "treasure",
      "planar",
      "trade_good"
    ]
  },
  {
    "id": "multidimensional_mapping_tools",
    "name": "Multidimensional Mapping Tools",
    "description": "A set of specialized tools for charting and navigating spaces with non-Euclidean or shifting geometries.",
    "item_type": "tool",
    "rarity": "epic",
    "weight": 1.5,
    "value": 1200,
    "tags": [
      "tool",
      "prismal",
      "mapping",
      "planar",
      "dimensional"
    ]
  },
  {
    "id": "notebook",
    "name": "Notebook",
    "description": "A well-made notebook for recording thoughts, observations, or calculations.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.4,
    "value": 8,
    "tags": [
      "tool",
      "writing",
      "notes"
    ]
  },
  {
    "id": "old_map",
    "name": "Old Map",
    "description": "A hand-drawn map given to you by a mysterious traveler, showing unfamiliar lands and cryptic symbols.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "map",
      "quest_item",
      "adventure"
    ]
  },
  {
    "id": "ornate_dagger",
    "name": "Ornate Dagger",
    "description": "A finely crafted dagger, more decorative than practical, but still sharp. A reminder of a wealthier past.",
    "item_type": "weapon",
    "rarity": "uncommon",
    "weight": 0.6,
    "value": 100,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "stats": [],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d4"
      }
    ],
    "durability": 60,
    "tags": [
      "weapon",
      "dagger",
      "ornate",
      "noble"
    ]
  },
  {
    "id": "partial_armor_set",
    "name": "Partial Plate Armor",
    "description": "A mismatched set of plate armor pieces, offering good protection for vital areas. Likely scavenged or repaired.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 18.0,
    "value": 300,
    "is_equippable": true,
    "equip_slots": [
      "chest",
      "shoulders"
    ],
    "stats": [
      {
        "name": "armor",
        "value": 10,
        "display_name": "Armor"
      }
    ],
    "durability": 140,
    "tags": [
      "armor",
      "plate",
      "heavy",
      "mismatched"
    ]
  },
  {
    "id": "partially_empty_memory_vial",
    "name": "Partially Empty Memory Vial",
    "description": "A crystal vial, cool to the touch, containing a swirling, faintly luminous mist. It feels like a part of you is missing when you hold it.",
    "item_type": "miscellaneous",
    "rarity": "rare",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "custom_properties": {
      "content": "fragmented_player_memories"
    },
    "tags": [
      "vial",
      "quest_item",
      "memory",
      "ghost_market",
      "ethereal"
    ]
  },
  {
    "id": "pilgrimage_map",
    "name": "Pilgrimage Map",
    "description": "A map charted on fire-resistant hide, marking known sacred flame sites across various planes.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "map",
      "cinderspawn",
      "pilgrimage",
      "quest_item"
    ]
  },
  {
    "id": "planar_map",
    "name": "Planar Map Fragment",
    "description": "A piece of an old map showing routes between Nexus and other, stranger planes. Some markings are unfamiliar.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 50,
    "tags": [
      "document",
      "map",
      "planar",
      "navigation"
    ]
  },
  {
    "id": "planar_protection_amulet",
    "name": "Planar Protection Amulet",
    "description": "An amulet issued to those venturing into unstable planar regions, offering some resistance to harmful energies.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 280,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "planar_hazard_resistance",
        "value": 10,
        "display_name": "Planar Hazard Resist",
        "is_percentage": true
      }
    ],
    "tags": [
      "amulet",
      "accessory",
      "protection",
      "planar"
    ]
  },
  {
    "id": "planar_protection_suit",
    "name": "Planar Protection Suit",
    "description": "A specialized suit designed to offer protection against moderate levels of hazardous planar energies and environmental effects.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 5.0,
    "value": 400,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 3,
        "display_name": "Armor"
      },
      {
        "name": "planar_damage_resistance",
        "value": 10,
        "display_name": "Planar Damage Resist",
        "is_percentage": true
      }
    ],
    "durability": 120,
    "tags": [
      "armor",
      "protection",
      "planar",
      "research"
    ]
  },
  {
    "id": "portable_writing_desk",
    "name": "Portable Writing Desk",
    "description": "A small, foldable desk with compartments for ink, quills, and paper.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 3.0,
    "value": 90,
    "tags": [
      "tool",
      "writing",
      "academic",
      "portable"
    ]
  },
  {
    "id": "precision_measuring_tools",
    "name": "Precision Measuring Tools",
    "description": "A set of fine calipers, rulers, and levels for accurate measurement in research.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 1.0,
    "value": 55,
    "tags": [
      "tool",
      "research",
      "measurement"
    ]
  },
  {
    "id": "precision_tools",
    "name": "Precision Tools",
    "description": "A kit of fine tools for delicate work, often used by Consortium artisans and researchers.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.7,
    "value": 75,
    "stats": [
      {
        "name": "crafting_fine_bonus",
        "value": 1,
        "display_name": "Fine Crafting Bonus"
      }
    ],
    "tags": [
      "tool",
      "crafting",
      "research",
      "crystalline_consortium"
    ]
  },
  {
    "id": "preserved_provisions",
    "name": "Preserved Elven Provisions",
    "description": "Lightweight, nutrient-rich food prepared using elven preservation techniques. Lasts for a long time.",
    "item_type": "consumable",
    "rarity": "uncommon",
    "weight": 1.0,
    "value": 50,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "custom_properties": {
      "days_of_sustenance_efficient": 5
    },
    "stats": [
      {
        "name": "hunger_restore_efficient",
        "value": 25
      }
    ],
    "tags": [
      "food",
      "consumable",
      "elven",
      "survival",
      "preserved"
    ]
  },
  {
    "id": "probability_dice",
    "name": "Probability Dice",
    "description": "A set of strangely weighted dice that seem to favor certain outcomes. Used by Tempest Flotilla gamblers.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 300,
    "custom_properties": {
      "luck_influence": "minor_positive_bias"
    },
    "tags": [
      "tool",
      "gambling",
      "tempest_flotilla",
      "chance"
    ]
  },
  {
    "id": "protection_talisman",
    "name": "Protection Talisman (Mercenary)",
    "description": "A rugged talisman, often carried by mercenaries, said to ward off ill luck and minor curses.",
    "item_type": "accessory",
    "rarity": "common",
    "weight": 0.2,
    "value": 80,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "save_bonus_minor_curses",
        "value": 1,
        "display_name": "Curse Resist (Minor)"
      }
    ],
    "tags": [
      "talisman",
      "accessory",
      "protection",
      "luck"
    ]
  },
  {
    "id": "protective_charm",
    "name": "Protective Charm (Anti-Ethereal)",
    "description": "A small charm said to offer minor protection against ethereal entities and influences from The Between.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 220,
    "is_equippable": true,
    "equip_slots": [
      "trinket_1",
      "trinket_2"
    ],
    "stats": [
      {
        "name": "ethereal_resistance",
        "value": 5,
        "display_name": "Ethereal Resistance",
        "is_percentage": true
      }
    ],
    "tags": [
      "charm",
      "accessory",
      "protection",
      "ethereal",
      "ghost_market"
    ]
  },
  {
    "id": "rations_pack",
    "name": "Rations Pack (3 Days)",
    "description": "A pack containing enough preserved food and water for three days of travel.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 2.0,
    "value": 25,
    "is_consumable": true,
    "is_stackable": false,
    "custom_properties": {
      "days_of_sustenance": 3
    },
    "stats": [
      {
        "name": "hunger_restore_full_day",
        "value": 3
      }
    ],
    "tags": [
      "food",
      "consumable",
      "survival",
      "rations"
    ]
  },
  {
    "id": "reality_anchor",
    "name": "Reality Anchor (Personal)",
    "description": "A device that creates a small field of stabilized reality, offering protection against minor spatial distortions.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 1.2,
    "value": 700,
    "custom_properties": {
      "field_radius_meters": 1,
      "stability_rating": 3
    },
    "tags": [
      "tool",
      "planar",
      "protection",
      "research"
    ]
  },
  {
    "id": "recording_crystal",
    "name": "Recording Crystal",
    "description": "A crystal that passively records ambient sounds and subtle planar energies. Glows faintly when active.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 250,
    "custom_properties": {
      "storage_capacity_hours": 24,
      "sensitivity": "medium"
    },
    "tags": [
      "tool",
      "research",
      "planar",
      "crystal",
      "recording"
    ]
  },
  {
    "id": "research_notes",
    "name": "Research Notes",
    "description": "A collection of notes, theories, and references related to your current field of study.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.8,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "notes",
      "research",
      "academic"
    ]
  },
  {
    "id": "researcher_equipment",
    "name": "Researcher's Field Kit",
    "description": "A collection of tools for field research: sample bags, measuring devices, a multi-tool, and basic first aid.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 2.5,
    "value": 80,
    "custom_properties": {
      "contents_summary": "sample_bags, measuring_tape, multi_tool, first_aid_basics"
    },
    "tags": [
      "tool",
      "research",
      "kit",
      "field_work"
    ]
  },
  {
    "id": "resonance_amulet",
    "name": "Resonance Amulet",
    "description": "An amulet that hums faintly, designed to help stabilize its wearer during minor Resonance Events.",
    "item_type": "accessory",
    "rarity": "common",
    "weight": 0.1,
    "value": 100,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "resonance_stability",
        "value": 5,
        "display_name": "Resonance Stability"
      }
    ],
    "tags": [
      "amulet",
      "harmonia",
      "planar",
      "protection"
    ]
  },
  {
    "id": "resonance_detector",
    "name": "Resonance Detector",
    "description": "A device that hums and glows in the presence of planar resonance or magical energies.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.7,
    "value": 350,
    "stats": [
      {
        "name": "perception_magic",
        "value": 2,
        "display_name": "Magic Perception"
      }
    ],
    "tags": [
      "tool",
      "magic_detection",
      "planar",
      "research"
    ]
  },
  {
    "id": "resonance_journal",
    "name": "Resonance Journal",
    "description": "A journal specifically designed to record observations of planar resonance and magical phenomena.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.6,
    "value": 80,
    "tags": [
      "tool",
      "writing",
      "research",
      "planar",
      "magic"
    ]
  },
  {
    "id": "ritual_dagger",
    "name": "Ritual Dagger",
    "description": "A ceremonial dagger, sharp and well-balanced, used by the Ashen Covenant in their rites. It feels strangely warm to the touch.",
    "item_type": "weapon",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 75,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "stats": [
      {
        "name": "melee_attack",
        "value": 1,
        "display_name": "Attack Bonus"
      }
    ],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d6",
        "description": "Base weapon damage"
      }
    ],
    "durability": 70,
    "tags": [
      "weapon",
      "dagger",
      "ritual",
      "ashen_covenant"
    ]
  },
  {
    "id": "ritual_igniter",
    "name": "Ritual Igniter",
    "description": "A Cinderspawn tool that can create a spark of intense, spiritually attuned flame, used to light sacred fires.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.3,
    "value": 350,
    "custom_properties": {
      "uses_per_day": 3,
      "flame_purity": "high"
    },
    "tags": [
      "tool",
      "cinderspawn",
      "fire",
      "ritual"
    ]
  },
  {
    "id": "sample_case_of_goods",
    "name": "Sample Case of Goods",
    "description": "A sturdy case containing a curated selection of exotic goods for showcasing to potential buyers.",
    "item_type": "container",
    "rarity": "common",
    "weight": 3.0,
    "value": 50,
    "custom_properties": {
      "max_item_showcase": 10,
      "security_level": "basic"
    },
    "tags": [
      "container",
      "trade",
      "sample_case"
    ]
  },
  {
    "id": "sealed_letter_of_introduction",
    "name": "Sealed Letter of Introduction",
    "description": "A letter addressed to an influential figure, sealed with an unbroken noble crest.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "letter",
      "quest_item",
      "introduction"
    ]
  },
  {
    "id": "sealed_message",
    "name": "Sealed Message",
    "description": "A message scroll sealed with an unfamiliar sigil. Its contents are unknown.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "message",
      "quest_item",
      "sealed"
    ]
  },
  {
    "id": "sealed_orders",
    "name": "Sealed Orders",
    "description": "Official military orders, sealed with the mark of a high-ranking Harmonic Guard officer.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "orders",
      "quest_item",
      "military"
    ]
  },
  {
    "id": "seed_vault",
    "name": "Seed Vault",
    "description": "A specially prepared container holding a diverse collection of rare and adaptable seeds from the Verdant plane.",
    "item_type": "container",
    "rarity": "rare",
    "weight": 1.0,
    "value": 500,
    "custom_properties": {
      "preservation_field_active": true,
      "seed_variety_count": 50
    },
    "tags": [
      "container",
      "seeds",
      "mycora",
      "verdant_plane",
      "preservation"
    ]
  },
  {
    "id": "simple_clothing",
    "name": "Simple Clothing",
    "description": "Basic, practical clothing suitable for everyday wear in Harmonia.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.5,
    "value": 10,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 60,
    "tags": [
      "clothing",
      "armor",
      "commoner"
    ]
  },
  {
    "id": "simple_tool",
    "name": "Simple Tool",
    "description": "A basic tool related to your former trade (e.g., a hammer, a lute, a farming hoe).",
    "item_type": "tool",
    "rarity": "common",
    "weight": 1.0,
    "value": 8,
    "custom_properties": {
      "tool_type": "generic_trade_tool"
    },
    "tags": [
      "tool",
      "commoner",
      "trade_tool"
    ]
  },
  {
    "id": "small_pouch_of_ancestral_ash",
    "name": "Small Pouch of Ancestral Ash",
    "description": "A leather pouch containing a mixture of sacred ashes from revered ancestors of the Ashen Covenant. Used in rituals and for guidance.",
    "item_type": "miscellaneous",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 50,
    "is_equippable": false,
    "is_consumable": false,
    "is_stackable": false,
    "is_quest_item": true,
    "tags": [
      "ritual_component",
      "ashen_covenant",
      "spiritual",
      "ash"
    ]
  },
  {
    "id": "small_pouch_of_seeds",
    "name": "Small Pouch of Seeds",
    "description": "A collection of various seeds from your homeland, perhaps for trade or study.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.2,
    "value": 20,
    "is_stackable": true,
    "stack_limit": 50,
    "tags": [
      "seeds",
      "nature",
      "trade_good"
    ]
  },
  {
    "id": "small_purse_of_coins",
    "name": "Small Purse of Coins",
    "description": "A leather purse containing a modest amount of mixed currency.",
    "item_type": "treasure",
    "rarity": "common",
    "weight": 0.3,
    "value": 500,
    "is_stackable": false,
    "custom_properties": {
      "contains_copper": 500
    },
    "tags": [
      "currency",
      "container",
      "treasure"
    ]
  },
  {
    "id": "small_tent",
    "name": "Small Tent",
    "description": "A one-person tent, lightweight and easy to set up, providing shelter from the elements.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 2.5,
    "value": 60,
    "custom_properties": {
      "capacity": 1,
      "shelter_rating": 5
    },
    "tags": [
      "tool",
      "shelter",
      "camping",
      "survival"
    ]
  },
  {
    "id": "small_trading_goods",
    "name": "Small Trading Goods",
    "description": "A small bundle of assorted goods suitable for minor trades, like spices, trinkets, or common tools.",
    "item_type": "treasure",
    "rarity": "common",
    "weight": 1.0,
    "value": 100,
    "is_stackable": false,
    "tags": [
      "trade_good",
      "bundle",
      "miscellaneous"
    ]
  },
  {
    "id": "specimen_containers",
    "name": "Specimen Containers",
    "description": "A set of reinforced, sealable containers for collecting and preserving biological or energetic samples.",
    "item_type": "container",
    "rarity": "common",
    "weight": 1.0,
    "value": 30,
    "custom_properties": {
      "capacity_units": 10,
      "preservation_level": "medium"
    },
    "tags": [
      "container",
      "research",
      "sample_collection"
    ]
  },
  {
    "id": "spore_collection_kit",
    "name": "Spore Collection Kit",
    "description": "Tools for safely collecting, identifying, and preserving various types of fungal spores.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.6,
    "value": 90,
    "tags": [
      "tool",
      "mycora",
      "research",
      "spores",
      "collection"
    ]
  },
  {
    "id": "standard_issue_weapon",
    "name": "Standard Issue Guard Sword",
    "description": "A durable, well-maintained sword, the standard armament for Harmonic Guard soldiers.",
    "item_type": "weapon",
    "rarity": "common",
    "weight": 3.0,
    "value": 180,
    "is_equippable": true,
    "equip_slots": [
      "main_hand"
    ],
    "dice_roll_effects": [
      {
        "effect_type": "slashing",
        "dice_notation": "1d6"
      }
    ],
    "durability": 110,
    "tags": [
      "weapon",
      "sword",
      "harmonic_guard",
      "standard_issue"
    ]
  },
  {
    "id": "stolen_supplies",
    "name": "Stolen Supplies",
    "description": "A small sack containing pilfered food, water, and a few useful tools. Clearly not acquired legitimately.",
    "item_type": "container",
    "rarity": "common",
    "weight": 3.0,
    "value": -50,
    "custom_properties": {
      "contents": "food_1day, water_1day, lockpicks_basic"
    },
    "tags": [
      "container",
      "stolen",
      "survival"
    ]
  },
  {
    "id": "storm_compass",
    "name": "Storm Compass",
    "description": "A compass that points towards the strongest nearby atmospheric or planar disturbance, rather than magnetic north.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.4,
    "value": 500,
    "tags": [
      "tool",
      "navigation",
      "tempest_flotilla",
      "planar"
    ]
  },
  {
    "id": "storm_tattoo_kit",
    "name": "Storm Tattoo Kit (Maelstri)",
    "description": "A Maelstri kit containing inks made from condensed storm essence and needles carved from lightning-struck wood. Used to create tattoos that channel tempestuous energies.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.4,
    "value": 600,
    "tags": [
      "tool",
      "maelstri",
      "tattoo",
      "storm_magic",
      "artisan"
    ]
  },
  {
    "id": "strange_contract",
    "name": "Strange Contract",
    "description": "A rolled parchment tied with an ethereal ribbon. The script within is unsettling and shifts when not directly observed. It details a bargain made with an entity from The Between.",
    "item_type": "document",
    "rarity": "rare",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "quest_item",
      "ghost_market",
      "ethereal"
    ]
  },
  {
    "id": "sturdy_work_clothes",
    "name": "Sturdy Work Clothes",
    "description": "Durable and practical clothes, patched in places but clean. Suited for manual labor or travel.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 2.0,
    "value": 15,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 70,
    "tags": [
      "clothing",
      "armor",
      "commoner",
      "workwear"
    ]
  },
  {
    "id": "survival_kit",
    "name": "Survival Kit",
    "description": "A compact kit containing essentials for survival in the wilderness: tinder, fishing line, a small knife, bandages.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 1.5,
    "value": 50,
    "custom_properties": {
      "contents_summary": "tinder, fishing_line, small_knife, bandages"
    },
    "tags": [
      "tool",
      "survival",
      "kit"
    ]
  },
  {
    "id": "symbiotic_communication_pod",
    "name": "Symbiotic Communication Pod",
    "description": "A living fungal pod that allows limited telepathic communication with the Mycora collective consciousness when attuned.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.3,
    "value": 700,
    "custom_properties": {
      "range_km": 10,
      "attunement_required": "Mycora_or_symbiote"
    },
    "tags": [
      "tool",
      "mycora",
      "communication",
      "telepathy",
      "symbiotic"
    ]
  },
  {
    "id": "temporal_compass",
    "name": "Temporal Compass (Maelstri)",
    "description": "A Maelstri compass that doesn't point north, but rather towards areas of significant temporal distortion or probability flux.",
    "item_type": "tool",
    "rarity": "epic",
    "weight": 0.5,
    "value": 1500,
    "tags": [
      "tool",
      "maelstri",
      "navigation",
      "temporal",
      "probability",
      "planar"
    ]
  },
  {
    "id": "test_apple",
    "name": "Test apple",
    "description": "A test apple.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.1,
    "value": 1,
    "is_equippable": false,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 20,
    "tags": [
      "miscellaneous",
      "consumable",
      "food"
    ]
  },
  {
    "id": "trading_ledger",
    "name": "Trading Ledger",
    "description": "A well-used ledger filled with notes on prices, contacts, and trade routes across various planes.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.7,
    "value": 25,
    "tags": [
      "tool",
      "trade",
      "ledger",
      "notes"
    ]
  },
  {
    "id": "translator's_guidebook",
    "name": "Translator's Guidebook (Verdant)",
    "description": "A guidebook containing common phrases, customs, and notes on the plant-based communication of the Verdant Collective.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.3,
    "value": 40,
    "stats": [
      {
        "name": "language_comprehension_verdant",
        "value": 1,
        "display_name": "Verdant Language Comprehension"
      }
    ],
    "tags": [
      "book",
      "tool",
      "language",
      "translation",
      "verdant_collective"
    ]
  },
  {
    "id": "treaty_drafts",
    "name": "Treaty Drafts",
    "description": "Drafts of proposed treaties and agreements, with various clauses and options for negotiation.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.5,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "treaty",
      "diplomacy",
      "negotiation",
      "quest_item"
    ]
  },
  {
    "id": "wanted_poster",
    "name": "Wanted Poster",
    "description": "A weathered wanted poster bearing a crude likeness of someone... perhaps you?",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "wanted",
      "quest_item"
    ]
  },
  {
    "id": "water_flask",
    "name": "Water Flask",
    "description": "A sturdy flask filled with fresh water.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 1.0,
    "value": 2,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "stats": [
      {
        "name": "thirst_quench",
        "value": 20
      }
    ],
    "custom_properties": {
      "charges": 3,
      "refillable": true
    },
    "tags": [
      "drink",
      "consumable",
      "survival"
    ]
  },
  {
    "id": "weather_prediction_dice",
    "name": "Weather Prediction Dice (Maelstri)",
    "description": "A set of dice that, when thrown by a Maelstri, offer glimpses into short-term weather patterns and probability currents.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 450,
    "custom_properties": {
      "prediction_accuracy": "moderate",
      "range_hours": 6
    },
    "tags": [
      "tool",
      "maelstri",
      "divination",
      "weather",
      "probability"
    ]
  },
  {
    "id": "weather-resistant_clothing",
    "name": "Weather-Resistant Clothing",
    "description": "Clothing treated to repel water and wind, suitable for unpredictable weather.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 2.2,
    "value": 45,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "elemental_resistance_minor",
        "value": 3,
        "display_name": "Minor Elemental Resist",
        "is_percentage": true
      }
    ],
    "durability": 90,
    "tags": [
      "clothing",
      "armor",
      "protection",
      "weather"
    ]
  },
  {
    "id": "worn_disguise",
    "name": "Worn Disguise",
    "description": "A set of commoner's clothes, a hooded cloak, and some makeup, used to alter one's appearance.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.5,
    "value": 20,
    "is_equippable": true,
    "equip_slots": [
      "chest",
      "head"
    ],
    "custom_properties": {
      "disguise_effectiveness": "moderate"
    },
    "stats": [
      {
        "name": "stealth_bonus_urban",
        "value": 2,
        "display_name": "Urban Stealth"
      }
    ],
    "durability": 40,
    "tags": [
      "clothing",
      "armor",
      "disguise",
      "stealth"
    ]
  }
]
```

### File: config\character\backgrounds.json

```json
{
    "backgrounds": {
      "Noble": {
        "id": "Noble",
        "name": "Noble",
        "description": "Born into privilege, you are accustomed to high society, politics, and perhaps a bit of intrigue.",
        "starting_skills": ["Persuasion", "History"],
        "starting_items": ["Fine Clothes", "Signet Ring", "50 Gold"],
        "stat_modifiers": {"CHA": 1}
      },
      "Commoner": {
        "id": "Commoner",
        "name": "Commoner",
        "description": "You grew up among the ordinary folk, learning a trade or working the land. You are resilient and practical.",
        "starting_skills": ["Endurance", "Crafting (Basic)"],
        "starting_items": ["Simple Clothes", "Basic Tool", "10 Gold"],
        "stat_modifiers": {"CON": 1}
      },
      "Scholar": {
        "id": "Scholar",
        "name": "Scholar",
        "description": "You spent years studying lore, history, or the arcane. Knowledge is your greatest asset.",
        "starting_skills": ["Lore", "Investigation"],
        "starting_items": ["Scholar's Robes", "Book", "Ink & Quill", "20 Gold"],
        "stat_modifiers": {"INT": 1}
      },
      "Soldier": {
        "id": "Soldier",
        "name": "Soldier",
        "description": "You have seen battle, whether in an army, militia, or mercenary company. You understand discipline and combat.",
        "starting_skills": ["Athletics", "Intimidation"],
        "starting_items": ["Worn Uniform/Armor", "Token of Service", "Simple Weapon", "15 Gold"],
        "stat_modifiers": {"STR": 1}
      },
      "Outlaw": {
        "id": "Outlaw",
        "name": "Outlaw",
        "description": "You have lived outside the law, relying on your wits, stealth, or force to survive.",
        "starting_skills": ["Stealth", "Deception"],
        "starting_items": ["Dark Cloak", "Lockpicks", "Dagger", "25 Gold"],
        "stat_modifiers": {"DEX": 1}
      }
    }
  }
  
```

### File: config\character\classes.json

```json
{
  "classes": {
    "Warrior": {
      "id": "Warrior",
      "name": "Warrior",
      "description": "Masters of martial combat, warriors excel in physical strength and durability.",
      "stat_modifiers": {
        "STR": 2,
        "DEX": 0,
        "CON": 2,
        "INT": -1,
        "WIS": 0,
        "CHA": 0,
        "WIL": 2,
        "INS": -1
      },
      "minimum_stats": {
        "STR": 11,
        "CON": 10
      },
      "recommended_stats": {
        "primary": [
          "STR",
          "CON",
          "WIL"
        ],
        "secondary": [
          "DEX"
        ],
        "tertiary": [
          "WIS",
          "CHA",
          "INT",
          "INS"
        ]
      },
      "archetypes": {
        "Balanced": {
          "name": "Balanced",
          "description": "A well-rounded warrior effective in most situations",
          "stat_distribution": {
            "STR": 14,
            "DEX": 12,
            "CON": 14,
            "INT": 8,
            "WIS": 10,
            "CHA": 10
          }
        },
        "Offensive": {
          "name": "Offensive",
          "description": "A warrior focused on dealing maximum damage",
          "stat_distribution": {
            "STR": 16,
            "DEX": 12,
            "CON": 12,
            "INT": 8,
            "WIS": 8,
            "CHA": 10
          }
        },
        "Defensive": {
          "name": "Defensive",
          "description": "A warrior specialized in taking hits and protecting allies",
          "stat_distribution": {
            "STR": 12,
            "DEX": 10,
            "CON": 16,
            "INT": 8,
            "WIS": 12,
            "CHA": 8
          }
        }
      },
      "weapon_proficiencies": [
        "swords",
        "axes",
        "maces",
        "polearms",
        "shields"
      ],
      "armor_proficiencies": [
        "light",
        "medium",
        "heavy",
        "shields"
      ]
    },
    "Mage": {
      "id": "Mage",
      "name": "Mage",
      "description": "Scholars of the arcane, mages command powerful spells and magical knowledge.",
      "stat_modifiers": {
        "STR": -1,
        "DEX": 0,
        "CON": -1,
        "INT": 3,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 2
      },
      "minimum_stats": {
        "INT": 12
      },
      "recommended_stats": {
        "primary": [
          "INT",
          "INS"
        ],
        "secondary": [
          "WIS",
          "CON",
          "WIL"
        ],
        "tertiary": [
          "DEX",
          "CHA",
          "STR"
        ]
      },
      "archetypes": {
        "Elementalist": {
          "name": "Elementalist",
          "description": "A mage focused on elemental damage spells",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 10,
            "INT": 16,
            "WIS": 12,
            "CHA": 10
          }
        },
        "Enchanter": {
          "name": "Enchanter",
          "description": "A mage specialized in controlling minds and enhancing items",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 8,
            "INT": 14,
            "WIS": 12,
            "CHA": 14
          }
        },
        "Scholar": {
          "name": "Scholar",
          "description": "A mage with broad magical knowledge and versatile spellcasting",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 10,
            "INT": 16,
            "WIS": 14,
            "CHA": 8
          }
        }
      },
      "weapon_proficiencies": [
        "daggers",
        "staves",
        "wands"
      ],
      "armor_proficiencies": [
        "none"
      ]
    },
    "Rogue": {
      "id": "Rogue",
      "name": "Rogue",
      "description": "Masters of stealth and trickery, rogues excel in dexterity and cunning.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 3,
        "CON": 0,
        "INT": 1,
        "WIS": 0,
        "CHA": 1,
        "WIL": 0,
        "INS": 2
      },
      "minimum_stats": {
        "DEX": 12
      },
      "recommended_stats": {
        "primary": [
          "DEX",
          "INS"
        ],
        "secondary": [
          "INT",
          "CHA"
        ],
        "tertiary": [
          "CON",
          "WIS",
          "STR",
          "WIL"
        ]
      },
      "archetypes": {
        "Thief": {
          "name": "Thief",
          "description": "A rogue specialized in stealing and evading detection",
          "stat_distribution": {
            "STR": 8,
            "DEX": 16,
            "CON": 10,
            "INT": 12,
            "WIS": 10,
            "CHA": 10
          }
        },
        "Assassin": {
          "name": "Assassin",
          "description": "A rogue focused on dealing high damage from stealth",
          "stat_distribution": {
            "STR": 10,
            "DEX": 16,
            "CON": 10,
            "INT": 12,
            "WIS": 12,
            "CHA": 8
          }
        },
        "Bard": {
          "name": "Bard",
          "description": "A charming rogue with persuasive abilities",
          "stat_distribution": {
            "STR": 8,
            "DEX": 14,
            "CON": 10,
            "INT": 10,
            "WIS": 8,
            "CHA": 16
          }
        }
      },
      "weapon_proficiencies": [
        "daggers",
        "short swords",
        "bows",
        "crossbows"
      ],
      "armor_proficiencies": [
        "light"
      ]
    },
    "Cleric": {
      "id": "Cleric",
      "name": "Cleric",
      "description": "Divine agents who channel the power of their deity to heal and protect.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 0,
        "CON": 1,
        "INT": 0,
        "WIS": 3,
        "CHA": 1,
        "WIL": 2,
        "INS": 1
      },
      "minimum_stats": {
        "WIS": 12
      },
      "recommended_stats": {
        "primary": [
          "WIS",
          "WIL"
        ],
        "secondary": [
          "CON",
          "CHA",
          "INS"
        ],
        "tertiary": [
          "STR",
          "DEX",
          "INT"
        ]
      },
      "archetypes": {
        "Healer": {
          "name": "Healer",
          "description": "A cleric focused on healing and restoration",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 12,
            "INT": 8,
            "WIS": 16,
            "CHA": 12
          }
        },
        "Crusader": {
          "name": "Crusader",
          "description": "A battle cleric with combat and healing abilities",
          "stat_distribution": {
            "STR": 12,
            "DEX": 8,
            "CON": 12,
            "INT": 8,
            "WIS": 16,
            "CHA": 10
          }
        },
        "Oracle": {
          "name": "Oracle",
          "description": "A cleric with foresight and powerful divine magic",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 10,
            "INT": 12,
            "WIS": 16,
            "CHA": 10
          }
        }
      },
      "weapon_proficiencies": [
        "maces",
        "hammers",
        "staves"
      ],
      "armor_proficiencies": [
        "light",
        "medium",
        "shields"
      ]
    },
    "Ranger": {
      "id": "Ranger",
      "name": "Ranger",
      "description": "Wilderness experts who combine combat prowess with natural knowledge.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": 2,
        "CON": 1,
        "INT": 0,
        "WIS": 2,
        "CHA": -1,
        "WIL": 1,
        "INS": 2
      },
      "minimum_stats": {
        "DEX": 11,
        "WIS": 11
      },
      "recommended_stats": {
        "primary": [
          "DEX",
          "WIS",
          "INS"
        ],
        "secondary": [
          "STR",
          "CON",
          "WIL"
        ],
        "tertiary": [
          "INT",
          "CHA"
        ]
      },
      "archetypes": {
        "Hunter": {
          "name": "Hunter",
          "description": "A ranger specialized in tracking and hunting prey",
          "stat_distribution": {
            "STR": 10,
            "DEX": 16,
            "CON": 10,
            "INT": 8,
            "WIS": 14,
            "CHA": 8
          }
        },
        "Beastmaster": {
          "name": "Beastmaster",
          "description": "A ranger with a powerful animal companion",
          "stat_distribution": {
            "STR": 10,
            "DEX": 14,
            "CON": 12,
            "INT": 8,
            "WIS": 14,
            "CHA": 10
          }
        },
        "Scout": {
          "name": "Scout",
          "description": "A wilderness expert with stealth and survival skills",
          "stat_distribution": {
            "STR": 10,
            "DEX": 14,
            "CON": 10,
            "INT": 10,
            "WIS": 14,
            "CHA": 8
          }
        }
      },
      "weapon_proficiencies": [
        "bows",
        "spears",
        "swords",
        "daggers"
      ],
      "armor_proficiencies": [
        "light",
        "medium"
      ]
    },
    "Wanderer": {
      "id": "Wanderer",
      "name": "Wanderer",
      "description": "Masterless adventurers who adapt to various situations with versatile skills.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 1,
        "CON": 1,
        "INT": 1,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 1
      },
      "minimum_stats": {},
      "recommended_stats": {
        "primary": [
          "DEX",
          "WIS",
          "WIL",
          "INS"
        ],
        "secondary": [
          "CON",
          "INT"
        ],
        "tertiary": [
          "STR",
          "CHA"
        ]
      },
      "archetypes": {
        "Jack-of-All-Trades": {
          "name": "Jack-of-All-Trades",
          "description": "A wanderer with balanced skills in many areas",
          "stat_distribution": {
            "STR": 10,
            "DEX": 12,
            "CON": 12,
            "INT": 12,
            "WIS": 12,
            "CHA": 10
          }
        },
        "Survivor": {
          "name": "Survivor",
          "description": "A wanderer focused on endurance and survival skills",
          "stat_distribution": {
            "STR": 10,
            "DEX": 12,
            "CON": 14,
            "INT": 10,
            "WIS": 14,
            "CHA": 8
          }
        },
        "Diplomat": {
          "name": "Diplomat",
          "description": "A wanderer specializing in social interaction and negotiation",
          "stat_distribution": {
            "STR": 8,
            "DEX": 12,
            "CON": 10,
            "INT": 12,
            "WIS": 10,
            "CHA": 14
          }
        }
      },
      "weapon_proficiencies": [
        "simple weapons"
      ],
      "armor_proficiencies": [
        "light"
      ]
    }
  }
}
```

### File: config\character\races.json

```json
{
  "races": {
    "Human": {
      "id": "Human",
      "name": "Human",
      "description": "Versatile and adaptable, humans are known for their diversity and ambition.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": 1,
        "CON": 1,
        "INT": 1,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 1
      },
      "traits": [
        {
          "name": "Adaptability",
          "description": "Humans can adapt to almost any situation. Gain +1 to all saving throws."
        },
        {
          "name": "Quick Learner",
          "description": "Humans gain 10% more experience from all sources."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Mage",
        "Rogue",
        "Cleric",
        "Ranger",
        "Wanderer"
      ]
    },
    "Elf": {
      "id": "Elf",
      "name": "Elf",
      "description": "Ancient and graceful, elves excel in magic and dexterity-based skills.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 2,
        "CON": -1,
        "INT": 2,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 2
      },
      "traits": [
        {
          "name": "Keen Senses",
          "description": "Elves have heightened perception. Gain advantage on perception checks."
        },
        {
          "name": "Magic Affinity",
          "description": "Elves have a natural connection to magic. Spell costs are reduced by 10%."
        }
      ],
      "recommended_classes": [
        "Mage",
        "Ranger",
        "Wanderer"
      ]
    },
    "Dwarf": {
      "id": "Dwarf",
      "name": "Dwarf",
      "description": "Stout and hardy, dwarves are known for their resilience and craftsmanship.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": -1,
        "CON": 3,
        "INT": 0,
        "WIS": 2,
        "CHA": -1,
        "WIL": 3,
        "INS": 0
      },
      "traits": [
        {
          "name": "Dwarven Resilience",
          "description": "Dwarves resist poison and have additional health regeneration."
        },
        {
          "name": "Stonecunning",
          "description": "Dwarves have expertise with stone and metalwork. Advantage on related checks."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Cleric"
      ]
    },
    "Orc": {
      "id": "Orc",
      "name": "Orc",
      "description": "Powerful and fierce, orcs excel in physical combat and intimidation.",
      "stat_modifiers": {
        "STR": 3,
        "DEX": 0,
        "CON": 2,
        "INT": -1,
        "WIS": -1,
        "CHA": -1,
        "WIL": 2,
        "INS": -1
      },
      "traits": [
        {
          "name": "Relentless Endurance",
          "description": "Orcs can push through grievous wounds. Once per day, drop to 1 HP instead of 0."
        },
        {
          "name": "Savage Attacks",
          "description": "Orcs deal additional damage on critical hits."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Ranger"
      ]
    },
    "Halfling": {
      "id": "Halfling",
      "name": "Halfling",
      "description": "Small but nimble, halflings are lucky and naturally stealthy.",
      "stat_modifiers": {
        "STR": -1,
        "DEX": 3,
        "CON": 1,
        "INT": 0,
        "WIS": 1,
        "CHA": 1,
        "WIL": 0,
        "INS": 2
      },
      "traits": [
        {
          "name": "Lucky",
          "description": "Halflings can reroll critical failures once per day."
        },
        {
          "name": "Naturally Stealthy",
          "description": "Halflings gain advantage on stealth checks."
        }
      ],
      "recommended_classes": [
        "Rogue",
        "Wanderer"
      ]
    },
    "Mycora": {
      "id": "Mycora",
      "name": "Mycora",
      "description": "Fungal humanoids from the Verdant plane, Mycora share a communal consciousness and can adapt their bodies to various environments.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 0,
        "CON": 2,
        "INT": 0,
        "WIS": 3,
        "CHA": -1,
        "WIL": 2,
        "INS": 1
      },
      "traits": [
        {
          "name": "Spore Symbiosis",
          "description": "Mycora can release healing spores to regenerate health for themselves and nearby allies once per day."
        },
        {
          "name": "Environmental Adaptation",
          "description": "Mycora can adapt to toxic environments and gain resistance to poison and disease."
        }
      ],
      "recommended_classes": [
        "Cleric",
        "Ranger",
        "Wanderer"
      ]
    },
    "Prismal": {
      "id": "Prismal",
      "name": "Prismal",
      "description": "Crystalline beings from the Crystalline plane with geometric bodies that refract magical energies through their crystalline forms.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": -1,
        "CON": 1,
        "INT": 3,
        "WIS": 1,
        "CHA": -1,
        "WIL": 0,
        "INS": 3
      },
      "traits": [
        {
          "name": "Crystal Resonance",
          "description": "Prismals can focus magical energies, reducing mana costs of spells by 15%."
        },
        {
          "name": "Geometric Insight",
          "description": "Prismals gain advantage on checks involving mathematics, precision, and magical formulas."
        }
      ],
      "recommended_classes": [
        "Mage",
        "Cleric"
      ]
    },
    "Cinderspawn": {
      "id": "Cinderspawn",
      "name": "Cinderspawn",
      "description": "Ash-infused beings from the Ashen plane whose bodies constantly regenerate from inner embers, leaving trails of fine ash behind them.",
      "stat_modifiers": {
        "STR": 2,
        "DEX": 1,
        "CON": 1,
        "INT": -1,
        "WIS": 1,
        "CHA": -2,
        "WIL": 2,
        "INS": 0
      },
      "traits": [
        {
          "name": "Ember Renewal",
          "description": "Cinderspawn regenerate health when near fire and gain resistance to fire damage."
        },
        {
          "name": "Ash Walking",
          "description": "Cinderspawn can temporarily transfer their consciousness to ashes, allowing limited espionage and communication."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Mage",
        "Ranger"
      ]
    },
    "Maelstri": {
      "id": "Maelstri",
      "name": "Maelstri",
      "description": "Storm-touched beings from the Tempest plane with partially translucent bodies that contain swirling internal tempests.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 3,
        "CON": 0,
        "INT": 1,
        "WIS": -1,
        "CHA": 2,
        "WIL": 0,
        "INS": 2
      },
      "traits": [
        {
          "name": "Storm Binding",
          "description": "Maelstri can capture essence of storms in their bodies, granting unpredictable magical abilities once per day."
        },
        {
          "name": "Electric Reflexes",
          "description": "Maelstri have lightning-fast reactions, gaining advantage on initiative rolls and dexterity saving throws."
        }
      ],
      "recommended_classes": [
        "Rogue",
        "Mage",
        "Wanderer"
      ]
    }
  }
}
```

### File: config\character\stats_config.json

```json
{
  "version": "1.0",
  "name": "Character Stats Configuration",
  "description": "Configuration for character statistics and derived values",
  
  "default_stat_value": 10,
  
  "base_strength": 10,
  "base_dexterity": 10,
  "base_constitution": 10,
  "base_intelligence": 10,
  "base_wisdom": 10,
  "base_charisma": 10,
  
  "base_health": 10,
  "hp_per_level": 5,
  
  "base_mana": 5,
  "mana_per_level": 3,
  
  "base_stamina": 10,
  "stamina_per_level": 2,
  
  "base_defense": 10,
  "base_magic_defense": 10,
  "max_dex_mod_to_defense": 5,
  
  "base_carry_capacity": 50,
  "carry_capacity_multiplier": 5,
  
  "base_movement": 30,
  
  "stat_min_value": 3,
  "stat_max_value": 20,
  
  "modifier_thresholds": {
    "1": -5,
    "2": -4,
    "3": -4,
    "4": -3,
    "5": -3,
    "6": -2,
    "7": -2,
    "8": -1,
    "9": -1,
    "10": 0,
    "11": 0,
    "12": 1,
    "13": 1,
    "14": 2,
    "15": 2,
    "16": 3,
    "17": 3,
    "18": 4,
    "19": 4,
    "20": 5
  },
  
  "races": {
    "human": {
      "stat_bonuses": {
        "strength": 1,
        "dexterity": 1,
        "constitution": 1,
        "intelligence": 1,
        "wisdom": 1,
        "charisma": 1
      },
      "abilities": ["versatile", "adaptable"]
    },
    "elf": {
      "stat_bonuses": {
        "dexterity": 2,
        "intelligence": 1,
        "wisdom": 1
      },
      "abilities": ["darkvision", "keen_senses"]
    },
    "dwarf": {
      "stat_bonuses": {
        "constitution": 2,
        "strength": 1,
        "wisdom": 1
      },
      "abilities": ["darkvision", "stonecutting", "poison_resistance"]
    }
  },
  
  "classes": {
    "warrior": {
      "primary_stats": ["strength", "constitution"],
      "hp_bonus": 2,
      "stamina_bonus": 2
    },
    "mage": {
      "primary_stats": ["intelligence", "wisdom"],
      "mp_bonus": 3,
      "magic_attack_bonus": 1
    },
    "rogue": {
      "primary_stats": ["dexterity", "charisma"],
      "initiative_bonus": 2,
      "evasion_bonus": 1
    }
  },
  
  "level_up": {
    "points_per_level": 2,
    "max_points_per_stat": 1
  },
  
  "combat": {
    "critical_hit_threshold": 20,
    "fumble_threshold": 1,
    "base_hit_chance": 65,
    "base_flee_chance": 50
  }
}

```

