# Project Documentation: latest version
Generated on: 2025-10-09 14:16:18

## Project Structure

```
latest version/
├── archiv/
│   └── gui/
│       ├── advanced_config_editor/
│       │   ├── form_views/
│       │   │   ├── __init__.py
│       │   │   ├── items_form.py
│       │   │   ├── paths_form.py
│       │   │   ├── races_form.py
│       │   │   ├── scenarios_form.py
│       │   │   └── world_settings_form.py
│       │   ├── __init__.py
│       │   ├── advanced_config_editor.py
│       │   ├── custom_widgets.py
│       │   ├── entry_editor.py
│       │   ├── schemas.py
│       │   └── versioning.py
│       ├── inventory/
│       │   ├── __init__.py
│       │   ├── detail_panels.py
│       │   ├── equipment_slot_widget.py
│       │   ├── inventory_widget.py
│       │   ├── item_widget.py
│       │   └── utils.py
│       ├── widgets/
│       │   ├── __init__.py
│       │   ├── music_controls.py
│       │   └── widgets-LEGACY-MOVED TO INIT.py
│       ├── __init__.py
│       ├── conversation_widget.py
│       ├── dialogs.py
│       ├── game_engine_runner.py
│       ├── llm_settings_dialog.py
│       ├── log_explorer.py
│       ├── logging_handlers.py
│       ├── main_window.py
│       ├── message_widget.py
│       ├── quest_widgets.py
│       ├── safe_zone_widget.py
│       └── tab_widgets.py
├── archiv_dev/
│   ├── FIXES_APPLIED_2025-09-30.md
│   ├── INVENTORY_EQUIPMENT_REFACTORING_REPORT.md
│   ├── TESTING_INSTRUCTIONS.md
│   ├── VARIANTS_AI_IMPROVEMENTS.md
│   └── items&damage_types.md
├── config/
│   ├── aliases/
│   │   └── entities.json
│   ├── backup/
│   │   ├── skills_skills_20250912_235959.json
│   │   ├── skills_skills_20250913_002318.json
│   │   ├── skills_skills_20250913_002554.json
│   │   ├── skills_skills_20250913_141551.json
│   │   ├── skills_skills_20250913_141748.json
│   │   ├── skills_skills_20250913_180742.json
│   │   ├── skills_skills_20250913_235905.json
│   │   ├── skills_skills_20250914_130547.json
│   │   ├── skills_skills_20250914_131055.json
│   │   ├── skills_skills_20250914_132944.json
│   │   ├── skills_skills_20250919_095109.json
│   │   ├── skills_skills_20250919_131027.json
│   │   ├── skills_skills_20250919_142500.json
│   │   ├── skills_skills_20251006_220742.json
│   │   ├── skills_skills_20251006_225101.json
│   │   └── skills_skills_20251007_222935.json
│   ├── character/
│   │   ├── backup/
│   │   │   ├── classes_20250418_133031.json
│   │   │   ├── classes_20250418_135120.json
│   │   │   ├── classes_20250912_235959.json
│   │   │   ├── classes_20250913_002318.json
│   │   │   ├── classes_20250913_002554.json
│   │   │   ├── classes_20250913_141551.json
│   │   │   ├── classes_20250913_141748.json
│   │   │   ├── classes_20250913_180742.json
│   │   │   ├── classes_20250913_235905.json
│   │   │   ├── classes_20250914_130547.json
│   │   │   ├── classes_20250914_131055.json
│   │   │   ├── classes_20250914_132944.json
│   │   │   ├── classes_20250919_095109.json
│   │   │   ├── classes_20250919_131027.json
│   │   │   ├── classes_20250919_142500.json
│   │   │   ├── classes_20251006_220742.json
│   │   │   ├── classes_20251006_225101.json
│   │   │   ├── classes_20251007_222935.json
│   │   │   ├── races_20250418_131835.json
│   │   │   ├── races_20250418_132122.json
│   │   │   ├── races_20250418_132911.json
│   │   │   ├── races_20250418_135120.json
│   │   │   ├── races_20250912_235959.json
│   │   │   ├── races_20250913_002318.json
│   │   │   ├── races_20250913_002554.json
│   │   │   ├── races_20250913_141551.json
│   │   │   ├── races_20250913_141748.json
│   │   │   ├── races_20250913_180742.json
│   │   │   ├── races_20250913_235905.json
│   │   │   ├── races_20250914_130547.json
│   │   │   ├── races_20250914_131055.json
│   │   │   ├── races_20250914_132944.json
│   │   │   ├── races_20250919_095109.json
│   │   │   ├── races_20250919_131027.json
│   │   │   ├── races_20250919_142500.json
│   │   │   ├── races_20251006_220742.json
│   │   │   ├── races_20251006_225101.json
│   │   │   └── races_20251007_222935.json
│   │   ├── backgrounds.json
│   │   ├── classes.json
│   │   ├── npc_templates.json
│   │   ├── races.json
│   │   ├── stat_registry.json
│   │   └── stats_config.json
│   ├── combat/
│   │   └── combat_config.json
│   ├── game/
│   │   └── base_config.json
│   ├── gameplay/
│   │   ├── calendar.json
│   │   └── canonical_lists.json
│   ├── items/
│   │   ├── backup/
│   │   │   ├── base_armor_items_armor_20250912_235959.json
│   │   │   ├── base_armor_items_armor_20250913_002318.json
│   │   │   ├── base_armor_items_armor_20250913_002554.json
│   │   │   ├── base_armor_items_armor_20250913_141551.json
│   │   │   ├── base_armor_items_armor_20250913_141748.json
│   │   │   ├── base_armor_items_armor_20250913_180742.json
│   │   │   ├── base_armor_items_armor_20250913_235905.json
│   │   │   ├── base_armor_items_armor_20250914_130547.json
│   │   │   ├── base_armor_items_armor_20250914_131055.json
│   │   │   ├── base_armor_items_armor_20250914_132944.json
│   │   │   ├── base_armor_items_armor_20250919_095109.json
│   │   │   ├── base_armor_items_armor_20250919_131027.json
│   │   │   ├── base_armor_items_armor_20250919_142500.json
│   │   │   ├── base_armor_items_armor_20251006_220742.json
│   │   │   ├── base_armor_items_armor_20251006_225101.json
│   │   │   ├── base_armor_items_armor_20251007_222935.json
│   │   │   ├── base_armor_items_armor_20251007_230717.json
│   │   │   ├── base_weapons_items_weapons_20250912_235959.json
│   │   │   ├── base_weapons_items_weapons_20250913_002318.json
│   │   │   ├── base_weapons_items_weapons_20250913_002554.json
│   │   │   ├── base_weapons_items_weapons_20250913_141551.json
│   │   │   ├── base_weapons_items_weapons_20250913_141748.json
│   │   │   ├── base_weapons_items_weapons_20250913_180742.json
│   │   │   ├── base_weapons_items_weapons_20250913_235905.json
│   │   │   ├── base_weapons_items_weapons_20250914_130547.json
│   │   │   ├── base_weapons_items_weapons_20250914_131055.json
│   │   │   ├── base_weapons_items_weapons_20250914_132944.json
│   │   │   ├── base_weapons_items_weapons_20250919_095109.json
│   │   │   ├── base_weapons_items_weapons_20250919_131027.json
│   │   │   ├── base_weapons_items_weapons_20250919_142500.json
│   │   │   ├── base_weapons_items_weapons_20251006_220302.json
│   │   │   ├── base_weapons_items_weapons_20251006_220742.json
│   │   │   ├── base_weapons_items_weapons_20251006_225101.json
│   │   │   ├── base_weapons_items_weapons_20251007_222935.json
│   │   │   ├── base_weapons_items_weapons_20251007_224914.json
│   │   │   ├── base_weapons_items_weapons_20251007_225231.json
│   │   │   ├── base_weapons_items_weapons_20251007_225824.json
│   │   │   ├── base_weapons_items_weapons_20251007_230517.json
│   │   │   ├── consumables_items_consumables_20250912_235959.json
│   │   │   ├── consumables_items_consumables_20250913_002318.json
│   │   │   ├── consumables_items_consumables_20250913_002554.json
│   │   │   ├── consumables_items_consumables_20250913_141551.json
│   │   │   ├── consumables_items_consumables_20250913_141748.json
│   │   │   ├── consumables_items_consumables_20250913_180742.json
│   │   │   ├── consumables_items_consumables_20250913_235905.json
│   │   │   ├── consumables_items_consumables_20250914_130547.json
│   │   │   ├── consumables_items_consumables_20250914_131055.json
│   │   │   ├── consumables_items_consumables_20250914_132944.json
│   │   │   ├── consumables_items_consumables_20250919_095109.json
│   │   │   ├── consumables_items_consumables_20250919_131027.json
│   │   │   ├── consumables_items_consumables_20250919_142500.json
│   │   │   ├── consumables_items_consumables_20251006_220742.json
│   │   │   ├── consumables_items_consumables_20251006_225101.json
│   │   │   ├── consumables_items_consumables_20251007_222935.json
│   │   │   ├── miscellaneous_items_misc_20250912_235959.json
│   │   │   ├── miscellaneous_items_misc_20250913_002318.json
│   │   │   ├── miscellaneous_items_misc_20250913_002554.json
│   │   │   ├── miscellaneous_items_misc_20250913_141551.json
│   │   │   ├── miscellaneous_items_misc_20250913_141748.json
│   │   │   ├── miscellaneous_items_misc_20250913_180742.json
│   │   │   ├── miscellaneous_items_misc_20250913_235905.json
│   │   │   ├── miscellaneous_items_misc_20250914_130547.json
│   │   │   ├── miscellaneous_items_misc_20250914_131055.json
│   │   │   ├── miscellaneous_items_misc_20250914_132944.json
│   │   │   ├── miscellaneous_items_misc_20250919_095109.json
│   │   │   ├── miscellaneous_items_misc_20250919_131027.json
│   │   │   ├── miscellaneous_items_misc_20250919_142500.json
│   │   │   ├── miscellaneous_items_misc_20251006_220742.json
│   │   │   ├── miscellaneous_items_misc_20251006_225101.json
│   │   │   ├── miscellaneous_items_misc_20251007_222935.json
│   │   │   ├── origin_items_items_origin_20250912_235959.json
│   │   │   ├── origin_items_items_origin_20250913_002318.json
│   │   │   ├── origin_items_items_origin_20250913_002554.json
│   │   │   ├── origin_items_items_origin_20250913_141551.json
│   │   │   ├── origin_items_items_origin_20250913_141748.json
│   │   │   ├── origin_items_items_origin_20250913_180742.json
│   │   │   ├── origin_items_items_origin_20250913_235905.json
│   │   │   ├── origin_items_items_origin_20250914_130547.json
│   │   │   ├── origin_items_items_origin_20250914_131055.json
│   │   │   ├── origin_items_items_origin_20250914_132944.json
│   │   │   ├── origin_items_items_origin_20250919_095109.json
│   │   │   ├── origin_items_items_origin_20250919_131027.json
│   │   │   ├── origin_items_items_origin_20250919_142500.json
│   │   │   ├── origin_items_items_origin_20251006_220742.json
│   │   │   ├── origin_items_items_origin_20251006_225101.json
│   │   │   └── origin_items_items_origin_20251007_222935.json
│   │   ├── README.md
│   │   ├── base_armor.json
│   │   ├── base_weapons.json
│   │   ├── consumables.json
│   │   ├── miscellaneous.json
│   │   └── origin_items.json
│   ├── llm/
│   │   ├── agents/
│   │   │   ├── README.md
│   │   │   ├── combatnarrator.json
│   │   │   ├── context_evaluator.json
│   │   │   ├── narrator.json
│   │   │   └── rule_checker.json
│   │   ├── base_config.json
│   │   ├── models.json
│   │   └── providers.json
│   ├── npc/
│   │   ├── backup/
│   │   │   ├── names_20250919_095109.json
│   │   │   ├── names_20250919_131027.json
│   │   │   ├── names_20250919_142500.json
│   │   │   ├── names_20251006_220742.json
│   │   │   ├── names_20251006_225101.json
│   │   │   ├── names_20251007_222935.json
│   │   │   ├── variants_20251006_220742.json
│   │   │   ├── variants_20251006_225101.json
│   │   │   └── variants_20251007_222935.json
│   │   ├── NPC_SYSTEM.md
│   │   ├── README_scaling_system.md
│   │   ├── abilities.json
│   │   ├── abilities.schema.json
│   │   ├── boss_overlays.json
│   │   ├── boss_overlays.schema.json
│   │   ├── families.json
│   │   ├── families.schema.json
│   │   ├── families_factions.json
│   │   ├── generation_rules.json
│   │   ├── generation_rules.schema.json
│   │   ├── names.json
│   │   ├── roles.json
│   │   ├── roles.schema.json
│   │   ├── tags.json
│   │   ├── tags.schema.json
│   │   └── variants.json
│   ├── schemas/
│   │   ├── aliases.schema.json
│   │   ├── npc_family.schema.json
│   │   ├── npc_tags.schema.json
│   │   └── npc_variant.schema.json
│   ├── world/
│   │   ├── base/
│   │   │   ├── backup/
│   │   │   │   ├── cultures_20250912_235959.json
│   │   │   │   ├── cultures_20250913_002318.json
│   │   │   │   ├── cultures_20250913_002554.json
│   │   │   │   ├── cultures_20250913_141551.json
│   │   │   │   ├── cultures_20250913_141748.json
│   │   │   │   ├── cultures_20250913_180742.json
│   │   │   │   ├── cultures_20250913_235905.json
│   │   │   │   ├── cultures_20250914_130547.json
│   │   │   │   ├── cultures_20250914_131055.json
│   │   │   │   ├── cultures_20250914_132944.json
│   │   │   │   ├── cultures_20250919_095109.json
│   │   │   │   ├── cultures_20250919_131027.json
│   │   │   │   ├── cultures_20250919_142500.json
│   │   │   │   ├── cultures_20251006_220742.json
│   │   │   │   ├── cultures_20251006_225101.json
│   │   │   │   ├── cultures_20251007_222935.json
│   │   │   │   ├── fundamental_rules_20250912_235959.json
│   │   │   │   ├── fundamental_rules_20250913_002318.json
│   │   │   │   ├── fundamental_rules_20250913_002554.json
│   │   │   │   ├── fundamental_rules_20250913_141551.json
│   │   │   │   ├── fundamental_rules_20250913_141748.json
│   │   │   │   ├── fundamental_rules_20250913_180742.json
│   │   │   │   ├── fundamental_rules_20250913_235905.json
│   │   │   │   ├── fundamental_rules_20250914_130547.json
│   │   │   │   ├── fundamental_rules_20250914_131055.json
│   │   │   │   ├── fundamental_rules_20250914_132944.json
│   │   │   │   ├── fundamental_rules_20250919_095109.json
│   │   │   │   ├── fundamental_rules_20250919_131027.json
│   │   │   │   ├── fundamental_rules_20250919_142500.json
│   │   │   │   ├── fundamental_rules_20251006_220742.json
│   │   │   │   ├── fundamental_rules_20251006_225101.json
│   │   │   │   ├── fundamental_rules_20251007_222935.json
│   │   │   │   ├── magic_systems_20250912_235959.json
│   │   │   │   ├── magic_systems_20250913_002318.json
│   │   │   │   ├── magic_systems_20250913_002554.json
│   │   │   │   ├── magic_systems_20250913_141551.json
│   │   │   │   ├── magic_systems_20250913_141748.json
│   │   │   │   ├── magic_systems_20250913_180742.json
│   │   │   │   ├── magic_systems_20250913_235905.json
│   │   │   │   ├── magic_systems_20250914_130547.json
│   │   │   │   ├── magic_systems_20250914_131055.json
│   │   │   │   ├── magic_systems_20250914_132944.json
│   │   │   │   ├── magic_systems_20250919_095109.json
│   │   │   │   ├── magic_systems_20250919_131027.json
│   │   │   │   ├── magic_systems_20250919_142500.json
│   │   │   │   ├── magic_systems_20251006_220742.json
│   │   │   │   ├── magic_systems_20251006_225101.json
│   │   │   │   ├── magic_systems_20251007_222935.json
│   │   │   │   ├── world_history_20250912_235959.json
│   │   │   │   ├── world_history_20250913_002318.json
│   │   │   │   ├── world_history_20250913_002554.json
│   │   │   │   ├── world_history_20250913_141551.json
│   │   │   │   ├── world_history_20250913_141748.json
│   │   │   │   ├── world_history_20250913_180742.json
│   │   │   │   ├── world_history_20250913_235905.json
│   │   │   │   ├── world_history_20250914_130547.json
│   │   │   │   ├── world_history_20250914_131055.json
│   │   │   │   ├── world_history_20250914_132944.json
│   │   │   │   ├── world_history_20250919_095109.json
│   │   │   │   ├── world_history_20250919_131027.json
│   │   │   │   ├── world_history_20250919_142500.json
│   │   │   │   ├── world_history_20251006_220742.json
│   │   │   │   ├── world_history_20251006_225101.json
│   │   │   │   └── world_history_20251007_222935.json
│   │   │   ├── cultures.json
│   │   │   ├── fundamental_rules.json
│   │   │   ├── magic_systems.json
│   │   │   └── world_history.json
│   │   ├── locations/
│   │   │   ├── backup/
│   │   │   │   ├── defaults_20251006_220742.json
│   │   │   │   ├── defaults_20251006_225101.json
│   │   │   │   ├── defaults_20251007_222935.json
│   │   │   │   ├── locations_20250912_235959.json
│   │   │   │   ├── locations_20250913_002318.json
│   │   │   │   ├── locations_20250913_002554.json
│   │   │   │   ├── locations_20250913_141551.json
│   │   │   │   ├── locations_20250913_141748.json
│   │   │   │   ├── locations_20250913_180742.json
│   │   │   │   ├── locations_20250913_235905.json
│   │   │   │   ├── locations_20250914_130547.json
│   │   │   │   ├── locations_20250914_131055.json
│   │   │   │   ├── locations_20250914_132944.json
│   │   │   │   ├── locations_20250919_095109.json
│   │   │   │   ├── locations_20250919_131027.json
│   │   │   │   ├── locations_20250919_142500.json
│   │   │   │   ├── locations_20251006_220742.json
│   │   │   │   ├── locations_20251006_225101.json
│   │   │   │   └── locations_20251007_222935.json
│   │   │   ├── defaults.json
│   │   │   └── locations.json
│   │   └── scenarios/
│   │       ├── backup/
│   │       │   ├── origins_20250912_235330.json
│   │       │   ├── origins_20250912_235959.json
│   │       │   ├── origins_20250913_002318.json
│   │       │   ├── origins_20250913_002554.json
│   │       │   ├── origins_20250913_141551.json
│   │       │   ├── origins_20250913_141748.json
│   │       │   ├── origins_20250913_180742.json
│   │       │   ├── origins_20250913_235905.json
│   │       │   ├── origins_20250914_130547.json
│   │       │   ├── origins_20250914_131055.json
│   │       │   ├── origins_20250914_132944.json
│   │       │   ├── origins_20250919_095109.json
│   │       │   ├── origins_20250919_131027.json
│   │       │   ├── origins_20250919_142500.json
│   │       │   ├── origins_20251006_220742.json
│   │       │   ├── origins_20251006_225101.json
│   │       │   ├── origins_20251007_222935.json
│   │       │   ├── quests_20250912_235330.json
│   │       │   ├── quests_20250912_235959.json
│   │       │   ├── quests_20250913_002318.json
│   │       │   ├── quests_20250913_002554.json
│   │       │   ├── quests_20250913_141551.json
│   │       │   ├── quests_20250913_141748.json
│   │       │   ├── quests_20250913_180742.json
│   │       │   ├── quests_20250913_235905.json
│   │       │   ├── quests_20250914_130547.json
│   │       │   ├── quests_20250914_131055.json
│   │       │   ├── quests_20250914_132944.json
│   │       │   ├── quests_20250919_095109.json
│   │       │   ├── quests_20250919_131027.json
│   │       │   ├── quests_20250919_142500.json
│   │       │   ├── quests_20251006_220742.json
│   │       │   ├── quests_20251006_225101.json
│   │       │   └── quests_20251007_222935.json
│   │       ├── origins.json
│   │       └── quests.json
│   ├── README.md
│   ├── combat_display_settings.json
│   ├── game_config.json
│   ├── gui_config.json
│   ├── llm_config.json
│   ├── skills.json
│   └── system_config.json
├── core/
│   ├── agents/
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── agent_manager.py
│   │   ├── base_agent.py
│   │   ├── combat_narrator.py
│   │   ├── context_evaluator.py
│   │   ├── data_retrieval_commands.py
│   │   ├── narrator.py
│   │   ├── rule_checker.py
│   │   ├── social_conflict_agent.py
│   │   └── trade_agent.py
│   ├── audio/
│   │   ├── __init__.py
│   │   └── tts_manager.py
│   ├── base/
│   │   ├── state/
│   │   │   ├── __init__.py
│   │   │   ├── calendar_state.py
│   │   │   ├── game_state.py
│   │   │   ├── player_state.py
│   │   │   ├── state_manager.py
│   │   │   ├── stats_integration.py
│   │   │   └── world_state.py
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── commands.py
│   │   ├── config.py
│   │   ├── engine.py
│   │   ├── game_loop.py
│   │   ├── init_modules.py
│   │   └── state.py
│   ├── character/
│   │   ├── selected_files_documentation_25.05.2025_22_45_07_output/
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── background_generator.py
│   │   ├── npc_base.py
│   │   ├── npc_creator.py
│   │   ├── npc_family_generator.py
│   │   ├── npc_flavor.py
│   │   ├── npc_generator.py
│   │   ├── npc_manager.py
│   │   ├── npc_memory.py
│   │   ├── npc_persistence.py
│   │   └── npc_system.py
│   ├── combat/
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── action_handlers.py
│   │   ├── combat_action.py
│   │   ├── combat_entity.py
│   │   ├── combat_manager.py
│   │   ├── dev_commands.py
│   │   └── enums.py
│   ├── game_flow/
│   │   ├── __init__.py
│   │   ├── command_handlers.py
│   │   ├── command_router.py
│   │   ├── event_log.py
│   │   ├── game_flow_utils.py
│   │   ├── input_router.py
│   │   ├── interaction_core.py
│   │   ├── interaction_processor.py
│   │   ├── lifecycle.py
│   │   ├── mode_transitions.py
│   │   ├── npc_interaction.py
│   │   ├── quest_updates.py
│   │   ├── reference_resolver.py
│   │   └── request_handlers.py
│   ├── interaction/
│   │   ├── context_builder.py
│   │   ├── enums.py
│   │   ├── social_effects.py
│   │   └── structured_requests.py
│   ├── inventory/
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── currency_manager.py
│   │   ├── equipment_manager.py
│   │   ├── inventory_base.py
│   │   ├── inventory_commands.py
│   │   ├── inventory_commands_2.py
│   │   ├── inventory_commands_3.py
│   │   ├── inventory_item_operations.py
│   │   ├── inventory_limits.py
│   │   ├── inventory_manager.py
│   │   ├── item.py
│   │   ├── item_effect.py
│   │   ├── item_enums.py
│   │   ├── item_factory.py
│   │   ├── item_manager.py
│   │   ├── item_modifier.py
│   │   ├── item_serialization.py
│   │   ├── item_stat.py
│   │   ├── item_stat_modifier.py
│   │   ├── item_template_loader.py
│   │   ├── item_variation_generator.py
│   │   ├── narrative_item_creation.py
│   │   ├── narrative_item_discovery.py
│   │   ├── narrative_item_manager.py
│   │   └── narrative_item_mappings.py
│   ├── llm/
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── llm_manager.py
│   │   ├── provider_manager.py
│   │   ├── settings_cli.py
│   │   ├── settings_manager.py
│   │   └── settings_manager_new.py
│   ├── orchestration/
│   │   ├── __init__.py
│   │   ├── combat_orchestrator.py
│   │   └── events.py
│   ├── stats/
│   │   ├── enums/
│   │   │   └── __init__.py
│   │   ├── tests/
│   │   │   ├── __init__.py
│   │   │   └── test_stats_manager.py
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── combat_effects.py
│   │   ├── derived_stats.py
│   │   ├── enums.py
│   │   ├── modifier.py
│   │   ├── modifier_manager.py
│   │   ├── registry.py
│   │   ├── skill_check.py
│   │   ├── skill_manager.py
│   │   ├── stat_allocation.py
│   │   ├── stat_modifier_info.py
│   │   ├── stats_base.py
│   │   └── stats_manager.py
│   ├── testing/
│   │   ├── __init__.py
│   │   ├── headless_env.py
│   │   ├── headless_ui_listener.py
│   │   ├── quest_commands.py
│   │   └── scenario_runner.py
│   ├── utils/
│   │   ├── README.md
│   │   ├── dice.py
│   │   ├── dice.py.README.md
│   │   ├── dotdict.py
│   │   ├── enhanced_time_manager.py
│   │   ├── json_utils.py
│   │   ├── logging_config.py
│   │   ├── save_manager.py
│   │   └── time_utils.py
│   ├── README.md
│   └── __init__.py
├── gui/
│   ├── components/
│   │   ├── README.md
│   │   ├── character_sheet.py
│   │   ├── combat_display.py
│   │   ├── command_input.py
│   │   ├── game_menu.py
│   │   ├── game_output.py
│   │   ├── inventory_panel.py
│   │   ├── journal_panel.py
│   │   ├── menu_panel.py
│   │   ├── right_panel.py
│   │   ├── skill_check_display.py
│   │   ├── stat_allocation_widget.py
│   │   └── status_bar.py
│   ├── dialogs/
│   │   ├── settings/
│   │   │   ├── __init__.py
│   │   │   ├── agent_setup_tab.py
│   │   │   ├── anthropic_tab.py
│   │   │   ├── background_tab.py
│   │   │   ├── base_settings_dialog.py
│   │   │   ├── llm_general_tab.py
│   │   │   ├── llm_provider_tab.py
│   │   │   ├── llm_settings_dialog.py
│   │   │   ├── model_management_widget.py
│   │   │   ├── provider_tabs.py
│   │   │   ├── settings_dialog.py
│   │   │   └── style_tab.py
│   │   ├── README.md
│   │   ├── __init__.py
│   │   ├── base_dialog.py
│   │   ├── character_creation_dialog.py
│   │   ├── combat_settings_dialog.py
│   │   ├── game_over_dialog.py
│   │   ├── item_info_dialog.py
│   │   ├── load_game_dialog.py
│   │   ├── new_game_dialog.py
│   │   └── save_game_dialog.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── init_settings.py
│   │   └── resource_manager.py
│   ├── README.md
│   ├── descr.md
│   └── main_window.py
├── images/
│   ├── character/
│   │   └── paperdoll/
│   │       └── dump/
│   ├── character_icons/
│   │   ├── Cinderspawn_Cleric/
│   │   ├── Cinderspawn_Mage/
│   │   ├── Cinderspawn_Ranger/
│   │   ├── Cinderspawn_Rogue/
│   │   ├── Cinderspawn_Wanderer/
│   │   ├── Cinderspawn_Warrior/
│   │   ├── Dwarf_Cleric/
│   │   ├── Dwarf_Mage/
│   │   ├── Dwarf_Ranger/
│   │   ├── Dwarf_Rogue/
│   │   ├── Dwarf_Warrior/
│   │   ├── Elf_Cleric/
│   │   ├── Elf_Mage/
│   │   ├── Elf_Ranger/
│   │   ├── Elf_Rogue/
│   │   ├── Elf_Wanderer/
│   │   ├── Elf_Warrior/
│   │   ├── Halfling_Cleric/
│   │   ├── Halfling_Mage/
│   │   ├── Halfling_Ranger/
│   │   ├── Halfling_Rogue/
│   │   ├── Halfling_Wanderer/
│   │   ├── Halfling_Warrior/
│   │   ├── Human_Cleric/
│   │   ├── Human_Mage/
│   │   ├── Human_Ranger/
│   │   ├── Human_Rogue/
│   │   ├── Human_Wanderer/
│   │   ├── Human_Warrior/
│   │   ├── Maelstri_Cleric/
│   │   ├── Maelstri_Mage/
│   │   ├── Maelstri_Ranger/
│   │   ├── Maelstri_Rogue/
│   │   ├── Maelstri_Wanderer/
│   │   ├── Maelstri_Warrior/
│   │   ├── Mycora_Cleric/
│   │   ├── Mycora_Mage/
│   │   ├── Mycora_Ranger/
│   │   ├── Mycora_Rogue/
│   │   ├── Mycora_Wanderer/
│   │   ├── Mycora_Warrior/
│   │   ├── Orc_Cleric/
│   │   ├── Orc_Mage/
│   │   ├── Orc_Ranger/
│   │   ├── Orc_Rogue/
│   │   ├── Orc_Wanderer/
│   │   ├── Orc_Warrior/
│   │   ├── Prismal_Cleric/
│   │   ├── Prismal_Mage/
│   │   ├── Prismal_Ranger/
│   │   ├── Prismal_Rogue/
│   │   ├── Prismal_Wanderer/
│   │   ├── Prismal_Warrior/
│   │   ├── gui/
│   │   │   ├── background/
│   │   │   ├── colors/
│   │   │   │   └── placeholder_creator.py
│   │   │   ├── combat_display/
│   │   │   ├── textures/
│   │   │   ├── placeholder_creator.py
│   │   │   └── test.html
│   │   ├── icons/
│   │   ├── character_combinations.txt.bulk_settings.json
│   │   └── convert_images_recursive.py
│   ├── gui/
│   │   ├── background/
│   │   └── combat_display/
│   ├── icons/
│   │   ├── accessory/
│   │   ├── armor/
│   │   ├── consumable/
│   │   ├── container/
│   │   ├── document/
│   │   ├── key/
│   │   ├── material/
│   │   ├── miscellaneous/
│   │   ├── quest/
│   │   ├── shield/
│   │   ├── tool/
│   │   ├── treasure/
│   │   └── weapon/
│   └── convert_images_recursive.py
├── log_viewer_tool/
│   ├── logs/
│   ├── __init__.py
│   ├── color_delegate.py
│   ├── color_settings_dialog.py
│   ├── export_dialog.py
│   ├── filter_model.py
│   ├── log_entry.py
│   ├── log_parser.py
│   ├── main_window.py
│   └── settings_manager.py
├── logs/
├── reports/
│   └── npc_headless_report.json
├── saves/
│   ├── backups/
│   ├── npcs/
│   │   └── _report_tmp/
│   ├── README.md
│   ├── newgame1.json
│   ├── newgame2.json
│   ├── newgame3.json
│   ├── test1.json
│   ├── test2.json
│   ├── test3.json
│   ├── test4.json
│   ├── test5.json
│   ├── test6.json
│   ├── test7.json
│   ├── test8.json
│   ├── test8wolf.json
│   ├── test9.json
│   ├── test_fight_new.json
│   ├── test_time_1.json
│   ├── testing.json
│   ├── testing_apple1.json
│   └── wolf_alpha.json
├── scripts/
│   └── migrations/
│       └── normalize_items_aliases.py
├── selected_files_documentation_08.10.2025_22_29_43_output/
├── selected_files_documentation_09.10.2025_10_35_57_output/
├── selected_files_documentation_09.10.2025_14_16_18_output/
├── sound/
│   └── README.md
├── tests/
│   ├── README.md
│   ├── __init__.py
│   └── test_stats_system.py
├── tools/
│   ├── headless_cli/
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── repro_new_game_wolf.py
│   │   ├── run_families_quick.py
│   │   ├── run_loaded.py
│   │   └── verify_q02_autocomplete.py
│   ├── __init__.py
│   ├── npc_headless_report.py
│   ├── sanity_check_npc.py
│   ├── test_npc_boss_overlays_headless.py
│   ├── test_npc_families_headless.py
│   ├── test_npc_generation_rules_headless.py
│   ├── test_npc_variants_headless.py
│   ├── test_social_determinism_headless.py
│   ├── test_social_npcs_headless.py
│   ├── test_spawn_intent_resolution_headless.py
│   └── validate_json.py
├── web/
│   ├── client/
│   │   ├── css/
│   │   │   └── style.css
│   │   ├── js/
│   │   │   ├── agent-settings.js
│   │   │   ├── api-client.js
│   │   │   ├── character-creator.js
│   │   │   ├── main.js
│   │   │   ├── model-debug.js
│   │   │   ├── ui-manager.js
│   │   │   └── websocket-client.js
│   │   └── index.html
│   ├── server/
│   │   └── server.py
│   ├── README.md
│   └── layout_edit_instr.md
├── world_configurator/
│   ├── assistant/
│   │   ├── __init__.py
│   │   ├── context.py
│   │   ├── panel.py
│   │   ├── patching.py
│   │   └── prompt_builder.py
│   ├── config/
│   │   └── skills.json
│   ├── data/
│   ├── llm/
│   │   ├── __init__.py
│   │   ├── client_base.py
│   │   ├── gemini.py
│   │   ├── providers_registry.py
│   │   └── settings.py
│   ├── logs/
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base_models.py
│   │   ├── item_data_manager.py
│   │   ├── location_data.py
│   │   ├── location_defaults_manager.py
│   │   ├── names_manager.py
│   │   ├── origin_data.py
│   │   ├── skill_manager.py
│   │   ├── variants_manager.py
│   │   ├── world_config.py
│   │   └── world_data.py
│   ├── selected_files_documentation_31.05.2025_22_40_59_output/
│   ├── ui/
│   │   ├── dialogs/
│   │   │   ├── __init__.py
│   │   │   ├── base_dialog.py
│   │   │   ├── export_dialog.py
│   │   │   ├── item_selection_dialog.py
│   │   │   ├── new_project_dialog.py
│   │   │   ├── quest_selection_dialog.py
│   │   │   ├── settings_dialog.py
│   │   │   └── skill_selection_dialog.py
│   │   ├── editors/
│   │   │   ├── SpecificItemEditor.py
│   │   │   ├── __init__.py
│   │   │   ├── class_editor.py
│   │   │   ├── culture_editor.py
│   │   │   ├── history_editor.py
│   │   │   ├── item_editor_panel.py
│   │   │   ├── location_editor.py
│   │   │   ├── magic_systems_editor.py
│   │   │   ├── names_editor.py
│   │   │   ├── origin_editor.py
│   │   │   ├── quest_editor.py
│   │   │   ├── race_editor.py
│   │   │   ├── skills_editor.py
│   │   │   └── variants_editor.py
│   │   ├── widgets/
│   │   │   ├── __init__.py
│   │   │   ├── multiselect_combo.py
│   │   │   └── typed_resistances_editor.py
│   │   ├── __init__.py
│   │   └── main_window.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── data_validator.py
│   │   ├── file_manager.py
│   │   └── logging_setup.py
│   ├── validators/
│   │   └── origins_quests_validator.py
│   ├── README.md
│   ├── __init__.py
│   └── main.py
├── world_configurator.egg-info/
├── PROJECT_STRUCTURE.MD
├── README.md
├── REFACTORING_PLAN.MD
├── The Resonance Cycle Timekeeping in Aetheris.MD
├── WARP.md
├── background_refactor_checklist.md
├── checklist.md
├── checklist_full.md
├── combat_flow.md
├── combat_flow_adjustment_checklist.md
├── create_color_swatches.py
├── create_texture.py
├── create_textures.py
├── engine_refactor_checklist.md
├── gameworld_framework.md
├── generate_project_structure.py
├── gui_redesign_spec.md
├── implementation_summary.md
├── magic_system_overhaul.md
├── magic_system_overhaul_checklist.md
├── main.py
├── manage_llm_settings.py
├── mode_transition_plan.md
├── npc_item_mgmt_combat.md
├── prompt_construction.md
├── quest_management_implementation.md
├── root_causes.MD
├── run_gui.py
├── run_headless.py
├── run_headless_load.py
├── run_log_viewer.py
├── run_verify_q02.py
├── setup.py
├── start_server.py
├── test_difficulty_encounter_scaling.py
├── test_inventory.py
└── world_configurator.py
```

## Files Content

### File: gameworld_framework.md

```markdown
# SHATTERED RESONANCE
## Fantasy World Building Guide

## CORE CONCEPT
This world, called Aetheris, was once a single unified reality until "The Shattering" - a catastrophic magical event that fractured the world into overlapping planes of reality. These planes occasionally merge, causing "Resonance Events" where landscapes, creatures, and cultures temporarily blend before separating again. This has led to unique evolutionary paths, cultural adaptations, and magical systems.

## WORLD HISTORY

### The Age of Harmony (Ancient Era)
- Aetheris was once a singular reality where all races existed in harmony under the watchful eye of the Luminaries - cosmic entities who maintained balance.
- Magic was a natural force, accessible through song and ritualistic movements rather than formal spellcasting.
- Society was nomadic, following seasonal magical currents across the land.

### The Shattering (Defining Cataclysm)
- Approximately 2,500 years ago, an experiment by the Cipher Conclave, an ancient mage collective seeking immortality, tore reality apart.
- The world split into five overlapping planes: Verdant (nature), Crystalline (order), Ashen (decay), Tempest (chaos), and Nexus (the central plane where most inhabitants now dwell).
- The Luminaries were scattered across the planes, their essences fragmented.

### The Age of Isolation (1-1000 AS - After Shattering)
- Surviving populations adapted to their new isolated realities.
- First Resonance Events occurred, terrifying and disorienting as planes temporarily merged.
- The Five Speakers emerged - individuals who could hear the "voices" of the fragmented Luminaries.

### The Age of Discovery (1000-2000 AS)
- Civilizations developed ways to predict and utilize Resonance Events.
- The Harmonic Order formed to study and catalog plane interactions.
- First intentional cross-plane settlements established.

### The Modern Age (2000-2500 AS)
- Sophisticated societies have emerged that incorporate elements from multiple planes.
- Resonance Events are now celebrated cultural occurrences, though unpredictable ones can still be dangerous.
- Rumors of methods to permanently reunite the planes circulate, causing political and ideological tension.

## CULTURES & SOCIETIES

### The Concordant Cities
- **Capital**: Harmonia
- **Culture**: These seven interconnected city-states sit at major Resonance nodes on Nexus plane. Their architecture constantly shifts as it incorporates elements from other planes during Resonance Events.
- **Notable Feature**: Citizens undergo "Attunement" - ritual tattooing that helps them maintain their identity during plane shifts.
- **Governance**: Ruled by the Council of Resonance - representatives from each major race and class specialization.

### The Verdant Collective
- **Territory**: Primarily exists in the Verdant plane but maintains outposts on Nexus.
- **Culture**: Focused on symbiotic relationships with their environment. Societal roles are seasonal, with individuals changing their societal functions throughout the year.
- **Notable Feature**: "Green Speech" - a language composed of plant growth patterns and pheromones that non-members cannot decode.
- **Primary Races**: Elves, Halflings, and the unique Mycora (fungal humanoids).

### The Crystalline Consortium
- **Territory**: Most stable presence on the Crystalline plane, with trading enclaves on Nexus.
- **Culture**: Highly ordered society where personal worth is measured by one's contribution to mathematical and magical precision.
- **Notable Feature**: "Faceting" - a coming-of-age ritual where adolescents receive geometric crystal implants that enhance specific mental abilities.
- **Primary Races**: Dwarves, Humans, and the unique Prismals (crystalline beings).

### The Ashen Covenant
- **Territory**: Nomadic societies traveling the Ashen plane and temporary settlements on Nexus.
- **Culture**: Focuses on impermanence and rebirth. Nothing is permanently owned; all possessions rotate through the community.
- **Notable Feature**: "Dust Keeping" - the practice of preserving the ashes of ancestors and using them in rituals to communicate with the dead.
- **Primary Races**: Orcs, Humans, and the unique Cinderspawn (ash-infused beings).

### The Tempest Flotilla
- **Territory**: Constantly moving throughout the chaotic Tempest plane with harbors on Nexus during certain celestial alignments.
- **Culture**: Adapts rapidly to change with fluid social hierarchies that can transform daily.
- **Notable Feature**: "Storm Binding" - capturing the essence of Tempest plane storms in tattoos that grant unpredictable magical abilities.
- **Primary Races**: Humans, Halflings, and the unique Maelstri (storm-touched beings with partially translucent bodies).

## MAJOR FACTIONS & POWERS

### The Harmonic Order
- **Base**: Harmonia
- **Purpose**: Study and predict Resonance Events; maintain historical records.
- **Structure**: Academic hierarchy with Resonance Sages at the top.
- **Current Agenda**: Searching for a way to stabilize unpredictable Resonance Events that have been increasing in frequency.

### The Cipher Remnant
- **Base**: Hidden enclaves throughout all planes
- **Purpose**: Descendants of the Cipher Conclave who caused The Shattering, seeking redemption through reunification of the planes.
- **Structure**: Cell-based organization with individual "Threads" working independently.
- **Current Agenda**: Collecting fragments of Luminaries to potentially reverse The Shattering.

### The Dissonant Path
- **Base**: Primarily in the Ashen plane
- **Purpose**: Believes The Shattering was necessary evolution; opposes reunification.
- **Structure**: Loosely organized collectives led by "Disruptors" - individuals who can temporarily intensify plane separation.
- **Current Agenda**: Sabotaging reunification efforts; inducing controlled Resonance Events to strengthen the barriers between planes.

### The Mercantile Chord
- **Base**: Trading hubs at the edges of major settlements across all planes
- **Purpose**: Profit from cross-plane commerce and the unique resources each plane provides.
- **Structure**: Guild-based organization with specialized traders for each plane's goods.
- **Current Agenda**: Monopolizing "Resonant Materials" - items that retain properties from multiple planes.

### The Five Speakers
- **Base**: Individual territories throughout Nexus
- **Purpose**: Each communicates with a fragmented Luminary, interpreting their will.
- **Structure**: Quasi-religious leaders with devoted followers.
- **Current Agenda**: The Speakers disagree on whether the Luminaries want reunification, leading to growing conflict between their factions.

## CONFLICTS & TENSIONS

### The Resonance Crisis
- Resonance Events are becoming more frequent and unpredictable.
- Some believe this heralds an imminent collapse of the planar boundaries.
- Others see it as an opportunity for permanent reunification.
- The Harmonic Order works to contain dangerous Resonances while studying the phenomenon.

### The Luminary Fragments
- Pieces of the original Luminaries occasionally manifest as powerful artifacts.
- Major factions compete to collect these fragments for their own purposes.
- Each fragment contains knowledge and power from before The Shattering.
- Some fragments have developed sentience and their own agendas.

### Resource Imbalance
- Each plane produces unique resources necessary for advanced magic and technology.
- The Mercantile Chord's monopolistic practices have created resource inequalities.
- Border settlements face exploitation from multiple powers.
- Resource wars are becoming more common as certain materials become scarce.

### Identity Crisis
- Individuals caught in Resonance Events sometimes return changed or merged with alternate versions of themselves.
- "Resonance sickness" - a psychological condition where one's sense of self fragments.
- Religious and philosophical movements debate the nature of soul and self in a fractured reality.
- Treatment and integration of the "Resonance-touched" varies widely between cultures.

## UNIQUE MAGICAL SYSTEMS

### Song Weaving
- The most ancient form of magic, predating The Shattering.
- Practitioners create effects through specific melodies and harmonies.
- Different musical scales connect to different planes.
- Most powerful when performed as a group.

### Planar Anchoring
- The art of maintaining stability during Resonance Events.
- Practitioners can extend areas of stability or purposefully blur planar boundaries.
- Primarily used by the Harmonic Order to protect settlements.
- Requires physical components from multiple planes.

### Echo Binding
- Capturing "echoes" - residual effects from other planes that linger after Resonance Events.
- These echoes can be bound to objects or people to grant temporary planar properties.
- Black market for illegal echo harvesting is growing.
- Side effects can include "planar bleeding" - uncontrolled manifestations of other planes.

### Facet Magic
- Developed by the Crystalline Consortium.
- Uses precisely cut geometric crystals to channel and focus magical energies.
- Different shapes and angles produce different effects.
- Requires mathematical precision but extremely stable and reliable.

### Ash Walking
- Unique to the Ashen Covenant.
- Temporarily transferring consciousness into the Ashen plane.
- Used for communication, espionage, and retrieving lost knowledge.
- Extended use causes physical body to gradually turn to ash.

## UNIQUE ELEMENTS & HOOKS

### The Resonance Calendar
- Time is measured by predictable Resonance Events.
- Major celebrations and trade agreements coincide with specific Resonances.
- Calendar interpreters are essential advisors to leaders.
- Recent calendar disruptions are causing social and economic turmoil.

### Planar Bleed Zones
- Areas where planes have permanently merged.
- Contain unique hybrid flora, fauna, and magical properties.
- Highly valuable for research and resources.
- Often dangerous and unpredictable.

### The Ghost Markets
- Appear only during specific Resonance Events.
- Sell items, memories, and services from across all planes.
- Operated by mysterious entities called "The Between."
- Contracts made here are binding across all planes.

### The Shifting Library
- Repository of knowledge that exists simultaneously in all planes.
- Different sections accessible depending on which plane is currently dominant.
- Maintained by the enigmatic Lexicants - beings who can exist in multiple planes simultaneously.
- Contains records from before The Shattering that could potentially reveal how to reverse it.

### The Broken Song
- Fragments of an ancient melody believed to have power over the structure of reality itself.
- Possibly the trigger or solution to The Shattering.
- Those who hear pieces of it are forever changed.
- Various factions seek to either complete or permanently silence the song.

### The Luminary Chess Game
- A political/metaphysical game played between the Five Speakers.
- Moves in the game correspond to real-world events and Resonance patterns.
- The game board is a complex physical representation of the planar system.
- Some believe the outcome of the game will determine the fate of all planes.

## PLAYER INTEGRATION

### Character Origins
- Characters can originate from specific planes, mixed-plane settlements, or be "Resonance-touched."
- Class choices might reflect planar affinities (e.g., clerics might serve specific Luminaries).
- Background traits could include planar exposure effects or Resonance sensitivity.

### Adventure Hooks
- Tracking down Luminary fragments before they fall into dangerous hands.
- Investigating increasingly dangerous Resonance Events in frontier regions.
- Mediating conflicts between planar factions during temporary merges.
- Exploring newly discovered Planar Bleed Zones for valuable resources.
- Preventing or enabling plane reunification attempts.
- Unraveling the true history of The Shattering and those responsible.
- Protecting communities during unexpected Resonance Events.
- Recovering lost knowledge from the Shifting Library.

### Moral Questions
- Is reunifying the planes the right choice, or has separation created valuable diversity?
- How should those transformed by Resonance Events be treated?
- Should powerful planar technology be controlled or freely available?
- What responsibilities do the current generation have for fixing mistakes made in the past?
- Is maintain the status quo more important than progress if progress brings risk?

This world framework offers numerous opportunities for unique storytelling while maintaining familiar fantasy elements that players can relate to. The concept of shifting realities provides both mechanical opportunities for gameplay variety and rich narrative possibilities.
```

### File: magic_system_overhaul.md

```markdown
we're working on \world_configurator but as well on stats or effects / modifiers of items or magic (D:\coding\RPG project\latest version\config\world\base\magic_systems.json). the magic systems are  configurable in world_configuration in 'magic systems' tab -> editing allows to edit the basic info, spells, race affinities and class affinities, but for example, gameplay for magic is not yet implemented nor I'm sure how it could be done for this turn based text rpg game with llm support for uniqueness of experience and crestivity. I am considering that magic could be configured in world_configurator but then, for configured magic/spells, actual effects would be up to the llm narrator (during narration mode or combat mode or barter etc), only with some few guidelines and coded rules (it could ressemble how it is done in RPG games like warhammer or D&D but translated to LORE of this world - see D:\coding\RPG project\latest version\config\world\base\cultures.json, D:\coding\RPG project\latest version\config\world\base\fundamental_rules.json, D:\coding\RPG project\latest version\config\world\base\world_history.json) as having magic system purely mechanistic could be too complcated (too many complicated rules and variations to handle) plus it could be an overkill - what do you think of it? i also noticed that in the initially created items and item templates (before I started to expand fucntionalities of world_configurator) many items have in listed stats attack_speed, strenght requirement, critical chance, range, reach, nouse, movement speed, armor and many others (lots different in starting items, including skill modifiers while skills are not yet implemented; and also in consumables). This is another aspect that should be normalized, especially that stats were recentrly set to be either primary or derived, matching the ones recognizable already by game engine for character -> this aspect should be well thought through (NO code changes yet, only brainstorming!) how to tackle it for different item types


Great direction. A purely mechanistic magic system would be heavy to maintain and hard to keep fun; a purely LLM-driven system risks inconsistency and exploits. I recommend a hybrid: keep a small, deterministic “mechanics core” and let the LLM provide creative narration and propose actions within rails. Use world_configurator to define the rails and validate content. No code changes below—just design.

Recommendation summary
- Use a constrained set of effect atoms and a light rules engine for resolution.
- Drive flavor, improvisation, and diegetic coherence via the LLM narrator, bounded by those atoms and the world’s lore.
- Normalize all stats and item fields with a canonical stat registry and item-type schemas; world_configurator should enforce these.
- Keep everything data-driven in config/, and surface JSON schemas in world_configurator for validation.

1) Magic gameplay: hybrid model
- Deterministic core handles:
  - Legality: is the spell available, targetable, in range, with required components.
  - Resolution: roll/checks, resource costs, resistances, durations, stacking rules, and state updates.
  - Safety: LLM never mutates state; only the core applies effects.
- LLM provides:
  - Narrative descriptions tailored to cultures, rules, and history.
  - Optional “action proposals” (pick a known spell, or propose within policy) returned as strictly structured JSON the engine can parse.
  - Theatrical improvisation within a policy: e.g., allow harmless flavor changes or bounded mechanical substitutions (e.g., convert fire->heat DoT) if permitted by the magic system’s “creativity policy.”
- Orchestration:
  - Core adds DisplayEvent objects to the CombatOutputOrchestrator for each step (cast, save, hit, damage, side-effect, etc.).
  - LLM text accompanies those events, but math/state comes from the core.

2) World_configurator: what to capture in “Magic Systems”
- Basic info: name, schools/paths, flavor, cosmology links to world_history.json and cultures.json.
- Casting model: action economy, cast time, focus/implements, components, concentration.
- Resource model: mana/focus/fatigue/blood, regen rules, overcast/tax.
- Chaos/backlash: miscast chance, fumbles, corruption per fundamental_rules.json.
- Damage and tags: allowed damage types, tags (holy, void, illusion, transmutation…).
- Creativity policy for LLM: leeway, forbidden themes, substitution rules, allowed improvisations.
- Affinities: race/class potency, cost, speed, resistance modifiers by tag/school/damage type.
- Spell catalog: define spells using effect atoms and scaling rules (below).

Example shape for a magic system and spell
```json
{
  "id": "auric_concord",
  "name": "Auric Concord",
  "schools": ["radiance", "binding"],
  "resources": { "mana": true, "focus": false, "blood": false },
  "casting_model": {
    "action": "cast",
    "cast_time_turns": 1,
    "concentration": true,
    "requires_focus_item": true
  },
  "creativity_policy": {
    "llm_leeway": 0.25,
    "allowed_substitutions": ["flavor_only", "tag_preserving_damage_variant"],
    "forbidden": ["time_travel", "permanent_character_edit"]
  },
  "chaos": {
    "miscast_base_chance": 0.02,
    "corruption_on_miscast": { "type": "radiant_scorch", "stacks": 1 }
  },
  "allowed_damage_types": ["radiant", "holy", "pure"],
  "race_affinities": [{ "race_id": "luminar", "potency_mult": 1.15, "cost_mult": 0.9 }],
  "class_affinities": [{ "class_id": "templar", "potency_mult": 1.1 }],
  "spells": [
    {
      "id": "sun_lance",
      "name": "Sun Lance",
      "tier": 2,
      "tags": ["radiance", "projectile"],
      "cost": { "mana": 12 },
      "targeting": { "type": "single", "range_m": 18, "requires_los": true },
      "duration": { "type": "instant" },
      "save": { "defense": "will", "half_on_save": true },
      "scaling": [{ "by": "power", "potency_mult_per_point": 0.02 }],
      "effect_atoms": [
        { "type": "damage", "damage_type": "radiant", "base": 24, "variance_pct": 0.15 },
        { "type": "debuff", "stat": "dark_vision", "delta": -1, "duration_rounds": 2 }
      ]
    }
  ]
}
```
3) Effect atoms and the resolution pipeline
- Keep a small, universal set, applied across combat, exploration, and social:
  - damage, heal, resource_change, buff, debuff, condition (stun/blind/poison/etc.), cleanse/dispel, summon/conjure, transform, movement (pull/push/dash), terrain_hazard, reveal/scry, item_interact, perception/stealth_mod.
- Resolution steps (core only):
  1) Validate targeting and costs.
  2) Compute checks (attack vs defense or save vs DC).
  3) Apply scaling (stats/level/mastery/affinities).
  4) Roll RNG deterministically.
  5) Apply resistances/immunities and stacking rules.
  6) Mutate state and enqueue DisplayEvents with both mechanical results and LLM text.

Example effect atoms
```json
[
  { "type": "damage", "damage_type": "fire", "base": 16, "variance_pct": 0.2, "crit": { "chance": 0.05, "mult": 1.5 } },
  { "type": "condition", "name": "burning", "stacks": 2, "duration_rounds": 3, "tick": { "type": "damage", "damage_type": "fire", "base": 4 } },
  { "type": "resource_change", "resource": "mana", "delta": -12 }
]
```
4) LLM integration and guardrails
- Two roles work best:
  - Action Planner (optional): selects a legal spell or composes atoms within policy, returns structured JSON.
  - Narrator: renders the outcome with world-accurate prose; never changes mechanics.
- Output must be strictly typed for the engine:
```json
{
  "agent": "CombatNarratorAgent",
  "mode": "combat",
  "selected_spell_id": "sun_lance",
  "proposed_atoms": [
    { "type": "damage", "damage_type": "radiant", "base": 24 }
  ],
  "narration": {
    "cast": "You braid light into a spear of noon.",
    "impact": "It bursts against the ghoul, searing shadow to vapor."
  },
  "metadata": { "safety": { "within_policy": true }, "references": ["cultures.luminar", "fundamental_rules.radiance"] }
}
```
- Place policy and lore snippets in config/llm/agents/ and link to world base config so agents stay in-lore.
- In combat, always turn LLM outputs into DisplayEvents. The core remains the source of truth.

5) Non-combat use of magic
- Social: buffs/debuffs to persuasion/resolve/fear, charms, truth wards.
- Exploration: light, reveal, unlock bindings, traverse terrain, illusions that gate checks.
- Barter/crafting: item identify, purity checks, temporary infusions.
- Treat these with the same atoms; only context and targets differ.

6) Stats and item normalization
Problem today: inconsistent item fields (attack_speed, strenght requirement, nouse, etc.), skills referenced but not implemented, recent primary/derived split in the engine.

Solution: a canonical stat registry with aliases, and item-type schemas enforced by world_configurator.

A) Stat registry (canonical + aliases)
- Define canonical key, category (primary/derived/resource/flag), bounds, stacking rules, and display label.
- Maintain an alias map so existing data migrates cleanly.

```json
{
  "stats": [
    { "key": "strength", "category": "primary", "min": 0, "max": 20, "label": "Strength", "aliases": ["str", "strenght"] },
    { "key": "agility", "category": "primary", "label": "Agility", "aliases": ["agi", "dexterity"] },
    { "key": "intellect", "category": "primary", "label": "Intellect", "aliases": ["int"] },
    { "key": "willpower", "category": "primary", "label": "Willpower", "aliases": ["wil", "will"] },
    { "key": "vitality", "category": "primary", "label": "Vitality", "aliases": ["vit", "constitution", "con"] },

    { "key": "hp_max", "category": "derived", "label": "Max HP", "aliases": ["health_max"] },
    { "key": "mana_max", "category": "derived", "label": "Max Mana", "aliases": [] },
    { "key": "stamina_max", "category": "derived", "label": "Max Stamina", "aliases": [] },
    { "key": "armor", "category": "derived", "label": "Armor", "aliases": [] },
    { "key": "attack_speed", "category": "derived", "label": "Attack Speed", "aliases": ["atk_speed", "swing_speed"] },
    { "key": "cast_speed", "category": "derived", "label": "Cast Speed", "aliases": ["spell_speed"] },
    { "key": "crit_chance", "category": "derived", "label": "Critical Chance", "aliases": ["critical chance"] },
    { "key": "accuracy", "category": "derived", "label": "Accuracy", "aliases": [] },
    { "key": "dodge", "category": "derived", "label": "Dodge", "aliases": ["evasion"] },
    { "key": "initiative", "category": "derived", "label": "Initiative", "aliases": [] },
    { "key": "movement_speed", "category": "derived", "label": "Movement Speed", "aliases": ["move_speed"] },
    { "key": "reach", "category": "derived", "label": "Reach", "aliases": [] },
    { "key": "range", "category": "derived", "label": "Range", "aliases": [] },
    { "key": "noise", "category": "derived", "label": "Noise", "aliases": ["nouse"] }
  ]
}
```
B) Item type schema (allowed fields per type)
- Weapon: slot, handedness, damage_profile, attack_speed, range/reach, noise, requirements, on_hit_procs, on_equip_modifiers.
- Armor: slot, armor, resistances, movement_speed_penalty, noise, requirements, on_equip_modifiers.
- Focus/implement: cast_speed, potency_mult, school_tags, requirements.
- Accessory: on_equip_modifiers, resistances, auras.
- Consumable: on_use_effects (atoms), charges, cooldown.
- Ammo/Thrown: damage_profile, range, special tags.
- Tool: utility modifiers, on_use_effects.
```json
{
  "type": "weapon",
  "slot": "main_hand",
  "handedness": "one_handed",
  "requirements": { "strength": 8 },
  "damage_profile": [
    { "damage_type": "slashing", "min": 6, "max": 10 }
  ],
  "attack_speed": 1.1,
  "reach": 1.0,
  "noise": 0.3,
  "on_equip_modifiers": [{ "stat": "accuracy", "delta": 3 }],
  "on_hit_procs": [
    { "chance": 0.1, "atoms": [{ "type": "condition", "name": "bleed", "duration_rounds": 2 }] }
  ]
}
```
C) Validation in world_configurator
- Enforce canonical stat keys via the registry (aliases auto-mapped).
- Per item type, only allow defined fields; flag extras.
- Provide live validation badges and auto-fix suggestions (e.g., “strenght” -> “strength”).

D) Bridging “skills”
- If “skills” aren’t implemented, model “masteries” as derived stats the engine already recognizes (e.g., weapon_mastery, school_mastery.radiance). Keep keys canonical and optional until mechanics are live.

7) Phased rollout (no code yet)
- Decide canonical lists:
  - Primary/derived stats recognized by the engine today.
  - Damage types and status conditions you want first.
  - Item types and minimum viable fields.
- Draft schemas:
  - Magic system and spell schema with effect atoms and scaling.
  - Stat registry with aliases.
  - Item type schemas and validation rules.
  - Creativity policy template for LLM agents.
- World_configurator UX:
  - Magic Systems: add subtabs for Casting Model, Creativity Policy, Chaos/Backlash, Affinities, Spell Catalog.
  - Items: type-first editor, stat pickers bound to the registry, validation panel, synonym auto-fix.
- Migration plan for existing items:
  - Build synonym map from current data to the registry.
  - Normalize fields; drop or park unsupported fields in a “notes/legacy” bag.
  - Spot-check top 20 items per category.
- Pilot:
  - Pick 1–2 magic systems and 8–12 spells to validate end-to-end.
  - Exercise in combat, exploration, and social scenes.

8) Open questions to align before implementation
- What is the exact set of primary and derived stats the engine currently recognizes for characters? Please list them so the registry can match 1:1.
- Which damage types and conditions are canonical already (if any)? If not decided, which ~6–10 do you want to start with?
- Do you want “creativity leeway” set at the magic system level, spell level, or both?
- Are miscasts/backlash part of the world’s fundamental rules broadly, or should they be opt-in per magic system?
- Which item types do you consider MVP for normalization (weapons, armor, focus, consumables)?
- For ranged weapons, do you want “range” and “reach” both, or only “range”? For melee, keep “reach”?
- Should we treat “skills” as future-facing derived stats now (e.g., arcana_mastery) so items/spells can reference them without blocking gameplay?

//

Findings summary (no code changes made)

High-level
•  Magic systems are richly authored in config/world/base/magic_systems.json and fully editable in world_configurator (basic info, spells, race/class affinities). However, there’s no runtime wiring that resolves configured spells into mechanics during combat or narration.
•  Combat already uses an event-driven orchestrator with clear separation between mechanics and UI. LLM agents are in place (Narrator and CombatNarrator), but they don’t consult the authored magic_systems.json for selection or rules.
•  Stats are well-defined in code (primary + derived), but item config uses many free-form stat names. Equipment only maps a very small synonym set and otherwise ignores unknown stats. Typed resistances via items are implemented and flow into mechanics.

Details and evidence

1) Magic systems and spells (data)
•  File: D:\coding\RPG project\latest version\config\world\base\magic_systems.json
◦  Systems like song_weaving, planar_anchoring, echo_binding, facet_magic, ash_walking, divine_healing include:
▪  description/origin/limitations/practitioners/cultural_significance
▪  racial_affinities and class_affinities (often referencing stats like STR/DEX/WIS/INT/CHA by short codes)
▪  spells: each with fields such as mana_cost, casting_time, range, target, effects[] where effect_type ∈ {damage, healing, stat_modification, status_effect}, and dice_notation optionally present
◦  Stats referenced in effects include display strings like “Defense”, “Magic Resistance”, “Planar Stability”, “Knowledge”, “Perception”, “HP Regeneration” which are not aligned with engine enums.
•  World lore context:
◦  fundamental_rules.json and world_history.json are present and coherent with planar themes, Resonance Events, Luminaries, etc. This is suitable to guide LLM narrative style and policy.

2) Runtime combat and magic hooks
•  Combat orchestrator and events:
◦  core/orchestration/events.py and combat_orchestrator.py implement the DisplayEvent pipeline (SYSTEM_MESSAGE, NARRATIVE_ATTEMPT, NARRATIVE_IMPACT, UI_BAR_UPDATE_PHASE*, APPLY_ENTITY_RESOURCE_UPDATE/STATE_UPDATE). This is robust and aligns with your “UI updates are event-driven” rule.
•  Spell mechanics entry point:
◦  core/combat/action_handlers.py has _handle_spell_action(), which:
▪  Uses action.dice_notation and action.special_effects to compute damage vs MAGIC_DEFENSE and apply typed resistance based on damage_type (e.g., “arcane” or special_effects.damage_type).
▪  Applies status effects via special_effects keys like apply_status. It is not consuming magic_systems.json definitions.
◦  There is no bridge that translates a configured Spell (from magic_systems.json) into a CombatAction (dice_notation, effects, typed damage) automatically.
•  Combat flow is otherwise healthy: turn order, surprise, stamina/mana costs, typed riders (from config/combat/combat_config.json) are applied deterministically and visualized via the orchestrator.

3) LLM agents and integration
•  core/agents/combat_narrator.py:
◦  Generates a strict JSON for “attempt” narration and structured “requests” (e.g., request_skill_check, request_state_change).
◦  Doesn’t read the authored spell systems (no selected_spell_id usage built-in); your “proposed_atoms” and spell-policy idea is not implemented in code.
•  AgentManager (core/agents/agent_manager.py) orchestrates Narrator, RuleChecker, ContextEvaluator. CombatNarrator is separate and referenced by CombatManager.
•  config/llm/agents/ contains per-agent JSON; good separation and data-driven LLM settings.

4) Canonical stats recognized by engine (today)
•  Primary (StatType): STRENGTH(STR), DEXTERITY(DEX), CONSTITUTION(CON), INTELLIGENCE(INT), WISDOM(WIS), CHARISMA(CHA), WILLPOWER(WIL), INSIGHT(INS)
•  Derived (DerivedStatType):
◦  Resources: HEALTH/MAX_HEALTH, MANA/MAX_MANA, STAMINA/MAX_STAMINA, RESOLVE/MAX_RESOLVE
◦  Combat: MELEE_ATTACK, RANGED_ATTACK, MAGIC_ATTACK, DEFENSE, MAGIC_DEFENSE, DAMAGE_REDUCTION
◦  Utility: INITIATIVE, CARRY_CAPACITY, MOVEMENT
•  Status effects framework exists with types BUFF/DEBUFF/CROWD_CONTROL/DAMAGE_OVER_TIME/SPECIAL and factories (poison, stunned, berserk, regeneration) in core/stats/combat_effects.py.

5) Items: current state vs engine
•  Item templates and origin items use many ad-hoc stat names:
◦  base_weapons.json, base_armor.json, origin_items.json include “attack_speed”, “critical_chance”, “strength_requirement”, “defense”, “magic_resistance_minor”, “planar_hazard_resistance”, etc.
•  Equipment to stats wiring:
◦  EquipmentManager builds self._equipment_modifiers from item.stats entries and hands them to StatsManager via sync_equipment_modifiers.
◦  StatsManager normalizes only a tiny synonym set:
▪  'attack_bonus'->'melee_attack', 'atk_bonus'->'melee_attack', 'spell_focus_bonus'->'magic_attack', 'ranged_bonus'->'ranged_attack', 'armor'->'defense', plus a few *save_bonus to primary stats.
◦  If a stat name isn’t recognized by StatType/DerivedStatType.from_string and isn’t in the small synonym map, it is ignored with a warning. That means many item stats today do not take effect at runtime.
•  Typed resistances from items:
◦  Implemented and working: items can contribute custom_properties.typed_resistances per slot; InventoryManager funnels these into StatsManager.set_resistance_contribution.
•  Dice-roll damage on weapons:
◦  Templates carry dice_roll_effects, but attack mechanics rely on CombatAction.dice_notation chosen at runtime; no guaranteed linkage from equipped weapon template to attack dice unless code elsewhere performs that translation.

6) world_configurator Magic Systems editor
•  UI supports:
◦  Basic info fields, Spells tab (SpellDialog with damage/healing/stat_modification/status_effect, dice notation), Race/Class affinities.
•  Not present in editor:
◦  No GUI for casting model, resource model details, chaos/backlash, creativity policy for LLM, or validations against canonical engine stats. No schema-based validation of effect types vs engine enums.

7) Combat config and typed damage
•  config/combat/combat_config.json:
◦  Defines damage.types: slashing, piercing, bludgeoning, fire, cold, lightning, poison, acid, arcane.
◦  Defines typed riders (e.g., fire -> Burning). This integrates with action_handlers where typed_resistances and riders are applied.

Implications and gaps

•  Config/runtime gap for magic:
◦  The spell data authored in magic_systems.json isn’t used when resolving spells in combat. The combat handler expects a prepared action (dice_notation + special_effects). No resolver exists to translate Spell.effect entries into those action fields.
•  Stat normalization gap for items:
◦  Many item.stats names are not recognized by StatsManager; effects don’t apply. Only a few synonyms are handled. Attack speed, critical chance, and many “resistance_*” variants currently do nothing.
•  LLM guardrails and policy:
◦  Agents don’t read magic system policies or curated damage/condition taxonomies. No “creativity policy” or “allowed substitutions” are enforced at runtime. Structured JSON requests exist, but not constrained by your magic data.

Recommendations (no code changes; design alignment)

Short-term alignment
•  Establish the canonical engine-facing vocabularies:
◦  Stats: Use the exact StatType/DerivedStatType lists above.
◦  Damage types: Use those from combat_config.json (slashing, piercing, bludgeoning, fire, cold, lightning, poison, acid, arcane).
◦  Conditions: Start with the ones implemented (Poisoned, Burning, Frozen, Stunned, Bleeding, Defending, Inspired) and any factory-backed conditions you want live.
•  Create a stat registry (data) with alias mapping:
◦  Registry file in config (e.g., config/character/stat_registry.json) defining canonical keys and aliases (e.g., “armor” -> DEFENSE, “critical_chance” -> not supported yet, “attack_speed” -> not supported yet). Use this to:
▪  Drive world_configurator dropdowns and auto-correct entries.
▪  Validate item.stats and magic spell “stat_modification” entries and warn when unmapped.
◦  Document what’s supported now vs future (e.g., crit chance/attack speed are future; today, ignore or park under notes).
•  Define a minimal magic-to-mechanics mapping schema (data):
◦  For each Spell.effect entry in magic_systems.json, constrain to:
▪  effect_type: damage/healing/stat_modification/status_effect
▪  If damage/healing: require dice_notation (or base) and damage_type from combat_config damage.types.
▪  If stat_modification: stat must map to StatType/DerivedStatType from the registry; otherwise warn.
▪  If status_effect: name must be in a known set (e.g., Burning/Stunned/etc.) or tagged as narrative-only.
◦  This enables a deterministic translation layer later.

Medium-term integration concept
•  Introduce a “SpellResolver” design (data-driven):
◦  Input: magic_system_id + spell_id (+ caster, targets).
◦  Output: a CombatAction blueprint with dice_notation, damage_type, and special_effects keyed exactly as action_handlers.py expects (apply_status, etc.).
◦  Resource costs: map spell.mana_cost to stamina/mana deductions already displayed in handlers.
◦  Scaling: optionally map INT/WIS/CHA from class_affinities/required_stats to spell_stat_override used in _handle_spell_action.
•  LLM policy alignment (no code yet):
◦  Add “creativity policy” data to each magic system (allowed substitutions, disallowed themes, leeway). Feed these to CombatNarrator’s system prompt so narrative attempts respect boundaries without changing mechanics.
◦  Optional “Action Planner” agent could propose a legal spell by id; the engine then resolves it via SpellResolver and passes the resulting CombatAction to mechanics.

Items normalization approach
•  In world_configurator:
◦  Bind item.stats names to the registry via a dropdown with aliases. Warn or refuse unknown stats.
◦  For resistances, prefer typed_resistances under custom_properties.typed_resistances with keys restricted to combat_config.damage.types (already integrated).
◦  For unreconciled fields (attack_speed, critical_chance, strength_requirement, range/reach, “magic_resistance_minor”), either:
▪  Map to existing stats (e.g., “armor” -> DEFENSE).
▪  Move to notes/legacy fields until the engine supports them.
•  In item docs (config/items/README.md):
◦  Update examples to use canonical stats where possible (e.g., “defense” should be serialized as DEFENSE via the registry), and steer “damage” to dice_roll_effects + action translation (future step).

What’s already good and can be leveraged
•  Event-driven orchestration is solid; it will accommodate narrative and mechanical steps and delays.
•  Typed resistances pipeline is implemented and data-driven.
•  CombatNarrator produces structured “requests”, so enforcing magic system constraints in prompts/policy is straightforward once policy data exists.

Concrete next steps for you to approve (still no code)
•  Approve the canonical lists (engine truth):
◦  Primary/Derived stats listed above.
◦  Damage types from combat_config.json.
◦  Initial supported conditions: Burning, Poisoned, Frozen, Stunned, Bleeding, Defending, Inspired (plus any you add into combat_config).
•  Approve adding a stat registry JSON (with alias map) and wiring world_configurator to validate and auto-correct item and spell stat names at edit time.
•  Approve a minimal spell schema contract for mechanics:
◦  Require dice_notation or base for damage/heal.
◦  Require damage_type ∈ combat_config.damage.types.
◦  Constrain stat_modification to canonical stats only.
◦  Constrain status_effect to a curated set (or mark as narrative-only).
•  Approve adding “creativity policy” data to each magic system (data only) so LLM prompts can incorporate it later.
```

### File: main.py

```python
#!/usr/bin/env python3
"""
Main entry point for the RPG game.
This script handles initialization and startup of the game in GUI mode.
"""

import sys
import argparse
import logging
from dotenv import load_dotenv # Import load_dotenv

# Import module initializer
from core.base.init_modules import init_modules
# Use centralized logging config
from core.utils.logging_config import setup_logging as core_setup_logging

# Application version
VERSION = "0.1.0"

def setup_logging():
    """Set up logging using the centralized project configuration."""
    core_setup_logging()

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="RPG Game")
    parser.add_argument("--version", action="version", version=f"RPG Game v{VERSION}")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    
    return parser.parse_args()

def main():
    """Main entry point for the game."""
    load_dotenv() # Load environment variables from .env file
    # Parse command line arguments
    args = parse_arguments()
    
    # Set up logging
    setup_logging()
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Log startup information
    logging.info(f"Starting RPG Game v{VERSION}")
    
    # Initialize all game modules
    init_modules()
    
    # GUI mode
    logging.info("Running in GUI mode")
    try:
        # Import the GUI runner
        from run_gui import run_gui
        run_gui()
    except ImportError as e:
        logging.error(f"Failed to import GUI components: {e}")
        print("Error: Could not start GUI mode. See log for details.")
        sys.exit(1)
    except Exception as e:
        logging.exception(f"Error starting GUI: {e}")
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### File: README.md

```markdown
# RPG Text Adventure Game

## Overview

This project is a text-based RPG adventure game framework that combines traditional role-playing elements with modern LLM (Large Language Model) technology. The goal is to create dynamic narratives, interactive characters, and an immersive game world generated and managed with the help of AI.

## Features

*   **Core RPG Gameplay:** Character creation, inventory management, combat system (under development), time system, save/load functionality.
*   **LLM Integration:** Dynamic story generation, NPC interactions, rule checking, and context evaluation powered by configurable LLM providers (OpenAI, Google, OpenRouter).
*   **Graphical User Interface (GUI):** A desktop application built with PySide6 providing a visual way to interact with the game.
*   **Command Line Interface (CLI):** A text-based interface for playing the game in a terminal.
*   **Web Interface:** A web-based frontend (using FastAPI and a simple HTML/JS client) to interact with the game engine remotely.
*   **World Configurator:** A separate tool (also using PySide6) for creating and editing game world data, items, locations, etc.
*   **Modular Design:** Separated components for core logic, UI, configuration, and LLM integration.

## Technology Stack

*   **Language:** Python 3.9+
*   **GUI:** PySide6
*   **Web Framework:** FastAPI
*   **Configuration:** JSON
*   **Core Libraries:** Standard Python libraries

## Project Structure

The project is organized into the following main directories:

*   `config/`: Contains JSON configuration files for game settings, LLM providers, items, locations, etc. ([config/README.md](./config/README.md))
*   `core/`: Houses the core game engine logic, including state management, command processing, LLM integration, character systems, inventory, and utilities. ([core/README.md](./core/README.md))
*   `gui/`: Components for the PySide6-based desktop graphical user interface. ([gui/README.md](./gui/README.md))
*   `web/`: Contains the FastAPI server and basic HTML/JS client for the web interface. ([web/README.md](./web/README.md))
*   `world_configurator/`: The standalone application for editing game world data. ([world_configurator/README.md](./world_configurator/README.md))
*   `tests/`: Unit and integration tests for the project components. ([tests/README.md](./tests/README.md))
*   `images/`: Static image assets used by the GUI and potentially the web interface.
*   `logs/`: Application log files.
*   `saves/`: Default directory for saved game files.
*   `sound/`: Sound effects and music files.

## Setup Instructions

1.  **Clone the Repository:**
    ```bash
    git clone <repository_url>
    cd <repository_directory>
    ```
2.  **Create a Virtual Environment (Recommended):**
    ```bash
    python -m venv venv
    # Activate the environment
    # Windows (cmd.exe):
    venv\Scripts\activate.bat
    # Windows (PowerShell):
    .\venv\Scripts\Activate.ps1
    # Linux/macOS:
    source venv/bin/activate
    ```
3.  **Install Dependencies:**
    The project uses `setup.py`. Install the project and its dependencies in editable mode:
    ```bash
    pip install -e .
    ```
    *Note: The web server component might have additional dependencies listed in `web/server/requirements.txt`. If you plan to run the web server, install those as well:*
    ```bash
    pip install -r web/server/requirements.txt
    ```

## Running the Application

### Main Game (GUI Mode)

This is the primary way to play the game with the graphical interface.

```bash
python run_gui.py
# or
python main.py
```

### Main Game (CLI Mode)

Run the game purely in your terminal.

```bash
python main.py --cli
```

### World Configurator

Run the tool to edit game world data.

```bash
python world_configurator/main.py
```

### Web Interface

Start the FastAPI web server. By default, it runs on `http://localhost:8000`.

```bash
# Ensure you are in the project root directory
uvicorn web.server.server:app --reload --port 8000
```
*Alternatively, you might be able to use `python start_server.py` if it's configured.*

### Running Tests

Navigate to the `tests` directory and use `pytest` (you might need to install it: `pip install pytest`).

```bash
cd tests
pytest
# Or from the root directory:
python -m pytest tests/
```
Refer to `tests/README.md` for more details on testing.

## Configuration

Game settings, LLM API keys, item definitions, and world data are managed through JSON files in the `config/` directory. The LLM settings can also be managed through the GUI or potentially the web interface.

## Development Status

See `checklist.md` for the current development status, planned features, and roadmap.

## License

This project is intended for personal use and learning purposes.

```

### File: config\world\base\cultures.json

```json
{
  "cultures": {
    "concordant": {
      "id": "concordant",
      "name": "The Concordant Cities",
      "description": "A confederation of seven interconnected city-states that sit at major Resonance nodes on the Nexus plane. Their architecture constantly shifts as it incorporates elements from other planes during Resonance Events.",
      "values": [
        {
          "name": "Harmony",
          "description": "Balancing the influences of all planes for the benefit of society.",
          "importance": 9
        },
        {
          "name": "Adaptability",
          "description": "Embracing change brought by Resonance Events rather than fearing it.",
          "importance": 8
        },
        {
          "name": "Knowledge",
          "description": "Understanding the patterns of Resonance to better predict and utilize them.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Attunement",
          "description": "A ritual tattooing process that helps citizens maintain their identity during plane shifts. The tattoos contain geometric patterns representing all five planes.",
          "occasion": "Coming of age (16 years)",
          "significance": "Marks full citizenship and provides protection during Resonance Events."
        },
        {
          "name": "Resonance Festival",
          "description": "A celebration held during major predicted Resonance Events, with music, dance, and temporary markets for cross-planar goods.",
          "occasion": "Major Resonance Events (5-7 times per year)",
          "significance": "Celebrates the unique nature of their fractured world and the opportunities it presents."
        }
      ],
      "language_style": "Formal with many technical terms related to planar phenomena. Contains words and sounds borrowed from all five planes.",
      "naming_conventions": {
        "male": "Melodic names with consonant pairs (Jaedin, Thaerol, Vestrian)",
        "female": "Flowing names with multiple vowels (Aliora, Nyaeve, Seraphine)",
        "places": "Often named after Resonance patterns or Luminary fragments (Harmonium, Echopoint, Luminfall)"
      },
      "common_traits": [
        "Diplomatic",
        "Studious",
        "Pragmatic",
        "Adaptable"
      ]
    },
    "verdant": {
      "id": "verdant",
      "name": "The Verdant Collective",
      "description": "A nature-focused society that primarily exists in the Verdant plane but maintains outposts on Nexus. Their societal roles are seasonal, with individuals changing their functions throughout the year.",
      "values": [
        {
          "name": "Symbiosis",
          "description": "Living in harmony with the natural world and each other.",
          "importance": 10
        },
        {
          "name": "Renewal",
          "description": "Embracing the cycles of growth, death, and rebirth.",
          "importance": 8
        },
        {
          "name": "Community",
          "description": "Prioritizing the needs of the collective over the individual.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Season Shifting",
          "description": "A ceremony where individuals transition to new societal roles based on the changing seasons.",
          "occasion": "Each solstice and equinox",
          "significance": "Ensures that everyone experiences different aspects of their society and prevents stagnation."
        },
        {
          "name": "Green Speech Initiation",
          "description": "A ritual where new members learn the secret language of the collective, composed of plant growth patterns and pheromones.",
          "occasion": "Upon joining the collective or coming of age",
          "significance": "Allows communication that outsiders cannot decode, preserving the collective's secrets."
        }
      ],
      "language_style": "Soft spoken verbal language with many metaphors drawn from plant and animal life. Green Speech is non-verbal and uses pheromones and subtle manipulation of nearby plants.",
      "naming_conventions": {
        "male": "Names derived from plant species or natural phenomena (Alder, Rowan, Brook)",
        "female": "Names derived from flowers or natural elements (Willow, Laurel, Dawn)",
        "places": "Named after ecological features (Deeproot, Sunmeadow, Mistcanopy)"
      },
      "common_traits": [
        "Patient",
        "Communal",
        "Secretive with outsiders",
        "Deeply intuitive"
      ]
    },
    "crystalline": {
      "id": "crystalline",
      "name": "The Crystalline Consortium",
      "description": "A highly ordered society with the most stable presence on the Crystalline plane and trading enclaves on Nexus. Personal worth is measured by one's contribution to mathematical and magical precision.",
      "values": [
        {
          "name": "Order",
          "description": "Maintaining structure, hierarchy, and predictability in all things.",
          "importance": 9
        },
        {
          "name": "Excellence",
          "description": "Striving for perfection in one's specialized field.",
          "importance": 8
        },
        {
          "name": "Legacy",
          "description": "Creating lasting works that will endure through time.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Faceting",
          "description": "A coming-of-age ritual where adolescents receive geometric crystal implants that enhance specific mental abilities.",
          "occasion": "Upon completing academic assessment (typically age 14-16)",
          "significance": "Determines one's specialized role in society and enhances natural talents."
        },
        {
          "name": "Calculation Contest",
          "description": "Annual competition where individuals and teams solve increasingly complex mathematical and magical equations.",
          "occasion": "Mid-winter",
          "significance": "Elevates social standing and determines resource allocation for the coming year."
        }
      ],
      "language_style": "Precise and technical with minimal use of metaphor or ambiguity. Mathematical formulae are often incorporated into everyday speech.",
      "naming_conventions": {
        "male": "Geometric or mineral-based names (Hexar, Obsidian, Quartz)",
        "female": "Gemstone or crystalline structure names (Sapphira, Amethyst, Lattice)",
        "places": "Named after mathematical concepts or crystal formations (Dodecahedron, Fibonacci, Geode)"
      },
      "common_traits": [
        "Methodical",
        "Reserved",
        "Perfectionistic",
        "Specialized"
      ]
    },
    "ashen": {
      "id": "ashen",
      "name": "The Ashen Covenant",
      "description": "Nomadic societies traveling the Ashen plane with temporary settlements on Nexus. Their culture focuses on impermanence and rebirth, with no permanent ownership as possessions rotate through the community.",
      "values": [
        {
          "name": "Impermanence",
          "description": "Accepting that all things eventually end and transform.",
          "importance": 9
        },
        {
          "name": "Memory",
          "description": "Preserving the wisdom and stories of those who came before.",
          "importance": 8
        },
        {
          "name": "Transformation",
          "description": "Embracing change and rebirth as natural and necessary.",
          "importance": 8
        }
      ],
      "traditions": [
        {
          "name": "Dust Keeping",
          "description": "The practice of preserving the ashes of ancestors and using them in rituals to communicate with the dead.",
          "occasion": "Death of community members and monthly remembrance ceremonies",
          "significance": "Maintains connection with ancestors and their wisdom, while honoring the cycle of decay and rebirth."
        },
        {
          "name": "Possession Exchange",
          "description": "Periodic ceremony where all material goods are collected and redistributed among the community.",
          "occasion": "New moon of each month",
          "significance": "Reinforces the concept that nothing is permanently owned, teaches detachment from material possessions."
        }
      ],
      "language_style": "Poetic with many euphemisms, especially regarding death and endings. Words often have multiple context-dependent meanings.",
      "naming_conventions": {
        "male": "Names related to fire or earth (Ember, Coal, Dust)",
        "female": "Names related to transition or cycles (Twilight, Echo, Whisper)",
        "places": "Temporary settlements named for events or omens (Ravenfall, Ashbloom, Veilbreak)"
      },
      "common_traits": [
        "Philosophical",
        "Detached",
        "Spiritual",
        "Resilient"
      ]
    },
    "tempest": {
      "id": "tempest",
      "name": "The Tempest Flotilla",
      "description": "A society constantly moving throughout the chaotic Tempest plane with harbors on Nexus during certain celestial alignments. They adapt rapidly to change with fluid social hierarchies that can transform daily.",
      "values": [
        {
          "name": "Freedom",
          "description": "The right to change and choose one's path without constraint.",
          "importance": 10
        },
        {
          "name": "Opportunity",
          "description": "Seizing chances that arise from chaos and unexpected change.",
          "importance": 8
        },
        {
          "name": "Resilience",
          "description": "Weathering storms both literal and metaphorical with flexibility and strength.",
          "importance": 7
        }
      ],
      "traditions": [
        {
          "name": "Storm Binding",
          "description": "Capturing the essence of Tempest plane storms in tattoos that grant unpredictable magical abilities.",
          "occasion": "When an individual successfully navigates their first major Tempest storm",
          "significance": "Marks true membership in the Flotilla and bestows unique, often chaotic magical gifts."
        },
        {
          "name": "Leadership Flux",
          "description": "A daily ritual where leadership positions are reassigned based on needs and circumstances.",
          "occasion": "Dawn of each day",
          "significance": "Ensures that those best suited to current challenges take command, prevents power entrenchment."
        }
      ],
      "language_style": "Fast-paced with many slang terms that change rapidly. Incorporates sounds mimicking wind and water. Tonal shifts indicate emotional context.",
      "naming_conventions": {
        "male": "Action-oriented names (Surge, Dash, Flint)",
        "female": "Weather or energy-based names (Storm, Spark, Gale)",
        "places": "Named after vessels or weather events (Thunderwake, Squallrider, Maelstrom)"
      },
      "common_traits": [
        "Spontaneous",
        "Bold",
        "Adaptable",
        "Unpredictable"
      ]
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Culture definitions for the RPG game world"
  }
}
```

### File: config\world\base\fundamental_rules.json

```json
{
  "name": "Laws of Aetheris",
  "description": "The fundamental rules that govern how the world of Aetheris operates after The Shattering.",
  "rules": [
    {
      "name": "The Fractured Reality",
      "description": "Aetheris is split into five overlapping planes: Verdant (nature), Crystalline (order), Ashen (decay), Tempest (chaos), and Nexus (the central plane where most inhabitants now dwell).",
      "category": "cosmology",
      "effects": [
        "Most sentient beings live on the Nexus plane, which serves as a crossroads between the other planes",
        "The other planes can be accessed through special portals, during Resonance Events, or through specific magical techniques",
        "Each plane has unique physical laws and resources that influence magic and technology",
        "Time flows slightly differently in each plane, causing travelers to experience temporal distortion"
      ]
    },
    {
      "name": "Resonance Events",
      "description": "Periodic and partly predictable occurrences where planes temporarily merge, causing landscapes, creatures, and cultures to blend before separating again.",
      "category": "planar phenomenon",
      "effects": [
        "Minor Resonance Events are common and localized, affecting small areas",
        "Major Resonance Events are rarer and can transform entire regions",
        "The Resonance Calendar predicts many events, but anomalies are increasing",
        "Beings caught during Resonance Events may be altered or merged with alternate versions of themselves",
        "Some areas become 'Planar Bleed Zones' where the merger becomes permanent"
      ]
    },
    {
      "name": "The Luminaries",
      "description": "Once-unified cosmic entities who maintained balance before The Shattering, now fragmented across the planes. Their fragments still influence reality.",
      "category": "divine",
      "effects": [
        "Luminary fragments manifest as powerful artifacts with reality-altering properties",
        "The Five Speakers can hear and interpret the will of specific Luminaries",
        "Divine magic draws power from Luminary fragments rather than unified deities",
        "Collecting multiple fragments increases power but risks instability",
        "Some fragments have developed sentience and their own agendas"
      ]
    },
    {
      "name": "Planar Affinity",
      "description": "All beings have natural affinities for specific planes, influencing their abilities, temperament, and magical talent.",
      "category": "biology",
      "effects": [
        "Birth location and lineage determine initial planar affinity",
        "Exposure to different planes can gradually shift one's affinity",
        "Magic is easier to perform when aligned with one's planar affinity",
        "Some individuals (Resonance-touched) have multiple affinities",
        "Certain races evolved specific adaptations to their primary plane"
      ]
    },
    {
      "name": "Magical Resonance",
      "description": "Magic in Aetheris is shaped by The Shattering, manifesting differently in each plane and requiring specific techniques based on planar alignment.",
      "category": "magic",
      "effects": [
        "Traditional spellcasting is unreliable across planar boundaries",
        "Song Weaving is the most ancient and stable form of cross-planar magic",
        "Each plane has a signature magical style (e.g., Facet Magic in Crystalline)",
        "Magical education typically focuses on a planar specialty",
        "The most powerful magic often requires components from multiple planes"
      ]
    },
    {
      "name": "Planar Resources",
      "description": "Each plane produces unique materials and resources essential for advanced magic, technology, and medicine.",
      "category": "economy",
      "effects": [
        "Verdant Plane: Living materials, adaptive plant matter, medicinal components",
        "Crystalline Plane: Perfect geometric minerals, resonance crystals, timekeeping devices",
        "Ashen Plane: Memory metals, preservative compounds, spectral essences",
        "Tempest Plane: Energy condensates, probability alloys, chaos crystals",
        "Nexus Plane: Planar binding agents, stabilizing compounds, universal catalysts"
      ]
    }
  ]
}
```

### File: config\world\base\magic_systems.json

```json
{
  "magic_systems": {
    "song_weaving": {
      "id": "song_weaving",
      "name": "Song Weaving",
      "description": "The most ancient form of magic, predating The Shattering. Practitioners create effects through specific melodies and harmonies rather than formal spellcasting.",
      "origin": "Song Weaving is the original form of magic used in Aetheris before The Shattering. It was taught directly by the Luminaries to the first inhabitants of the world, who discovered that certain melodies could tap into the natural magical currents that flowed through the land.",
      "limitations": "Requires vocal ability and musical aptitude. Effects are weaker when performed solo rather than in a group. Cannot be performed silently. Some complex effects require specific musical instruments as foci.",
      "practitioners": "Most commonly practiced among Elves, who have maintained the ancient traditions, and Maelstri, who naturally resonate with the harmonic frequencies. However, any race with sufficient musical talent can learn its basics.",
      "cultural_significance": "Song Weaving is revered as the purest form of magic, especially among older cultures. Annual music festivals in the Concordant Cities often feature Song Weaving performances, and the most skilled practitioners are highly respected across all planes.",
      "racial_affinities": {
        "Elf": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "10% increased potency of all Song Weaving spells"
        },
        "Maelstri": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "Can maintain Song Weaving effects 25% longer than other races"
        },
        "Human": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Mage": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "required_stats": {
            "INT": 12,
            "CHA": 10
          }
        },
        "Cleric": {
          "affinity_level": "High",
          "learning_difficulty": "Easy",
          "required_stats": {
            "WIS": 12,
            "CHA": 10
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "CHA": 12
          }
        },
        "Ranger": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "WIS": 12,
            "CHA": 8
          }
        },
        "Rogue": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "required_stats": {
            "CHA": 14
          }
        },
        "Warrior": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "CHA": 14,
            "INT": 10
          }
        }
      },
      "spells": {
        "harmonic_healing": {
          "id": "harmonic_healing",
          "name": "Harmonic Healing",
          "description": "A soothing melody that accelerates natural healing processes in the target.",
          "mana_cost": 15,
          "casting_time": "10 seconds",
          "range": "5m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 20.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "2d6+8",
              "description": "Immediate healing of wounds and ailments"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "HP Regeneration",
              "status_effect": "",
              "duration": 3,
              "dice_notation": "",
              "description": "Accelerated natural healing for a short duration"
            }
          ],
          "level": 2,
          "components": [
            "voice",
            "focus"
          ],
          "tags": [
            "healing",
            "regeneration",
            "restoration"
          ]
        },
        "resonant_shield": {
          "id": "resonant_shield",
          "name": "Resonant Shield",
          "description": "Creates a barrier of sound waves that deflects incoming attacks.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Sound waves deflect physical and magical attacks"
            }
          ],
          "level": 2,
          "components": [
            "voice",
            "gesture"
          ],
          "tags": [
            "protection",
            "defense",
            "sound"
          ]
        },
        "chorus_of_clarity": {
          "id": "chorus_of_clarity",
          "name": "Chorus of Clarity",
          "description": "A harmonizing melody that clears the mind and enhances perception.",
          "mana_cost": 10,
          "casting_time": "5 seconds",
          "range": "10m",
          "target": "multiple",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "INT",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Temporarily enhances intellectual capabilities"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "WIS",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Temporarily enhances perceptive capabilities"
            }
          ],
          "level": 1,
          "components": [
            "voice",
            "concentration"
          ],
          "tags": [
            "enhancement",
            "mind",
            "perception"
          ]
        },
        "dirge_of_despair": {
          "id": "dirge_of_despair",
          "name": "Dirge of Despair",
          "description": "A haunting melody that instills dread and weakens resolve.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "15m",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -2.0,
              "stat_affected": "CHA",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Weakens social presence and confidence"
            },
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Frightened",
              "duration": 3,
              "dice_notation": "",
              "description": "Targets feel a deep sense of dread and fear"
            }
          ],
          "level": 3,
          "components": [
            "voice",
            "gesture",
            "concentration"
          ],
          "tags": [
            "debuff",
            "fear",
            "control"
          ]
        },
        "planar_harmonization": {
          "id": "planar_harmonization",
          "name": "Planar Harmonization",
          "description": "A complex melody that resonates with the natural frequencies of different planes, facilitating travel and communication between them.",
          "mana_cost": 40,
          "casting_time": "1 minute",
          "range": "30m",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Planar Resonance",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Enhances ability to perceive and interact with planar energies"
            }
          ],
          "level": 5,
          "components": [
            "voice",
            "instrument",
            "focus",
            "concentration"
          ],
          "tags": [
            "planar",
            "utility",
            "ritual"
          ]
        },
        "song_of_mending": {
          "id": "song_of_mending",
          "name": "Song of Mending",
          "description": "A gentle tune that repairs physical objects and mends broken items.",
          "mana_cost": 15,
          "casting_time": "30 seconds",
          "range": "5m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 30.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "",
              "description": "Repairs damage to a non-living object"
            }
          ],
          "level": 2,
          "components": [
            "voice",
            "focus"
          ],
          "tags": [
            "utility",
            "restoration",
            "crafting"
          ]
        }
      }
    },
    "planar_anchoring": {
      "id": "planar_anchoring",
      "name": "Planar Anchoring",
      "description": "The art of maintaining stability during Resonance Events. Practitioners can extend areas of stability or purposefully blur planar boundaries.",
      "origin": "Planar Anchoring emerged shortly after The Shattering as a necessity for survival. The Harmonic Order developed these techniques to protect settlements when the planes would temporarily merge, preventing catastrophic destruction.",
      "limitations": "Requires physical components from multiple planes. Creates significant mental strain on the caster, with prolonged use potentially causing 'planar sickness' - a condition where the practitioner begins to exist partially in multiple planes simultaneously.",
      "practitioners": "Primarily used by the Harmonic Order as part of their duty to protect settlements during Resonance Events. It is also practiced by planar researchers and certain specialized mages who study the boundaries between realities.",
      "cultural_significance": "Planar Anchors are highly respected in all societies, as they serve as protectors during dangerous Resonance Events. In the Concordant Cities, they hold positions of authority and are often consulted on matters of planar significance.",
      "racial_affinities": {
        "Human": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can maintain anchoring effects 20% longer than other races"
        },
        "Prismal": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "15% reduced mana cost for planar anchoring spells"
        },
        "Maelstri": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can detect planar instabilities within 50m radius"
        },
        "Elf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Mage": {
          "affinity_level": "Very High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "INT": 14,
            "WIS": 10
          }
        },
        "Cleric": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 10
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 12,
            "WIS": 12
          }
        },
        "Ranger": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 12
          }
        },
        "Rogue": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14,
            "DEX": 14
          }
        },
        "Warrior": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "required_stats": {
            "INT": 14,
            "CON": 14,
            "WIS": 10
          }
        }
      },
      "spells": {
        "stability_field": {
          "id": "stability_field",
          "name": "Stability Field",
          "description": "Creates a field where planar fluctuations are suppressed, providing safety during Resonance Events.",
          "mana_cost": 30,
          "casting_time": "30 seconds",
          "range": "20m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Planar Stability",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Maintains the current plane's physics and prevents planar bleeding"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 3.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "The stability field provides minor protection against normal attacks as well"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "focus",
            "planar components"
          ],
          "tags": [
            "protection",
            "planar",
            "area effect"
          ]
        },
        "reality_tether": {
          "id": "reality_tether",
          "name": "Reality Tether",
          "description": "Anchors a person or object to their home plane, protecting them from planar shifts and dimensional effects.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -10.0,
              "stat_affected": "Planar Resonance",
              "status_effect": "",
              "duration": 60,
              "dice_notation": "",
              "description": "Reduces susceptibility to planar effects and dimensional displacement"
            }
          ],
          "level": 2,
          "components": [
            "touch",
            "focus",
            "crystalline dust"
          ],
          "tags": [
            "protection",
            "planar",
            "anchoring"
          ]
        },
        "planar_sight": {
          "id": "planar_sight",
          "name": "Planar Sight",
          "description": "Grants the ability to see planar boundaries, resonance patterns, and entities from other planes that might otherwise be invisible.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Perception",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Allows visibility of planar boundaries and cross-planar entities"
            }
          ],
          "level": 2,
          "components": [
            "gesture",
            "prismatic lens"
          ],
          "tags": [
            "divination",
            "planar",
            "perception"
          ]
        },
        "boundary_distortion": {
          "id": "boundary_distortion",
          "name": "Boundary Distortion",
          "description": "Temporarily weakens planar boundaries in a small area, allowing for partial merging of planes or extraction of planar energy.",
          "mana_cost": 35,
          "casting_time": "1 minute",
          "range": "10m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -20.0,
              "stat_affected": "Planar Stability",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Creates a controlled destabilization of planar boundaries"
            }
          ],
          "level": 4,
          "components": [
            "gesture",
            "focus",
            "components from target plane",
            "ritual circle"
          ],
          "tags": [
            "planar",
            "manipulation",
            "advanced"
          ]
        },
        "resonance_shield": {
          "id": "resonance_shield",
          "name": "Resonance Shield",
          "description": "Creates a personal barrier that absorbs planar energy and harmful resonance effects.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Planar Resistance",
              "status_effect": "",
              "duration": 20,
              "dice_notation": "",
              "description": "Provides immunity to harmful effects from planar resonance and instability"
            },
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Magic Resistance",
              "status_effect": "",
              "duration": 20,
              "dice_notation": "",
              "description": "The shield also provides some protection against conventional magic"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "focus",
            "resonant crystal"
          ],
          "tags": [
            "protection",
            "planar",
            "defensive"
          ]
        },
        "planar_transit": {
          "id": "planar_transit",
          "name": "Planar Transit",
          "description": "Creates a stable corridor between planes, allowing safe passage for a short time. Only works between planes currently in resonance.",
          "mana_cost": 50,
          "casting_time": "5 minutes",
          "range": "5m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Planar Transit",
              "duration": 10,
              "dice_notation": "",
              "description": "Creates a controlled passage between planes in resonance"
            }
          ],
          "level": 5,
          "components": [
            "gesture",
            "focus",
            "planar essence",
            "ritual circle",
            "resonance map"
          ],
          "tags": [
            "planar",
            "travel",
            "advanced",
            "ritual"
          ]
        }
      }
    },
    "echo_binding": {
      "id": "echo_binding",
      "name": "Echo Binding",
      "description": "The art of capturing 'echoes' - residual effects from other planes that linger after Resonance Events - and binding them to objects or people to grant temporary planar properties.",
      "origin": "Echo Binding emerged from the opportunistic practices of scavengers who frequented areas after Resonance Events. They discovered that certain residual energies could be captured and preserved for later use, eventually developing sophisticated techniques to harness these 'echoes'.",
      "limitations": "Requires fresh echoes from recent Resonance Events. Prolonged use can cause 'planar bleeding' - uncontrolled manifestations of other planes. The practice is somewhat unstable; effects can be unpredictable if not properly controlled.",
      "practitioners": "Popular among independent magical practitioners, merchants specializing in unique magical items, and adventurers who need versatile magical effects without formal training. The Mercantile Chord employs many Echo Binders to create valuable cross-planar goods.",
      "cultural_significance": "Viewed with mixed opinions across cultures. Some see it as a practical adaptation to the post-Shattering world, while others consider it dangerous tampering with forces that should be left alone. There's a growing black market for illegal echo harvesting, particularly from dangerous or forbidden planes.",
      "racial_affinities": {
        "Human": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can identify echo properties 25% more accurately than other races"
        },
        "Halfling": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Echo bindings last 15% longer when created by Halflings"
        },
        "Maelstri": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "Can naturally sense echoes within 30m radius"
        },
        "Elf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Low",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Rogue": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "required_stats": {
            "DEX": 12,
            "INT": 10
          }
        },
        "Mage": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "INT": 12,
            "DEX": 10
          }
        },
        "Wanderer": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "DEX": 12,
            "INT": 10
          }
        },
        "Ranger": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "DEX": 12,
            "WIS": 12
          }
        },
        "Cleric": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 12
          }
        },
        "Warrior": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "STR": 14,
            "DEX": 12
          }
        }
      },
      "spells": {
        "echo_capture": {
          "id": "echo_capture",
          "name": "Echo Capture",
          "description": "Captures a lingering planar echo and stores it temporarily for later use.",
          "mana_cost": 15,
          "casting_time": "30 seconds",
          "range": "5m",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Echo Contained",
              "duration": 60,
              "dice_notation": "",
              "description": "Captures a planar echo for later binding"
            }
          ],
          "level": 1,
          "components": [
            "gesture",
            "echo vessel",
            "focusing crystal"
          ],
          "tags": [
            "utility",
            "planar",
            "gathering"
          ]
        },
        "bind_echo": {
          "id": "bind_echo",
          "name": "Bind Echo",
          "description": "Binds a captured echo to an object or person, transferring its planar properties.",
          "mana_cost": 20,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Planar Essence",
              "status_effect": "",
              "duration": 120,
              "dice_notation": "",
              "description": "Transfers captured echo properties to the target"
            }
          ],
          "level": 2,
          "components": [
            "gesture",
            "captured echo",
            "binding agent"
          ],
          "tags": [
            "enchantment",
            "planar",
            "binding"
          ]
        },
        "echo_sight": {
          "id": "echo_sight",
          "name": "Echo Sight",
          "description": "Grants the ability to see lingering echoes and assess their properties and potential uses.",
          "mana_cost": 10,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Echo Perception",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Allows visibility of planar echoes and understanding of their properties"
            }
          ],
          "level": 1,
          "components": [
            "gesture",
            "residue sample"
          ],
          "tags": [
            "divination",
            "planar",
            "perception"
          ]
        },
        "weapon_echo": {
          "id": "weapon_echo",
          "name": "Weapon Echo",
          "description": "Binds a combat-oriented echo to a weapon, granting it planar offensive properties.",
          "mana_cost": 25,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 6.0,
              "stat_affected": "Damage",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Adds planar damage to weapon attacks"
            },
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Planar Disruption",
              "duration": 3,
              "dice_notation": "",
              "description": "Weapon attacks can disrupt planar abilities of targets"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "combat echo",
            "binding agent",
            "weapon"
          ],
          "tags": [
            "combat",
            "enhancement",
            "planar"
          ]
        },
        "echo_ward": {
          "id": "echo_ward",
          "name": "Echo Ward",
          "description": "Creates a protective barrier using protective echoes, shielding against both physical and planar threats.",
          "mana_cost": 30,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 7.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 60,
              "dice_notation": "",
              "description": "Protects against physical attacks"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 12.0,
              "stat_affected": "Planar Resistance",
              "status_effect": "",
              "duration": 60,
              "dice_notation": "",
              "description": "Protects against planar effects and energies"
            }
          ],
          "level": 3,
          "components": [
            "gesture",
            "protective echo",
            "binding circle"
          ],
          "tags": [
            "protection",
            "defensive",
            "planar"
          ]
        },
        "echo_mimicry": {
          "id": "echo_mimicry",
          "name": "Echo Mimicry",
          "description": "Binds an entity echo to the caster, temporarily granting traits, abilities, or appearance of creatures from other planes.",
          "mana_cost": 40,
          "casting_time": "2 minutes",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 8.0,
              "stat_affected": "Varied",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Grants traits and abilities based on the specific echo bound"
            },
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Echo Transformation",
              "duration": 30,
              "dice_notation": "",
              "description": "Physically transforms aspects of the caster to match the echo source"
            }
          ],
          "level": 4,
          "components": [
            "gesture",
            "entity echo",
            "binding agent",
            "personal focus"
          ],
          "tags": [
            "transformation",
            "planar",
            "mimicry"
          ]
        }
      }
    },
    "facet_magic": {
      "id": "facet_magic",
      "name": "Facet Magic",
      "description": "A precise form of magic developed by the Crystalline Consortium that uses geometric crystals to channel and focus magical energies with mathematical precision.",
      "origin": "Facet Magic was developed in the Crystalline plane after The Shattering. The Prismals, with their natural crystalline bodies, discovered they could channel magical energies through precisely cut geometric forms, leading to a highly structured and mathematical approach to spellcasting.",
      "limitations": "Requires precisely cut crystals as foci, with different shapes producing different effects. Demands mathematical precision and calculation. Less effective in chaotic environments or when crystals are damaged. Requires significant preparation and is difficult to use spontaneously.",
      "practitioners": "Primarily used by members of the Crystalline Consortium, especially Prismals and mathematically-inclined humans and dwarves. Requires formal education in crystalline geometry and facet theory, making it inaccessible to those without proper training.",
      "cultural_significance": "Facet Magic is seen as the most 'civilized' and scholarly form of magic within the Crystalline Consortium. Practitioners are viewed as elite intellectuals, and the precision of one's faceted crystals is a status symbol. Those who master this art often receive the honorific 'Facet' before their name.",
      "racial_affinities": {
        "Prismal": {
          "affinity_level": "Very High",
          "learning_difficulty": "Very Easy",
          "natural_talent": true,
          "bonus_effects": "20% reduced mana cost for all Facet Magic spells"
        },
        "Dwarf": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Facet crystals crafted by Dwarves last 30% longer before needing recalibration"
        },
        "Human": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Elf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Maelstri": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Mage": {
          "affinity_level": "Very High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "INT": 14
          }
        },
        "Cleric": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 12,
            "WIS": 12
          }
        },
        "Rogue": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 12,
            "DEX": 12
          }
        },
        "Warrior": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14,
            "STR": 12
          }
        },
        "Ranger": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14,
            "DEX": 12
          }
        },
        "Wanderer": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "INT": 14
          }
        }
      },
      "spells": {
        "prismatic_bolt": {
          "id": "prismatic_bolt",
          "name": "Prismatic Bolt",
          "description": "Creates a beam of concentrated light energy that strikes with geometric precision.",
          "mana_cost": 15,
          "casting_time": "1 action",
          "range": "30m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "damage",
              "value": 25.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "3d8+4",
              "description": "Pure light energy strikes the target with unerring accuracy"
            }
          ],
          "level": 2,
          "components": [
            "octahedral crystal",
            "gesture",
            "calculation"
          ],
          "tags": [
            "attack",
            "precision",
            "light"
          ]
        },
        "crystalline_shield": {
          "id": "crystalline_shield",
          "name": "Crystalline Shield",
          "description": "Forms a perfect geometric barrier of faceted energy that absorbs damage.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 8.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Creates a perfectly calculated defensive barrier"
            }
          ],
          "level": 2,
          "components": [
            "cubic crystal",
            "gesture"
          ],
          "tags": [
            "protection",
            "defensive",
            "barrier"
          ]
        },
        "computational_enhancement": {
          "id": "computational_enhancement",
          "name": "Computational Enhancement",
          "description": "Enhances mental faculties through crystalline resonance with the brain's natural patterns.",
          "mana_cost": 25,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 4.0,
              "stat_affected": "INT",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Temporarily boosts intellectual capacity and computational ability"
            }
          ],
          "level": 3,
          "components": [
            "dodecahedral crystal",
            "mental calculation",
            "touch"
          ],
          "tags": [
            "enhancement",
            "mental",
            "intellect"
          ]
        },
        "perfect_analysis": {
          "id": "perfect_analysis",
          "name": "Perfect Analysis",
          "description": "Uses crystalline resonance to perfectly analyze an object, creature, or phenomenon.",
          "mana_cost": 15,
          "casting_time": "1 minute",
          "range": "5m",
          "target": "single",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 20.0,
              "stat_affected": "Knowledge",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Grants precise information about the target's composition, properties, and nature"
            }
          ],
          "level": 2,
          "components": [
            "tetrahedral crystal",
            "concentration",
            "calculation"
          ],
          "tags": [
            "divination",
            "knowledge",
            "analysis"
          ]
        },
        "geometric_restructuring": {
          "id": "geometric_restructuring",
          "name": "Geometric Restructuring",
          "description": "Manipulates the physical structure of non-living matter by precisely realigning its internal geometry.",
          "mana_cost": 30,
          "casting_time": "5 minutes",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 40.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "",
              "description": "Repairs and restructures non-living matter according to precise calculations"
            }
          ],
          "level": 3,
          "components": [
            "icosahedral crystal",
            "geometric diagram",
            "touch",
            "calculation"
          ],
          "tags": [
            "transmutation",
            "repair",
            "crafting"
          ]
        },
        "crystal_prison": {
          "id": "crystal_prison",
          "name": "Crystal Prison",
          "description": "Encases the target in a perfect crystalline structure that restricts movement.",
          "mana_cost": 35,
          "casting_time": "1 action",
          "range": "15m",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Restrained",
              "duration": 5,
              "dice_notation": "",
              "description": "Target is encased in a precisely calculated crystalline structure"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -5.0,
              "stat_affected": "DEX",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Crystal severely restricts movement"
            }
          ],
          "level": 4,
          "components": [
            "cubic crystal",
            "gesture",
            "calculation"
          ],
          "tags": [
            "control",
            "restraint",
            "crystal"
          ]
        }
      }
    },
    "ash_walking": {
      "id": "ash_walking",
      "name": "Ash Walking",
      "description": "A unique form of magic from the Ashen plane that allows practitioners to temporarily transfer their consciousness into the Ashen plane for communication, espionage, and retrieving lost knowledge.",
      "origin": "Ash Walking developed among the nomadic societies of the Ashen plane as a means of maintaining communication across vast distances. After The Shattering, the Cinderspawn refined these techniques into a formal magical practice that allows consciousness to slip between the boundaries of physical existence.",
      "limitations": "Extended use causes physical body to gradually turn to ash. Risk of becoming lost in the Ashen plane increases with duration. Requires absolute concentration, making it vulnerable to interruption. Cannot interact physically with the material world while consciousness is transferred.",
      "practitioners": "Primarily practiced by members of the Ashen Covenant, especially Cinderspawn who have a natural affinity for the practice. Some secretive groups like assassins guilds have adopted modified versions for espionage purposes.",
      "cultural_significance": "Among the Ashen Covenant, Ash Walking is considered sacred, used in important ceremonies to commune with ancestors. Outside these communities, it is often viewed with suspicion or fear, associated with death magic and necromancy, though this is a misunderstanding of its true nature.",
      "racial_affinities": {
        "Cinderspawn": {
          "affinity_level": "Very High",
          "learning_difficulty": "Very Easy",
          "natural_talent": true,
          "bonus_effects": "Can maintain Ash Walking 50% longer without physical degradation"
        },
        "Orc": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": true,
          "bonus_effects": "15% increased perception while Ash Walking"
        },
        "Human": {
          "affinity_level": "Medium",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Elf": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Dwarf": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Mycora": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Maelstri": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Rogue": {
          "affinity_level": "Very High",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "DEX": 12,
            "WIS": 12
          }
        },
        "Mage": {
          "affinity_level": "High",
          "learning_difficulty": "Hard",
          "required_stats": {
            "INT": 14,
            "WIS": 12
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 14
          }
        },
        "Cleric": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 14,
            "CON": 12
          }
        },
        "Ranger": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "DEX": 12
          }
        },
        "Warrior": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "required_stats": {
            "WIS": 14,
            "CON": 14
          }
        }
      },
      "spells": {
        "minor_projection": {
          "id": "minor_projection",
          "name": "Minor Projection",
          "description": "Temporarily transfers a small portion of consciousness into the Ashen plane, allowing limited perception beyond physical barriers.",
          "mana_cost": 10,
          "casting_time": "30 seconds",
          "range": "50m",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ash Perception",
              "duration": 5,
              "dice_notation": "",
              "description": "Allows perception through solid objects within range"
            }
          ],
          "level": 1,
          "components": [
            "pinch of ash",
            "concentration"
          ],
          "tags": [
            "perception",
            "divination",
            "espionage"
          ]
        },
        "ashen_transit": {
          "id": "ashen_transit",
          "name": "Ashen Transit",
          "description": "Fully transfers consciousness into the Ashen plane, leaving the physical body in a trance-like state.",
          "mana_cost": 25,
          "casting_time": "1 minute",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ash Walking",
              "duration": 15,
              "dice_notation": "",
              "description": "Consciousness fully transfers to the Ashen plane"
            },
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": -10.0,
              "stat_affected": "Physical Defense",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Physical body is vulnerable while consciousness is elsewhere"
            }
          ],
          "level": 3,
          "components": [
            "handful of ashes",
            "ritual circle",
            "concentration"
          ],
          "tags": [
            "transportation",
            "planar",
            "espionage"
          ]
        },
        "whispers_of_ash": {
          "id": "whispers_of_ash",
          "name": "Whispers of Ash",
          "description": "Allows communication through the Ashen plane to another individual, regardless of distance, so long as both parties have access to ash from the same source.",
          "mana_cost": 15,
          "casting_time": "1 minute",
          "range": "unlimited",
          "target": "single",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ash Communication",
              "duration": 10,
              "dice_notation": "",
              "description": "Establishes a mental link through the Ashen plane"
            }
          ],
          "level": 2,
          "components": [
            "shared ash source",
            "concentration"
          ],
          "tags": [
            "communication",
            "utility",
            "social"
          ]
        },
        "ashen_knowledge": {
          "id": "ashen_knowledge",
          "name": "Ashen Knowledge",
          "description": "Accesses the collective memory of the Ashen plane to retrieve lost or forgotten knowledge about a specific subject or location.",
          "mana_cost": 30,
          "casting_time": "10 minutes",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 15.0,
              "stat_affected": "Knowledge",
              "status_effect": "",
              "duration": 1,
              "dice_notation": "",
              "description": "Grants specific knowledge about a subject from the collective memory of the Ashen plane"
            }
          ],
          "level": 4,
          "components": [
            "ash from location or subject",
            "ritual circle",
            "concentration",
            "meditation"
          ],
          "tags": [
            "knowledge",
            "divination",
            "history"
          ]
        },
        "ash_veil": {
          "id": "ash_veil",
          "name": "Ash Veil",
          "description": "Creates a cloud of animate ash that obscures vision and can be mentally controlled by the caster.",
          "mana_cost": 20,
          "casting_time": "1 action",
          "range": "15m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": -10.0,
              "stat_affected": "Perception",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Reduces visibility and sensory perception in the affected area"
            }
          ],
          "level": 2,
          "components": [
            "handful of ashes",
            "gesture"
          ],
          "tags": [
            "concealment",
            "control",
            "defense"
          ]
        },
        "ashen_body": {
          "id": "ashen_body",
          "name": "Ashen Body",
          "description": "Temporarily transforms the caster's physical form into ash, allowing them to flow through small openings and resist physical damage.",
          "mana_cost": 35,
          "casting_time": "1 action",
          "range": "self",
          "target": "self",
          "effects": [
            {
              "target_type": "caster",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Ashen Form",
              "duration": 5,
              "dice_notation": "",
              "description": "Physical body becomes partially incorporeal ash"
            },
            {
              "target_type": "caster",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Physical Resistance",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Significantly reduces damage from physical attacks"
            }
          ],
          "level": 4,
          "components": [
            "ritual ashes",
            "gesture",
            "concentration"
          ],
          "tags": [
            "transformation",
            "defense",
            "movement"
          ]
        }
      }
    },
    "divine_healing": {
      "id": "divine_healing",
      "name": "Divine Healing",
      "description": "A sacred form of magic that channels divine energy to heal wounds, cure ailments, and restore life force. While healing effects can be achieved through other magical systems, Divine Healing is specifically focused on restoration and protection through spiritual connection.",
      "origin": "Divine Healing predates The Shattering, stemming from the earliest spiritual practices across all planes. After the cosmic trauma of The Shattering, these healing traditions became even more vital, with practitioners developing formalized methods to channel divine energies from fragmented Luminaries.",
      "limitations": "Requires genuine spiritual conviction or connection. Effectiveness is reduced when used for selfish purposes. Cannot typically restore life to the truly dead. More severe injuries require greater spiritual energy and preparation. Some ailments require specific divine connections or rituals.",
      "practitioners": "Most commonly practiced by clerics and spiritual leaders, though anyone with sufficient faith and training can learn its basics. The most powerful practitioners are those who maintain a deep connection with the fragmented Luminaries or other divine entities.",
      "cultural_significance": "Healing practitioners are highly respected in all societies, often serving both spiritual and medical roles in their communities. In many cultures, significant healing rituals mark important life transitions and community events. The ability to heal is seen as one of the most noble uses of magic.",
      "racial_affinities": {
        "Mycora": {
          "affinity_level": "Very High",
          "learning_difficulty": "Easy",
          "natural_talent": true,
          "bonus_effects": "Healing spells are 25% more effective when cast by Mycora"
        },
        "Human": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can sense injuries and ailments within 10m radius"
        },
        "Elf": {
          "affinity_level": "High",
          "learning_difficulty": "Moderate",
          "natural_talent": true,
          "bonus_effects": "Can maintain healing effects 20% longer than other races"
        },
        "Dwarf": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Halfling": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Orc": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Prismal": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Cinderspawn": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        },
        "Maelstri": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "natural_talent": false,
          "bonus_effects": null
        }
      },
      "class_affinities": {
        "Cleric": {
          "affinity_level": "Very High",
          "learning_difficulty": "Very Easy",
          "required_stats": {
            "WIS": 10
          }
        },
        "Wanderer": {
          "affinity_level": "Medium",
          "learning_difficulty": "Moderate",
          "required_stats": {
            "WIS": 12,
            "CHA": 10
          }
        },
        "Ranger": {
          "affinity_level": "Medium",
          "learning_difficulty": "Hard",
          "required_stats": {
            "WIS": 12
          }
        },
        "Mage": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "INT": 12
          }
        },
        "Warrior": {
          "affinity_level": "Low",
          "learning_difficulty": "Very Hard",
          "required_stats": {
            "WIS": 14,
            "CHA": 12
          }
        },
        "Rogue": {
          "affinity_level": "Very Low",
          "learning_difficulty": "Extremely Hard",
          "required_stats": {
            "WIS": 14,
            "CHA": 12
          }
        }
      },
      "spells": {
        "healing_touch": {
          "id": "healing_touch",
          "name": "Healing Touch",
          "description": "Channels divine energy through the caster's hands to heal wounds and injuries.",
          "mana_cost": 15,
          "casting_time": "1 action",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 25.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "2d8+10",
              "description": "Immediate healing of physical wounds and injuries"
            }
          ],
          "level": 2,
          "components": [
            "touch",
            "prayer",
            "focus"
          ],
          "tags": [
            "healing",
            "restoration",
            "touch"
          ]
        },
        "purify_body": {
          "id": "purify_body",
          "name": "Purify Body",
          "description": "Cleanses the body of disease, poison, and other harmful substances through divine intervention.",
          "mana_cost": 20,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Purified",
              "duration": 0,
              "dice_notation": "",
              "description": "Removes disease, poison, and other harmful conditions"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "CON",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Temporarily enhances physical resilience"
            }
          ],
          "level": 3,
          "components": [
            "touch",
            "prayer",
            "holy water",
            "focus"
          ],
          "tags": [
            "purification",
            "restoration",
            "protection"
          ]
        },
        "divine_restoration": {
          "id": "divine_restoration",
          "name": "Divine Restoration",
          "description": "A powerful healing spell that mends severe injuries, regenerates damaged tissue, and restores vitality.",
          "mana_cost": 35,
          "casting_time": "5 minutes",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 50.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "4d10+20",
              "description": "Comprehensive healing of major wounds and injuries"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "HP Regeneration",
              "status_effect": "",
              "duration": 10,
              "dice_notation": "",
              "description": "Enhances natural healing for a period of time"
            }
          ],
          "level": 4,
          "components": [
            "touch",
            "ritual prayer",
            "holy symbol",
            "focus",
            "sacred herbs"
          ],
          "tags": [
            "healing",
            "restoration",
            "regeneration"
          ]
        },
        "circle_of_healing": {
          "id": "circle_of_healing",
          "name": "Circle of Healing",
          "description": "Creates a sacred circle that radiates healing energy to all within its bounds.",
          "mana_cost": 30,
          "casting_time": "1 minute",
          "range": "10m radius",
          "target": "area",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "healing",
              "value": 15.0,
              "stat_affected": "",
              "status_effect": "",
              "duration": 0,
              "dice_notation": "2d6+5",
              "description": "Immediate healing to all within the circle"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 2.0,
              "stat_affected": "HP Regeneration",
              "status_effect": "",
              "duration": 5,
              "dice_notation": "",
              "description": "Enhances natural healing while within the circle"
            }
          ],
          "level": 3,
          "components": [
            "ritual circle",
            "group prayer",
            "holy symbol"
          ],
          "tags": [
            "healing",
            "area effect",
            "support"
          ]
        },
        "protective_blessing": {
          "id": "protective_blessing",
          "name": "Protective Blessing",
          "description": "Invokes divine protection to shield the target from harm and enhance their resilience.",
          "mana_cost": 25,
          "casting_time": "1 action",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Defense",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Divine energy creates a protective barrier against harm"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 5.0,
              "stat_affected": "Magic Resistance",
              "status_effect": "",
              "duration": 15,
              "dice_notation": "",
              "description": "Enhances resistance to harmful magical effects"
            }
          ],
          "level": 3,
          "components": [
            "touch",
            "prayer",
            "holy symbol"
          ],
          "tags": [
            "protection",
            "defensive",
            "blessing"
          ]
        },
        "revitalize": {
          "id": "revitalize",
          "name": "Revitalize",
          "description": "Restores energy and vitality to the exhausted, removing fatigue and granting renewed strength.",
          "mana_cost": 20,
          "casting_time": "1 minute",
          "range": "touch",
          "target": "single",
          "effects": [
            {
              "target_type": "target",
              "effect_type": "status_effect",
              "value": 0.0,
              "stat_affected": "",
              "status_effect": "Revitalized",
              "duration": 60,
              "dice_notation": "",
              "description": "Removes exhaustion and fatigue"
            },
            {
              "target_type": "target",
              "effect_type": "stat_modification",
              "value": 10.0,
              "stat_affected": "Stamina",
              "status_effect": "",
              "duration": 30,
              "dice_notation": "",
              "description": "Enhances physical endurance and energy"
            }
          ],
          "level": 2,
          "components": [
            "touch",
            "prayer",
            "holy water"
          ],
          "tags": [
            "restoration",
            "enhancement",
            "recovery"
          ]
        }
      }
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Magic system definitions for the RPG game world"
  }
}
```

### File: config\world\base\world_history.json

```json
{
  "name": "Aetheris",
  "description": "A world once unified that was fractured into five overlapping planes by The Shattering, a catastrophic magical event approximately 2,500 years ago.",
  "current_year": 2500,
  "eras": [
    {
      "name": "The Age of Harmony",
      "start_year": -3000,
      "end_year": 0,
      "description": "The ancient era when Aetheris was a singular reality where all races existed in harmony under the watchful eye of the Luminaries - cosmic entities who maintained balance.",
      "events": [
        {
          "year": -3000,
          "title": "The First Settlements",
          "description": "The earliest known civilizations of Aetheris form, following the seasonal magical currents across the unified world.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -2500,
          "title": "The Song of Creation",
          "description": "The first documented use of Song Weaving magic, which becomes the primary magical practice of the era.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -1500,
          "title": "Formation of the Cipher Conclave",
          "description": "A collective of the most powerful mages forms to study the fundamental nature of reality and the Luminaries.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -500,
          "title": "The Luminescent Age",
          "description": "A period of unprecedented growth and prosperity as the Luminaries actively guide civilization.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": -100,
          "title": "The Immortality Project",
          "description": "The Cipher Conclave begins experiments to achieve immortality by tapping into the essence of the Luminaries.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Shattering",
      "start_year": 0,
      "end_year": 1,
      "description": "The catastrophic event that tore reality apart, splitting the world into five overlapping planes and scattering the Luminaries.",
      "events": [
        {
          "year": 0,
          "title": "The Fatal Experiment",
          "description": "The Cipher Conclave's attempt to harness immortality goes catastrophically wrong, tearing the fabric of reality.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 0,
          "title": "The Fracturing of the Planes",
          "description": "The unified world splits into five distinct planes: Verdant, Crystalline, Ashen, Tempest, and Nexus.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 0,
          "title": "The Scattering of the Luminaries",
          "description": "The cosmic entities that maintained balance are shattered, their essences fragmented across all planes.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1,
          "title": "The First Resonance",
          "description": "The initial overlap between planes occurs, causing confusion and fear among survivors.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Age of Isolation",
      "start_year": 1,
      "end_year": 1000,
      "description": "A millennium when surviving populations adapted to their new isolated realities while experiencing the first Resonance Events.",
      "events": [
        {
          "year": 50,
          "title": "The Emergence of the Five Speakers",
          "description": "Five individuals across different planes develop the ability to hear the \"voices\" of the fragmented Luminaries.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 127,
          "title": "The First Planar Adaptation",
          "description": "Isolated populations begin developing distinct traits based on their planar environment.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 345,
          "title": "The Founding of Harmonia",
          "description": "The first stable settlement is established on the Nexus plane, later becoming the capital of the Concordant Cities.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 512,
          "title": "The Resonance Calendar",
          "description": "Early attempts to predict and catalogue Resonance Events lead to the creation of a new calendar system.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 827,
          "title": "The First Planar Bleed Zone",
          "description": "An area where two planes permanently merged is discovered, leading to new theories about the nature of reality.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Age of Discovery",
      "start_year": 1000,
      "end_year": 2000,
      "description": "A period when civilizations developed ways to predict and utilize Resonance Events, leading to the first intentional cross-plane settlements.",
      "events": [
        {
          "year": 1024,
          "title": "The Formation of the Harmonic Order",
          "description": "Scholars from across the Nexus plane unite to study and catalogue plane interactions.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1156,
          "title": "The First Controlled Crossing",
          "description": "The Harmonic Order successfully predicts and utilizes a Resonance Event to deliberately travel between planes.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1378,
          "title": "The Verdant Collective",
          "description": "The formation of the first society to deliberately incorporate elements of the Verdant plane into their culture.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1591,
          "title": "The Crystalline Breakthrough",
          "description": "Facet Magic is developed, allowing for precise magical control through geometric crystal structures.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 1842,
          "title": "The Ghost Markets",
          "description": "The mysterious trading network that appears only during specific Resonance Events is established by entities known as \"The Between.\"",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    },
    {
      "name": "The Modern Age",
      "start_year": 2000,
      "end_year": 2500,
      "description": "The current era where sophisticated societies have emerged that incorporate elements from multiple planes while facing new challenges.",
      "events": [
        {
          "year": 2025,
          "title": "The Concordant Charter",
          "description": "The seven city-states of the Nexus plane form a unified government known as the Concordant Cities.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2142,
          "title": "The Emergence of the Dissonant Path",
          "description": "A faction forms that believes The Shattering was necessary evolution and actively opposes reunification efforts.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2287,
          "title": "The Luminary Chess Game",
          "description": "The Five Speakers begin a complex metaphysical game that corresponds to real-world events and Resonance patterns.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2398,
          "title": "The Resonance Crisis Begins",
          "description": "Resonance Events become more frequent and unpredictable, causing concern among scholars and leaders.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        },
        {
          "year": 2489,
          "title": "The Shifting Library",
          "description": "The discovery of a repository of knowledge that exists simultaneously in all planes, containing potential records from before The Shattering.",
          "significance": "",
          "affected_locations": [],
          "affected_cultures": []
        }
      ]
    }
  ]
}
```

### File: config\aliases\entities.json

```json
{
  "entities": {
    "white_wolf": {
      "aliases": [
        "white_wolf",
        "wolf_white",
        "white-wolf",
        "albino_wolf",
        "snow_wolf"
      ]
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Alias mappings for entities to support normalization in quests/evidence. Extend freely."
  }
}


```

### File: web\client\index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Adventure</title>
    <link rel="stylesheet" href="css/style.css">
    <!-- Add FontAwesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="app-container">
        <div class="game-frame">
            <div class="banner-bar">
                <div class="title-banner">
                    <img id="title-banner" src="/images/gui/title_banner.png" alt="Title Banner">
                </div>
                <div class="music-controls">
                    <button class="music-btn" title="Play/Pause"><img src="/images/gui/music_play.png" alt="Play"></button>
                    <button class="music-btn" title="Next"><img src="/images/gui/music_next.png" alt="Next"></button>
                    <button class="music-btn" title="Volume"><img src="/images/gui/music_volume.png" alt="Volume"></button>
                </div>
            </div>

            <aside class="left-menu">
                <div class="menu-buttons">
                    <button id="new-game-btn" class="menu-btn"><i class="fas fa-plus"></i> New Game</button>
                    <button id="save-game-btn" class="menu-btn"><i class="fas fa-save"></i> Save Game</button>
                    <button id="load-game-btn" class="menu-btn"><i class="fas fa-folder-open"></i> Load Game</button>
                    <button id="settings-btn" class="menu-btn"><i class="fas fa-cog"></i> Settings</button>
                    <button id="llm-btn" class="menu-btn">LLM</button>
                    <button id="exit-btn" class="menu-btn">Exit</button>
                </div>
            </aside>

            <section class="center-stack">
                <div class="game-output" id="game-output" style="display:none;">
                    <div class="welcome-message">
                        <h2>Welcome to RPG Adventure</h2>
                        <p>Start a new game or load a saved game to begin your adventure.</p>
                    </div>
                </div>
                <div class="command-input-container" style="display:none;">
                    <input type="text" id="command-input" class="command-input" placeholder="Enter a command..." disabled>
                    <button id="send-command-btn" class="send-command-btn" disabled><i class="fas fa-paper-plane"></i></button>
                </div>
            </section>

            <aside class="right-panel" style="display:none;">
                <div class="right-tabs">
                    <div class="tab-buttons small-tabs">
                        <button class="rp-tab-btn active" data-tab="tab-character">Character</button>
                        <button class="rp-tab-btn" data-tab="tab-inventory">Inventory</button>
                        <button class="rp-tab-btn" data-tab="tab-journal">Journal</button>
                    </div>
                    <div class="tab-content">
                        <div class="rp-tab-pane active" id="tab-character"><div class="placeholder">Character panel</div></div>
                        <div class="rp-tab-pane" id="tab-inventory"><div class="placeholder">Inventory panel</div></div>
                        <div class="rp-tab-pane" id="tab-journal"><div class="placeholder">Journal panel</div></div>
                    </div>
                </div>
            </aside>

            <footer class="status-bar" style="display:none;">
                <div class="status-text">
                    Location: <span id="current-location">-</span> | Time: <span id="game-time">-</span> | Calendar: <span id="game-calendar"></span> | Player: <span id="player-name">-</span> (Lv <span id="player-level">1</span>)
                </div>
            </footer>
        </div>

        <!-- Modals -->
        <!-- New Game Modal -->
        <div class="modal" id="new-game-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Create New Game</h2>
                    <span class="close-modal">&times;</span>
                </div>
                <div class="modal-body">
                        <div class="cc-tabs"><button class="cc-tab-btn active" data-step="basic">1. Basic Info</button><button class="cc-tab-btn" data-step="origin">2. Origin</button><button class="cc-tab-btn" data-step="stats">3. Stats</button></div>
                        <div class="cc-step" data-step="basic">
                        <div class="character-creator-container">
                            <div class="character-info-section">
                                <div class="form-group">
                                    <label for="new-player-name">Character Name:</label>
                                    <input type="text" id="new-player-name" placeholder="Enter your character name">
                                </div>
                                <div class="form-group">
                                    <label for="character-race-select">Race:</label>
                                    <select id="character-race-select"></select>
                                </div>
                                <div class="form-group">
                                    <label for="character-class-select">Class:</label>
                                    <select id="character-class-select"></select>
                                </div>
                                <div class="form-group">
                                    <label for="character-background-select">Origin:</label>
                                    <select id="character-background-select"><option value="">-- Select an Origin ---</option></select>
                                </div>
                                <div class="form-group">
                                    <label for="character-sex-select">Sex:</label>
                                    <select id="character-sex-select">
                                        <option value="Male">Male</option>
                                        <option value="Female">Female</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="character-llm-toggle" checked>
                                        <span class="toggle-slider"></span>
                                        <span class="toggle-label">Enable LLM for this game</span>
                                    </label>
                                </div>
                                <!-- Hidden input for selected icon path -->
                                <input type="hidden" id="character-icon-input">
                            </div>
                            <div class="character-icon-section">
                                <label>Character Portrait:</label>
                                <div class="icon-display-container">
                                    <div id="character-icon-display" class="icon-display">
                                        <div class="loading-icons">Loading icons...</div>
                                    </div>
                                    <div class="icon-controls">
                                        <button id="prev-icon-button" class="icon-nav-btn"><i class="fas fa-arrow-left"></i></button>
                                        <span id="icon-counter">0 / 0</span>
                                        <button id="next-icon-button" class="icon-nav-btn"><i class="fas fa-arrow-right"></i></button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        </div>
                        <div class="cc-step" data-step="origin" style="display:none">
                        <div class="origin-and-backstory">
                            <div class="origin-details-card">
                                <h3>Origin Details</h3>
                                <div class="form-group">
                                    <label>Description:</label>
                                    <div id="origin-description" class="origin-text">Select an Origin to see details.</div>
                                </div>
                                <div class="form-group">
                                    <label>Skill Proficiencies:</label>
                                    <div id="origin-skills" class="origin-text">-</div>
                                </div>
                                <div class="form-group">
                                    <label>Origin Traits:</label>
                                    <div id="origin-traits" class="origin-text">-</div>
                                </div>
                            </div>
                            <div class="origin-backstory-card">
                                <h3>Character Backstory (Seed)</h3>
                                <div class="form-group">
                                    <label>Edit the text below (loaded from Origin) to guide LLM background generation:</label>
                                    <textarea id="character-backstory-seed" rows="8" placeholder="Select an Origin to load starting text..."></textarea>
                                </div>
                                <div class="form-group">
                                    <div class="backstory-ai-controls" style="display:flex; gap:8px;">
                                        <button id="cc-improve-backstory" class="primary-btn">Improve via AI</button>
                                        <button id="cc-generate-backstory" class="primary-btn">Generate via AI</button>
                                    </div>
                                    <div id="cc-backstory-status" class="origin-text" style="display:none; margin-top:6px;"></div>
                                </div>
                            </div>
                        </div>
                        </div>
                        <div class="cc-step" data-step="stats" style="display:none">
                            <div class="cc-stats">
                                <div class="cc-stats-header">
                                    <div id="cc-stats-rc-display"></div>
                                    <div class="cc-points-remaining">Points Remaining: <span id="cc-points-remaining">27</span></div>
                                    <button id="cc-reset-btn" class="cancel-btn" style="float:right;">Reset</button>
                                </div>
                                <div id="cc-stats-grid"></div>
                                <div class="cc-preset-row" style="margin-top:10px; display:flex; gap:8px;">
                                    <button class="primary-btn" id="cc-preset-healer">Healer</button>
                                    <button class="primary-btn" id="cc-preset-crusader">Crusader</button>
                                    <button class="primary-btn" id="cc-preset-oracle">Oracle</button>
                                </div>
                                <div id="cc-stats-info" class="origin-text" style="margin-top:10px;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button id="create-game-btn" class="primary-btn">Create Game</button>
                        <button class="cancel-btn">Cancel</button>
                    </div>
            </div>
        </div>

        <!-- Save Game Modal -->
        <div class="modal" id="save-game-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Save Game</h2>
                    <span class="close-modal">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="save-name">Save Name:</label>
                        <input type="text" id="save-name" placeholder="Enter a name for your save">
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="save-btn" class="primary-btn">Save</button>
                    <button class="cancel-btn">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Load Game Modal -->
        <div class="modal" id="load-game-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Load Game</h2>
                    <span class="close-modal">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="saves-list" id="saves-list">
                        <div class="loading-saves">Loading saved games...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="load-btn" class="primary-btn" disabled>Load Selected</button>
                    <button class="cancel-btn">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div class="modal" id="settings-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Settings</h2>
                    <span class="close-modal">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="settings-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" data-tab="display-settings">Display</button>
                            <button class="tab-btn" data-tab="llm-settings">LLM Settings</button>
                            <button class="tab-btn" data-tab="agent-settings">Agent Settings</button>
                            <button class="tab-btn" data-tab="style-tools">Style Tools</button>
                        </div>
                        
                        <div class="tab-content">
                            <!-- Display Settings Tab -->
                            <div class="tab-pane active" id="display-settings">
                                <div class="settings-section">
                                    <h3>Display Settings</h3>
                                    <div class="form-group">
                                        <label for="theme-select">Theme:</label>
                                        <select id="theme-select">
                                            <option value="light">Light</option>
                                            <option value="dark">Dark</option>
                                            <option value="fantasy">Fantasy</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label for="font-size-slider">Font Size:</label>
                                        <input type="range" id="font-size-slider" min="12" max="24" value="16">
                                        <span id="font-size-value">16px</span>
                                    </div>
                                    <div class="form-group">
                                        <label for="background-select">Background:</label>
                                        <select id="background-select">
                                            <option value="">Auto (first available)</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- LLM Settings Tab -->
                            <div class="tab-pane" id="llm-settings">
                                <div class="settings-section">
                                    <h3>LLM Provider Settings</h3>
                                    <div class="form-group">
                                        <label class="toggle-switch">
                                            <input type="checkbox" id="llm-enabled-toggle">
                                            <span class="toggle-slider"></span>
                                            <span class="toggle-label">Enable LLM Functionality</span>
                                        </label>
                                    </div>
                                    
                                    <div id="llm-provider-settings">
                                        <!-- OpenAI Settings -->
                                        <div class="provider-section">
                                            <h4>OpenAI</h4>
                                            <div class="form-group">
                                                <label for="openai-api-key">API Key:</label>
                                                <input type="password" id="openai-api-key" placeholder="Enter OpenAI API key">
                                                <button class="show-hide-btn" data-target="openai-api-key"><i class="fas fa-eye"></i></button>
                                            </div>
                                            <div class="form-group">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="openai-enabled-toggle" checked>
                                                    <span class="toggle-slider"></span>
                                                    <span class="toggle-label">Enabled</span>
                                                </label>
                                            </div>
                                        </div>
                                        
                                        <!-- Google Settings -->
                                        <div class="provider-section">
                                            <h4>Google</h4>
                                            <div class="form-group">
                                                <label for="google-api-key">API Key:</label>
                                                <input type="password" id="google-api-key" placeholder="Enter Google API key">
                                                <button class="show-hide-btn" data-target="google-api-key"><i class="fas fa-eye"></i></button>
                                            </div>
                                            <div class="form-group">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="google-enabled-toggle" checked>
                                                    <span class="toggle-slider"></span>
                                                    <span class="toggle-label">Enabled</span>
                                                </label>
                                            </div>
                                        </div>
                                        
                                        <!-- OpenRouter Settings -->
                                        <div class="provider-section">
                                            <h4>OpenRouter</h4>
                                            <div class="form-group">
                                                <label for="openrouter-api-key">API Key:</label>
                                                <input type="password" id="openrouter-api-key" placeholder="Enter OpenRouter API key">
                                                <button class="show-hide-btn" data-target="openrouter-api-key"><i class="fas fa-eye"></i></button>
                                            </div>
                                            <div class="form-group">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="openrouter-enabled-toggle" checked>
                                                    <span class="toggle-slider"></span>
                                                    <span class="toggle-label">Enabled</span>
                                                </label>
                                            </div>
                                        </div>
                                        
                                        <!-- Provider sections end here -->
                                        
                                        <!-- Additional providers can be added here in the future -->
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Agent Settings Tab -->
                            <div class="tab-pane" id="agent-settings">
                                <div class="settings-section">
                                    <h3>Agent Configuration</h3>
                                    
                                    <!-- Narrator Agent Settings -->
                                    <div class="agent-section">
                                        <h4>Narrator Agent</h4>
                                        <div class="form-group">
                                            <label for="narrator-provider">Provider:</label>
                                            <select id="narrator-provider">
                                                <option value="OPENAI">OpenAI</option>
                                                <option value="GOOGLE">Google</option>
                                                <option value="OPENROUTER">OpenRouter</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label for="narrator-model">Model:</label>
                                            <select id="narrator-model">
                                                <!-- Options will be populated dynamically -->
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label for="narrator-temperature">Temperature:</label>
                                            <input type="range" id="narrator-temperature" min="0" max="2" step="0.1" value="0.7">
                                            <span id="narrator-temperature-value">0.7</span>
                                        </div>
                                        <div class="form-group">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="narrator-enabled-toggle" checked>
                                                <span class="toggle-slider"></span>
                                                <span class="toggle-label">Enabled</span>
                                            </label>
                                        </div>
                                    </div>
                                    
                                    <!-- Rule Checker Agent Settings -->
                                    <div class="agent-section">
                                        <h4>Rule Checker Agent</h4>
                                        <div class="form-group">
                                            <label for="rule-checker-provider">Provider:</label>
                                            <select id="rule-checker-provider">
                                                <option value="OPENAI">OpenAI</option>
                                                <option value="GOOGLE">Google</option>
                                                <option value="OPENROUTER">OpenRouter</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label for="rule-checker-model">Model:</label>
                                            <select id="rule-checker-model">
                                                <!-- Options will be populated dynamically -->
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label for="rule-checker-temperature">Temperature:</label>
                                            <input type="range" id="rule-checker-temperature" min="0" max="2" step="0.1" value="0.3">
                                            <span id="rule-checker-temperature-value">0.3</span>
                                        </div>
                                        <div class="form-group">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="rule-checker-enabled-toggle" checked>
                                                <span class="toggle-slider"></span>
                                                <span class="toggle-label">Enabled</span>
                                            </label>
                                        </div>
                                    </div>
                                    
                                    <!-- Context Evaluator Agent Settings -->
                                    <div class="agent-section">
                                        <h4>Context Evaluator Agent</h4>
                                        <div class="form-group">
                                            <label for="context-evaluator-provider">Provider:</label>
                                            <select id="context-evaluator-provider">
                                                <option value="OPENAI">OpenAI</option>
                                                <option value="GOOGLE">Google</option>
                                                <option value="OPENROUTER">OpenRouter</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label for="context-evaluator-model">Model:</label>
                                            <select id="context-evaluator-model">
                                                <!-- Options will be populated dynamically -->
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label for="context-evaluator-temperature">Temperature:</label>
                                            <input type="range" id="context-evaluator-temperature" min="0" max="2" step="0.1" value="0.2">
                                            <span id="context-evaluator-temperature-value">0.2</span>
                                        </div>
                                        <div class="form-group">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="context-evaluator-enabled-toggle" checked>
                                                <span class="toggle-slider"></span>
                                                <span class="toggle-label">Enabled</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                            <!-- Style Tools Tab -->
                            <div class="tab-pane" id="style-tools">
                                <div class="settings-section">
                                    <h3>Layout & Debug Tools</h3>
                                    <div class="form-group">
                                        <label class="toggle-switch">
                                            <input type="checkbox" id="layout-debug-toggle">
                                            <span class="toggle-slider"></span>
                                            <span class="toggle-label">Enable Layout Inspector</span>
                                        </label>
                                    </div>
                            <div class="form-group">
                                        <label class="toggle-switch">
                                            <input type="checkbox" id="layout-grid-toggle">
                                            <span class="toggle-slider"></span>
                                            <span class="toggle-label">Show Grid Overlay</span>
                                        </label>
                                    </div>
                                    <div class="form-group">
                                        <label class="toggle-switch">
                                            <input type="checkbox" id="layout-editor-toggle">
                                            <span class="toggle-slider"></span>
                                            <span class="toggle-label">Enable Element Resize Mode</span>
                                        </label>
                                    </div>
                                    <div class="form-group">
                                        <label class="toggle-switch">
                                            <input type="checkbox" id="layout-move-toggle">
                                            <span class="toggle-slider"></span>
                                            <span class="toggle-label">Enable Move Mode (drag to reposition)</span>
                                        </label>
                                    </div>
                                    <div class="form-group">
                                        <label for="layout-grid-size">Grid Size:</label>
                                        <input type="number" id="layout-grid-size" min="4" max="64" step="2" value="16">
                                    </div>
                                    <div class="form-group">
                                        <label for="layout-left-width">Left Menu Width (px):</label>
                                        <input type="number" id="layout-left-width" min="120" max="320" step="5" value="180">
                                    </div>
                                    <div class="form-group">
                                        <label for="layout-right-width">Right Panel Width (px):</label>
                                        <input type="number" id="layout-right-width" min="320" max="640" step="5" value="420">
                                    </div>
                                    <div class="form-group">
                                        <label for="layout-gap">Content Gap (px):</label>
                                        <input type="number" id="layout-gap" min="0" max="24" step="1" value="10">
                                    </div>
                                    <div class="form-group">
                                        <label for="layout-rp-max">Right Panel Pane Max Height (px or 0 for none):</label>
                                        <input type="number" id="layout-rp-max" min="0" max="1200" step="10" value="0">
                                    </div>
                                    <div class="form-group" style="display:flex; gap:8px; flex-wrap:wrap;">
                                        <button id="layout-reset-all" class="cancel-btn" style="background:#b71c1c;border-color:#b71c1c;color:#fff;">Reset Layout to Defaults</button>
                                        <button id="layout-hard-reset" class="cancel-btn" style="background:#8B0000;border-color:#8B0000;color:#fff;" title="Wipes all saved layout data from the browser and reloads the page. Use this if the UI is severely broken.">Hard Reset Layout & Reload</button>
                                        <button id="layout-restore-saved" class="secondary-btn">Restore Layout From Saved Snapshot</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="reset-settings-btn" class="secondary-btn">Reset to Default</button>
                    <button id="save-settings-btn" class="primary-btn">Save Settings</button>
                    <button class="cancel-btn">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Item Info Modal -->
        <div class="modal" id="item-info-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Item Info</h2>
                    <span class="close-modal">&times;</span>
                </div>
                <div class="modal-body" id="item-info-body">
                    <div class="loading-item-info">Loading...</div>
                </div>
                <div class="modal-footer">
                    <button class="cancel-btn">Close</button>
                </div>
            </div>
        </div>

        <!-- Notification System -->
        <div class="notification-container" id="notification-container"></div>
    </div>

    <!-- Create CSS directory -->
    <script>
        // This will be replaced by proper CSS files
        const createCssDirectory = () => {
            console.log("CSS directory would be created here in a real deployment");
        };
    </script>

    <!-- JavaScript Files with cache-busting via version parameter -->
    <!-- Update the version number when JavaScript changes to force browser refresh -->
    <script src="js/api-client.js?v=2025093003"></script>
    <script src="js/websocket-client.js?v=2025093003"></script>
    <script src="js/ui-manager.js?v=2025093003"></script>
    <script src="js/character-creator.js?v=2025093003"></script>
    <script src="js/main.js?v=2025093003"></script>
    <script src="js/model-debug.js?v=2025093003"></script>
</body>
</html>

```

### File: web\client\js\agent-settings.js

```javascript
/**
 * Agent Settings Manager for LLM Configuration
 * Provides UI for configuring provider/model settings for different agents
 */

class AgentSettingsManager {
    constructor() {
        this.agentTypes = ['narrator', 'rule_checker', 'context_evaluator'];
        this.agentDisplayNames = {
            'narrator': 'Narrator Agent',
            'rule_checker': 'Rule Checker Agent',
            'context_evaluator': 'Context Evaluator Agent'
        };
        this.providerTypes = {
            'OPENAI': 'OpenAI',
            'GOOGLE': 'Google',
            'ANTHROPIC': 'Anthropic',
            'OPENROUTER': 'OpenRouter'
        };
        
        // Settings will be loaded from the API
        this.settings = {
            providers: {},
            agents: {}
        };
        
        // Initialize DOM elements
        this.initElements();
        this.initEventListeners();
    }
    
    /**
     * Initialize DOM elements for agent settings
     */
    initElements() {
        // Check if the settings tab already exists
        if (document.getElementById('agent-settings-tab')) {
            return;
        }
        
        // Add the agents tab to LLM settings
        const tabsContainer = document.querySelector('#llm-settings-tabs');
        if (tabsContainer) {
            const agentTab = document.createElement('button');
            agentTab.className = 'tab-button';
            agentTab.id = 'agent-settings-tab';
            agentTab.textContent = 'Agent Settings';
            agentTab.dataset.target = 'agent-settings-content';
            tabsContainer.appendChild(agentTab);
            
            // Create the content container
            const contentArea = document.querySelector('#llm-settings-content');
            const agentContent = document.createElement('div');
            agentContent.className = 'tab-content';
            agentContent.id = 'agent-settings-content';
            agentContent.style.display = 'none';
            
            // Create the agent settings form
            agentContent.innerHTML = this.createAgentSettingsHTML();
            contentArea.appendChild(agentContent);
        }
    }
    
    /**
     * Create HTML for agent settings tab
     */
    createAgentSettingsHTML() {
        let html = `
            <h3>Agent Configuration</h3>
            <p>Configure which AI provider and model to use for each agent type.</p>
            <div class="settings-grid">
        `;
        
        // Create settings for each agent type
        this.agentTypes.forEach(agentType => {
            const displayName = this.agentDisplayNames[agentType] || agentType;
            
            html += `
                <div class="settings-section">
                    <h4>${displayName}</h4>
                    <div class="form-group">
                        <label for="${agentType}-provider">AI Provider:</label>
                        <select id="${agentType}-provider" class="agent-provider-select" data-agent="${agentType}">
                            ${Object.entries(this.providerTypes).map(([key, value]) => 
                                `<option value="${key}">${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="${agentType}-model">Model:</label>
                        <select id="${agentType}-model" class="agent-model-select" data-agent="${agentType}">
                            <!-- Models will be populated dynamically -->
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="${agentType}-temperature">Temperature:</label>
                        <input type="range" id="${agentType}-temperature" class="agent-temperature" data-agent="${agentType}"
                               min="0" max="1" step="0.1" value="0.7">
                        <span class="temperature-value" id="${agentType}-temperature-value">0.7</span>
                    </div>
                </div>
            `;
        });
        
        html += `</div>
            <div class="settings-actions">
                <button id="save-agent-settings" class="btn btn-primary">Save Agent Settings</button>
            </div>
        `;
        
        return html;
    }
    
    /**
     * Initialize event listeners for agent settings UI
     */
    initEventListeners() {
        // Wait for elements to be added to DOM
        setTimeout(() => {
            // Provider selection changes
            document.querySelectorAll('.agent-provider-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const agentType = e.target.dataset.agent;
                    const providerType = e.target.value;
                    this.updateModelOptions(agentType, providerType);
                });
            });
            
            // Temperature slider changes
            document.querySelectorAll('.agent-temperature').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const agentType = e.target.dataset.agent;
                    const value = e.target.value;
                    document.getElementById(`${agentType}-temperature-value`).textContent = value;
                });
            });
            
            // Save button
            const saveButton = document.getElementById('save-agent-settings');
            if (saveButton) {
                saveButton.addEventListener('click', () => this.saveAgentSettings());
            }
            
            // Tab selection
            const agentTab = document.getElementById('agent-settings-tab');
            if (agentTab) {
                agentTab.addEventListener('click', () => this.loadAgentSettings());
            }
        }, 500);
    }
    
    /**
     * Load LLM settings from the API
     */
    async loadAgentSettings() {
        try {
            const response = await apiClient.getLLMSettings();
            this.settings = response;
            
            // Update UI with loaded settings
            this.updateAgentSettingsUI();
        } catch (error) {
            console.error('Error loading agent settings:', error);
            alert('Failed to load agent settings. Please try again.');
        }
    }
    
    /**
     * Update the agent settings UI with loaded settings
     */
    updateAgentSettingsUI() {
        const agents = this.settings.agents || {};
        
        // Update each agent's settings
        for (const agentType of this.agentTypes) {
            const agentSettings = agents[agentType] || {};
            
            // Set provider
            const providerSelect = document.getElementById(`${agentType}-provider`);
            if (providerSelect && agentSettings.provider_type) {
                providerSelect.value = agentSettings.provider_type;
                
                // Update model options for this provider
                this.updateModelOptions(agentType, agentSettings.provider_type);
                
                // Set model after options are updated
                setTimeout(() => {
                    const modelSelect = document.getElementById(`${agentType}-model`);
                    if (modelSelect && agentSettings.model) {
                        modelSelect.value = agentSettings.model;
                    }
                }, 100);
            }
            
            // Set temperature
            const temperatureSlider = document.getElementById(`${agentType}-temperature`);
            const temperatureValue = document.getElementById(`${agentType}-temperature-value`);
            if (temperatureSlider && temperatureValue && agentSettings.temperature !== undefined) {
                temperatureSlider.value = agentSettings.temperature;
                temperatureValue.textContent = agentSettings.temperature;
            }
        }
    }
    
    /**
     * Update model options based on selected provider
     */
    updateModelOptions(agentType, providerType) {
        const modelSelect = document.getElementById(`${agentType}-model`);
        if (!modelSelect) return;
        
        // Clear current options
        modelSelect.innerHTML = '';
        
        // Get available models for this provider
        let availableModels = [];
        
        // Check providers in loaded settings
        const providers = this.settings.providers || {};
        const providerKey = providerType.toLowerCase();
        
        if (providers[providerKey] && providers[providerKey].available_models) {
            availableModels = providers[providerKey].available_models;
        } else {
            // Default models if not found in settings
            const defaultModels = {
                'OPENAI': ['gpt-4o', 'gpt-4-turbo', 'gpt-3.5-turbo'],
                'GOOGLE': ['gemini-2.0-flash', 'gemini-2.0-pro'],
                'ANTHROPIC': ['claude-3-opus', 'claude-3-sonnet', 'claude-3-haiku'],
                'OPENROUTER': ['anthropic/claude-3-haiku', 'anthropic/claude-3-sonnet', 'anthropic/claude-3-opus', 'google/gemini-pro']
            };
            
            availableModels = defaultModels[providerType] || [];
        }
        
        // Add options for available models
        availableModels.forEach(model => {
            const option = document.createElement('option');
            option.value = model;
            option.textContent = model;
            modelSelect.appendChild(option);
        });
        
        // If no models found, add a placeholder
        if (availableModels.length === 0) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'No models available';
            modelSelect.appendChild(option);
        }
    }
    
    /**
     * Save agent settings to the API
     */
    async saveAgentSettings() {
        try {
            // Collect settings from UI
            const agentSettings = {};
            
            for (const agentType of this.agentTypes) {
                const providerSelect = document.getElementById(`${agentType}-provider`);
                const modelSelect = document.getElementById(`${agentType}-model`);
                const temperatureSlider = document.getElementById(`${agentType}-temperature`);
                
                if (providerSelect && modelSelect && temperatureSlider) {
                    agentSettings[agentType] = {
                        provider_type: providerSelect.value,
                        model: modelSelect.value,
                        temperature: parseFloat(temperatureSlider.value)
                    };
                }
            }
            
            // Save to API
            await apiClient.updateLLMSettings({ agents: agentSettings });
            
            // Show success message
            alert('Agent settings saved successfully!');
            
        } catch (error) {
            console.error('Error saving agent settings:', error);
            alert('Failed to save agent settings. Please try again.');
        }
    }
}

// Initialize the agent settings manager
const agentSettingsManager = new AgentSettingsManager();
```

### File: web\client\js\api-client.js

```javascript
/**
 * API Client for RPG Game Web Interface
 * Handles all API communication with the backend server
 */

class ApiClient {
    constructor(baseUrl = '') {
        this.baseUrl = baseUrl || window.location.origin;
        this.sessionId = null;
        this.token = null;

        // Attempt to load session from localStorage
        this.loadSession();
    }

    /**
     * Save the current session to localStorage
     */
    saveSession() {
        if (this.sessionId) {
            localStorage.setItem('rpg_session_id', this.sessionId);
        }
        if (this.token) {
            localStorage.setItem('rpg_auth_token', this.token);
        }
    }

    /**
     * Load session from localStorage
     */
    loadSession() {
        this.sessionId = localStorage.getItem('rpg_session_id');
        this.token = localStorage.getItem('rpg_auth_token');
    }

    /**
     * Clear the current session
     */
    clearSession() {
        this.sessionId = null;
        this.token = null;
        localStorage.removeItem('rpg_session_id');
        localStorage.removeItem('rpg_auth_token');
    }

    /**
     * Clean up a session on the server
     */
    async cleanupSession(sessionId = null) {
        const id = sessionId || this.sessionId;
        if (!id) {
            return;
        }

        try {
            const response = await fetch(this.buildUrl(`session/${id}`), {
                method: 'DELETE',
                headers: this.getHeaders()
            });
            // Don't throw on failure - cleanup is best-effort
            if (response.ok) {
                console.log(`Session ${id} cleaned up successfully`);
            }
        } catch (error) {
            console.warn(`Failed to cleanup session ${id}:`, error);
        }
    }

    /**
     * Check if there's an active session
     */
    hasActiveSession() {
        return !!this.sessionId;
    }

    /**
     * Set the authentication token
     */
    setAuthToken(token) {
        this.token = token;
        this.saveSession();
    }

    /**
     * Helper method to build the full URL for an API endpoint
     */
    buildUrl(endpoint) {
        return `${this.baseUrl}/api/${endpoint}`;
    }

    /**
     * Helper method to build request headers
     */
    getHeaders() {
        const headers = {
            'Content-Type': 'application/json',
        };

        if (this.token) {
            headers['Authorization'] = `Bearer ${this.token}`;
        }

        return headers;
    }

    /**
     * Login to the server
     */
    async login(username, password) {
        try {
            // Create form data
            const formData = new URLSearchParams();
            formData.append('username', username);
            formData.append('password', password);

            const response = await fetch(`${this.baseUrl}/token`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Login failed');
            }

            const data = await response.json();
            this.setAuthToken(data.access_token);
            return data;

        } catch (error) {
            console.error('Login error:', error);
            throw error;
        }
    }

    /**
     * Start a new game with extended character creation options
     * 
     * @param {string} playerName - The name of the player character
     * @param {Object} options - Additional character creation options
     * @param {string} [options.race="Human"] - Character race
     * @param {string} [options.path="Wanderer"] - Character class/path
     * @param {string} [options.background="Commoner"] - Character background
     * @param {string} [options.sex="Male"] - Character sex/gender
     * @param {string} [options.characterImage=null] - Path to character portrait image
     * @param {boolean} [options.useLLM=true] - Whether to enable LLM functionality
     * @returns {Promise<Object>} - Promise resolving to session data
     */
    async createNewGame(playerName, options = {}) {
        try {
            const defaults = {
                race: "Human",
                path: "Wanderer", 
                background: "Commoner",
                sex: "Male",
                characterImage: null,
                useLLM: true
            };
            
            const settings = { ...defaults, ...options };
            
            const requestBody = {
                player_name: playerName,
                race: settings.race,
                path: settings.path,
                background: settings.background,
                sex: settings.sex,
                character_image: settings.characterImage,
                use_llm: settings.useLLM,
                origin_id: settings.origin_id || null,
                stats: settings.stats || null
            };
            
            const response = await fetch(this.buildUrl('new_game'), {
                method: 'POST',
                headers: this.getHeaders(),
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                throw new Error('Failed to create new game');
            }

            const data = await response.json();
            this.sessionId = data.session_id;
            this.saveSession();
            return data;

        } catch (error) {
            console.error('Create game error:', error);
            throw error;
        }
    }

    /**
     * Send a command to the game
     */
    async sendCommand(command) {
        if (!this.sessionId) {
            throw new Error('No active game session');
        }

        try {
            const response = await fetch(this.buildUrl(`command/${this.sessionId}`), {
                method: 'POST',
                headers: this.getHeaders(),
                body: JSON.stringify({ command }),
            });

            if (!response.ok) {
                try {
                    // Try to extract error details from server
                    const contentType = response.headers.get('content-type') || '';
                    if (contentType.includes('application/json')) {
                        const errJson = await response.json();
                        const msg = (errJson && (errJson.detail || errJson.message)) || `HTTP ${response.status}`;
                        throw new Error(msg);
                    } else {
                        const txt = await response.text();
                        throw new Error(txt || `HTTP ${response.status}`);
                    }
                } catch (e) {
                    // Fall back if parsing fails
                    throw new Error(`Failed to process command (HTTP ${response.status})`);
                }
            }

            return await response.json();

        } catch (error) {
            console.error('Command error:', error);
            throw error;
        }
    }

    /**
     * Create a session without starting a game
     */
    async createSession() {
        try {
            const response = await fetch(this.buildUrl('session'), {
                method: 'POST',
                headers: this.getHeaders(),
            });
            if (!response.ok) throw new Error('Failed to create session');
            const data = await response.json();
            this.sessionId = data.session_id;
            this.saveSession();
            return data;
        } catch (e) {
            console.error('Create session error:', e);
            throw e;
        }
    }

    /**
     * Save the current game
     */
    async saveGame(saveName = null) {
        if (!this.sessionId) {
            throw new Error('No active game session');
        }

        try {
            const response = await fetch(this.buildUrl(`save_game/${this.sessionId}`), {
                method: 'POST',
                headers: this.getHeaders(),
                body: JSON.stringify({ save_name: saveName }),
            });

            if (!response.ok) {
                throw new Error('Failed to save game');
            }

            return await response.json();

        } catch (error) {
            console.error('Save game error:', error);
            throw error;
        }
    }

    /**
     * Load a saved game
     */
    async loadGame(saveId) {
        if (!this.sessionId) {
            throw new Error('No active game session');
        }

        try {
            // Correct: session_id in URL path, save_id in request body
            const response = await fetch(this.buildUrl(`load_game/${this.sessionId}`), {
                method: 'POST',
                headers: this.getHeaders(),
                body: JSON.stringify({ save_id: saveId }),
            });

            if (!response.ok) {
                throw new Error('Failed to load game');
            }

            return await response.json();

        } catch (error) {
            console.error('Load game error:', error);
            throw error;
        }
    }

    /**
     * Get a list of all saves
     */
    async listSaves() {
        try {
            const response = await fetch(this.buildUrl('list_saves'), {
                method: 'GET',
                headers: this.getHeaders(),
            });

            if (!response.ok) {
                throw new Error('Failed to list saves');
            }

            return await response.json();

        } catch (error) {
            console.error('List saves error:', error);
            throw error;
        }
    }

    /**
     * End the current game session
     */
    async endSession() {
        if (!this.sessionId) {
            return;
        }

        try {
            // Correct: use session_id in URL path
            const response = await fetch(this.buildUrl(`end_session/${this.sessionId}`), {
                method: 'DELETE',
                headers: this.getHeaders(),
            });

            if (!response.ok) {
                console.warn('Failed to end session properly');
            }

            this.clearSession();
            return true;

        } catch (error) {
            console.error('End session error:', error);
            this.clearSession();
            return false;
        }
    }

    /**
     * Get LLM settings.
     * @returns {Promise<Object>} - Promise resolving to LLM settings
     */
    async getLLMSettings() {
        try {
            const response = await fetch(this.buildUrl('llm/settings'), {
                method: 'GET',
                headers: this.getHeaders()
            });
            
            if (!response.ok) {
                throw new Error('Failed to retrieve LLM settings');
            }
            
            return await response.json();
        } catch (error) {
            console.error('Get LLM settings error:', error);
            throw error;
        }
    }

    /**
     * Update LLM settings.
     * @param {Object} settings - LLM settings to update
     * @param {Object} settings.providers - Provider settings (optional)
     * @param {Object} settings.agents - Agent settings (optional)
     * @returns {Promise<Object>} - Promise resolving to response data
     */
    async updateLLMSettings(settings) {
        try {
            const response = await fetch(this.buildUrl('llm/settings'), {
                method: 'POST',
                headers: {
                    ...this.getHeaders(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
            });
            
            if (!response.ok) {
                throw new Error('Failed to update LLM settings');
            }
            
            return await response.json();
        } catch (error) {
            console.error('Update LLM settings error:', error);
            throw error;
        }
    }

    /**
     * Toggle LLM functionality for the current game session.
     * @param {boolean} enabled - Whether to enable LLM functionality
     * @returns {Promise<Object>} - Promise resolving to response data
     */
    async toggleLLM(enabled) {
        if (!this.sessionId) {
            throw new Error('No active game session');
        }
        
        try {
            const response = await fetch(this.buildUrl(`llm/toggle/${this.sessionId}`), {
                method: 'POST',
                headers: {
                    ...this.getHeaders(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ enabled })
            });
            
            if (!response.ok) {
                throw new Error('Failed to toggle LLM functionality');
            }
            
            return await response.json();
        } catch (error) {
            console.error('Toggle LLM error:', error);
            throw error;
        }
    }

    /**
     * Get a list of all available character icons
     * @returns {Promise<Object>} - Promise resolving to icon data
     */
    async getCharacterIcons() {
        try {
            const response = await fetch(this.buildUrl('character-icons'), {
                method: 'GET',
                headers: this.getHeaders(),
            });

            if (!response.ok) {
                throw new Error('Failed to get character icons');
            }

            return await response.json();

        } catch (error) {
            console.error('Get character icons error:', error);
            throw error;
        }
    }

    /** Filtered character icons by race/class/sex */
    async getFilteredCharacterIcons(race, path, sex='Other') {
        try {
            const params = new URLSearchParams({ race, path, sex });
            const response = await fetch(this.buildUrl(`character-icons/filter?${params.toString()}`), {
                method: 'GET', headers: this.getHeaders()
            });
            if (!response.ok) throw new Error('Failed to get filtered character icons');
            return await response.json();
        } catch (e) {
            console.error('Get filtered icons error:', e);
            throw e;
        }
    }

    /** Config endpoints */
    async getConfigRaces() {
        const r = await fetch(this.buildUrl('config/races'), { headers: this.getHeaders() });
        if (!r.ok) throw new Error('Failed to load races');
        return await r.json();
    }
    async getConfigClasses() {
        const r = await fetch(this.buildUrl('config/classes'), { headers: this.getHeaders() });
        if (!r.ok) throw new Error('Failed to load classes');
        return await r.json();
    }
    async getConfigOrigins() {
        const r = await fetch(this.buildUrl('config/origins'), { headers: this.getHeaders() });
        if (!r.ok) throw new Error('Failed to load origins');
        return await r.json();
    }

    /**
     * Check if the server is available
     */
    async checkServerStatus() {
        try {
            const response = await fetch(`${this.baseUrl}/api/list_saves`, {
                method: 'GET',
                headers: this.getHeaders(),
            });

            return response.ok;

        } catch (error) {
            console.error('Server check error:', error);
            return false;
        }
    }
    /** Fetch detailed UI state for the right panel and status bar */
    async getUIState() {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`ui/state/${this.sessionId}`), { headers: this.getHeaders() });
        if (!resp.ok) throw new Error('Failed to fetch UI state');
        return await resp.json();
    }

    /** Fetch inventory listing/currency/weight */
    async getInventory() {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`inventory/${this.sessionId}`), { headers: this.getHeaders() });
        if (!resp.ok) throw new Error('Failed to fetch inventory');
        return await resp.json();
    }

    async equipItem(itemId, slot = null) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`inventory/equip/${this.sessionId}`), {
            method: 'POST',
            headers: this.getHeaders(),
            body: JSON.stringify({ item_id: itemId, slot })
        });
        if (!resp.ok) throw new Error('Failed to equip');
        return await resp.json();
    }

    async unequip(slotOrItemId) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`inventory/unequip/${this.sessionId}`), {
            method: 'POST', headers: this.getHeaders(), body: JSON.stringify({ slot: slotOrItemId, item_id: slotOrItemId })
        });
        if (!resp.ok) throw new Error('Failed to unequip');
        return await resp.json();
    }

    async useItem(itemId) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`inventory/use/${this.sessionId}`), {
            method: 'POST', headers: this.getHeaders(), body: JSON.stringify({ item_id: itemId })
        });
        if (!resp.ok) throw new Error('Failed to use item');
        return await resp.json();
    }

    async dropItem(itemId) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`inventory/drop/${this.sessionId}`), {
            method: 'POST', headers: this.getHeaders(), body: JSON.stringify({ item_id: itemId })
        });
        if (!resp.ok) throw new Error('Failed to drop item');
        return await resp.json();
    }

    // Journal endpoints
    async updateJournalCharacter(text) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`journal/character/${this.sessionId}`), { method:'POST', headers: this.getHeaders(), body: JSON.stringify({ text }) });
        if (!resp.ok) throw new Error('Failed to save character notes');
        return await resp.json();
    }
    async updateObjectiveStatus(quest_id, objective_id, payload) {
        if (!this.sessionId) throw new Error('No active game session');
        const body = { quest_id, objective_id };
        if (typeof payload.completed === 'boolean') body.completed = payload.completed;
        if (typeof payload.failed === 'boolean') body.failed = payload.failed;
        const resp = await fetch(this.buildUrl(`journal/objective_status/${this.sessionId}`), { method:'POST', headers: this.getHeaders(), body: JSON.stringify(body) });
        if (!resp.ok) throw new Error('Failed to update objective');
        return await resp.json();
    }
    async abandonQuest(quest_id) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`journal/abandon/${this.sessionId}`), { method:'POST', headers: this.getHeaders(), body: JSON.stringify({ quest_id }) });
        if (!resp.ok) throw new Error('Failed to abandon quest');
        return await resp.json();
    }

    async addJournalNote(text) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`journal/add_note/${this.sessionId}`), { method:'POST', headers: this.getHeaders(), body: JSON.stringify({ text }) });
        if (!resp.ok) throw new Error('Failed to add note');
        return await resp.json();
    }
    async deleteJournalNote(noteId) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`journal/delete_note/${this.sessionId}/${encodeURIComponent(noteId)}`), { method:'DELETE', headers: this.getHeaders() });
        if (!resp.ok) throw new Error('Failed to delete note');
        return await resp.json();
    }

    /** Get stat modifiers for a specific stat key (e.g., 'STR', 'MELEE_ATTACK') */
    async getStatModifiers(statKey) {
        if (!this.sessionId) throw new Error('No active game session');
        const resp = await fetch(this.buildUrl(`stats/modifiers/${this.sessionId}?stat=${encodeURIComponent(statKey)}`), {
            method: 'GET', headers: this.getHeaders()
        });
        if (!resp.ok) throw new Error('Failed to get stat modifiers');
        return await resp.json();
    }

    /**
     * Improve backstory seed via LLM
     * @param {{name:string, race:string, path:string, origin_id?:string, sex?:string, seed_text:string}} payload
     */
    async improveBackstory(payload) {
        const resp = await fetch(this.buildUrl('backstory/improve'), {
            method: 'POST',
            headers: this.getHeaders(),
            body: JSON.stringify(payload)
        });
        if (!resp.ok) throw new Error('Failed to improve backstory');
        return await resp.json();
    }

    /**
     * Generate a new backstory via LLM
     * @param {{name:string, race:string, path:string, origin_id?:string, sex?:string}} payload
     */
    async generateBackstory(payload) {
        const resp = await fetch(this.buildUrl('backstory/generate'), {
            method: 'POST',
            headers: this.getHeaders(),
            body: JSON.stringify(payload)
        });
        if (!resp.ok) throw new Error('Failed to generate backstory');
        return await resp.json();
    }
}

// Create and export the singleton instance
const apiClient = new ApiClient();

```

### File: web\client\js\character-creator.js

```javascript
/**
 * Character creator module for the RPG Game
 * Handles character creation UI, icon selection, and form validation
 */

// Character Creator Module
const CharacterCreator = (function() {
    // Private variables
    let characterIcons = [];
    let currentIconIndex = 0;
    let selectedIcon = null;

    // DOM elements
    let iconDisplay = null;
    let prevButton = null;
    let nextButton = null;
    let sexSelector = null;

    // Stats state
    const STAT_KEYS = ['STR','DEX','CON','INT','WIS','CHA','WIL','INS'];
    const BASE_DEFAULT = 8;
    let statBase = Object.fromEntries(STAT_KEYS.map(k=>[k, BASE_DEFAULT]));
    let statAdjust = Object.fromEntries(STAT_KEYS.map(k=>[k, 0]));
    let raceMods = Object.fromEntries(STAT_KEYS.map(k=>[k, 0]));
    let classMods = Object.fromEntries(STAT_KEYS.map(k=>[k, 0]));
    let pointPool = 27;
    let minStat = 3;
    let maxStat = 18;

    function getSpentPoints() { return STAT_KEYS.reduce((s,k)=> s + (statAdjust[k]||0), 0); }
    function getPointsRemaining() { return pointPool - getSpentPoints(); }

    function setAdjust(k, delta) {
        const newAdj = (statAdjust[k]||0) + delta;
        const newBase = (statBase[k]||BASE_DEFAULT) + newAdj;
        if (newBase < minStat || newBase > maxStat) return;
        // Respect point pool
        const spentIf = getSpentPoints() + delta;
        if (spentIf > pointPool) return;
        statAdjust[k] = newAdj;
        renderStatsUI();
    }

    function resetAlloc() {
        STAT_KEYS.forEach(k=> statAdjust[k] = 0);
        renderStatsUI();
    }

    function applyPreset(preset) {
        resetAlloc();
        const plan = {
            'Healer': { WIS: 6, CON: 4, INT: 2, DEX: 2 },
            'Crusader': { STR: 6, CON: 6, WIS: 2 },
            'Oracle': { WIS: 7, INS: 4, CON: 2 }
        }[preset] || {};
        for (const [k, v] of Object.entries(plan)) {
            for (let i=0;i<v;i++) setAdjust(k, +1);
        }
    }

    function modFromTotal(total) { return Math.floor((total - 10) / 2); }

    function renderStatsUI() {
        try {
            const grid = document.getElementById('cc-stats-grid');
            const prEl = document.getElementById('cc-points-remaining');
            const rcEl = document.getElementById('cc-stats-rc-display');
            const raceSel = document.getElementById('character-race-select');
            const classSel = document.getElementById('character-class-select');
            if (rcEl) rcEl.textContent = `${raceSel?.value||''} • ${classSel?.value||''}`;
            if (prEl) prEl.textContent = String(getPointsRemaining());
            if (!grid) return;
            const header = `<div class=\"cc-stat-name\">Stat</div><div class=\"cc-stat-base\">Base</div><div class=\"cc-stat-adjust\">Adjust</div><div class=\"cc-stat-race\">Race</div><div class=\"cc-stat-class\">Class</div><div class=\"cc-stat-total\">Total</div><div class=\"cc-stat-mod\">Mod</div>`;
            const rows = STAT_KEYS.map(k=>{
                const base = statBase[k]||BASE_DEFAULT;
                const adj = statAdjust[k]||0;
                const r = raceMods[k]||0;
                const c = classMods[k]||0;
                const total = base + adj + r + c;
                const mod = modFromTotal(total);
                const adjStr = adj===0 ? '0' : (adj>0?`+${adj}`:String(adj));
                const adjCls = adj>0 ? 'cc-pos' : (adj<0 ? 'cc-neg' : '');
                const rStr = r===0 ? '0' : (r>0?`+${r}`:String(r));
                const rCls = r>0 ? 'cc-pos' : (r<0 ? 'cc-neg' : '');
                const cStr = c===0 ? '0' : (c>0?`+${c}`:String(c));
                const cCls = c>0 ? 'cc-pos' : (c<0 ? 'cc-neg' : '');
                const modStr = mod===0 ? '0' : (mod>0?`+${mod}`:String(mod));
                const modCls = mod>0 ? 'cc-pos' : (mod<0 ? 'cc-neg' : '');
                return `<div class=\"cc-stat-row\">
                    <div class=\"cc-stat-name\">${k}</div>
                    <div class=\"cc-stat-base\">${base}</div>
                    <div class=\"cc-stat-adjust\"><div class=\"cc-stat-controls\"><button class=\"cc-stat-btn\" data-k=\"${k}\" data-d=\"-1\">-</button><span class=\"${adjCls}\">${adjStr}</span><button class=\"cc-stat-btn\" data-k=\"${k}\" data-d=\"+1\">+</button></div></div>
                    <div class=\"cc-stat-race\"><span class=\"${rCls}\">${rStr}</span></div>
                    <div class=\"cc-stat-class\"><span class=\"${cCls}\">${cStr}</span></div>
                    <div class=\"cc-stat-total\">${total}</div>
                    <div class=\"cc-stat-mod\"><span class=\"${modCls}\">${modStr}</span></div>
                </div>`;
            }).join('');
            grid.innerHTML = header + rows;
            grid.querySelectorAll('.cc-stat-btn').forEach(btn=>{
                btn.addEventListener('click', ()=>{
                    const k = btn.getAttribute('data-k');
                    const d = parseInt(btn.getAttribute('data-d'), 10);
                    setAdjust(k, d);
                });
            });
        } catch (e) { console.warn('renderStatsUI error', e); }
    }

    function computeModifiersFromConfig() {
        try {
            const raceSel = document.getElementById('character-race-select');
            const classSel = document.getElementById('character-class-select');
            const raceName = raceSel?.value || '';
            const className = classSel?.value || '';
            // Use cached origins/classes/races from loadConfigAndPopulate scope variables
            // For races/classes we expect .names and maybe dict at CharacterCreator._config
            const cfg = CharacterCreator._config || {};
            const races = cfg.races || {};
            const classes = cfg.classes || {};
            const rEntry = Object.values(races).find(x => (x?.name||'') === raceName) || races[raceName] || {};
            const cEntry = Object.values(classes).find(x => (x?.name||'') === className) || classes[className] || {};
            raceMods = extractStatDict(rEntry);
            classMods = extractStatDict(cEntry);
            // Ensure all keys present
            STAT_KEYS.forEach(k=>{ if (raceMods[k]==null) raceMods[k]=0; if (classMods[k]==null) classMods[k]=0; });
        } catch (e) { /* ignore */ }
    }

    function extractStatDict(obj) {
        // Heuristically find a dict mapping stat keys -> numbers
        const candidates = ['stat_modifiers','modifiers','stats','stat_bonuses','primary_stats','base_stats'];
        for (const key of candidates) {
            if (obj && typeof obj[key] === 'object' && obj[key] !== null) {
                const out = {};
                const source = obj[key];
                for (const [k,v] of Object.entries(source)) {
                    const KK = (k||'').toString().toUpperCase().slice(0,3);
                    if (STAT_KEYS.includes(KK) && typeof v === 'number') out[KK] = v;
                }
                const keys = Object.keys(out);
                if (keys.length) return out;
            }
        }
        return Object.fromEntries(STAT_KEYS.map(k=>[k,0]));
    }

    function hookCreatorStepNav() {
        const tabs = document.querySelectorAll('.cc-tab-btn');
        tabs.forEach(btn=>{
            btn.addEventListener('click', ()=>{
                const step = btn.getAttribute('data-step');
                document.querySelectorAll('.cc-tab-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                document.querySelectorAll('.cc-step').forEach(s=>{
                    if (s.getAttribute('data-step') === step) s.style.display='block'; else s.style.display='none';
                });
                if (step === 'stats') renderStatsUI();
            });
        });
    }
    
    // Initialize the module
    function init() {
        // Cache DOM elements
        iconDisplay = document.getElementById('character-icon-display');
        prevButton = document.getElementById('prev-icon-button');
        nextButton = document.getElementById('next-icon-button');
        sexSelector = document.getElementById('character-sex-select');
        
        // Add event listeners
        if (prevButton) prevButton.addEventListener('click', showPreviousIcon);
        if (nextButton) nextButton.addEventListener('click', showNextIcon);
        if (sexSelector) sexSelector.addEventListener('change', updateSexSelection);
        
        hookCreatorStepNav();
        // Load config-driven selects (races/classes/origins) and then icons
        loadConfigAndPopulate().then(()=>{
            loadFilteredIcons();
        }).catch(() => {
            // Fallback to flat icons list
            loadCharacterIcons();
        });

        // Stats controls
        const resetBtn = document.getElementById('cc-reset-btn');
        if (resetBtn) resetBtn.addEventListener('click', resetAlloc);
        const presetHealer = document.getElementById('cc-preset-healer');
        const presetCrusader = document.getElementById('cc-preset-crusader');
        const presetOracle = document.getElementById('cc-preset-oracle');
        if (presetHealer) presetHealer.addEventListener('click', ()=>applyPreset('Healer'));
        if (presetCrusader) presetCrusader.addEventListener('click', ()=>applyPreset('Crusader'));
        if (presetOracle) presetOracle.addEventListener('click', ()=>applyPreset('Oracle'));
        renderStatsUI();

        // Backstory AI buttons
        const improveBtn = document.getElementById('cc-improve-backstory');
        const generateBtn = document.getElementById('cc-generate-backstory');
        if (improveBtn) improveBtn.addEventListener('click', handleImproveBackstory);
        if (generateBtn) generateBtn.addEventListener('click', handleGenerateBackstory);
    }
    
    // Load character icons from the server (flat, fallback)
    async function loadCharacterIcons() {
        try {
            if (!apiClient || typeof apiClient.getCharacterIcons !== 'function') {
                console.error('API client not available or getCharacterIcons method not found');
                throw new Error('API client not available');
            }
            
            const data = await apiClient.getCharacterIcons();
            
            if (data.status === 'success' && data.icons) {
                characterIcons = data.icons;
                // Display the first icon if available
                if (characterIcons.length > 0) {
                    displayIcon(0);
                } else {
                    displayNoIconsMessage();
                }
            } else {
                throw new Error('Invalid response format');
            }
        } catch (error) {
            console.error('Error loading character icons:', error);
            displayNoIconsMessage();
        }
    }
    
    // Display the icon at the specified index
    function displayIcon(index) {
        if (!iconDisplay || characterIcons.length === 0) return;
        
        // Ensure index is within bounds
        currentIconIndex = (index + characterIcons.length) % characterIcons.length;
        
        const icon = characterIcons[currentIconIndex];
        selectedIcon = icon;
        
        // Update the icon display
        iconDisplay.innerHTML = '';
        iconDisplay.style.backgroundImage = `url('${icon.url}')`;
        iconDisplay.style.backgroundSize = 'contain';
        iconDisplay.style.backgroundPosition = 'center';
        iconDisplay.style.backgroundRepeat = 'no-repeat';
        
        // Update the form value for icon
        const iconInput = document.getElementById('character-icon-input');
        if (iconInput) {
            iconInput.value = icon.path;
        }
        
        // Update counter display
        const counterDisplay = document.getElementById('icon-counter');
        if (counterDisplay) {
            counterDisplay.textContent = `${currentIconIndex + 1} / ${characterIcons.length}`;
        }
    }
    
    // Display a message when no icons are available
    function displayNoIconsMessage() {
        if (!iconDisplay) return;
        
        iconDisplay.innerHTML = '<div class="no-icons-message">No character icons available</div>';
        iconDisplay.style.backgroundImage = 'none';
        
        // Update counter display
        const counterDisplay = document.getElementById('icon-counter');
        if (counterDisplay) {
            counterDisplay.textContent = '0 / 0';
        }
    }
    
    // Show the next icon
    function showNextIcon() {
        displayIcon(currentIconIndex + 1);
    }
    
    // Show the previous icon
    function showPreviousIcon() {
        displayIcon(currentIconIndex - 1);
    }
    
    // Handle sex selection change
    function updateSexSelection(event) {
        try { loadFilteredIcons(); } catch (e) { console.warn(e); }
    }

    let _originsDict = {};
    let _originList = [];
    async function loadConfigAndPopulate() {
        try {
            // Populate races and classes
            const racesData = await apiClient.getConfigRaces();
            const classesData = await apiClient.getConfigClasses();
            const originsData = await apiClient.getConfigOrigins();
            _originsDict = originsData.origins || {};
            _originList = originsData.list || [];
            const raceSel = document.getElementById('character-race-select');
            const classSel = document.getElementById('character-class-select');
            const originSel = document.getElementById('character-background-select');
            // Clear current options
            function setOptions(sel, names) {
                if (!sel) return;
                sel.innerHTML = '';
                names.forEach(n => {
                    const opt = document.createElement('option');
                    opt.value = n; opt.textContent = n;
                    sel.appendChild(opt);
                });
            }
            setOptions(raceSel, (racesData.names||[]));
            setOptions(classSel, (classesData.names||[]));
            // Populate origins (use list, set data-origin-id)
            if (originSel) {
                originSel.innerHTML = '';
                const list = _originList;
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = '-- Select an Origin ---';
                originSel.appendChild(placeholder);
                list.forEach(o => {
                    const opt = document.createElement('option');
                    opt.value = o.name || o.id || '';
                    opt.textContent = o.name || o.id || '';
                    if (o.id) opt.setAttribute('data-origin-id', o.id);
                    originSel.appendChild(opt);
                });
            }
            // On race/class change, reload icons and update stat modifiers
            if (raceSel) raceSel.addEventListener('change', () => { loadFilteredIcons(); computeModifiersFromConfig(); renderStatsUI(); });
            if (classSel) classSel.addEventListener('change', () => { loadFilteredIcons(); computeModifiersFromConfig(); renderStatsUI(); });
            if (originSel) originSel.addEventListener('change', () => updateOriginDetails());
            // Cache config for later
            CharacterCreator._config = { races: racesData.races||{}, classes: classesData.classes||{}, origins: originsData.origins||{} };
            // Initialize modifiers/details
            computeModifiersFromConfig();
            // Initialize origin details
            updateOriginDetails();
        } catch (e) {
            console.warn('Failed to populate selects from config', e);
            throw e;
        }
    }

    function _join(arr) {
        if (!Array.isArray(arr)) return '';
        return arr.map(x=> typeof x === 'string' ? x : (x && x.name) || String(x)).join(', ');
    }
    function _pick(obj, keys) {
        for (const k of keys) {
            if (obj && obj[k]!=null) return obj[k];
        }
        return null;
    }
    function _findOriginBySel(originSel) {
        if (!originSel) return null;
        const opt = originSel.selectedOptions && originSel.selectedOptions[0];
        if (!opt || !opt.value) return null;
        const oid = opt.getAttribute('data-origin-id');
        if (oid && _originsDict[oid]) return _originsDict[oid];
        const name = opt.value;
        return _originList.find(o => (o.name||o.id) === name) || null;
    }
    function updateOriginDetails() {
        try {
            const originSel = document.getElementById('character-background-select');
            const origin = _findOriginBySel(originSel);
            const descEl = document.getElementById('origin-description');
            const skillsEl = document.getElementById('origin-skills');
            const traitsEl = document.getElementById('origin-traits');
            const seedEl = document.getElementById('character-backstory-seed');
            if (!descEl || !skillsEl || !traitsEl || !seedEl) return;
            if (!origin) {
                descEl.textContent = 'Select an Origin to see details.';
                skillsEl.textContent = '-';
                traitsEl.textContent = '-';
                seedEl.value = '';
                return;
            }
            const description = _pick(origin, ['description','desc','summary','details']) || '';
            const profs = _pick(origin, ['skill_proficiencies','proficiencies','skills']) || [];
            const traits = _pick(origin, ['origin_traits','traits']) || [];
            // Backstory seed: try multiple possible fields
            let seed = _pick(origin, ['backstory_seed','seed','backstory','background_seed','starting_text']) || '';
            descEl.textContent = description || '-';
            skillsEl.textContent = _join(profs) || '-';
            traitsEl.textContent = _join(traits) || '-';
            if (!seedEl.value) seedEl.value = seed || '';
        } catch (e) {
            console.warn('Failed to update origin details', e);
        }
    }

    async function loadFilteredIcons() {
        try {
            const raceSel = document.getElementById('character-race-select');
            const classSel = document.getElementById('character-class-select');
            const sexSel = document.getElementById('character-sex-select');
            const race = raceSel ? raceSel.value : '';
            const clazz = classSel ? classSel.value : '';
            const sex = sexSel ? sexSel.value : 'Other';
            const data = await apiClient.getFilteredCharacterIcons(race, clazz, sex);
            if (data.status === 'success' && Array.isArray(data.icons)) {
                characterIcons = data.icons;
                if (characterIcons.length > 0) displayIcon(0); else displayNoIconsMessage();
            } else {
                displayNoIconsMessage();
            }
        } catch (e) {
            console.warn('Failed to load filtered icons', e);
            displayNoIconsMessage();
        }
    }
    
    // Get the currently selected icon
    function getSelectedIcon() {
        return selectedIcon;
    }
    
    // Validate the character creation form
    function validateForm() {
        const nameInput = document.getElementById('new-player-name');
        const originSel = document.getElementById('character-background-select');
        if (!nameInput || !nameInput.value.trim()) {
            alert('Please enter a character name');
            return false;
        }
        if (!originSel || !originSel.value) {
            alert('Please select an Origin');
            return false;
        }
        const remaining = getPointsRemaining();
        if (remaining < 0) {
            alert('You have allocated more points than available');
            return false;
        }
        return true;
    }
    
    // Backstory AI handlers
    function _getSelectedOriginId() {
        try {
            const originSel = document.getElementById('character-background-select');
            const opt = originSel?.selectedOptions && originSel.selectedOptions[0];
            if (!opt) return null;
            return opt.getAttribute('data-origin-id') || null;
        } catch(e) { return null; }
    }
    function _getPointsRemaining() { return getPointsRemaining(); }
    function _readBasicFields() {
        const name = (document.getElementById('new-player-name')?.value||'').trim();
        const race = document.getElementById('character-race-select')?.value||'';
        const path = document.getElementById('character-class-select')?.value||'';
        const sex = document.getElementById('character-sex-select')?.value||'';
        const origin_id = _getSelectedOriginId();
        return { name, race, path, sex, origin_id };
    }
    function _setBackstoryStatus(text, show=true) {
        const el = document.getElementById('cc-backstory-status');
        if (!el) return;
        el.textContent = text||'';
        el.style.display = show && text ? 'block' : 'none';
    }
    async function handleImproveBackstory() {
        try {
            const seedEl = document.getElementById('character-backstory-seed');
            const seed = (seedEl?.value||'').trim();
            const { name, race, path, sex, origin_id } = _readBasicFields();
            if (!name) { alert('Enter a character name first.'); return; }
            if (!origin_id) { alert('Select an Origin first.'); return; }
            if (!seed) { alert('Enter or load some seed text first.'); return; }
            if (_getPointsRemaining() > 0) { alert('Allocate all stat points first.'); return; }
            _setBackstoryStatus('Improving backstory...');
            const btn = document.getElementById('cc-improve-backstory'); if (btn) btn.disabled = true;
            const resp = await apiClient.improveBackstory({ name, race, path, origin_id, sex, seed_text: seed });
            if (resp && resp.narrative) seedEl.value = resp.narrative;
            _setBackstoryStatus('Backstory improved.', true);
        } catch (e) {
            console.error(e);
            _setBackstoryStatus('Failed to improve backstory.', true);
        } finally {
            const btn = document.getElementById('cc-improve-backstory'); if (btn) btn.disabled = false;
            setTimeout(()=>_setBackstoryStatus('', false), 2000);
        }
    }
    async function handleGenerateBackstory() {
        try {
            const seedEl = document.getElementById('character-backstory-seed');
            const { name, race, path, sex, origin_id } = _readBasicFields();
            if (!name) { alert('Enter a character name first.'); return; }
            if (!origin_id) { alert('Select an Origin first.'); return; }
            if (_getPointsRemaining() > 0) { alert('Allocate all stat points first.'); return; }
            _setBackstoryStatus('Generating backstory...');
            const btn = document.getElementById('cc-generate-backstory'); if (btn) btn.disabled = true;
            const resp = await apiClient.generateBackstory({ name, race, path, origin_id, sex });
            if (resp && resp.narrative) seedEl.value = resp.narrative;
            _setBackstoryStatus('Backstory generated.', true);
        } catch (e) {
            console.error(e);
            _setBackstoryStatus('Failed to generate backstory.', true);
        } finally {
            const btn = document.getElementById('cc-generate-backstory'); if (btn) btn.disabled = false;
            setTimeout(()=>_setBackstoryStatus('', false), 2000);
        }
    }

    // Public API
    return {
        init,
        getSelectedIcon,
        validateForm,
        getAllocatedStats: () => {
            // Return base + adjust only (engine will apply race/class modifiers)
            const out = {};
            STAT_KEYS.forEach(k=> out[k] = (statBase[k]||BASE_DEFAULT) + (statAdjust[k]||0));
            return out;
        }
    };
})();

// Initialize the module when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', CharacterCreator.init);

// Export the module for use in other scripts
window.CharacterCreator = CharacterCreator;

```

### File: web\client\js\main.js

```javascript
/**
 * Main JavaScript for RPG Game Web Interface
 * Initializes all components and handles application flow
 */

// Wait for DOM to be fully loaded
document.addEventListener('DOMContentLoaded', () => {
    // Let UI manager initialize model options
    // This code has been moved to the UI manager to prevent race conditions
    /*
    setTimeout(() => {
        // Initialize model options for each agent
        ['narrator', 'rule-checker', 'context-evaluator'].forEach(agent => { 
            const providerSelect = document.getElementById(`${agent}-provider`);
            if (providerSelect) {
                const event = new Event('change');
                providerSelect.dispatchEvent(event);
            }
        });
    }, 100);
    */
    // Initialize UI event listeners
    uiManager.initEventListeners();
    
    // New Game button
    document.getElementById('new-game-btn').addEventListener('click', () => {
        uiManager.openModal('newGame');
        
        // Initialize character creator if available
        if (window.CharacterCreator && typeof window.CharacterCreator.init === 'function') {
            // Initialize with a small delay to ensure the modal is fully open
            setTimeout(() => {
                window.CharacterCreator.init();
            }, 100);
        }
    });
    
    // Create Game button (inside new game modal)
    document.getElementById('create-game-btn').addEventListener('click', () => {
        // Validate using the CharacterCreator module if it exists
        if (window.CharacterCreator && typeof window.CharacterCreator.validateForm === 'function') {
            if (!window.CharacterCreator.validateForm()) {
                return; // Validation failed
            }
        } else {
            // Fallback validation
            const playerName = document.getElementById('new-player-name').value.trim();
            if (!playerName) {
                uiManager.showNotification('Please enter a character name', 'warning');
                return;
            }
        }
        
        // Get character information from the form
        const playerName = document.getElementById('new-player-name').value.trim();
        const race = document.getElementById('character-race-select').value;
        const characterClass = document.getElementById('character-class-select').value;
        const originLabel = document.getElementById('character-background-select').value;
        const seedEl = document.getElementById('character-backstory-seed');
        const background = (seedEl && seedEl.value && seedEl.value.trim()) ? seedEl.value.trim() : originLabel;
        const sex = document.getElementById('character-sex-select').value;
        const useLLM = document.getElementById('character-llm-toggle').checked;
        const stats = (window.CharacterCreator && typeof window.CharacterCreator.getAllocatedStats==='function') ? window.CharacterCreator.getAllocatedStats() : null;
        
        // Get selected icon if available
        let characterIcon = null;
        if (window.CharacterCreator && typeof window.CharacterCreator.getSelectedIcon === 'function') {
            const iconInfo = window.CharacterCreator.getSelectedIcon();
            if (iconInfo) {
                characterIcon = iconInfo.path;
            }
        }
        
        // Determine selected origin_id from option dataset if available
        let originId = null;
        try {
            const originSelect = document.getElementById('character-background-select');
            if (originSelect && originSelect.selectedOptions && originSelect.selectedOptions.length > 0) {
                originId = originSelect.selectedOptions[0].getAttribute('data-origin-id') || null;
            }
        } catch (e) { /* ignore */ }
        // Create the new game with all parameters
        createNewGame(playerName, {
            race: race,
            path: characterClass,
            background: background,
            sex: sex,
            characterImage: characterIcon,
            useLLM: useLLM,
            origin_id: originId,
            stats
        });
    });
    
    // Save Game button
    document.getElementById('save-game-btn').addEventListener('click', () => {
        if (!apiClient.hasActiveSession()) {
            uiManager.showNotification('No active game to save', 'warning');
            return;
        }
        
        uiManager.openModal('saveGame');
    });
    
    // Save button (inside save game modal)
    document.getElementById('save-btn').addEventListener('click', () => {
        const saveName = document.getElementById('save-name').value.trim();
        saveGame(saveName);
    });
    
    // Load Game button
    document.getElementById('load-game-btn').addEventListener('click', () => {
        loadSavesList();
    });
    
    // Settings button
    document.getElementById('settings-btn').addEventListener('click', async () => {
        uiManager.openModal('settings');
        
        // Load LLM settings when settings dialog is opened
        try {
            await uiManager.loadLLMSettings();
        } catch (error) {
            console.error('Error loading LLM settings:', error);
            uiManager.showNotification('Error loading LLM settings', 'error');
        }
    });
    
    // LLM button opens settings to LLM tab
    const llmBtn = document.getElementById('llm-btn');
    if (llmBtn) {
        llmBtn.addEventListener('click', async () => {
            uiManager.openModal('settings');
            try { await uiManager.loadLLMSettings(); } catch {}
            // switch to llm tab
            uiManager.switchTab('llm-settings');
        });
    }

    // Exit button
    const exitBtn = document.getElementById('exit-btn');
    if (exitBtn) {
        exitBtn.addEventListener('click', async () => {
            try { await apiClient.endSession(); } catch {}
            uiManager.disableCommandInput();
            hideGamePanels();
            uiManager.addMessage('Session ended.', 'system');
        });
    }

    // Command submission
    document.getElementById('send-command-btn').addEventListener('click', () => {
        sendCommand();
    });
    
// Command submission via Enter key (suppress default to avoid accidental double-trigger)
    document.getElementById('command-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            sendCommand();
        }
    });
    
    // Listen for save loading event
    document.addEventListener('load-save', (e) => {
        loadGame(e.detail.saveId);
    });

    // Listen for new session creation
    document.addEventListener('session-created', (e) => {
        // Show game panels when session is created
        showGamePanels();
        // Always reconnect to ensure fresh connection
        connectWebSocket(e.detail.sessionId);
        uiManager.enableCommandInput();
    });
    
    // Check for existing session
    checkExistingSession();
    
    // Check server status
    checkServerStatus();
});

/**
 * Show game output, command input, right panel, and status bar (when session becomes active)
 */
function showGamePanels() {
    const gameOutput = document.getElementById('game-output');
    const rightPanel = document.querySelector('.right-panel');
    const commandInput = document.querySelector('.command-input-container');
    const statusBar = document.querySelector('.status-bar');
    
    console.log('showGamePanels() called');
    console.log('  gameOutput:', gameOutput, 'current display:', gameOutput?.style?.display);
    console.log('  rightPanel:', rightPanel, 'current display:', rightPanel?.style?.display);
    console.log('  commandInput:', commandInput, 'current display:', commandInput?.style?.display);
    console.log('  statusBar:', statusBar, 'current display:', statusBar?.style?.display);
    
    if (gameOutput) {
        gameOutput.style.display = 'block';
        console.log('  -> gameOutput display set to block');
    }
    if (rightPanel) {
        rightPanel.style.display = 'block';
        console.log('  -> rightPanel display set to block');
    }
    if (commandInput) {
        commandInput.style.display = 'flex';
        console.log('  -> commandInput display set to flex');
    }
    if (statusBar) {
        statusBar.style.display = 'block';
        console.log('  -> statusBar display set to block');
    }
}

/**
 * Hide game output, command input, right panel, and status bar (when session ends)
 */
function hideGamePanels() {
    const gameOutput = document.getElementById('game-output');
    const rightPanel = document.querySelector('.right-panel');
    const commandInput = document.querySelector('.command-input-container');
    const statusBar = document.querySelector('.status-bar');
    
    console.log('hideGamePanels() called');
    
    if (gameOutput) {
        gameOutput.style.display = 'none';
    }
    if (rightPanel) {
        rightPanel.style.display = 'none';
    }
    if (commandInput) {
        commandInput.style.display = 'none';
    }
    if (statusBar) {
        statusBar.style.display = 'none';
    }
}

/**
 * Check if the server is available
 */
async function checkServerStatus() {
    try {
        const isAvailable = await apiClient.checkServerStatus();
        
        if (!isAvailable) {
            uiManager.showNotification('Server is not available. Please try again later.', 'error', 0);
        }
    } catch (error) {
        console.error('Server check failed:', error);
        uiManager.showNotification('Unable to connect to the server.', 'error', 0);
    }
}

/**
 * Check for existing session and restore if found
 */
function checkExistingSession() {
    if (apiClient.hasActiveSession()) {
        // Show game panels
        showGamePanels();
        uiManager.addMessage('Reconnecting to existing game session...', 'system');
        connectWebSocket(apiClient.sessionId);
        uiManager.enableCommandInput();
    }
}

/**
 * Create a new game with optional character customization
 * 
 * @param {string} playerName - Name of the character
 * @param {Object} options - Optional character customization options
 */
async function createNewGame(playerName, options = {}) {
    try {
        // Clear any existing game
        uiManager.clearOutput();
        
        // Show loading message
        uiManager.addMessage('Creating new game...', 'system');
        
        // Clean up any existing session before creating a new game
        if (apiClient.hasActiveSession()) {
            const oldSessionId = apiClient.sessionId;
            // Disconnect WebSocket (intentional)
            if (webSocketClient.isConnected) {
                webSocketClient.disconnect(true);
            }
            // Clean up the old session on server
            await apiClient.cleanupSession(oldSessionId);
            // Clear local session
            apiClient.clearSession();
            // Wait briefly for clean disconnection and cleanup
            await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        // Create new game via API with all character options
        const result = await apiClient.createNewGame(playerName, options);
        
        // Close the modal
        uiManager.closeAllModals();
        
        // Connect WebSocket for the new session
        connectWebSocket(result.session_id, { isNewGame: true });
        
        // Extract character details for UI update
        const characterRace = options.race || result.race || 'Human';
        const characterClass = options.path || result.path || 'Wanderer';
        
        // Update UI
        uiManager.updateGameInfo({
            player: {
                name: playerName,
                level: 1,
                race: characterRace,
                path: characterClass
            },
            location: result.location || 'Starting Area',
            time: result.game_time || 'Dawn'
        });
        
        // Enable input
        uiManager.enableCommandInput();
        // Refresh full UI (right panel + status)
        uiManager.refreshUI();
        
        // Initial narrative and help will arrive via WebSocket events from the engine
        
        // Create user-event for session creation (for other components to react to)
        document.dispatchEvent(new CustomEvent('session-created', { 
            detail: { 
                sessionId: result.session_id,
                playerData: result
            }
        }));
        
    } catch (error) {
        console.error('Error creating new game:', error);
        uiManager.showNotification('Failed to create new game: ' + error.message, 'error');
    }
}

/**
 * Connect to WebSocket for real-time updates
 */
function connectWebSocket(sessionId, options = {}) {
    if (!sessionId && !apiClient.sessionId) {
        console.error('No session ID to connect WebSocket');
        return;
    }
    
    const id = sessionId || apiClient.sessionId;
    
    // If already connected to this session, don't reconnect
    if (webSocketClient.socket && webSocketClient.isConnected && webSocketClient.sessionId === id) {
        console.log('Already connected to session', id);
        return;
    }
    
    // Only disconnect if not already done (e.g., for new games, we disconnect earlier)
    if (!options.isNewGame && webSocketClient.isConnected) {
        webSocketClient.disconnect(false); // Not intentional - we're reconnecting immediately
    }
    
    // Remove any existing event handlers to prevent duplication
    if (typeof webSocketClient.offAll === 'function') {
        // Clear all event handlers
        Object.keys(webSocketClient.eventHandlers).forEach(eventType => {
            webSocketClient.offAll(eventType);
        });
    } else {
        // Alternative cleanup if offAll is not available
        console.warn('WebSocketClient.offAll is not available - using manual event handler cleanup');
        webSocketClient.eventHandlers = {
            'connect': [],
            'disconnect': [],
            'game_state': [],
            'command_result': [],
            'game_loaded': [],
            'time_update': [],
            'stats_changed': [],
            'turn_order_update': [],
            'ui_bar_update_phase1': [],
            'ui_bar_update_phase2': [],
            'combat_log_set_html': [],
            'combat_log_append': [],
            'narrative': [],
            'journal_updated': [],
            'error': []
        };
    }
    
    // Set up WebSocket event handlers BEFORE connecting
    webSocketClient.on('game_state', (data) => {
        // Update status and right panel on push
        uiManager.refreshUI();
        console.log('Received game state update');
        updateGameState(data);
    });
    
    webSocketClient.on('command_result', (data) => {
        console.log('Received command result via WebSocket');
        // Only handle responses that came from WebSocket to prevent duplication
        if (data.source === 'websocket') {
            handleCommandResult(data);
        }
    });
    
    webSocketClient.on('game_loaded', (data) => {
        console.log('Received game loaded event');
        if (data.state) {
            updateGameState(data.state);
        }
        if (data.message) {
            uiManager.addMessage(data.message, 'system');
        }
        // Ensure UI is refreshed (and Combat tab activated if needed)
        try { uiManager.refreshUI(); } catch (e) { console.warn(e); }
    });
    
    webSocketClient.on('time_update', (data) => {
        if (data.time) {
            uiManager.gameTimeElement.textContent = data.time;
        }
    });
    
    webSocketClient.on('error', (data) => {
        uiManager.showNotification('Connection error: ' + data.message, 'error');
    });
    
    webSocketClient.on('disconnect', (data) => {
        uiManager.addMessage('Connection to server lost. Attempting to reconnect...', 'system');
    });
    
    webSocketClient.on('connect', (data) => {
        uiManager.addMessage('Connected to game server.', 'system');
    });
    
    // Live UI updates from server events
    webSocketClient.on('stats_changed', () => { try { uiManager.refreshUI(); } catch (e) { console.warn(e); } });
    webSocketClient.on('turn_order_update', () => { try { uiManager.refreshUI(); } catch (e) { console.warn(e); } });
    webSocketClient.on('ui_bar_update_phase1', (data) => { try { uiManager.updateResourceBarPhase1(data?.bar_type||data?.metadata?.bar_type||'hp', data||{}); } catch (e) { console.warn(e); } });
    webSocketClient.on('ui_bar_update_phase2', (data) => { try { uiManager.updateResourceBarPhase2(data?.bar_type||data?.metadata?.bar_type||'hp', data||{}); } catch (e) { console.warn(e); } });
    // Combat log HTML updates
    webSocketClient.on('combat_log_set_html', (data) => {
        try { uiManager.setCombatLogHtml(data?.html || ''); } catch (e) { console.warn(e); }
    });
    webSocketClient.on('narrative', (data) => {
        try {
            const role = (data && data.role) || 'system';
            const text = (data && data.text) || '';
            // Prefer server hint if provided; otherwise default to gradual for non-system narrations
            const hasGradual = data && Object.prototype.hasOwnProperty.call(data, 'gradual');
            const gradual = hasGradual ? !!data.gradual : (String(role).toLowerCase() !== 'system');
            // Suppress pure echo of the last command we sent (attempt messages)
            try {
                const lastCmd = (uiManager.lastSentCommand || '').trim();
                if (lastCmd && text && text.trim() === lastCmd) {
                    return; // skip duplicate echo
                }
            } catch {}
            uiManager.addMessage(text, role === 'system' ? 'system' : 'game', gradual);
        } catch (e) { console.warn(e); }
    });
    // New: append incremental mechanics lines to combat tab
    webSocketClient.on('combat_log_append', (data) => {
        try { uiManager.appendCombatLogLine(data || {}); } catch (e) { console.warn(e); }
    });
    webSocketClient.on('journal_updated', ()=>{ try { uiManager.refreshUI(); } catch (e) { console.warn(e); } });
    // Connect WebSocket only after setting up all handlers
    webSocketClient.connect(id);
}

/**
 * Send a command to the server
 */
async function sendCommand() {
    const command = uiManager.commandInput.value.trim();
    
    if (!command) {
        return;
    }
    
    if (!apiClient.hasActiveSession()) {
        uiManager.showNotification('No active game session', 'warning');
        return;
    }
    
    try {
        // Remember last sent command for echo-suppression on WS stream
        uiManager.lastSentCommand = command;
        
        // Local echo so the user immediately sees what they typed
        uiManager.addMessage(command, 'player');
        
        // Add to command history
        uiManager.addCommandToHistory(command);
        
        // Clear input
        uiManager.clearCommandInput();
        
        // Send command to server
        const result = await apiClient.sendCommand(command);
        
        // Handle result only if it came from HTTP response
        if (result.source === 'http_response') {
            // Refresh UI after command
            uiManager.refreshUI();
            // Do not display narrative here; rely on WebSocket stream for messages
            handleCommandResult(result);
        }
        
    } catch (error) {
        console.error('Command error:', error);
        uiManager.addMessage(`Error: ${error.message}`, 'system');
    }
}

/**
 * Handle command result
 */
function handleCommandResult(result) {
    if (!result) return;
    
    // IMPORTANT: Do NOT add result.message here to avoid duplicates.
    // Narrative and system text are streamed via WebSocket 'narrative' events.
    // This handler should only update state and handle control flow.
    
    // Update game state if provided
    if (result.state) {
        updateGameState(result.state);
    }
    
    // Handle exit command
    if (result.status === 'EXIT') {
        handleGameExit();
    }
}

/**
 * Update game state in UI
 */
function updateGameState(state) {
    if (!state) return;
    
    const gameInfo = {
        player: state.player,
        location: state.player?.location || state.location,
        time: state.time
    };
    
    uiManager.updateGameInfo(gameInfo);
}

/**
 * Handle game exit
 */
function handleGameExit() {
    apiClient.endSession().then(() => {
        webSocketClient.disconnect(true); // Intentional disconnect
        uiManager.disableCommandInput();
        hideGamePanels();
        uiManager.addMessage('Thanks for playing! Refresh the page to start a new game.', 'system');
    });
}

/**
 * Save the current game
 */
async function saveGame(saveName) {
    if (!apiClient.hasActiveSession()) {
        uiManager.showNotification('No active game to save', 'warning');
        return;
    }
    
    try {
        const result = await apiClient.saveGame(saveName);
        uiManager.closeAllModals();
        
        if (result.status === 'success') {
            uiManager.addMessage(`Game saved as "${result.save_name}"`, 'system');
            uiManager.showNotification('Game saved successfully', 'success');
        }
    } catch (error) {
        console.error('Save error:', error);
        uiManager.showNotification('Failed to save game: ' + error.message, 'error');
    }
}

/**
 * Load available saves list
 */
async function loadSavesList() {
    try {
        // Open the modal and show loading state
        uiManager.openModal('loadGame');
        
        // Fetch saves
        const result = await apiClient.listSaves();
        
        if (result.status === 'success') {
            // Populate the saves list
            uiManager.populateSavesList(result.saves);
        } else {
            uiManager.savesList.innerHTML = '<div class="error-message">Failed to load saves.</div>';
        }
    } catch (error) {
        console.error('List saves error:', error);
        uiManager.savesList.innerHTML = '<div class="error-message">Failed to load saves: ' + error.message + '</div>';
    }
}

/**
 * Load a saved game
 */
async function loadGame(saveId) {
    try {
        // Clear the current output
        uiManager.clearOutput();
        uiManager.addMessage('Loading game...', 'system');
        
        // Ensure we have a fresh session for loading
        // Clean up any existing session first
        if (apiClient.hasActiveSession()) {
            try {
                if (webSocketClient.isConnected) {
                    webSocketClient.disconnect(true); // Intentional disconnect
                }
                // Don't call endSession - just clear local state since we're loading into the same session
                // await apiClient.endSession();
            } catch (e) {
                console.warn('Error cleaning up old session:', e);
            }
        }
        
        // Create a new session for loading the game
        const sessionResult = await apiClient.createSession();
        
        // Connect WebSocket before loading so we can receive events
        connectWebSocket(sessionResult.session_id);
        
        // Small delay to ensure WebSocket is ready
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Now load the game with the active session
        const result = await apiClient.loadGame(saveId);
        
        if (result.status === 'success') {
            // Show game panels since we now have an active session
            showGamePanels();
            
            // Update game state from the load result
            if (result.state) {
                updateGameState(result.state);
            }
            
            // Enable command input
            uiManager.enableCommandInput();
            
            // Refresh UI to populate right panel with character stats
            await uiManager.refreshUI();
            
            // Give WebSocket events time to arrive (including combat log HTML)
            await new Promise(resolve => setTimeout(resolve, 500));
            
            uiManager.addMessage('Game loaded successfully.', 'system');
            uiManager.showNotification('Game loaded successfully', 'success');
            
            // Close the load game modal
            uiManager.closeAllModals();
        } else {
            throw new Error(result.message || 'Failed to load game');
        }
    } catch (error) {
        console.error('Load game error:', error);
        uiManager.addMessage('Failed to load game: ' + (error.message || error), 'system');
        uiManager.showNotification('Failed to load game: ' + (error.message || error), 'error');
    }
}

// Handle window beforeunload event to warn about losing game progress
window.addEventListener('beforeunload', (event) => {
    if (apiClient.hasActiveSession()) {
        const message = 'You have an active game session. Leaving this page will end your session.';
        event.returnValue = message;
        return message;
    }
});

```

### File: web\client\js\model-debug.js

```javascript
// Debug script to identify what's replacing the SELECT element with INPUT
window.addEventListener('DOMContentLoaded', function() {
    // Direct fix for OpenRouter model field
    function fixOpenRouterModelField() {
        // Get all provider dropdowns
        const providerSelects = [
            document.getElementById('narrator-provider'),
            document.getElementById('rule-checker-provider'),
            document.getElementById('context-evaluator-provider')
        ];
        
        // Watch for changes and fix the model field
        providerSelects.forEach(providerSelect => {
            if (!providerSelect) return;
            
            providerSelect.addEventListener('change', function(e) {
                const agent = this.id.split('-')[0];
                const provider = this.value;
                
                console.log(`Provider changed for ${agent} to ${provider}`);
                
                // If OpenRouter is selected, wait for the model field to be created
                // then check if it's an INPUT and replace it with a SELECT if needed
                if (provider === 'OPENROUTER') {
                    setTimeout(() => {
                        const modelElement = document.getElementById(`${agent}-model`);
                        console.log(`Model element for ${agent}: ${modelElement ? modelElement.tagName : 'not found'}`);
                        
                        if (modelElement && modelElement.tagName === 'INPUT') {
                            console.log(`Found INPUT for ${agent} model, replacing with SELECT`);
                            
                            // Create a replacement SELECT
                            const modelFormGroup = modelElement.closest('.form-group');
                            if (modelFormGroup) {
                                // Save any entered value
                                const currentValue = modelElement.value;
                                
                                // Clear the form group
                                modelFormGroup.innerHTML = '';
                                
                                // Create label
                                const label = document.createElement('label');
                                label.setAttribute('for', `${agent}-model`);
                                label.textContent = 'Model:';
                                modelFormGroup.appendChild(label);
                                
                                // Create new SELECT
                                const select = document.createElement('select');
                                select.id = `${agent}-model`;
                                
                                // Add OpenRouter models
                                const openRouterModels = [
                                    { value: 'google/gemini-2.0-flash-lite-preview-02-05:free', label: 'Google Gemini 2.0 Flash Lite (Free)' },
                                    { value: 'nousresearch/deephermes-3-llama-3-8b-preview:free', label: 'DeepHermes 3 Llama 3 8B (Free)' },
                                    { value: 'google/gemini-2.0-pro-exp-02-05:free', label: 'Google Gemini 2.0 Pro (Free)' },
                                    { value: 'mistralai/mistral-small-3.1-24b-instruct:free', label: 'Mistral Small 3.1 24B (Free)' },
                                    { value: 'google/gemini-2.0-flash-exp:free', label: 'Google Gemini 2.0 Flash (Free)' },
                                    // Include the current value if it's not empty
                                    ...(currentValue ? [{ value: currentValue, label: currentValue }] : [])
                                ];
                                
                                openRouterModels.forEach(model => {
                                    const option = document.createElement('option');
                                    option.value = model.value;
                                    option.textContent = model.label;
                                    select.appendChild(option);
                                });
                                
                                // Set the value if it exists
                                if (currentValue) {
                                    select.value = currentValue;
                                }
                                
                                // Add the select to the form group
                                modelFormGroup.appendChild(select);
                                
                                console.log(`Successfully replaced INPUT with SELECT for ${agent}`);
                            }
                        }
                    }, 100);
                }
            });
            
            // Also run once on page load to fix existing fields
            setTimeout(() => {
                if (providerSelect.value === 'OPENROUTER') {
                    const agent = providerSelect.id.split('-')[0];
                    const modelElement = document.getElementById(`${agent}-model`);
                    
                    if (modelElement && modelElement.tagName === 'INPUT') {
                        console.log(`Found INPUT for ${agent} model on load, replacing with SELECT`);
                        
                        // Create a replacement SELECT (same code as above)
                        const modelFormGroup = modelElement.closest('.form-group');
                        if (modelFormGroup) {
                            // Save any entered value
                            const currentValue = modelElement.value;
                            
                            // Clear the form group
                            modelFormGroup.innerHTML = '';
                            
                            // Create label
                            const label = document.createElement('label');
                            label.setAttribute('for', `${agent}-model`);
                            label.textContent = 'Model:';
                            modelFormGroup.appendChild(label);
                            
                            // Create new SELECT
                            const select = document.createElement('select');
                            select.id = `${agent}-model`;
                            
                            // Add OpenRouter models
                            const openRouterModels = [
                                { value: 'google/gemini-2.0-flash-lite-preview-02-05:free', label: 'Google Gemini 2.0 Flash Lite (Free)' },
                                { value: 'nousresearch/deephermes-3-llama-3-8b-preview:free', label: 'DeepHermes 3 Llama 3 8B (Free)' },
                                { value: 'google/gemini-2.0-pro-exp-02-05:free', label: 'Google Gemini 2.0 Pro (Free)' },
                                { value: 'mistralai/mistral-small-3.1-24b-instruct:free', label: 'Mistral Small 3.1 24B (Free)' },
                                { value: 'google/gemini-2.0-flash-exp:free', label: 'Google Gemini 2.0 Flash (Free)' },
                                // Include the current value if it's not empty
                                ...(currentValue ? [{ value: currentValue, label: currentValue }] : [])
                            ];
                            
                            openRouterModels.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.value;
                                option.textContent = model.label;
                                select.appendChild(option);
                            });
                            
                            // Set the value if it exists
                            if (currentValue) {
                                select.value = currentValue;
                            }
                            
                            // Add the select to the form group
                            modelFormGroup.appendChild(select);
                            
                            console.log(`Successfully replaced INPUT with SELECT for ${agent} on load`);
                        }
                    }
                }
            }, 500);
        });
    }
    
    // Run the fix
    setTimeout(fixOpenRouterModelField, 1000);
});

```

### File: web\client\js\ui-manager.js

```javascript
/**
 * UI Manager for RPG Game Web Interface
 * Handles DOM interactions and UI state
 */

class UiManager {
    constructor() {
        // Main UI elements
        this.outputElement = document.getElementById('game-output');
        this.commandInput = document.getElementById('command-input');
        this.sendButton = document.getElementById('send-command-btn');

        // Lightweight recent message de-duplication
        // Stores { key: string, ts: number } for last few seconds
        this._recentMsgKeys = [];

        // Game info elements
        this.playerNameElement = document.getElementById('player-name');
        this.playerLevelElement = document.getElementById('player-level');
        this.locationElement = document.getElementById('current-location');
        this.gameTimeElement = document.getElementById('game-time');

        // Menu buttons
        this.newGameButton = document.getElementById('new-game-btn');
        this.saveGameButton = document.getElementById('save-game-btn');
        this.loadGameButton = document.getElementById('load-game-btn');
        this.settingsButton = document.getElementById('settings-btn');

        // Modal elements
        this.modals = {
            newGame: document.getElementById('new-game-modal'),
            saveGame: document.getElementById('save-game-modal'),
            loadGame: document.getElementById('load-game-modal'),
            settings: document.getElementById('settings-modal'),
            itemInfo: document.getElementById('item-info-modal')
        };

        // Form elements
        this.newPlayerNameInput = document.getElementById('new-player-name');
        this.saveNameInput = document.getElementById('save-name');
        this.savesList = document.getElementById('saves-list');
        this.loadButton = document.getElementById('load-btn');

        // Notification container
        this.notificationContainer = document.getElementById('notification-container');

        // Command history
        this.commandHistory = [];
        this.historyIndex = -1;

        // Gradual message queue (to ensure sequential, readable display)
        this._messageQueue = [];
        this._isTyping = false;

        // Settings
        this.settings = {
            theme: localStorage.getItem('rpg_theme') || 'light',
            fontSize: localStorage.getItem('rpg_font_size') || '16',
            llmEnabled: localStorage.getItem('rpg_llm_enabled') === 'true' || false
        };

        // Initialize theme
        this.applyTheme(this.settings.theme);
        
        // Initialize font size
        this.applyFontSize(this.settings.fontSize);
        
        // Track mode transitions for auto-activating combat tab
        this._prevMode = null;
        this._autoCombatShown = false;
        
        // Enforce base layout anchors before loading any saved styles
        this.enforceMainLayoutAnchors();
        this.enforceCenterStackOrder();
        this.applySavedElementStyles();
        this.initStyleToolsBindings();
        // Final enforcement after all styles are loaded
        this.enforceMainLayoutAnchors();
        this.enforceCenterStackOrder();
        this.autoHealLayoutIfCorrupted();
        this.llmSettings = {
            providers: {},
            agents: {}
        };
        
        // This flag is used to block any other code from modifying the model element
        this.isUpdatingModelOptions = false;
        
        // Set up MutationObserver to prevent INPUT elements being created
        this.setupMutationObserver();

        // Apply background from server assets (matches Py GUI backgrounds)
        this.applyBackgroundFromServer();
    }
    
    // NEW FUNCTION: Prevent other code from replacing SELECT with INPUT
    setupMutationObserver() {
        // Create a MutationObserver to monitor for changes to the DOM
        this.observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                // Only act if we're not currently updating model options ourselves
                if (!this.isUpdatingModelOptions) {
                    if (mutation.type === 'childList') {
                        // Check if any INPUTs have been added with ID ending in -model
                        Array.from(mutation.addedNodes).forEach(node => {
                            if (node.nodeType === 1 && node.tagName === 'INPUT' && node.id && node.id.endsWith('-model')) {
                                console.log(`Detected INPUT added for ${node.id}, converting back to SELECT`);
                                const agent = node.id.split('-')[0];
                                const provider = document.getElementById(`${agent}-provider`)?.value || 'OPENAI';
                                
                                // Force create a SELECT to replace the INPUT
                                this.forceCreateSelect(agent, provider, node.value);
                            }
                        });
                    }
                    
                    // Also check if attributes have changed on model elements
                    if (mutation.type === 'attributes' && 
                        mutation.attributeName === 'type' && 
                        mutation.target.id && 
                        mutation.target.id.endsWith('-model')) {
                        
                        if (mutation.target.type === 'text') {
                            console.log(`Detected model element changed to INPUT type for ${mutation.target.id}`);
                            const agent = mutation.target.id.split('-')[0];
                            const provider = document.getElementById(`${agent}-provider`)?.value || 'OPENAI';
                            
                            // Force create a SELECT to replace the INPUT
                            this.forceCreateSelect(agent, provider, mutation.target.value);
                        }
                    }
                }
            });
        });
        
        // Start observing the entire document
        this.observer.observe(document.body, { 
            childList: true, 
            subtree: true,
            attributes: true,
            attributeFilter: ['type']
        });
    }
    
    // NEW FUNCTION: Force create a SELECT element to replace an INPUT
    forceCreateSelect(agent, provider, currentValue = '') {
        // Set flag to prevent observer from acting
        this.isUpdatingModelOptions = true;
        
        try {
            // Find the model form group
            const modelElement = document.getElementById(`${agent}-model`);
            if (!modelElement) {
                console.error(`Cannot find model element for ${agent}`);
                return;
            }
            
            const modelFormGroup = modelElement.closest('.form-group');
            if (!modelFormGroup) {
                console.error(`Cannot find form group for ${agent} model`);
                return;
            }
            
            // Clear the form group
            modelFormGroup.innerHTML = '';
            
            // Create label
            const label = document.createElement('label');
            label.setAttribute('for', `${agent}-model`);
            label.textContent = 'Model:';
            modelFormGroup.appendChild(label);
            
            // Create SELECT
            const select = document.createElement('select');
            select.id = `${agent}-model`;
            
            // Get models based on provider
            let models = [];
            
            if (provider === 'OPENROUTER') {
                // OpenRouter models
                models = [
                    { value: 'google/gemini-2.0-flash-lite-preview-02-05:free', label: 'Google Gemini 2.0 Flash Lite (Free)' },
                    { value: 'nousresearch/deephermes-3-llama-3-8b-preview:free', label: 'DeepHermes 3 Llama 3 8B (Free)' },
                    { value: 'google/gemini-2.0-pro-exp-02-05:free', label: 'Google Gemini 2.0 Pro (Free)' },
                    { value: 'mistralai/mistral-small-3.1-24b-instruct:free', label: 'Mistral Small 3.1 24B (Free)' },
                    { value: 'google/gemini-2.0-flash-exp:free', label: 'Google Gemini 2.0 Flash (Free)' }
                ];
                
                // Add current value if not empty and not already in the list
                if (currentValue && !models.some(m => m.value === currentValue)) {
                    models.push({ value: currentValue, label: currentValue });
                }
            } else if (provider === 'OPENAI') {
                // OpenAI models
                models = [
                    { value: 'gpt-4o-mini', label: 'GPT-4o Mini' },
                    { value: 'gpt-4o', label: 'GPT-4o' },
                ];
            } else if (provider === 'GOOGLE') {
                // Google models
                models = [
                    { value: 'gemini-2.0-flash', label: 'Gemini 2.0 Flash' },
                    { value: 'gemini-2.0-pro-latest', label: 'Gemini 2.0 Pro' },
                ];
            } else {
                models = [
                    { value: 'unknown-provider-model', label: 'Select Model' }
                ];
            }
            
            // Add options to the select
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.label;
                select.appendChild(option);
            });
            
            // Set the value if it exists in options
            if (currentValue) {
                const option = Array.from(select.options).find(opt => opt.value === currentValue);
                if (option) {
                    select.value = currentValue;
                }
            }
            
            // Append the select to the form group
            modelFormGroup.appendChild(select);
            
            console.log(`Successfully created SELECT for ${agent} with provider ${provider}`);
        } finally {
            // Reset flag
            this.isUpdatingModelOptions = false;
        }
    }

    /**
     * Initialize UI event listeners
     */
    initEventListeners() {
        // Initialize agent provider change listeners
        const agentNames = ['narrator', 'rule-checker', 'context-evaluator'];
        agentNames.forEach(agent => {
            const providerSelect = document.getElementById(`${agent}-provider`);
            if (providerSelect) {
                providerSelect.addEventListener('change', (e) => {
                    this.updateModelOptionsForAgent(agent, e.target.value);
                });

                // Initialize model options based on current provider selection
                // Use a single flag to prevent duplicate initialization
                if (!window._modelInitialized) {
                    window._modelInitialized = {};
                }
                
                if (!window._modelInitialized[agent]) {
                    window._modelInitialized[agent] = true;
                    setTimeout(() => {
                        this.updateModelOptionsForAgent(agent, providerSelect.value);
                    }, 200);
                }
            }
        });

        // Initialize close buttons on all modals
        document.querySelectorAll('.close-modal, .cancel-btn').forEach(element => {
            element.addEventListener('click', () => {
                this.closeAllModals();
            });
        });

        // Close modal when clicking outside
        window.addEventListener('click', (event) => {
            for (const modalName in this.modals) {
                const modal = this.modals[modalName];
                if (event.target === modal) {
                    this.closeModal(modalName);
                }
            }
        });

        // Initialize settings controls
        if (document.getElementById('theme-select')) {
            document.getElementById('theme-select').addEventListener('change', (e) => {
                this.applyTheme(e.target.value);
            });
        }
        // Background select
        const bgSelect = document.getElementById('background-select');
        if (bgSelect) {
            this.populateBackgroundsSelect();
            bgSelect.addEventListener('change', (e)=>{
                const filename = e.target.value || '';
                if (filename) {
                    document.body.style.setProperty('--bg-image-url', `url("/images/gui/background/${filename}")`);
                    document.body.classList.add('has-bg');
                    localStorage.setItem('rpg_bg_filename', filename);
                } else {
                    localStorage.removeItem('rpg_bg_filename');
                    this.applyBackgroundFromServer();
                }
            });
        }

        // Style Tools: load and bind
        this.applySavedLayoutSettings();
        this.applySavedElementStyles();
        this.initStyleToolsBindings();

        // History for editor actions
        this._history = [];
        this._historyIndex = -1;
        // Internal editor state
        this._resizeHandlesEnabled = false; // true when Resize mode ON; overlay can exist also for Move mode only
        this._editorListenersAttached = false;

        if (document.getElementById('font-size-slider')) {
            const fontSizeSlider = document.getElementById('font-size-slider');
            const fontSizeValue = document.getElementById('font-size-value');

            // Set initial value
            fontSizeSlider.value = this.settings.fontSize;
            fontSizeValue.textContent = `${this.settings.fontSize}px`;

            // Update when slider changes
            fontSizeSlider.addEventListener('input', (e) => {
                const size = e.target.value;
                fontSizeValue.textContent = `${size}px`;
                this.applyFontSize(size);
            });
        }

        if (document.getElementById('save-settings-btn')) {
            document.getElementById('save-settings-btn').addEventListener('click', () => {
                this.saveSettings();
                this.closeAllModals();
                this.showNotification('Settings saved successfully', 'success');
            });
        }

        // Initialize reset settings button
        if (document.getElementById('reset-settings-btn')) {
            document.getElementById('reset-settings-btn').addEventListener('click', () => {
                this.resetAgentSettingsToDefault();
                this.showNotification('Agent settings reset to default values', 'info');
            });
        }

        // Initialize tabs in settings modal
        const tabButtons = document.querySelectorAll('.tab-btn');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.getAttribute('data-tab');
                this.switchTab(targetTab);
            });
        });

        // Initialize right panel tabs (separate namespace to avoid clashing with settings tabs)
        const rpTabButtons = document.querySelectorAll('.right-tabs .rp-tab-btn');
        rpTabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.getAttribute('data-tab');
                document.querySelectorAll('.right-tabs .rp-tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.right-tabs .rp-tab-pane').forEach(p => p.classList.remove('active'));
                button.classList.add('active');
                const pane = document.getElementById(targetTab);
                if (pane) {
                    pane.classList.add('active');
                    // Ensure proper scrolling for the newly active tab
                    this.ensureRightPanelScrollable();
                }
            });
        });

        // Initialize password visibility toggles
        const showHideButtons = document.querySelectorAll('.show-hide-btn');
        showHideButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetId = button.getAttribute('data-target');
                this.togglePasswordVisibility(targetId, button);
            });
        });

        // Initialize LLM toggle
        const llmToggle = document.getElementById('llm-enabled-toggle');
        if (llmToggle) {
            llmToggle.checked = this.settings.llmEnabled;
            llmToggle.addEventListener('change', (e) => {
                this.settings.llmEnabled = e.target.checked;
                localStorage.setItem('rpg_llm_enabled', e.target.checked);

                // Update UI based on LLM toggle state
                const llmProviderSettings = document.getElementById('llm-provider-settings');
                if (llmProviderSettings) {
                    llmProviderSettings.style.opacity = e.target.checked ? '1' : '0.5';
                    llmProviderSettings.style.pointerEvents = e.target.checked ? 'auto' : 'none';
                }
            });

            // Apply initial state
            const llmProviderSettings = document.getElementById('llm-provider-settings');
            if (llmProviderSettings) {
                llmProviderSettings.style.opacity = this.settings.llmEnabled ? '1' : '0.5';
                llmProviderSettings.style.pointerEvents = this.settings.llmEnabled ? 'auto' : 'none';
            }
        }

        // Command history navigation
        this.commandInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                if (this.historyIndex < this.commandHistory.length - 1) {
                    this.historyIndex++;
                    this.commandInput.value = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex];
                }
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.commandInput.value = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex];
                } else if (this.historyIndex === 0) {
                    this.historyIndex = -1;
                    this.commandInput.value = '';
                }
                e.preventDefault();
            }
        });

        // Window resize handler to adjust right panel scrolling
        window.addEventListener('resize', () => {
            // Debounce the resize handler
            clearTimeout(this._resizeTimeout);
            this._resizeTimeout = setTimeout(() => {
                this.ensureRightPanelScrollable();
                this.ensureCenterOutputScrollable();
            }, 150);
        });
    }

    /**
     * Enable the command input when a game is active
     */
    enableCommandInput() {
        this.commandInput.disabled = false;
        this.sendButton.disabled = false;
        this.saveGameButton.disabled = false;
    }

    /**
     * Disable the command input when no game is active
     */
    disableCommandInput() {
        this.commandInput.disabled = true;
        this.sendButton.disabled = true;
        this.saveGameButton.disabled = true;
    }

    /**
     * Update the game information display
     * @param {Object} gameInfo - Game information object
     */
    updateGameInfo(gameInfo) {
        if (gameInfo.player) {
            if (gameInfo.player.name) {
                this.playerNameElement.textContent = gameInfo.player.name;
            }
            if (gameInfo.player.level) {
                this.playerLevelElement.textContent = gameInfo.player.level;
            }
        }

        if (gameInfo.location) {
            this.locationElement.textContent = gameInfo.location;
        }

        if (gameInfo.time) {
            this.gameTimeElement.textContent = gameInfo.time;
        }
    }

    /**
     * Add a message to the game output area
     * @param {string} text - The message text
     * @param {string} type - The type of message (system, player, game)
     * @param {boolean} gradual - Whether to display text gradually (like Python GUI)
     */
addMessage(text, type = 'game', gradual = false) {
        // Guard: ignore empty
        if (text == null) return;
        const txt = String(text);
        const key = `${type}|${txt}`;
        const now = Date.now();
        // Drop identical messages received within 1500ms window
        // Keep only recent window entries (5s)
        try {
            this._recentMsgKeys = (this._recentMsgKeys || []).filter(e => now - e.ts < 5000);
            const seen = this._recentMsgKeys.find(e => e.key === key && (now - e.ts) < 1500);
            if (seen) return; // skip duplicate burst
            this._recentMsgKeys.push({ key, ts: now });
            if (this._recentMsgKeys.length > 50) this._recentMsgKeys.shift();
        } catch {}

        const messageElement = document.createElement('div');
        messageElement.className = `message ${type}`;
        
        if (gradual) {
            // Queue gradual display to mimic orchestrator's sequential UI flow
            this._enqueueGradualMessage({ text: txt, type, element: null });
        } else {
            // Instant display
            messageElement.textContent = txt;
            this.outputElement.appendChild(messageElement);
            this.ensureCenterOutputScrollable();
            this.scrollToBottom();
        }
    }

    /** Queue a gradual message for sequential display */
    _enqueueGradualMessage(item) {
        this._messageQueue.push(item);
        // Kick the processor if idle
        if (!this._isTyping) this._processNextMessage();
    }

    /** Process the next queued gradual message, if any */
    _processNextMessage() {
        if (this._isTyping) return;
        const next = this._messageQueue.shift();
        if (!next) return;
        this._isTyping = true;
        const { text, type } = next;
        const messageElement = document.createElement('div');
        messageElement.className = `message ${type}`;
        messageElement.textContent = '';
        this.outputElement.appendChild(messageElement);
        this.ensureCenterOutputScrollable();
        this.scrollToBottom();
        // Display text gradually, then continue with the queue
        this._displayTextGradually(messageElement, text, () => {
            this._isTyping = false;
            // Small micro-delay to let layout settle
            setTimeout(() => this._processNextMessage(), 0);
        });
    }
    
    /**
     * Display text gradually in an element (like Python GUI gradual display)
     * @param {HTMLElement} element - The element to display text in
     * @param {string} fullText - The complete text to display
     * @param {function} [onComplete] - Callback when finished
     */
    _displayTextGradually(element, fullText, onComplete) {
        // Cancel any ongoing gradual display for this element
        if (element._gradualDisplayTimer) {
            clearInterval(element._gradualDisplayTimer);
            element._gradualDisplayTimer = null;
        }
        
        let currentIndex = 0;
        const charsPerFrame = 1; // Display 1 character at a time (matches Python GUI)
        const intervalMs = 5; // 5ms between characters (matches Python GUI default setting)
        
        element._gradualDisplayTimer = setInterval(() => {
            if (currentIndex >= fullText.length) {
                clearInterval(element._gradualDisplayTimer);
                element._gradualDisplayTimer = null;
                try { if (typeof onComplete === 'function') onComplete(); } catch {}
                return;
            }
            
            // Add next character
            const nextIndex = Math.min(currentIndex + charsPerFrame, fullText.length);
            element.textContent = fullText.substring(0, nextIndex);
            currentIndex = nextIndex;
            
            // Auto-scroll to keep new text visible
            this.scrollToBottom();
        }, intervalMs);
    }

    /**
     * Add a command to the history
     * @param {string} command - The command to add
     */
    addCommandToHistory(command) {
        this.commandHistory.push(command);
        // Limit history to 50 entries
        if (this.commandHistory.length > 50) {
            this.commandHistory.shift();
        }
        this.historyIndex = -1;
    }

    /**
     * Clear the command input
     */
    clearCommandInput() {
        this.commandInput.value = '';
    }

    /**
     * Clear the game output area
     */
    clearOutput() {
        this.outputElement.innerHTML = '';
    }

    /**
     * Scroll the output area to the bottom
     */
    scrollToBottom() {
        // Use requestAnimationFrame for smooth scrolling
        requestAnimationFrame(() => {
            this.outputElement.scrollTop = this.outputElement.scrollHeight;
        });
    }

    /**
     * Scroll a specific element to the bottom (for right panel tabs)
     * @param {HTMLElement} element - The element to scroll
     */
    scrollElementToBottom(element) {
        if (!element) return;
        requestAnimationFrame(() => {
            element.scrollTop = element.scrollHeight;
        });
    }

    /**
     * Ensure an element is visible by scrolling its container if needed
     * @param {HTMLElement} element - The element to make visible
     * @param {HTMLElement} container - The scrollable container (optional)
     */
    scrollIntoView(element, container = null) {
        if (!element) return;
        
        if (container) {
            // Scroll within a specific container
            const elementTop = element.offsetTop;
            const elementBottom = elementTop + element.offsetHeight;
            const containerTop = container.scrollTop;
            const containerBottom = containerTop + container.clientHeight;
            
            if (elementBottom > containerBottom) {
                // Element is below the visible area
                container.scrollTop = elementBottom - container.clientHeight;
            } else if (elementTop < containerTop) {
                // Element is above the visible area
                container.scrollTop = elementTop;
            }
        } else {
            // Use browser's built-in scrollIntoView
            element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    /**
     * Ensure the right panel content is properly scrollable and handle overflow
     */
    ensureRightPanelScrollable() {
        const rightPanel = document.querySelector('.right-panel');
        if (!rightPanel) return;

        // Get the currently active tab pane
        const activePane = rightPanel.querySelector('.rp-tab-pane.active');
        if (!activePane) return;

        // Check if content overflows and adjust scrolling
        requestAnimationFrame(() => {
            const rightPanelHeight = rightPanel.clientHeight;
            const tabButtonsHeight = rightPanel.querySelector('.tab-buttons')?.offsetHeight || 0;
            const availableHeight = rightPanelHeight - tabButtonsHeight - 20; // 20px for padding
            
            // Set max height for the active pane if not already set by CSS variable
            const maxHeight = getComputedStyle(document.documentElement)
                .getPropertyValue('--rp-pane-max');
            
            if (maxHeight === 'none' || !maxHeight) {
                // Only set max height if not controlled by CSS variable
                activePane.style.maxHeight = `${availableHeight}px`;
            }

            // If content is overflowing, ensure scrolling is enabled
            if (activePane.scrollHeight > activePane.clientHeight) {
                activePane.style.overflowY = 'auto';
                // Optional: scroll to a specific element if needed
                // For now, we'll keep the current scroll position
            }
        });
    }

    /** Ensure main output area remains a fixed-height, scrollable viewport */
    ensureCenterOutputScrollable() {
        try {
            const center = document.querySelector('.center-stack');
            const out = this.outputElement;
            if (!center || !out) return;
            // Compute available height for the output area within center stack
            requestAnimationFrame(() => {
                const inp = center.querySelector('.command-input-container');
                const centerH = center.clientHeight || 0;
                const inpH = inp ? inp.offsetHeight : 0;
                const pad = 10;
                const available = Math.max(0, centerH - inpH - pad);
                if (available > 0) {
                    out.style.maxHeight = `${available}px`;
                }
                out.style.overflowY = 'auto';
            });
        } catch (e) { /* ignore */ }
    }

    /**
     * Show a notification
     * @param {string} message - The notification message
     * @param {string} type - The type of notification (success, info, warning, error)
     * @param {number} duration - Duration in milliseconds
     */
    showNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;

        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;

        const closeBtn = document.createElement('span');
        closeBtn.className = 'notification-close';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => {
            this.notificationContainer.removeChild(notification);
        });

        notification.appendChild(messageSpan);
        notification.appendChild(closeBtn);

        this.notificationContainer.appendChild(notification);

        // Auto-remove after duration
        if (duration > 0) {
            setTimeout(() => {
                if (notification.parentNode === this.notificationContainer) {
                    this.notificationContainer.removeChild(notification);
                }
            }, duration);
        }
    }

    applySavedLayoutSettings() {
        // Re-anchor layout before applying saved values
        this.enforceMainLayoutAnchors();
        this.enforceCenterStackOrder();
        try {
            const left = localStorage.getItem('rpg_layout_left');
            const right = localStorage.getItem('rpg_layout_right');
            const gap = localStorage.getItem('rpg_layout_gap');
            const rpMax = localStorage.getItem('rpg_rp_max');
            const grid = localStorage.getItem('rpg_grid_enabled') === 'true';
            const gsize = localStorage.getItem('rpg_grid_size');
            const inspector = localStorage.getItem('rpg_dev_inspector_enabled') === 'true';
            const centerH = localStorage.getItem('rpg_center_output_h');
            if (left) document.documentElement.style.setProperty('--left-menu-width', `${parseInt(left,10)}px`);
            if (right) document.documentElement.style.setProperty('--right-panel-width', `${parseInt(right,10)}px`);
            if (gap) document.documentElement.style.setProperty('--content-gap', `${parseInt(gap,10)}px`);
            if (rpMax && parseInt(rpMax,10) > 0) document.documentElement.style.setProperty('--rp-pane-max', `${parseInt(rpMax,10)}px`);
            if (rpMax && parseInt(rpMax,10) === 0) document.documentElement.style.setProperty('--rp-pane-max', `none`);
            if (gsize) document.documentElement.style.setProperty('--grid-size', `${parseInt(gsize,10)}px`);
            if (centerH && parseInt(centerH,10) > 0) {
                document.documentElement.style.setProperty('--center-output-track', `${parseInt(centerH,10)}px`);
            } else {
                document.documentElement.style.setProperty('--center-output-track', `1fr`);
            }
            // Sync inputs if present
            const setVal = (id, val)=>{ const el=document.getElementById(id); if (el && val!=null) el.value = String(val).replace('px',''); };
            setVal('layout-left-width', left||180);
            setVal('layout-right-width', right||420);
            setVal('layout-gap', gap||10);
            setVal('layout-rp-max', rpMax||0);
            setVal('layout-grid-size', gsize||16);
            const gridToggle = document.getElementById('layout-grid-toggle'); if (gridToggle) gridToggle.checked = grid;
            const inspToggle = document.getElementById('layout-debug-toggle'); if (inspToggle) inspToggle.checked = inspector;
            this.toggleGridOverlay(grid);
            this.enableLayoutInspector(inspector);
        } catch (e) { console.warn('applySavedLayoutSettings failed', e); }
    }

    initStyleToolsBindings() {
        const bindNum = (id, cb) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.addEventListener('input', ()=> {
                const v = parseInt(el.value, 10);
                cb(isNaN(v)?0:v);
            });
        };
        bindNum('layout-left-width', (v)=>{ document.documentElement.style.setProperty('--left-menu-width', `${v}px`); localStorage.setItem('rpg_layout_left', v); });
        bindNum('layout-right-width', (v)=>{ document.documentElement.style.setProperty('--right-panel-width', `${v}px`); localStorage.setItem('rpg_layout_right', v); });
        bindNum('layout-gap', (v)=>{ document.documentElement.style.setProperty('--content-gap', `${v}px`); localStorage.setItem('rpg_layout_gap', v); });
        bindNum('layout-grid-size', (v)=>{ document.documentElement.style.setProperty('--grid-size', `${v}px`); localStorage.setItem('rpg_grid_size', v); });
        bindNum('layout-rp-max', (v)=>{ if (v>0) { document.documentElement.style.setProperty('--rp-pane-max', `${v}px`); } else { document.documentElement.style.setProperty('--rp-pane-max', `none`); } localStorage.setItem('rpg_rp_max', v); });
        const gridToggle = document.getElementById('layout-grid-toggle');
        if (gridToggle) gridToggle.addEventListener('change', ()=>{ const on=gridToggle.checked; localStorage.setItem('rpg_grid_enabled', on); this.toggleGridOverlay(on); });
        const inspToggle = document.getElementById('layout-debug-toggle');
        if (inspToggle) inspToggle.addEventListener('change', ()=>{ const on=inspToggle.checked; localStorage.setItem('rpg_dev_inspector_enabled', on); this.enableLayoutInspector(on); });
        const editorToggle = document.getElementById('layout-editor-toggle');
        if (editorToggle) editorToggle.addEventListener('change', ()=>{ 
            const on = editorToggle.checked;
            // enforce exclusivity: if turning resize ON, turn move OFF
            const moveToggleEl = document.getElementById('layout-move-toggle');
            if (on) {
                if (moveToggleEl) moveToggleEl.checked = false;
                this._moveMode = false;
                localStorage.setItem('rpg_dev_move_enabled', false);
            }
            localStorage.setItem('rpg_dev_editor_enabled', on);
            this._resizeHandlesEnabled = on;
            this.enableElementResizeMode(on); // will keep overlay active if move mode is on
        });
        const moveToggle = document.getElementById('layout-move-toggle');
        if (moveToggle) moveToggle.addEventListener('change', ()=>{ 
            const on = moveToggle.checked; 
            // enforce exclusivity: if turning move ON, turn resize OFF (handles hidden)
            const editorToggleEl = document.getElementById('layout-editor-toggle');
            if (on) {
                if (editorToggleEl) editorToggleEl.checked = false;
                localStorage.setItem('rpg_dev_editor_enabled', false);
                this._resizeHandlesEnabled = false;
            }
            localStorage.setItem('rpg_dev_move_enabled', on); 
            this._moveMode = on; 
            // ensure overlay exists or is removed based on combined state
            this.enableElementResizeMode(this._resizeHandlesEnabled);
            try { this._updateOverlayRef && this._updateOverlayRef(); } catch(e) {} 
        });
        const resetAllBtn = document.getElementById('layout-reset-all');
        if (resetAllBtn) resetAllBtn.addEventListener('click', (e)=>{ e.preventDefault(); this.resetLayoutToDefaults(true); });
        const restoreBtn = document.getElementById('layout-restore-saved');
        if (restoreBtn) restoreBtn.addEventListener('click', (e)=>{ e.preventDefault(); this.restoreFromSavedLayoutSnapshot(); });
        const hardResetBtn = document.getElementById('layout-hard-reset');
        if (hardResetBtn) hardResetBtn.addEventListener('click', (e)=> { e.preventDefault(); this.hardResetLayoutStorage(); location.reload(); });
        // If saved
        let savedEditor = localStorage.getItem('rpg_dev_editor_enabled') === 'true';
        let savedMove = localStorage.getItem('rpg_dev_move_enabled') === 'true';
        // Enforce exclusivity at startup: prefer Resize if both were true
        if (savedEditor && savedMove) { savedMove = false; localStorage.setItem('rpg_dev_move_enabled', false); }
        if (editorToggle) editorToggle.checked = savedEditor;
        if (moveToggle) moveToggle.checked = savedMove;
        this._moveMode = savedMove;
        this._resizeHandlesEnabled = savedEditor;
        this.enableElementResizeMode(savedEditor);
    }

    toggleGridOverlay(show) {
        try {
            let el = document.getElementById('layout-grid-overlay');
            if (show) {
                if (!el) { el = document.createElement('div'); el.id='layout-grid-overlay'; document.body.appendChild(el); }
            } else {
                if (el && el.parentNode) el.parentNode.removeChild(el);
            }
        } catch (e) { /* ignore */ }
    }

    enableLayoutInspector(enable) {
        if (enable) {
            if (!this._inspHover) this._inspHover = document.createElement('div');
            if (!this._inspPanel) this._inspPanel = document.createElement('div');
            this._inspHover.id = 'layout-hover-overlay';
            this._inspPanel.id = 'layout-inspector';
            if (!document.getElementById('layout-hover-overlay')) document.body.appendChild(this._inspHover);
            if (!document.getElementById('layout-inspector')) document.body.appendChild(this._inspPanel);
            // Track editing mode and last target to avoid re-rendering while typing
            if (!this._inspEditingBound) {
                this._inspPanel.addEventListener('focusin', ()=>{ this._inspEditing = true; });
                this._inspPanel.addEventListener('focusout', ()=>{ setTimeout(()=>{ this._inspEditing = false; }, 50); });
                this._inspEditingBound = true;
            }
            const readVars = ()=>{
                const left = getComputedStyle(document.documentElement).getPropertyValue('--left-menu-width').trim();
                const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width').trim();
                const gap = getComputedStyle(document.documentElement).getPropertyValue('--content-gap').trim();
                const rpmax = getComputedStyle(document.documentElement).getPropertyValue('--rp-pane-max').trim();
                const grid = getComputedStyle(document.documentElement).getPropertyValue('--grid-size').trim();
                const toNum = (v)=> v && v !== 'none' ? parseInt(v,10) : 0;
                return { left: toNum(left), right: toNum(right), gap: toNum(gap), rpmax: toNum(rpmax), grid: toNum(grid) };
            };
            const writeHandlers = ()=>{
                const L = this._inspPanel.querySelector('#insp-left');
                const R = this._inspPanel.querySelector('#insp-right');
                const G = this._inspPanel.querySelector('#insp-gap');
                const M = this._inspPanel.querySelector('#insp-rpmax');
                const S = this._inspPanel.querySelector('#insp-grid');
                const bind = (el, cb)=>{ if (!el) return; el.addEventListener('input', ()=>{ const v=parseInt(el.value,10)||0; cb(v); }); };
                bind(L, v=>{ document.documentElement.style.setProperty('--left-menu-width', `${v}px`); localStorage.setItem('rpg_layout_left', v); });
                bind(R, v=>{ document.documentElement.style.setProperty('--right-panel-width', `${v}px`); localStorage.setItem('rpg_layout_right', v); });
                bind(G, v=>{ document.documentElement.style.setProperty('--content-gap', `${v}px`); localStorage.setItem('rpg_layout_gap', v); });
                bind(M, v=>{ if (v>0) { document.documentElement.style.setProperty('--rp-pane-max', `${v}px`); } else { document.documentElement.style.setProperty('--rp-pane-max', `none`); } localStorage.setItem('rpg_rp_max', v); });
                bind(S, v=>{ document.documentElement.style.setProperty('--grid-size', `${v}px`); localStorage.setItem('rpg_grid_size', v); });
            };
            const renderInspector = (target)=>{
                const r = target.getBoundingClientRect();
                Object.assign(this._inspHover.style, { left:`${r.left}px`, top:`${r.top}px`, width:`${r.width}px`, height:`${r.height}px` });
                const cs = getComputedStyle(target);
                const id = target.id?`#${target.id}`:'';
                const cls = target.className?'.'+String(target.className).trim().split(/\s+/).join('.') : '';
                const tag = target.tagName.toLowerCase();
                const vars = readVars();
                this._inspPanel.style.left = `${Math.min(window.innerWidth-380, r.left+8)}px`;
                this._inspPanel.style.top = `${Math.min(window.innerHeight-160, r.top+8)}px`;
                this._inspPanel.innerHTML = `
                    <div style="font-weight:bold; margin-bottom:4px;">${tag}${id}${cls}</div>
                    <div>size: ${Math.round(r.width)}x${Math.round(r.height)} | overflowY: ${cs.overflowY} | maxH: ${cs.maxHeight}</div>
                    <div class="insp-row"><label for="insp-left">Left:</label><input type="number" id="insp-left" min="120" max="640" step="5" value="${vars.left}"><span>px</span></div>
                    <div class="insp-row"><label for="insp-right">Right:</label><input type="number" id="insp-right" min="320" max="800" step="5" value="${vars.right}"><span>px</span></div>
                    <div class="insp-row"><label for="insp-gap">Gap:</label><input type="number" id="insp-gap" min="0" max="24" step="1" value="${vars.gap}"><span>px</span></div>
                    <div class="insp-row"><label for="insp-rpmax">RP Max:</label><input type="number" id="insp-rpmax" min="0" max="1200" step="10" value="${vars.rpmax}"><span>px</span></div>
                    <div class="insp-row"><label for="insp-grid">Grid:</label><input type="number" id="insp-grid" min="4" max="64" step="2" value="${vars.grid}"><span>px</span></div>
                `;
                writeHandlers();
            };
            if (!this._inspHandler) {
                this._inspHandler = (e)=>{
                    try {
                        const target = e.target;
                        if (!target || target.id==='layout-hover-overlay' || target.id==='layout-inspector') return;
                        const r = target.getBoundingClientRect();
                        // Always update hover box position
                        Object.assign(this._inspHover.style, { left:`${r.left}px`, top:`${r.top}px`, width:`${r.width}px`, height:`${r.height}px` });
                        // Only re-render content when target changes and not editing/locked
                        if (this._inspEditing) return;
                        if (this._editorSelected) return; // locked via right-click
                        if (this._inspLastTarget !== target) {
                            this._inspLastTarget = target;
                            renderInspector(target);
                        } else {
                            // Still keep panel following cursor
                            this._inspPanel.style.left = `${Math.min(window.innerWidth-380, r.left+8)}px`;
                            this._inspPanel.style.top = `${Math.min(window.innerHeight-160, r.top+8)}px`;
                        }
                    } catch (err) { /* ignore */ }
                };
            }
            document.addEventListener('mousemove', this._inspHandler);
            // Right-click to lock inspector editing on element (independent of resize/move modes)
            if (!this._inspContextHandler) {
                this._inspContextHandler = (ev)=>{
                    try {
                        const t = ev.target;
                        if (!t || t.closest('#layout-inspector')) return;
                        // If right-clicked on overlay frame, ignore
                        if (t.closest && t.closest('#layout-resize-overlay')) return;
                        if (!this.isEditableTarget(t)) return;
                        ev.preventDefault();
                        this._editorSelected = t;
                        this._selectionSet = [t];
                        this._inspLastTarget = t;
                        renderInspector(t);
                        this.renderInspectorForSelected();
                    } catch {}
                };
            }
            document.addEventListener('contextmenu', this._inspContextHandler);
            if (!this._inspUnlockHandler) {
                this._inspUnlockHandler = (ev)=>{
                    const inside = ev.target && (ev.target.closest('#layout-inspector'));
                    if (!inside) { this._editorSelected = null; /* unlock editing */ }
                };
            }
            document.addEventListener('click', this._inspUnlockHandler);
        } else {
            if (this._inspHandler) document.removeEventListener('mousemove', this._inspHandler);
            if (this._inspContextHandler) document.removeEventListener('contextmenu', this._inspContextHandler);
            if (this._inspUnlockHandler) document.removeEventListener('click', this._inspUnlockHandler);
            const h = document.getElementById('layout-hover-overlay'); if (h) h.remove();
            const p = document.getElementById('layout-inspector'); if (p) p.remove();
            this._inspLastTarget = null; this._inspEditing = false; this._editorSelected = null;
        }
    }

    applySavedElementStyles() {
        try {
            // Prefer the toolbar snapshot if present, otherwise fall back to the direct map
            let incoming = null;
            try {
                const snapRaw = localStorage.getItem('rpg_layout_saved');
                if (snapRaw) {
                    const snap = JSON.parse(snapRaw);
                    if (snap && snap.element_styles && typeof snap.element_styles === 'object') {
                        incoming = snap.element_styles;
                    }
                }
            } catch {}
            if (!incoming) {
                const raw = localStorage.getItem('rpg_element_styles');
                if (!raw) return;
                incoming = JSON.parse(raw);
            }
            const sanitized = {};
            Object.entries(incoming || {}).forEach(([selector, styles])=>{
                try {
                    document.querySelectorAll(selector).forEach(el=>{
                        const filtered = this.filterStylesForElement(el, styles);
                        if (Object.keys(filtered).length) {
                            Object.assign(el.style, filtered);
                            const sel = this.getUniqueSelectorFor(el);
                            if (sel) sanitized[sel] = { ...(sanitized[sel]||{}), ...filtered };
                        }
                    });
                } catch (e) { /* ignore */ }
            });
            // Keep both stores in sync with the sanitized, actually-applied map
            try { localStorage.setItem('rpg_element_styles', JSON.stringify(sanitized)); } catch {}
            try {
                const saved = JSON.parse(localStorage.getItem('rpg_layout_saved') || '{}');
                if (saved && typeof saved === 'object') {
                    saved.element_styles = sanitized;
                    localStorage.setItem('rpg_layout_saved', JSON.stringify(saved));
                }
            } catch {}
            // After applying, enforce anchors again in case any stray positions slipped in
            this.enforceMainLayoutAnchors();
            this.enforceCenterStackOrder();
        } catch (e) { console.warn('applySavedElementStyles failed', e);}        
    }

    // Disallow editing of outer/root containers
    isEditableTarget(el) {
        if (!el) return false;
        const tag = (el.tagName||'').toUpperCase();
        if (tag === 'HTML' || tag === 'BODY') return false;
        // Block app root frames
        if (el.classList && (el.classList.contains('app-container') || el.classList.contains('game-frame'))) return false;
        const gameFrame = document.querySelector('.game-frame');
        if (el === gameFrame) return false;
        return true;
    }

    // Build a stable CSS selector that is reproducible across reloads
    getStableSelector(el) {
        if (!el) return null;
        if (el.id) return `#${el.id}`;
        const parts = [];
        let node = el;
        while (node && node !== document.body && node !== document.documentElement) {
            if (node.id) { parts.unshift(`#${node.id}`); break; }
            const parent = node.parentElement;
            if (!parent) break;
            const tag = node.tagName.toLowerCase();
            // nth-of-type to avoid class name dependence
            const siblingsOfType = Array.from(parent.children).filter(ch => ch.tagName === node.tagName);
            const index = siblingsOfType.indexOf(node) + 1;
            parts.unshift(`${tag}:nth-of-type(${index})`);
            if (parent.classList && (parent.classList.contains('game-frame') || parent.classList.contains('app-container'))) {
                parts.unshift(parent.classList.contains('game-frame') ? '.game-frame' : '.app-container');
                break;
            }
            node = parent;
        }
        return parts.join(' > ');
    }

    getUniqueSelectorFor(el) {
        if (!el) return null;
        if (!this.isEditableTarget(el)) return null;
        return this.getStableSelector(el);
    }

    persistElementStyle(el) {
        try {
            if (!this.isEditableTarget(el)) return;
            const selector = this.getUniqueSelectorFor(el);
            if (!selector) return;
            const raw = localStorage.getItem('rpg_element_styles');
            const map = raw ? JSON.parse(raw) : {};
            map[selector] = map[selector] || {};
            const styles = {};
            const allowProp = (k)=>{
                // Never persist positioning for protected sections or their descendants
                const inMainSection = !!(el.closest('.left-menu, .center-stack, .right-panel, .banner-bar, .status-bar'));
                if (inMainSection && (k==='position' || k==='left' || k==='top' || k==='zIndex' || k==='transform')) return false;
                return true;
            };
            ['width','height','maxHeight','overflowY','position','left','top','zIndex','transform'].forEach(k=>{ if (el.style[k] && allowProp(k)) styles[k] = el.style[k]; });
            map[selector] = { ...map[selector], ...styles };
            localStorage.setItem('rpg_element_styles', JSON.stringify(map));
        } catch (e) { console.warn('persistElementStyle failed', e); }
    }

    // Layout protection helpers
    isProtectedLayoutElement(el) {
        if (!el) return false;
        // Main grid sections
        if (el.classList && (el.classList.contains('left-menu') || el.classList.contains('center-stack') || el.classList.contains('right-panel') || el.classList.contains('banner-bar') || el.classList.contains('status-bar'))) {
            return true;
        }
        // Critical widgets that must retain order and position
        if (el.id === 'game-output' || el.classList?.contains('game-output')) return true;
        if (el.id === 'command-input' || el.classList?.contains('command-input-container')) return true;
        return false;
    }

    filterStylesForElement(el, styles) {
        try {
            const filtered = { ...styles };
            // For main sections and anything inside them, strip absolute positioning/transform
            if (el.closest('.left-menu, .center-stack, .right-panel, .banner-bar, .status-bar')) {
                delete filtered.position;
                delete filtered.left;
                delete filtered.top;
                delete filtered.zIndex;
                delete filtered.transform;
            }
            return filtered;
        } catch { return styles; }
    }

    enforceCenterStackOrder() {
        try {
            const cs = document.querySelector('.center-stack');
            if (!cs) return;
            const out = cs.querySelector('.game-output');
            const inp = cs.querySelector('.command-input-container');
            if (out && inp) {
                if (out.nextElementSibling !== inp) {
                    cs.insertBefore(inp, null); // move to end
                    cs.insertBefore(out, inp); // ensure out before inp
                }
                // Clear any rogue transforms/positions
                [out, inp].forEach(el=>{ try { el.style.position=''; el.style.left=''; el.style.top=''; el.style.transform=''; el.style.zIndex=''; } catch {} });
            }
        } catch {}
    }

    enforceMainLayoutAnchors() {
        try {
            const anchors = [
                document.querySelector('.left-menu'),
                document.querySelector('.center-stack'),
                document.querySelector('.right-panel'),
                document.querySelector('.banner-bar'),
                document.querySelector('.status-bar')
            ].filter(Boolean);
            anchors.forEach(el=>{ try { el.style.position=''; el.style.left=''; el.style.top=''; el.style.transform=''; el.style.zIndex=''; el.style.gridColumn=''; el.style.gridColumnStart=''; el.style.gridColumnEnd=''; } catch {} });
        } catch {}
    }

    hardResetLayoutStorage() {
        try {
            const keys = [
                'rpg_element_styles','rpg_layout_saved','rpg_layout_left','rpg_layout_right','rpg_layout_gap','rpg_rp_max','rpg_grid_size',
                'rpg_dev_inspector_enabled','rpg_dev_editor_enabled','rpg_dev_move_enabled','rpg_grid_enabled'
            ];
            keys.forEach(k=> localStorage.removeItem(k));
            // Reset CSS variables to defaults
            document.documentElement.style.setProperty('--left-menu-width', '180px');
            document.documentElement.style.setProperty('--right-panel-width', '420px');
            document.documentElement.style.setProperty('--content-gap', '10px');
            document.documentElement.style.setProperty('--rp-pane-max', 'none');
            document.documentElement.style.setProperty('--grid-size', '16px');
            // Re-anchor
            this.enforceMainLayoutAnchors();
            this.enforceCenterStackOrder();
        } catch (e) { console.warn('hardResetLayoutStorage failed', e); }
    }

    autoHealLayoutIfCorrupted() {
        try {
            // Only perform once per browser until the next explicit reset
            if (localStorage.getItem('rpg_layout_auto_healed') === 'true') return;
            const left = document.querySelector('.left-menu');
            const center = document.querySelector('.center-stack');
            const right = document.querySelector('.right-panel');
            const out = document.querySelector('.center-stack .game-output');
            const inp = document.querySelector('.center-stack .command-input-container');
            if (!left || !center || !right) return;
            const lr = left.getBoundingClientRect();
            const cr = center.getBoundingClientRect();
            const rr = right.getBoundingClientRect();
            const problems = [];
            // Right panel should be to the right of center
            if (rr.left < cr.left) problems.push('rightPanelLeftOfCenter');
            // Right panel should not massively overlap center (allow small margin)
            if (rr.left < cr.right - 40 && rr.right > cr.left + 40) problems.push('rightPanelOverlapsCenter');
            // Input should be below output
            if (out && inp) {
                const orc = out.getBoundingClientRect();
                const irc = inp.getBoundingClientRect();
                if (irc.top < orc.bottom - 5) problems.push('inputAboveOutput');
            }
            if (problems.length) {
                console.warn('Layout corruption detected:', problems);
                this.hardResetLayoutStorage();
                localStorage.setItem('rpg_layout_auto_healed', 'true');
                // Notify once
                try { this.showNotification('Layout auto-healed to defaults due to corrupted saved layout', 'warning', 5000); } catch {}
            }
        } catch (e) { /* ignore */ }
    }

    // Helper: get current translate offsets from CSS transform
    getCurrentTranslate(el) {
        try {
            const t = getComputedStyle(el).transform || '';
            if (!t || t === 'none') return { tx: 0, ty: 0 };
            if (t.startsWith('matrix3d(')) {
                const vals = t.slice(9, -1).split(',').map(parseFloat);
                return { tx: vals[12] || 0, ty: vals[13] || 0 };
            }
            if (t.startsWith('matrix(')) {
                const vals = t.slice(7, -1).split(',').map(parseFloat);
                return { tx: vals[4] || 0, ty: vals[5] || 0 };
            }
        } catch {}
        return { tx: 0, ty: 0 };
    }

    enableElementResizeMode(enable) {
        // enable controls whether resize handles are enabled; overlay remains active if either resize OR move is enabled
        this._resizeHandlesEnabled = !!enable;
        const wantsActive = this._resizeHandlesEnabled || !!this._moveMode;
        if (wantsActive) {
            if (!this._resizeOverlay) {
                const ov = document.createElement('div');
                ov.id = 'layout-resize-overlay';
                // Drag surface (for move mode)
                const ds = document.createElement('div'); ds.className='drag-surface'; ov.appendChild(ds);
                ['n','s','e','w','ne','nw','se','sw'].forEach(n=>{ const h=document.createElement('div'); h.className=`handle ${n}`; ov.appendChild(h); });
                // Toolbar
                const tb = document.createElement('div');
                tb.className = 'toolbar';
                const unlockBtn = document.createElement('button'); unlockBtn.id = 'resize-unlock-btn'; unlockBtn.textContent='Unlock'; tb.appendChild(unlockBtn);
                const resetWH = document.createElement('button'); resetWH.id = 'resize-resetwh-btn'; resetWH.textContent='Reset WH'; tb.appendChild(resetWH);
                const resetPos = document.createElement('button'); resetPos.id = 'resize-resetpos-btn'; resetPos.textContent='Reset Pos'; tb.appendChild(resetPos);
                const clearSel = document.createElement('button'); clearSel.id = 'resize-clearsel-btn'; clearSel.textContent='Clear Sel'; tb.appendChild(clearSel);
                const undoBtn = document.createElement('button'); undoBtn.id = 'resize-undo-btn'; undoBtn.textContent='Undo'; tb.appendChild(undoBtn);
                const redoBtn = document.createElement('button'); redoBtn.id = 'resize-redo-btn'; redoBtn.textContent='Redo'; tb.appendChild(redoBtn);
                const saveBtn = document.createElement('button'); saveBtn.id = 'resize-save-layout-btn'; saveBtn.textContent='Save Layout'; saveBtn.classList.add('save'); tb.appendChild(saveBtn);
                const restoreBtn = document.createElement('button'); restoreBtn.id = 'resize-restore-layout-btn'; restoreBtn.textContent='Restore'; tb.appendChild(restoreBtn);
                const resetAllBtn = document.createElement('button'); resetAllBtn.id = 'resize-resetall-btn'; resetAllBtn.textContent='Reset All'; resetAllBtn.classList.add('danger'); tb.appendChild(resetAllBtn);
                ov.appendChild(tb);
                document.body.appendChild(ov);
                this._resizeOverlay = ov;
            }
            const getBounds = (els)=>{
                if (!els || !els.length) return null;
                let l=Infinity,t=Infinity,r=-Infinity,b=-Infinity;
                els.forEach(el=>{ const rc=el.getBoundingClientRect(); l=Math.min(l, rc.left); t=Math.min(t, rc.top); r=Math.max(r, rc.right); b=Math.max(b, rc.bottom); });
                return { left:l, top:t, width: r-l, height: b-t };
            };
            const updateOverlay = (elOrEls)=>{
                const els = Array.isArray(elOrEls)? elOrEls : (this._selectionSet && this._selectionSet.length? this._selectionSet : [elOrEls]);
                // Filter out non-editable elements
                const filtered = (els||[]).filter(el=> this.isEditableTarget(el));
                if (!filtered.length) return;
                const rb = getBounds(filtered);
                if (!rb) return;
                Object.assign(this._resizeOverlay.style, { left:`${rb.left}px`, top:`${rb.top}px`, width:`${rb.width}px`, height:`${rb.height}px`, display:'block' });
                
                // Classification of selection for smart handles
                const selectedEl = filtered.length === 1 ? filtered[0] : null;
                const isSidePanel = !!(selectedEl && selectedEl.classList && (selectedEl.classList.contains('left-menu') || selectedEl.classList.contains('right-panel')));
                const isOutput = !!(selectedEl && selectedEl.classList && selectedEl.classList.contains('game-output'));
                const isCore = !!(selectedEl && selectedEl.classList && (selectedEl.classList.contains('left-menu') || selectedEl.classList.contains('right-panel') || selectedEl.classList.contains('center-stack') || selectedEl.classList.contains('banner-bar') || selectedEl.classList.contains('status-bar')));

                // Show controls only when a selection is locked
                const showControls = !!(this._selectionSet && this._selectionSet.length);
                const tb = this._resizeOverlay.querySelector('.toolbar'); if (tb) {
                    tb.style.display = showControls ? 'flex' : 'none';
                    if (showControls) {
                        // Keep toolbar always on-screen using fixed positioning
                        try {
                            tb.style.position = 'fixed';
                            const tbw = tb.offsetWidth || 120;
                            const tbh = tb.offsetHeight || 28;
                            const pad = 8;
                            let left = Math.max(pad, Math.min(window.innerWidth - tbw - pad, rb.left));
                            // Prefer above the box, otherwise place below
                            let top = rb.top - tbh - 6;
                            if (top < pad) top = Math.min(window.innerHeight - tbh - pad, rb.top + rb.height + 6);
                            tb.style.left = `${Math.round(left)}px`;
                            tb.style.top = `${Math.round(top)}px`;
                            tb.style.right = 'auto';
                            tb.style.bottom = 'auto';
                        } catch {}
                    }
                }
                const showHandles = showControls && !!this._resizeHandlesEnabled;
                this._resizeOverlay.querySelectorAll('.handle').forEach(h=> {
                    const dir = [...h.classList].find(c=> c!=='handle') || '';
                    let shouldShow = showHandles;
                    // For side panels, only allow horizontal resizing
                    if (isSidePanel && !['e','w'].includes(dir)) shouldShow = false;
                    // For game output, only allow vertical resizing
                    if (isOutput && !['n','s'].includes(dir)) shouldShow = false;
                    h.style.display = shouldShow ? 'block' : 'none';
                });
                const ds = this._resizeOverlay.querySelector('.drag-surface');
                if (ds) {
                    // For protected/anchored selections, disable move mode entirely
                    if (showControls && this._moveMode && !(isCore || isOutput)) {
                        ds.style.pointerEvents='auto';
                        ds.style.cursor='move';
                    } else {
                        ds.style.pointerEvents='none';
                        ds.style.cursor='default';
                    }
                }
            };
            // expose a refresher so external toggles can re-evaluate pointer events
            this._updateOverlayRef = ()=>{ try { const els = (this._selectionSet && this._selectionSet.length)? this._selectionSet : (this._editorSelected?[this._editorSelected]:null); if (els) updateOverlay(els); } catch(e) {} };
            const onMove = (e)=>{
                // When a selection exists and not dragging, freeze overlay on the selected element
                if (this._editorSelected || this._draggingHandle) return;
                const t = e.target;
                if (!t || t.id==='layout-resize-overlay' || t.closest('#layout-inspector')) return;
                if (!this.isEditableTarget(t)) return;
                this._hoverTarget = t;
                updateOverlay(t);
            };
            // Attach listeners only once
            if (!this._editorListenersAttached) {
                this._onEditorMove = onMove;
                document.addEventListener('mousemove', this._onEditorMove);
            }
            // Activate selection only on right-click (contextmenu)
            this._onEditorContext = (e)=>{
                const t = e.target;
                if (!t || t.closest('#layout-inspector')) return;
                const clickedOverlay = t.closest && t.closest('#layout-resize-overlay');
                // Ignore right-clicks on overlay frame or controls
                if (clickedOverlay) return;
                if (!this.isEditableTarget(t)) return;
                e.preventDefault();
                const ov = this._resizeOverlay;
                if (e.ctrlKey) {
                    this._selectionSet = this._selectionSet || [];
                    const idx = this._selectionSet.indexOf(t);
                    if (idx===-1) this._selectionSet.push(t); else this._selectionSet.splice(idx,1);
                    if (this._selectionSet.length) { this._editorSelected = this._selectionSet[0]; updateOverlay(this._selectionSet); this.renderInspectorForSelected(); }
                    else { this._editorSelected = null; if (ov) ov.style.display='none'; }
                    return;
                }
                // Normal right-click selects a single element
                this._selectionSet = [t];
                this._editorSelected = t;
                updateOverlay(this._selectionSet);
                this.renderInspectorForSelected();
            };
            if (!this._editorListenersAttached) {
                document.addEventListener('contextmenu', this._onEditorContext);
            }
            // expose updater after selection change
            this._updateOverlayRef && this._updateOverlayRef();
            // Drag handles
            const startDrag = (dir, startX, startY)=>{
                if (!this._editorSelected) return;
                
                const el = this._editorSelected;
                if (!this.isEditableTarget(el)) return;

                // Branch: Special handling for side panels
                const isSidePanel = (el.classList.contains('left-menu') || el.classList.contains('right-panel'));
                if (isSidePanel) {
                    const varName = el.classList.contains('left-menu') ? '--left-menu-width' : '--right-panel-width';
                    const storageKey = el.classList.contains('left-menu') ? 'rpg_layout_left' : 'rpg_layout_right';
                    const startW = el.getBoundingClientRect().width;

                    const onMM = (ev)=>{
                        let dx = ev.clientX - startX;
                        let newWidth = dir.includes('w') ? startW - dx : startW + dx;
                        newWidth = Math.max(120, Math.min(800, newWidth)); // Clamp width
                        document.documentElement.style.setProperty(varName, `${Math.round(newWidth)}px`);
                    };
                    const onMU = ()=>{
                        document.removeEventListener('mousemove', onMM);
                        document.removeEventListener('mouseup', onMU);
                        const finalWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(varName));
                        localStorage.setItem(storageKey, finalWidth);
                    };
                    document.addEventListener('mousemove', onMM);
                    document.addEventListener('mouseup', onMU);
                    return; // End special handling
                }

                // Branch: Special handling for game output vertical resizing
                if (el.classList.contains('game-output')) {
                    const csEl = document.querySelector('.center-stack');
                    const startH = el.getBoundingClientRect().height;
                    const onMM = (ev)=>{
                        let dy = ev.clientY - startY;
                        let newHeight = dir.includes('n') ? startH - dy : startH + dy;
                        newHeight = Math.max(240, Math.min(1000, newHeight));
                        document.documentElement.style.setProperty('--center-output-track', `${Math.round(newHeight)}px`);
                    };
                    const onMU = ()=>{
                        document.removeEventListener('mousemove', onMM);
                        document.removeEventListener('mouseup', onMU);
                        const v = getComputedStyle(document.documentElement).getPropertyValue('--center-output-track');
                        const px = parseInt(v,10);
                        if (!isNaN(px)) localStorage.setItem('rpg_center_output_h', px);
                    };
                    document.addEventListener('mousemove', onMM);
                    document.addEventListener('mouseup', onMU);
                    return; // End special handling
                }

                // Default handling for all other elements
                const r = el.getBoundingClientRect();
                const startW = r.width; const startH = r.height; const startL = r.left; const startT = r.top;
                // Record action snapshot
                this.beginEditorAction('resize', [el]);
                const onMM = (ev)=>{
                    let dx = ev.clientX - startX; let dy = ev.clientY - startY;
                    let w = startW, h = startH;
                    if (dir.includes('e')) w = Math.max(50, startW + dx);
                    if (dir.includes('s')) h = Math.max(30, startH + dy);
                    if (dir.includes('w')) w = Math.max(50, startW - dx);
                    if (dir.includes('n')) h = Math.max(30, startH - dy);
                    el.style.width = `${Math.round(w)}px`;
                    el.style.height = `${Math.round(h)}px`;
                    this.persistElementStyle(el);
                    const rr = el.getBoundingClientRect();
                    Object.assign(this._resizeOverlay.style, { width:`${rr.width}px`, height:`${rr.height}px` });
                    this.renderInspectorForSelected();
                };
                const onMU = ()=>{ document.removeEventListener('mousemove', onMM); document.removeEventListener('mouseup', onMU); this._draggingHandle = null; this.commitEditorAction(); };
                document.addEventListener('mousemove', onMM);
                document.addEventListener('mouseup', onMU);
                this._draggingHandle = dir;
            };
            this._resizeOverlay.querySelectorAll('.handle').forEach(h=>{
                h.addEventListener('mousedown', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); const cls = [...h.classList].find(c=> c!=='handle'); startDrag(cls, ev.clientX, ev.clientY); });
            });
            // Drag to move (move mode)
            const dragSurface = this._resizeOverlay.querySelector('.drag-surface');
            if (dragSurface) {
                dragSurface.addEventListener('mousedown', (ev)=>{
                    if (!this._moveMode) return; ev.preventDefault(); ev.stopPropagation();
                    const startX = ev.clientX, startY = ev.clientY;
                    let els = (this._selectionSet && this._selectionSet.length)? [...this._selectionSet] : (this._editorSelected?[this._editorSelected]:[]);
                    els = els.filter(el=> this.isEditableTarget(el));
                    if (!els.length) return;
                    // Record action snapshot
                    this.beginEditorAction('move', els);
                    // Precompute rects, containers, and starting transforms
                    const movedSet = new Set(els);
                    const state = els.map(el=>{
                        const rc = el.getBoundingClientRect();
                        const parent = el.parentElement || document.body;
                        const containerRect = parent.getBoundingClientRect();
                        const { tx, ty } = this.getCurrentTranslate(el);
                        // blocker rects = siblings not in movedSet
                        const blockers = [];
                        try {
                            Array.from(parent.children||[]).forEach(ch=>{ if (!movedSet.has(ch) && this.isEditableTarget(ch)) { const r = ch.getBoundingClientRect(); if (r.width>0 && r.height>0) blockers.push({ el: ch, rect: r }); } });
                        } catch {}
                        return { el, startRect: rc, containerRect, startTx: tx, startTy: ty, blockers };
                    });
                    // Compute container clamping once
                    const dxMin = Math.max(...state.map(s=> s.containerRect.left - s.startRect.left));
                    const dxMax = Math.min(...state.map(s=> s.containerRect.right - s.startRect.right));
                    const dyMin = Math.max(...state.map(s=> s.containerRect.top - s.startRect.top));
                    const dyMax = Math.min(...state.map(s=> s.containerRect.bottom - s.startRect.bottom));
                    let lastGoodDx = 0, lastGoodDy = 0;
                    let swapCandidateEl = null;
                    const onMM = (e2)=>{
                        let dx = e2.clientX - startX; let dy = e2.clientY - startY;
                        // Snap-to-grid when Shift is held
                        try {
                            if (e2.shiftKey) {
                                const g = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-size')||'16',10) || 16;
                                dx = Math.round(dx / g) * g;
                                dy = Math.round(dy / g) * g;
                            }
                        } catch {}
                        // Clamp to container
                        dx = Math.max(dxMin, Math.min(dxMax, dx));
                        dy = Math.max(dyMin, Math.min(dyMax, dy));
                        // Check overlap against blockers; if any, revert to last good
                        const intersects = (a,b)=> a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
                        let ok = true;
                        for (let i=0;i<state.length;i++) {
                            const s = state[i];
                            const nr = { left: s.startRect.left + dx, right: s.startRect.right + dx, top: s.startRect.top + dy, bottom: s.startRect.bottom + dy };
                            for (const br of s.blockers) { if (intersects(nr, br.rect)) { ok = false; if (!swapCandidateEl && i===0) swapCandidateEl = br.el; break; } }
                            if (!ok) break;
                        }
                        if (!ok) { dx = lastGoodDx; dy = lastGoodDy; }
                        else { lastGoodDx = dx; lastGoodDy = dy; }
                        // Apply transforms without changing dimensions
                        state.forEach(s=>{ s.el.style.transform = `translate(${Math.round(s.startTx + dx)}px, ${Math.round(s.startTy + dy)}px)`; this.persistElementStyle(s.el); });
                        updateOverlay(els);
                    };
                    const onMU = ()=>{ 
                        document.removeEventListener('mousemove', onMM); document.removeEventListener('mouseup', onMU);
                        // If we detected a swap candidate for the anchor element, perform a swap of transforms
                        try {
                            if (swapCandidateEl && state && state.length) {
                                const a = state[0];
                                // ensure we track candidate before/after in history
                                if (this._pendingAction) {
                                    const sel = this.getUniqueSelectorFor(swapCandidateEl);
                                    if (sel) {
                                        const beforeSnap = this.captureStylesForElements([swapCandidateEl]);
                                        this._pendingAction.before = { ...(this._pendingAction.before||{}), ...(beforeSnap||{}) };
                                        this._pendingAction.elements.push(sel);
                                    }
                                }
                                // Find candidate rect captured during mousedown
                                let candRect = null;
                                for (const br of a.blockers) { if (br.el === swapCandidateEl) { candRect = br.rect; break; } }
                                const bTxTy = this.getCurrentTranslate(swapCandidateEl);
                                if (candRect) {
                                    const newATx = (a.startTx||0) + (candRect.left - a.startRect.left);
                                    const newATy = (a.startTy||0) + (candRect.top - a.startRect.top);
                                    const newBTx = (bTxTy.tx||0) + (a.startRect.left - candRect.left);
                                    const newBTy = (bTxTy.ty||0) + (a.startRect.top - candRect.top);
                                    a.el.style.transform = `translate(${Math.round(newATx)}px, ${Math.round(newATy)}px)`;
                                    swapCandidateEl.style.transform = `translate(${Math.round(newBTx)}px, ${Math.round(newBTy)}px)`;
                                    this.persistElementStyle(a.el);
                                    this.persistElementStyle(swapCandidateEl);
                                }
                            }
                        } catch {}
                        this.commitEditorAction();
                        // For elements anchored within main sections, never keep transform after drop
                        try {
                            (els||[]).forEach(el=>{ if (el && el.closest && el.closest('.left-menu, .center-stack, .right-panel, .banner-bar, .status-bar')) { el.style.transform=''; this.persistElementStyle(el); } });
                        } catch {}
                    };
                    document.addEventListener('mousemove', onMM);
                    document.addEventListener('mouseup', onMU);
                });
            }
            const unlock = ()=>{ this._editorSelected = null; this._selectionSet = []; if (this._resizeOverlay) { this._resizeOverlay.style.display='none'; const tb=this._resizeOverlay.querySelector('.toolbar'); if (tb) tb.style.display='none'; this._resizeOverlay.querySelectorAll('.handle').forEach(h=> h.style.display='none'); const ds=this._resizeOverlay.querySelector('.drag-surface'); if (ds) { ds.style.pointerEvents='none'; ds.style.cursor='default'; } } };
            const unlockBtn = this._resizeOverlay.querySelector('#resize-unlock-btn'); if (unlockBtn) unlockBtn.addEventListener('click', (e)=>{ e.stopPropagation(); unlock(); });
            const resetBtn = this._resizeOverlay.querySelector('#resize-resetwh-btn'); if (resetBtn) resetBtn.addEventListener('click', (e)=>{ e.stopPropagation(); const targets=(this._selectionSet&&this._selectionSet.length)?this._selectionSet:[this._editorSelected]; const filtered=(targets||[]).filter(el=> this.isEditableTarget(el)); this.beginEditorAction('reset-size', filtered); filtered.forEach(el=>{ if (el){ el.style.width=''; el.style.height=''; this.persistElementStyle(el); } }); this.commitEditorAction(); this.renderInspectorForSelected(); if (this._editorSelected){ const rr=this._editorSelected.getBoundingClientRect(); Object.assign(this._resizeOverlay.style, { width:`${rr.width}px`, height:`${rr.height}px` }); } });
            const resetPosBtn = this._resizeOverlay.querySelector('#resize-resetpos-btn'); if (resetPosBtn) resetPosBtn.addEventListener('click', (e)=>{ e.stopPropagation(); const targets=(this._selectionSet&&this._selectionSet.length)?this._selectionSet:[this._editorSelected]; const filtered=(targets||[]).filter(el=> this.isEditableTarget(el)); this.beginEditorAction('reset-position', filtered); filtered.forEach(el=>{ if (el){ el.style.position=''; el.style.left=''; el.style.top=''; el.style.zIndex=''; el.style.transform=''; this.persistElementStyle(el); } }); this.commitEditorAction(); updateOverlay(filtered.length?filtered:[this._editorSelected]); });
            const clearSelBtn = this._resizeOverlay.querySelector('#resize-clearsel-btn'); if (clearSelBtn) clearSelBtn.addEventListener('click',(e)=>{ e.stopPropagation(); this._selectionSet=[this._editorSelected].filter(Boolean); updateOverlay(this._selectionSet); });
            const undoBtn = this._resizeOverlay.querySelector('#resize-undo-btn'); if (undoBtn) undoBtn.addEventListener('click',(e)=>{ e.stopPropagation(); this.undoEditorAction(); });
            const redoBtn = this._resizeOverlay.querySelector('#resize-redo-btn'); if (redoBtn) redoBtn.addEventListener('click',(e)=>{ e.stopPropagation(); this.redoEditorAction(); });
            const saveBtn = this._resizeOverlay.querySelector('#resize-save-layout-btn'); if (saveBtn) saveBtn.addEventListener('click',(e)=>{ e.stopPropagation(); this.saveCurrentLayoutSnapshot(); this.showNotification('Layout saved','success', 1500); });
            const restoreBtn = this._resizeOverlay.querySelector('#resize-restore-layout-btn'); if (restoreBtn) restoreBtn.addEventListener('click',(e)=>{ e.stopPropagation(); this.restoreFromSavedLayoutSnapshot(); });
            const resetAllBtn = this._resizeOverlay.querySelector('#resize-resetall-btn'); if (resetAllBtn) resetAllBtn.addEventListener('click',(e)=>{ e.stopPropagation(); this.resetLayoutToDefaults(true); });
            // Escape to unlock + shortcuts
            this._onEditorKey = (ev)=>{ 
                if (ev.key === 'Escape') { unlock(); }
                if (ev.ctrlKey && ev.key.toLowerCase()==='z') { ev.preventDefault(); this.undoEditorAction(); }
                if ((ev.ctrlKey && ev.shiftKey && ev.key.toLowerCase()==='z') || (ev.ctrlKey && ev.key.toLowerCase()==='y')) { ev.preventDefault(); this.redoEditorAction(); }
            };
            if (!this._editorListenersAttached) {
                document.addEventListener('keydown', this._onEditorKey);
                this._editorListenersAttached = true;
            }
            // Initialize buttons state
            this.updateUndoRedoButtons();
        } else {
            // Only tear down if move mode is also off
            if (!this._moveMode) {
                if (this._onEditorMove) document.removeEventListener('mousemove', this._onEditorMove);
                if (this._onEditorContext) document.removeEventListener('contextmenu', this._onEditorContext);
                if (this._onEditorKey) document.removeEventListener('keydown', this._onEditorKey);
                this._editorListenersAttached = false;
                const ov = document.getElementById('layout-resize-overlay'); if (ov) ov.remove();
                this._resizeOverlay = null; this._editorSelected = null; this._selectionSet = []; this._hoverTarget = null; this._updateOverlayRef = null;
            } else {
                // Keep overlay for move mode, just hide handles
                if (this._resizeOverlay) this._resizeOverlay.querySelectorAll('.handle').forEach(h=> h.style.display='none');
            }
        }
    }

    // -------- Layout persistence & history helpers --------
    getCurrentLayoutVariables() {
        const cs = getComputedStyle(document.documentElement);
        const toNum = (v)=>{ v=v.trim(); return v && v !== 'none' ? parseInt(v,10) : 0; };
        return {
            left: toNum(cs.getPropertyValue('--left-menu-width')||'0'),
            right: toNum(cs.getPropertyValue('--right-panel-width')||'0'),
            gap: toNum(cs.getPropertyValue('--content-gap')||'0'),
            rpmax: toNum(cs.getPropertyValue('--rp-pane-max')||'0'),
            grid: toNum(cs.getPropertyValue('--grid-size')||'16'),
            center_output: (function(){ const v = cs.getPropertyValue('--center-output-track')||'1fr'; return /px/.test(v)? toNum(v): 0; })()
        };
    }

    // Collect a full snapshot of editable elements, including computed transform if present
    collectAllEditableStyles() {
        const props = ['width','height','maxHeight','overflowY','position','left','top','zIndex','transform','fontSize','fontFamily','fontWeight','textAlign','lineHeight','color','backgroundColor','paddingTop','paddingRight','paddingBottom','paddingLeft'];
        const map = {};
        try {
            const all = Array.from(document.body.querySelectorAll('*'));
            for (const el of all) {
                if (!this.isEditableTarget(el)) continue;
                const selector = this.getUniqueSelectorFor(el);
                if (!selector) continue;
                const styles = {};
                const cs = getComputedStyle(el);
                for (const k of props) {
                    let v = el.style[k];
                    if (!v || v === '') {
                        // If not set inline, capture computed for robustness (fonts/colors/padding/line-height/position, etc.)
                        if (k === 'transform') {
                            const ct = cs.transform; if (ct && ct !== 'none') v = ct;
                        } else {
                            const cv = cs[k]; if (cv && cv !== '' && cv !== 'initial' && cv !== 'auto' && cv !== 'normal' && cv !== 'none') v = cv;
                        }
                    }
                    if (v && v !== '') styles[k] = v;
                }
                if (Object.keys(styles).length > 0) map[selector] = styles;
            }
        } catch (e) { /* ignore */ }
        return map;
    }

    saveCurrentLayoutSnapshot() {
        try {
            const vars = this.getCurrentLayoutVariables();
            const element_styles = this.collectAllEditableStyles();
            const payload = { vars, element_styles, saved_at: Date.now() };
            // 1) Save the snapshot that the toolbar "Restore" uses
            localStorage.setItem('rpg_layout_saved', JSON.stringify(payload));
            // 2) Also update the auto-applied map so a simple reload reflects the new layout
            //    (we store the raw capture here; application time will sanitize if needed)
            try { localStorage.setItem('rpg_element_styles', JSON.stringify(element_styles)); } catch {}
        } catch (e) { console.warn('saveCurrentLayoutSnapshot failed', e); }
    }

    resetLayoutToDefaults(showMsg = true) {
        try {
            // Clear saved element styles and remove inline styles from affected elements
            const raw = localStorage.getItem('rpg_element_styles');
            if (raw) {
                try {
                    const map = JSON.parse(raw);
                    Object.entries(map).forEach(([selector, styles])=>{
                        try {
                            document.querySelectorAll(selector).forEach(el=>{
                                ['width','height','maxHeight','overflowY','position','left','top','zIndex','transform','fontSize','fontFamily','fontWeight','textAlign','lineHeight','color','backgroundColor','paddingTop','paddingRight','paddingBottom','paddingLeft'].forEach(k=>{ el.style[k] = ''; });
                            });
                        } catch { /* ignore */ }
                    });
                } catch { /* ignore */ }
            }
            localStorage.removeItem('rpg_element_styles');
            // Reset CSS variables to defaults as defined in CSS
            document.documentElement.style.setProperty('--left-menu-width', '180px');
            document.documentElement.style.setProperty('--right-panel-width', '420px');
            document.documentElement.style.setProperty('--content-gap', '10px');
            document.documentElement.style.setProperty('--rp-pane-max', 'none');
            document.documentElement.style.setProperty('--grid-size', '16px');
            // Clear saved variable overrides
            ['rpg_layout_left','rpg_layout_right','rpg_layout_gap','rpg_rp_max','rpg_grid_size'].forEach(k=> localStorage.removeItem(k));
            // Turn off editor/move by default
            localStorage.setItem('rpg_dev_editor_enabled', 'false');
            localStorage.setItem('rpg_dev_move_enabled', 'false');
            // Remove overlays
            this.toggleGridOverlay(false);
            this.enableLayoutInspector(false);
            this.enableElementResizeMode(false);
            // Re-anchor layout and restore expected order
            this.enforceMainLayoutAnchors();
            this.enforceCenterStackOrder();
            if (showMsg) this.showNotification('Layout reset to defaults', 'success');
        } catch (e) { console.warn('resetLayoutToDefaults failed', e); }
    }

    captureStylesForElements(els) {
        const snap = {};
        els.forEach(el=>{
            if (!this.isEditableTarget(el)) return;
            const selector = this.getUniqueSelectorFor(el);
            if (!selector) return;
            snap[selector] = {};
            ['width','height','maxHeight','overflowY','position','left','top','zIndex','transform','fontSize','fontFamily','fontWeight','textAlign','lineHeight','color','backgroundColor','paddingTop','paddingRight','paddingBottom','paddingLeft'].forEach(k=>{ if (el.style[k]) snap[selector][k] = el.style[k]; });
        });
        return snap;
    }

    applySnapshot(snap) {
        Object.entries(snap||{}).forEach(([selector, styles])=>{
            try {
                document.querySelectorAll(selector).forEach(el=>{ Object.assign(el.style, styles||{}); this.persistElementStyle(el); });
            } catch { /* ignore */ }
        });
    }

    beginEditorAction(label, els) {
        try {
            const elements = (els||[]).filter(Boolean);
            this._pendingAction = { label, before: this.captureStylesForElements(elements), elements: elements.map(el=> this.getUniqueSelectorFor(el)) };
        } catch { this._pendingAction = null; }
    }

    commitEditorAction() {
        if (!this._pendingAction) { this.updateUndoRedoButtons(); return; }
        try {
            const after = {};
            (this._pendingAction.elements||[]).forEach(sel=>{
                document.querySelectorAll(sel).forEach(el=>{
                    after[sel] = after[sel] || {};
                    ['width','height','maxHeight','overflowY','position','left','top','zIndex','transform','fontSize','fontFamily','fontWeight','textAlign','lineHeight','color','backgroundColor','paddingTop','paddingRight','paddingBottom','paddingLeft'].forEach(k=>{ if (el.style[k]) after[sel][k] = el.style[k]; });
                });
            });
            const action = { label: this._pendingAction.label, before: this._pendingAction.before, after };
            // Truncate any redo tail
            if (this._historyIndex < this._history.length - 1) this._history = this._history.slice(0, this._historyIndex + 1);
            this._history.push(action);
            this._historyIndex = this._history.length - 1;
        } finally {
            this._pendingAction = null;
            this.updateUndoRedoButtons();
        }
    }

    undoEditorAction() {
        if (this._historyIndex < 0) return;
        const action = this._history[this._historyIndex];
        this.applySnapshot(action.before);
        this._historyIndex--;
        this.updateUndoRedoButtons();
    }

    redoEditorAction() {
        if (this._historyIndex >= this._history.length - 1) return;
        this._historyIndex++;
        const action = this._history[this._historyIndex];
        this.applySnapshot(action.after);
        this.updateUndoRedoButtons();
    }

    updateUndoRedoButtons() {
        try {
            const ov = this._resizeOverlay;
            if (!ov) return;
            const canUndo = this._historyIndex >= 0;
            const canRedo = this._historyIndex < this._history.length - 1;
            const u = ov.querySelector('#resize-undo-btn'); if (u) u.disabled = !canUndo;
            const r = ov.querySelector('#resize-redo-btn'); if (r) r.disabled = !canRedo;
        } catch { /* ignore */ }
    }

    restoreFromSavedLayoutSnapshot() {
        try {
            const raw = localStorage.getItem('rpg_layout_saved');
            if (!raw) { this.showNotification('No saved snapshot found','warning'); return; }
            const saved = JSON.parse(raw);
            const v = saved.vars || {};
            const setVar = (name, val)=>{ 
                if (name==='--rp-pane-max') {
                    if (val && parseInt(val,10)>0) document.documentElement.style.setProperty(name, `${parseInt(val,10)}px`); 
                    else document.documentElement.style.setProperty(name, 'none'); 
                } else if (name==='--center-output-track') {
                    if (val && parseInt(val,10)>0) document.documentElement.style.setProperty(name, `${parseInt(val,10)}px`);
                    else document.documentElement.style.setProperty(name, '1fr');
                } else if (val!=null) { 
                    document.documentElement.style.setProperty(name, `${parseInt(val,10)}px`); 
                } 
            };
            setVar('--left-menu-width', v.left||180);
            setVar('--right-panel-width', v.right||420);
            setVar('--content-gap', v.gap||10);
            setVar('--rp-pane-max', v.rpmax||0);
            setVar('--grid-size', v.grid||16);
            setVar('--center-output-track', v.center_output||0);
            localStorage.setItem('rpg_layout_left', v.left||180);
            localStorage.setItem('rpg_layout_right', v.right||420);
            localStorage.setItem('rpg_layout_gap', v.gap||10);
            localStorage.setItem('rpg_rp_max', v.rpmax||0);
            localStorage.setItem('rpg_grid_size', v.grid||16);
            const map = saved.element_styles || {};
            localStorage.setItem('rpg_element_styles', JSON.stringify(map));
            // Clear inline styles for known edited elements and reapply
            try { Object.keys(map).forEach(sel=>{ document.querySelectorAll(sel).forEach(el=>{ ['width','height','maxHeight','overflowY','position','left','top','zIndex','transform','fontSize','fontFamily','fontWeight','textAlign','lineHeight','color','backgroundColor','paddingTop','paddingRight','paddingBottom','paddingLeft'].forEach(k=>{ el.style[k]=''; }); }); }); } catch(e) {}
            Object.entries(map).forEach(([selector, styles])=>{ try { document.querySelectorAll(selector).forEach(el=>{ Object.assign(el.style, styles||{}); }); } catch(e) {} });
            this.applySavedLayoutSettings();
            if (this._updateOverlayRef) this._updateOverlayRef();
            this.showNotification('Layout restored from saved snapshot','success');
        } catch (e) { console.warn('restoreFromSavedLayoutSnapshot failed', e); this.showNotification('Failed to restore layout','error'); }
    }

    rgbToHex(rgb) {
        try {
            if (!rgb) return '#000000';
            if (rgb.startsWith('#')) return rgb;
            const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            if (!m) return '#000000';
            const toHex = (n)=> ('0'+(parseInt(n,10)||0).toString(16)).slice(-2);
            return `#${toHex(m[1])}${toHex(m[2])}${toHex(m[3])}`;
        } catch { return '#000000'; }
    }

    renderInspectorForSelected() {
        if (!this._editorSelected || !this._inspPanel) return;
        try {
            const el = this._editorSelected;
            const r = el.getBoundingClientRect();
            const cs = getComputedStyle(el);
            const id = el.id?`#${el.id}`:''; const cls = el.className?'.'+String(el.className).trim().split(/\s+/).join('.') : '';
            const tag = el.tagName.toLowerCase();
            const w = parseInt(cs.width,10)||Math.round(r.width); const h = parseInt(cs.height,10)||Math.round(r.height);
            const ov = cs.overflowY || 'visible'; const mh = cs.maxHeight || 'none';
            const base = this._inspPanel.innerHTML;
            // Append editor controls if not already present
            if (!this._inspPanel.querySelector('#insp-el-width')) {
                this._inspPanel.innerHTML = base + `
                    <hr style=\"opacity:0.4;margin:6px 0;\">
                    <div style=\"font-weight:bold;margin-bottom:4px;\">Selected: ${tag}${id}${cls}</div>
                    <div class=\"insp-row\"><label for=\"insp-el-width\">Width:</label><input type=\"number\" id=\"insp-el-width\" min=\"50\" max=\"2000\" step=\"1\" value=\"${w}\"><span>px</span></div>
                    <div class=\"insp-row\"><label for=\"insp-el-height\">Height:</label><input type=\"number\" id=\"insp-el-height\" min=\"30\" max=\"2000\" step=\"1\" value=\"${h}\"><span>px</span></div>
                    <div class=\"insp-row\"><label for=\"insp-el-maxh\">MaxH:</label><input type=\"number\" id=\"insp-el-maxh\" min=\"0\" max=\"4000\" step=\"10\" value=\"${mh==='none'?0:parseInt(mh,10)||0}\"><span>px</span></div>
                    <div class=\"insp-row\"><label for=\"insp-el-over\">Overflow:</label><input type=\"text\" id=\"insp-el-over\" value=\"${ov}\"></div>
                    <div class=\"insp-row\"><button id=\"insp-el-reset\" class=\"cancel-btn\">Reset</button></div>
                    <hr style=\"opacity:0.3;margin:6px 0;\">
                    <div style=\"font-weight:bold;margin-bottom:4px;\">Typography & Colors</div>
                    <div class=\"insp-row\"><label for=\"insp-font-size\">Font Size:</label><input type=\"number\" id=\"insp-font-size\" min=\"8\" max=\"64\" step=\"1\" value=\"${parseInt(cs.fontSize,10)||14}\"><span>px</span></div>
                    <div class=\"insp-row\"><label for=\"insp-font-family\">Font:</label><input type=\"text\" id=\"insp-font-family\" list=\"font-family-list\" value=\"${(cs.fontFamily||'').replace(/\"/g,'&quot;')}\"></div>
                    <datalist id=\"font-family-list\">${[
                        "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif",
                        "Segoe UI, Tahoma, Geneva, Verdana, sans-serif",
                        "Roboto, system-ui, -apple-system, Segoe UI, sans-serif",
                        "Inter, system-ui, -apple-system, Segoe UI, sans-serif",
                        "Open Sans, Segoe UI, Verdana, sans-serif",
                        "Lato, Segoe UI, Verdana, sans-serif",
                        "Montserrat, Segoe UI, Verdana, sans-serif",
                        "Nunito, Segoe UI, Verdana, sans-serif",
                        "Poppins, Segoe UI, Verdana, sans-serif",
                        "Garamond, 'Palatino Linotype', Palatino, serif",
                        "Georgia, 'Times New Roman', Times, serif",
                        "Times New Roman, Times, serif",
                        "Palatino Linotype, Book Antiqua, Palatino, serif",
                        "Trebuchet MS, Helvetica, sans-serif",
                        "Lucida Grande, Lucida Sans Unicode, Lucida Sans, Geneva, Verdana, sans-serif",
                        "Courier New, Courier, monospace",
                        "Consolas, 'Liberation Mono', Menlo, monospace"
                    ].map(f=>`<option value=\"${f.replace(/\"/g,'&quot;')}\"></option>`).join('')}</datalist>
                    <div class=\"insp-row\"><label for=\"insp-font-weight\">Weight:</label><select id=\"insp-font-weight\"><option value=\"normal\">normal</option><option value=\"bold\">bold</option><option value=\"100\">100</option><option value=\"200\">200</option><option value=\"300\">300</option><option value=\"400\">400</option><option value=\"500\">500</option><option value=\"600\">600</option><option value=\"700\">700</option><option value=\"800\">800</option><option value=\"900\">900</option></select></div>
                    <div class=\"insp-row\"><label for=\"insp-text-align\">Text Align:</label><select id=\"insp-text-align\"><option value=\"left\">left</option><option value=\"center\">center</option><option value=\"right\">right</option></select></div>
                    <div class=\"insp-row\"><label for=\"insp-line-height\">Line Height:</label><input type=\"number\" id=\"insp-line-height\" min=\"0\" max=\"400\" step=\"1\" value=\"${parseInt(cs.lineHeight,10)||0}\"><span>px</span></div>
                    <div class=\"insp-row\"><label for=\"insp-color\">Text Color:</label><input type=\"color\" id=\"insp-color\" value=\"${this.rgbToHex(cs.color||'#000000')}\"></div>
                    <div class=\"insp-row\"><label for=\"insp-bgcolor\">Background:</label><input type=\"color\" id=\"insp-bgcolor\" value=\"${this.rgbToHex(cs.backgroundColor||'#000000')}\"></div>
                    <div class=\"insp-row\"><label>Padding:</label>
                        <input type=\"number\" id=\"insp-pad-top\" style=\"width:60px\" value=\"${parseInt(cs.paddingTop,10)||0}\" title=\"Top\"> 
                        <input type=\"number\" id=\"insp-pad-right\" style=\"width:60px\" value=\"${parseInt(cs.paddingRight,10)||0}\" title=\"Right\"> 
                        <input type=\"number\" id=\"insp-pad-bottom\" style=\"width:60px\" value=\"${parseInt(cs.paddingBottom,10)||0}\" title=\"Bottom\"> 
                        <input type=\"number\" id=\"insp-pad-left\" style=\"width:60px\" value=\"${parseInt(cs.paddingLeft,10)||0}\" title=\"Left\">
                        <span>px</span>
                    </div>
                `;
                const wI = this._inspPanel.querySelector('#insp-el-width');
                const hI = this._inspPanel.querySelector('#insp-el-height');
                const mI = this._inspPanel.querySelector('#insp-el-maxh');
                const oI = this._inspPanel.querySelector('#insp-el-over');
                const resetBtn = this._inspPanel.querySelector('#insp-el-reset');
                const bind = (elInput, cssProp, parse=(v)=>v+"px")=>{
                    if (!elInput) return; 
                    elInput.addEventListener('focusin', ()=>{ this.beginEditorAction('insp-edit', [el]); });
                    elInput.addEventListener('input', ()=>{ let v = elInput.value; if (cssProp==='maxHeight' && (v===0 || v==='0')) { el.style.maxHeight = ''; } else { el.style[cssProp] = (cssProp==='overflowY' || cssProp==='fontFamily' || cssProp==='fontWeight' || cssProp==='textAlign' || cssProp==='color' || cssProp==='backgroundColor')? v : `${parseInt(v,10)||0}px`; } this.persistElementStyle(el); });
                    elInput.addEventListener('focusout', ()=>{ this.commitEditorAction(); });
                };
                bind(wI,'width'); bind(hI,'height'); bind(mI,'maxHeight');
                if (oI) { oI.addEventListener('focusin', ()=>{ this.beginEditorAction('insp-edit', [el]); }); oI.addEventListener('input', ()=>{ el.style.overflowY = oI.value||''; this.persistElementStyle(el); }); oI.addEventListener('focusout', ()=>{ this.commitEditorAction(); }); }
                if (resetBtn) resetBtn.addEventListener('click', ()=>{ this.beginEditorAction('insp-reset', [el]); el.style.width=''; el.style.height=''; el.style.maxHeight=''; el.style.overflowY=''; this.persistElementStyle(el); this.commitEditorAction(); });
                // Typography & colors bindings
                const fsI = this._inspPanel.querySelector('#insp-font-size'); bind(fsI,'fontSize');
                const ffI = this._inspPanel.querySelector('#insp-font-family'); bind(ffI,'fontFamily');
                const fwI = this._inspPanel.querySelector('#insp-font-weight'); if (fwI) { fwI.value = cs.fontWeight || 'normal'; bind(fwI,'fontWeight'); }
                const taI = this._inspPanel.querySelector('#insp-text-align'); if (taI) { taI.value = cs.textAlign || 'left'; bind(taI,'textAlign'); }
                const lhI = this._inspPanel.querySelector('#insp-line-height'); bind(lhI,'lineHeight');
                const colorI = this._inspPanel.querySelector('#insp-color'); if (colorI) { colorI.addEventListener('input', ()=>{ el.style.color = colorI.value; this.persistElementStyle(el); }); }
                const bgI = this._inspPanel.querySelector('#insp-bgcolor'); if (bgI) { bgI.addEventListener('input', ()=>{ el.style.backgroundColor = bgI.value; this.persistElementStyle(el); }); }
                const ptI = this._inspPanel.querySelector('#insp-pad-top'); bind(ptI,'paddingTop');
                const prI = this._inspPanel.querySelector('#insp-pad-right'); bind(prI,'paddingRight');
                const pbI = this._inspPanel.querySelector('#insp-pad-bottom'); bind(pbI,'paddingBottom');
                const plI = this._inspPanel.querySelector('#insp-pad-left'); bind(plI,'paddingLeft');
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Open a modal dialog
     * @param {string} modalName - The name of the modal to open
     */
    openModal(modalName) {
        this.closeAllModals();

        if (this.modals[modalName]) {
            this.modals[modalName].classList.add('active');

            // Focus first input in modal, if any
            const firstInput = this.modals[modalName].querySelector('input, select, button');
            if (firstInput) {
                firstInput.focus();
            }
        }
    }

    /**
     * Close a specific modal
     * @param {string} modalName - The name of the modal to close
     */
    closeModal(modalName) {
        if (this.modals[modalName]) {
            this.modals[modalName].classList.remove('active');
        }
    }

    /**
     * Close all modals
     */
    closeAllModals() {
        for (const modalName in this.modals) {
            this.closeModal(modalName);
        }
    }

    /**
     * Populate the saves list in the load game modal
     * @param {Array} saves - Array of save objects
     */
    populateSavesList(saves) {
        this.savesList.innerHTML = '';

        if (!saves || saves.length === 0) {
            const message = document.createElement('div');
            message.className = 'no-saves';
            message.textContent = 'No saved games found.';
            this.savesList.appendChild(message);
            this.loadButton.disabled = true;
            return;
        }

        this.loadButton.disabled = true;
        let selectedSaveId = null;

        saves.forEach(save => {
            const saveItem = document.createElement('div');
            saveItem.className = 'save-item';
            saveItem.dataset.saveId = save.save_id;

            const header = document.createElement('div');
            header.className = 'save-item-header';

            const name = document.createElement('div');
            name.className = 'save-item-name';
            name.textContent = save.save_name;

            const time = document.createElement('div');
            time.className = 'save-item-time';
            time.textContent = save.formatted_save_time || new Date(save.save_time * 1000).toLocaleString();

            header.appendChild(name);
            header.appendChild(time);

            const details = document.createElement('div');
            details.className = 'save-item-details';
            details.textContent = `${save.player_name} (Level ${save.player_level}) - ${save.location}`;

            saveItem.appendChild(header);
            saveItem.appendChild(details);

            // Add click event to select the save
            saveItem.addEventListener('click', () => {
                // Remove selection from all saves
                document.querySelectorAll('.save-item').forEach(item => {
                    item.classList.remove('selected');
                });

                // Select this save
                saveItem.classList.add('selected');
                selectedSaveId = save.save_id;
                this.loadButton.disabled = false;
            });

            this.savesList.appendChild(saveItem);
        });

        // Set up load button to return the selected save
        this.loadButton.onclick = () => {
            if (selectedSaveId) {
                const event = new CustomEvent('load-save', {
                    detail: { saveId: selectedSaveId }
                });
                document.dispatchEvent(event);
                this.closeAllModals();
            }
        };
    }

    /**
     * Apply a theme to the UI
     * @param {string} theme - The theme name
     */
    applyTheme(theme) {
        document.body.classList.remove('light-theme', 'dark-theme', 'fantasy-theme');
        document.body.classList.add(`${theme}-theme`);
        this.settings.theme = theme;

        // Update theme selector if it exists
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) {
            themeSelect.value = theme;
        }

        localStorage.setItem('rpg_theme', theme);
    }

    async populateBackgroundsSelect() {
        try {
            const resp = await fetch('/api/ui/backgrounds');
            if (!resp.ok) return;
            const data = await resp.json();
            const select = document.getElementById('background-select');
            if (!select) return;
            const saved = localStorage.getItem('rpg_bg_filename') || '';
            (data.backgrounds||[]).forEach(fn=>{
                const opt = document.createElement('option');
                opt.value = fn;
                opt.textContent = fn;
                select.appendChild(opt);
            });
            if (saved) select.value = saved;
        } catch (e) { /* ignore */ }
    }

    /** Render the right panel using UI state */
    renderRightPanel(ui) {
        // Ensure combat tab presence if in combat mode
        if ((ui.mode||'').toUpperCase() === 'COMBAT') {
            this.ensureCombatTab();
        }
        // Character tab content
        const charPane = document.getElementById('tab-character');
        if (charPane) {
            const res = ui.resources || {};
            const bar = (name, key, color) => {
                const r = res[key] || { current: 0, max: 0 };
                const pct = r.max ? Math.min(100, (r.current / r.max) * 100) : 0;
                return `<div class=\"rp-bar\" data-bar-type=\"${key}\">
                    <div class=\"rp-bar-title\" data-bar-type=\"${key}\">${name}: ${Math.round(r.current)}/${Math.round(r.max)}</div>
                    <div class=\"rp-bar-track\"><div class=\"rp-bar-fill\" data-bar-type=\"${key}\" style=\"width:${pct}%; background:${color}\"></div></div>
                </div>`;
            };
            const statList = (title, dict) => {
                const rows = Object.keys(dict||{}).map(k=>{
                    const s = dict[k] || {};
                    const valNum = Number(s.value||0);
                    const baseNum = Number(s.base_value||valNum);
                    const delta = Math.round(valNum - baseNum);
                    const sign = delta > 0 ? '+' : '';
                    const color = delta > 0 ? '#69c45f' : (delta < 0 ? '#c45f5f' : null);
                    const deltaHtml = delta !== 0 ? ` <span class=\"stat-delta\" style=\"color:${color}\">(${sign}${delta})</span>` : '';
                    return `<div class=\"rp-row stat-row\" data-stat-key=\"${k}\" data-stat-base=\"${baseNum}\" data-stat-value=\"${valNum}\"><span>${s.name||k}</span><span>${Math.round(valNum)}${deltaHtml}</span></div>`;
                }).join('');
                return `<div class=\"rp-group\"><div class=\"rp-title\">${title}</div>${rows||'<div class=\"rp-empty\">—</div>'}</div>`;
            };
            const statusRows = (ui.status_effects||[]).map(e=>`<div class="rp-row"><span>${e.name}</span><span>${e.duration??''}</span></div>`).join('');
            const turnRows = (ui.turn_order||[]).map(t=>`<div class="rp-row"><span>${t}</span></div>`).join('');
            const initiativeVal = (ui.initiative==null||ui.initiative===undefined)?'0':Math.round(ui.initiative);
            
            // Build paperdoll
            const paperdollHtml = this.renderPaperdoll(ui);
            charPane.innerHTML = `
                <div class="rp-header">
                    <div class="rp-name">${ui.player.name}</div>
                    <div class="rp-sub">Race: ${ui.player.race} | Class: ${ui.player.path}</div>
                    <div class="rp-sub">Level: ${ui.player.level} | Experience: ${ui.player.experience_current}/${ui.player.experience_max}</div>
                </div>
                ${bar('Health', 'health', '#CC3333')}
                ${bar('Mana', 'mana', '#3366CC')}
                ${bar('Stamina', 'stamina', '#66CC33')}
                <div class="rp-columns">
                    <div class="rp-col">${statList('Primary Stats', ui.primary_stats)}</div>
                    <div class="rp-col">${statList('Derived Stats', ui.derived_stats)}</div>
                </div>
                <div class="rp-columns">
                    <div class="rp-col">${statList('Social', ui.social_stats)}</div>
                    <div class="rp-col">${statList('Other', ui.other_stats)}</div>
                </div>
                <div class="rp-group"><div class="rp-title">Combat Info</div>
                    <div class="rp-row"><span>Initiative</span><span>${initiativeVal}</span></div>
                    <div class="rp-subtitle">Status Effects</div>${statusRows||'<div class="rp-empty">—</div>'}
                    <div class="rp-subtitle">Turn Order</div>${turnRows||'<div class="rp-empty">—</div>'}
                </div>
                ${paperdollHtml}
            `;
            // Attach character tab handlers (context menus, tooltips, paperdoll)
            this.attachCharacterTabHandlers();
            this.attachPaperdollHandlers();
        }
        // Inventory tab
        const invPane = document.getElementById('tab-inventory');
        if (invPane) {
            this.renderInventoryPane();
        }
        // Journal tab
        const jPane = document.getElementById('tab-journal');
        if (jPane) {
            this.renderJournalPane(ui);
        }
        
        // Auto-scroll the active right panel tab if content overflows
        this.ensureRightPanelScrollable();
    }

    // Ensure the 'Combat' tab exists in the right panel
    ensureCombatTab() {
        try {
            const tabs = document.querySelector('.right-tabs');
            if (!tabs) return;
            const btnRow = tabs.querySelector('.tab-buttons');
            const content = tabs.querySelector('.tab-content');
            if (!btnRow || !content) return;
            let btn = btnRow.querySelector('[data-tab="tab-combat"]');
            let pane = document.getElementById('tab-combat');
            if (!btn) {
                btn = document.createElement('button');
                btn.className = 'rp-tab-btn';
                btn.setAttribute('data-tab', 'tab-combat');
                btn.textContent = 'Combat';
                btnRow.insertBefore(btn, btnRow.firstChild); // put Combat first
                // wire click like others
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.right-tabs .rp-tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.right-tabs .rp-tab-pane').forEach(p => p.classList.remove('active'));
                    btn.classList.add('active');
                    const pane = document.getElementById('tab-combat');
                    if (pane) pane.classList.add('active');
                    this.ensureRightPanelScrollable();
                });
            }
            if (!pane) {
                pane = document.createElement('div');
                pane.className = 'rp-tab-pane';
                pane.id = 'tab-combat';
                pane.innerHTML = '<div class="placeholder">Combat log</div>';
                content.insertBefore(pane, content.firstChild);
            }
        } catch (e) { /* ignore */ }
    }

    // Remove the 'Combat' tab from the right panel
    removeCombatTab() {
        try {
            const tabs = document.querySelector('.right-tabs');
            if (!tabs) return;
            const btnRow = tabs.querySelector('.tab-buttons');
            const content = tabs.querySelector('.tab-content');
            if (!btnRow || !content) return;
            
            const btn = btnRow.querySelector('[data-tab="tab-combat"]');
            const pane = document.getElementById('tab-combat');
            
            // If the combat tab is currently active, switch to Character tab
            const wasActive = btn && btn.classList.contains('active');
            
            // Remove the button and pane
            if (btn) btn.remove();
            if (pane) pane.remove();
            
            // If combat tab was active, activate the Character tab
            if (wasActive) {
                this.activateRightPanelTab('tab-character');
            }
        } catch (e) {
            console.warn('Failed to remove combat tab:', e);
        }
    }

    // Programmatically activate a right panel tab
    activateRightPanelTab(tabId) {
        const btn = document.querySelector(`.right-tabs .rp-tab-btn[data-tab="${tabId}"]`);
        const pane = document.getElementById(tabId);
        if (!btn || !pane) return;
        document.querySelectorAll('.right-tabs .rp-tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.right-tabs .rp-tab-pane').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        pane.classList.add('active');
        this.ensureRightPanelScrollable();
    }

    // Update combat log HTML content
    setCombatLogHtml(html) {
        this.ensureCombatTab();
        const pane = document.getElementById('tab-combat');
        if (pane) {
            pane.innerHTML = html || '<div class="placeholder">Combat log</div>';
            // After snapshot replace, keep pane scrollable and pinned to bottom
            this.ensureRightPanelScrollable();
            this.scrollElementToBottom(pane);
        }
    }

    // Append a single mechanics/log line to the Combat tab and autoscroll
    appendCombatLogLine(data) {
        try {
            this.ensureCombatTab();
            const pane = document.getElementById('tab-combat');
            if (!pane) return;
            // Remove placeholder if present
            const ph = pane.querySelector('.placeholder');
            if (ph) { try { ph.remove(); } catch (e) {}
            }
            const div = document.createElement('div');
            const text = (data && typeof data.text === 'string') ? data.text : '';
            const cls = this.classifyCombatLogLine(text, data && data.step, data && data.kind, data && data.role);
            div.className = `combat-log-line ${cls}`.trim();
            if (data && typeof data.html === 'string' && data.html.trim()) {
                div.innerHTML = data.html;
            } else {
                // Escape and inject text
                const esc = (t)=> String(t).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
                div.innerHTML = esc(text);
            }
            pane.appendChild(div);
            this.ensureRightPanelScrollable();
            this.scrollElementToBottom(pane);
        } catch (e) { console.warn('appendCombatLogLine failed', e); }
    }

    // Heuristic classification to mimic loaded log colors/styles
    classifyCombatLogLine(text, step=null, kind=null, role=null) {
        try {
            const t = (text||'').trim();
            const low = t.toLowerCase();
            // Hard markers
            if (t.startsWith('Round ') && t.endsWith('begins!')) return 'cl-round';
            if (t.startsWith('Turn order:')) return 'cl-turnorder';
            if (t.startsWith('It is now')) return 'cl-turn';
            if (t.startsWith('Combat started')) return 'cl-round';
            // Content markers
            if (low.includes(' recovers ') || low.includes('regains')) return 'cl-heal';
            if (low.includes('takes') && low.includes('damage')) return 'cl-damage';
            if (low.includes('misses')) return 'cl-miss';
            if (low.includes('attacks') || low.includes('attack')) return 'cl-attack';
            if (low.includes('status effect') || low.includes('worn off')) return 'cl-status';
            if (low.includes('defend') || low.includes('braces')) return 'cl-defend';
            if (low.startsWith('entity ') && low.includes('stamina')) return 'cl-heal';
            // Step-based hint
            if (typeof step === 'string') {
                const s = step.toUpperCase();
                if (s.includes('ADVANCING_TURN')) return 'cl-turn';
                if (s.includes('APPLYING_STATUS_EFFECTS')) return 'cl-status';
            }
            return 'cl-generic';
        } catch { return 'cl-generic'; }
    }

    attachCharacterTabHandlers() {
        const charPane = document.getElementById('tab-character');
        if (!charPane) return;
        // Stat tooltips on right-click
        charPane.querySelectorAll('.stat-row').forEach(row => {
            row.addEventListener('contextmenu', async (e) => {
                e.preventDefault();
                const key = row.getAttribute('data-stat-key');
                if (!key) return;
                const base = Number(row.getAttribute('data-stat-base')||0);
                const val = Number(row.getAttribute('data-stat-value')||0);
                const delta = Math.round(val - base);
                const sign = delta>0?'+':'';
                const color = delta>0?'#69c45f':(delta<0?'#c45f5f':'#cccccc');
                try {
                    const data = await apiClient.getStatModifiers(key);
                    const lines = (data.modifiers||[]).map(m => {
                        const mv = Number(m.value||0);
                        const ms = mv>0?'+':'';
                        const mc = mv>0?'#69c45f':(mv<0?'#c45f5f':'#cccccc');
                        const perc = m.is_percentage?'%':'';
                        const dur = (m.duration!=null)?` (${m.duration} turns)`:'';
                        const source = m.source || m.source_name || 'Source';
                        return `${source}: <span style="color:${mc}">${ms}${mv}${perc}</span>${dur}`;
                    });
                    const header = `<b>${key}</b><hr>Base: ${Math.round(base)}<br>Total: ${Math.round(val)}${delta!==0?` <span style=\"color:${color}\">(${sign}${delta})</span>`:''}<br><br><b>Modifiers:</b><br>`;
                    this.showTemporaryTooltip(e.pageX, e.pageY, header + (lines.length?lines.join('<br>'):'No active modifiers.'));
                } catch (err) {
                    const header = `<b>${key}</b><hr>Base: ${Math.round(base)}<br>Total: ${Math.round(val)}${delta!==0?` <span style=\"color:${color}\">(${sign}${delta})</span>`:''}<br>`;
                    this.showTemporaryTooltip(e.pageX, e.pageY, header + '<br>Failed to load modifiers.');
                }
            });
        });
        // Equipment context menu on right-click
        charPane.querySelectorAll('.equip-item').forEach(el => {
            el.addEventListener('contextmenu', (ev) => {
                ev.preventDefault();
                const slot = el.getAttribute('data-slot');
                const itemId = el.getAttribute('data-item-id');
                const items = [];
                if (itemId) {
                    items.push({label: 'Unequip', action: async ()=>{ try{ await apiClient.unequip(slot||itemId); await this.refreshUI(); } catch(e){ this.showNotification('Unequip failed','error'); } }});
                    items.push({label: 'Item Info', action: ()=>{ this.showNotification('Item info not implemented yet','info'); }});
                    items.push({label: 'Drop', action: async ()=>{ try{ await apiClient.unequip(slot||itemId); await apiClient.dropItem(itemId); await this.refreshUI(); } catch(e){ this.showNotification('Drop failed','error'); } }});
                } else {
                    items.push({label: 'Empty Slot', action: ()=>{}});
                }
                this.showContextMenu(ev.pageX, ev.pageY, items);
            });
        });
    }

    renderJournalPane(ui) {
        const jPane = document.getElementById('tab-journal');
        if (!jPane) return;
        const j = ui.journal || {};
        const quests = j.quests || {};
        const ids = Object.keys(quests);
        // Selected quest tracking
        if (!this._selectedQuestId || !quests[this._selectedQuestId]) {
            this._selectedQuestId = ids.length ? ids[0] : null;
        }
        const selected = this._selectedQuestId ? quests[this._selectedQuestId] : null;
        // Build left quest list
        const listHtml = ids.map(qid => {
            const q = quests[qid] || {}; const active = qid===this._selectedQuestId ? ' style="font-weight:bold;"' : '';
            const status = (q.status||'').toString();
            return `<div class="rp-row" data-quest-id="${qid}"><span${active}>${q.name||qid}</span><span>${status}</span></div>`;
        }).join('');
        // Build right detail
        let objHtml = '';
        if (selected && Array.isArray(selected.objectives)) {
            objHtml = selected.objectives.map(o=>{
                const c = o.completed? 'checked' : '';
                const f = o.failed? 'checked' : '';
                return `<div class="rp-row">
                    <span>${o.text||o.description||o.name||o.id}</span>
                    <span>
                        <label style="margin-right:8px;"><input type="checkbox" class="obj-complete" data-quest-id="${selected.id||this._selectedQuestId}" data-obj-id="${o.id}" ${c}> Completed</label>
                        <label><input type="checkbox" class="obj-fail" data-quest-id="${selected.id||this._selectedQuestId}" data-obj-id="${o.id}" ${f}> Failed</label>
                    </span>
                </div>`;
            }).join('');
        } else {
            objHtml = '<div class="rp-empty">No objectives</div>';
        }
        const charText = (j.character||'').toString();
        const notes = Array.isArray(j.notes)? j.notes : [];
        const notesList = notes.map(n=>`<div class=\"rp-row\"><span>${(n.text||'').toString().replace(/</g,'&lt;')}</span><span><button class=\"cancel-btn\" data-del-note=\"${n.id}\">Delete</button></span></div>`).join('');
        jPane.innerHTML = `
            <div class="rp-columns">
                <div class="rp-col">
                    <div class="rp-group"><div class="rp-title">Quests</div>${listHtml||'<div class="rp-empty">—</div>'}</div>
                </div>
                <div class="rp-col">
                    <div class="rp-group"><div class="rp-title">Character Notes</div>
                        <textarea id="journal-character-text" rows="5" style="width:100%">${charText.replace(/</g,'&lt;')}</textarea>
                        <div style="text-align:right; margin-top:6px;"><button id="journal-save-character" class="primary-btn">Save</button></div>
                    </div>
                    <div class="rp-group"><div class="rp-title">Notes</div>
                        <div>${notesList || '<div class=\"rp-empty\">No notes</div>'}</div>
                        <div style="display:flex; gap:6px; margin-top:6px;"><input type="text" id="journal-new-note" placeholder="Add a note..." style="flex:1;"><button id="journal-add-note" class="primary-btn">Add</button></div>
                    </div>
                    <div class="rp-group"><div class="rp-title">${selected?(selected.name||selected.id||'Quest'): 'Quest Details'}</div>
                        ${selected?`<div class="rp-row"><span>Status</span><span>${selected.status||''}</span></div>`:''}
                        <div class="rp-subtitle">Objectives</div>
                        ${objHtml}
                        ${selected?`<div style="text-align:right; margin-top:6px;"><button id="journal-abandon" class="cancel-btn" data-quest-id="${selected.id||this._selectedQuestId}">Abandon Quest</button></div>`:''}
                    </div>
                </div>
            </div>`;
        // Attach handlers
        jPane.querySelectorAll('.rp-row[data-quest-id]').forEach(row=>{
            row.addEventListener('click', ()=>{ this._selectedQuestId = row.getAttribute('data-quest-id'); this.renderJournalPane(ui); });
        });
        const saveBtn = jPane.querySelector('#journal-save-character');
        if (saveBtn) saveBtn.addEventListener('click', async ()=>{
            try { await apiClient.updateJournalCharacter(document.getElementById('journal-character-text').value||''); this.showNotification('Character notes saved','success'); } catch(e){ this.showNotification('Save failed','error'); }
        });
        jPane.querySelectorAll('.obj-complete, .obj-fail').forEach(cb=>{
            cb.addEventListener('change', async ()=>{
                const questId = cb.getAttribute('data-quest-id');
                const objId = cb.getAttribute('data-obj-id');
                const completed = jPane.querySelector(`.obj-complete[data-quest-id="${questId}"][data-obj-id="${objId}"]`).checked;
                const failed = jPane.querySelector(`.obj-fail[data-quest-id="${questId}"][data-obj-id="${objId}"]`).checked;
                try { await apiClient.updateObjectiveStatus(questId, objId, { completed, failed }); } catch(e){ this.showNotification('Update failed','error'); }
            });
        });
        const abandonBtn = jPane.querySelector('#journal-abandon');
        if (abandonBtn) abandonBtn.addEventListener('click', async ()=>{
            const qid = abandonBtn.getAttribute('data-quest-id');
            try { await apiClient.abandonQuest(qid); this.showNotification('Quest abandoned','info'); } catch(e){ this.showNotification('Abandon failed','error'); }
        });
        const addBtn = jPane.querySelector('#journal-add-note');
        if (addBtn) addBtn.addEventListener('click', async ()=>{
            const inp = jPane.querySelector('#journal-new-note');
            const text = (inp && inp.value || '').trim();
            if (!text) return;
            try { await apiClient.addJournalNote(text); inp.value=''; } catch(e){ this.showNotification('Add note failed','error'); }
        });
        jPane.querySelectorAll('button[data-del-note]').forEach(btn=>{
            btn.addEventListener('click', async ()=>{
                const id = btn.getAttribute('data-del-note');
                try { await apiClient.deleteJournalNote(id); } catch(e){ this.showNotification('Delete note failed','error'); }
            });
        });
    }

    showTemporaryTooltip(x, y, html) {
        const tip = document.createElement('div');
        tip.className = 'ui-tooltip';
        tip.innerHTML = html;
        Object.assign(tip.style, { position:'absolute', left:`${x}px`, top:`${y}px`, zIndex:10000, background:'#222', color:'#eee', border:'1px solid #555', borderRadius:'4px', padding:'8px', maxWidth:'280px' });
        document.body.appendChild(tip);
        setTimeout(()=>{ if (tip.parentNode) tip.parentNode.removeChild(tip); }, 2000);
    }

    showContextMenu(x, y, items) {
        const existing = document.getElementById('ui-context-menu');
        if (existing) existing.remove();
        const menu = document.createElement('div');
        menu.id = 'ui-context-menu';
        menu.className = 'ui-context-menu';
        Object.assign(menu.style, { position:'absolute', left:`${x}px`, top:`${y}px`, zIndex:10001, background:'#2b2b2b', color:'#e0e0e0', border:'1px solid #3a3a3a', borderRadius:'4px', minWidth:'160px' });
        (items||[]).forEach(it => {
            const a = document.createElement('div');
            a.textContent = it.label || '';
            Object.assign(a.style, { padding:'6px 12px', cursor:'pointer' });
            a.addEventListener('mouseover', ()=>{ a.style.background='#3a3a3a'; });
            a.addEventListener('mouseout', ()=>{ a.style.background='transparent'; });
            a.addEventListener('click', ()=>{ try{ it.action && it.action(); } finally { menu.remove(); } });
            menu.appendChild(a);
        });
        document.body.appendChild(menu);
        const close = ()=>{ if (menu.parentNode) menu.parentNode.removeChild(menu); document.removeEventListener('click', close); };
        setTimeout(()=>{ document.addEventListener('click', close); }, 0);
    }

    async renderInventoryPane() {
        const invPane = document.getElementById('tab-inventory');
        try {
            const inv = await apiClient.getInventory();
            const items = inv.items||[];
            const money = inv.currency||{};
            
            // Currency display
            const header = `<div class="currency-section">
                <div class="currency-grid">
                    <div class="currency-item currency-gold">
                        <div class="currency-label">Gold</div>
                        <div class="currency-value">${money.gold||0}</div>
                    </div>
                    <div class="currency-item currency-silver">
                        <div class="currency-label">Silver</div>
                        <div class="currency-value">${money.silver||0}</div>
                    </div>
                    <div class="currency-item currency-copper">
                        <div class="currency-label">Copper</div>
                        <div class="currency-value">${money.copper||0}</div>
                    </div>
                </div>
            </div>`;
            
            // Weight display
            const currentWeight = inv.weight?.current||0;
            const maxWeight = inv.weight?.max||1;
            const overLimit = currentWeight > maxWeight ? ' over-limit' : '';
            const weight = `<div class="weight-section">
                <div class="weight-label">Encumbrance</div>
                <div class="weight-value${overLimit}">${currentWeight.toFixed(1)} / ${maxWeight.toFixed(1)}</div>
            </div>`;
            
            // Filter controls
            const currentType = this._invFilterType || 'All';
            const currentSearch = this._invFilterSearch || '';
            const types = Array.from(new Set(items.map(i => (i.type||'miscellaneous').toLowerCase()))).sort();
            const typeOptions = ['All', ...types].map(t => `<option value="${t}" ${t===currentType?'selected':''}>${t.charAt(0).toUpperCase()+t.slice(1)}</option>`).join('');
            const filters = `<div class="rp-group"><div class="rp-title">Filters</div>
                <div class="rp-row"><span>Type</span><span><select id="inv-filter-type">${typeOptions}</select></span></div>
                <div class="rp-row"><span>Search</span><span><input id="inv-filter-search" type="text" value="${currentSearch.replace(/"/g,'&quot;')}" placeholder="Item name..."></span></div>
            </div>`;
            
            // Apply filters
            const filteredItems = items.filter(it => {
                const matchType = (currentType==='All') || ((it.type||'').toLowerCase()===currentType.toLowerCase());
                const matchName = !currentSearch || (it.name||'').toLowerCase().includes(currentSearch.toLowerCase());
                return matchType && matchName;
            });
            
            // Render grid
            const gridCells = filteredItems.map(it=>{
                const rarity = (it.rarity||'common').toLowerCase();
                const iconPath = it.icon_path || '/images/icons/miscellaneous/generic_1.png';
                const count = it.quantity > 1 ? it.quantity : (it.count || 0);
                const stackHtml = count > 1 ? `<span class="item-stack-count">x${count}</span>` : '';
                const questHtml = it.is_quest_item ? `<span class="item-quest-marker">★</span>` : '';
                const equippedHtml = it.equipped ? `<span class="item-equipped-marker">✓</span>` : '';
                
                // Durability badge
                let durabilityHtml = '';
                if (it.durability != null && it.current_durability != null) {
                    const pct = (it.current_durability / it.durability) * 100;
                    const durClass = pct < 25 ? 'low' : pct < 60 ? 'medium' : 'high';
                    durabilityHtml = `<span class="item-durability-badge ${durClass}">${Math.round(pct)}%</span>`;
                }
                
                return `<div class="inventory-cell" 
                            data-id="${it.id}" 
                            data-rarity="${rarity}"
                            data-type="${it.type||'miscellaneous'}"
                            title="${it.name}">
                    <img src="${iconPath}" class="inventory-cell-icon" alt="${it.name}" onerror="this.src='/images/icons/miscellaneous/generic_1.png'">
                    <div class="item-overlay">
                        ${equippedHtml}
                        ${questHtml}
                        ${durabilityHtml}
                        ${stackHtml}
                    </div>
                </div>`;
            }).join('');
            
            const gridHtml = `<div class="inventory-grid-container">
                <div class="inventory-grid">${gridCells || '<div class="rp-empty">No items</div>'}</div>
            </div>`;
            
            invPane.innerHTML = header + weight + filters + gridHtml;
            
            // Attach filter handlers
            const typeSel = invPane.querySelector('#inv-filter-type');
            const searchInp = invPane.querySelector('#inv-filter-search');
            if (typeSel) typeSel.addEventListener('change', ()=>{ this._invFilterType = typeSel.value; this.renderInventoryPane(); });
            if (searchInp) searchInp.addEventListener('input', ()=>{ this._invFilterSearch = searchInp.value||''; this.renderInventoryPane(); });
            
            // Attach click handlers to cells
            invPane.querySelectorAll('.inventory-cell').forEach(cell=>{
                cell.addEventListener('click', async () => {
                    const id = cell.getAttribute('data-id');
                    await this.showItemInfo(id);
                });
                
                // Right-click for context menu (future: equip/drop options)
                cell.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const id = cell.getAttribute('data-id');
                    this.showItemContextMenu(e.pageX, e.pageY, id, items.find(i => i.id === id));
                });
            });
        } catch (e) {
            console.error('Inventory render error:', e);
            invPane.innerHTML = `<div class="rp-empty">Failed to load inventory</div>`;
        }
    }
    
    renderPaperdoll(ui) {
        // Determine silhouette path based on race and gender
        const race = (ui.player.race || 'human').toLowerCase();
        const gender = (ui.player.sex || ui.player.gender || 'male').toLowerCase();
        
        // Try race-specific, fallback to default, then to generic default
        const silhouettePath = `/images/character/paperdoll/${race}_${gender}.png`;
        const fallbackPath = `/images/character/paperdoll/default_${gender}.png`;
        const finalFallback = `/images/character/paperdoll/default_male.png`;
        
        // Build equipment map
        const eqMap = {};
        console.log('=== PAPERDOLL DEBUG ===');
        console.log('ui.equipment array:', ui.equipment);
        (ui.equipment||[]).forEach(e=>{ 
            const slotKey = e.slot ? e.slot.toUpperCase() : '';
            console.log(`Mapping: slot="${e.slot}" -> key="${slotKey}" | item="${e.item_name}" | icon="${e.icon_path}"`);
            eqMap[slotKey] = e; 
        });
        console.log('Final equipment map:', eqMap);
        console.log('Checking CHEST slot:', eqMap['CHEST']);
        console.log('Checking MAIN_HAND slot:', eqMap['MAIN_HAND']);
        
        // Define all equipment slots
        const allSlots = [
            'HEAD', 'NECK', 'SHOULDERS', 'CHEST', 'BACK', 'WRISTS', 'HANDS', 'WAIST', 'LEGS', 'FEET',
            'MAIN_HAND', 'OFF_HAND', 'RANGED',
            'FINGER_1', 'FINGER_2', 'FINGER_3', 'FINGER_4', 'FINGER_5',
            'FINGER_6', 'FINGER_7', 'FINGER_8', 'FINGER_9', 'FINGER_10',
            'TRINKET_1', 'TRINKET_2'
        ];
        
        const slotsHtml = allSlots.map(slot => {
            const eq = eqMap[slot];
            const hasItem = eq && eq.item_id;
            // Fallback to generic icon if icon_path is missing
            const iconPath = (eq && eq.icon_path) ? eq.icon_path : '/images/icons/miscellaneous/generic_1.png';
            const rarity = eq && eq.rarity ? eq.rarity.toLowerCase() : 'common';
            const itemName = eq && eq.item_name ? eq.item_name : '';
            const slotDisplay = slot.replace(/_/g, ' ').toLowerCase().replace(/(^|\s)\S/g, t => t.toUpperCase());
            
            return `<div class=\"equipment-slot ${hasItem ? 'has-item' : 'empty'}\" 
                        data-slot=\"${slot.toLowerCase()}\" 
                        data-rarity=\"${rarity}\"
                        ${hasItem ? `data-item-id=\"${eq.item_id}\"` : ''}>
                ${hasItem ? `<img src=\"${iconPath}\" class=\"equipment-slot-icon\" alt=\"${itemName}\" onerror=\"this.src='/images/icons/miscellaneous/generic_1.png'\">` : ''}
                <div class=\"equipment-slot-label\">${hasItem ? itemName : slotDisplay}</div>
            </div>`;
        }).join('');
        
        return `<div class="rp-group">
            <div class="rp-title">Equipment</div>
            <div class="paperdoll-container">
                <div class="paperdoll-wrapper">
                    <img src="${silhouettePath}" 
                         class="paperdoll-silhouette" 
                         alt="Character" 
                         style="display:none;" 
                         onload="this.style.display='block';" 
                         onerror="this.style.display='none';this.onerror=null;"
                    <div class="paperdoll-slots">
                        ${slotsHtml}
                    </div>
                </div>
                <div class="paperdoll-info">
                    <div class="paperdoll-race-class">${ui.player.race} ${ui.player.path}</div>
                    <div>Click slots to manage equipment</div>
                </div>
            </div>
        </div>`;
    }
    
    attachPaperdollHandlers() {
        const charPane = document.getElementById('tab-character');
        if (!charPane) return;
        
        charPane.querySelectorAll('.equipment-slot').forEach(slot => {
            slot.addEventListener('click', async () => {
                const slotName = slot.getAttribute('data-slot');
                const itemId = slot.getAttribute('data-item-id');
                
                if (itemId) {
                    // Slot has item - show item info
                    await this.showItemInfo(itemId);
                } else {
                    // Empty slot - show notification
                    const slotDisplay = slotName.replace(/_/g, ' ').toUpperCase();
                    this.showNotification(`${slotDisplay} slot is empty`, 'info', 2000);
                }
            });
            
            // Right-click for context menu
            slot.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const slotName = slot.getAttribute('data-slot');
                const itemId = slot.getAttribute('data-item-id');
                
                if (itemId) {
                    this.showEquipmentSlotContextMenu(e.pageX, e.pageY, slotName, itemId);
                } else {
                    this.showNotification('Slot is empty', 'info', 1500);
                }
            });
        });
    }
    
    showEquipmentSlotContextMenu(x, y, slotName, itemId) {
        const menuItems = [
            { label: '📖 Examine', action: () => this.showItemInfo(itemId) },
            { label: '✖ Unequip', action: async () => {
                try {
                    // Unequip by slot name for reliability
                    await apiClient.unequip(slotName);
                    await this.refreshUI();
                    this.showNotification('Item unequipped', 'success');
                } catch(e) {
                    this.showNotification(e.message || 'Failed to unequip', 'error');
                }
            }}
        ];
        
        this.showContextMenu(x, y, menuItems);
    }
    
    showItemContextMenu(x, y, itemId, item) {
        if (!item) return;
        
        const menuItems = [
            { label: '📖 Examine', action: () => this.showItemInfo(itemId) }
        ];
        
        // Add equip/unequip option
        if (item.is_equippable || ['weapon','armor','shield','accessory'].includes((item.type||'').toLowerCase())) {
            if (item.equipped) {
                menuItems.push({ label: '✖ Unequip', action: async () => {
                    try {
                        await apiClient.unequip(itemId);
                        await this.refreshUI();
                    } catch(e) { this.showNotification(e.message||'Failed to unequip','error'); }
                }});
            } else {
                menuItems.push({ label: '✓ Equip', action: async () => {
                    try {
                        await apiClient.equipItem(itemId);
                        await this.refreshUI();
                    } catch(e) { this.showNotification(e.message||'Failed to equip','error'); }
                }});
            }
        }
        
        // Add use option for consumables
        if (item.is_consumable || (item.type||'').toLowerCase() === 'consumable') {
            menuItems.push({ label: '🍴 Use', action: async () => {
                try {
                    await apiClient.useItem(itemId);
                    await this.refreshUI();
                } catch(e) { this.showNotification(e.message||'Failed to use','error'); }
            }});
        }
        
        // Add drop option
        menuItems.push({ label: '🗑 Drop', action: async () => {
            try {
                await apiClient.dropItem(itemId);
                await this.refreshUI();
            } catch(e) { this.showNotification(e.message||'Failed to drop','error'); }
        }});
        
        this.showContextMenu(x, y, menuItems);
    }

    /** Update resource bar label/width for Phase 1 (preview) */
    updateResourceBarPhase1(barTypeKey, update) {
        const map = { hp:'health', stamina:'stamina', mana:'mana', resolve:'resolve', mp:'mana' };
        const key = map[String(barTypeKey||'').toLowerCase()] || barTypeKey;
        const titleEl = document.querySelector(`.rp-bar-title[data-bar-type="${key}"]`);
        const fillEl = document.querySelector(`.rp-bar-fill[data-bar-type="${key}"]`);
        if (!titleEl || !fillEl) return;
        const max = update.max_value!=null ? parseInt(update.max_value,10) : 0;
        const cur = update.new_value_preview!=null ? parseInt(update.new_value_preview,10) : 0;
        const barName = key.charAt(0).toUpperCase()+key.slice(1);
        titleEl.textContent = `${barName}: ${cur}/${max}`;
        const pct = max? Math.min(100, (cur/max)*100) : 0;
        fillEl.style.width = `${pct}%`;
    }

    /** Update resource bar label/width for Phase 2 (finalize) */
    updateResourceBarPhase2(barTypeKey, update) {
        const map = { hp:'health', stamina:'stamina', mana:'mana', resolve:'resolve', mp:'mana' };
        const key = map[String(barTypeKey||'').toLowerCase()] || barTypeKey;
        const titleEl = document.querySelector(`.rp-bar-title[data-bar-type="${key}"]`);
        const fillEl = document.querySelector(`.rp-bar-fill[data-bar-type="${key}"]`);
        if (!titleEl || !fillEl) return;
        const max = update.max_value!=null ? parseInt(update.max_value,10) : 0;
        const cur = update.final_new_value!=null ? parseInt(update.final_new_value,10) : 0;
        const barName = key.charAt(0).toUpperCase()+key.slice(1);
        titleEl.textContent = `${barName}: ${cur}/${max}`;
        const pct = max? Math.min(100, (cur/max)*100) : 0;
        fillEl.style.width = `${pct}%`;
    }

    async showItemInfo(itemId) {
        try {
            const data = await (async ()=>{
                const resp = await fetch(apiClient.buildUrl(`items/${apiClient.sessionId}/${encodeURIComponent(itemId)}`), { headers: apiClient.getHeaders() });
                if (!resp.ok) throw new Error('Failed to fetch item details');
                return await resp.json();
            })();
            // Populate modal
            const modal = document.getElementById('item-info-modal');
            const body = document.getElementById('item-info-body');
            if (!modal || !body) { this.showNotification('Item info UI not available','error'); return; }
            const rows = [];
            const esc = (t)=> (t==null?'' : String(t)).replace(/</g,'&lt;');
            rows.push(`<div class=\"rp-row\"><span><b>Type</b></span><span>${esc(data.item_type)}</span></div>`);
            if (data.description) rows.push(`<div class=\"rp-row\"><span><b>Description</b></span><span>${esc(data.description)}</span></div>`);
            rows.push(`<div class=\"rp-row\"><span><b>Weight</b></span><span>${data.weight!=null?data.weight:'?'}</span></div>`);
            rows.push(`<div class=\"rp-row\"><span><b>Value</b></span><span>${data.value!=null?data.value:'?'}</span></div>`);
            rows.push(`<div class=\"rp-row\"><span><b>Quantity</b></span><span>${data.quantity||1}</span></div>`);
            if (data.durability!=null || data.current_durability!=null) rows.push(`<div class=\"rp-row\"><span><b>Durability</b></span><span>${data.current_durability!=null?data.current_durability:'?'} / ${data.durability!=null?data.durability:'?'}</span></div>`);
            if (Array.isArray(data.equip_slots) && data.equip_slots.length>0) rows.push(`<div class=\"rp-row\"><span><b>Equip Slots</b></span><span>${data.equip_slots.map(s=>esc(s.replace(/_/g,' '))).join(', ')}</span></div>`);
            // Stats
            if (Array.isArray(data.stats) && data.stats.length>0) {
                const srows = data.stats.map(s=>`<li>${esc(s.display_name||s.name)}: ${s.value}${s.is_percentage?'%':''}</li>`).join('');
                rows.push(`<div class=\"rp-subtitle\">Stats & Effects</div><ul>${srows}</ul>`);
            }
            // Custom props
            const keys = Object.keys(data.custom_properties||{});
            if (keys.length>0) {
                const plist = keys.map(k=>`<li><b>${esc(k.replace(/_/g,' '))}:</b> ${esc(data.custom_properties[k])}</li>`).join('');
                rows.push(`<div class=\"rp-subtitle\">Properties</div><ul>${plist}</ul>`);
            }
            // Tags
            if (Array.isArray(data.tags) && data.tags.length>0) rows.push(`<div class=\"rp-row\"><span><b>Tags</b></span><span>${data.tags.map(esc).join(', ')}</span></div>`);
            body.innerHTML = `<h3>${esc(data.name||'Item')}</h3>` + rows.join('');
            this.openModal('itemInfo');
        } catch (e) {
            console.error('Item info error', e);
            this.showNotification('Failed to load item info','error');
        }
    }

    /** Refresh UI: fetch UI state and render panels + status bar */
    async refreshUI() {
        try {
            const ui = await apiClient.getUIState();
            // Normalize mode value from server
            let modeRaw = ui.mode;
            let modeStr = '';
            try { modeStr = String(modeRaw || '').toUpperCase(); } catch { modeStr = ''; }
            const inCombat = modeStr.includes('COMBAT');
            
            // Handle combat mode changes
            if (inCombat) {
                // Entering or staying in combat - ensure combat tab exists
                this.ensureCombatTab();
                if (!this._autoCombatShown || this._prevMode !== 'COMBAT') {
                    this.activateRightPanelTab('tab-combat');
                    this._autoCombatShown = true;
                }
            } else if (this._prevMode === 'COMBAT') {
                // Exiting combat - remove combat tab
                this.removeCombatTab();
                this._autoCombatShown = false;
            }
            
            // Update previous mode for next comparison
            this._prevMode = inCombat ? 'COMBAT' : modeStr;
            
            // Status bar
            const locEl = document.getElementById('current-location');
            const timeEl = document.getElementById('game-time');
            const calEl = document.getElementById('game-calendar');
            const pName = document.getElementById('player-name');
            const pLvl = document.getElementById('player-level');
            if (locEl) locEl.textContent = ui.location||'-';
            if (timeEl) {
                const t = ui.time||'-';
                const capitalizedTime = t === '-' ? t : t.charAt(0).toUpperCase() + t.slice(1);

                if (calEl) {
                    timeEl.textContent = capitalizedTime;
                    const calVal = (ui && (ui.calendar || (ui.state && ui.state.calendar))) || '';
                    calEl.textContent = calVal;
                } else {
                    const calVal = (ui && (ui.calendar || (ui.state && ui.state.calendar))) || '';
                    // Fallback: append calendar after time if dedicated element missing
                    const cal = calVal ? ` | ${calVal}` : '';
                    timeEl.textContent = `${capitalizedTime}${cal}`;
                }
            }
            if (pName) pName.textContent = ui.player.name||'-';
            if (pLvl) pLvl.textContent = ui.player.level||'1';
            
            // Render right panel content
            this.renderRightPanel(ui);
            // Ensure center output remains scrollable and pinned
            this.ensureCenterOutputScrollable();
        } catch (e) {
            console.warn('refreshUI failed', e);
        }
    }

    /**
     * Load background list from server and apply the first available (to mirror Py GUI default).
     */
    async applyBackgroundFromServer() {
        try {
            const saved = localStorage.getItem('rpg_bg_filename');
            if (saved) {
                document.body.style.setProperty('--bg-image-url', `url("/images/gui/background/${saved}")`);
                document.body.classList.add('has-bg');
                return;
            }
        } catch (e) { /* ignore */ }
        try {
            const resp = await fetch('/api/ui/backgrounds');
            if (!resp.ok) return;
            const data = await resp.json();
            if (data && Array.isArray(data.backgrounds) && data.backgrounds.length > 0) {
                const filename = data.backgrounds[0];
                document.body.style.setProperty('--bg-image-url', `url("/images/gui/background/${filename}")`);
                document.body.classList.add('has-bg');
            }
        } catch (e) {
            console.warn('Failed to apply background from server:', e);
        }
    }

    /**
     * Apply font size to the output area
     * @param {string} size - Font size in pixels
     */
    applyFontSize(size) {
        this.outputElement.style.fontSize = `${size}px`;
        this.settings.fontSize = size;

        // Update font size slider if it exists
        const fontSizeSlider = document.getElementById('font-size-slider');
        if (fontSizeSlider) {
            fontSizeSlider.value = size;
        }

        const fontSizeValue = document.getElementById('font-size-value');
        if (fontSizeValue) {
            fontSizeValue.textContent = `${size}px`;
        }

        localStorage.setItem('rpg_font_size', size);
    }

    /**
     * Switch to a different tab in the settings modal
     * @param {string} tabId - The ID of the tab to switch to
     */
    switchTab(tabId) {
        // Deactivate all tabs
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });

        // Activate the target tab
        document.querySelector(`.tab-btn[data-tab="${tabId}"]`).classList.add('active');
        document.getElementById(tabId).classList.add('active');
    }

    /**
     * Toggle password field visibility
     * @param {string} inputId - The ID of the password input field
     * @param {HTMLElement} button - The button element that toggles visibility
     */
    togglePasswordVisibility(inputId, button) {
        const input = document.getElementById(inputId);
        const icon = button.querySelector('i');

        if (input.type === 'password') {
            input.type = 'text';
            icon.className = 'fas fa-eye-slash';
        } else {
            input.type = 'password';
            icon.className = 'fas fa-eye';
        }
    }

    /**
     * Reset agent settings to default values
     */
    resetAgentSettingsToDefault() {
        console.log('Resetting agent settings to defaults');

        // Default settings for each agent
        const defaultSettings = {
            'narrator': {
                provider: 'OPENAI',
                model: 'gpt-4o-mini', 
                temperature: 0.7,
                enabled: true
            },
            'rule-checker': {
                provider: 'GOOGLE',
                model: 'gemini-2.0-flash', 
                temperature: 0.3,
                enabled: true
            },
            'context-evaluator': {
                provider: 'GOOGLE',
                model: 'gemini-2.0-flash', 
                temperature: 0.2,
                enabled: true
            }
        };

        // Apply default settings to UI
        for (const [agent, settings] of Object.entries(defaultSettings)) {
            console.log(`Applying default settings for ${agent}`);

            // Set provider
            const providerSelect = document.getElementById(`${agent}-provider`);
            if (providerSelect) {
                providerSelect.value = settings.provider;

                // Update the model dropdown first
                this.updateModelOptionsForAgent(agent, settings.provider);

                // Give time for the model options to update
                setTimeout(() => {
                    // Try to find the model select - it should exist now after updateModelOptionsForAgent
                    const modelSelect = document.getElementById(`${agent}-model`);
                    if (!modelSelect || modelSelect.tagName !== 'SELECT') { // Ensure it's a select
                        console.error(`Model select not found or not a SELECT for ${agent} after updateModelOptionsForAgent`);
                        return;
                    }

                    // Set model value
                    // For selecting options, first check if the desired value exists
                    let optionExists = false;
                    for (let i = 0; i < modelSelect.options.length; i++) {
                        if (modelSelect.options[i].value === settings.model) {
                            optionExists = true;
                            modelSelect.selectedIndex = i;
                            break;
                        }
                    }

                    // If option doesn't exist, select the first one
                    if (!optionExists && modelSelect.options.length > 0) {
                        console.warn(`Default model ${settings.model} not found for ${agent}, selecting first option.`);
                        modelSelect.selectedIndex = 0;
                    }

                    // Set temperature
                    const tempSlider = document.getElementById(`${agent}-temperature`);
                    const tempValue = document.getElementById(`${agent}-temperature-value`);
                    if (tempSlider) {
                        tempSlider.value = settings.temperature;
                        if (tempValue) {
                            tempValue.textContent = settings.temperature;
                        }
                    }

                    // Set enabled state
                    const enabledToggle = document.getElementById(`${agent}-enabled-toggle`);
                    if (enabledToggle) {
                        enabledToggle.checked = settings.enabled;
                    }
                }, 150); // Slightly increased wait time for DOM updates
            } else {
                console.error(`Provider select not found for ${agent}`);
            }
        }

        console.log('Reset to defaults completed');
    }

    /**
     * Load LLM settings from the API
     */
    async loadLLMSettings() {
        try {
            const settings = await apiClient.getLLMSettings();
            this.llmSettings = settings;

            // Update UI with loaded settings
            this.updateLLMSettingsUI(settings);

            // Initialize model options for each agent based on current provider selection
            const agentNames = ['narrator', 'rule-checker', 'context-evaluator'];
            agentNames.forEach(agent => {
                const providerSelect = document.getElementById(`${agent}-provider`);
                if (providerSelect) {
                    // Ensure model options are updated AFTER settings are loaded
                    this.updateModelOptionsForAgent(agent, providerSelect.value);
                    // Schedule setting the value after options are populated
                     setTimeout(() => {
                         this.setAgentModelValueFromSettings(agent, settings);
                     }, 100);
                }
            });

            return settings;
        } catch (error) {
            console.error('Error loading LLM settings:', error);
            this.showNotification('Failed to load LLM settings', 'error');
            return null;
        }
    }

    /**
     * Helper to set agent model value after options are populated
     */
    setAgentModelValueFromSettings(agent, settings) {
        const modelSelect = document.getElementById(`${agent}-model`);
        const agentConfig = settings?.agents?.[agent.replace('-', '_')];

        if (modelSelect && modelSelect.tagName === 'SELECT' && agentConfig) {
            const modelValue = agentConfig.model;
            // Safely check if options exists and has items before using Array.from
            if (modelSelect.options && modelSelect.options.length > 0) {
                const option = Array.from(modelSelect.options).find(opt => opt.value === modelValue);
                if (option) {
                    modelSelect.value = modelValue;
                } else {
                    // Model from settings not found in options, select first option
                    console.warn(`Model ${modelValue} for agent ${agent} not found in options. Selecting first available.`);
                    modelSelect.value = modelSelect.options[0].value;
                }
            }
        } else if (modelSelect) {
             console.warn(`Model element for agent ${agent} is not a SELECT or config is missing.`);
             // Try to fix it if it's not a SELECT
             if (modelSelect.tagName !== 'SELECT') {
                 const provider = document.getElementById(`${agent}-provider`)?.value || 'OPENAI';
                 this.forceCreateSelect(agent, provider, modelSelect.value || '');
             }
        }
    }


    /**
     * Update model options for an agent based on selected provider
     * @param {string} agent - The agent name (e.g., 'narrator', 'rule-checker', 'context-evaluator')
     * @param {string} provider - The selected provider (e.g., 'OPENAI', 'GOOGLE', 'OPENROUTER')
     */
    updateModelOptionsForAgent(agent, provider) {
        console.log(`Updating model options for ${agent} with provider ${provider}`);
        
        // Set the flag to prevent other code from interfering
        this.isUpdatingModelOptions = true;
        
        try {
            // Find the agent section
            const agentSection = document.querySelector(`#${agent}-provider`).closest('.agent-section');
            if (!agentSection) {
                console.error(`Could not find agent section for ${agent}`);
                return;
            }
            
            // Find all form groups in the section
            const formGroups = agentSection.querySelectorAll('.form-group');
            let modelFormGroup = null;
            
            // Find the form group for the model
            for (const group of formGroups) {
                const label = group.querySelector('label');
                if (label && label.getAttribute('for') === `${agent}-model`) {
                    modelFormGroup = group;
                    break;
                }
            }
            
            // Get current value if there's an existing model element
            let currentValue = '';
            const existingModel = document.getElementById(`${agent}-model`);
            if (existingModel) {
                currentValue = existingModel.value || '';
            }
            
            // If we couldn't find it, create a new one
            if (!modelFormGroup) {
                console.log(`Creating new form group for models`);
                modelFormGroup = document.createElement('div');
                modelFormGroup.className = 'form-group';
                
                // Insert it after the provider form group
                const providerFormGroup = agentSection.querySelector(`#${agent}-provider`).closest('.form-group');
                if (providerFormGroup && providerFormGroup.nextSibling) {
                    agentSection.insertBefore(modelFormGroup, providerFormGroup.nextSibling);
                } else {
                    agentSection.appendChild(modelFormGroup);
                }
            }
            
            // Check what's in the form group before clearing
            console.log('Current model form group content:', modelFormGroup.innerHTML);
            
            // Clear the existing form group
            modelFormGroup.innerHTML = '';
            
            // Create model label
            const label = document.createElement('label');
            label.setAttribute('for', `${agent}-model`);
            label.textContent = 'Model:';
            modelFormGroup.appendChild(label);
            
            // Create select element
            const select = document.createElement('select');
            select.id = `${agent}-model`;
            
            // Get models based on provider
            let models = [];
            
            if (provider === 'OPENROUTER') {
                // OpenRouter models
                models = [
                    { value: 'google/gemini-2.0-flash-lite-preview-02-05:free', label: 'Google Gemini 2.0 Flash Lite (Free)' },
                    { value: 'nousresearch/deephermes-3-llama-3-8b-preview:free', label: 'DeepHermes 3 Llama 3 8B (Free)' },
                    { value: 'google/gemini-2.0-pro-exp-02-05:free', label: 'Google Gemini 2.0 Pro (Free)' },
                    { value: 'mistralai/mistral-small-3.1-24b-instruct:free', label: 'Mistral Small 3.1 24B (Free)' },
                    { value: 'google/gemini-2.0-flash-exp:free', label: 'Google Gemini 2.0 Flash (Free)' }
                ];
                
                // Add current value if not empty and not already in the list
                if (currentValue && !models.some(m => m.value === currentValue)) {
                    models.push({ value: currentValue, label: currentValue });
                }
            } else if (provider === 'OPENAI') {
                // OpenAI models
                models = [
                    { value: 'gpt-4o-mini', label: 'GPT-4o Mini' },
                    { value: 'gpt-4o', label: 'GPT-4o' },
                ];
            } else if (provider === 'GOOGLE') {
                // Google models
                models = [
                    { value: 'gemini-2.0-flash', label: 'Gemini 2.0 Flash' },
                    { value: 'gemini-2.0-pro-latest', label: 'Gemini 2.0 Pro' },
                ];
            } else {
                models = [
                    { value: 'unknown-provider-model', label: 'Select Model' }
                ];
            }
            
            // Add options to the select
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.label;
                select.appendChild(option);
            });
            
            // Set the value if it exists in options
            if (currentValue) {
                const option = Array.from(select.options).find(opt => opt.value === currentValue);
                if (option) {
                    select.value = currentValue;
                }
            }
            
            // Append the select to the form group
            modelFormGroup.appendChild(select);
            
            // Ensure the element is a SELECT by checking it
            setTimeout(() => {
                const modelElement = document.getElementById(`${agent}-model`);
                if (modelElement && modelElement.tagName !== 'SELECT') {
                    console.error(`Model element for ${agent} is not a SELECT after creation!`);
                    // Attempt to force replace
                    this.forceCreateSelect(agent, provider, modelElement.value || '');
                }
            }, 50);
            
            console.log('Element created:', select.tagName);
            console.log('Form group after update:', modelFormGroup.innerHTML);
        } finally {
            // Reset flag
            this.isUpdatingModelOptions = false;
        }
    }

    /**
     * Update the LLM settings UI with the given settings
     * @param {Object} settings - The LLM settings object
     */
    updateLLMSettingsUI(settings) {
        if (!settings) return;

        // Update LLM enabled toggle
        const llmToggle = document.getElementById('llm-enabled-toggle');
        if (llmToggle) {
            llmToggle.checked = settings.llm_enabled;
            this.settings.llmEnabled = settings.llm_enabled;
            localStorage.setItem('rpg_llm_enabled', settings.llm_enabled);
        }

        // Update provider settings
        if (settings.providers) {
            for (const [provider, config] of Object.entries(settings.providers)) {
                if (provider !== 'openai' && provider !== 'google' && provider !== 'openrouter') continue;

                // API Key
                const apiKeyInput = document.getElementById(`${provider}-api-key`);
                if (apiKeyInput) {
                    apiKeyInput.value = config.api_key || '';
                }

                // Enabled toggle
                const enabledToggle = document.getElementById(`${provider}-enabled-toggle`);
                if (enabledToggle) {
                    enabledToggle.checked = config.enabled !== false;
                }
            }
        }

        // Update agent settings
        if (settings.agents) {
            for (const [agent, config] of Object.entries(settings.agents)) {
                // Provider
                const providerSelect = document.getElementById(`${agent}-provider`);
                if (providerSelect) {
                    providerSelect.value = config.provider_type || 'OPENAI';
                    // Model options will be updated and value set by loadLLMSettings caller
                }

                // Temperature
                const tempSlider = document.getElementById(`${agent}-temperature`);
                const tempValue = document.getElementById(`${agent}-temperature-value`);
                if (tempSlider) {
                    const temp = config.temperature !== undefined ? config.temperature : 0.7;
                    tempSlider.value = temp;
                    if (tempValue) {
                        tempValue.textContent = temp;
                    }
                }

                // Enabled toggle
                const enabledToggle = document.getElementById(`${agent}-enabled-toggle`);
                if (enabledToggle) {
                    enabledToggle.checked = config.enabled !== false;
                }
            }
        }
    }

    /**
     * Collect LLM settings from the UI
     * @returns {Object} The collected LLM settings
     */
    collectLLMSettings() {
        const settings = {
            providers: {
                openai: {
                    api_key: document.getElementById('openai-api-key')?.value || '',
                    enabled: document.getElementById('openai-enabled-toggle')?.checked !== false
                },
                google: {
                    api_key: document.getElementById('google-api-key')?.value || '',
                    enabled: document.getElementById('google-enabled-toggle')?.checked !== false
                },
                openrouter: {
                    api_key: document.getElementById('openrouter-api-key')?.value || '',
                    enabled: document.getElementById('openrouter-enabled-toggle')?.checked !== false
                }
            },
            agents: {}
        };

        // Collect agent settings
        const agentNames = ['narrator', 'rule-checker', 'context-evaluator'];

        for (const agent of agentNames) {
            const providerSelect = document.getElementById(`${agent}-provider`);
            let modelElement = document.getElementById(`${agent}-model`);
            const temperatureElement = document.getElementById(`${agent}-temperature`);
            const enabledElement = document.getElementById(`${agent}-enabled-toggle`);

            if (!providerSelect) continue;

            const provider = providerSelect.value;
            let model = '';

            // Check if model element is not a SELECT, and fix it if needed
            if (modelElement && modelElement.tagName !== 'SELECT') {
                console.warn(`Model element for ${agent} is not a SELECT when collecting settings, fixing...`);
                this.forceCreateSelect(agent, provider, modelElement.value || '');
                // Get the new SELECT
                modelElement = document.getElementById(`${agent}-model`);
            }

            // Get model value
            if (modelElement && modelElement.tagName === 'SELECT') {
                model = modelElement.value;
                // Handle case where no models were available
                if (model === 'no-models-available') {
                    console.warn(`Agent ${agent} has no model selected. Using empty string.`);
                    model = '';
                }
            } else if (modelElement) {
                // If it's an INPUT somehow, at least get its value
                model = modelElement.value || '';
                console.error(`Model element for ${agent} is still not a SELECT! Using value: ${model}`);
            } else {
                console.error(`Model element for ${agent} not found!`);
            }

            // Create agent setting
            settings.agents[agent.replace('-', '_')] = {
                provider_type: provider,
                model: model,
                temperature: parseFloat(temperatureElement?.value || 0.7),
                enabled: enabledElement?.checked !== false
            };
        }

        return settings;
    }

    /**
     * Toggle LLM functionality for the current game session
     * @param {boolean} enabled - Whether to enable LLM functionality
     */
    async toggleLLM(enabled) {
        try {
            if (!apiClient.hasActiveSession()) {
                this.showNotification('No active game session', 'warning');
                return;
            }

            const result = await apiClient.toggleLLM(enabled);

            if (result.status === 'success') {
                this.settings.llmEnabled = enabled;
                localStorage.setItem('rpg_llm_enabled', enabled);
                this.showNotification(`LLM functionality ${enabled ? 'enabled' : 'disabled'}`, 'success');
            } else {
                this.showNotification(`Failed to ${enabled ? 'enable' : 'disable'} LLM functionality`, 'error');
            }

            return result;
        } catch (error) {
            console.error('Error toggling LLM:', error);
            this.showNotification(`Failed to ${enabled ? 'enable' : 'disable'} LLM functionality`, 'error');
            return null;
        }
    }

    /**
     * Save settings to localStorage and backend
     */
    async saveSettings() {
        let hasSession = apiClient.hasActiveSession();

        // Save UI preferences locally immediately
        const themeSelect = document.getElementById('theme-select');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const llmEnabledToggle = document.getElementById('llm-enabled-toggle');

        if (themeSelect) {
            this.settings.theme = themeSelect.value;
            localStorage.setItem('rpg_theme', this.settings.theme);
        }

        if (fontSizeSlider) {
            this.settings.fontSize = fontSizeSlider.value;
            localStorage.setItem('rpg_font_size', this.settings.fontSize);
        }

        if (llmEnabledToggle) {
            this.settings.llmEnabled = llmEnabledToggle.checked;
            localStorage.setItem('rpg_llm_enabled', llmEnabledToggle.checked);
        }


        // Save LLM settings to backend
        if (document.getElementById('llm-settings')) {
            const llmSettings = this.collectLLMSettings();

            // Ensure session exists before saving LLM settings or toggling LLM
            if (!hasSession) {
                try {
                    this.addMessage('Creating a temporary session to save settings...', 'system');
                    const result = await apiClient.createNewGame('TemporarySettingsSave');
                    apiClient.sessionId = result.session_id;
                    apiClient.saveSession();

                    // Let main.js handle WebSocket connection if needed
                    const event = new CustomEvent('session-created', { detail: { sessionId: result.session_id } });
                    document.dispatchEvent(event);

                    hasSession = true; // Now we have a session
                } catch (error) {
                    console.error('Failed to create session for LLM settings save:', error);
                    uiManager.showNotification('Failed to create session to save LLM settings', 'error');
                    return; // Abort saving LLM settings if session creation fails
                }
            }

            // Now save LLM settings to backend
            try {
                const result = await apiClient.updateLLMSettings(llmSettings);
                if (result.status === 'success') {
                    console.log('LLM settings saved successfully to backend');
                    // Optionally show a specific notification for LLM settings save
                    // this.showNotification('LLM settings saved', 'success');
                } else {
                    console.error('Failed to save LLM settings to backend:', result);
                    this.showNotification('Failed to save LLM settings', 'error');
                }
            } catch (error) {
                console.error('Error saving LLM settings via API:', error);
                this.showNotification('Error saving LLM settings', 'error');
            }

            // Apply LLM enabled setting to current game session if active
            if (apiClient.hasActiveSession()) {
                 // Use the state from the toggle just saved
                 const currentLLMEnabledState = llmEnabledToggle ? llmEnabledToggle.checked : this.settings.llmEnabled;
                 this.toggleLLM(currentLLMEnabledState)
                     .catch(error => console.error('Error toggling LLM after save:', error));
            }
        } else {
            // No LLM settings tab? Just log it.
             console.log("LLM settings tab not found, skipping backend save for LLM settings.");
        }
    }
}

// Make sure there's only one instance of UiManager
window.uiManager = window.uiManager || new UiManager();

```

### File: web\client\js\websocket-client.js

```javascript
/**
 * WebSocket Client for RPG Game
 * Handles real-time updates from the server
 */

class WebSocketClient {
    constructor(baseUrl = '') {
        this.baseUrl = baseUrl || window.location.origin;
        this.socket = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 3000; // Start with 3 seconds
        this.sessionId = null;
        this.eventHandlers = {
            'connect': [],
            'disconnect': [],
            'game_state': [],
            'command_result': [],
            'game_loaded': [],
            'time_update': [],
            'stats_changed': [],
            'turn_order_update': [],
            'ui_bar_update_phase1': [],
            'ui_bar_update_phase2': [],
            'combat_log_set_html': [],
            'narrative': [],
            'journal_updated': [],
            'error': []
        };
        
        // Flag to prevent multiple connection attempts
        this.connecting = false;
    }

    /**
     * Connect to the WebSocket server
     * @param {string} sessionId - The game session ID
     */
    connect(sessionId) {
        if (!sessionId) {
            console.error('Cannot connect WebSocket: No session ID provided');
            return false;
        }

        // If already connected to the same session, don't reconnect
        if (this.socket && this.isConnected && this.sessionId === sessionId) {
            console.log('Already connected to this session, skipping reconnect');
            return true;
        }
        
        // If already in the process of connecting, don't start another connection
        if (this.connecting) {
            console.log('Connection already in progress, skipping');
            return false;
        }
        
        this.connecting = true;

        // If connected to a different session, disconnect first
        if (this.socket) {
            this.disconnect();
        }

        this.sessionId = sessionId;

        // Normalize the WebSocket URL (handle ws/wss protocol)
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsBaseUrl = this.baseUrl.replace(/^http(s?):\/\//, '');
        const wsUrl = `${protocol}//${wsBaseUrl}/ws/${sessionId}`;

        console.log(`Connecting to WebSocket: ${wsUrl}`);

        try {
            this.socket = new WebSocket(wsUrl);
            
            // Connection opened
            this.socket.addEventListener('open', (event) => {
                this.isConnected = true;
                this.connecting = false;
                this.reconnectAttempts = 0;
                console.log('WebSocket connection established');
                this._notifyEventHandlers('connect', { event });
            });
            
            // Listen for messages
            this.socket.addEventListener('message', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    const eventType = data.type || 'unknown';
                    
                    console.log(`WebSocket received ${eventType} event:`, data);
                    
                    // Notify appropriate event handlers
                    this._notifyEventHandlers(eventType, data.data || data);
                    
                } catch (error) {
                    console.error('Error processing WebSocket message:', error);
                    this._notifyEventHandlers('error', { error, message: 'Error processing message' });
                }
            });
            
            // Connection closed
            this.socket.addEventListener('close', (event) => {
                this.isConnected = false;
                this.connecting = false;
                console.log('WebSocket connection closed', event.code, event.reason);
                this._notifyEventHandlers('disconnect', { code: event.code, reason: event.reason });
                
                // Attempt to reconnect if it wasn't a normal closure and not intentionally disconnected
                if (event.code !== 1000 && event.code !== 1001 && !this.intentionalDisconnect) {
                    this._attemptReconnect();
                } else if (this.intentionalDisconnect) {
                    console.log('Skipping reconnect - disconnect was intentional');
                    this.intentionalDisconnect = false; // Reset flag
                }
            });
            
            // Connection error
            this.socket.addEventListener('error', (error) => {
                this.connecting = false;
                console.error('WebSocket error:', error);
                this._notifyEventHandlers('error', { error, message: 'Connection error' });
            });
            
            return true;
        } catch (error) {
            this.connecting = false;
            console.error('Failed to create WebSocket:', error);
            this._notifyEventHandlers('error', { error, message: 'Failed to create connection' });
            return false;
        }
    }

    /**
     * Disconnect from the WebSocket server
     * @param {boolean} intentional - If true, will not attempt to reconnect
     */
    disconnect(intentional = false) {
        this.intentionalDisconnect = intentional;
        if (this.socket) {
            try {
                this.socket.close(1000, 'Client disconnected');
            } catch (error) {
                console.error('Error closing WebSocket:', error);
            } finally {
                this.socket = null;
                this.isConnected = false;
                this.connecting = false;
            }
        }
    }

    /**
     * Register an event handler
     * @param {string} eventType - The type of event to handle
     * @param {function} handler - The handler function
     */
    on(eventType, handler) {
        if (typeof handler !== 'function') {
            console.error('Event handler must be a function');
            return;
        }

        if (!this.eventHandlers[eventType]) {
            this.eventHandlers[eventType] = [];
        }
        
        // Check if handler is already registered
        if (this.eventHandlers[eventType].indexOf(handler) === -1) {
            this.eventHandlers[eventType].push(handler);
        }
    }

    /**
     * Remove an event handler
     * @param {string} eventType - The type of event
     * @param {function} handler - The handler function to remove
     */
    off(eventType, handler) {
        if (!this.eventHandlers[eventType]) return;

        const index = this.eventHandlers[eventType].indexOf(handler);
        if (index !== -1) {
            this.eventHandlers[eventType].splice(index, 1);
        }
    }
    
    /**
     * Remove all event handlers for a specific event type
     * @param {string} eventType - The type of event
     */
    offAll(eventType) {
        if (eventType && this.eventHandlers[eventType]) {
            this.eventHandlers[eventType] = [];
        }
    }

    /**
     * Send data to the server (if needed)
     * @param {object} data - The data to send
     */
    send(data) {
        if (!this.isConnected || !this.socket) {
            console.error('Cannot send: WebSocket not connected');
            return false;
        }

        try {
            this.socket.send(JSON.stringify(data));
            return true;
        } catch (error) {
            console.error('Error sending WebSocket message:', error);
            return false;
        }
    }

    /**
     * Check if the WebSocket is currently connected
     */
    checkConnected() {
        return this.isConnected && this.socket && this.socket.readyState === WebSocket.OPEN;
    }

    /**
     * Attempt to reconnect to the WebSocket server
     * @private
     */
    _attemptReconnect() {
        if (this.connecting) {
            return; // Already trying to connect
        }
        
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error(`Maximum reconnect attempts (${this.maxReconnectAttempts}) reached`);
            this._notifyEventHandlers('error', { message: 'Failed to reconnect after maximum attempts' });
            return;
        }

        // Exponential backoff
        const delay = this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts);
        
        console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);
        
        setTimeout(() => {
            this.reconnectAttempts++;
            this.connect(this.sessionId);
        }, delay);
    }

    /**
     * Notify all registered handlers for an event type
     * @private
     */
    _notifyEventHandlers(eventType, data) {
        if (!this.eventHandlers[eventType]) return;

        for (const handler of this.eventHandlers[eventType]) {
            try {
                handler(data);
            } catch (error) {
                console.error(`Error in ${eventType} handler:`, error);
            }
        }
    }
}

// Create and export the singleton instance
const webSocketClient = new WebSocketClient();
```

### File: config\world\locations\defaults.json

```json
{
  "culture_mix": {
    "concordant": 0.5,
    "verdant": 0.2,
    "crystalline": 0.15,
    "ashen": 0.1,
    "tempest": 0.05
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Default cultural mixture applied to locations that don't specify culture_mix."
  }
}
```

### File: config\world\locations\locations.json

```json
{
  "locations": {
    "harmonia": {
      "id": "harmonia",
      "name": "Harmonia",
      "description": "The largest and most influential of the Concordant Cities, serving as the capital of their confederation. Built at the confluence of major Resonance nodes, its architecture is a mesmerizing blend of all five planes that shifts and reconfigures during Resonance Events. The city is arranged in seven concentric rings, each representing different aspects of planar influence.",
      "type": "city",
      "region": "Central Nexus",
      "culture_id": "concordant",
      "population": 80000,
      "culture_mix": {
        "concordant": 0.8,
        "verdant": 0.1,
        "crystalline": 0.05,
        "tempest": 0.05
      },
      "features": [
        {
          "name": "The Harmonic Spire",
          "description": "A towering structure at the city center that serves as both government seat and Resonance monitoring station. The spire changes color and sometimes shape depending on upcoming Resonance Events.",
          "interaction_type": "examine"
        },
        {
          "name": "The Attunement Hall",
          "description": "A sacred space where citizens receive their protective tattoos. The walls are lined with designs from across all five planes.",
          "interaction_type": "interact"
        },
        {
          "name": "The Resonance Academy",
          "description": "The premier institution for studying planar phenomena and predicting Resonance Events. Home to the Harmonic Order.",
          "interaction_type": "examine"
        },
        {
          "name": "The Five Voices Plaza",
          "description": "A pentagonal square where the Five Speakers occasionally gather to deliberate. Each corner features a statue representing a fragmented Luminary.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "verdant_embassy",
          "description": "A well-maintained road leading to the diplomatic outpost of the Verdant Collective.",
          "travel_time": 240,
          "requirements": []
        },
        {
          "target": "crystalline_enclave",
          "description": "A geometric pathway of perfectly aligned stones leading to the Crystalline Consortium's trading post.",
          "travel_time": 180,
          "requirements": []
        },
        {
          "target": "echo_woods",
          "description": "A winding path through increasingly wild terrain that eventually reaches the Echo Woods.",
          "travel_time": 360,
          "requirements": []
        }
      ],
      "npcs": [
        "council_speaker",
        "resonance_sage",
        "attunement_master"
      ]
    },
    "verdant_embassy": {
      "id": "verdant_embassy",
      "name": "Verdant Embassy",
      "description": "An outpost of the Verdant Collective on the Nexus plane. The embassy is a living structure, grown rather than built, with walls of interwoven trees and flowering vines that change with the seasons. It serves as both a diplomatic mission and a trading post for the unique flora and fauna of the Verdant plane.",
      "type": "outpost",
      "region": "Western Nexus",
      "culture_id": "verdant",
      "population": 350,
      "culture_mix": {
        "verdant": 0.8,
        "concordant": 0.1,
        "crystalline": 0.05,
        "tempest": 0.05
      },
      "features": [
        {
          "name": "The Living Council Chamber",
          "description": "A circular room where tree branches have been coaxed into forming a natural amphitheater. The branches shift slightly to improve acoustics when someone speaks.",
          "interaction_type": "examine"
        },
        {
          "name": "The Green Speech Garden",
          "description": "A secluded garden where members of the Verdant Collective communicate through their unique plant-based language.",
          "interaction_type": "examine"
        },
        {
          "name": "Seasonal Quarters",
          "description": "Living quarters that transform with the seasons, offering different amenities depending on the time of year.",
          "interaction_type": "interact"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A well-maintained road leading back to the capital city of Harmonia.",
          "travel_time": 240,
          "requirements": []
        },
        {
          "target": "deeproot_crossing",
          "description": "A temporary passage to the Verdant plane that becomes accessible during specific Resonance Events.",
          "travel_time": 120,
          "requirements": [
            "resonance_event_verdant"
          ]
        }
      ],
      "npcs": [
        "verdant_ambassador",
        "botanical_trader",
        "green_speaker"
      ]
    },
    "crystalline_enclave": {
      "id": "crystalline_enclave",
      "name": "Crystalline Enclave",
      "description": "A trading post and research facility established by the Crystalline Consortium on the Nexus plane. The entire structure is built from precisely angled crystalline materials that reflect light in complex mathematical patterns. Inside, scholars and merchants work to advance Facet Magic and trade in rare minerals.",
      "type": "outpost",
      "region": "Eastern Nexus",
      "culture_id": "crystalline",
      "population": 275,
      "culture_mix": {
        "crystalline": 0.8,
        "concordant": 0.1,
        "verdant": 0.05,
        "tempest": 0.05
      },
      "features": [
        {
          "name": "The Calculation Chamber",
          "description": "A hexagonal room where crystal matrices are used to solve complex mathematical and magical equations. The floor is inscribed with intricate geometric formulas.",
          "interaction_type": "examine"
        },
        {
          "name": "The Precision Market",
          "description": "A marketplace where crystalline components and precision instruments are traded under strict quality control standards.",
          "interaction_type": "interact"
        },
        {
          "name": "Faceting Workshop",
          "description": "A facility where young members of the Consortium receive their crystal implants, carefully aligned to enhance specific mental abilities.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A geometric pathway of perfectly aligned stones leading back to Harmonia.",
          "travel_time": 180,
          "requirements": []
        },
        {
          "target": "lattice_point",
          "description": "A precisely calibrated portal to the Crystalline plane, accessible only during certain celestial alignments.",
          "travel_time": 90,
          "requirements": [
            "celestial_alignment"
          ]
        }
      ],
      "npcs": [
        "consortium_representative",
        "facet_mage",
        "crystal_merchant"
      ]
    },
    "echo_woods": {
      "id": "echo_woods",
      "name": "Echo Woods",
      "description": "A mysterious forest that exists partially in the Nexus plane and partially in the Verdant plane. The trees seem to whisper echoes of conversations held long ago, and visitors often report seeing shadowy figures moving between the trunks. It's known as a place where the boundaries between planes are naturally thin.",
      "type": "forest",
      "region": "Northwestern Nexus",
      "culture_id": "",
      "population": 0,
      "culture_mix": {
        "verdant": 0.6,
        "concordant": 0.2,
        "ashen": 0.2
      },
      "features": [
        {
          "name": "The Whispering Grove",
          "description": "A clearing where echoes of past conversations can be heard clearly, sometimes providing valuable historical information.",
          "interaction_type": "interact"
        },
        {
          "name": "The Blurred Stream",
          "description": "A waterway that occasionally shifts between planes, with water that can grant temporary visions of other planes when drunk.",
          "interaction_type": "use"
        },
        {
          "name": "The Ancient Hollow",
          "description": "An enormous hollow tree that predates The Shattering. Inside is a small, permanent Planar Bleed Zone.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A winding path through increasingly civilized terrain that eventually reaches Harmonia.",
          "travel_time": 360,
          "requirements": []
        },
        {
          "target": "ashen_camp",
          "description": "A barely visible trail that leads to a temporary settlement of the Ashen Covenant.",
          "travel_time": 180,
          "requirements": [
            "tracking_skill"
          ]
        }
      ],
      "npcs": [
        "echo_collector",
        "plane_walker"
      ]
    },
    "ashen_camp": {
      "id": "ashen_camp",
      "name": "Ashen Camp",
      "description": "A temporary settlement of the Ashen Covenant, comprised of easily dismantled structures and tents made from ash-treated hides. The camp is relocated monthly according to Covenant traditions. At its center burns an eternal flame where ancestral ashes are kept and used in rituals.",
      "type": "settlement",
      "region": "Northern Nexus",
      "culture_id": "ashen",
      "population": 120,
      "culture_mix": {
        "ashen": 0.8,
        "concordant": 0.1,
        "verdant": 0.1
      },
      "features": [
        {
          "name": "The Ancestor Fire",
          "description": "A central fire pit where ashes of ancestors are preserved. Covenant members can sometimes communicate with the dead through rituals performed here.",
          "interaction_type": "interact"
        },
        {
          "name": "The Exchange Circle",
          "description": "An open area where the monthly Possession Exchange ceremony takes place, redistributing all material goods among the community.",
          "interaction_type": "examine"
        },
        {
          "name": "Ash Walker Tents",
          "description": "Special tents where practitioners of Ash Walking temporarily transfer their consciousness to the Ashen plane.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "echo_woods",
          "description": "A barely visible trail leading back to the Echo Woods.",
          "travel_time": 180,
          "requirements": []
        },
        {
          "target": "gray_veil",
          "description": "A spiritual pathway to a location in the Ashen plane, only accessible to those trained in Ash Walking.",
          "travel_time": 60,
          "requirements": [
            "ash_walking_knowledge"
          ]
        }
      ],
      "npcs": [
        "covenant_elder",
        "ash_walker",
        "memory_keeper"
      ]
    },
    "tempest_harbor": {
      "id": "tempest_harbor",
      "name": "Tempest Harbor",
      "description": "A temporary docking location for the Tempest Flotilla on the Nexus plane, only present during specific celestial alignments. The harbor consists of rapidly constructed floating platforms and swaying walkways, all designed to be disassembled quickly. The atmosphere is chaotic and festive, with constant trading, gambling, and storytelling.",
      "type": "harbor",
      "region": "Southern Nexus",
      "culture_id": "tempest",
      "population": 800,
      "culture_mix": {
        "tempest": 0.8,
        "concordant": 0.1,
        "verdant": 0.1
      },
      "features": [
        {
          "name": "The Flux Market",
          "description": "A chaotic marketplace where leadership and prices change daily, offering rare goods from the Tempest plane.",
          "interaction_type": "interact"
        },
        {
          "name": "Storm Binder's Pavilion",
          "description": "A large tent where skilled artisans capture storm essences in elaborate tattoo designs.",
          "interaction_type": "interact"
        },
        {
          "name": "The Opportunity Board",
          "description": "A constantly updated notice board listing current jobs, adventures, and opportunities throughout the planes.",
          "interaction_type": "examine"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "A southern road leading to the capital city of Harmonia.",
          "travel_time": 300,
          "requirements": []
        },
        {
          "target": "maelstrom_edge",
          "description": "A dangerous passage to the edge of the Tempest plane, only navigable during specific celestial alignments.",
          "travel_time": 240,
          "requirements": [
            "celestial_alignment",
            "tempest_navigation"
          ]
        }
      ],
      "npcs": [
        "flotilla_captain",
        "storm_binder",
        "probability_merchant"
      ]
    },
    "shifting_library": {
      "id": "shifting_library",
      "name": "The Shifting Library",
      "description": "A mysterious repository of knowledge that exists simultaneously in all planes. Different sections become accessible depending on which plane is currently dominant. The exterior appears as a modest stone building, but the interior contains seemingly endless halls of books, artifacts, and recordings from across all planes and time periods.",
      "type": "library",
      "region": "Planar Overlap",
      "culture_id": "",
      "population": 20,
      "culture_mix": {},
      "features": [
        {
          "name": "The Lexicant Hall",
          "description": "The central chamber where the enigmatic Lexicants—beings who can exist in multiple planes simultaneously—catalog and preserve knowledge.",
          "interaction_type": "examine"
        },
        {
          "name": "The Shifting Stacks",
          "description": "Endless rows of bookshelves that rearrange themselves based on planar influences, sometimes revealing previously inaccessible tomes.",
          "interaction_type": "interact"
        },
        {
          "name": "Pre-Shattering Archive",
          "description": "A heavily secured section containing fragmentary records from before The Shattering, only accessible during rare planar alignments.",
          "interaction_type": "examine"
        },
        {
          "name": "The Reading Nexus",
          "description": "A circular chamber with desks that automatically provide reference materials related to the researcher's current study.",
          "interaction_type": "use"
        }
      ],
      "connections": [
        {
          "target": "harmonia",
          "description": "The library's location relative to Harmonia changes based on planar alignments, but it's typically a day's journey.",
          "travel_time": 480,
          "requirements": [
            "library_authorization"
          ]
        }
      ],
      "npcs": [
        "head_lexicant",
        "knowledge_seeker",
        "forgotten_scholar"
      ]
    },
    "planar_bleed_zone": {
      "id": "planar_bleed_zone",
      "name": "The Convergence",
      "description": "A large area where multiple planes have permanently merged, creating a surreal landscape with elements from all planes coexisting in impossible ways. Flora and fauna have hybridized, and the laws of physics seem to vary from one meter to the next. Despite the dangers, researchers and resource gatherers frequent the area for its unique properties.",
      "type": "anomaly",
      "region": "Planar Border",
      "culture_id": "",
      "population": 50,
      "culture_mix": {},
      "features": [
        {
          "name": "Reality Fault",
          "description": "A visible crack in space where raw planar energy seeps through, causing unpredictable magical effects in the vicinity.",
          "interaction_type": "examine"
        },
        {
          "name": "Hybridization Gardens",
          "description": "A research station where Harmonic Order scientists study the unique hybrid flora and fauna that have evolved in the zone.",
          "interaction_type": "interact"
        },
        {
          "name": "Echo Chamber",
          "description": "A cave where sounds seem to echo from other planes and times, occasionally revealing useful information.",
          "interaction_type": "interact"
        },
        {
          "name": "Harvester Camp",
          "description": "A fortified encampment for those who gather the valuable resources that can only be found in Planar Bleed Zones.",
          "interaction_type": "interact"
        }
      ],
      "connections": [
        {
          "target": "echo_woods",
          "description": "A hazardous path through shifting terrain that eventually reaches more stable ground near the Echo Woods.",
          "travel_time": 600,
          "requirements": [
            "planar_protection"
          ]
        }
      ],
      "npcs": [
        "harmonic_researcher",
        "resource_harvester",
        "planar_hybrid"
      ]
    },
    "ghost_market": {
      "id": "ghost_market",
      "name": "The Ghost Market",
      "description": "A mysterious marketplace that appears only during specific Resonance Events. Run by enigmatic entities known as 'The Between,' it offers goods, services, and information from across all planes. The market materializes in different locations each time but is recognizable by its ethereal tents and the faint bell music that accompanies its appearance.",
      "type": "market",
      "region": "Variable",
      "culture_id": "",
      "population": 0,
      "culture_mix": {},
      "features": [
        {
          "name": "The Contract Circle",
          "description": "A central area where deals and contracts are formalized. Agreements made here are magically binding across all planes.",
          "interaction_type": "interact"
        },
        {
          "name": "Memory Exchange",
          "description": "A tent where memories can be bought, sold, or traded – sometimes willingly, sometimes not.",
          "interaction_type": "interact"
        },
        {
          "name": "Between Emporium",
          "description": "The largest structure in the market, selling impossible items that shouldn't exist in any single plane.",
          "interaction_type": "interact"
        },
        {
          "name": "Information Well",
          "description": "A literal well where visitors can ask questions and receive answers – for a price.",
          "interaction_type": "use"
        }
      ],
      "connections": [],
      "npcs": [
        "the_proprietor",
        "memory_merchant",
        "contract_binder"
      ]
    },
    "test_hub": {
      "id": "test_hub",
      "name": "Quest Test Hub",
      "description": "A developer test area used to quickly validate quest proofs (items, kills, visits, flags) in a controlled environment.",
      "type": "outpost",
      "region": "Dev",
      "culture_id": "concordant",
      "population": 0,
      "culture_mix": {},
      "features": [],
      "connections": [],
      "npcs": []
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Location definitions for the RPG game world"
  }
}
```

### File: gui\components\README.md

```markdown
# GUI Components

The `components` directory contains reusable UI components used in the game's graphical interface.

## Available Components

### character_sheet.py

The `CharacterSheet` component displays character information:
- Name, level, and basic stats
- Health, mana, and other resources
- Character attributes and skills
- Experience and progression

### command_input.py

The `CommandInput` component manages player input:
- Command text entry
- Command history navigation
- Auto-completion (if implemented)
- Command validation and feedback

### game_menu.py

The `GameMenu` component provides game menu functionality:
- New game, save, load options
- Settings and configuration
- Help and information
- Exit game functionality

### game_output.py

The `GameOutput` component displays game text and narrative:
- Scrollable text area for game output
- Formatting for different message types
- Image embedding (if applicable)
- History retention

### inventory_panel.py

The `InventoryPanel` component displays the player's inventory:
- Item listing with icons and basic info
- Equipment slots and equipped items
- Item interaction (use, equip, examine, etc.)
- Item filtering and sorting

### status_bar.py

The `StatusBar` component shows game status information:
- Current time and location
- Character status indicators
- Game mode indicators (LLM status, etc.)
- Quick access to common functions

## Implementation

All components are implemented using PySide6 (Qt) and follow a consistent pattern:
- Inherit from appropriate Qt widget classes
- Implement signals for event communication
- Provide public methods for external control
- Maintain internal state as needed

## Signals and Slots

Components communicate using Qt's signals and slots mechanism:
- Components emit signals when important events occur
- Other components or the main window connect to these signals
- Connected slots handle the events and update accordingly

## Styling

Components use stylesheets for visual styling:
- Common styles are defined in a central location
- Components can have specific style overrides
- Theme support is partially implemented

## Future Enhancements

1. Enhanced inventory visualization
2. More detailed character information display
3. Expandable panels and resizing
4. Theme selection and customization
5. Animated transitions and effects

```

### File: core\agents\README.md

```markdown
# Agents Module

The `core/agents` module provides a system of specialized, LLM-powered agents designed to manage different aspects of the game's narrative, rules, and context. These agents work together, coordinated by the `AgentManager`, to create a dynamic and interactive game experience.

## Purpose

The primary goal of the agent system is to leverage Large Language Models (LLMs) to:

*   Generate rich, descriptive, and contextually relevant game narrative.
*   Interpret player input and translate it into game actions and narrative consequences.
*   Enforce game rules consistently and fairly.
*   Manage the flow of information, ensuring agents have the necessary context (game state, memories, etc.) to perform their tasks.
*   Allow for modular design, where different agents handle specific responsibilities.

## Key Components

### `base_agent.py`

Defines the foundational elements for all agents:

*   **`BaseAgent`**: An abstract base class providing common functionality like configuration loading (`config/llm/agents/<agent_name>.json`), interaction with the `LLMManager`, basic prompt construction, and settings reloading. All specific agents inherit from this class.
*   **`AgentContext`**: A dataclass holding the information passed to an agent for processing a request. This includes game state, player state, world state, player input, conversation history, relevant memories, and potentially additional context retrieved during processing.
*   **`AgentResponse`**: A dataclass containing the output from an agent, including the generated text (`content`), any extracted commands (`commands`), and metadata (like LLM usage details).

### `agent_manager.py`

*   **`AgentManager`**: A singleton class that acts as the central coordinator for the agent system. It orchestrates the processing pipeline for player input:
    1.  Creates the initial `AgentContext`.
    2.  (Optional) Calls the `ContextEvaluatorAgent` to enrich the context with summaries or relevant memories.
    3.  (Optional) Calls the `RuleCheckerAgent` to validate the player's intended action based on game rules and state. If invalid, the process stops and returns feedback.
    4.  Calls the `NarratorAgent` to generate an initial narrative response.
    5.  Checks the Narrator's response for specific data retrieval commands (e.g., `{GET_INVENTORY}`, `{GET_STATS}`).
    6.  If data retrieval commands are present, it uses `data_retrieval_commands.py` to fetch the required data from the `GameState`.
    7.  Calls the `NarratorAgent` *again* with the enhanced context (including the retrieved data) to generate the final narrative.
    8.  Processes any narrative item commands (e.g., `{ITEM:potion}`) using the `NarrativeItemManager`.
    9.  Extracts remaining commands (e.g., `{STAT_CHECK}`, `{QUEST_UPDATE}`) from the final narrative.
    10. Returns the final narrative text and the list of commands to the game loop for execution.

### `narrator.py`

*   **`NarratorAgent`**: Responsible for generating the game's narrative content.
    *   Takes the `AgentContext` (potentially enriched by the `AgentManager`) and crafts descriptive text based on player actions, game state, and world events.
    *   Instructed via its system prompt to use specific data retrieval commands (`{GET_INVENTORY}`, `{GET_STATS}`, `{GET_QUESTS}`, `{GET_LOCATION_INFO}`) when the player asks for game information, rather than hallucinating details.
    *   Can embed other commands (e.g., `{ITEM_CREATE}`, `{STAT_CHECK}`, `{MUSIC_MOOD}`) within its narrative to trigger game state changes or checks.

### `rule_checker.py`

*   **`RuleCheckerAgent`**: Enforces game rules and validates player actions.
    *   Receives the `AgentContext` and evaluates if the player's input/action is permissible based on game rules, physics, character capabilities, and current state.
    *   Provides feedback if an action is invalid.
    *   Includes logic to prevent cheating (e.g., tracking looted entities).
    *   Can perform skill checks (`perform_skill_check`) when triggered by commands like `{STAT_CHECK}`.

### `context_evaluator.py`

*   **`ContextEvaluatorAgent`**: Analyzes the game context to determine relevance and provide summaries.
    *   Evaluates the current `AgentContext`, including game state, conversation history, and potentially memories.
    *   Generates concise context summaries to help other agents (especially the `NarratorAgent`) focus on the most relevant information.
    *   Can identify key elements in the context and evaluate the importance of memories.
    *   Includes basic caching for context summaries based on location and input hash.

### `data_retrieval_commands.py`

*   Contains helper functions used by the `AgentManager` to process data retrieval commands issued by the `NarratorAgent`. It fetches specific information (like inventory lists, character stats, quest details, location info) directly from the `GameState`.

## Interaction Flow

1.  Player input is received by the main game loop.
2.  The game loop calls `AgentManager.process_input()`, passing the current `GameState` and player input.
3.  `AgentManager` creates an `AgentContext`.
4.  `AgentManager` optionally calls `ContextEvaluatorAgent` and `RuleCheckerAgent`.
5.  `AgentManager` calls `NarratorAgent` (potentially twice if data retrieval is needed).
6.  `AgentManager` processes narrative items and extracts final commands.
7.  `AgentManager` returns the final narrative text and commands to the game loop.
8.  The game loop displays the narrative and executes the commands using the `CommandProcessor`.

## Dependencies

The `agents` module primarily depends on:

*   `core.base`: For `GameState`, `CommandProcessor`, configuration (`get_config`).
*   `core.llm`: For `LLMManager`, `LLMResponse`, `ProviderType`.
*   `core.inventory`: For `NarrativeItemManager` (used by `AgentManager`).
*   `core.stats`: For `StatsManager` (used by `RuleCheckerAgent` for skill checks).
*   `core.utils`: For logging configuration.

## Configuration

Each agent type (`Narrator`, `RuleChecker`, `ContextEvaluator`) loads its specific settings from a corresponding JSON file in `config/llm/agents/` (e.g., `config/llm/agents/narrator.json`). These files control:

*   LLM provider and model selection (or defaults).
*   LLM parameters (temperature, max tokens).
*   System prompt templates.
*   Inclusion/exclusion of context elements (history, memories).

## Extending the System

To create a new type of agent:

1.  Create a new Python file (e.g., `my_new_agent.py`).
2.  Define a class that inherits from `BaseAgent`.
3.  Implement the required abstract methods (`_generate_system_prompt`, `supports_command`).
4.  Override other methods (`_prepare_messages`, `process`) as needed for custom logic.
5.  Create a configuration file in `config/llm/agents/my_new_agent.json`.
6.  Integrate the new agent into the `AgentManager`'s workflow if necessary.

## Usage Example

```python
from core.agents.agent_manager import get_agent_manager
from core.base.state import get_state_manager # Assuming state is managed

# Get the singleton instances
agent_manager = get_agent_manager()
state_manager = get_state_manager()

# Ensure game state is loaded or initialized
# state_manager.load_game(...) or state_manager.new_game(...)

# Process player input
player_input = "I search the chest for traps"
narrative_text, commands = agent_manager.process_input(
    game_state=state_manager.state,
    player_input=player_input
)

# Display the narrative
print(narrative_text)

# Process any commands returned by the agents
if commands:
    results = agent_manager.process_commands(state_manager.state, commands)
    # Handle command results...

```

### File: web\server\server.py

```python
#!/usr/bin/env python3
"""
Web server for the RPG game using FastAPI.
Provides API endpoints and WebSocket functionality to interface with the game engine.
"""

import os
import sys
import json
import uuid
import logging
import asyncio
from typing import Dict, List, Optional, Any
# Import datetime directly - CRITICAL - must be at global level for exec() to work
from datetime import datetime

# Define datetime at global level to make it available to exec() context
datetime = datetime  # Redefine to ensure it's in the global namespace

# Add the project root to the path to import core modules
# Ensure we can find project root from any execution context
server_dir = os.path.dirname(os.path.abspath(__file__))
web_dir = os.path.dirname(server_dir)
project_root = os.path.dirname(web_dir)

# Insert project root at beginning of path to ensure correct imports
sys.path.insert(0, project_root)

# Print path for debugging
print(f"Project root: {project_root}")
print(f"Python path: {sys.path}")

# FastAPI imports
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, status, Body, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from starlette.responses import JSONResponse

# Import Pydantic BaseModel
from pydantic import BaseModel, Field

# Game engine imports
from core.base.engine import GameEngine
from core.base.state import GameState, PlayerState, WorldState
from core.base.commands import CommandResult
from core.utils.logging_config import get_logger
from core.llm.settings_manager import SettingsManager
from core.agents.base_agent import AgentContext
from core.agents.narrator import get_narrator_agent
from core.base.config import get_config as _get_config_singleton
import html as _html_escape_mod

# Configure logger
logger = get_logger("API")

# Active game sessions - mapping session_id to GameEngine instance
active_sessions: Dict[str, GameEngine] = {}

# Active WebSocket connections - mapping session_id to list of WebSocket connections
websocket_connections: Dict[str, List[WebSocket]] = {}

# Pending WS payloads to flush on first connect per session
pending_ws_payloads: Dict[str, List[dict]] = {}

# Session listeners to allow disconnecting/cleanup per session
session_listeners: Dict[str, Dict[str, Any]] = {}

from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, RedirectResponse
from pathlib import Path

# Get path to web client files
# Try multiple approaches to find the client directory
possible_paths = []

# First approach: Try using current working directory
cwd = os.getcwd()
client_dir_cwd = Path(cwd).joinpath('web', 'client')
possible_paths.append(("CWD", client_dir_cwd))

# Second approach: Try using relative path from server.py location
server_dir = Path(os.path.abspath(__file__)).parent
parent_dir = server_dir.parent.parent  # Go up two levels from server.py
client_dir_relative = parent_dir.joinpath('web', 'client')
possible_paths.append(("Relative", client_dir_relative))

# Check if any of the paths exist
client_dir = None
for path_type, path in possible_paths:
    logger.info(f"Trying to locate client directory using {path_type} approach: {path}")
    if path.exists():
        client_dir = path
        logger.info(f"Found client directory at: {client_dir}")
        break

# If no client directory found, raise an error
if client_dir is None:
    error_msg = f"Client directory not found. Tried the following paths: {[str(p[1]) for p in possible_paths]}"
    logger.error(error_msg)
    raise FileNotFoundError(error_msg)

# Create FastAPI application
app = FastAPI(
    title="RPG Game API",
    description="API for the RPG game web interface",
    version="0.1.0"
)

# Configure CORS for frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Adjust for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files directory - multiple mounts to handle different path references
app.mount("/static", StaticFiles(directory=str(client_dir)), name="static")
# Mount CSS and JS directories directly to support references without /static/ prefix
app.mount("/css", StaticFiles(directory=str(client_dir / "css")), name="css")
app.mount("/js", StaticFiles(directory=str(client_dir / "js")), name="js")
# Root path redirects to the web client
@app.get("/")
async def root():
    return FileResponse(str(client_dir / "index.html"))

# Helper function to scan for character icons
def get_character_icons():
    """Scan for character icons in the images/character_icons directory (flat)."""
    icons_dir = os.path.join(project_root, "images", "character_icons")
    os.makedirs(icons_dir, exist_ok=True)
    supported_extensions = [".png", ".jpg", ".jpeg", ".gif", ".svg"]
    icons = []
    try:
        for filename in os.listdir(icons_dir):
            if any(filename.lower().endswith(ext) for ext in supported_extensions):
                file_path = os.path.join(icons_dir, filename)
                url_path = f"/images/character_icons/{filename}"
                icons.append({"filename": filename, "path": file_path, "url": url_path})
    except Exception:
        pass
    icons.sort(key=lambda x: x["filename"]) 
    return icons

def get_character_icons_filtered(race: Optional[str], class_name: Optional[str], sex: Optional[str]):
    """Scan for icons in subfolder images/character_icons/<Race_Class> and filter by sex keywords."""
    from pathlib import Path
    safe_race = (race or "").replace(" ", "_")
    safe_class = (class_name or "").replace(" ", "_")
    base_dir = Path(project_root) / "images" / "character_icons"
    subdir = base_dir / f"{safe_race}_{safe_class}"
    supported = {".png", ".jpg", ".jpeg", ".gif", ".svg"}
    results: List[Dict[str, str]] = []
    if not safe_race or not safe_class:
        return results
    try:
        if not subdir.exists():
            return results
        sex_l = (sex or "").lower()
        for p in sorted(subdir.iterdir()):
            if p.is_file() and p.suffix.lower() in supported:
                name_lower = p.stem.lower()
                contains_male = "male" in name_lower
                contains_female = "female" in name_lower
                include = False
                if sex_l == "male":
                    include = contains_male and not contains_female
                elif sex_l == "female":
                    include = contains_female
                else:
                    include = contains_male or contains_female
                if include:
                    rel = f"/images/character_icons/{safe_race}_{safe_class}/{p.name}"
                    results.append({"filename": p.name, "path": str(p), "url": rel})
    except Exception as e:
        logger.warning(f"Error scanning filtered character icons: {e}")
    return results

# Mount images directory for character icons
try:
    images_dir = os.path.join(project_root, "images")
    os.makedirs(images_dir, exist_ok=True)
    os.makedirs(os.path.join(images_dir, "character_icons"), exist_ok=True)
    app.mount("/images", StaticFiles(directory=images_dir), name="images")
    logger.info(f"Mounted images directory at: {images_dir}")
except Exception as e:
    logger.error(f"Error mounting images directory: {e}")

# Simple OAuth2 password bearer for basic authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Model for creating a new game
class NewGameRequest(BaseModel):
    player_name: str = Field(..., description="Name of the player character")
    race: str = Field(default="Human", description="Race of the player character")
    path: str = Field(default="Wanderer", description="Class/path of the player character")
    background: str = Field(default="Commoner", description="Background/backstory seed (Origin description)")
    sex: str = Field(default="Male", description="Sex/gender of the player character")
    character_image: Optional[str] = Field(None, description="Path to character portrait image")
    use_llm: bool = Field(default=True, description="Whether to enable LLM functionality for this game")
    origin_id: Optional[str] = Field(default=None, description="Selected Origin ID")
    stats: Optional[Dict[str, int]] = Field(default=None, description="Allocated base stats mapping (e.g., {'STR':12,...})")
    
# Model for session information
class SessionInfo(BaseModel):
    session_id: str = Field(..., description="Unique game session ID")
    player_name: str = Field(..., description="Player character name")
    created_at: datetime = Field(..., description="Session creation time")
    race: Optional[str] = Field(None, description="Player character race")
    path: Optional[str] = Field(None, description="Player character class/path")
    background: Optional[str] = Field(None, description="Player character background")
    sex: Optional[str] = Field(None, description="Player character sex/gender")
    character_image: Optional[str] = Field(None, description="Path to character portrait image")
    llm_enabled: bool = Field(False, description="Whether LLM functionality is enabled")
    location: Optional[str] = Field(None, description="Current location")
    game_time: Optional[str] = Field(None, description="Current in-game time")
    calendar: Optional[str] = Field(None, description="Canonical calendar string (Era/Cycle/Phase/Tide/Span/Day)")
    
# Model for command request
class CommandRequest(BaseModel):
    command: str  # Game command to execute
    
# Model for save game request
class SaveGameRequest(BaseModel):
    save_name: Optional[str] = None  # Name for the save file

# Model for load game request
class LoadGameRequest(BaseModel):
    save_id: str  # ID of the save to load

# UI State response models (lightweight)
class UIResourceBar(BaseModel):
    current: float
    max: float

class UIPlayerHeader(BaseModel):
    name: str
    race: str
    path: str
    level: int = 1
    experience_current: int = 0
    experience_max: int = 100
    sex: Optional[str] = None
    portrait_url: Optional[str] = None

class UIStatEntry(BaseModel):
    name: str
    value: float
    base_value: float

class UIEquipmentEntry(BaseModel):
    slot: str
    item_id: Optional[str] = None
    item_name: Optional[str] = None
    icon_path: Optional[str] = None
    rarity: Optional[str] = None

class UIStatusEffectEntry(BaseModel):
    name: str
    duration: Optional[int] = None

class UIStateResponse(BaseModel):
    mode: str
    location: Optional[str] = None
    time: Optional[str] = None
    calendar: Optional[str] = None
    player: UIPlayerHeader
    resources: Dict[str, UIResourceBar]
    primary_stats: Dict[str, UIStatEntry]
    derived_stats: Dict[str, UIStatEntry]
    social_stats: Dict[str, UIStatEntry]
    other_stats: Dict[str, UIStatEntry]
    status_effects: List[UIStatusEffectEntry] = []
    equipment: List[UIEquipmentEntry] = []
    turn_order: List[str] = []
    initiative: Optional[float] = None
    journal: Dict[str, Any] = {}
    
# Model for save information
class SaveInfo(BaseModel):
    save_id: str  # Save ID
    save_name: str  # Save name
    save_time: datetime  # Save creation time
    player_name: str  # Player character name
    player_level: int  # Player character level
    location: str  # Current location

# Models for LLM settings management
class ProviderSettings(BaseModel):
    api_key: str = Field(default="", description="API key for the provider")
    organization_id: Optional[str] = Field(default="", description="Organization ID (if applicable)")
    enabled: bool = Field(default=True, description="Whether this provider is enabled")

class ProviderConfig(BaseModel):
    openai: ProviderSettings
    google: ProviderSettings
    openrouter: ProviderSettings

class AgentSettings(BaseModel):
    provider_type: str = Field(description="Provider type for this agent")
    model: str = Field(description="Model to use for this agent")
    temperature: float = Field(default=0.7, description="Temperature for generation")
    top_p: float = Field(default=1.0, description="Top-p sampling value")
    max_tokens: int = Field(default=1000, description="Maximum tokens to generate")
    enabled: bool = Field(default=True, description="Whether this agent is enabled")

class AgentConfig(BaseModel):
    narrator: AgentSettings
    rule_checker: AgentSettings
    context_evaluator: AgentSettings

class CreateSessionResponse(BaseModel):
    session_id: str
    created_at: datetime

class LLMSettingsResponse(BaseModel):
    providers: ProviderConfig
    agents: AgentConfig
    llm_enabled: bool = Field(description="Whether LLM functionality is enabled")

class ToggleLLMRequest(BaseModel):
    enabled: bool = Field(description="Whether to enable LLM functionality")
    
# Simple user database for demonstration
# In a real application, use a proper database and password hashing
USERS = {
    "admin": {
        "username": "admin",
        "password": "adminpassword",  # Use hashed passwords in production
        "disabled": False,
    }
}

# Character icon model
class CharacterIcon(BaseModel):
    filename: str = Field(..., description="Filename of the icon")
    path: str = Field(..., description="Path to the icon file")
    url: str = Field(..., description="URL to access the icon")

# Authentication dependency
async def get_current_user(token: str = Depends(oauth2_scheme)):
    """Get the current user from the token."""
    # In a real application, validate the JWT token
    # For demonstration, we'll just check if the token is a username in our database
    if token not in USERS:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    user = USERS[token]
    if user.get("disabled"):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Inactive user",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user

# Session validation dependency
async def get_game_engine(session_id: str = None):
    """Get the game engine for a session."""
    # For endpoints that require session ID in path
    if session_id:
        if session_id not in active_sessions:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Game session {session_id} not found",
            )
        return active_sessions[session_id]
    # For endpoints that should work without a session
    return None

# Authentication endpoint
@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """Login endpoint for obtaining access token."""
    user = USERS.get(form_data.username)
    if not user or user["password"] != form_data.password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    # In a real application, return a JWT token
    # For demonstration, we'll just return the username as the token
    return {"access_token": user["username"], "token_type": "bearer"}

# WebSocket connection manager for real-time game updates
class ConnectionManager:
    """
    Manages WebSocket connections for real-time game updates.
    """
    
    @staticmethod
    async def connect(websocket: WebSocket, session_id: str):
        """Connect a new WebSocket client."""
        await websocket.accept()
        if session_id not in websocket_connections:
            websocket_connections[session_id] = []
        websocket_connections[session_id].append(websocket)
        logger.info(f"WebSocket connected for session {session_id}")
    
    @staticmethod
    async def disconnect(websocket: WebSocket, session_id: str):
        """Disconnect a WebSocket client."""
        if session_id in websocket_connections and websocket in websocket_connections[session_id]:
            websocket_connections[session_id].remove(websocket)
            logger.info(f"WebSocket disconnected for session {session_id}")
    
    @staticmethod
    async def send_update(session_id: str, data: dict):
        """Send an update to all WebSocket clients for a session."""
        if session_id in websocket_connections:
            disconnected = []
            for websocket in websocket_connections[session_id]:
                try:
                    await websocket.send_json(data)
                except Exception as e:
                    logger.error(f"Error sending WebSocket update: {e}")
                    disconnected.append(websocket)
            
            # Remove disconnected WebSockets
            for websocket in disconnected:
                if websocket in websocket_connections[session_id]:
                    websocket_connections[session_id].remove(websocket)

# WebSocket endpoint for real-time game updates
@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    """WebSocket endpoint for real-time game updates."""
    await ConnectionManager.connect(websocket, session_id)
    try:
        # Send initial game state
        if session_id in active_sessions:
            engine = active_sessions[session_id]
            state = engine.state_manager.state
            await websocket.send_json({
                "type": "game_state",
                "data": {
                    "player": {
                        "name": state.player.name,
                        "level": state.player.level,
                        "location": state.world.current_location
                    },
                    "time": state.game_time.get_formatted_time(),
                    "game_running": engine.game_loop.is_running,
                }
            })
        
        # Flush any pending payloads that were buffered before the first WS client connected
        try:
            pending = pending_ws_payloads.get(session_id) or []
            if pending:
                for payload in pending:
                    try:
                        await websocket.send_json(payload)
                    except Exception as e:
                        logger.warning(f"Failed to flush pending WS payload: {e}")
                pending_ws_payloads[session_id] = []
        except Exception as e:
            logger.warning(f"Error flushing pending WS payloads: {e}")
        
        # Listen for WebSocket messages
        while True:
            # This will keep the connection open and handle disconnections
            data = await websocket.receive_text()
            # Process any WebSocket commands if needed
            # For now, we'll just use HTTP endpoints for commands
    except WebSocketDisconnect:
        await ConnectionManager.disconnect(websocket, session_id)

# API endpoints

@app.post("/api/session", response_model=CreateSessionResponse)
async def create_session():
    """Create a session without starting or loading a game."""
    try:
        session_id = str(uuid.uuid4())
        engine = GameEngine()
        # Register session early
        active_sessions[session_id] = engine
        websocket_connections[session_id] = []
        pending_ws_payloads[session_id] = []
        # Attach listeners so outputs are captured once a stream attaches
        _attach_engine_listeners(session_id, engine)
        logger.info(f"Created empty session {session_id}")
        return CreateSessionResponse(session_id=session_id, created_at=datetime.now())
    except Exception as e:
        logger.error(f"Error creating session: {e}")
        raise HTTPException(status_code=500, detail="Failed to create session")

# Helper to attach engine listeners for a session
def _attach_engine_listeners(session_id: str, engine: GameEngine):
    """Attach engine signals to websocket broadcast for the given session."""

    # Palette loader for combat log coloring (from Python config)
    def _load_combat_palette():
        pal = {}
        try:
            cfg = _get_config_singleton()
            raw = cfg.get_all("combat_display_settings") or {}
            # map keys we care about (provide defaults)
            defaults = {
                "color_log_damage": "#ececec",
                "color_log_heal": "#ececec",
                "color_log_miss": "#ececec",
                "color_log_turn": "#ececec",
                "color_log_round": "#ececec",
                "color_log_system_message": "#ececec",
                "color_log_narrative": "#ececec",
                "color_log_default": "#ececec",
            }
            for k, v in defaults.items():
                pal[k] = raw.get(k, v)
        except Exception:
            # Fallback hard defaults (light grey)
            pal = {
                "color_log_damage": "#ececec",
                "color_log_heal": "#ececec",
                "color_log_miss": "#ececec",
                "color_log_turn": "#ececec",
                "color_log_round": "#ececec",
                "color_log_system_message": "#ececec",
                "color_log_narrative": "#ececec",
                "color_log_default": "#ececec",
            }
        return pal

    _combat_palette_cache = _load_combat_palette()

    def _color_for_log_line(text: str, event_type, source_step: str = None) -> str:
        t = (text or "").strip()
        low = t.lower()
        pal = _combat_palette_cache
        try:
            # Round/turn markers
            if t.startswith("Round ") and t.endswith("begins!"): return pal.get("color_log_round")
            if t.startswith("It is now "): return pal.get("color_log_turn")
            if t.startswith("Turn order:"): return pal.get("color_log_turn")
            # Semantics
            if ("takes" in low and "damage" in low) or ("raw damage" in low) or ("critical hit" in low):
                return pal.get("color_log_damage")
            if ("recovers" in low or "regains" in low):
                return pal.get("color_log_heal")
            if ("misses" in low):
                return pal.get("color_log_miss")
            # Step hints
            if isinstance(source_step, str):
                s = source_step.upper()
                if "ADVANCING_TURN" in s: return pal.get("color_log_turn")
            # System messages fallback
            try:
                from core.orchestration.events import DisplayEventType
                if event_type == DisplayEventType.SYSTEM_MESSAGE:
                    return pal.get("color_log_system_message")
            except Exception:
                pass
            return pal.get("color_log_default")
        except Exception:
            return pal.get("color_log_default")

    # Clean existing listeners
    try:
        if session_id in session_listeners:
            lst = session_listeners.pop(session_id)
            # Attempt to disconnect prior connections if present
            try:
                if lst.get('stats_conn') and engine.state_manager.stats_manager:
                    engine.state_manager.stats_manager.stats_changed.disconnect(lst['stats_conn'])
            except Exception:
                pass
            try:
                if lst.get('orch_conn'):
                    engine.orchestrated_event_to_ui.disconnect(lst['orch_conn'])
            except Exception:
                pass
            try:
                if lst.get('out_conn'):
                    engine.output_generated.disconnect(lst['out_conn'])
            except Exception:
                pass
    except Exception:
        pass

    def _emit_ws(payload: dict):
        try:
            conns = websocket_connections.get(session_id) or []
            if not conns:
                # Buffer until a client connects
                lst = pending_ws_payloads.setdefault(session_id, [])
                lst.append(payload)
            else:
                asyncio.create_task(ConnectionManager.send_update(session_id, payload))
        except Exception as e:
            logger.warning(f"WS emit failed: {e}")

    # Stats changed -> broadcast
    def on_stats_changed(stats_data):
        _emit_ws({"type": "stats_changed", "data": stats_data})
    stats_conn = None
    try:
        if engine.state_manager and engine.state_manager.stats_manager:
            engine.state_manager.stats_manager.stats_changed.connect(on_stats_changed)
            stats_conn = on_stats_changed
    except Exception as e:
        logger.warning(f"Failed connecting stats_changed listener: {e}")

    # Orchestrated events -> broadcast specific types
    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget
    def on_orchestrated_event(event_obj):
        try:
            if not isinstance(event_obj, DisplayEvent):
                return
            t = event_obj.type
            target = getattr(event_obj, 'target_display', None)
            # Map to websocket event types
            if t == DisplayEventType.TURN_ORDER_UPDATE:
                _emit_ws({"type": "turn_order_update", "data": event_obj.content})
            elif t == DisplayEventType.UI_BAR_UPDATE_PHASE1:
                _emit_ws({"type": "ui_bar_update_phase1", "data": event_obj.metadata or {}})
            elif t == DisplayEventType.UI_BAR_UPDATE_PHASE2:
                _emit_ws({"type": "ui_bar_update_phase2", "data": event_obj.metadata or {}})
            elif t == DisplayEventType.COMBAT_LOG_SET_HTML:
                _emit_ws({"type": "combat_log_set_html", "data": {"html": event_obj.content}})
            else:
                # Route by target display and event type
                if target == DisplayTarget.COMBAT_LOG:
                    from core.orchestration.events import DisplayEventType as _DET
                    # Narration prose goes to main output
                    if t in (_DET.NARRATIVE_GENERAL, _DET.NARRATIVE_ATTEMPT, _DET.NARRATIVE_IMPACT):
                        _emit_ws({
                            "type": "narrative",
                            "data": {"role": event_obj.role or "gm", "text": event_obj.content, "gradual": bool(getattr(event_obj, 'gradual_visual_display', False))}
                        })
                    else:
                        # Mechanics/system lines appended to Combat tab with inline color from Python config
                        plain_text = str(event_obj.content) if event_obj.content is not None else ""
                        color = _color_for_log_line(plain_text, t, getattr(event_obj, 'source_step', None))
                        # Escape then inject color
                        esc = _html_escape_mod.escape(plain_text)
                        html_line = f"<span style=\"color:{color}\">{esc}</span>"
                        line_payload = {
                            "text": plain_text,
                            "html": html_line,
                            "kind": getattr(t, 'name', str(t)),
                            "role": event_obj.role or "system",
                            "step": getattr(event_obj, 'source_step', None)
                        }
                        _emit_ws({"type": "combat_log_append", "data": line_payload})
                else:
                    # Default: stream as narrative to main output
                    from core.orchestration.events import DisplayEventType as _DET2
                    if t in (_DET2.SYSTEM_MESSAGE, _DET2.NARRATIVE_GENERAL, _DET2.NARRATIVE_ATTEMPT, _DET2.NARRATIVE_IMPACT):
                        _emit_ws({
                            "type": "narrative",
                            "data": {"role": event_obj.role or "system", "text": event_obj.content, "gradual": bool(getattr(event_obj, 'gradual_visual_display', False))}
                        })
                    # else: ignore other internal events

            # IMPORTANT: In the web server we don't have a Qt UI to acknowledge visual completion.
            # Without an acknowledgement, the CombatOutputOrchestrator will never advance its queue,
            # and the CombatManager won't resume (no QTimer event loop here). We therefore
            # immediately acknowledge the visual completion and manually trigger the inter-step
            # timeout using asyncio to keep the combat flow progressing in headless mode.
            try:
                orch = getattr(engine, "_combat_orchestrator", None)
                if orch is not None:
                    # Acknowledge the visual display completion for this event
                    try:
                        orch._handle_visual_display_complete()
                    except Exception:
                        # Safe to ignore; orchestrator may not be waiting for visual on some events
                        pass
                    # Manually schedule inter-step timeout since QTimer won't fire in FastAPI
                    async def _advance_after_delay(delay_ms: int):
                        try:
                            import asyncio as _asyncio
                            # Bound the delay to a small range to avoid stalling
                            d = max(0, int(delay_ms)) / 1000.0 if delay_ms is not None else 0.0
                            # Keep very small delays from being 0 to ensure scheduling
                            if d > 0:
                                await _asyncio.sleep(d)
                            # 1) Nudge the orchestrator's delay timeout (normally fired by QTimer)
                            try:
                                orch._on_inter_step_delay_timeout()
                            except Exception:
                                pass
                            # 2) Directly resume the CombatManager step (bypass Qt timers)
                            try:
                                st = getattr(engine, 'state_manager', None)
                                gs = getattr(st, 'state', None) if st else None
                                cm = getattr(gs, 'combat_manager', None) if gs else None
                                if cm is not None:
                                    try:
                                        # Mark as no longer waiting and process next step
                                        setattr(cm, 'waiting_for_display_completion', False)
                                    except Exception:
                                        pass
                                    try:
                                        cm.process_combat_step(engine)
                                    except Exception:
                                        # Do not crash server if CM processing throws
                                        pass
                            except Exception:
                                pass
                        except Exception:
                            pass
                    try:
                        delay = getattr(orch, "config_delay_ms", 0) or 0
                    except Exception:
                        delay = 0
                    try:
                        asyncio.create_task(_advance_after_delay(delay))
                    except Exception:
                        # If the event loop is not available for some reason, fall back to immediate call
                        try:
                            orch._on_inter_step_delay_timeout()
                        except Exception:
                            pass
            except Exception:
                # Never let WS event handling crash due to ack issues
                pass
        except Exception as e:
            logger.warning(f"Error handling orchestrated event for WS: {e}")
            # Without an acknowledgement, the CombatOutputOrchestrator will never advance its queue,
            # and the CombatManager won't resume (no QTimer event loop here). We therefore
            # immediately acknowledge the visual completion and manually trigger the inter-step
            # timeout using asyncio to keep the combat flow progressing in headless mode.
            try:
                orch = getattr(engine, "_combat_orchestrator", None)
                if orch is not None:
                    # Acknowledge the visual display completion for this event
                    try:
                        orch._handle_visual_display_complete()
                    except Exception:
                        # Safe to ignore; orchestrator may not be waiting for visual on some events
                        pass
                    # Manually schedule inter-step timeout since QTimer won't fire in FastAPI
                    async def _advance_after_delay(delay_ms: int):
                        try:
                            import asyncio as _asyncio
                            # Bound the delay to a small range to avoid stalling
                            d = max(0, int(delay_ms)) / 1000.0 if delay_ms is not None else 0.0
                            # Keep very small delays from being 0 to ensure scheduling
                            if d > 0:
                                await _asyncio.sleep(d)
                            # 1) Nudge the orchestrator's delay timeout (normally fired by QTimer)
                            try:
                                orch._on_inter_step_delay_timeout()
                            except Exception:
                                pass
                            # 2) Directly resume the CombatManager step (bypass Qt timers)
                            try:
                                st = getattr(engine, 'state_manager', None)
                                gs = getattr(st, 'state', None) if st else None
                                cm = getattr(gs, 'combat_manager', None) if gs else None
                                if cm is not None:
                                    try:
                                        # Mark as no longer waiting and process next step
                                        setattr(cm, 'waiting_for_display_completion', False)
                                    except Exception:
                                        pass
                                    try:
                                        cm.process_combat_step(engine)
                                    except Exception:
                                        # Do not crash server if CM processing throws
                                        pass
                            except Exception:
                                pass
                        except Exception:
                            pass
                    try:
                        delay = getattr(orch, "config_delay_ms", 0) or 0
                    except Exception:
                        delay = 0
                    try:
                        asyncio.create_task(_advance_after_delay(delay))
                    except Exception:
                        # If the event loop is not available for some reason, fall back to immediate call
                        try:
                            orch._on_inter_step_delay_timeout()
                        except Exception:
                            pass
            except Exception:
                # Never let WS event handling crash due to ack issues
                pass
        except Exception as e:
            logger.warning(f"Error handling orchestrated event for WS: {e}")
    orch_conn = None
    try:
        engine.orchestrated_event_to_ui.connect(on_orchestrated_event)
        orch_conn = on_orchestrated_event
    except Exception as e:
        logger.warning(f"Failed connecting orchestrator listener: {e}")

    # Engine generic outputs (welcome/help/etc.) -> broadcast as narrative
    def on_output_generated(role: str, content: str):
        try:
            # Treat non-system narrations (e.g., GM/story text) as gradual by default to match Python GUI
            is_non_system = (str(role).lower() != 'system')
            _emit_ws({"type": "narrative", "data": {"role": role, "text": content, "gradual": is_non_system}})
        except Exception as e:
            logger.warning(f"Error handling engine.output_generated for WS: {e}")
    out_conn = None
    try:
        engine.output_generated.connect(on_output_generated)
        out_conn = on_output_generated
    except Exception as e:
        logger.warning(f"Failed connecting output_generated listener: {e}")

    session_listeners[session_id] = {"stats_conn": stats_conn, "orch_conn": orch_conn, "out_conn": out_conn}

def _cleanup_session(session_id: str):
    """Clean up a session's resources."""
    try:
        # Cleanup engine listeners
        _detach_engine_listeners(session_id)
        # Remove from active sessions
        if session_id in active_sessions:
            del active_sessions[session_id]
        # Close WebSocket connections
        if session_id in websocket_connections:
            conns = websocket_connections[session_id]
            for ws in conns:
                try:
                    if not ws.client_state.disconnected:
                        asyncio.create_task(ws.close())
                except Exception:
                    pass
            del websocket_connections[session_id]
        # Clear pending payloads
        if session_id in pending_ws_payloads:
            del pending_ws_payloads[session_id]
        logger.info(f"Cleaned up session {session_id}")
    except Exception as e:
        logger.warning(f"Error cleaning up session {session_id}: {e}")

@app.delete("/api/session/{session_id}")
async def cleanup_session(session_id: str):
    """Clean up a specific session."""
    try:
        _cleanup_session(session_id)
        return {"status": "success", "message": f"Session {session_id} cleaned up"}
    except Exception as e:
        logger.error(f"Error cleaning up session {session_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error cleaning up session: {str(e)}"
        )

@app.post("/api/new_game", response_model=SessionInfo)
async def create_new_game(request: NewGameRequest):
    """Create a new game session."""
    try:
        session_id = str(uuid.uuid4())
        engine = GameEngine()
        # Pre-register the session so WS/connects and later calls see it immediately
        active_sessions[session_id] = engine
        websocket_connections[session_id] = []
        # Clear any pending payloads for this new session
        pending_ws_payloads[session_id] = []
        # Attach listeners BEFORE starting the game to catch welcome/help/narration
        _attach_engine_listeners(session_id, engine)
        # Set LLM preference before start (default is True, but honor request)
        try:
            engine.set_llm_enabled(bool(request.use_llm))
        except Exception:
            pass
        # Start new game using full parameters
        engine.start_new_game(
            player_name=request.player_name,
            race=request.race,
            path=request.path,
            background=request.background,
            sex=request.sex,
            character_image=request.character_image,
            stats=request.stats,
            origin_id=request.origin_id
        )
        # Re-attach listeners in case managers initialized during start
        try:
            _attach_engine_listeners(session_id, engine)
        except Exception:
            pass
        logger.info(f"Created new game session {session_id} for player {request.player_name}")
        state = engine.state_manager.state
        return SessionInfo(
            session_id=session_id,
            player_name=request.player_name,
            created_at=datetime.now(),
            race=state.player.race,
            path=state.player.path,
            background=state.player.background,
            sex=state.player.sex,
            character_image=state.player.character_image,
            llm_enabled=engine._use_llm,
            location=state.player.current_location,
            game_time=(state.world.time_of_day if state and getattr(state, 'world', None) else None),
            calendar=(getattr(state.world, 'calendar_string', None) if state and getattr(state, 'world', None) else None)
        )
    except Exception as e:
        logger.error(f"Error creating new game: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating new game: {str(e)}"
        )

@app.post("/api/command/{session_id}")
async def process_command(session_id: str, request: CommandRequest, engine: GameEngine = Depends(get_game_engine)):
    """Process a game command."""
    try:
        # Process the command using the game engine
        result = engine.process_command(request.command)
        
        # Get the updated game state
        state = engine.state_manager.state
        
        # Prepare response data
        response_data = {
            "status": result.status.name,
            "message": result.message,
            "data": result.data or {},
            "state": {
                "player": {
                    "name": state.player.name,
                    "level": state.player.level,
                    "location": state.world.current_location
                },
                "time": (state.world.time_of_day if getattr(state, 'world', None) else None),
                "calendar": (getattr(state.world, 'calendar_string', None) if getattr(state, 'world', None) else None),
                "game_running": engine.game_loop.is_running,
            }
        }
        
        # Add a marker to the message to prevent duplicate display
        response_data["source"] = "http_response"
        
        # Send update to WebSocket clients only for events that should be broadcast
        # This prevents duplicate outputs when using LLM commands
        # Be robust when result.data is None
        try:
            data_dict = result.data or {}
        except Exception:
            data_dict = {}
        result.data = data_dict
        should_broadcast = (result.status.name != "SUCCESS") or ("websocket_sent" not in data_dict)
        if should_broadcast:
            # Mark that we've broadcast this via websocket
            data_dict["websocket_sent"] = True
            
            # Create a websocket-specific copy of the data
            ws_data = response_data.copy()
            ws_data["source"] = "websocket"
            
            # Send via websocket
            asyncio.create_task(ConnectionManager.send_update(session_id, {
                "type": "command_result",
                "data": ws_data
            }))
        
        return response_data
    except Exception as e:
        logger.error(f"Error processing command: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing command: {str(e)}"
        )

@app.post("/api/save_game/{session_id}")
async def save_game(session_id: str, request: SaveGameRequest, engine: GameEngine = Depends(get_game_engine)):
    """Save the current game state."""
    try:
        # Determine filename
        save_name = (request.save_name or "").strip() or None
        # Use engine lifecycle to save (writes JSON in /saves)
        saved_path = engine.save_game(save_name)
        if not saved_path:
            raise RuntimeError("Save failed")
        import os as _os
        save_id = _os.path.basename(saved_path)
        logger.info(f"Saved game {save_id} for session {session_id}")
        return {
            "status": "success",
            "message": f"Game saved as '{save_name or save_id}'",
            "save_id": save_id,
            "save_name": save_name or _os.path.splitext(save_id)[0]
        }
    except Exception as e:
        logger.error(f"Error saving game: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error saving game: {str(e)}"
        )

@app.post("/api/load_game/{session_id}")
async def load_game(session_id: str, request: LoadGameRequest, engine: GameEngine = Depends(get_game_engine)):
    """Load a saved game state."""
    try:
        # Ensure listeners are attached BEFORE loading so welcome-back and reintro outputs are captured/buffered
        try:
            _attach_engine_listeners(session_id, engine)
        except Exception:
            pass

        # Load the game
        success_state = engine.load_game(request.save_id)
        if success_state is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Save file '{request.save_id}' not found or is invalid"
            )
        
        # Get the updated game state
        state = engine.state_manager.state
        
        # Prepare response data
        response_data = {
            "status": "success",
            "message": "Game loaded successfully",
            "state": {
                "player": {
                    "name": state.player.name,
                    "level": state.player.level,
                    "location": state.world.current_location
                },
                "time": (state.world.time_of_day if getattr(state, 'world', None) else None),
                "calendar": (getattr(state.world, 'calendar_string', None) if getattr(state, 'world', None) else None),
                "game_running": engine.game_loop.is_running,
                # Include mode explicitly for clients that want to react immediately
                "mode": (getattr(getattr(state, 'current_mode', None), 'name', str(getattr(state, 'current_mode', 'NARRATIVE'))) if state else 'NARRATIVE')
            }
        }
        
        # Re-attach listeners (in case any signal sources were recreated by load) and send update
        try:
            _attach_engine_listeners(session_id, engine)
        except Exception:
            pass
        asyncio.create_task(ConnectionManager.send_update(session_id, {
            "type": "game_loaded",
            "data": response_data
        }))
        
        # If loading into combat, send current combat log HTML via WebSocket
        try:
            raw_mode = getattr(state, 'current_mode', None)
            mode_str = raw_mode.name if hasattr(raw_mode, 'name') else str(raw_mode) if raw_mode else 'NARRATIVE'
            if mode_str == 'COMBAT':
                # Try to get combat log HTML from combat manager
                cm = getattr(engine, 'combat_manager', None)
                if cm and hasattr(cm, 'get_combat_log_html'):
                    combat_html = cm.get_combat_log_html()
                    if combat_html:
                        asyncio.create_task(ConnectionManager.send_update(session_id, {
                            "type": "combat_log_set_html",
                            "data": {"html": combat_html}
                        }))
        except Exception as e:
            logger.warning(f"Could not send combat log HTML after load: {e}")
        
        logger.info(f"Loaded game {request.save_id} for session {session_id}")
        
        return response_data
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error loading game: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error loading game: {str(e)}"
        )

@app.get("/api/ui/state/{session_id}", response_model=UIStateResponse)
async def get_ui_state(session_id: str, engine: GameEngine = Depends(get_game_engine)):
    """Aggregate UI state for the right panel and status bar to mimic Py GUI."""
    try:
        state = engine.state_manager.state
        if not state:
            raise HTTPException(status_code=404, detail="No active state")

        # Player header
        player = state.player
        sm = engine.state_manager.stats_manager
        level = getattr(sm, 'level', 1) if sm else 1
        header = UIPlayerHeader(
            name=getattr(player, 'name', 'Unknown'),
            race=getattr(player, 'race', 'Unknown'),
            path=getattr(player, 'path', 'Unknown'),
            level=level,
            sex=getattr(player, 'sex', None),
            experience_current=0,
            experience_max=100,
            portrait_url=getattr(player, 'character_image', None)
        )

        # Resources
        resources: Dict[str, UIResourceBar] = {}
        if sm:
            from core.stats.stats_base import DerivedStatType
            def rb(current_t, max_t):
                cur = sm.get_current_stat_value(current_t)
                mx = sm.get_stat_value(max_t)
                return UIResourceBar(current=cur, max=mx)
            resources['health'] = rb(DerivedStatType.HEALTH, DerivedStatType.MAX_HEALTH)
            resources['mana'] = rb(DerivedStatType.MANA, DerivedStatType.MAX_MANA)
            resources['stamina'] = rb(DerivedStatType.STAMINA, DerivedStatType.MAX_STAMINA)

        # Stats
        primary_stats: Dict[str, UIStatEntry] = {}
        derived_stats: Dict[str, UIStatEntry] = {}
        social_stats: Dict[str, UIStatEntry] = {}
        other_stats: Dict[str, UIStatEntry] = {}
        if sm:
            all_stats = sm.get_all_stats()
            for key, data in (all_stats.get('primary') or {}).items():
                primary_stats[key] = UIStatEntry(name=str(data.get('name', key)), value=float(data.get('value', 0)), base_value=float(data.get('base_value', 0)))
            for key, data in (all_stats.get('combat') or {}).items():
                derived_stats[key] = UIStatEntry(name=str(data.get('name', key)), value=float(data.get('value', 0)), base_value=float(data.get('base_value', 0)))
            for key, data in (all_stats.get('social') or {}).items():
                social_stats[key] = UIStatEntry(name=str(data.get('name', key)), value=float(data.get('value', 0)), base_value=float(data.get('base_value', 0)))
            for key, data in (all_stats.get('other') or {}).items():
                other_stats[key] = UIStatEntry(name=str(data.get('name', key)), value=float(data.get('value', 0)), base_value=float(data.get('base_value', 0)))

        # Status effects
        status_effects: List[UIStatusEffectEntry] = []
        if sm and hasattr(sm, 'get_status_effects'):
            for eff in sm.get_status_effects():
                try:
                    status_effects.append(UIStatusEffectEntry(name=getattr(eff, 'name', 'Effect'), duration=getattr(eff, 'remaining_turns', None)))
                except Exception:
                    continue

        # Equipment
        from core.inventory.item_manager import get_inventory_manager
        inv = get_inventory_manager()
        equipment_entries: List[UIEquipmentEntry] = []
        try:
            eq = getattr(inv, 'equipment', {})
            for slot, val in (eq.items() if hasattr(eq, 'items') else []):
                # Skip empty slots
                if not val:
                    continue

                slot_name = slot.value if hasattr(slot, 'value') else str(slot)
                item_obj = None
                item_id_str = None
                item_name = None
                icon_path = None
                rarity = None
                
                try:
                    # val may be an Item object or a string ID
                    # Prefer duck-typing so we don't import Item here
                    if hasattr(val, 'id') and hasattr(val, 'name'):
                        item_obj = val
                    else:
                        item_obj = inv.get_item(val)
                    if item_obj:
                        item_id_str = getattr(item_obj, 'id', None) or (str(val) if isinstance(val, str) else None)
                        item_name = getattr(item_obj, 'name', None)
                        icon_path = getattr(item_obj, 'icon_path', None)
                        rarity_obj = getattr(item_obj, 'rarity', None)
                        if rarity_obj:
                            rarity = rarity_obj.value if hasattr(rarity_obj, 'value') else str(rarity_obj)
                        equipment_entries.append(UIEquipmentEntry(
                            slot=slot_name,
                            item_id=item_id_str,
                            item_name=item_name,
                            icon_path=icon_path,
                            rarity=rarity
                        ))
                        logger.debug(f"Added equipment: {slot_name} -> {item_name} (id: {item_id_str})")
                    else:
                        logger.warning(f"Equipment slot {slot_name} had value but item could not be resolved: {val}")
                except Exception as e:
                    logger.warning(f"Error processing equipped entry for slot {slot_name}: {e}")
                    continue
        except Exception as e:
            logger.error(f"Error building equipment list: {e}", exc_info=True)

        # Mode, location, time (ensure mode is a plain string for clients)
        raw_mode = getattr(state, 'current_mode', 'NARRATIVE')
        mode = None
        try:
            mode = raw_mode.name if hasattr(raw_mode, 'name') else str(raw_mode)
        except Exception:
            mode = 'NARRATIVE'
        location = getattr(player, 'current_location', None)
        # Provide narrative time-of-day period for UI instead of exact clock and calendar string
        try:
            game_time = state.world.time_of_day if getattr(state, 'world', None) else None
            calendar_str = None
            if getattr(state, 'world', None):
                try:
                    calendar_str = getattr(state.world, 'calendar_string', None)
                except Exception:
                    calendar_str = None
                if not calendar_str:
                    # Fallbacks to ensure non-empty string
                    calendar_str = getattr(state.world, 'game_date', None) or ''
        except Exception:
            game_time = None
            calendar_str = ''

        # Combat info (basic)
        turn_order: List[str] = []
        initiative = None
        try:
            cm = getattr(state, 'combat_manager', None)
            if cm and mode == 'COMBAT':
                # If combat manager exposes turn order list of names
                order = getattr(cm, 'turn_order', [])
                turn_order = [str(getattr(e, 'name', e)) for e in order] if isinstance(order, list) else []
                initiative = None
        except Exception:
            pass

        journal = getattr(state, 'journal', {}) or {}

        return UIStateResponse(
            mode=mode,
            location=location,
            time=game_time,
            calendar=calendar_str,
            player=header,
            resources=resources,
            primary_stats=primary_stats,
            derived_stats=derived_stats,
            social_stats=social_stats,
            other_stats=other_stats,
            status_effects=status_effects,
            equipment=equipment_entries,
            turn_order=turn_order,
            initiative=initiative,
            journal=journal,
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error building UI state: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Error building UI state")


@app.get("/api/inventory/{session_id}")
async def get_inventory_state(session_id: str, engine: GameEngine = Depends(get_game_engine)):
    """Return inventory listing, equipped flags, and currency/weight."""
    try:
        from core.inventory.item_manager import get_inventory_manager
        inv = get_inventory_manager()
        items = []
        for item in getattr(inv, 'items', []):
            try:
                rarity_obj = getattr(item, 'rarity', None)
                rarity = rarity_obj.value if hasattr(rarity_obj, 'value') else str(rarity_obj) if rarity_obj else 'common'
                items.append({
                    'id': item.id,
                    'name': item.name,
                    'type': item.item_type.value if hasattr(item.item_type, 'value') else str(item.item_type),
                    'description': getattr(item, 'description', ''),
                    'count': getattr(item, 'quantity', 1),
                    'quantity': getattr(item, 'quantity', 1),
                    'equipped': bool(inv.is_item_equipped(item.id)),
                    'icon_path': getattr(item, 'icon_path', None),
                    'rarity': rarity,
                    'is_quest_item': getattr(item, 'is_quest_item', False),
                    'is_equippable': getattr(item, 'is_equippable', False),
                    'is_consumable': getattr(item, 'is_consumable', False),
                    'durability': getattr(item, 'durability', None),
                    'current_durability': getattr(item, 'current_durability', None)
                })
            except Exception:
                continue
        currency = getattr(inv, 'currency', None)
        money = {'gold': 0, 'silver': 0, 'copper': 0}
        if currency:
            money['gold'] = getattr(currency, 'gold', 0)
            money['silver'] = getattr(currency, 'silver', 0)
            total_copper = getattr(currency, '_copper', 0)
            cps = getattr(currency, '_copper_per_silver', 100)
            money['copper'] = total_copper % cps
        current_weight = getattr(inv, 'get_current_weight', lambda: 0.0)()
        weight_limit = getattr(inv, 'weight_limit', 0.0)
        return {
            'items': items,
            'currency': money,
            'weight': {'current': current_weight, 'max': weight_limit}
        }
    except Exception as e:
        logger.error(f"Inventory state error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Inventory state error")


class InventoryActionRequest(BaseModel):
    item_id: Optional[str] = None

    slot: Optional[str] = None
@app.post("/api/inventory/equip/{session_id}")
async def api_inventory_equip(session_id: str, req: InventoryActionRequest, engine: GameEngine = Depends(get_game_engine)):
    if not req.item_id:
        raise HTTPException(status_code=400, detail="item_id required")
    try:
        from core.inventory.item_manager import get_inventory_manager
        from core.inventory.item_enums import EquipmentSlot
        inv = get_inventory_manager()
        preferred_slot = None
        if req.slot:
            try:
                preferred_slot = EquipmentSlot(str(req.slot).lower().replace(' ', '_'))
            except Exception:
                preferred_slot = str(req.slot)
        ok = inv.equip_item(req.item_id, preferred_slot=preferred_slot)
        if not ok:
            raise HTTPException(status_code=400, detail="Could not equip item")
        return {'status': 'SUCCESS', 'message': 'Equipped', 'state_updated': True}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Equip API error: {e}")
        raise HTTPException(status_code=500, detail="Equip failed")

@app.post("/api/inventory/unequip/{session_id}")
async def api_inventory_unequip(session_id: str, req: InventoryActionRequest, engine: GameEngine = Depends(get_game_engine)):
    if not req.slot and not req.item_id:
        raise HTTPException(status_code=400, detail="slot or item_id required")
    try:
        from core.inventory.item_manager import get_inventory_manager
        from core.inventory.item_enums import EquipmentSlot
        inv = get_inventory_manager()
        # Determine slot to unequip
        target_slot = None
        if req.slot:
            try:
                target_slot = EquipmentSlot(str(req.slot).lower().replace(' ', '_'))
            except Exception:
                target_slot = None
        if not target_slot and req.item_id:
            slots = inv.get_equipped_slots_for_item(req.item_id)
            target_slot = slots[0] if slots else None
        if not target_slot:
            raise HTTPException(status_code=400, detail="Item not equipped")
        removed_id = inv.unequip_item(target_slot)
        if not removed_id:
            raise HTTPException(status_code=400, detail="Nothing to unequip")
        return {'status': 'SUCCESS', 'message': 'Unequipped', 'state_updated': True}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Unequip API error: {e}")
        raise HTTPException(status_code=500, detail="Unequip failed")

@app.post("/api/inventory/use/{session_id}")
async def api_inventory_use(session_id: str, req: InventoryActionRequest, engine: GameEngine = Depends(get_game_engine)):
    if not req.item_id:
        raise HTTPException(status_code=400, detail="item_id required")
    result = engine.process_command(f"use {req.item_id}")
    return {'status': result.status.name, 'message': result.message, 'state_updated': True}

@app.post("/api/inventory/drop/{session_id}")
async def api_inventory_drop(session_id: str, req: InventoryActionRequest, engine: GameEngine = Depends(get_game_engine)):
    if not req.item_id:
        raise HTTPException(status_code=400, detail="item_id required")
    result = engine.process_command(f"drop {req.item_id}")
    return {'status': result.status.name, 'message': result.message, 'state_updated': True}


# Item details endpoint for Examine dialog
@app.get("/api/items/{session_id}/{item_id}")
async def get_item_details(session_id: str, item_id: str, engine: GameEngine = Depends(get_game_engine)):
    try:
        from core.inventory.item_manager import get_inventory_manager
        inv = get_inventory_manager()
        item = inv.get_item(item_id)
        if not item:
            raise HTTPException(status_code=404, detail="Item not found")
        # Build a rich detail dict
        def to_name(val):
            try:
                return val.name if hasattr(val, 'name') else str(val)
            except Exception:
                return str(val)
        details: Dict[str, Any] = {
            'id': getattr(item, 'id', None),
            'name': getattr(item, 'name', '?'),
            'item_type': getattr(getattr(item, 'item_type', None), 'value', str(getattr(item, 'item_type', '?'))),
            'description': getattr(item, 'description', ''),
            'weight': getattr(item, 'weight', None),
            'value': getattr(item, 'value', None),
            'quantity': getattr(item, 'quantity', 1),
            'is_stackable': getattr(item, 'is_stackable', False),
            'stack_limit': getattr(item, 'stack_limit', None),
            'durability': getattr(item, 'durability', None),
            'current_durability': getattr(item, 'current_durability', None),
            'equip_slots': [getattr(s, 'value', str(s)) for s in (getattr(item, 'equip_slots', []) or [])],
            'rarity': getattr(getattr(item, 'rarity', None), 'value', None),
            'tags': list(getattr(item, 'tags', []) or []),
            'custom_properties': dict(getattr(item, 'custom_properties', {}) or {}),
            'known_properties': list(getattr(item, 'known_properties', []) or []),
        }
        # Stats/effects if present
        stats_list = []
        try:
            for st in getattr(item, 'stats', []) or []:
                stats_list.append({
                    'name': getattr(st, 'name', None),
                    'display_name': getattr(st, 'display_name', None),
                    'value': getattr(st, 'value', None),
                    'is_percentage': getattr(st, 'is_percentage', False)
                })
        except Exception:
            pass
        details['stats'] = stats_list
        dice_list = []
        try:
            for eff in getattr(item, 'dice_roll_effects', []) or []:
                dice_list.append({
                    'dice_notation': getattr(eff, 'dice_notation', None),
                    'effect_type': getattr(eff, 'effect_type', None),
                    'description': getattr(eff, 'description', None)
                })
        except Exception:
            pass
        details['dice_roll_effects'] = dice_list
        return details
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting item details: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Error getting item details")

@app.get("/api/list_saves")
async def list_saves():
    """List available JSON saves from the /saves directory (GUI-compatible)."""
    try:
        from core.base.state.state_manager import get_state_manager as _get_state_manager
        sm = _get_state_manager()
        saves_raw = sm.get_available_saves() or []
        save_list = []
        for s in saves_raw:
            try:
                filename = s.get("filename") or ""
                player_name = s.get("player_name", "Unknown")
                player_level = s.get("level", 1)
                location = s.get("location", "Unknown")
                ts = s.get("last_saved_at") or s.get("created_at") or 0
                try:
                    # If ts is ISO string, try to parse; else assume epoch seconds
                    if isinstance(ts, str):
                        dt = datetime.fromisoformat(ts)
                        epoch = dt.timestamp()
                        formatted = dt.strftime("%Y-%m-%d %H:%M:%S")
                    else:
                        epoch = float(ts)
                        formatted = datetime.fromtimestamp(epoch).strftime("%Y-%m-%d %H:%M:%S") if epoch else ""
                except Exception:
                    epoch = 0
                    formatted = ""
                save_list.append({
                    "save_id": filename,
                    "save_name": filename.rsplit('.', 1)[0] if filename else "",
                    "save_time": epoch,
                    "formatted_save_time": formatted,
                    "player_name": player_name,
                    "player_level": player_level,
                    "location": location,
                })
            except Exception:
                continue
        return {"status": "success", "saves": save_list}
    except Exception as e:
        logger.error(f"Error listing saves: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error listing saves: {str(e)}"
        )

@app.delete("/api/end_session/{session_id}")
async def end_session(session_id: str):
    """End a game session and clean up resources.
    
    Note: Does not require the engine to exist - allows cleanup of orphaned sessions.
    """
    try:
        # Get engine if it exists (may be None if session already cleaned up)
        engine = active_sessions.get(session_id)
        
        if engine:
            # Stop the game loop if running (best-effort)
            try:
                if hasattr(engine, 'game_loop') and engine.game_loop and engine.game_loop.is_running:
                    engine.game_loop.stop()
                    logger.info(f"Stopped game loop for session {session_id}")
            except Exception as e:
                logger.warning(f"Failed to stop game loop for session {session_id}: {e}")
            
            # Disconnect listeners (best-effort)
            try:
                if session_id in session_listeners:
                    lst = session_listeners.pop(session_id)
                    if lst.get('stats_conn') and hasattr(engine, 'state_manager'):
                        try:
                            if engine.state_manager and hasattr(engine.state_manager, 'stats_manager'):
                                if engine.state_manager.stats_manager:
                                    engine.state_manager.stats_manager.stats_changed.disconnect(lst['stats_conn'])
                        except Exception as e:
                            logger.warning(f"Failed to disconnect stats listener: {e}")
                    if lst.get('orch_conn') and hasattr(engine, 'orchestrated_event_to_ui'):
                        try:
                            engine.orchestrated_event_to_ui.disconnect(lst['orch_conn'])
                        except Exception as e:
                            logger.warning(f"Failed to disconnect orchestration listener: {e}")
            except Exception as e:
                logger.warning(f"Error disconnecting listeners for session {session_id}: {e}")
        
        # Remove from active sessions (whether engine existed or not)
        if session_id in active_sessions:
            del active_sessions[session_id]
            logger.info(f"Removed session {session_id} from active sessions")
        
        # Remove WebSocket connections (best-effort)
        if session_id in websocket_connections:
            for websocket in websocket_connections[session_id]:
                try:
                    await websocket.close()
                except Exception as e:
                    logger.warning(f"Failed to close WebSocket: {e}")
            del websocket_connections[session_id]
            logger.info(f"Closed WebSocket connections for session {session_id}")
        
        # Clean up pending payloads if any
        if session_id in pending_ws_payloads:
            del pending_ws_payloads[session_id]
        
        logger.info(f"Successfully ended session {session_id}")
        
        return {
            "status": "success",
            "message": f"Session {session_id} ended successfully"
        }
    except Exception as e:
        # Log the error but return success anyway - cleanup is best-effort
        logger.error(f"Error ending session {session_id}: {e}", exc_info=True)
        # Still return success since we did our best to clean up
        return {
            "status": "success",
            "message": f"Session {session_id} cleanup completed with warnings (see logs)"
        }

# Server startup and shutdown events
@app.on_event("startup")
async def startup_event():
    """Initialize resources on server startup."""
    logger.info("API server starting up")

@app.on_event("shutdown")
async def shutdown_event():
    """Clean up resources on server shutdown."""
    logger.info("API server shutting down")
    
    # Stop all game engines
    for session_id, engine in active_sessions.items():
        if engine.game_loop.is_running:
            engine.game_loop.stop()
    
    # Close all WebSocket connections
    for session_id, connections in websocket_connections.items():
        for websocket in connections:
            try:
                await websocket.close()
            except:
                pass

# LLM settings endpoints
@app.get("/api/llm/settings", response_model=LLMSettingsResponse)
async def get_llm_settings():
    """Get current LLM settings."""
    try:
        # Create settings manager
        settings_manager = SettingsManager()
        
        # Get provider settings
        provider_config = settings_manager.get_provider_settings()
        
        # Get agent settings
        agent_config = {
            "narrator": settings_manager.get_agent_settings("narrator"),
            "rule_checker": settings_manager.get_agent_settings("rule_checker"),
            "context_evaluator": settings_manager.get_agent_settings("context_evaluator")
        }
        
        # Get LLM enabled status from any active game engine or settings
        llm_enabled = False
        if active_sessions:
            # Use the first active engine to check if LLM is enabled
            engine = next(iter(active_sessions.values()))
            llm_enabled = engine._use_llm
        
        return {
            "providers": {
            "openai": {**provider_config.get("openai", {"api_key": "", "organization_id": "", "enabled": True})},
            "google": {**provider_config.get("google", {"api_key": "", "organization_id": "", "enabled": True})},
            "openrouter": {**provider_config.get("openrouter", {"api_key": "", "organization_id": "", "enabled": True})}
            },
            "agents": {
                "narrator": agent_config.get("narrator", {
                    "provider_type": "OPENAI",
                    "model": "gpt-4o", 
                    "temperature": 0.7,
                    "top_p": 1.0,
                    "max_tokens": 1000,
                    "enabled": True
                }),
                "rule_checker": agent_config.get("rule_checker", {
                    "provider_type": "GOOGLE",
                    "model": "gemini-2.0-flash", 
                    "temperature": 0.3,
                    "top_p": 1.0,
                    "max_tokens": 500,
                    "enabled": True
                }),
                "context_evaluator": agent_config.get("context_evaluator", {
                    "provider_type": "GOOGLE",
                    "model": "gemini-2.0-flash", 
                    "temperature": 0.2,
                    "top_p": 1.0,
                    "max_tokens": 800,
                    "enabled": True
                }),
            },
            "llm_enabled": llm_enabled,
        }
    except Exception as e:
        logger.error(f"Error getting LLM settings: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting LLM settings: {str(e)}"
        )

@app.post("/api/llm/settings")
async def update_llm_settings(providers: Optional[ProviderConfig] = None, agents: Optional[AgentConfig] = None):
    """Update LLM settings."""
    try:
        # Create settings manager
        settings_manager = SettingsManager()
        
        # Update provider settings
        if providers:
            for provider_name in ["openai", "google", "openrouter"]:
                if hasattr(providers, provider_name):
                    provider_settings = getattr(providers, provider_name)
                    if provider_settings:
                        settings_manager.update_provider_settings(
                            provider_name,
                            provider_settings.dict()
                        )
        
        # Update agent settings
        if agents:
            for agent_name in ["narrator", "rule_checker", "context_evaluator"]:
                if hasattr(agents, agent_name):
                    agent_settings = getattr(agents, agent_name)
                    if agent_settings:
                        settings_manager.update_agent_settings(
                            agent_name,
                            agent_settings.dict()
                        )
        
        # Apply settings to any active game engines
        for engine in active_sessions.values():
            # Re-initialize agent manager if needed
            if hasattr(engine, '_agent_manager') and engine._agent_manager is not None:
                engine._agent_manager.reload_settings()
        
        return {
            "status": "success",
            "message": "LLM settings updated"
        }
    except Exception as e:
        logger.error(f"Error updating LLM settings: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error updating LLM settings: {str(e)}"
        )

@app.post("/api/llm/toggle/{session_id}")
async def toggle_llm(session_id: str, request: ToggleLLMRequest, engine: GameEngine = Depends(get_game_engine)):
    """Toggle LLM functionality for a game session."""
    try:
        # Toggle LLM functionality
        engine.set_llm_enabled(request.enabled)
        
        return {
            "status": "success",
            "message": f"LLM functionality {'enabled' if request.enabled else 'disabled'}",
            "llm_enabled": request.enabled
        }
    except Exception as e:
        logger.error(f"Error toggling LLM: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error toggling LLM: {str(e)}"
        )

# --- Backstory generation endpoints ---
class BackstoryImproveRequest(BaseModel):
    name: str
    race: str
    path: str
    origin_id: Optional[str] = None
    sex: Optional[str] = None
    seed_text: str = Field(..., description="Seed text to improve")

class BackstoryGenerateRequest(BaseModel):
    name: str
    race: str
    path: str
    origin_id: Optional[str] = None
    sex: Optional[str] = None


def _format_backstory_context(name: str, race: str, path: str, origin_id: Optional[str], sex: Optional[str]) -> str:
    try:
        cfg = _get_config_singleton()
        origin_text = ""
        if origin_id:
            origins = cfg.get_all("origins") or {}
            if isinstance(origins, dict) and origin_id in origins:
                od = origins[origin_id]
                desc = od.get("description") or od.get("summary") or ""
                traits = od.get("origin_traits") or od.get("traits") or []
                profs = od.get("skill_proficiencies") or od.get("skills") or []
                origin_text = f"Origin: {od.get('name', origin_id)}. {desc}\nTraits: "+", ".join([t.get('name', t) if isinstance(t, dict) else str(t) for t in traits]) + "\nSkills: "+", ".join([s.get('name', s) if isinstance(s, dict) else str(s) for s in profs])
        sex_text = f"Sex: {sex}. " if sex else ""
        base = f"Character: {name}. Race: {race}. Class: {path}. {sex_text}"
        return base + ("\n" + origin_text if origin_text else "")
    except Exception:
        return f"Character: {name}. Race: {race}. Class: {path}."

@app.post("/api/backstory/improve")
async def api_backstory_improve(req: BackstoryImproveRequest):
    try:
        context_text = _format_backstory_context(req.name, req.race, req.path, req.origin_id, req.sex)
        prompt = (
            "Improve the following background seed text for the character described below. "
            "Make it an engaging character description focusing on personality, motivation, and appearance, "
            "fitting the provided context. Do not narrate actions, just describe the character.\n\n"
            f"BACKGROUND SEED:\n{req.seed_text}\n\n"
            f"{context_text}"
        )
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={},
            player_input=prompt, conversation_history=[], relevant_memories=[], additional_context={}
        )
        agent = get_narrator_agent()
        out = agent.process(ctx) or {}
        narrative = out.get("narrative") or ""
        if not narrative:
            raise RuntimeError("Empty LLM response")
        return {"status": "success", "narrative": narrative}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Backstory improve error: {e}")
        raise HTTPException(status_code=500, detail=f"Backstory improve failed: {e}")

@app.post("/api/backstory/generate")
async def api_backstory_generate(req: BackstoryGenerateRequest):
    try:
        context_text = _format_backstory_context(req.name, req.race, req.path, req.origin_id, req.sex)
        prompt = (
            "Generate a short, engaging character description backstory seed (personality, motivation, appearance) "
            "for the character described below. Do not narrate actions, just describe the character based on the context.\n\n"
            f"{context_text}"
        )
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={},
            player_input=prompt, conversation_history=[], relevant_memories=[], additional_context={}
        )
        agent = get_narrator_agent()
        out = agent.process(ctx) or {}
        narrative = out.get("narrative") or ""
        if not narrative:
            raise RuntimeError("Empty LLM response")
        return {"status": "success", "narrative": narrative}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Backstory generate error: {e}")
        raise HTTPException(status_code=500, detail=f"Backstory generate failed: {e}")

@app.get("/api/ui/backgrounds")
async def list_ui_backgrounds():
    """List available GUI backgrounds (PNG/GIF) so the web UI can mirror Py GUI."""
    bg_dir = os.path.join(project_root, "images", "gui", "background")
    try:
        files = [f for f in os.listdir(bg_dir) if f.lower().endswith((".png", ".gif"))]
        files.sort()
    except Exception:
        files = []
    return {"backgrounds": files}

@app.get("/api/character-icons")
async def get_all_character_icons():
    """Get a list of all available character icons (flat list)."""
    try:
        icons = get_character_icons()
        return {"status": "success", "icons": icons}
    except Exception as e:
        logger.error(f"Error getting character icons: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error getting character icons: {str(e)}")

@app.get("/api/character-icons/filter")
async def get_filtered_character_icons(race: str = Query(...), path: str = Query(...), sex: str = Query("Other")):
    """Get a filtered list of character icons by race/class/sex subfolder and filename tags."""
    try:
        icons = get_character_icons_filtered(race, path, sex)
        return {"status": "success", "icons": icons}
    except Exception as e:
        logger.error(f"Error getting filtered icons: {e}")
        raise HTTPException(status_code=500, detail="Error getting filtered icons")

# --- Config endpoints ---
from core.base.config import get_config as _get_config_singleton

@app.get("/api/config/races")
async def api_config_races():
    try:
        cfg = _get_config_singleton()
        races = cfg.get_all("races") or {}
        names = sorted([data.get('name', rid) for rid, data in races.items()])
        return {"races": races, "names": names}
    except Exception as e:
        logger.error(f"Error reading races config: {e}")
        raise HTTPException(status_code=500, detail="Error reading races config")

@app.get("/api/config/classes")
async def api_config_classes():
    try:
        cfg = _get_config_singleton()
        classes = cfg.get_all("classes") or {}
        names = sorted([data.get('name', cid) for cid, data in classes.items()])
        return {"classes": classes, "names": names}
    except Exception as e:
        logger.error(f"Error reading classes config: {e}")
        raise HTTPException(status_code=500, detail="Error reading classes config")

@app.get("/api/config/origins")
async def api_config_origins():
    try:
        cfg = _get_config_singleton()
        origins = cfg.get_all("origins") or {}
        # Return as list for convenience + dict form
        origin_list = list(origins.values())
        origin_list.sort(key=lambda x: x.get('name', ''))
        return {"origins": origins, "list": origin_list}
    except Exception as e:
        logger.error(f"Error reading origins config: {e}")
        raise HTTPException(status_code=500, detail="Error reading origins config")

# --- Stats endpoints ---
@app.get("/api/stats/all/{session_id}")
async def api_stats_all(session_id: str, engine: GameEngine = Depends(get_game_engine)):
    try:
        sm = engine.state_manager.stats_manager
        if not sm:
            raise HTTPException(status_code=404, detail="Stats manager not available")
        return sm.get_all_stats()
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting all stats: {e}")
        raise HTTPException(status_code=500, detail="Error getting stats")

class StatModifiersQuery(BaseModel):
    stat: str

@app.get("/api/stats/modifiers/{session_id}")
async def api_stat_modifiers(session_id: str, stat: str = Query(...), engine: GameEngine = Depends(get_game_engine)):
    try:
        sm = engine.state_manager.stats_manager
        if not sm:
            raise HTTPException(status_code=404, detail="Stats manager not available")
        from core.stats.stats_base import StatType, DerivedStatType
        stat_key = stat.strip().upper()
        stat_enum = None
        try:
            stat_enum = StatType[stat_key]
        except KeyError:
            try:
                stat_enum = DerivedStatType[stat_key]
            except KeyError:
                raise HTTPException(status_code=400, detail=f"Unknown stat '{stat}'")
        mods = sm.modifier_manager.get_modifiers_for_stat(stat_enum)
        # Convert modifiers to dicts if they have to_dict
        out = []
        for m in mods:
            try:
                out.append(m.to_dict())
            except Exception:
                # Basic projection
                out.append({
                    "id": getattr(m, 'id', None),
                    "source": getattr(m, 'source_name', ''),
                    "value": getattr(m, 'value', 0),
                    "is_percentage": getattr(m, 'is_percentage', False),
                    "duration": getattr(m, 'duration', None)
                })
        return {"stat": stat_key, "modifiers": out}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting stat modifiers: {e}")
        raise HTTPException(status_code=500, detail="Error getting modifiers")

# --- Journal endpoints ---
class JournalCharacterUpdate(BaseModel):
    text: str

class JournalObjectiveStatus(BaseModel):
    quest_id: str
    objective_id: str
    completed: Optional[bool] = None
    failed: Optional[bool] = None

class JournalAbandonRequest(BaseModel):
    quest_id: str

class JournalNoteRequest(BaseModel):
    text: str

@app.get("/api/journal/{session_id}")
async def api_get_journal(session_id: str, engine: GameEngine = Depends(get_game_engine)):
    try:
        st = engine.state_manager.state
        return getattr(st, 'journal', {}) or {}
    except Exception as e:
        logger.error(f"Error getting journal: {e}")
        raise HTTPException(status_code=500, detail="Error getting journal")

@app.post("/api/journal/character/{session_id}")
async def api_update_journal_character(session_id: str, req: JournalCharacterUpdate, engine: GameEngine = Depends(get_game_engine)):
    try:
        st = engine.state_manager.state
        if not hasattr(st, 'journal') or st.journal is None:
            st.journal = {"character": "", "quests": {}, "notes": []}
        st.journal["character"] = req.text or ""
        # Broadcast simple journal update
        asyncio.create_task(ConnectionManager.send_update(session_id, {"type": "journal_updated", "data": st.journal}))
        return {"status": "success"}
    except Exception as e:
        logger.error(f"Error updating journal character: {e}")
        raise HTTPException(status_code=500, detail="Error updating journal character")

@app.post("/api/journal/objective_status/{session_id}")
async def api_update_objective_status(session_id: str, req: JournalObjectiveStatus, engine: GameEngine = Depends(get_game_engine)):
    try:
        st = engine.state_manager.state
        if not hasattr(st, 'journal') or st.journal is None:
            st.journal = {"character": "", "quests": {}, "notes": []}
        q = st.journal.setdefault("quests", {}).get(req.quest_id)
        if not q:
            raise HTTPException(status_code=404, detail="Quest not found")
        # Update objective
        for o in q.get("objectives", []):
            if o.get("id") == req.objective_id:
                if req.completed is not None:
                    o["completed"] = bool(req.completed)
                    if req.completed:
                        o["failed"] = False
                if req.failed is not None:
                    o["failed"] = bool(req.failed)
                    if req.failed:
                        o["completed"] = False
                break
        asyncio.create_task(ConnectionManager.send_update(session_id, {"type": "journal_updated", "data": st.journal}))
        return {"status": "success"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating objective status: {e}")
        raise HTTPException(status_code=500, detail="Error updating objective status")

@app.post("/api/journal/abandon/{session_id}")
async def api_abandon_quest(session_id: str, req: JournalAbandonRequest, engine: GameEngine = Depends(get_game_engine)):
    try:
        st = engine.state_manager.state
        if not hasattr(st, 'journal') or st.journal is None:
            st.journal = {"character": "", "quests": {}, "notes": []}
        q = st.journal.setdefault("quests", {}).get(req.quest_id)
        if not q:
            raise HTTPException(status_code=404, detail="Quest not found")
        q["status"] = "failed"
        q["abandoned"] = True
        asyncio.create_task(ConnectionManager.send_update(session_id, {"type": "journal_updated", "data": st.journal}))
        return {"status": "success"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error abandoning quest: {e}")
        raise HTTPException(status_code=500, detail="Error abandoning quest")

@app.post("/api/journal/add_note/{session_id}")
async def api_add_journal_note(session_id: str, req: JournalNoteRequest, engine: GameEngine = Depends(get_game_engine)):
    try:
        st = engine.state_manager.state
        if not hasattr(st, 'journal') or st.journal is None:
            st.journal = {"character": "", "quests": {}, "notes": []}
        notes = st.journal.setdefault("notes", [])
        note = {"id": str(uuid.uuid4()), "text": req.text or "", "created_at": datetime.now().isoformat()}
        notes.append(note)
        asyncio.create_task(ConnectionManager.send_update(session_id, {"type": "journal_updated", "data": st.journal}))
        return {"status": "success", "note": note}
    except Exception as e:
        logger.error(f"Error adding note: {e}")
        raise HTTPException(status_code=500, detail="Error adding note")

@app.delete("/api/journal/delete_note/{session_id}/{note_id}")
async def api_delete_journal_note(session_id: str, note_id: str, engine: GameEngine = Depends(get_game_engine)):
    try:
        st = engine.state_manager.state
        if not hasattr(st, 'journal') or st.journal is None:
            st.journal = {"character": "", "quests": {}, "notes": []}
        notes = st.journal.setdefault("notes", [])
        before = len(notes)
        notes[:] = [n for n in notes if str(n.get('id')) != str(note_id)]
        if len(notes) == before:
            raise HTTPException(status_code=404, detail="Note not found")
        asyncio.create_task(ConnectionManager.send_update(session_id, {"type": "journal_updated", "data": st.journal}))
        return {"status": "success"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting note: {e}")
        raise HTTPException(status_code=500, detail="Error deleting note")

# Run server directly with: uvicorn server:app --reload
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("server:app", host="0.0.0.0", port=8000, reload=True)

```

### File: config\world\scenarios\origins.json

```json
{
  "origins": {
    "harmonia_initiate": {
      "id": "harmonia_initiate",
      "name": "Harmonia Initiate",
      "description": "You've recently completed your Attunement ceremony and are now officially a citizen of Harmonia. As a new initiate into adult society, you're eager to prove yourself and find your place within the Concordant Cities.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "simple_clothing",
        "harmonian_tattoo_kit",
        "resonance_amulet",
        "bread",
        "water_flask"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Halfling"
      ],
      "suitable_classes": [
        "Wanderer",
        "Mage",
        "Rogue",
        "Cleric"
      ],
      "introduction_text": "The vibrant city of Harmonia stretches before you, its seven concentric rings shifting subtly as distant Resonance energies flow through the metropolis. You touch the still-tender Attunement tattoos on your forearms, their ink seeming to shimmer as you pass through a pocket of concentrated planar energy. After years of preparation, you've finally been recognized as a full citizen, ready to contribute to the great Concordant society.\n\nThe Attunement Master has granted you your first day of freedom to explore opportunities throughout the city. Your future is unwritten – perhaps you'll join the Harmonic Order to study Resonance phenomena, sign up with local merchants as a guard or guide, or even apply for a coveted position with the ambassadorial corps. Whatever path you choose, one thing is certain: life in Harmonia is never predictable, especially with recent reports of increased Resonance Event frequency.\n\nYou adjust your new resonance amulet, a gift from your family to commemorate your initiation, and step forward into your new life.",
      "skill_proficiencies": [
        "Diplomacy",
        "Planar Lore (Basic)",
        "Streetwise (Harmonia)"
      ],
      "origin_traits": [
        {
          "name": "Attuned Citizen",
          "description": "Your Attunement tattoos offer minor resistance (+1 save) to psychological effects during moderate Resonance Events."
        },
        {
          "name": "Concordant Native",
          "description": "You are familiar with the basic customs and layout of Harmonia."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "embassy_assignment": {
      "id": "embassy_assignment",
      "name": "The Embassy Assignment",
      "description": "You've been assigned to the Verdant Embassy as part of a cultural exchange program. Your mission is to learn about the Verdant Collective while representing your own people or interests.",
      "starting_location_id": "verdant_embassy",
      "starting_items": [
        "diplomatic_papers",
        "formal_attire",
        "journal",
        "small_pouch_of_seeds",
        "water_flask"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Halfling",
        "Dwarf"
      ],
      "suitable_classes": [
        "Wanderer",
        "Cleric",
        "Ranger",
        "Mage"
      ],
      "introduction_text": "The living walls of the Verdant Embassy pulse with quiet energy around you as you settle into your new quarters. Branches intertwine above to form your ceiling, occasionally shifting to allow beams of sunlight to filter through the leafy canopy. It's been less than a day since you arrived at this outpost, a representative selected to participate in the cultural exchange program between your people and the enigmatic Verdant Collective.\n\nYour diplomatic papers were accepted readily enough by the Green Speakers stationed here, though you noticed they communicated among themselves using their mysterious plant-based language – subtle movements of leaves and the release of spores that somehow convey complex thoughts. You've been told that part of your role will be to learn their customs and potentially even the basics of their communication methods.\n\nAs you unpack your belongings, a small seedpod drops from the ceiling onto your desk, splitting open to reveal a message written on a thin leaf inside. It appears to be an invitation to meet with the Verdant Ambassador at your earliest convenience. Your time at the Embassy has officially begun.",
      "skill_proficiencies": [
        "Diplomacy",
        "Nature",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Cultural Envoy",
          "description": "You have official standing within the Verdant Embassy, granting easier access to certain areas and individuals."
        },
        {
          "name": "Observant Outsider",
          "description": "Your unfamiliarity allows you to notice details Verdant natives might overlook."
        }
      ],
      "starting_culture_id": "verdant"
    },
    "crystal_study_apprentice": {
      "id": "crystal_study_apprentice",
      "name": "Crystal Study Apprentice",
      "description": "You've been accepted as an apprentice in the Crystalline Enclave, a prestigious position. You'll study the mathematical principles of Facet Magic under the tutelage of Consortium representatives.",
      "starting_location_id": "crystalline_enclave",
      "starting_items": [
        "apprentice_robes",
        "calculation_crystals",
        "precision_tools",
        "faceted_focusing_lens",
        "notebook"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Prismal",
        "Dwarf"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The precise angles of the Crystalline Enclave's architecture catch the morning light, sending mathematically perfect rainbows across the polished surfaces of the Calculation Chamber. It's your first day as an official apprentice to the Crystalline Consortium, a position few outsiders ever achieve. Your acceptance came after months of rigorous testing of your logical reasoning and mathematical aptitude.\n\nYour new quarters are spartan but functional – every surface and object positioned according to precise geometric principles that the Consortium claims enhance cognitive function. On your desk sits a set of calculation crystals and precision tools, along with a faceted focusing lens that you're expected to learn to attune to your specific thought patterns.\n\nThe schedule delivered to you this morning is exacting: your first lesson in the fundamental principles of Facet Magic begins in exactly forty-three minutes, followed by two hours of observational study in the Precision Market, then meditation on crystalline harmonic progressions. There will be little room for error or inefficiency – exactly as your Consortium mentors prefer it.",
      "skill_proficiencies": [
        "Arcana",
        "Investigation",
        "Mathematics (Basic)"
      ],
      "origin_traits": [
        {
          "name": "Consortium Apprentice",
          "description": "You have access to basic Crystalline Consortium facilities and learning resources."
        },
        {
          "name": "Logical Mind",
          "description": "You gain a minor bonus (+1 save) against effects that cause confusion or illogical thinking."
        }
      ],
      "starting_culture_id": "crystalline"
    },
    "echo_woods_explorer": {
      "id": "echo_woods_explorer",
      "name": "Echo Woods Explorer",
      "description": "You've been drawn to the mysterious Echo Woods, either to study its planar phenomena, collect valuable resources, or perhaps because you're following the whispers of a specific echo that holds personal significance.",
      "starting_location_id": "echo_woods",
      "starting_items": [
        "explorer_clothing",
        "survival_kit",
        "small_tent",
        "recording_crystal",
        "hunting_knife"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Halfling",
        "Mycora"
      ],
      "suitable_classes": [
        "Ranger",
        "Wanderer",
        "Rogue",
        "Mage"
      ],
      "introduction_text": "Mist curls between the ancient trees of the Echo Woods as you make your way deeper into this strange forest. The boundary between the Nexus and Verdant planes feels particularly thin here – occasionally you glimpse plants that couldn't possibly exist in either realm alone, hybrid creations thriving in the planar overlap. More unsettling are the whispers that seem to follow you: fragments of conversations held long ago, preserved somehow in the very fabric of this place.\n\nYou've come prepared for an extended stay, carrying essential survival gear and a recording crystal to document your findings. Whether you're here as a researcher, a resource gatherer, or because you're following a particular echo that caught your attention during a previous visit, the woods offer endless mysteries to unravel.\n\nAs you set up your small camp near what appears to be a suitable clearing, you notice that the whispers have grown more distinct. Some seem to be repeating your own movements, describing the very actions you're taking as you secure your tent. Others speak of events from centuries past – or perhaps yet to come. The Echo Woods reveal their secrets only to the patient and observant, and you intend to be both.",
      "skill_proficiencies": [
        "Survival",
        "Nature",
        "Perception"
      ],
      "origin_traits": [
        {
          "name": "Echo Sensitive",
          "description": "You are more susceptible to hearing the whispers of the Echo Woods, potentially gaining insights or facing distractions."
        },
        {
          "name": "Wilderness Acclimated",
          "description": "You have advantage on saving throws against natural environmental hazards within forests."
        }
      ]
    },
    "ashen_covenant_recruit": {
      "id": "ashen_covenant_recruit",
      "name": "Ashen Covenant Recruit",
      "description": "You've recently joined the nomadic Ashen Covenant, embracing their philosophy of impermanence. You seek to learn their unique spiritual practices, including the mysterious art of Ash Walking.",
      "starting_location_id": "ashen_camp",
      "starting_items": [
        "ash-treated_clothing",
        "covenant_pendant",
        "fire_striker",
        "ritual_dagger",
        "small_pouch_of_ancestral_ash",
        "test_apple"
      ],
      "initial_quests": [
        "551cdb35-a4bb-4b23-b6c1-4d2772947efb",
        "TEST_Q01",
        "TEST_Q02",
        "TEST_Q03",
        "TEST_Q04",
        "TEST_Q05",
        "TEST_Q06",
        "TEST_Q07",
        "TEST_Q08",
        "TEST_Q09",
        "TEST_Q10",
        "TEST_Q11",
        "TEST_Q12",
        "TEST_Q13",
        "TEST_Q14",
        "TEST_Q15",
        "TEST_Q16",
        "TEST_Q17",
        "TEST_Q18",
        "TEST_Q19",
        "TEST_Q20",
        "TEST_Q21",
        "TEST_Q22",
        "TEST_Q23",
        "TEST_Q24",
        "TEST_Q25"
      ],
      "suitable_races": [
        "Cinderspawn",
        "Human",
        "Orc"
      ],
      "suitable_classes": [
        "Cleric",
        "Mage",
        "Wanderer",
        "Warrior"
      ],
      "introduction_text": "The Eternal Flame at the center of the Ashen Camp dances hypnotically, casting long shadows from the temporary structures that surround it. You've arrived just days ago, but already the Covenant has accepted you as one of their own – an unusually quick integration into their normally closed society. Perhaps they saw something in you that suggested an affinity for their ways, or perhaps the ancestors spoke your name during a ritual.\n\nYour tent, like all others in the camp, is designed for quick assembly and disassembly. The nomadic Ashen Covenant never stays in one place long, following ancient migration patterns known only to their elders. All possessions are considered temporary – including the ritual dagger you were gifted this morning, which you're expected to surrender during the next Possession Exchange ceremony.\n\nAn elder approaches you now, their skin bearing the distinctive gray markings that indicate frequent Ash Walking – the mysterious practice of projecting consciousness through the ashes of the dead to commune with ancestors or travel spiritually to the Ashen plane. They've promised to begin your initial training today, starting with the fundamental philosophy that nothing – not possessions, not places, not even lives – is permanent. All returns to ash eventually, and in understanding this, the Covenant finds freedom.",
      "skill_proficiencies": [
        "History (Oral)",
        "Religion",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Covenant Initiate",
          "description": "You are recognized by the Ashen Covenant and can participate in basic community rituals like the Possession Exchange."
        },
        {
          "name": "Embracing Impermanence",
          "description": "You have a minor bonus (+1 save) against effects causing fear of loss or attachment."
        }
      ],
      "starting_culture_id": "ashen"
    },
    "tempest_harbor_arrival": {
      "id": "tempest_harbor_arrival",
      "name": "Tempest Harbor Arrival",
      "description": "You've arrived at Tempest Harbor during a rare celestial alignment, either as a trader, an adventurer seeking opportunity, or perhaps as someone who has unfinished business with the enigmatic Tempest Flotilla.",
      "starting_location_id": "tempest_harbor",
      "starting_items": [
        "weather-resistant_clothing",
        "small_trading_goods",
        "probability_dice",
        "storm_compass",
        "sealed_message"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Maelstri",
        "Elf",
        "Dwarf"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer",
        "Mage",
        "Warrior"
      ],
      "introduction_text": "The chaotic energy of Tempest Harbor surrounds you as you make your way along the swaying walkways. The entire harbor appeared less than two days ago when the celestial alignment permitted the Tempest Flotilla to dock at the Nexus plane, and it will vanish just as quickly once the alignment ends. All around you, traders from across the planes haggle furiously, well aware that time is limited.\n\nThe air crackles with small surges of storm energy, captured and contained by the Flotilla's distinctive vessels. Probability merchants call out their wares – dice that may influence chance itself, pendants that predict local weather patterns, contracts with favorable statistical outcomes. The Flux Market ahead changes leadership hourly, causing prices and available goods to fluctuate in patterns only the most seasoned traders can predict.\n\nYou clutch the storm compass in your pocket – a gift, or perhaps a burden, that led you here at this precise moment. The sealed message you carry remains unopened, its recipient somewhere among the hundreds of temporary visitors and Flotilla members. Whether you've come to trade, to find someone, or to start anew where your past cannot follow, the Tempest Harbor offers possibilities as changeable as the storms the Flotilla navigates.",
      "skill_proficiencies": [
        "Acrobatics",
        "Deception",
        "Insight (Risk Assessment)"
      ],
      "origin_traits": [
        {
          "name": "Harbor Savvy",
          "description": "You understand the basic flow and dangers of the temporary Tempest Harbor."
        },
        {
          "name": "Embracer of Chaos",
          "description": "You react slightly faster (+1 Initiative) in unpredictable or rapidly changing situations."
        }
      ],
      "starting_culture_id": "tempest"
    },
    "library_assistant": {
      "id": "library_assistant",
      "name": "The Library's New Assistant",
      "description": "You've been granted the rare privilege of assisting at the Shifting Library. Knowledge from across all planes is collected and preserved by the enigmatic Lexicants.",
      "starting_location_id": "shifting_library",
      "starting_items": [
        "assistant_robes",
        "library_authorization",
        "cataloging_tools",
        "enchanted_quill",
        "blank_journal"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Prismal",
        "Dwarf"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The impossible architecture of the Shifting Library stretches around you, corridors extending far beyond what the exterior of the building should allow. You've been here for just under a week, still adjusting to the disorienting sensation of walking through sections of the library that exist simultaneously in different planes. The modest stone exterior belies the near-infinite collection contained within.\n\nYour quarters are small but comfortable, positioned near the Reading Nexus where researchers from across the planes come to study rare texts. Your position as an assistant came unexpectedly – some say the Library itself chooses its caretakers, somehow recognizing those with the necessary qualities long before they themselves are aware of their destiny.\n\nThe Head Lexicant assigned you simple cataloging duties to start, but hinted that you would soon begin training to access the deeper archives, where knowledge from before The Shattering is preserved in fragmentary form. Your enchanted quill allows you to take notes that will remain readable regardless of which plane currently dominates the section you're working in – a necessary tool for any Library employee.\n\nAs you prepare for your morning duties, you notice your blank journal glowing faintly. Opening it reveals a message in flowing script: 'Report to the Lexicant Hall. Your real work begins today.'",
      "skill_proficiencies": [
        "Investigation",
        "History",
        "Arcana (Basic)"
      ],
      "origin_traits": [
        {
          "name": "Library Access",
          "description": "You possess basic authorization to navigate the common areas of the Shifting Library."
        },
        {
          "name": "Planar Acclimation (Minor)",
          "description": "You have minor resistance (+1 save) against disorientation caused by shifting planar environments within the Library."
        }
      ]
    },
    "planar_researcher": {
      "id": "planar_researcher",
      "name": "Planar Bleed Researcher",
      "description": "You've volunteered for a research expedition to The Convergence, a dangerous Planar Bleed Zone. Multiple planes have permanently merged, creating unique phenomena worth studying despite the risks.",
      "starting_location_id": "planar_bleed_zone",
      "starting_items": [
        "researcher_equipment",
        "planar_protection_suit",
        "specimen_containers",
        "reality_anchor",
        "emergency_beacon"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Prismal",
        "Elf",
        "Mycora"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer",
        "Ranger"
      ],
      "introduction_text": "The laws of reality bend and fracture around you as you record observations at your designated research post in The Convergence. Here, at least three planes have merged permanently, creating impossible landscapes where forests of crystalline trees grow alongside pools of ash that somehow support aquatic life. The hybrid flora and fauna that have evolved in this zone exist nowhere else in any plane – making them invaluable subjects for study despite the considerable dangers.\n\nYour planar protection suit hums softly as it generates a field of stable reality around you, preventing the worst effects of planar exposure. Without it, prolonged presence here would lead to physical and mental alterations – some fascinating, most deadly. Even with protection, you must regularly calibrate your reality anchor to prevent being drawn into pocket dimensions that spontaneously form and collapse.\n\nYou volunteered for this three-month research rotation knowing the risks, driven by scientific curiosity or perhaps by the substantial hazard pay offered by the Harmonic Order. Your small team occupies the fortified Harvester Camp nearby, venturing out daily to collect data and specimens before retreating to relative safety each night.\n\nAs you finish documenting a particularly interesting reality fault, your instruments begin detecting unusual energy patterns. Something is happening in the Bleed Zone – something not recorded in any of your briefing materials.",
      "skill_proficiencies": [
        "Investigation",
        "Survival",
        "Planar Lore"
      ],
      "origin_traits": [
        {
          "name": "Field Researcher",
          "description": "You are trained in basic planar sample collection and data recording techniques."
        },
        {
          "name": "Reality Anchor Familiarity",
          "description": "You know how to operate and perform basic maintenance on personal reality anchors."
        }
      ]
    },
    "ghost_market_escapee": {
      "id": "ghost_market_escapee",
      "name": "Ghost Market Escapee",
      "description": "You recently found yourself trapped in the mysterious Ghost Market during a Resonance Event. After making a questionable deal with one of The Between to secure your freedom, you now navigate the consequences of that bargain.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "strange_contract",
        "between_token",
        "partially_empty_memory_vial",
        "planar_map",
        "market_trinket"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Elf",
        "Dwarf",
        "Orc"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer",
        "Mage",
        "Warrior"
      ],
      "introduction_text": "The streets of Harmonia offer welcome stability after your harrowing experience in the Ghost Market. Three days have passed since you escaped that ethereal bazaar, though 'escaped' might not be the right word when you consider the contract currently burning a hole in your pocket. The Between – those enigmatic entities who run the market – rarely let anyone leave without some form of payment or promise.\n\nYou still don't fully remember how you came to be trapped there when the Resonance Event struck. One moment you were going about your business, the next you were surrounded by ethereal tents and the haunting bell music that announces the Ghost Market's appearance. What you do remember clearly is the panic that set in when you realized the market was beginning to dematerialize, preparing to shift to another location, with you still inside it.\n\nThe strange contract you signed with one of The Between secured your release back to the Nexus plane, but the cost remains ambiguous – something about 'services to be rendered at a time of the signatory's choosing.' The Between Token you were given supposedly allows them to contact you when they decide to collect on your debt.\n\nMost disturbing is the partially empty memory vial hanging around your neck. You're certain it contains some of your own memories, extracted as a 'deposit' on your contract. You don't know what you've forgotten, but the sense of loss haunts you.",
      "skill_proficiencies": [
        "Deception",
        "Stealth",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Between's Bargain",
          "description": "You carry a binding contract with an entity from the Ghost Market, which may have unforeseen consequences."
        },
        {
          "name": "Fragmented Memory",
          "description": "You have gaps in your recent memory due to your Ghost Market encounter."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "nobles_fall": {
      "id": "nobles_fall",
      "name": "Noble's Fall from Grace",
      "description": "Once a privileged noble in Harmonia, you've recently fallen from grace due to a political misstep, family scandal, or being on the wrong side of a Resonance Event prediction. Now you must rebuild your life with few resources but valuable connections and knowledge.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "fine_clothes_(worn)",
        "family_signet_ring",
        "small_purse_of_coins",
        "sealed_letter_of_introduction",
        "ornate_dagger"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf"
      ],
      "suitable_classes": [
        "Wanderer",
        "Rogue",
        "Warrior",
        "Mage"
      ],
      "introduction_text": "The lower rings of Harmonia look different from this perspective – as a resident rather than a visitor. Your family's estate in the third ring, with its clear view of the Harmonic Spire, now seems impossibly distant. Your current lodgings, a modest room above a resonance equipment repair shop, serve as a stark reminder of how quickly fortunes can change in the Concordant Cities.\n\nIt's been just two weeks since the Council's decree stripped your family of position and most of your wealth. Perhaps it was your father's opposition to the new Resonance monitoring protocols, your sister's ill-advised romance with a Tempest diplomat, or simply being caught on the wrong side of a factional realignment. Whatever the cause, the result is the same – you now find yourself starting over with little more than your education, your connections, and whatever personal possessions you could discreetly secure before the seizures began.\n\nThe signet ring you wear now feels heavy – a reminder of your heritage that might open doors or close them, depending on who you encounter. The sealed letter of introduction from a family ally might offer a path forward, though you haven't yet decided whether to use it. Pride suggests making your own way; pragmatism argues for using every advantage available.\n\nAs you look out over the unfamiliar neighborhood, you consider your options. Your knowledge of high society and planar politics remains valuable. The question is how to leverage it without becoming entangled in the same web that ensnared your family.",
      "skill_proficiencies": [
        "Persuasion",
        "History",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Fallen Noble",
          "description": "You retain knowledge of noble etiquette and politics, but lack the resources and official standing you once had."
        },
        {
          "name": "Lingering Connections",
          "description": "Some individuals may still recognize your family name, for better or worse."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "commoners_call": {
      "id": "commoners_call",
      "name": "Commoner's Call to Adventure",
      "description": "After years of ordinary life in Harmonia's lower rings, a chance encounter with a mysterious traveler has given you a glimpse of the wider world across the planes, along with an offer you can't refuse.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "sturdy_work_clothes",
        "family_heirloom",
        "simple_tool",
        "lunch_bundle",
        "old_map"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Dwarf",
        "Orc"
      ],
      "suitable_classes": [
        "Warrior",
        "Rogue",
        "Ranger",
        "Wanderer"
      ],
      "introduction_text": "The familiar streets of your neighborhood in Harmonia's sixth ring buzz with the usual morning activity – merchants setting up stalls, children running errands, workers heading to their duties in the inner rings. For two decades, this has been your entire world, your days filled with honest work and simple pleasures, never venturing beyond the boundaries set by circumstance and station.\n\nBut everything changed three nights ago when a traveler with strange, swirling tattoos and eyes that seemed to reflect multiple planes took shelter in your family's modest home during an unexpected Resonance tremor. The stories they shared of crystalline cities, floating harbors, and libraries that exist in all planes simultaneously awakened something within you that had lain dormant for too long.\n\nBefore leaving at dawn, they pressed an old map into your hands, marked with locations you'd never heard of, and whispered that you were 'meant for more than this life.' Whether driven by restlessness, curiosity, or the strange certainty in the traveler's voice, you've made your decision. Today, you leave the familiarity of your neighborhood behind, your few possessions packed and your family's blessing reluctantly given.\n\nThe weight of your family heirloom in your pocket reminds you of where you came from, while the map in your hand points to where you might be going. What awaits beyond the boundaries of everything you've ever known? It's time to find out.",
      "skill_proficiencies": [
        "Athletics",
        "Endurance",
        "Crafting (Basic)"
      ],
      "origin_traits": [
        {
          "name": "Common Sense",
          "description": "You possess practical knowledge and resilience gained from ordinary life."
        },
        {
          "name": "Mysterious Map",
          "description": "You carry an old map marked with unknown locations, hinting at a potential destiny."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "scholarly_expedition": {
      "id": "scholarly_expedition",
      "name": "Scholarly Expedition",
      "description": "As a historian or researcher from the prestigious Resonance Academy in Harmonia, you've been sent on an expedition to document and study a recently discovered site of pre-Shattering significance.",
      "starting_location_id": "echo_woods",
      "starting_items": [
        "academic_robes",
        "research_notes",
        "precision_measuring_tools",
        "portable_writing_desk",
        "resonance_detector"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Elf",
        "Prismal",
        "Dwarf"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The mist-shrouded trees of the Echo Woods loom around you as you consult your notes once more. According to the fragmentary references discovered in the Academy archives, somewhere in this region lies a structure that predates The Shattering – a find of potentially immeasurable historical importance. As a scholar who has dedicated years to studying the sparse records of that lost era, the opportunity to document such a site firsthand could define your entire academic career.\n\nYour small expedition team has already set up a base camp half a day's journey behind you. As the team's lead historian, you've pressed ahead with just the essentials, eager to make the initial assessment before bringing in the other specialists. The portable resonance detector at your belt occasionally pulses with a soft blue light, confirming you're moving in the right direction.\n\nThe Academy's funding for this expedition was hard-won, with many senior faculty dismissing the ancient texts you uncovered as mere fantasy or allegory. Proving them wrong would be satisfying, but your true motivation runs deeper – to understand the world that existed before The Shattering, to piece together how one reality became five distinct planes, might help humanity comprehend its own fragmented existence.\n\nAs you push aside a curtain of hanging vines, your resonance detector suddenly flares with brilliant light. There, partially reclaimed by the forest but unmistakably artificial, stands a structure unlike any you've seen in modern architectural records. Your heart races as you approach, research notes at the ready. This is what you came for – the past, waiting to be rediscovered.",
      "skill_proficiencies": [
        "History",
        "Investigation",
        "Planar Lore"
      ],
      "origin_traits": [
        {
          "name": "Academic Authority",
          "description": "You possess credentials from the Resonance Academy, which may grant access to certain sites or information."
        },
        {
          "name": "Analytical Mind",
          "description": "You gain advantage on checks made to analyze historical artifacts or decipher ancient texts."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "soldiers_mission": {
      "id": "soldiers_mission",
      "name": "Soldier's New Mission",
      "description": "After years of service in the Harmonic Guard, you've been selected for a special assignment. Investigate reports of unusual planar activity that may pose a threat to the stability of the Concordant Cities.",
      "starting_location_id": "planar_bleed_zone",
      "starting_items": [
        "guard_uniform",
        "standard_issue_weapon",
        "planar_protection_amulet",
        "rations_pack",
        "sealed_orders"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Dwarf",
        "Orc"
      ],
      "suitable_classes": [
        "Warrior",
        "Ranger",
        "Cleric"
      ],
      "introduction_text": "The ever-shifting landscape of The Convergence stretches before you, a vivid reminder of why the Harmonic Guard maintains constant vigilance against planar threats. For eight years, you've served with distinction, patrolling the orderly streets of Harmonia and occasionally venturing to outlying settlements to maintain security and order. But this assignment is different – more dangerous, more secretive, and potentially more significant than anything in your service record.\n\nTwo weeks ago, monitoring stations detected unusual ripples in the planar boundaries – not the typical fluctuations that precede Resonance Events, but something more deliberate, almost structured. Your commander's briefing was uncharacteristically grave as he handed you sealed orders and the special protection amulet now hanging around your neck. 'We need someone who can think independently,' he said, 'someone who understands what's at stake.'\n\nYour small squad consists of just three other hand-picked guards, each with specialized skills. You've been granted unusual autonomy for this mission – no regular check-ins, no standard protocols, just a directive to investigate and report on whatever is causing these anomalies, and if necessary, neutralize any threat they might pose.\n\nAs you adjust your uniform, designed to blend in rather than stand out in this chaotic environment, you feel the weight of responsibility. The safety of Harmonia may depend on what you discover here in this unstable region where reality itself cannot be trusted. It's time to break the seal on those orders and begin your mission properly.",
      "skill_proficiencies": [
        "Athletics",
        "Perception",
        "Intimidation"
      ],
      "origin_traits": [
        {
          "name": "Harmonic Guard Veteran",
          "description": "You possess military discipline and are recognized by Concordant City officials."
        },
        {
          "name": "Planar Hazard Training",
          "description": "You have basic training in identifying and mitigating common planar dangers."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "outlaw_on_run": {
      "id": "outlaw_on_run",
      "name": "Outlaw on the Run",
      "description": "You're a fugitive from Harmonian justice, whether rightfully accused or wrongfully framed. You've fled to the edges of controlled territory, seeking to either clear your name or disappear into the chaotic regions beyond the Concordant Cities' influence.",
      "starting_location_id": "echo_woods",
      "starting_items": [
        "worn_disguise",
        "stolen_supplies",
        "forged_documents",
        "concealed_weapon",
        "wanted_poster"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Elf",
        "Orc"
      ],
      "suitable_classes": [
        "Rogue",
        "Ranger",
        "Warrior",
        "Wanderer"
      ],
      "introduction_text": "The dense foliage of the Echo Woods provides welcome cover as you pause to catch your breath. It's been three days since you slipped past the outer checkpoints of Harmonia, evading the guards who would happily collect the bounty now on your head. The wanted poster you took from the last outpost confirms your fears – your description has been circulated widely, though thankfully without an accurate likeness.\n\nYour crime – whether it was truly yours or one you were framed for – has made returning to any life you knew impossible. The stolen supplies in your pack might last another week if you're careful, but after that, you'll need to find a way to survive on the fringes of civilization. The forged documents might get you into one of the trading outposts where questions are fewer and coin speaks louder than official seals.\n\nOccasionally, the strange whispers of the Echo Woods seem to mock your situation, replaying fragments of the events that led to your downfall. Your fingers instinctively check the concealed weapon at your side – out here, justice and law are distant concepts, but danger is ever-present.\n\nAhead lies uncertainty, but behind lies certain capture. The whispers around you suddenly shift, no longer echoing the past but seemingly offering hints of possible futures. One path leads deeper into the unknown territories beyond the Concordant Cities' control. Another suggests a route to evidence that might clear your name. The choice, like the burden of your fugitive status, is yours alone to bear.",
      "skill_proficiencies": [
        "Stealth",
        "Deception",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Fugitive",
          "description": "You are wanted by Harmonian authorities and must avoid identification in controlled territories."
        },
        {
          "name": "Resourceful Survivor",
          "description": "You gain advantage on checks made to find basic food, water, or shelter in the wilderness."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "elven_emissary": {
      "id": "elven_emissary",
      "name": "Elven Emissary",
      "description": "As an Elf with exceptional magical sensitivity, you've been sent from your secluded community. Investigate the increasing frequency of Resonance Events and determine whether they pose a threat to your people.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "elven_crafted_robes",
        "ancestral_focus_crystal",
        "diplomatic_insignia",
        "resonance_journal",
        "preserved_provisions"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Elf"
      ],
      "suitable_classes": [
        "Mage",
        "Ranger",
        "Wanderer",
        "Cleric"
      ],
      "introduction_text": "The overwhelming sensory cacophony of Harmonia assaults your elven senses as you stand at the edge of the Seven-Ring Market. After decades of seclusion in your community's hidden enclave, the noise, smells, and most of all, the chaotic resonance patterns of this planar hub are almost too much to bear. You instinctively touch the ancestral focus crystal hanging at your neck, allowing its familiar energy to center you.\n\nFor centuries, your people have maintained their distance from the Concordant Cities, preferring to nurture their innate connection to magic in isolation. But the recent surge in Resonance Events has become impossible to ignore. Disturbances have reached even your secluded forests, disrupting ancient wards and causing unpredictable magical phenomena. When the Elders' Council needed an emissary, your exceptional sensitivity to planar energies made you the natural choice.\n\nYour mission is clear: gather information on these Resonance shifts, establish diplomatic relations where necessary, and determine whether this growing instability threatens elven lands. The diplomatic insignia hidden within your robes should grant you access to various authorities, though elves are still met with curious looks in these cities.\n\nAs you take your first steps into the crowded market, you feel the swirling currents of multiple planes intersecting around you. Your elven senses perceive what others cannot—a growing disharmony in the very fabric of reality. Something is unbalancing the planes, and your people need to know what, why, and how to protect themselves from whatever comes next.",
      "skill_proficiencies": [
        "Arcana",
        "Perception",
        "Planar Lore"
      ],
      "origin_traits": [
        {
          "name": "Elven Sensitivity",
          "description": "You have advantage on checks to perceive subtle magical or planar phenomena."
        },
        {
          "name": "Emissary Status",
          "description": "You carry diplomatic credentials representing your secluded elven community."
        }
      ]
    },
    "dwarven_craftmaster": {
      "id": "dwarven_craftmaster",
      "name": "Dwarven Craftmaster",
      "description": "As a master of traditional dwarven crafting techniques, you've traveled to the Crystalline Enclave. Study their precision technology and possibly establish a trade agreement that would benefit your distant mountain hold.",
      "starting_location_id": "crystalline_enclave",
      "starting_items": [
        "dwarven_forge_hammer",
        "master_crafting_tools",
        "clan_trade_contract",
        "metal_samples",
        "ceremonial_flask"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Dwarf"
      ],
      "suitable_classes": [
        "Warrior",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The geometrically perfect architecture of the Crystalline Enclave surrounds you, its mathematical precision both impressive and somehow lifeless to your dwarven sensibilities. Where dwarven crafting embraces the natural variations in stone and metal, celebrating the materials' inherent character, the Crystalline Consortium creates structures of such uniform exactness that they seem almost unnatural.\n\nNevertheless, you cannot deny their technological achievements. After three centuries of mastering traditional dwarven metallurgy and stonecraft at your mountain hold, you've been sent to study the Consortium's precision techniques and determine what might be adapted to enhance your clan's legendary craftsmanship. Your secondary mission—to establish a trade agreement for the unique metals and gems found only in your ancestral mines—would bring much-needed resources to your people.\n\nThe forge hammer at your belt, passed down through seven generations of master crafters, feels heavy with responsibility. Your clan has not sent an emissary to the outer planes in nearly two centuries, preferring self-sufficiency to outside entanglements. Yet resources grow scarcer in the mountains, and the hold's council finally acknowledged that controlled trade might be necessary for survival.\n\nYou take a deep breath, savoring the familiar scent of metal from the samples in your pack—a reminder of home and purpose. The Prismals of the Consortium are already studying you with their faceted eyes, likely cataloging every aspect of your dwarven appearance. Their analytical nature might seem cold, but you understand examination before commitment. After all, no master crafter would forge an alliance without first testing the materials thoroughly.",
      "skill_proficiencies": [
        "Crafting (Metallurgy)",
        "History (Dwarven)",
        "Appraisal"
      ],
      "origin_traits": [
        {
          "name": "Master Crafter's Eye",
          "description": "You gain advantage on checks made to assess the quality of metalwork or stonework."
        },
        {
          "name": "Clan Representative",
          "description": "You carry the authority to negotiate trade agreements on behalf of your dwarven clan."
        }
      ]
    },
    "mycora_envoy": {
      "id": "mycora_envoy",
      "name": "Mycora Envoy",
      "description": "As a Mycora from the Verdant plane, you've been sent to the Nexus world. Study how different planar environments affect growth patterns and share your people's symbiotic knowledge with other cultures.",
      "starting_location_id": "verdant_embassy",
      "starting_items": [
        "living_garments",
        "spore_collection_kit",
        "symbiotic_communication_pod",
        "seed_vault",
        "environmental_adaptation_tonic"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Mycora"
      ],
      "suitable_classes": [
        "Cleric",
        "Ranger",
        "Wanderer",
        "Mage"
      ],
      "introduction_text": "The carefully cultivated environment of the Verdant Embassy provides welcome familiarity after your transition from the Verdant plane, though you can sense its slight artificiality. The living walls here are distant cousins to the vast mycelial networks of your home, maintained through careful tending rather than existing in their natural state of constant evolution and adaptation.\n\nAs a chosen envoy of the Mycora collective consciousness, you carry with you the wisdom of thousands of growth cycles, the communal knowledge of your fungal species shared through spore-based memory transfer. Your mission has two symbiotic aspects: to collect and study growth patterns from different planar environments, and to share beneficial Mycoran techniques with other cultures.\n\nThrough the symbiotic communication pod at your side, you maintain a tenuous connection to your home collective, though the messages across planes arrive delayed and sometimes fragmented. The seed vault you carry contains carefully selected specimens that might thrive in new environments, potentially creating beneficial adaptations that could be reintegrated into the collective.\n\nYour living garments shift slightly, adjusting to the embassy's humidity levels—a practical demonstration of the Mycoran principle that all life should continually adapt rather than impose rigid order. This philosophy often puts your people at odds with the Crystalline Consortium's precise equations and the Concordant Cities' careful management of planar boundaries.\n\nAs you prepare to venture beyond the embassy's familiar environment, you take a small sip of adaptation tonic, feeling its effects spread through your system. Like all Mycora, you excel at finding balance in new ecosystems. The question is whether the beings of this plane will be receptive to the symbiotic wisdom you offer, or if they will see only an unusual fungal entity too different from themselves to trust.",
      "skill_proficiencies": [
        "Nature",
        "Medicine",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Collective Connection",
          "description": "You maintain a tenuous link to the Mycora collective, potentially receiving guidance or sharing information."
        },
        {
          "name": "Symbiotic Knowledge",
          "description": "You possess unique insights into plant life, fungi, and ecological balance."
        }
      ],
      "starting_culture_id": "verdant"
    },
    "prismal_researcher": {
      "id": "prismal_researcher",
      "name": "Prismal Researcher",
      "description": "As a Prismal mathematician specializing in planar geometry, you've been authorized by the Crystalline Consortium. Conduct field research at the Shifting Library, seeking patterns in the way knowledge exists across multiple planes simultaneously.",
      "starting_location_id": "shifting_library",
      "starting_items": [
        "crystalline_implants",
        "geometric_calculation_device",
        "consortium_authorization",
        "multidimensional_mapping_tools",
        "faceted_light_source"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Prismal"
      ],
      "suitable_classes": [
        "Mage",
        "Cleric",
        "Wanderer"
      ],
      "introduction_text": "The extraordinary spatial anomalies of the Shifting Library surround you, their mathematical complexity both fascinating and challenging even to your Prismal perceptions. Your crystalline body refracts the ambient light as you stand motionless, allowing your geometric implants to process and analyze the impossible architecture that allows the Library to exist simultaneously across multiple planes.\n\nThe Crystalline Consortium rarely approves extended external research missions, preferring controlled experiments within their precisely ordered environments. However, your theoretical work on planar intersection matrices proved sufficiently compelling for the High Calculation Chamber to make an exception. If your hypothesis about predictable patterns in cross-planar knowledge storage is correct, it would represent a significant advancement in the Consortium's understanding of reality's fundamental structure.\n\nYour geometric calculation device emits a soft hum as it continues mapping the Library's dimensional shifts, recording data that would overwhelm even the most brilliant non-Prismal mind. The faceted light source at your belt occasionally pulses in response to particularly complex spatial distortions, alerting you to areas worthy of detailed analysis.\n\nThe Lexicants have been surprisingly accommodating, granting you access to sections typically restricted to their own kind. Perhaps they recognize in your crystalline form a kindred appreciation for precision and order, though their organic methods of knowledge preservation seem needlessly inefficient compared to the perfect data storage of Prismal crystal matrices.\n\nAs your implants complete their initial calibration to the Library's unique resonance pattern, you mentally review your research parameters. The Consortium expects quantifiable results, precise measurements, and logical conclusions. What they do not expect—what you have not shared with them—is your personal hypothesis that the Library may contain mathematical proofs that could fundamentally alter the Consortium's understanding of reality itself.",
      "skill_proficiencies": [
        "Arcana",
        "Investigation",
        "Mathematics (Advanced)"
      ],
      "origin_traits": [
        {
          "name": "Planar Geometer",
          "description": "You possess advanced knowledge of the mathematical principles governing planar interactions."
        },
        {
          "name": "Consortium Authorization",
          "description": "Your research is sanctioned by the Crystalline Consortium, granting you specific privileges and access."
        }
      ],
      "starting_culture_id": "crystalline"
    },
    "cinderspawn_pilgrim": {
      "id": "cinderspawn_pilgrim",
      "name": "Cinderspawn Pilgrim",
      "description": "As a Cinderspawn seeking deeper spiritual connection with your ancestors, you've left the Ashen plane. Undertake a pilgrimage to various ceremonial fire sites across the Nexus world, beginning with the Eternal Flame at the Ashen Camp.",
      "starting_location_id": "ashen_camp",
      "starting_items": [
        "ancestral_ash_container",
        "ember_renewal_tonic",
        "pilgrimage_map",
        "flame-resistant_wrappings",
        "ritual_igniter"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Cinderspawn"
      ],
      "suitable_classes": [
        "Warrior",
        "Mage",
        "Cleric"
      ],
      "introduction_text": "The Eternal Flame at the center of the Ashen Camp flickers in response to your presence, its heat calling to the embers that constantly regenerate your Cinderspawn form. Fine ash trails behind you as you approach the sacred fire—not the lifeless dust of mundane ash, but living particles infused with ancestral memory and power. The Covenant members give you respectful distance, recognizing a fellow devotee of impermanence despite your origin from the Ashen plane itself.\n\nYour pilgrimage has just begun. The container of ancestral ash secured within your flame-resistant wrappings holds the remains of your progenitor—the one whose final immolation created the spark from which your consciousness formed. Through the sacred ritual of Ash Walking, you've communed with fragments of their memory, but full understanding remains elusive, like embers glimpsed through smoke.\n\nThe pilgrimage map, marked with locations of significant fires across the Nexus plane, will guide your journey. Each site offers an opportunity to perform the rituals that might strengthen your connection to the ancestral knowledge embedded in your very being. The Eternal Flame of the Ashen Camp marks only the first step.\n\nAs you kneel before the fire, you uncork the ember renewal tonic, consuming half and offering the remainder to the flames. Your body's internal heat intensifies, the ember at your core flaring brightly enough that the glow shows through your skin. The sensation is both painful and exhilarating—a reminder that in the philosophy of both the Ashen Covenant and your own people, transformation requires consumption, and rebirth demands destruction.\n\nTomorrow, you will continue your pilgrimage, following the map to the next sacred flame. But tonight, as sparks rise into the darkening sky, you prepare for the ritual that will temporarily separate your consciousness from your body, allowing your awareness to merge with the Eternal Flame and perhaps glimpse the wisdom of all who have surrendered themselves to its purifying heat.",
      "skill_proficiencies": [
        "Religion",
        "Endurance",
        "History (Oral)"
      ],
      "origin_traits": [
        {
          "name": "Pilgrim's Purpose",
          "description": "Your journey has a sacred goal, granting you inner resilience (+1 WIS save) against despair."
        },
        {
          "name": "Ashen Affinity",
          "description": "You have a natural connection to the Ashen plane and its associated magic (Ash Walking)."
        }
      ],
      "starting_culture_id": "ashen"
    },
    "maelstri_navigator": {
      "id": "maelstri_navigator",
      "name": "Maelstri Navigator",
      "description": "As a Maelstri, you've arrived at Tempest Harbor to serve as a navigator for trading vessels. Use your innate connection to storms to predict and navigate the chaotic weather patterns near the Tempest plane.",
      "starting_location_id": "tempest_harbor",
      "starting_items": [
        "storm_tattoo_kit",
        "weather_prediction_dice",
        "captain's_contract",
        "bottled_lightning",
        "temporal_compass"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Maelstri"
      ],
      "suitable_classes": [
        "Rogue",
        "Mage",
        "Wanderer"
      ],
      "introduction_text": "The swaying docks of Tempest Harbor shift beneath your feet in a rhythm that feels like home—chaotic yet somehow predictable to your Maelstri senses. The internal tempest that swirls within your partially translucent body resonates with the storm energies captured in the Flotilla's vessels, creating a harmony of chaotic potentials that other species could never perceive.\n\nYou've arrived during a rare celestial alignment, when the barriers between the Tempest plane and the Nexus are at their thinnest, allowing for easier passage and more reliable predictions. Your services as a navigator are in high demand; captains know that a Maelstri's intuitive understanding of probability and storm patterns can mean the difference between profitable voyages and disaster.\n\nThe captain's contract tucked into your belt represents your first commission in this harbor—a trading vessel seeking to venture dangerously close to the edges of the Tempest plane to collect rare storm essences. The payment offered is substantial, reflecting the risk involved and the value of your abilities.\n\nAs you wait for your meeting with the captain, you idly spin your weather prediction dice, their faces constantly shifting to display different meteorological patterns. With each tumble, you can sense the minute probability shifts they represent—not just predictions, but subtle manipulations of chance itself, a skill unique to your people.\n\nThe bottled lightning at your side occasionally illuminates your translucent skin from within as it resonates with the tempest inside you. Outsiders find it disconcerting how the storm patterns within your body never repeat, never settle into predictable forms. But then, that is the essence of being Maelstri—embracing the beauty of chaos and the certainty of change, guiding others through patterns they cannot comprehend.",
      "skill_proficiencies": [
        "Navigation",
        "Acrobatics",
        "Insight (Probability)"
      ],
      "origin_traits": [
        {
          "name": "Storm Sense",
          "description": "You can intuitively sense impending weather changes and planar disturbances related to the Tempest plane."
        },
        {
          "name": "Fluid Motion",
          "description": "You gain advantage on checks made to maintain balance in unstable or chaotic environments."
        }
      ],
      "starting_culture_id": "tempest"
    },
    "halfling_trader": {
      "id": "halfling_trader",
      "name": "Halfling Trader",
      "description": "As a halfling with a knack for finding valuable goods and spotting good deals, you've arrived at the bustling Tempest Harbor. You hope to make your fortune trading exotic goods from across the planes during a rare celestial alignment.",
      "starting_location_id": "tempest_harbor",
      "starting_items": [
        "trading_ledger",
        "sample_case_of_goods",
        "lucky_coin",
        "haggler's_pendant",
        "hidden_coin_purse"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Halfling"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer"
      ],
      "introduction_text": "The vibrant chaos of Tempest Harbor surrounds you, a halfling barely noticed among the taller traders and sailors rushing to conduct business before the celestial alignment ends and the harbor disappears. This suits you perfectly—being underestimated has always been your greatest advantage in the trading business.\n\nThe sample case of goods strapped across your back contains carefully selected items from three different planes, each small enough to carry easily but valuable enough to fund your next, larger venture. Your trading ledger, filled with contacts in ports across the Nexus plane, represents years of building trust and reputation despite the prejudice larger folk often hold against halfling merchants.\n\nYou absently finger the lucky coin in your pocket—not actually magical, despite what you tell potential business partners, but a reminder of your first successful trade. The haggler's pendant around your neck, however, genuinely helps focus your natural halfling luck during crucial negotiations, giving you an edge when deals come down to chance.\n\nThe hidden coin purse, sewn into the lining of your vest where nimble-fingered thieves wouldn't think to look, contains just enough capital to secure the exotic goods you've heard rumors about—crystalline computational devices from the Consortium, rare spores from the Verdant Collective, or perhaps emotional residue captured in ash by Covenant mystics.\n\nAs you weave through the crowd, your keen eyes notice pricing patterns and inventory shifts that others miss. The Tempest Flotilla's merchants follow no predictable system, their leadership changing hourly, but that apparent disorder holds opportunities for those observant enough to spot them. Being smaller than most traders means you hear conversations not meant for your ears and see deals happening under tables or behind curtains.\n\nYou adjust your sample case and head toward the Flux Market. With the right timing, a smallish halfling might just walk away with the biggest profit of the day.",
      "skill_proficiencies": [
        "Persuasion",
        "Appraisal",
        "Stealth"
      ],
      "origin_traits": [
        {
          "name": "Opportunistic Trader",
          "description": "You have a knack for spotting valuable goods and potential deals where others might not."
        },
        {
          "name": "Unassuming Presence",
          "description": "Your small stature allows you to blend into crowds easily, gaining advantage on checks to eavesdrop or remain unnoticed."
        }
      ],
      "starting_culture_id": "tempest"
    },
    "orc_mercenary": {
      "id": "orc_mercenary",
      "name": "Orc Mercenary",
      "description": "As an orc with a reputation for battlefield prowess, you've been hired to protect a research team. Your strength and combat experience will be crucial for survival in the dangerous Planar Bleed Zone.",
      "starting_location_id": "planar_bleed_zone",
      "starting_items": [
        "mercenary_contract",
        "heavy_weapon",
        "partial_armor_set",
        "protection_talisman",
        "battlefield_trophy"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Orc"
      ],
      "suitable_classes": [
        "Warrior",
        "Ranger"
      ],
      "introduction_text": "The impossible landscape of The Convergence stretches before you, a chaotic blend of elements from multiple planes that would disorient most guards. But you've seen stranger battlefields during your years as a mercenary, and your orcish senses are already cataloging potential threats and defensive positions around the researchers' camp.\n\nThe mercenary contract that brought you to this dangerous assignment promised triple the usual rate—compensation for the planar exposure risks that even the researchers' protective equipment can't fully mitigate. Your own protection comes in the form of a talisman given to you by the team leader, its magic constantly humming against your skin, supposedly stabilizing your personal reality against the zone's unpredictable effects.\n\nYour heavy weapon rests easily across your shoulders, its weight a familiar comfort in this unfamiliar environment. The partial armor set you wear offers protection while maintaining mobility—crucial in a place where the very ground might suddenly behave according to another plane's physical laws. The battlefield trophy hanging from your belt—a crystalline shard from your first campaign against rogue Consortium elements—serves as both lucky charm and reminder of past victories against seemingly impossible odds.\n\nThe research team eyes you with the usual mixture of wariness and relief that greets orcish mercenaries—fear of your species' legendary battle rage tempered by gratitude for having that same ferocity as protection. You've grown accustomed to these reactions, learning to use the intimidation factor to your advantage. It's usually better for morale if the clients believe nothing can frighten you, even if the truth is more complex.\n\nAs one of the researchers approaches with a map of planned exploration routes, you grin, revealing characteristic tusks. Time to earn your pay by keeping these scholars alive in a place where reality itself can't be trusted—just another day's work for an orc mercenary with a reputation to maintain.",
      "skill_proficiencies": [
        "Athletics",
        "Intimidation",
        "Survival"
      ],
      "origin_traits": [
        {
          "name": "Battle Hardened",
          "description": "You gain advantage on saving throws against fear effects."
        },
        {
          "name": "Mercenary Reputation",
          "description": "Your reputation precedes you, potentially influencing interactions with employers and other mercenaries."
        }
      ]
    },
    "fortune_seeker": {
      "id": "fortune_seeker",
      "name": "Fortune Seeker",
      "description": "Having heard rumors of a mysterious ghost market appearing during Resonance Events, offering items and opportunities not available anywhere else in the planes. You've positioned yourself in Harmonia to intercept its next manifestation.",
      "starting_location_id": "harmonia",
      "starting_items": [
        "resonance_detector",
        "trading_goods",
        "market_rumors_collection",
        "multi-planar_currency",
        "protective_charm"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human",
        "Halfling",
        "Elf",
        "Dwarf"
      ],
      "suitable_classes": [
        "Rogue",
        "Wanderer",
        "Mage"
      ],
      "introduction_text": "The streets of Harmonia hum with the usual energy of planar convergence, but your attention focuses on the subtle resonance fluctuations that your detector keeps registering near the eastern quarter. According to the rumor collection you've meticulously gathered over the past year, these are exactly the kind of pre-manifestation signals that precede the appearance of the legendary Ghost Market.\n\nMany dismiss the Ghost Market as mere myth—a fantastical bazaar run by entities known only as 'The Between,' appearing randomly during Resonance Events and offering impossible goods from all planes. But you've spoken with too many reliable sources, seen too many inexplicable items supposedly purchased there, to believe it's just a story. The pattern of manifestations you've mapped suggests the market is due to appear in Harmonia within days.\n\nThe protective charm hangs heavy around your neck, a necessary precaution according to those who claim to have visited the market successfully. 'The Between drive hard bargains,' one former merchant warned you, 'and sometimes the price isn't obvious until it's already been paid.' The multi-planar currency you've gathered—coins from across all five planes, each carrying its own unique resonance—should help you secure whatever opportunities arise.\n\nYour trading goods, carefully selected for their cross-planar rarity, represent most of your worldly wealth. It's a risk to invest so heavily in what might be a fruitless chase, but the potential rewards... rare artifacts, unique knowledge, perhaps even services unavailable anywhere else in any plane. Fortune favors the bold, after all, and you've never been accused of excessive caution.\n\nAs your resonance detector gives a particularly strong pulse, you adjust your course through the crowded street. The readings are getting stronger, more regular. If the pattern holds, you'll be perfectly positioned when the Ghost Market materializes. Then you'll discover firsthand if the opportunities it offers are worth the mysterious prices it demands.",
      "skill_proficiencies": [
        "Investigation",
        "Appraisal",
        "Planar Lore (Rumors)"
      ],
      "origin_traits": [
        {
          "name": "Market Chaser",
          "description": "You possess knowledge of rumored Ghost Market appearances and potential locations."
        },
        {
          "name": "Risk Taker",
          "description": "You are more willing to take chances for potential high rewards, for better or worse."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "human_diplomat": {
      "id": "human_diplomat",
      "name": "Human Diplomat",
      "description": "As a human diplomat representing Harmonia's interests, you've been assigned to the Verdant Embassy. Negotiate new trade agreements and cultural exchanges, leveraging your species' natural adaptability and diplomatic skills.",
      "starting_location_id": "verdant_embassy",
      "starting_items": [
        "diplomatic_credentials",
        "formal_negotiation_attire",
        "gift_package_for_ambassadors",
        "treaty_drafts",
        "translator's_guidebook"
      ],
      "initial_quests": [],
      "suitable_races": [
        "Human"
      ],
      "suitable_classes": [
        "Wanderer",
        "Mage",
        "Cleric"
      ],
      "introduction_text": "The living architecture of the Verdant Embassy surrounds you with an alien beauty that still manages to inspire rather than intimidate—exactly the kind of cross-cultural appreciation your diplomatic training emphasized. As Harmonia's newly appointed envoy to the Verdant Collective, you represent humanity's greatest strength: the ability to adapt to and find common ground with even the most different cultures across the planes.\n\nYour diplomatic credentials, bearing the seal of the Harmonic Council, opened doors easily enough, but you know that true rapport with the Verdant representatives will require more nuanced skills. The translator's guidebook you've studied for months has given you a basic understanding of their plant-based communication methods, though fluency in such an alien language remains elusive even for the most talented human linguists.\n\nThe treaty drafts in your attaché case represent months of preparation—proposals for expanded trade in medicinal compounds, research cooperation on adaptive agriculture, and cultural exchange programs that might benefit both societies. The formal negotiation attire you wear, designed to incorporate elements reminiscent of growth and renewal, was specifically commissioned to show respect for Verdant aesthetic values.\n\nThe gift package prepared for the ambassadors contains carefully selected offerings: seeds from rare Harmonian flowering plants, crystal prisms that refract light in patterns similar to Verdant spore displays, and small vials of pure water from the confluence springs near the Harmonic Spire. Such gifts, symbolic rather than extravagant, often speak louder than words in inter-planar diplomacy.\n\nAs you prepare for your first formal meeting with the Green Speakers, you mentally review what you know of their customs and hierarchies. Humans have long served as bridges between the more extreme differences of the planar races—lacking the specialized evolutionary adaptations of the Mycora or Prismals, but compensating with versatility and cultural flexibility. Today, those human diplomatic talents will be put to the test as you seek agreements beneficial to all within the complex web of inter-planar politics.",
      "skill_proficiencies": [
        "Diplomacy",
        "Persuasion",
        "Insight"
      ],
      "origin_traits": [
        {
          "name": "Harmonian Envoy",
          "description": "You represent the Concordant Cities and carry their diplomatic authority."
        },
        {
          "name": "Adaptive Negotiator",
          "description": "You gain advantage on checks made to understand and adapt to unfamiliar cultural norms during negotiations."
        }
      ],
      "starting_culture_id": "concordant"
    },
    "quest_testbed": {
      "id": "quest_testbed",
      "name": "Quest Testbed",
      "description": "A developer-focused starting origin in a special test hub designed to quickly generate and verify all quest proofs (items, kills, visits, flags).",
      "starting_location_id": "test_hub",
      "starting_items": [
        "test_apple"
      ],
      "initial_quests": [
        "TEST_Q01",
        "TEST_Q02",
        "TEST_Q03",
        "TEST_Q04",
        "TEST_Q05",
        "TEST_Q06",
        "TEST_Q07",
        "TEST_Q08",
        "TEST_Q09",
        "TEST_Q10",
        "TEST_Q11",
        "TEST_Q12",
        "TEST_Q13",
        "TEST_Q14",
        "TEST_Q15",
        "TEST_Q16",
        "TEST_Q17",
        "TEST_Q18",
        "TEST_Q19",
        "TEST_Q20",
        "TEST_Q21",
        "TEST_Q22",
        "TEST_Q23",
        "TEST_Q24",
        "TEST_Q25"
      ],
      "suitable_races": [
        "Human"
      ],
      "suitable_classes": [
        "Wanderer"
      ],
      "introduction_text": "This is a dedicated test scenario. You begin in the Quest Test Hub, with tools to validate quest objective detection and event logging.",
      "skill_proficiencies": [],
      "origin_traits": [],
      "starting_culture_id": "concordant"
    }
  },
  "metadata": {
    "version": "1.0.1",
    "description": "Starting origin definitions for the RPG game world"
  }
}
```

### File: config\world\scenarios\quests.json

```json
{
  "quests": {
    "luminary_fragment_hunt": {
      "id": "luminary_fragment_hunt",
      "title": "Echoes of the Luminaries",
      "description": "Reports indicate a Luminary fragment has manifested in the Echo Woods. Various factions are racing to obtain it, and the Harmonic Order has tasked you with retrieving it before it falls into dangerous hands.",
      "giver_id": "resonance_sage",
      "level": 3,
      "objectives": [
        {
          "id": "locate_fragment",
          "description": "Find the location of the Luminary fragment in Echo Woods",
          "type": "explore",
          "target_id": "whispering_grove",
          "location_id": "echo_woods",
          "completion_criteria": "Discover the Whispering Grove location where the fragment is hidden",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "defeat_cipher",
          "description": "Defeat the Cipher Remnant agents attempting to claim the fragment",
          "type": "kill",
          "target_id": "cipher_agents",
          "location_id": "whispering_grove",
          "completion_criteria": "Defeat all Cipher Remnant agents in the area",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "secure_fragment",
          "description": "Retrieve the Luminary fragment",
          "type": "fetch",
          "target_id": "luminary_fragment",
          "location_id": "whispering_grove",
          "completion_criteria": "Collect the Luminary fragment",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "return_fragment",
          "description": "Return the fragment to the Resonance Sage in Harmonia",
          "type": "deliver",
          "target_id": "resonance_sage",
          "location_id": "harmonia",
          "completion_criteria": "Deliver the Luminary fragment to the Resonance Sage",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 800,
        "gold": 250,
        "items": [
          "resonance_charm"
        ]
      },
      "prerequisites": []
    },
    "resonance_crisis": {
      "id": "resonance_crisis",
      "title": "Dangerous Frequencies",
      "description": "A small frontier settlement is experiencing unusually violent Resonance Events. The Harmonic Order needs someone to investigate the cause and protect the community during these unpredictable phenomena.",
      "giver_id": "council_speaker",
      "level": 5,
      "objectives": [
        {
          "id": "reach_settlement",
          "description": "Travel to the affected settlement near Echo Woods",
          "type": "explore",
          "target_id": "woodhaven_settlement",
          "location_id": "echo_woods",
          "completion_criteria": "Arrive at Woodhaven Settlement",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "investigate_anomalies",
          "description": "Investigate the unusual Resonance patterns in three locations around the settlement",
          "type": "explore",
          "target_id": "anomaly_sites",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Investigate all three anomaly sites",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "identify_disruptor",
          "description": "Identify the source of the Resonance disruption",
          "type": "fetch",
          "target_id": "dissonant_device",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Find the Dissonant Path device causing the disruptions",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "confront_dissonant",
          "description": "Confront the Dissonant Path member responsible for the disruption",
          "type": "kill",
          "target_id": "dissonant_disruptor",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Defeat the Dissonant Path member",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "stabilize_resonance",
          "description": "Use Planar Anchoring techniques to stabilize the area during the next Resonance Event",
          "type": "interact",
          "target_id": "resonance_node",
          "location_id": "woodhaven_settlement",
          "completion_criteria": "Complete the anchoring ritual at the village center",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 1200,
        "gold": 400,
        "items": [
          "planar_anchor_stone"
        ]
      },
      "prerequisites": []
    },
    "planar_expedition": {
      "id": "planar_expedition",
      "title": "Beyond the Veil",
      "description": "A research team from the Harmonic Order is mounting an expedition to explore a newly discovered Planar Bleed Zone. They need additional security and assistance to catalog the unique resources and phenomena within the zone.",
      "giver_id": "harmonic_researcher",
      "level": 4,
      "objectives": [
        {
          "id": "meet_expedition",
          "description": "Meet with the research team at their camp near The Convergence",
          "type": "explore",
          "target_id": "research_camp",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Find and speak with the research team at their camp",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "escort_researchers",
          "description": "Escort the research team safely into the Planar Bleed Zone",
          "type": "escort",
          "target_id": "research_team",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Protect all researchers during travel to the convergence perimeter",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "collect_samples",
          "description": "Collect samples from three different areas within the zone",
          "type": "fetch",
          "target_id": "planar_samples",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Collect all required samples",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "defend_camp",
          "description": "Defend the research camp from planar hybrid creatures",
          "type": "kill",
          "target_id": "planar_hybrids",
          "location_id": "research_camp",
          "completion_criteria": "Defeat all attacking creatures",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "document_anomaly",
          "description": "Help researchers document a major planar anomaly at the center of the zone",
          "type": "interact",
          "target_id": "reality_fault",
          "location_id": "planar_bleed_zone",
          "completion_criteria": "Complete documentation of the planar anomaly",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 1000,
        "gold": 350,
        "items": [
          "planar_sample_kit",
          "hybrid_seedling"
        ]
      },
      "prerequisites": []
    },
    "lost_knowledge": {
      "id": "lost_knowledge",
      "title": "Pages Through Time",
      "description": "The Shifting Library contains crucial information about stabilizing Resonance Events, but the needed texts only become accessible during a specific planar alignment. You need to obtain the required authorization and retrieve the knowledge before time runs out.",
      "giver_id": "head_lexicant",
      "level": 6,
      "objectives": [
        {
          "id": "obtain_authorization",
          "description": "Obtain authorization to access the Shifting Library from the Council of Resonance",
          "type": "interact",
          "target_id": "council_speaker",
          "location_id": "harmonia",
          "completion_criteria": "Convince the Council to grant library access",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "retrieve_focusing_crystal",
          "description": "Retrieve a focusing crystal from the Crystalline Enclave to help locate the texts",
          "type": "fetch",
          "target_id": "planar_focusing_crystal",
          "location_id": "crystalline_enclave",
          "completion_criteria": "Obtain the focusing crystal",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "access_library",
          "description": "Travel to the Shifting Library during the planar alignment",
          "type": "explore",
          "target_id": "shifting_library",
          "location_id": "shifting_library",
          "completion_criteria": "Reach the library during the alignment event",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "navigate_shifting_stacks",
          "description": "Navigate the constantly changing layout of the library to find the Pre-Shattering Archive",
          "type": "interact",
          "target_id": "shifting_stacks",
          "location_id": "shifting_library",
          "completion_criteria": "Solve the navigation puzzle of the shifting stacks",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "locate_texts",
          "description": "Find the texts about Resonance stabilization in the Pre-Shattering Archive",
          "type": "fetch",
          "target_id": "resonance_codex",
          "location_id": "pre_shattering_archive",
          "completion_criteria": "Locate and retrieve the Resonance Codex",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "escape_collapse",
          "description": "Escape the library as the planar alignment ends and sections begin disappearing",
          "type": "explore",
          "target_id": "library_entrance",
          "location_id": "shifting_library",
          "completion_criteria": "Reach the library entrance with the codex before time runs out",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 1500,
        "gold": 300,
        "items": [
          "lexicant_cipher",
          "plane_reader"
        ]
      },
      "prerequisites": []
    },
    "merchant_protection": {
      "id": "merchant_protection",
      "title": "Valuable Cargo",
      "description": "The Mercantile Chord is transporting a shipment of rare Resonant Materials between trading hubs and needs protection from bandits and natural hazards.",
      "giver_id": "mercantile_factor",
      "level": 3,
      "objectives": [
        {
          "id": "meet_caravan",
          "description": "Meet with the merchant caravan in Harmonia",
          "type": "interact",
          "target_id": "caravan_master",
          "location_id": "harmonia",
          "completion_criteria": "Meet and speak with the caravan master",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "escort_to_crystalline",
          "description": "Escort the caravan to the Crystalline Enclave",
          "type": "escort",
          "target_id": "merchant_caravan",
          "location_id": "crystalline_enclave",
          "completion_criteria": "Safely escort the caravan to its destination",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "fend_off_bandits",
          "description": "Protect the caravan from bandit attacks along the route",
          "type": "kill",
          "target_id": "resonance_bandits",
          "location_id": "",
          "completion_criteria": "Defeat all bandit groups that attack the caravan",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "navigate_flux_zone",
          "description": "Help the caravan safely navigate through a minor Resonance flux zone",
          "type": "interact",
          "target_id": "flux_zone",
          "location_id": "",
          "completion_criteria": "Successfully guide the caravan through the flux zone",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "delivery_complete",
          "description": "Ensure the cargo is safely delivered to the Crystalline Enclave",
          "type": "interact",
          "target_id": "consortium_representative",
          "location_id": "crystalline_enclave",
          "completion_criteria": "Complete delivery to the Consortium representative",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 750,
        "gold": 500,
        "items": [
          "resonant_trinket"
        ]
      },
      "prerequisites": []
    },
    "resonance_touched": {
      "id": "resonance_touched",
      "title": "Fragmented Self",
      "description": "A citizen of Harmonia has returned from a Resonance Event changed, possibly merged with an alternate version of themselves. They're experiencing 'Resonance sickness' and need help integrating their fragmented identity.",
      "giver_id": "attunement_master",
      "level": 2,
      "objectives": [
        {
          "id": "meet_patient",
          "description": "Meet with the Resonance-touched patient in the Attunement Hall",
          "type": "interact",
          "target_id": "resonance_touched_citizen",
          "location_id": "attunement_hall",
          "completion_criteria": "Meet and speak with the affected citizen",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "collect_erdium",
          "description": "Collect Erdium crystals to help with the reattunement ritual",
          "type": "fetch",
          "target_id": "erdium_crystal",
          "location_id": "echo_woods",
          "completion_criteria": "Gather the required erdium crystals",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "find_memories",
          "description": "Help the patient recover memories from before the Resonance Event",
          "type": "explore",
          "target_id": "memory_locations",
          "location_id": "harmonia",
          "completion_criteria": "Find all three memory locations in Harmonia",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "perform_ritual",
          "description": "Assist the Attunement Master in performing a reattunement ritual",
          "type": "interact",
          "target_id": "attunement_hall",
          "location_id": "harmonia",
          "completion_criteria": "Successfully complete the reattunement ritual",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "follow_up",
          "description": "Check on the patient after a few days to ensure the treatment worked",
          "type": "interact",
          "target_id": "resonance_touched_citizen",
          "location_id": "harmonia",
          "completion_criteria": "Follow up with the citizen to confirm recovery",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 500,
        "gold": 150,
        "items": [
          "identity_charm"
        ]
      },
      "prerequisites": []
    },
    "551cdb35-a4bb-4b23-b6c1-4d2772947efb": {
      "id": "551cdb35-a4bb-4b23-b6c1-4d2772947efb",
      "title": "Whispers of the Ash Plane (Ashen Covenant Recruit)",
      "description": "The Ashen Elder has tasked you with your first practical Ash Walking ritual. The Covenant needs to find a new, safe migration path, and the Elder believes a long-dead ancestor holds the key within the Ash Plane. You must project your consciousness, seek the ancestral spirit, and glean crucial information to guide your people.",
      "giver_id": "ashen_elder",
      "level": 1,
      "objectives": [
        {
          "id": "gather_ritual_ashes",
          "description": "Gather specific ritual ashes from the designated area near the Ashen Camp.",
          "type": "fetch",
          "target_id": "ritual_ashes",
          "location_id": "ashen_camp",
          "completion_criteria": "Collect the required ritual ashes for the Ash Walking ceremony.",
          "rewards": {},
          "mandatory": false
        },
        {
          "id": "perform_ash_walking_ritual",
          "description": "Perform the guided Ash Walking ritual at the sacred altar within the Ashen Camp.",
          "type": "interact",
          "target_id": "ash_walking_altar",
          "location_id": "ashen_camp",
          "completion_criteria": "Successfully initiate the Ash Walking ritual and project your consciousness.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "seek_ancestral_guidance",
          "description": "Within the Ash Plane, seek out the ancestral spirit and glean information about a safe migration path.",
          "type": "explore",
          "target_id": "ancestral_spirit_echo",
          "location_id": "ashen_camp",
          "completion_criteria": "Obtain the cryptic message or vision from the ancestral spirit.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "interpret_ancestral_message",
          "description": "Return to your body and consult with the Ashen Elder to interpret the ancestral message.",
          "type": "deliver",
          "target_id": "ashen_elder",
          "location_id": "ashen_camp",
          "completion_criteria": "Discuss the ancestral message with the Ashen Elder to understand its meaning.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "scout_new_migration_path",
          "description": "Based on the interpreted ancestral guidance, scout the new migration path in Echo Woods.",
          "type": "explore",
          "target_id": "migration_path_entrance",
          "location_id": "echo_woods",
          "completion_criteria": "Locate and assess the viability of the new migration path as indicated by the ancestor.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "gold": 50,
        "items": [
          "ash_walker_talisman"
        ],
        "xp": 200
      },
      "prerequisites": []
    },
    "the-first-exchange": {
      "id": "the-first-exchange",
      "title": "The First Exchange",
      "description": "A local merchant in Harmonia needs a small, important package delivered to a contact in the Verdant Embassy. This simple task will serve as your first foray into the world's commerce.",
      "giver_id": "merchant_guild_representative",
      "level": 1,
      "objectives": [
        {
          "id": "collect_package",
          "description": "Collect the delivery package from the Merchant Guild Representative in Harmonia.",
          "type": "fetch",
          "target_id": "delivery_package_harmonia",
          "location_id": "harmonia",
          "completion_criteria": "Obtain the delivery package from the representative.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "deliver_to_embassy",
          "description": "Deliver the package to the designated contact at the Verdant Embassy.",
          "type": "deliver",
          "target_id": "verdant_embassy_contact",
          "location_id": "verdant_embassy",
          "completion_criteria": "Successfully deliver the package to the contact.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "gold": 50,
        "items": [],
        "xp": 100
      },
      "prerequisites": []
    },
    "TEST_Q01": {
      "id": "TEST_Q01",
      "title": "Q01 – Fetch an Apple",
      "description": "Obtain a test apple.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Obtain 1 test_apple.",
          "type": "fetch",
          "target_id": "test_apple",
          "location_id": "",
          "completion_criteria": "Have at least 1 test_apple in inventory.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q02": {
      "id": "TEST_Q02",
      "title": "Q02 – Defeat the Test Wolf",
      "description": "Defeat the wolf",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat a wolf (test).",
          "type": "kill",
          "target_id": "wolf",
          "location_id": "harmonia",
          "completion_criteria": "Eliminate the wolf",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": "[]"
      },
      "prerequisites": []
    },
    "TEST_Q03": {
      "id": "TEST_Q03",
      "title": "Q03 – Visit the Test Ruins",
      "description": "Visit test_ancient_ruins.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_ancient_ruins.",
          "type": "explore",
          "target_id": "test_ancient_ruins",
          "location_id": "test_ancient_ruins",
          "completion_criteria": "Enter the test_ancient_ruins location.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q04": {
      "id": "TEST_Q04",
      "title": "Q04 – Speak to the Test Elder",
      "description": "Ensure flag test_spoke_to_elder is true.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Speak with the test_elder.",
          "type": "interact",
          "target_id": "test_elder",
          "location_id": "test_area",
          "completion_criteria": "Conversation with test_elder completed.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q05": {
      "id": "TEST_Q05",
      "title": "Q05 – Beat the Clock (Before 5m)",
      "description": "Complete before time < 300.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Finish the timed task before 300s.",
          "type": "interact",
          "target_id": "test_timer_gate",
          "location_id": "test_area",
          "completion_criteria": "Objective completed in under 300 seconds.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q06": {
      "id": "TEST_Q06",
      "title": "Q06 – After Time Gate (After 10m)",
      "description": "Complete only after time > 600.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Finish the timed task after 600s.",
          "type": "interact",
          "target_id": "test_timer_gate",
          "location_id": "test_area",
          "completion_criteria": "Objective completed after 600 seconds have elapsed.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q07": {
      "id": "TEST_Q07",
      "title": "Q07 – All Composite",
      "description": "Have test_key and defeat test_guardian.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Have test_key and defeat test_guardian.",
          "type": "interact",
          "target_id": "test_guardian_gate",
          "location_id": "test_area",
          "completion_criteria": "Gate opened with test_key and guardian defeated.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q08": {
      "id": "TEST_Q08",
      "title": "Q08 – Any Composite",
      "description": "Visit either test_dock or test_harbor.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_dock OR test_harbor.",
          "type": "explore",
          "target_id": "test_dock_or_harbor",
          "location_id": "test_coast",
          "completion_criteria": "Arrive at either test_dock or test_harbor.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q09": {
      "id": "TEST_Q09",
      "title": "Q09 – None Composite",
      "description": "Alarm must NOT be triggered.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Ensure alarm remains silent.",
          "type": "interact",
          "target_id": "test_alarm_system",
          "location_id": "test_area",
          "completion_criteria": "Objective completed with no alarm raised.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q10": {
      "id": "TEST_Q10",
      "title": "Q10 – Mandatory + Optional",
      "description": "Mandatory item; optional visit.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Obtain test_badge.",
          "type": "fetch",
          "target_id": "test_badge",
          "location_id": "",
          "completion_criteria": "Acquire the test_badge.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Optionally visit test_outpost.",
          "type": "explore",
          "target_id": "test_outpost",
          "location_id": "test_outpost",
          "completion_criteria": "Enter the test_outpost (optional).",
          "rewards": {},
          "mandatory": false
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q11": {
      "id": "TEST_Q11",
      "title": "Q11 – Two Mandatory Objectives",
      "description": "Complete both mandatory objectives.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat test_bandit_captain.",
          "type": "kill",
          "target_id": "test_bandit_captain",
          "location_id": "test_road",
          "completion_criteria": "Defeat the test_bandit_captain.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Collect 3 test_gem.",
          "type": "fetch",
          "target_id": "test_gem",
          "location_id": "",
          "completion_criteria": "Possess 3 test_gem.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q12": {
      "id": "TEST_Q12",
      "title": "Q12 – Semantic Only (No DSL)",
      "description": "Objective completion via semantic inference.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Convince the test_mayor to help.",
          "type": "interact",
          "target_id": "test_mayor",
          "location_id": "test_town",
          "completion_criteria": "Mayor agrees to help.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q13": {
      "id": "TEST_Q13",
      "title": "Q13 – Semantic Mandatory + Optional DSL",
      "description": "Mandatory semantic objective and optional visit objective.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Broker peace between test_factions.",
          "type": "interact",
          "target_id": "test_faction_council",
          "location_id": "test_hall",
          "completion_criteria": "Agreement reached between factions.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Optionally visit test_neutral_ground.",
          "type": "explore",
          "target_id": "test_neutral_ground",
          "location_id": "test_neutral_ground",
          "completion_criteria": "Enter test_neutral_ground (optional).",
          "rewards": {},
          "mandatory": false
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q14": {
      "id": "TEST_Q14",
      "title": "Q14 – Flag Chain",
      "description": "Require both flags set (speak to guard and acquire pass).",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Speak to guard and acquire pass.",
          "type": "interact",
          "target_id": "test_gate_guard",
          "location_id": "test_gate",
          "completion_criteria": "Guard spoken to and pass acquired.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q15": {
      "id": "TEST_Q15",
      "title": "Q15 – Inventory Count",
      "description": "Collect 3 test_herb.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Collect 3 test_herb.",
          "type": "fetch",
          "target_id": "test_herb",
          "location_id": "",
          "completion_criteria": "Possess 3 test_herb.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q16": {
      "id": "TEST_Q16",
      "title": "Q16 – Any of Three Enemies",
      "description": "Defeat any one of three test bandits.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat any bandit (1 of 3).",
          "type": "kill",
          "target_id": "test_bandit_group",
          "location_id": "test_road",
          "completion_criteria": "Defeat at least one of test_bandit_1/2/3.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q17": {
      "id": "TEST_Q17",
      "title": "Q17 – Visit Two Key Locations",
      "description": "Visit both test_gate and test_keep.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_gate and test_keep.",
          "type": "explore",
          "target_id": "test_gate_and_keep",
          "location_id": "test_realm",
          "completion_criteria": "Enter both test_gate and test_keep.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q18": {
      "id": "TEST_Q18",
      "title": "Q18 – Negative Flag (Not Banished)",
      "description": "Ensure not banished.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Ensure test_banished is false.",
          "type": "interact",
          "target_id": "test_citizenship_check",
          "location_id": "test_town",
          "completion_criteria": "Status confirms not banished.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q19": {
      "id": "TEST_Q19",
      "title": "Q19 – Mixed All/Any",
      "description": "Travel to dock or harbor and have a test_ticket.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Visit test_dock or test_harbor and show test_ticket.",
          "type": "interact",
          "target_id": "test_port_entry",
          "location_id": "test_coast",
          "completion_criteria": "Entry permitted with test_ticket at dock or harbor.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q20": {
      "id": "TEST_Q20",
      "title": "Q20 – Optional Does Not Block",
      "description": "Optional objective should not block completion.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Deliver test_letter.",
          "type": "deliver",
          "target_id": "test_recipient",
          "location_id": "test_town",
          "completion_criteria": "Deliver the test_letter to recipient.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Explore test_garden (optional).",
          "type": "explore",
          "target_id": "test_garden",
          "location_id": "test_garden",
          "completion_criteria": "Enter the test_garden.",
          "rewards": {},
          "mandatory": false
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q21": {
      "id": "TEST_Q21",
      "title": "Q21 – Narrative-Heavy Objective",
      "description": "Deliver an inspiring speech to the council.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Deliver an inspiring speech to the test_council about unity and cooperation.",
          "type": "interact",
          "target_id": "test_council",
          "location_id": "test_hall",
          "completion_criteria": "Speech delivered; council acknowledges.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q22": {
      "id": "TEST_Q22",
      "title": "Q22 – Three Mandatory Objectives",
      "description": "Complete three distinct tasks.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Defeat test_ogre.",
          "type": "kill",
          "target_id": "test_ogre",
          "location_id": "test_ogre_cave",
          "completion_criteria": "Ogre defeated.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O2",
          "description": "Collect 2 test_ogre_tooth.",
          "type": "fetch",
          "target_id": "test_ogre_tooth",
          "location_id": "",
          "completion_criteria": "Possess 2 test_ogre_tooth.",
          "rewards": {},
          "mandatory": true
        },
        {
          "id": "O3",
          "description": "Visit test_ogre_cave.",
          "type": "explore",
          "target_id": "test_ogre_cave",
          "location_id": "test_ogre_cave",
          "completion_criteria": "Enter the ogre cave.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q23": {
      "id": "TEST_Q23",
      "title": "Q23 – Semantic Failure Gating",
      "description": "Objective completion depends on semantic inference only.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Convince test_skeptic to trust you.",
          "type": "interact",
          "target_id": "test_skeptic",
          "location_id": "test_village",
          "completion_criteria": "Skeptic indicates trust.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q24": {
      "id": "TEST_Q24",
      "title": "Q24 – Abandon/Fallback Scenario",
      "description": "Regular quest for abandon/failure flow testing.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Recover the test_relic.",
          "type": "fetch",
          "target_id": "test_relic",
          "location_id": "test_ruins",
          "completion_criteria": "Obtain the test_relic.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    },
    "TEST_Q25": {
      "id": "TEST_Q25",
      "title": "Q25 – Complex Mixed Conditions",
      "description": "Any of two routes, but no alarm and with resource gate.",
      "giver_id": "test_proctor",
      "level": 1,
      "objectives": [
        {
          "id": "O1",
          "description": "Route A (visit test_tower AND have test_rope) OR Route B (defeat test_spider_queen) with no alarm.",
          "type": "interact",
          "target_id": "test_tower_or_spider_queen",
          "location_id": "test_vale",
          "completion_criteria": "No alarm triggered; either tower+rope route or spider queen defeated.",
          "rewards": {},
          "mandatory": true
        }
      ],
      "rewards": {
        "xp": 0,
        "gold": 0,
        "items": []
      },
      "prerequisites": []
    }
  },
  "metadata": {
    "version": "1.0.0",
    "description": "Quest definitions for the RPG game world"
  }
}
```

### File: gui\dialogs\README.md

```markdown
# GUI Dialogs

The `dialogs` directory contains dialog windows used in the game's graphical interface.

## Available Dialogs

### new_game_dialog.py

The `NewGameDialog` handles new game creation:
- Character name input
- Starting options selection
- Game difficulty settings (if applicable)
- Character customization options

### load_game_dialog.py

The `LoadGameDialog` provides save game loading functionality:
- Lists available save files
- Displays save metadata (character, date, location)
- Allows selection and loading of saves
- Delete save option

### save_game_dialog.py

The `SaveGameDialog` handles game saving:
- Save name input
- Overwrite confirmation
- Save metadata preview
- Quick save option

### settings/ (directory)

Contains dialogs for various settings:
- Game settings (difficulty, time scale, etc.)
- Graphics settings (resolution, effects, etc.)
- Sound settings (volume, music, effects)
- LLM settings (provider, model, parameters)

## Implementation

All dialogs are implemented as modal windows using PySide6 (Qt):
- Inherit from `QDialog`
- Provide result handling through `accept()` and `reject()`
- Include validation for user input
- Maintain consistent styling

## Common Features

All dialogs share these common features:
- Consistent styling and layout
- Cancel and confirm buttons
- Input validation
- Error and notification handling
- Persistence of settings

## Usage

Dialogs are typically shown from the main window or game menu:

```python
from gui.dialogs.new_game_dialog import NewGameDialog

# Create and show the dialog
dialog = NewGameDialog(parent=self)
result = dialog.exec_()

if result == QDialog.Accepted:
    # Get dialog data
    player_name = dialog.get_player_name()
    
    # Use the data
    self.engine.initialize(new_game=True, player_name=player_name)
```

## Future Enhancements

1. More comprehensive settings dialogs
2. Advanced character creation options
3. Save file management (backup, restore, etc.)
4. Configuration editors for game data
5. Help and tutorial dialogs

```

### File: config\character\backgrounds.json

```json
{
    "backgrounds": {
      "Noble": {
        "id": "Noble",
        "name": "Noble",
        "description": "Born into privilege, you are accustomed to high society, politics, and perhaps a bit of intrigue.",
        "starting_skills": ["Persuasion", "History"],
        "starting_items": ["Fine Clothes", "Signet Ring", "50 Gold"],
        "stat_modifiers": {"CHA": 1}
      },
      "Commoner": {
        "id": "Commoner",
        "name": "Commoner",
        "description": "You grew up among the ordinary folk, learning a trade or working the land. You are resilient and practical.",
        "starting_skills": ["Endurance", "Crafting (Basic)"],
        "starting_items": ["Simple Clothes", "Basic Tool", "10 Gold"],
        "stat_modifiers": {"CON": 1}
      },
      "Scholar": {
        "id": "Scholar",
        "name": "Scholar",
        "description": "You spent years studying lore, history, or the arcane. Knowledge is your greatest asset.",
        "starting_skills": ["Lore", "Investigation"],
        "starting_items": ["Scholar's Robes", "Book", "Ink & Quill", "20 Gold"],
        "stat_modifiers": {"INT": 1}
      },
      "Soldier": {
        "id": "Soldier",
        "name": "Soldier",
        "description": "You have seen battle, whether in an army, militia, or mercenary company. You understand discipline and combat.",
        "starting_skills": ["Athletics", "Intimidation"],
        "starting_items": ["Worn Uniform/Armor", "Token of Service", "Simple Weapon", "15 Gold"],
        "stat_modifiers": {"STR": 1}
      },
      "Outlaw": {
        "id": "Outlaw",
        "name": "Outlaw",
        "description": "You have lived outside the law, relying on your wits, stealth, or force to survive.",
        "starting_skills": ["Stealth", "Deception"],
        "starting_items": ["Dark Cloak", "Lockpicks", "Dagger", "25 Gold"],
        "stat_modifiers": {"DEX": 1}
      }
    }
  }
  
```

### File: config\character\classes.json

```json
{
  "classes": {
    "Warrior": {
      "id": "Warrior",
      "name": "Warrior",
      "description": "Masters of martial combat, warriors excel in physical strength and durability.",
      "stat_modifiers": {
        "STR": 2,
        "DEX": 0,
        "CON": 2,
        "INT": -1,
        "WIS": 0,
        "CHA": 0,
        "WIL": 2,
        "INS": -1
      },
      "minimum_stats": {
        "STR": 11,
        "CON": 10
      },
      "recommended_stats": {
        "primary": [
          "STR",
          "CON",
          "WIL"
        ],
        "secondary": [
          "DEX"
        ],
        "tertiary": [
          "WIS",
          "CHA",
          "INT",
          "INS"
        ]
      },
      "archetypes": {
        "Balanced": {
          "name": "Balanced",
          "description": "A well-rounded warrior effective in most situations",
          "stat_distribution": {
            "STR": 14,
            "DEX": 12,
            "CON": 14,
            "INT": 8,
            "WIS": 10,
            "CHA": 10
          }
        },
        "Offensive": {
          "name": "Offensive",
          "description": "A warrior focused on dealing maximum damage",
          "stat_distribution": {
            "STR": 16,
            "DEX": 12,
            "CON": 12,
            "INT": 8,
            "WIS": 8,
            "CHA": 10
          }
        },
        "Defensive": {
          "name": "Defensive",
          "description": "A warrior specialized in taking hits and protecting allies",
          "stat_distribution": {
            "STR": 12,
            "DEX": 10,
            "CON": 16,
            "INT": 8,
            "WIS": 12,
            "CHA": 8
          }
        }
      },
      "weapon_proficiencies": [
        "swords",
        "axes",
        "maces",
        "polearms",
        "shields"
      ],
      "armor_proficiencies": [
        "light",
        "medium",
        "heavy",
        "shields"
      ]
    },
    "Mage": {
      "id": "Mage",
      "name": "Mage",
      "description": "Scholars of the arcane, mages command powerful spells and magical knowledge.",
      "stat_modifiers": {
        "STR": -1,
        "DEX": 0,
        "CON": -1,
        "INT": 3,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 2
      },
      "minimum_stats": {
        "INT": 12
      },
      "recommended_stats": {
        "primary": [
          "INT",
          "INS"
        ],
        "secondary": [
          "WIS",
          "CON",
          "WIL"
        ],
        "tertiary": [
          "DEX",
          "CHA",
          "STR"
        ]
      },
      "archetypes": {
        "Elementalist": {
          "name": "Elementalist",
          "description": "A mage focused on elemental damage spells",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 10,
            "INT": 16,
            "WIS": 12,
            "CHA": 10
          }
        },
        "Enchanter": {
          "name": "Enchanter",
          "description": "A mage specialized in controlling minds and enhancing items",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 8,
            "INT": 14,
            "WIS": 12,
            "CHA": 14
          }
        },
        "Scholar": {
          "name": "Scholar",
          "description": "A mage with broad magical knowledge and versatile spellcasting",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 10,
            "INT": 16,
            "WIS": 14,
            "CHA": 8
          }
        }
      },
      "weapon_proficiencies": [
        "daggers",
        "staves",
        "wands"
      ],
      "armor_proficiencies": [
        "none"
      ]
    },
    "Rogue": {
      "id": "Rogue",
      "name": "Rogue",
      "description": "Masters of stealth and trickery, rogues excel in dexterity and cunning.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 3,
        "CON": 0,
        "INT": 1,
        "WIS": 0,
        "CHA": 1,
        "WIL": 0,
        "INS": 2
      },
      "minimum_stats": {
        "DEX": 12
      },
      "recommended_stats": {
        "primary": [
          "DEX",
          "INS"
        ],
        "secondary": [
          "INT",
          "CHA"
        ],
        "tertiary": [
          "CON",
          "WIS",
          "STR",
          "WIL"
        ]
      },
      "archetypes": {
        "Thief": {
          "name": "Thief",
          "description": "A rogue specialized in stealing and evading detection",
          "stat_distribution": {
            "STR": 8,
            "DEX": 16,
            "CON": 10,
            "INT": 12,
            "WIS": 10,
            "CHA": 10
          }
        },
        "Assassin": {
          "name": "Assassin",
          "description": "A rogue focused on dealing high damage from stealth",
          "stat_distribution": {
            "STR": 10,
            "DEX": 16,
            "CON": 10,
            "INT": 12,
            "WIS": 12,
            "CHA": 8
          }
        },
        "Bard": {
          "name": "Bard",
          "description": "A charming rogue with persuasive abilities",
          "stat_distribution": {
            "STR": 8,
            "DEX": 14,
            "CON": 10,
            "INT": 10,
            "WIS": 8,
            "CHA": 16
          }
        }
      },
      "weapon_proficiencies": [
        "daggers",
        "short swords",
        "bows",
        "crossbows"
      ],
      "armor_proficiencies": [
        "light"
      ]
    },
    "Cleric": {
      "id": "Cleric",
      "name": "Cleric",
      "description": "Divine agents who channel the power of their deity to heal and protect.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 0,
        "CON": 1,
        "INT": 0,
        "WIS": 3,
        "CHA": 1,
        "WIL": 2,
        "INS": 1
      },
      "minimum_stats": {
        "WIS": 12
      },
      "recommended_stats": {
        "primary": [
          "WIS",
          "WIL"
        ],
        "secondary": [
          "CON",
          "CHA",
          "INS"
        ],
        "tertiary": [
          "STR",
          "DEX",
          "INT"
        ]
      },
      "archetypes": {
        "Healer": {
          "name": "Healer",
          "description": "A cleric focused on healing and restoration",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 12,
            "INT": 8,
            "WIS": 16,
            "CHA": 12
          }
        },
        "Crusader": {
          "name": "Crusader",
          "description": "A battle cleric with combat and healing abilities",
          "stat_distribution": {
            "STR": 12,
            "DEX": 8,
            "CON": 12,
            "INT": 8,
            "WIS": 16,
            "CHA": 10
          }
        },
        "Oracle": {
          "name": "Oracle",
          "description": "A cleric with foresight and powerful divine magic",
          "stat_distribution": {
            "STR": 8,
            "DEX": 10,
            "CON": 10,
            "INT": 12,
            "WIS": 16,
            "CHA": 10
          }
        }
      },
      "weapon_proficiencies": [
        "maces",
        "hammers",
        "staves"
      ],
      "armor_proficiencies": [
        "light",
        "medium",
        "shields"
      ]
    },
    "Ranger": {
      "id": "Ranger",
      "name": "Ranger",
      "description": "Wilderness experts who combine combat prowess with natural knowledge.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": 2,
        "CON": 1,
        "INT": 0,
        "WIS": 2,
        "CHA": -1,
        "WIL": 1,
        "INS": 2
      },
      "minimum_stats": {
        "DEX": 11,
        "WIS": 11
      },
      "recommended_stats": {
        "primary": [
          "DEX",
          "WIS",
          "INS"
        ],
        "secondary": [
          "STR",
          "CON",
          "WIL"
        ],
        "tertiary": [
          "INT",
          "CHA"
        ]
      },
      "archetypes": {
        "Hunter": {
          "name": "Hunter",
          "description": "A ranger specialized in tracking and hunting prey",
          "stat_distribution": {
            "STR": 10,
            "DEX": 16,
            "CON": 10,
            "INT": 8,
            "WIS": 14,
            "CHA": 8
          }
        },
        "Beastmaster": {
          "name": "Beastmaster",
          "description": "A ranger with a powerful animal companion",
          "stat_distribution": {
            "STR": 10,
            "DEX": 14,
            "CON": 12,
            "INT": 8,
            "WIS": 14,
            "CHA": 10
          }
        },
        "Scout": {
          "name": "Scout",
          "description": "A wilderness expert with stealth and survival skills",
          "stat_distribution": {
            "STR": 10,
            "DEX": 14,
            "CON": 10,
            "INT": 10,
            "WIS": 14,
            "CHA": 8
          }
        }
      },
      "weapon_proficiencies": [
        "bows",
        "spears",
        "swords",
        "daggers"
      ],
      "armor_proficiencies": [
        "light",
        "medium"
      ]
    },
    "Wanderer": {
      "id": "Wanderer",
      "name": "Wanderer",
      "description": "Masterless adventurers who adapt to various situations with versatile skills.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 1,
        "CON": 1,
        "INT": 1,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 1
      },
      "minimum_stats": {},
      "recommended_stats": {
        "primary": [
          "DEX",
          "WIS",
          "WIL",
          "INS"
        ],
        "secondary": [
          "CON",
          "INT"
        ],
        "tertiary": [
          "STR",
          "CHA"
        ]
      },
      "archetypes": {
        "Jack-of-All-Trades": {
          "name": "Jack-of-All-Trades",
          "description": "A wanderer with balanced skills in many areas",
          "stat_distribution": {
            "STR": 10,
            "DEX": 12,
            "CON": 12,
            "INT": 12,
            "WIS": 12,
            "CHA": 10
          }
        },
        "Survivor": {
          "name": "Survivor",
          "description": "A wanderer focused on endurance and survival skills",
          "stat_distribution": {
            "STR": 10,
            "DEX": 12,
            "CON": 14,
            "INT": 10,
            "WIS": 14,
            "CHA": 8
          }
        },
        "Diplomat": {
          "name": "Diplomat",
          "description": "A wanderer specializing in social interaction and negotiation",
          "stat_distribution": {
            "STR": 8,
            "DEX": 12,
            "CON": 10,
            "INT": 12,
            "WIS": 10,
            "CHA": 14
          }
        }
      },
      "weapon_proficiencies": [
        "simple weapons"
      ],
      "armor_proficiencies": [
        "light"
      ]
    }
  }
}
```

### File: config\character\races.json

```json
{
  "races": {
    "Human": {
      "id": "Human",
      "name": "Human",
      "description": "Versatile and adaptable, humans are known for their diversity and ambition.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": 1,
        "CON": 1,
        "INT": 1,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 1
      },
      "traits": [
        {
          "name": "Adaptability",
          "description": "Humans can adapt to almost any situation. Gain +1 to all saving throws."
        },
        {
          "name": "Quick Learner",
          "description": "Humans gain 10% more experience from all sources."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Mage",
        "Rogue",
        "Cleric",
        "Ranger",
        "Wanderer"
      ]
    },
    "Elf": {
      "id": "Elf",
      "name": "Elf",
      "description": "Ancient and graceful, elves excel in magic and dexterity-based skills.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 2,
        "CON": -1,
        "INT": 2,
        "WIS": 1,
        "CHA": 1,
        "WIL": 1,
        "INS": 2
      },
      "traits": [
        {
          "name": "Keen Senses",
          "description": "Elves have heightened perception. Gain advantage on perception checks."
        },
        {
          "name": "Magic Affinity",
          "description": "Elves have a natural connection to magic. Spell costs are reduced by 10%."
        }
      ],
      "recommended_classes": [
        "Mage",
        "Ranger",
        "Wanderer"
      ]
    },
    "Dwarf": {
      "id": "Dwarf",
      "name": "Dwarf",
      "description": "Stout and hardy, dwarves are known for their resilience and craftsmanship.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": -1,
        "CON": 3,
        "INT": 0,
        "WIS": 2,
        "CHA": -1,
        "WIL": 3,
        "INS": 0
      },
      "traits": [
        {
          "name": "Dwarven Resilience",
          "description": "Dwarves resist poison and have additional health regeneration."
        },
        {
          "name": "Stonecunning",
          "description": "Dwarves have expertise with stone and metalwork. Advantage on related checks."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Cleric"
      ]
    },
    "Orc": {
      "id": "Orc",
      "name": "Orc",
      "description": "Powerful and fierce, orcs excel in physical combat and intimidation.",
      "stat_modifiers": {
        "STR": 3,
        "DEX": 0,
        "CON": 2,
        "INT": -1,
        "WIS": -1,
        "CHA": -1,
        "WIL": 2,
        "INS": -1
      },
      "traits": [
        {
          "name": "Relentless Endurance",
          "description": "Orcs can push through grievous wounds. Once per day, drop to 1 HP instead of 0."
        },
        {
          "name": "Savage Attacks",
          "description": "Orcs deal additional damage on critical hits."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Ranger"
      ]
    },
    "Halfling": {
      "id": "Halfling",
      "name": "Halfling",
      "description": "Small but nimble, halflings are lucky and naturally stealthy.",
      "stat_modifiers": {
        "STR": -1,
        "DEX": 3,
        "CON": 1,
        "INT": 0,
        "WIS": 1,
        "CHA": 1,
        "WIL": 0,
        "INS": 2
      },
      "traits": [
        {
          "name": "Lucky",
          "description": "Halflings can reroll critical failures once per day."
        },
        {
          "name": "Naturally Stealthy",
          "description": "Halflings gain advantage on stealth checks."
        }
      ],
      "recommended_classes": [
        "Rogue",
        "Wanderer"
      ]
    },
    "Mycora": {
      "id": "Mycora",
      "name": "Mycora",
      "description": "Fungal humanoids from the Verdant plane, Mycora share a communal consciousness and can adapt their bodies to various environments.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 0,
        "CON": 2,
        "INT": 0,
        "WIS": 3,
        "CHA": -1,
        "WIL": 2,
        "INS": 1
      },
      "traits": [
        {
          "name": "Spore Symbiosis",
          "description": "Mycora can release healing spores to regenerate health for themselves and nearby allies once per day."
        },
        {
          "name": "Environmental Adaptation",
          "description": "Mycora can adapt to toxic environments and gain resistance to poison and disease."
        }
      ],
      "recommended_classes": [
        "Cleric",
        "Ranger",
        "Wanderer"
      ]
    },
    "Prismal": {
      "id": "Prismal",
      "name": "Prismal",
      "description": "Crystalline beings from the Crystalline plane with geometric bodies that refract magical energies through their crystalline forms.",
      "stat_modifiers": {
        "STR": 1,
        "DEX": -1,
        "CON": 1,
        "INT": 3,
        "WIS": 1,
        "CHA": -1,
        "WIL": 0,
        "INS": 3
      },
      "traits": [
        {
          "name": "Crystal Resonance",
          "description": "Prismals can focus magical energies, reducing mana costs of spells by 15%."
        },
        {
          "name": "Geometric Insight",
          "description": "Prismals gain advantage on checks involving mathematics, precision, and magical formulas."
        }
      ],
      "recommended_classes": [
        "Mage",
        "Cleric"
      ]
    },
    "Cinderspawn": {
      "id": "Cinderspawn",
      "name": "Cinderspawn",
      "description": "Ash-infused beings from the Ashen plane whose bodies constantly regenerate from inner embers, leaving trails of fine ash behind them.",
      "stat_modifiers": {
        "STR": 2,
        "DEX": 1,
        "CON": 1,
        "INT": -1,
        "WIS": 1,
        "CHA": -2,
        "WIL": 2,
        "INS": 0
      },
      "traits": [
        {
          "name": "Ember Renewal",
          "description": "Cinderspawn regenerate health when near fire and gain resistance to fire damage."
        },
        {
          "name": "Ash Walking",
          "description": "Cinderspawn can temporarily transfer their consciousness to ashes, allowing limited espionage and communication."
        }
      ],
      "recommended_classes": [
        "Warrior",
        "Mage",
        "Ranger"
      ]
    },
    "Maelstri": {
      "id": "Maelstri",
      "name": "Maelstri",
      "description": "Storm-touched beings from the Tempest plane with partially translucent bodies that contain swirling internal tempests.",
      "stat_modifiers": {
        "STR": 0,
        "DEX": 3,
        "CON": 0,
        "INT": 1,
        "WIS": -1,
        "CHA": 2,
        "WIL": 0,
        "INS": 2
      },
      "traits": [
        {
          "name": "Storm Binding",
          "description": "Maelstri can capture essence of storms in their bodies, granting unpredictable magical abilities once per day."
        },
        {
          "name": "Electric Reflexes",
          "description": "Maelstri have lightning-fast reactions, gaining advantage on initiative rolls and dexterity saving throws."
        }
      ],
      "recommended_classes": [
        "Rogue",
        "Mage",
        "Wanderer"
      ]
    }
  }
}
```

### File: config\character\stats_config.json

```json
{
  "version": "1.0",
  "name": "Character Stats Configuration",
  "description": "Configuration for character statistics and derived values",
  
  "default_stat_value": 10,
  
  "base_strength": 10,
  "base_dexterity": 10,
  "base_constitution": 10,
  "base_intelligence": 10,
  "base_wisdom": 10,
  "base_charisma": 10,
  
  "base_health": 10,
  "hp_per_level": 5,
  
  "base_mana": 5,
  "mana_per_level": 3,
  
  "base_stamina": 10,
  "stamina_per_level": 2,
  
  "base_defense": 10,
  "base_magic_defense": 10,
  "max_dex_mod_to_defense": 5,
  
  "base_carry_capacity": 50,
  "carry_capacity_multiplier": 5,
  
  "base_movement": 30,
  
  "stat_min_value": 3,
  "stat_max_value": 20,
  
  "modifier_thresholds": {
    "1": -5,
    "2": -4,
    "3": -4,
    "4": -3,
    "5": -3,
    "6": -2,
    "7": -2,
    "8": -1,
    "9": -1,
    "10": 0,
    "11": 0,
    "12": 1,
    "13": 1,
    "14": 2,
    "15": 2,
    "16": 3,
    "17": 3,
    "18": 4,
    "19": 4,
    "20": 5
  },
  
  "races": {
    "human": {
      "stat_bonuses": {
        "strength": 1,
        "dexterity": 1,
        "constitution": 1,
        "intelligence": 1,
        "wisdom": 1,
        "charisma": 1
      },
      "abilities": ["versatile", "adaptable"]
    },
    "elf": {
      "stat_bonuses": {
        "dexterity": 2,
        "intelligence": 1,
        "wisdom": 1
      },
      "abilities": ["darkvision", "keen_senses"]
    },
    "dwarf": {
      "stat_bonuses": {
        "constitution": 2,
        "strength": 1,
        "wisdom": 1
      },
      "abilities": ["darkvision", "stonecutting", "poison_resistance"]
    }
  },
  
  "classes": {
    "warrior": {
      "primary_stats": ["strength", "constitution"],
      "hp_bonus": 2,
      "stamina_bonus": 2
    },
    "mage": {
      "primary_stats": ["intelligence", "wisdom"],
      "mp_bonus": 3,
      "magic_attack_bonus": 1
    },
    "rogue": {
      "primary_stats": ["dexterity", "charisma"],
      "initiative_bonus": 2,
      "evasion_bonus": 1
    }
  },
  
  "level_up": {
    "points_per_level": 2,
    "max_points_per_stat": 1
  },
  
  "combat": {
    "critical_hit_threshold": 20,
    "fumble_threshold": 1,
    "base_hit_chance": 65,
    "base_flee_chance": 50
  }
}

```

### File: core\base\README.md

```markdown
# Core Base Module (`core/base`)

This module provides the foundational building blocks and core systems for the game engine. It contains the essential infrastructure for game operation, including state management, command handling, the main game loop, configuration loading, and the central engine coordination.

## Purpose

The `core/base` module establishes the fundamental architecture upon which the rest of the game is built. It defines how game state is managed, how player input is processed, how time progresses, and how these different systems interact under the control of the main `GameEngine`.

## Key Components

### `GameEngine` (`engine.py`)

*   **Role**: The central coordinator and main entry point for game operations.
*   **Responsibilities**:
    *   Initializes and manages other base components (`StateManager`, `CommandProcessor`, `GameLoop`) and integrates with other systems like `AgentManager`.
    *   Handles game initialization (starting new games, loading saved games).
    *   Processes player input, routing it to `CommandProcessor` for direct commands or `AgentManager` for interactive text/LLM processing.
    *   Manages the game loop lifecycle (running, stopping, pausing).
    *   Coordinates auto-saving based on configuration.
    *   Emits game output (system messages, narration, etc.) via the `output_generated` PySide6 signal for decoupling from UI components.
*   **Access**: Singleton, accessed via `get_game_engine()`.

### `StateManager` (`state/state_manager.py`)

*   **Role**: Manages the lifecycle and persistence of the game state.
*   **Responsibilities**:
    *   Creates new `GameState` instances for new games.
    *   Saves the current `GameState` to a file, including player data, world data, stats, inventory, conversation history, etc.
    *   Loads `GameState` from save files, restoring the game to a previous point.
    *   Handles serialization and deserialization of the entire game state.
    *   Provides access to the currently active `GameState`.
    *   Manages save files (listing available saves, deleting saves, undoing deletion).
*   **Access**: Singleton, accessed via `get_state_manager()`.

### `CommandProcessor` (`commands.py`)

*   **Role**: Parses and executes player commands.
*   **Responsibilities**:
    *   Maintains a registry of standard game commands (e.g., `help`, `save`, `load`, `look`, `inventory`) and their handlers.
    *   Supports registration and execution of developer-specific commands (prefixed with `//`).
    *   Parses command arguments, respecting quoted strings.
    *   Processes special commands embedded within LLM responses (e.g., `{ITEM_CREATE chest}`).
    *   Defines `CommandResult` and `CommandStatus` to provide standardized outcomes for command execution (success, failure, error, exit, help).
*   **Access**: Singleton, accessed via `get_command_processor()`.

### `GameLoop` & `GameTime` (`game_loop.py`)

*   **`GameLoop`**:
    *   **Role**: Manages the progression of game time and scheduled events.
    *   **Responsibilities**: Operates on a tick-based system. Advances in-game time based on real-time elapsed and the current `GameSpeed`. Controls the game's speed (paused, normal, fast). Executes callbacks on each tick. Manages and executes `ScheduledEvent` instances at specific game times.
    *   **Access**: Singleton, accessed via `get_game_loop()`.
*   **`GameTime`**:
    *   **Role**: Represents and manipulates the in-game time.
    *   **Responsibilities**: Tracks the current game time (seconds since a starting epoch). Provides methods to get formatted date/time strings and the general time of day (Morning, Afternoon, etc.).
*   **`ScheduledEvent`**: Represents a callback function scheduled to run at a specific future game time, potentially repeating at intervals.

### State Dataclasses (`state/`)

These dataclasses define the structure of the game's state, managed by the `StateManager`.

*   **`GameState` (`game_state.py`)**: The top-level container for all state related to a single game session. It aggregates `PlayerState`, `WorldState`, an optional `CombatManager` (when combat is active), the conversation history, and session metadata (ID, timestamps, version).
*   **`PlayerState` (`player_state.py`)**: Holds all persistent information about the player character, including name, race, class (path), background, sex, level, experience, current location (area and district), references to their inventory and stats manager instances, equipped items, and quest status.
*   **`WorldState` (`world_state.py`)**: Contains information about the game world environment, such as the current game time, date, weather conditions, day/night status, active magical effects, global variables (used for tracking world events or quest progression), and a list of active world events.

### `GameConfig` (`config.py`)

*   **Role**: Manages game configuration settings.
*   **Responsibilities**: Loads configuration data from JSON files (e.g., `config/game_config.json`). Provides a simple interface to access configuration values throughout the application. Handles default values if specific settings are missing.
*   **Access**: Singleton, accessed via `get_config()`.

## Interactions

*   The `GameEngine` acts as the central orchestrator. It receives player input and uses the `CommandProcessor` (for commands like `/save`) or the `AgentManager` (for natural language) to handle it. It uses the `StateManager` to load/save the game and access the current `GameState`. It controls the `GameLoop` to manage time progression and pausing.
*   The `StateManager` is responsible for the `GameState` object. When saving/loading, it serializes/deserializes the `GameState`, which includes the nested `PlayerState` and `WorldState`, along with data from associated systems like stats and inventory.
*   The `CommandProcessor` and `AgentManager` operate on the current `GameState` provided by the `GameEngine` or `StateManager` to understand the context (player location, inventory, world variables) needed to execute commands or generate relevant LLM responses.
*   The `GameLoop` advances the `game_time` within the `WorldState` (managed by `StateManager`) and triggers scheduled events or tick callbacks, which might affect other parts of the state (e.g., NPC behavior, world events).

## Dependencies

*   **Internal Core Modules**:
    *   `core.utils`: For logging, JSON handling, save file management (`SaveManager`).
    *   `core.agents`: The `GameEngine` interacts with the `AgentManager` for LLM processing.
    *   `core.inventory`: `StateManager` saves/loads inventory data; `GameEngine` registers inventory commands.
    *   `core.combat`: `GameState` can hold a `CombatManager`; `StateManager` saves/loads combat state.
    *   `core.character`: `StateManager` interacts with `NPCSystem`.
    *   `core.stats`: `StateManager` saves/loads stats data via `StatsManager`.
*   **External Libraries**:
    *   `PySide6`: Used by `GameEngine` for its `output_generated` signal, enabling decoupling from the UI.

## Usage Example

The game engine is typically accessed through the `get_game_engine()` function, which returns a singleton instance of the `GameEngine` class:

```python
from core.base.engine import get_game_engine

# Get the engine instance
engine = get_game_engine()

# Start a new game (or load one)
engine.start_new_game(player_name="Adventurer")
# or engine.load_game("my_save.json")

# Process player input (command or natural language)
result = engine.process_command("look around") # Handled by LLM if enabled
result_save = engine.process_command("/save my_adventure") # Direct command

# Output is handled via the engine's output_generated signal
# (Connect a slot/function to this signal in your UI or main application)

```

### File: core\character\README.md

```markdown
# Core Character Module: Just-in-Time NPC System

This module (`core/character`) implements a dynamic system for managing Non-Player Characters (NPCs) within the game. Its core feature is a "just-in-time" generation approach, where NPCs are created and enhanced only when needed for specific interactions. This allows the game to efficiently manage a potentially large number of NPCs without requiring full generation of all characters at the start, optimizing performance and memory usage.

## Core Concept: Just-in-Time Generation

The primary innovation of this system is the "just-in-time" generation of NPCs. Instead of generating all NPCs with complete details up front, the system:

1.  Creates NPCs with minimal information when they are first encountered or mentioned (e.g., by name).
2.  Generates or enhances NPC stats, personality, and other details only when required for a specific type of interaction (e.g., combat, social dialogue, trading).
3.  Persists only the information that matters for future interactions, focusing on NPCs designated as `is_persistent`.

This approach offers several benefits:
-   Optimizes memory usage by only storing necessary information for active or important NPCs.
-   Creates more appropriate NPCs tailored to specific interaction types (e.g., stronger combat stats for enemies, higher charisma for merchants).
-   Allows narrative systems (like an LLM) to freely introduce NPCs without worrying about immediate, detailed implementation.
-   Saves processing time by avoiding the generation of unused NPCs or attributes.

## System Components

The `core/character` module is divided into several Python files for better organization and maintainability:

### 1. `npc_base.py`
-   **Purpose:** Defines the core data structures for NPCs.
-   **Key Classes/Enums:**
    -   `NPC`: The central dataclass representing an NPC, holding attributes like `id`, `name`, `npc_type`, `relationship`, `location`, `description`, `stats_manager`, `memories`, `inventory` (basic list), etc.
    -   `NPCMemory`: Dataclass representing a recorded interaction or event involving an NPC.
    -   `NPCType`: Enum defining NPC roles (MERCHANT, ENEMY, QUEST_GIVER, etc.).
    -   `NPCRelationship`: Enum defining the NPC's disposition towards the player (HOSTILE, FRIENDLY, NEUTRAL, etc.).
    -   `NPCInteractionType`: Enum defining the context of an interaction (COMBAT, SOCIAL, COMMERCE, etc.), used to determine necessary stats/details.
-   **Functionality:** Basic serialization (`to_dict`) and deserialization (`from_dict`) methods for `NPC` and `NPCMemory`.

### 2. `npc_manager.py`
-   **Purpose:** Manages the collection of active `NPC` objects currently loaded in memory.
-   **Key Class:** `NPCManager`.
-   **Functionality:** Acts as a central registry, providing methods for adding, removing, and retrieving NPCs using indices for ID, name (case-insensitive), and location.

### 3. `npc_generator.py`
-   **Purpose:** Responsible for generating NPC details, including stats, personality, and names.
-   **Key Class:** `NPCGenerator`.
-   **Functionality:**
    -   Loads NPC templates from configuration (`config/character/npc_templates.json`). Templates define stat ranges, personality traits, and name pools.
    -   Generates random names based on pools.
    -   Generates stats (`StatsManager` instance) appropriate for a given `NPCInteractionType` using template distributions.
    -   Enhances stats of existing NPCs for new interaction types.
    -   Generates basic personality descriptions.
-   **Dependencies:** `core.stats.stats_manager`, `config/character/npc_templates.json`.

### 4. `npc_creator.py`
-   **Purpose:** Provides a higher-level interface for creating and enhancing NPCs.
-   **Key Class:** `NPCCreator`.
-   **Functionality:**
    -   Uses `NPCGenerator` and `NPCManager`.
    -   Provides methods to create specific NPC types (`create_enemy`, `create_merchant`, etc.).
    -   Implements the core "get or create" logic (`get_or_create_npc`) for just-in-time instantiation.
    -   Handles enhancing existing NPCs when they are needed for a new interaction context (`enhance_npc_for_interaction`).

### 5. `npc_persistence.py`
-   **Purpose:** Manages the saving and loading of *persistent* NPCs to/from disk storage.
-   **Key Class:** `NPCPersistence`.
-   **Functionality:**
    -   Saves individual persistent NPCs (`save_npc`) or all persistent NPCs (`save_all_persistent_npcs`) to JSON files (named `{npc_id}.json`) in a specified directory (e.g., `saves/npcs/`).
    -   Loads NPCs from these files (`load_npc`, `load_all_npcs`).
    -   Handles cleanup of old/unused NPC files.
    -   Provides import/export functionality for NPC data.

### 6. `npc_memory.py`
-   **Purpose:** Manages the recording, retrieval, and lifecycle of NPC memories.
-   **Key Class:** `NPCMemoryManager`.
-   **Functionality:**
    -   Records new `NPCMemory` instances associated with an NPC (`record_interaction`).
    -   Retrieves memories based on recency, importance, location, or specific events (like relationship changes).
    -   Summarizes interactions with an NPC.
    -   Provides relevant memories as context for new interactions (`get_relevant_context_for_interaction`).
    -   Prunes old or unimportant memories to manage data size.

### 7. `background_generator.py`
-   **Purpose:** Generates or enhances narrative backgrounds for characters using an external LLM.
-   **Key Class:** `BackgroundGenerator`.
-   **Functionality:** Constructs prompts based on character data (race, class, etc.) and sends requests to the `LLMManager` to generate or improve background text.
-   **Dependencies:** `core.llm.llm_manager`.

### 8. `npc_system.py`
-   **Purpose:** Acts as a facade, integrating all the above components into a unified interface.
-   **Key Class:** `NPCSystem`.
-   **Functionality:**
    -   Initializes and provides access to the `NPCManager`, `NPCCreator`, `NPCPersistence`, and `NPCMemoryManager`.
    -   Provides high-level methods for common operations like loading/saving state, getting/creating NPCs (`get_or_create_npc`), preparing NPCs for interaction (`prepare_npc_for_interaction`), recording interactions, and retrieving interaction context.
    -   Simplifies interaction with the NPC subsystem for other parts of the game.

## Key Concepts & Data Flow

-   **NPC Representation:** The `NPC` class is the core data structure, holding all information about a non-player character. It relies on `core.stats.StatsManager` to handle numerical attributes and derived stats.
-   **Dynamic Stats:** Stats are not always pre-defined. `NPCGenerator` creates or enhances the `StatsManager` instance for an NPC based on the `NPCInteractionType` when needed.
-   **Memory:** Interactions are logged as `NPCMemory` objects, managed by `NPCMemoryManager`. These memories inform future interactions and can provide context to narrative systems.
-   **Persistence:** NPCs marked with `is_persistent=True` are saved by `NPCPersistence` to JSON files in the `saves/npcs/` directory (or as configured). `NPCSystem` orchestrates loading and saving the overall state.
-   **Configuration:** NPC generation relies heavily on templates defined in `config/character/npc_templates.json`.

## Interaction Types

The system uses `NPCInteractionType` to determine the necessary level of detail and specific stats required for an NPC:

-   **COMBAT**: Requires full combat stats (STR, DEX, CON, HP, Attack, Defense, etc.).
-   **SOCIAL**: Focuses on social stats (CHA, WIS).
-   **COMMERCE**: Focuses on relevant stats for trading (CHA, INT).
-   **QUEST**: May require specific knowledge or flags related to quests.
-   **INFORMATION**: Focuses on knowledge-related stats (INT, WIS).
-   **SERVICE**: May require specific skills or flags related to services offered.
-   **MINIMAL**: Requires only basic identification information; no stats are generated initially.

## Using the NPC System

The primary interface is the `NPCSystem` class, typically accessed via a central game state manager or a dedicated function like `get_npc_system()`.

```python
# Example: Assuming npc_system is an instance of NPCSystem

# Get or create an NPC for a specific interaction
# If "Guard Captain" exists, enhance for combat if needed. If not, create him.
npc, is_new = npc_system.get_or_create_npc(
    name="Guard Captain",
    interaction_type=NPCInteractionType.COMBAT,
    location="City Gates",
    npc_subtype="guard_captain" # Optional: uses specific template if available
)

# Record an interaction
memory = npc_system.record_interaction(
    npc_or_name="Guard Captain", # Can use name or NPC object
    interaction_type=NPCInteractionType.SOCIAL,
    description="Player asked about recent patrols.",
    location="City Gates",
    importance=5
)

# Get context for an LLM or dialogue system
context = npc_system.get_context_for_interaction(
    "Guard Captain",
    NPCInteractionType.SOCIAL
)
# context dictionary contains npc details, relevant stats, and recent/important memories
```

## Integration with LLM & Narrative

The just-in-time approach is well-suited for integration with LLM-driven narrative engines:

1.  The LLM can mention NPCs by name without needing them to exist beforehand.
2.  `npc_system.get_or_create_npc` handles creating a minimal NPC record.
3.  When an interaction occurs (e.g., player talks to the NPC), `npc_system.prepare_npc_for_interaction` ensures the NPC has the necessary details (like social stats).
4.  `npc_system.get_context_for_interaction` provides the LLM with the NPC's current state, relevant stats, and past interactions (memories) to inform its response generation.
5.  `BackgroundGenerator` can be invoked to create richer backstories for important NPCs introduced by the LLM.

This allows the narrative engine to dynamically populate the world with characters without the burden of pre-defining every detail.

```

### File: core\combat\README.md

```markdown
# Combat System (`core.combat`)

This module implements the turn-based combat system for the RPG game. It handles combat encounters, including entity management, turn order, action resolution, damage calculation, status effects, and interaction with other core systems.

## Overview

The combat system provides the framework for resolving conflicts between the player and enemies. Key features include:

-   **Turn-Based Flow:** Combat proceeds in rounds, with entities taking turns based on initiative.
-   **Action System:** Entities can perform various actions like attacking, casting spells, defending, using items, or attempting to flee.
-   **Stat Integration:** Combat calculations (hit chance, damage, defense, initiative) rely heavily on entity stats defined in `core.stats`.
-   **Dice Mechanics:** Uses the `core.utils.dice` module for randomized outcomes like attack rolls, damage, and critical hits/fumbles.
-   **Status Effects:** Entities can be affected by various conditions (e.g., defending, poisoned) that modify their capabilities or inflict damage over time.
-   **Combat Logging:** Records significant events during the encounter.

## Core Components

### 1. Combat Manager (`combat_manager.py`)

The central orchestrator of combat encounters.

-   **`CombatManager` Class:**
    -   Manages the overall state of a combat encounter (`CombatState`: `NOT_STARTED`, `IN_PROGRESS`, `PLAYER_VICTORY`, `PLAYER_DEFEAT`, `FLED`).
    -   Holds references to all participating `CombatEntity` objects.
    -   Determines turn order by calculating initiative (`_determine_initiative`) based on entity stats and a random roll.
    -   Processes `CombatAction` objects submitted by entities, resolving their effects (damage, healing, status effects, etc.).
    -   Advances turns (`_advance_turn`) and rounds.
    -   Checks for combat end conditions (player defeat, enemy defeat).
    -   Maintains a `combat_log` of events.
    -   Provides methods to start combat (`start_combat`) and get the current state (`get_combat_summary`).

### 2. Combat Entity (`combat_entity.py`)

Represents any participant in combat.

-   **`EntityType` Enum:** Defines the type of entity (`PLAYER`, `NPC`, `ALLY`, `ENEMY`, `CREATURE`).
-   **`CombatEntity` Class:**
    -   Stores the entity's current state in combat: ID, name, type, stats (from `core.stats`), current/max HP, MP, Stamina.
    -   Manages active `status_effects` (as a set of strings).
    -   Tracks initiative value and position (currently basic).
    -   Provides methods for taking damage (`take_damage`), healing (`heal`), spending/restoring resources (`spend_mp`, `spend_stamina`, etc.), and managing status effects (`add_status_effect`, `remove_status_effect`).
    -   Includes serialization methods (`to_dict`, `from_dict`).

### 3. Combat Action (`combat_action.py`)

Defines actions that entities can perform.

-   **`ActionType` Enum:** Categorizes actions (`ATTACK`, `SPELL`, `SKILL`, `DEFEND`, `ITEM`, `FLEE`, `MOVE`, `OTHER`).
-   **`CombatAction` Dataclass:** Base representation for an action, including performer ID, targets, costs (MP, stamina), dice notation for effects, description, and special effects.
-   **Specialized Action Subclasses:** Provide constructors and specific details for common actions:
    -   `AttackAction`: Basic attacks.
    -   `SpellAction`: Casting spells.
    -   `DefendAction`: Taking a defensive stance (applies "defending" status).
    -   `ItemAction`: Using items (currently basic implementation).
    -   `FleeAction`: Attempting to escape combat.

### 4. Developer Commands (`dev_commands.py`)

Provides commands for testing and debugging the combat system via the command processor (`core.base.commands`).

-   Registers commands like `//start_combat`, `//combat_status`, `//set_hp`, `//combat_action`.
-   Includes helper functions (`create_player_combat_entity`, `create_npc_combat_entity`) to convert game state objects (Player, NPCs from `core.character.npc_system`) into `CombatEntity` instances suitable for the `CombatManager`.

## Combat Flow

1.  **Initialization (`CombatManager.start_combat`):**
    -   Player and enemy entities are added to the `CombatManager`.
    -   Initiative is rolled for all entities (`_determine_initiative`).
    -   Turn order is established based on initiative rolls (highest first).
    -   Combat state is set to `IN_PROGRESS`, round counter starts at 1.
    -   Combat start and turn order are logged.
2.  **Turn Progression (`CombatManager._advance_turn`):**
    -   The manager identifies the `CombatEntity` whose turn it is based on the `turn_order` and `current_turn_index`.
    -   The entity (or its controlling agent/player) decides on a `CombatAction`.
3.  **Action Execution (`CombatManager.perform_action`):**
    -   The chosen `CombatAction` is passed to the `CombatManager`.
    -   The manager validates the action (is it the performer's turn? enough resources?).
    -   The appropriate handler (`_handle_attack_action`, `_handle_spell_action`, etc.) is called.
    -   **Resolution:**
        -   **Attack:** Roll to hit (d20 + bonus) vs. target's defense. On hit, roll damage (`dice_notation`), apply damage to target's HP. Check for critical hits/fumbles.
        -   **Spell/Item:** Check resource costs, apply effects (damage, healing, status effects) based on `dice_notation` and `special_effects`.
        -   **Defend:** Apply "defending" status effect.
        -   **Flee:** Calculate flee chance based on agility comparison, roll percentage dice.
    -   Results are logged.
4.  **State Check (`CombatManager._check_combat_state`):**
    -   After each action, the manager checks if all players or all enemies are defeated.
    -   If an end condition is met, the `state` is updated (`PLAYER_VICTORY`, `PLAYER_DEFEAT`).
    -   If the flee action was successful, the state is set to `FLED`.
5.  **Next Turn:**
    -   If combat is still `IN_PROGRESS`, the turn index advances (`_advance_turn`).
    -   Defeated entities are skipped.
    -   If the turn order wraps around, the round number increments.
    -   The process repeats from step 2.

## Key Mechanics

### Damage Calculation

-   Handled primarily within `CombatManager._handle_attack_action` and effect application in other handlers.
-   **Hit Chance:** Typically involves a d20 roll + attacker's relevant bonus (e.g., from stats) compared against the target's defense value (derived stat).
-   **Damage:** Based on the action's `dice_notation` (e.g., "2d6+3"), rolled using `core.utils.dice.roll_dice_notation`.
-   **Critical Hits/Fumbles:** Detected using `core.utils.dice.check_success` based on the d20 roll. Criticals usually involve rolling extra damage dice (`core.utils.dice.roll_critical`).
-   **Application:** Damage is applied using `CombatEntity.take_damage`, which reduces `current_hp`.

### Status Effects

-   Managed by `CombatEntity` (stored in `status_effects` set).
-   Applied by actions (e.g., `DefendAction` adds "defending", spells/items can add others via `special_effects`).
-   The *effects* of status effects (e.g., damage reduction for "defending", damage over time for "burning") need to be implemented within the relevant calculation steps (e.g., modifying damage taken in `take_damage`, applying DoT at the start/end of a turn - *Note: Turn-based effect processing is not explicitly shown in the current `CombatManager` code*).

## Dependencies and Interactions

The `core.combat` module relies on several other parts of the codebase:

-   **`core.stats`:** Essential for `CombatEntity` attributes (HP, MP, Stamina) and combat calculations (initiative, attack bonuses, defense). `StatType` and `DerivedStatType` are used directly.
-   **`core.utils.dice`:** Used extensively by `CombatManager` for all random rolls (initiative, hit chance, damage, flee chance).
-   **`core.base.commands`:** Used by `__init__.py` and `dev_commands.py` to register console commands.
-   **`core.base.state`:** Used by `dev_commands.py` to access the global game state (player info, NPC system).
-   **`core.character.npc_system`:** Used by `dev_commands.py` to create `CombatEntity` instances for enemies when starting test combats.
-   **`core.items` (Planned):** The `ItemAction` exists, but full integration (checking inventory, consuming items) is not yet implemented in `CombatManager._handle_item_action`.
-   **`core.utils.logging_config`:** Used for logging combat events and debug information.

## Configuration

While specific combat rules (like status effect details, critical hit multipliers) might be intended for external configuration (e.g., JSON files), the analyzed code within `core/combat/` does not currently show direct reading from configuration files. Default values or logic are embedded within the code (e.g., flee chance calculation, defend action effect).

## Usage Examples

*(Existing examples retained for demonstrating basic API usage)*

### 1. Starting Combat

```python
from core.combat.combat_manager import CombatManager
from core.combat.combat_entity import CombatEntity, EntityType
# Assume player_stats and enemy_stats are dictionaries populated from core.stats
# Assume player and enemy are created similar to dev_commands helpers

# Create combat manager
combat_mgr = CombatManager()

# Start combat
combat_mgr.start_combat(player_entity, [enemy_entity])
```

### 2. Performing Combat Actions

```python
from core.combat.combat_action import AttackAction, DefendAction

# Assume combat_mgr is an active CombatManager instance
# Assume current entity ID is known

# Attack action
attack = AttackAction(
    performer_id="player", # Use actual entity ID
    target_id="enemy_goblin_1", # Use actual entity ID
    weapon_name="sword",
    dice_notation="1d8+3" # Example damage
)
result = combat_mgr.perform_action(attack)

# Defend action
defend = DefendAction(performer_id="player") # Use actual entity ID
result = combat_mgr.perform_action(defend)
```

### 3. Getting Combat Information

```python
from core.combat.combat_manager import CombatState

# Assume combat_mgr is an active CombatManager instance

# Get combat summary
summary = combat_mgr.get_combat_summary()
print(f"Round: {summary['round']}, Turn: {summary['current_turn']}")
for entity_id, entity_data in summary['entities'].items():
    print(f"  {entity_data['name']}: {entity_data['hp']}")

# Check if combat has ended
if combat_mgr.state != CombatState.IN_PROGRESS:
    print(f"Combat ended: {combat_mgr.state.name}")

# Get recent combat log entries
for entry in summary['log']:
    print(entry)
```

## LLM Integration

*(Existing section retained)*

The combat system supports integration with the LLM narrative system:

-   Combat results can be narrated by the LLM.
-   Special combat actions can be triggered through narrative.
-   The LLM can apply appropriate modifiers based on narrative context.
-   Combat log provides content for narrative descriptions.

## Future Enhancements

*(Existing section retained)*

-   Multiple target and area effect attacks/spells.
-   Positioning and movement mechanics.
-   More complex action economy (e.g., main action, bonus action).
-   Tactical options (flanking, cover, opportunity attacks).
-   Combat AI for enemy decision-making (potentially via `core.agents`).
-   Full integration with `core.items` for item consumption.
-   Processing of duration-based status effects each turn.

## Testing

*(Existing section retained)*

The combat system requires comprehensive testing, including:
-   Initiative and turn order logic.
-   Attack/spell/item/flee action resolution.
-   Status effect application and interaction.
-   Combat state transitions (victory, defeat, flee).
-   Edge cases and error handling.

```

### File: config\items\origin_items.json

```json
[
  {
    "id": "academic_robes",
    "name": "Academic Robes",
    "description": "Formal robes of a scholar from the Resonance Academy, adorned with symbols of knowledge.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.5,
    "value": 40,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "intelligence_bonus_research",
        "value": 1,
        "display_name": "Research Intelligence"
      }
    ],
    "durability": 60,
    "tags": [
      "clothing",
      "armor",
      "academic",
      "scholar"
    ],
    "is_consumable": false,
    "is_stackable": false,
    "is_quest_item": false,
    "dice_roll_effects": []
  },
  {
    "id": "ancestral_ash_container",
    "name": "Ancestral Ash Container",
    "description": "A specially crafted container made from obsidian and silver, designed to safely hold and preserve sacred ancestral ashes.",
    "item_type": "container",
    "rarity": "rare",
    "weight": 0.5,
    "value": 400,
    "custom_properties": {
      "spiritual_attunement": "high",
      "preservation_quality": "excellent"
    },
    "tags": [
      "container",
      "cinderspawn",
      "ash",
      "ritual",
      "ancestral"
    ]
  },
  {
    "id": "ancestral_focus_crystal",
    "name": "Ancestral Focus Crystal",
    "description": "A crystal passed down through generations, used by elves to channel and focus magical energies.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.2,
    "value": 600,
    "is_equippable": true,
    "equip_slots": [
      "off_hand",
      "neck"
    ],
    "stats": [
      {
        "name": "spell_power_bonus",
        "value": 1,
        "display_name": "Spell Power"
      }
    ],
    "tags": [
      "tool",
      "magic_focus",
      "elven",
      "crystal",
      "ancestral"
    ]
  },
  {
    "id": "apprentice_robes",
    "name": "Apprentice Robes",
    "description": "Simple, functional robes identifying you as an apprentice of the Crystalline Enclave.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.0,
    "value": 25,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 40,
    "tags": [
      "clothing",
      "armor",
      "crystalline_consortium",
      "apprentice"
    ]
  },
  {
    "id": "ash-treated_clothing",
    "name": "Ash-Treated Clothing",
    "description": "Simple, durable clothing treated with sacred ashes for resilience and a faint connection to ancestral spirits. Common among the Ashen Covenant.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 2.0,
    "value": 20,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "fire_resistance",
        "value": 5,
        "display_name": "Fire Resistance",
        "is_percentage": true
      }
    ],
    "durability": 80,
    "tags": [
      "clothing",
      "armor",
      "ashen_covenant",
      "treated"
    ]
  },
  {
    "id": "battlefield_trophy",
    "name": "Battlefield Trophy",
    "description": "A memento taken from a significant past battle – perhaps a tooth, a banner fragment, or a broken weapon piece.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.3,
    "value": 10,
    "tags": [
      "trophy",
      "memento",
      "battle"
    ]
  },
  {
    "id": "between_token",
    "name": "Between Token",
    "description": "A smooth, dark stone that feels cold to the touch. It occasionally whispers in an unknown tongue. Given by an entity from The Between.",
    "item_type": "miscellaneous",
    "rarity": "rare",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "custom_properties": {
      "function": "communication_conduit_the_between"
    },
    "tags": [
      "token",
      "quest_item",
      "ghost_market",
      "ethereal"
    ]
  },
  {
    "id": "blank_journal",
    "name": "Blank Journal",
    "description": "A high-quality, empty journal ready to be filled with notes and discoveries.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.6,
    "value": 12,
    "tags": [
      "tool",
      "writing",
      "notes"
    ]
  },
  {
    "id": "bottled_lightning",
    "name": "Bottled Lightning",
    "description": "A vial containing a swirling spark of contained lightning. Can be used as a light source or a volatile component.",
    "item_type": "miscellaneous",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 150,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 5,
    "custom_properties": {
      "light_duration_minutes": 10,
      "discharge_damage": "1d8_lightning_if_broken"
    },
    "tags": [
      "lightning",
      "consumable",
      "light_source",
      "component",
      "maelstri"
    ]
  },
  {
    "id": "calculation_crystals",
    "name": "Calculation Crystals",
    "description": "A set of precisely cut crystals used in Crystalline Consortium mathematics and Facet Magic.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 200,
    "custom_properties": {
      "attunement_required": true
    },
    "tags": [
      "tool",
      "crystalline_consortium",
      "magic_component",
      "mathematics"
    ]
  },
  {
    "id": "captain's_contract",
    "name": "Captain's Contract",
    "description": "A signed contract securing your services as a navigator for a trading vessel in Tempest Harbor.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "quest_item",
      "tempest_harbor",
      "navigation"
    ]
  },
  {
    "id": "cataloging_tools",
    "name": "Cataloging Tools",
    "description": "A set of specialized tools for handling, examining, and indexing delicate texts and artifacts.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.8,
    "value": 60,
    "stats": [
      {
        "name": "investigation_bonus_texts",
        "value": 1,
        "display_name": "Text Investigation Bonus"
      }
    ],
    "tags": [
      "tool",
      "shifting_library",
      "research",
      "cataloging"
    ]
  },
  {
    "id": "clan_trade_contract",
    "name": "Clan Trade Contract (Template)",
    "description": "A formal contract template outlining terms for trade agreements on behalf of your dwarven clan.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "dwarven",
      "trade",
      "quest_item"
    ]
  },
  {
    "id": "market_rumors_collection",
    "name": "Collection of Market Rumors",
    "description": "A bundle of notes, overheard conversations, and cryptic clues related to the Ghost Market and other illicit trade.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.4,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "notes",
      "rumors",
      "ghost_market",
      "quest_item"
    ]
  },
  {
    "id": "concealed_weapon",
    "name": "Concealed Dagger",
    "description": "A small, easily hidden dagger. Favored by those who prefer to remain unassuming.",
    "item_type": "weapon",
    "rarity": "common",
    "weight": 0.3,
    "value": 40,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d4-1"
      }
    ],
    "durability": 50,
    "tags": [
      "weapon",
      "dagger",
      "concealed",
      "stealth"
    ]
  },
  {
    "id": "consortium_authorization",
    "name": "Consortium Research Authorization",
    "description": "A high-level authorization grant from the Crystalline Consortium, permitting access to restricted data and locations.",
    "item_type": "key",
    "rarity": "rare",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "key",
      "crystalline_consortium",
      "authorization",
      "research"
    ]
  },
  {
    "id": "covenant_pendant",
    "name": "Covenant Pendant",
    "description": "A small, carved bone pendant bearing the symbol of the Ashen Covenant. It's said to ward off minor malevolent spirits.",
    "item_type": "accessory",
    "rarity": "common",
    "weight": 0.1,
    "value": 15,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "willpower",
        "value": 1,
        "display_name": "Willpower Save Bonus"
      }
    ],
    "tags": [
      "amulet",
      "ashen_covenant",
      "spiritual"
    ]
  },
  {
    "id": "crystalline_implants",
    "name": "Crystalline Implants (Interface)",
    "description": "Subtle crystalline implants that allow a Prismal to interface with Consortium technology and enhance cognitive processing.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.0,
    "value": 0,
    "is_equippable": true,
    "equip_slots": [
      "head"
    ],
    "stats": [
      {
        "name": "data_processing_speed",
        "value": 2,
        "display_name": "Data Processing"
      },
      {
        "name": "mathematical_aptitude",
        "value": 1,
        "display_name": "Mathematical Aptitude"
      }
    ],
    "tags": [
      "implant",
      "tool",
      "prismal",
      "crystalline_consortium",
      "interface"
    ]
  },
  {
    "id": "diplomatic_credentials",
    "name": "Diplomatic Credentials",
    "description": "Official credentials identifying you as a diplomat of Harmonia, granting certain privileges and access.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "credentials",
      "diplomacy",
      "harmonia",
      "quest_item"
    ]
  },
  {
    "id": "diplomatic_insignia",
    "name": "Diplomatic Insignia",
    "description": "A broach or pin signifying your status as an emissary from your people.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "diplomacy_bonus",
        "value": 1,
        "display_name": "Diplomacy Bonus"
      }
    ],
    "tags": [
      "accessory",
      "insignia",
      "diplomacy"
    ]
  },
  {
    "id": "diplomatic_papers",
    "name": "Diplomatic Papers",
    "description": "Official documents identifying you as an envoy and outlining your mission.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "official",
      "diplomacy"
    ]
  },
  {
    "id": "ceremonial_flask",
    "name": "Dwarven Ceremonial Flask",
    "description": "An ornate flask, often filled with strong dwarven ale for rituals or important occasions.",
    "item_type": "container",
    "rarity": "uncommon",
    "weight": 0.7,
    "value": 120,
    "custom_properties": {
      "capacity_ml": 500,
      "material": "silver_inlaid_steel"
    },
    "tags": [
      "container",
      "flask",
      "dwarven",
      "ceremonial"
    ]
  },
  {
    "id": "dwarven_forge_hammer",
    "name": "Dwarven Forge Hammer",
    "description": "A masterfully crafted hammer, perfectly balanced for smithing. It bears ancient dwarven runes.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 5.0,
    "value": 800,
    "is_equippable": true,
    "equip_slots": [
      "main_hand"
    ],
    "stats": [
      {
        "name": "crafting_smithing_bonus",
        "value": 2,
        "display_name": "Smithing Bonus"
      }
    ],
    "dice_roll_effects": [
      {
        "effect_type": "physical_blunt_damage",
        "dice_notation": "1d6"
      }
    ],
    "durability": 200,
    "tags": [
      "tool",
      "weapon",
      "hammer",
      "dwarven",
      "crafting",
      "smithing"
    ]
  },
  {
    "id": "elven_crafted_robes",
    "name": "Elven Crafted Robes",
    "description": "Elegant robes woven with subtle patterns that shimmer in the light, offering surprising resilience.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 1.0,
    "value": 250,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 2,
        "display_name": "Armor"
      },
      {
        "name": "magic_resistance_minor",
        "value": 5,
        "display_name": "Minor Magic Resist",
        "is_percentage": true
      }
    ],
    "durability": 70,
    "tags": [
      "clothing",
      "armor",
      "elven",
      "magic"
    ]
  },
  {
    "id": "ember_renewal_tonic",
    "name": "Ember Renewal Tonic",
    "description": "A potent tonic that revitalizes a Cinderspawn's inner ember, hastening regeneration and enhancing flame-based abilities.",
    "item_type": "consumable",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 200,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "stats": [
      {
        "name": "regeneration_boost",
        "value": 50,
        "display_name": "Regeneration Boost",
        "is_percentage": true
      },
      {
        "name": "flame_power_increase",
        "value": 2,
        "display_name": "Flame Power"
      },
      {
        "name": "duration_minutes",
        "value": 10,
        "display_name": "Duration (Minutes)"
      }
    ],
    "tags": [
      "potion",
      "consumable",
      "cinderspawn",
      "buff",
      "fire"
    ]
  },
  {
    "id": "emergency_beacon",
    "name": "Emergency Beacon",
    "description": "A single-use beacon that, when activated, sends a distress signal detectable across short planar distances.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 150,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "tags": [
      "tool",
      "emergency",
      "signal",
      "consumable"
    ]
  },
  {
    "id": "enchanted_quill",
    "name": "Enchanted Quill",
    "description": "A quill that writes with self-replenishing ink and whose script remains stable across planar shifts.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 220,
    "tags": [
      "tool",
      "writing",
      "magic",
      "shifting_library"
    ]
  },
  {
    "id": "environmental_adaptation_tonic",
    "name": "Environmental Adaptation Tonic",
    "description": "A Mycoran tonic that temporarily enhances the imbiber's ability to adapt to hostile environments.",
    "item_type": "consumable",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 180,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "stats": [
      {
        "name": "environmental_resistance_boost",
        "value": 15,
        "display_name": "Environmental Resist Boost",
        "is_percentage": true
      },
      {
        "name": "duration_minutes",
        "value": 30,
        "display_name": "Duration (Minutes)"
      }
    ],
    "tags": [
      "potion",
      "consumable",
      "mycora",
      "adaptation",
      "buff"
    ]
  },
  {
    "id": "explorer_clothing",
    "name": "Explorer's Clothing",
    "description": "Durable, multi-layered clothing designed for protection against the elements and rough terrain.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 3.0,
    "value": 40,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 2,
        "display_name": "Armor"
      },
      {
        "name": "cold_resistance_minor",
        "value": 5,
        "display_name": "Minor Cold Resistance",
        "is_percentage": true
      }
    ],
    "durability": 100,
    "tags": [
      "clothing",
      "armor",
      "explorer",
      "survival"
    ]
  },
  {
    "id": "faceted_focusing_lens",
    "name": "Faceted Focusing Lens",
    "description": "A crystal lens with numerous facets, used to focus mental energies or manipulate light for Crystalline magic.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 180,
    "is_equippable": true,
    "equip_slots": [
      "off_hand"
    ],
    "stats": [
      {
        "name": "magic_attack",
        "value": 1,
        "display_name": "Spell Focus"
      }
    ],
    "tags": [
      "tool",
      "magic_focus",
      "crystalline_consortium",
      "lens"
    ]
  },
  {
    "id": "faceted_light_source",
    "name": "Faceted Light Source",
    "description": "A Prismal light source that emits focused beams of coherent light, useful for analysis or as a weak cutting tool.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.4,
    "value": 300,
    "custom_properties": {
      "light_intensity_lumens": 500,
      "focus_modes": [
        "wide_beam",
        "narrow_beam",
        "pulse"
      ]
    },
    "tags": [
      "tool",
      "prismal",
      "light_source",
      "analysis"
    ]
  },
  {
    "id": "family_heirloom",
    "name": "Family Heirloom",
    "description": "A small, worn trinket passed down through your family. Its true value might be sentimental, or perhaps something more.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.1,
    "value": 5,
    "is_quest_item": true,
    "tags": [
      "trinket",
      "heirloom",
      "sentimental",
      "quest_item"
    ]
  },
  {
    "id": "family_signet_ring",
    "name": "Family Signet Ring",
    "description": "A ring bearing the crest of a fallen noble family. It might still carry some influence, or attract unwanted attention.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 120,
    "is_equippable": true,
    "equip_slots": [
      "finger_1",
      "finger_2",
      "finger_3",
      "finger_4",
      "finger_5",
      "finger_6",
      "finger_7",
      "finger_8",
      "finger_9",
      "finger_10"
    ],
    "stats": [
      {
        "name": "social_influence_minor",
        "value": 1,
        "display_name": "Minor Social Influence"
      }
    ],
    "tags": [
      "ring",
      "accessory",
      "noble",
      "signet"
    ]
  },
  {
    "id": "fine_clothes_(worn)",
    "name": "Fine Clothes (Worn)",
    "description": "Once elegant attire, now showing signs of wear and travel. Still better than common rags.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.8,
    "value": 35,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 40,
    "current_durability": 25,
    "tags": [
      "clothing",
      "armor",
      "noble",
      "worn"
    ]
  },
  {
    "id": "fire_striker",
    "name": "Fire Striker",
    "description": "A reliable flint and steel for starting fires. Essential for survival and Covenant rituals.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.3,
    "value": 5,
    "is_equippable": false,
    "is_consumable": false,
    "is_stackable": false,
    "tags": [
      "tool",
      "fire",
      "survival"
    ]
  },
  {
    "id": "flame-resistant_wrappings",
    "name": "Flame-Resistant Wrappings",
    "description": "Thick, specially treated cloth wrappings that offer significant protection against fire and extreme heat.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 0.8,
    "value": 120,
    "is_equippable": true,
    "equip_slots": [
      "wrists",
      "legs",
      "chest"
    ],
    "stats": [
      {
        "name": "fire_resistance",
        "value": 25,
        "display_name": "Fire Resistance",
        "is_percentage": true
      }
    ],
    "durability": 90,
    "tags": [
      "clothing",
      "armor",
      "cinderspawn",
      "fire_protection"
    ]
  },
  {
    "id": "forged_documents",
    "name": "Forged Documents",
    "description": "Passably crafted travel papers and identification that might fool a cursory inspection.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 150,
    "custom_properties": {
      "forgery_quality": "average"
    },
    "tags": [
      "document",
      "forgery",
      "deception"
    ]
  },
  {
    "id": "formal_attire",
    "name": "Formal Attire",
    "description": "Well-made clothing suitable for diplomatic functions and formal occasions.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 2.5,
    "value": 150,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "charisma_bonus_social",
        "value": 1,
        "display_name": "Social Charisma"
      }
    ],
    "durability": 50,
    "tags": [
      "clothing",
      "armor",
      "formal",
      "diplomacy"
    ]
  },
  {
    "id": "formal_negotiation_attire",
    "name": "Formal Negotiation Attire",
    "description": "Impeccably tailored attire designed to convey authority and respect during high-stakes negotiations.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 2.0,
    "value": 200,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "persuasion_bonus",
        "value": 1,
        "display_name": "Persuasion Bonus"
      },
      {
        "name": "social_standing_perception",
        "value": 2,
        "display_name": "Perceived Social Standing"
      }
    ],
    "durability": 60,
    "tags": [
      "clothing",
      "armor",
      "formal",
      "diplomacy",
      "negotiation"
    ]
  },
  {
    "id": "geometric_calculation_device",
    "name": "Geometric Calculation Device",
    "description": "A complex Prismal device used for advanced geometric and multidimensional calculations.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.8,
    "value": 900,
    "stats": [
      {
        "name": "calculation_accuracy_bonus",
        "value": 3,
        "display_name": "Calculation Accuracy"
      }
    ],
    "tags": [
      "tool",
      "prismal",
      "crystalline_consortium",
      "mathematics",
      "calculation"
    ]
  },
  {
    "id": "market_trinket",
    "name": "Ghost Market Trinket",
    "description": "A small, oddly shaped trinket of unknown material. It hums faintly when Resonance Events are near.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 70,
    "is_equippable": true,
    "equip_slots": [
      "trinket_1",
      "trinket_2"
    ],
    "stats": [
      {
        "name": "resonance_detection",
        "value": 1,
        "display_name": "Resonance Detection"
      }
    ],
    "tags": [
      "trinket",
      "accessory",
      "ghost_market",
      "planar"
    ]
  },
  {
    "id": "gift_package_for_ambassadors",
    "name": "Gift Package for Ambassadors",
    "description": "A carefully selected assortment of gifts representing Harmonian culture, intended for presentation to foreign dignitaries.",
    "item_type": "miscellaneous",
    "rarity": "uncommon",
    "weight": 2.5,
    "value": 300,
    "is_stackable": false,
    "custom_properties": {
      "contents_description": "Rare seeds, crystal prism, pure water vial"
    },
    "tags": [
      "gift",
      "diplomacy",
      "harmonia",
      "trade_good"
    ]
  },
  {
    "id": "guard_uniform",
    "name": "Guard Uniform",
    "description": "Standard issue uniform of the Harmonic Guard, offering decent protection and clear identification.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 10.0,
    "value": 200,
    "is_equippable": true,
    "equip_slots": [
      "chest",
      "legs",
      "head"
    ],
    "stats": [
      {
        "name": "armor",
        "value": 6,
        "display_name": "Armor"
      }
    ],
    "durability": 130,
    "tags": [
      "armor",
      "uniform",
      "harmonic_guard"
    ]
  },
  {
    "id": "haggler's_pendant",
    "name": "Haggler's Pendant",
    "description": "A pendant that subtly influences negotiations in the wearer's favor. Or so the seller claimed.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 200,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "bargaining_bonus",
        "value": 1,
        "display_name": "Bargaining Bonus"
      }
    ],
    "tags": [
      "pendant",
      "accessory",
      "trade",
      "persuasion"
    ]
  },
  {
    "id": "harmonian_tattoo_kit",
    "name": "Harmonian Tattoo Kit",
    "description": "A set of fine needles, vibrant inks, and resonance-infused balms used for creating Attunement tattoos in Harmonia.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 150,
    "tags": [
      "tool",
      "harmonia",
      "attunement",
      "artisan"
    ]
  },
  {
    "id": "heavy_weapon",
    "name": "Heavy Orcish Cleaver",
    "description": "A large, brutally effective cleaver favored by Orcish warriors. Requires considerable strength to wield effectively.",
    "item_type": "weapon",
    "rarity": "uncommon",
    "weight": 7.0,
    "value": 450,
    "is_equippable": true,
    "equip_slots": [
      "two_hand"
    ],
    "stats": [
      {
        "name": "strength_requirement",
        "value": 15,
        "display_name": "Strength Req."
      }
    ],
    "dice_roll_effects": [
      {
        "effect_type": "slashing",
        "dice_notation": "1d12"
      }
    ],
    "durability": 160,
    "tags": [
      "weapon",
      "axe",
      "orcish",
      "heavy",
      "two-handed"
    ]
  },
  {
    "id": "hidden_coin_purse",
    "name": "Hidden Coin Purse",
    "description": "A small, discreet coin purse designed to be easily concealed within clothing.",
    "item_type": "container",
    "rarity": "common",
    "weight": 0.1,
    "value": 15,
    "custom_properties": {
      "capacity_coins": 100,
      "concealment_bonus": 2
    },
    "tags": [
      "container",
      "stealth",
      "currency"
    ]
  },
  {
    "id": "hunting_knife",
    "name": "Hunting Knife",
    "description": "A sturdy knife, useful for skinning game, preparing food, or as a last resort weapon.",
    "item_type": "weapon",
    "rarity": "common",
    "weight": 0.4,
    "value": 30,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "stats": [],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d4-1"
      }
    ],
    "durability": 80,
    "tags": [
      "weapon",
      "knife",
      "tool",
      "survival"
    ]
  },
  {
    "id": "journal",
    "name": "Journal",
    "description": "A blank, sturdy journal and a charcoal pencil for recording observations and notes.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.5,
    "value": 10,
    "tags": [
      "tool",
      "writing",
      "notes"
    ]
  },
  {
    "id": "assistant_robes",
    "name": "Library Assistant Robes",
    "description": "Simple, yet well-made robes worn by assistants at the Shifting Library. They offer minor protection against ambient magical energies.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.2,
    "value": 30,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "magic_resistance_minor",
        "value": 2,
        "display_name": "Minor Magic Resist",
        "is_percentage": true
      }
    ],
    "durability": 50,
    "tags": [
      "clothing",
      "armor",
      "shifting_library",
      "assistant"
    ]
  },
  {
    "id": "library_authorization",
    "name": "Library Authorization",
    "description": "A crystalline token that grants access to common areas and basic resources within the Shifting Library.",
    "item_type": "key",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "key",
      "shifting_library",
      "authorization"
    ]
  },
  {
    "id": "living_garments",
    "name": "Living Garments",
    "description": "Clothing woven from living plant fibers that subtly adapt to the wearer and environment. A hallmark of Mycora design.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 300,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 2,
        "display_name": "Armor"
      },
      {
        "name": "environmental_adaptation",
        "value": 1,
        "display_name": "Environmental Adaptation"
      }
    ],
    "durability": 80,
    "tags": [
      "clothing",
      "armor",
      "mycora",
      "living",
      "adaptive"
    ]
  },
  {
    "id": "bread",
    "name": "Loaf of Bread",
    "template_id": "template_food_bread",
    "description": "A simple loaf of bread that provides sustenance.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 0.5,
    "value": 5,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 5,
    "stats": [
      {
        "name": "hunger_restore",
        "value": 15
      },
      {
        "name": "healing",
        "value": 5
      }
    ],
    "tags": [
      "food",
      "consumable"
    ]
  },
  {
    "id": "lucky_coin",
    "name": "Lucky Coin",
    "description": "A mundane coin that its owner believes brings good fortune. Its true power is likely psychological.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.01,
    "value": 1,
    "stats": [
      {
        "name": "luck_subtle",
        "value": 0.1,
        "display_name": "Subtle Luck (Placebo)"
      }
    ],
    "tags": [
      "coin",
      "trinket",
      "luck",
      "sentimental"
    ]
  },
  {
    "id": "lunch_bundle",
    "name": "Lunch Bundle",
    "description": "A piece of fruit, some dried meat, and a small waterskin wrapped in cloth.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 0.7,
    "value": 10,
    "is_consumable": true,
    "is_stackable": false,
    "custom_properties": {
      "contains": "fruit, dried_meat, waterskin_1_charge"
    },
    "stats": [
      {
        "name": "hunger_restore",
        "value": 20
      },
      {
        "name": "healing",
        "value": 8
      }
    ],
    "tags": [
      "food",
      "consumable",
      "bundle"
    ]
  },
  {
    "id": "master_crafting_tools",
    "name": "Master Crafting Tools",
    "description": "A comprehensive set of high-quality tools for various crafts, kept in a sturdy leather roll.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 3.0,
    "value": 650,
    "stats": [
      {
        "name": "crafting_general_bonus",
        "value": 1,
        "display_name": "General Crafting Bonus"
      }
    ],
    "tags": [
      "tool",
      "crafting",
      "masterwork"
    ]
  },
  {
    "id": "mercenary_contract",
    "name": "Mercenary Contract",
    "description": "A binding contract detailing the terms of your employment, payment, and objectives for the current assignment.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "quest_item",
      "mercenary"
    ]
  },
  {
    "id": "metal_samples",
    "name": "Metal Samples",
    "description": "Small ingots and pieces of various rare metals and alloys from your clan's mines.",
    "item_type": "material",
    "rarity": "uncommon",
    "weight": 2.0,
    "value": 400,
    "is_stackable": true,
    "stack_limit": 10,
    "tags": [
      "material",
      "metal",
      "dwarven",
      "trade_good",
      "crafting"
    ]
  },
  {
    "id": "multi-planar_currency",
    "name": "Multi-Planar Currency Pouch",
    "description": "A pouch containing a mix of currencies from various planes, useful for interplanar trade.",
    "item_type": "treasure",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 1000,
    "custom_properties": {
      "contents_description": "Mixed coins from Nexus, Verdant, Ashen, Crystalline, Tempest planes"
    },
    "tags": [
      "currency",
      "treasure",
      "planar",
      "trade_good"
    ]
  },
  {
    "id": "multidimensional_mapping_tools",
    "name": "Multidimensional Mapping Tools",
    "description": "A set of specialized tools for charting and navigating spaces with non-Euclidean or shifting geometries.",
    "item_type": "tool",
    "rarity": "epic",
    "weight": 1.5,
    "value": 1200,
    "tags": [
      "tool",
      "prismal",
      "mapping",
      "planar",
      "dimensional"
    ]
  },
  {
    "id": "notebook",
    "name": "Notebook",
    "description": "A well-made notebook for recording thoughts, observations, or calculations.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.4,
    "value": 8,
    "tags": [
      "tool",
      "writing",
      "notes"
    ]
  },
  {
    "id": "old_map",
    "name": "Old Map",
    "description": "A hand-drawn map given to you by a mysterious traveler, showing unfamiliar lands and cryptic symbols.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "map",
      "quest_item",
      "adventure"
    ]
  },
  {
    "id": "ornate_dagger",
    "name": "Ornate Dagger",
    "description": "A finely crafted dagger, more decorative than practical, but still sharp. A reminder of a wealthier past.",
    "item_type": "weapon",
    "rarity": "uncommon",
    "weight": 0.6,
    "value": 100,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "stats": [],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d4"
      }
    ],
    "durability": 60,
    "tags": [
      "weapon",
      "dagger",
      "ornate",
      "noble"
    ]
  },
  {
    "id": "partial_armor_set",
    "name": "Partial Plate Armor",
    "description": "A mismatched set of plate armor pieces, offering good protection for vital areas. Likely scavenged or repaired.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 18.0,
    "value": 300,
    "is_equippable": true,
    "equip_slots": [
      "chest",
      "shoulders"
    ],
    "stats": [
      {
        "name": "armor",
        "value": 10,
        "display_name": "Armor"
      }
    ],
    "durability": 140,
    "tags": [
      "armor",
      "plate",
      "heavy",
      "mismatched"
    ]
  },
  {
    "id": "partially_empty_memory_vial",
    "name": "Partially Empty Memory Vial",
    "description": "A crystal vial, cool to the touch, containing a swirling, faintly luminous mist. It feels like a part of you is missing when you hold it.",
    "item_type": "miscellaneous",
    "rarity": "rare",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "custom_properties": {
      "content": "fragmented_player_memories"
    },
    "tags": [
      "vial",
      "quest_item",
      "memory",
      "ghost_market",
      "ethereal"
    ]
  },
  {
    "id": "pilgrimage_map",
    "name": "Pilgrimage Map",
    "description": "A map charted on fire-resistant hide, marking known sacred flame sites across various planes.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "map",
      "cinderspawn",
      "pilgrimage",
      "quest_item"
    ]
  },
  {
    "id": "planar_map",
    "name": "Planar Map Fragment",
    "description": "A piece of an old map showing routes between Nexus and other, stranger planes. Some markings are unfamiliar.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 50,
    "tags": [
      "document",
      "map",
      "planar",
      "navigation"
    ]
  },
  {
    "id": "planar_protection_amulet",
    "name": "Planar Protection Amulet",
    "description": "An amulet issued to those venturing into unstable planar regions, offering some resistance to harmful energies.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 280,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "planar_hazard_resistance",
        "value": 10,
        "display_name": "Planar Hazard Resist",
        "is_percentage": true
      }
    ],
    "tags": [
      "amulet",
      "accessory",
      "protection",
      "planar"
    ]
  },
  {
    "id": "planar_protection_suit",
    "name": "Planar Protection Suit",
    "description": "A specialized suit designed to offer protection against moderate levels of hazardous planar energies and environmental effects.",
    "item_type": "armor",
    "rarity": "uncommon",
    "weight": 5.0,
    "value": 400,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 3,
        "display_name": "Armor"
      },
      {
        "name": "planar_damage_resistance",
        "value": 10,
        "display_name": "Planar Damage Resist",
        "is_percentage": true
      }
    ],
    "durability": 120,
    "tags": [
      "armor",
      "protection",
      "planar",
      "research"
    ]
  },
  {
    "id": "portable_writing_desk",
    "name": "Portable Writing Desk",
    "description": "A small, foldable desk with compartments for ink, quills, and paper.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 3.0,
    "value": 90,
    "tags": [
      "tool",
      "writing",
      "academic",
      "portable"
    ]
  },
  {
    "id": "precision_measuring_tools",
    "name": "Precision Measuring Tools",
    "description": "A set of fine calipers, rulers, and levels for accurate measurement in research.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 1.0,
    "value": 55,
    "tags": [
      "tool",
      "research",
      "measurement"
    ]
  },
  {
    "id": "precision_tools",
    "name": "Precision Tools",
    "description": "A kit of fine tools for delicate work, often used by Consortium artisans and researchers.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.7,
    "value": 75,
    "stats": [
      {
        "name": "crafting_fine_bonus",
        "value": 1,
        "display_name": "Fine Crafting Bonus"
      }
    ],
    "tags": [
      "tool",
      "crafting",
      "research",
      "crystalline_consortium"
    ]
  },
  {
    "id": "preserved_provisions",
    "name": "Preserved Elven Provisions",
    "description": "Lightweight, nutrient-rich food prepared using elven preservation techniques. Lasts for a long time.",
    "item_type": "consumable",
    "rarity": "uncommon",
    "weight": 1.0,
    "value": 50,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "custom_properties": {
      "days_of_sustenance_efficient": 5
    },
    "stats": [
      {
        "name": "hunger_restore_efficient",
        "value": 25
      }
    ],
    "tags": [
      "food",
      "consumable",
      "elven",
      "survival",
      "preserved"
    ]
  },
  {
    "id": "probability_dice",
    "name": "Probability Dice",
    "description": "A set of strangely weighted dice that seem to favor certain outcomes. Used by Tempest Flotilla gamblers.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 300,
    "custom_properties": {
      "luck_influence": "minor_positive_bias"
    },
    "tags": [
      "tool",
      "gambling",
      "tempest_flotilla",
      "chance"
    ]
  },
  {
    "id": "protection_talisman",
    "name": "Protection Talisman (Mercenary)",
    "description": "A rugged talisman, often carried by mercenaries, said to ward off ill luck and minor curses.",
    "item_type": "accessory",
    "rarity": "common",
    "weight": 0.2,
    "value": 80,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "save_bonus_minor_curses",
        "value": 1,
        "display_name": "Curse Resist (Minor)"
      }
    ],
    "tags": [
      "talisman",
      "accessory",
      "protection",
      "luck"
    ]
  },
  {
    "id": "protective_charm",
    "name": "Protective Charm (Anti-Ethereal)",
    "description": "A small charm said to offer minor protection against ethereal entities and influences from The Between.",
    "item_type": "accessory",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 220,
    "is_equippable": true,
    "equip_slots": [
      "trinket_1",
      "trinket_2"
    ],
    "stats": [
      {
        "name": "ethereal_resistance",
        "value": 5,
        "display_name": "Ethereal Resistance",
        "is_percentage": true
      }
    ],
    "tags": [
      "charm",
      "accessory",
      "protection",
      "ethereal",
      "ghost_market"
    ]
  },
  {
    "id": "rations_pack",
    "name": "Rations Pack (3 Days)",
    "description": "A pack containing enough preserved food and water for three days of travel.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 2.0,
    "value": 25,
    "is_consumable": true,
    "is_stackable": false,
    "custom_properties": {
      "days_of_sustenance": 3
    },
    "stats": [
      {
        "name": "hunger_restore_full_day",
        "value": 3
      }
    ],
    "tags": [
      "food",
      "consumable",
      "survival",
      "rations"
    ]
  },
  {
    "id": "reality_anchor",
    "name": "Reality Anchor (Personal)",
    "description": "A device that creates a small field of stabilized reality, offering protection against minor spatial distortions.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 1.2,
    "value": 700,
    "custom_properties": {
      "field_radius_meters": 1,
      "stability_rating": 3
    },
    "tags": [
      "tool",
      "planar",
      "protection",
      "research"
    ]
  },
  {
    "id": "recording_crystal",
    "name": "Recording Crystal",
    "description": "A crystal that passively records ambient sounds and subtle planar energies. Glows faintly when active.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.3,
    "value": 250,
    "custom_properties": {
      "storage_capacity_hours": 24,
      "sensitivity": "medium"
    },
    "tags": [
      "tool",
      "research",
      "planar",
      "crystal",
      "recording"
    ]
  },
  {
    "id": "research_notes",
    "name": "Research Notes",
    "description": "A collection of notes, theories, and references related to your current field of study.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.8,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "notes",
      "research",
      "academic"
    ]
  },
  {
    "id": "researcher_equipment",
    "name": "Researcher's Field Kit",
    "description": "A collection of tools for field research: sample bags, measuring devices, a multi-tool, and basic first aid.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 2.5,
    "value": 80,
    "custom_properties": {
      "contents_summary": "sample_bags, measuring_tape, multi_tool, first_aid_basics"
    },
    "tags": [
      "tool",
      "research",
      "kit",
      "field_work"
    ]
  },
  {
    "id": "resonance_amulet",
    "name": "Resonance Amulet",
    "description": "An amulet that hums faintly, designed to help stabilize its wearer during minor Resonance Events.",
    "item_type": "accessory",
    "rarity": "common",
    "weight": 0.1,
    "value": 100,
    "is_equippable": true,
    "equip_slots": [
      "neck"
    ],
    "stats": [
      {
        "name": "resonance_stability",
        "value": 5,
        "display_name": "Resonance Stability"
      }
    ],
    "tags": [
      "amulet",
      "harmonia",
      "planar",
      "protection"
    ]
  },
  {
    "id": "resonance_detector",
    "name": "Resonance Detector",
    "description": "A device that hums and glows in the presence of planar resonance or magical energies.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.7,
    "value": 350,
    "stats": [
      {
        "name": "perception_magic",
        "value": 2,
        "display_name": "Magic Perception"
      }
    ],
    "tags": [
      "tool",
      "magic_detection",
      "planar",
      "research"
    ]
  },
  {
    "id": "resonance_journal",
    "name": "Resonance Journal",
    "description": "A journal specifically designed to record observations of planar resonance and magical phenomena.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.6,
    "value": 80,
    "tags": [
      "tool",
      "writing",
      "research",
      "planar",
      "magic"
    ]
  },
  {
    "id": "ritual_dagger",
    "name": "Ritual Dagger",
    "description": "A ceremonial dagger, sharp and well-balanced, used by the Ashen Covenant in their rites. It feels strangely warm to the touch.",
    "item_type": "weapon",
    "rarity": "uncommon",
    "weight": 0.5,
    "value": 75,
    "is_equippable": true,
    "equip_slots": [
      "main_hand",
      "off_hand"
    ],
    "stats": [
      {
        "name": "melee_attack",
        "value": 1,
        "display_name": "Attack Bonus"
      }
    ],
    "dice_roll_effects": [
      {
        "effect_type": "piercing",
        "dice_notation": "1d6",
        "description": "Base weapon damage"
      }
    ],
    "durability": 70,
    "tags": [
      "weapon",
      "dagger",
      "ritual",
      "ashen_covenant"
    ]
  },
  {
    "id": "ritual_igniter",
    "name": "Ritual Igniter",
    "description": "A Cinderspawn tool that can create a spark of intense, spiritually attuned flame, used to light sacred fires.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.3,
    "value": 350,
    "custom_properties": {
      "uses_per_day": 3,
      "flame_purity": "high"
    },
    "tags": [
      "tool",
      "cinderspawn",
      "fire",
      "ritual"
    ]
  },
  {
    "id": "sample_case_of_goods",
    "name": "Sample Case of Goods",
    "description": "A sturdy case containing a curated selection of exotic goods for showcasing to potential buyers.",
    "item_type": "container",
    "rarity": "common",
    "weight": 3.0,
    "value": 50,
    "custom_properties": {
      "max_item_showcase": 10,
      "security_level": "basic"
    },
    "tags": [
      "container",
      "trade",
      "sample_case"
    ]
  },
  {
    "id": "sealed_letter_of_introduction",
    "name": "Sealed Letter of Introduction",
    "description": "A letter addressed to an influential figure, sealed with an unbroken noble crest.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "letter",
      "quest_item",
      "introduction"
    ]
  },
  {
    "id": "sealed_message",
    "name": "Sealed Message",
    "description": "A message scroll sealed with an unfamiliar sigil. Its contents are unknown.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "message",
      "quest_item",
      "sealed"
    ]
  },
  {
    "id": "sealed_orders",
    "name": "Sealed Orders",
    "description": "Official military orders, sealed with the mark of a high-ranking Harmonic Guard officer.",
    "item_type": "document",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "orders",
      "quest_item",
      "military"
    ]
  },
  {
    "id": "seed_vault",
    "name": "Seed Vault",
    "description": "A specially prepared container holding a diverse collection of rare and adaptable seeds from the Verdant plane.",
    "item_type": "container",
    "rarity": "rare",
    "weight": 1.0,
    "value": 500,
    "custom_properties": {
      "preservation_field_active": true,
      "seed_variety_count": 50
    },
    "tags": [
      "container",
      "seeds",
      "mycora",
      "verdant_plane",
      "preservation"
    ]
  },
  {
    "id": "simple_clothing",
    "name": "Simple Clothing",
    "description": "Basic, practical clothing suitable for everyday wear in Harmonia.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.5,
    "value": 10,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 60,
    "tags": [
      "clothing",
      "armor",
      "commoner"
    ]
  },
  {
    "id": "simple_tool",
    "name": "Simple Tool",
    "description": "A basic tool related to your former trade (e.g., a hammer, a lute, a farming hoe).",
    "item_type": "tool",
    "rarity": "common",
    "weight": 1.0,
    "value": 8,
    "custom_properties": {
      "tool_type": "generic_trade_tool"
    },
    "tags": [
      "tool",
      "commoner",
      "trade_tool"
    ]
  },
  {
    "id": "small_pouch_of_ancestral_ash",
    "name": "Small Pouch of Ancestral Ash",
    "description": "A leather pouch containing a mixture of sacred ashes from revered ancestors of the Ashen Covenant. Used in rituals and for guidance.",
    "item_type": "miscellaneous",
    "rarity": "uncommon",
    "weight": 0.2,
    "value": 50,
    "is_equippable": false,
    "is_consumable": false,
    "is_stackable": false,
    "is_quest_item": true,
    "tags": [
      "ritual_component",
      "ashen_covenant",
      "spiritual",
      "ash"
    ]
  },
  {
    "id": "small_pouch_of_seeds",
    "name": "Small Pouch of Seeds",
    "description": "A collection of various seeds from your homeland, perhaps for trade or study.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.2,
    "value": 20,
    "is_stackable": true,
    "stack_limit": 50,
    "tags": [
      "seeds",
      "nature",
      "trade_good"
    ]
  },
  {
    "id": "small_purse_of_coins",
    "name": "Small Purse of Coins",
    "description": "A leather purse containing a modest amount of mixed currency.",
    "item_type": "treasure",
    "rarity": "common",
    "weight": 0.3,
    "value": 500,
    "is_stackable": false,
    "custom_properties": {
      "contains_copper": 500
    },
    "tags": [
      "currency",
      "container",
      "treasure"
    ]
  },
  {
    "id": "small_tent",
    "name": "Small Tent",
    "description": "A one-person tent, lightweight and easy to set up, providing shelter from the elements.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 2.5,
    "value": 60,
    "custom_properties": {
      "capacity": 1,
      "shelter_rating": 5
    },
    "tags": [
      "tool",
      "shelter",
      "camping",
      "survival"
    ]
  },
  {
    "id": "small_trading_goods",
    "name": "Small Trading Goods",
    "description": "A small bundle of assorted goods suitable for minor trades, like spices, trinkets, or common tools.",
    "item_type": "treasure",
    "rarity": "common",
    "weight": 1.0,
    "value": 100,
    "is_stackable": false,
    "tags": [
      "trade_good",
      "bundle",
      "miscellaneous"
    ]
  },
  {
    "id": "specimen_containers",
    "name": "Specimen Containers",
    "description": "A set of reinforced, sealable containers for collecting and preserving biological or energetic samples.",
    "item_type": "container",
    "rarity": "common",
    "weight": 1.0,
    "value": 30,
    "custom_properties": {
      "capacity_units": 10,
      "preservation_level": "medium"
    },
    "tags": [
      "container",
      "research",
      "sample_collection"
    ]
  },
  {
    "id": "spore_collection_kit",
    "name": "Spore Collection Kit",
    "description": "Tools for safely collecting, identifying, and preserving various types of fungal spores.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.6,
    "value": 90,
    "tags": [
      "tool",
      "mycora",
      "research",
      "spores",
      "collection"
    ]
  },
  {
    "id": "standard_issue_weapon",
    "name": "Standard Issue Guard Sword",
    "description": "A durable, well-maintained sword, the standard armament for Harmonic Guard soldiers.",
    "item_type": "weapon",
    "rarity": "common",
    "weight": 3.0,
    "value": 180,
    "is_equippable": true,
    "equip_slots": [
      "main_hand"
    ],
    "dice_roll_effects": [
      {
        "effect_type": "slashing",
        "dice_notation": "1d6"
      }
    ],
    "durability": 110,
    "tags": [
      "weapon",
      "sword",
      "harmonic_guard",
      "standard_issue"
    ]
  },
  {
    "id": "stolen_supplies",
    "name": "Stolen Supplies",
    "description": "A small sack containing pilfered food, water, and a few useful tools. Clearly not acquired legitimately.",
    "item_type": "container",
    "rarity": "common",
    "weight": 3.0,
    "value": -50,
    "custom_properties": {
      "contents": "food_1day, water_1day, lockpicks_basic"
    },
    "tags": [
      "container",
      "stolen",
      "survival"
    ]
  },
  {
    "id": "storm_compass",
    "name": "Storm Compass",
    "description": "A compass that points towards the strongest nearby atmospheric or planar disturbance, rather than magnetic north.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.4,
    "value": 500,
    "tags": [
      "tool",
      "navigation",
      "tempest_flotilla",
      "planar"
    ]
  },
  {
    "id": "storm_tattoo_kit",
    "name": "Storm Tattoo Kit (Maelstri)",
    "description": "A Maelstri kit containing inks made from condensed storm essence and needles carved from lightning-struck wood. Used to create tattoos that channel tempestuous energies.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.4,
    "value": 600,
    "tags": [
      "tool",
      "maelstri",
      "tattoo",
      "storm_magic",
      "artisan"
    ]
  },
  {
    "id": "strange_contract",
    "name": "Strange Contract",
    "description": "A rolled parchment tied with an ethereal ribbon. The script within is unsettling and shifts when not directly observed. It details a bargain made with an entity from The Between.",
    "item_type": "document",
    "rarity": "rare",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "contract",
      "quest_item",
      "ghost_market",
      "ethereal"
    ]
  },
  {
    "id": "sturdy_work_clothes",
    "name": "Sturdy Work Clothes",
    "description": "Durable and practical clothes, patched in places but clean. Suited for manual labor or travel.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 2.0,
    "value": 15,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      }
    ],
    "durability": 70,
    "tags": [
      "clothing",
      "armor",
      "commoner",
      "workwear"
    ]
  },
  {
    "id": "survival_kit",
    "name": "Survival Kit",
    "description": "A compact kit containing essentials for survival in the wilderness: tinder, fishing line, a small knife, bandages.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 1.5,
    "value": 50,
    "custom_properties": {
      "contents_summary": "tinder, fishing_line, small_knife, bandages"
    },
    "tags": [
      "tool",
      "survival",
      "kit"
    ]
  },
  {
    "id": "symbiotic_communication_pod",
    "name": "Symbiotic Communication Pod",
    "description": "A living fungal pod that allows limited telepathic communication with the Mycora collective consciousness when attuned.",
    "item_type": "tool",
    "rarity": "rare",
    "weight": 0.3,
    "value": 700,
    "custom_properties": {
      "range_km": 10,
      "attunement_required": "Mycora_or_symbiote"
    },
    "tags": [
      "tool",
      "mycora",
      "communication",
      "telepathy",
      "symbiotic"
    ]
  },
  {
    "id": "temporal_compass",
    "name": "Temporal Compass (Maelstri)",
    "description": "A Maelstri compass that doesn't point north, but rather towards areas of significant temporal distortion or probability flux.",
    "item_type": "tool",
    "rarity": "epic",
    "weight": 0.5,
    "value": 1500,
    "tags": [
      "tool",
      "maelstri",
      "navigation",
      "temporal",
      "probability",
      "planar"
    ]
  },
  {
    "id": "test_apple",
    "name": "Test apple",
    "description": "A test apple.",
    "item_type": "miscellaneous",
    "rarity": "common",
    "weight": 0.1,
    "value": 1,
    "is_equippable": false,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 20,
    "tags": [
      "miscellaneous",
      "consumable",
      "food"
    ]
  },
  {
    "id": "trading_ledger",
    "name": "Trading Ledger",
    "description": "A well-used ledger filled with notes on prices, contacts, and trade routes across various planes.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.7,
    "value": 25,
    "tags": [
      "tool",
      "trade",
      "ledger",
      "notes"
    ]
  },
  {
    "id": "translator's_guidebook",
    "name": "Translator's Guidebook (Verdant)",
    "description": "A guidebook containing common phrases, customs, and notes on the plant-based communication of the Verdant Collective.",
    "item_type": "tool",
    "rarity": "common",
    "weight": 0.3,
    "value": 40,
    "stats": [
      {
        "name": "language_comprehension_verdant",
        "value": 1,
        "display_name": "Verdant Language Comprehension"
      }
    ],
    "tags": [
      "book",
      "tool",
      "language",
      "translation",
      "verdant_collective"
    ]
  },
  {
    "id": "treaty_drafts",
    "name": "Treaty Drafts",
    "description": "Drafts of proposed treaties and agreements, with various clauses and options for negotiation.",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.5,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "treaty",
      "diplomacy",
      "negotiation",
      "quest_item"
    ]
  },
  {
    "id": "wanted_poster",
    "name": "Wanted Poster",
    "description": "A weathered wanted poster bearing a crude likeness of someone... perhaps you?",
    "item_type": "document",
    "rarity": "common",
    "weight": 0.1,
    "value": 0,
    "is_quest_item": true,
    "tags": [
      "document",
      "wanted",
      "quest_item"
    ]
  },
  {
    "id": "water_flask",
    "name": "Water Flask",
    "description": "A sturdy flask filled with fresh water.",
    "item_type": "consumable",
    "rarity": "common",
    "weight": 1.0,
    "value": 2,
    "is_consumable": true,
    "is_stackable": true,
    "stack_limit": 3,
    "stats": [
      {
        "name": "thirst_quench",
        "value": 20
      }
    ],
    "custom_properties": {
      "charges": 3,
      "refillable": true
    },
    "tags": [
      "drink",
      "consumable",
      "survival"
    ]
  },
  {
    "id": "weather_prediction_dice",
    "name": "Weather Prediction Dice (Maelstri)",
    "description": "A set of dice that, when thrown by a Maelstri, offer glimpses into short-term weather patterns and probability currents.",
    "item_type": "tool",
    "rarity": "uncommon",
    "weight": 0.1,
    "value": 450,
    "custom_properties": {
      "prediction_accuracy": "moderate",
      "range_hours": 6
    },
    "tags": [
      "tool",
      "maelstri",
      "divination",
      "weather",
      "probability"
    ]
  },
  {
    "id": "weather-resistant_clothing",
    "name": "Weather-Resistant Clothing",
    "description": "Clothing treated to repel water and wind, suitable for unpredictable weather.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 2.2,
    "value": 45,
    "is_equippable": true,
    "equip_slots": [
      "chest"
    ],
    "stats": [
      {
        "name": "defense",
        "value": 1,
        "display_name": "Armor"
      },
      {
        "name": "elemental_resistance_minor",
        "value": 3,
        "display_name": "Minor Elemental Resist",
        "is_percentage": true
      }
    ],
    "durability": 90,
    "tags": [
      "clothing",
      "armor",
      "protection",
      "weather"
    ]
  },
  {
    "id": "worn_disguise",
    "name": "Worn Disguise",
    "description": "A set of commoner's clothes, a hooded cloak, and some makeup, used to alter one's appearance.",
    "item_type": "armor",
    "rarity": "common",
    "weight": 1.5,
    "value": 20,
    "is_equippable": true,
    "equip_slots": [
      "chest",
      "head"
    ],
    "custom_properties": {
      "disguise_effectiveness": "moderate"
    },
    "stats": [
      {
        "name": "stealth_bonus_urban",
        "value": 2,
        "display_name": "Urban Stealth"
      }
    ],
    "durability": 40,
    "tags": [
      "clothing",
      "armor",
      "disguise",
      "stealth"
    ]
  }
]
```

### File: config\items\README.md

```markdown
# Item Configuration

This directory contains JSON configuration files that define the various items available in the game. These files serve as templates from which specific item instances are created.

## Item Configuration Files

The item definitions are categorized into the following files:

### base_weapons.json

Defines weapon templates including:
- Basic weapons (swords, bows, daggers, etc.)
- Weapon properties (damage, range, speed)
- Weapon categories and types
- Required attributes and restrictions (implicitly via stats or tags)
- Equip slots (e.g., main_hand, off_hand, two_hand)

### base_armor.json

Defines armor templates including:
- Armor types (light, medium, heavy - often indicated by tags or stats)
- Armor pieces (helmet, chest, gloves, etc.)
- Protection values and resistance stats
- Weight and mobility effects
- Equip slots

### consumables.json

Defines consumable items including:
- Potions and elixirs
- Food and drinks
- Scrolls and magical consumables
- Temporary effect items (defined via stats/effects)
- Crafting materials (if applicable)

### miscellaneous.json

Defines miscellaneous items including:
- Quest items
- Valuables and currency items (if not handled separately)
- Tools and utilities
- Decorative items
- Container items

## Item Definition Format

Each JSON file contains a list of item objects. Each item object defines a specific item template using the following key-value pairs:

*   `id` (String, Required): A unique identifier for the item template. Used internally to reference the item. Conventionally includes `template_` prefix.
*   `name` (String, Required): The display name of the item shown to the player.
*   `description` (String, Required): A textual description of the item shown to the player.
*   `item_type` (String, Required): The general category of the item (e.g., "weapon", "armor", "consumable", "misc").
*   `rarity` (String, Required): The rarity level of the item (e.g., "common", "uncommon", "rare", "epic", "legendary"). Affects drop rates, value, and potentially stats.
*   `weight` (Float, Required): The weight of the item, affecting inventory capacity.
*   `value` (Integer, Required): The base monetary value of the item in the smallest currency unit (e.g., copper).
*   `is_equippable` (Boolean, Required): Whether the item can be equipped by the player character.
*   `equip_slots` (List of Strings, Required if `is_equippable` is true): A list of equipment slots the item can occupy (e.g., `["main_hand", "off_hand"]`, `["chest"]`, `["two_hand"]`).
*   `stats` (List of Objects, Optional): A list defining the item's effects on character statistics or other properties. Each stat object contains:
    *   `name` (String, Required): The internal name of the stat being modified (e.g., "damage", "defense", "health_regen").
    *   `value` (Number, Required): The magnitude of the stat modification.
    *   `display_name` (String, Required): How the stat is presented to the player (e.g., "Damage", "Armor Class").
    *   `is_percentage` (Boolean, Optional): If true, the `value` is treated as a percentage modifier. Defaults to false if omitted.
*   `is_stackable` (Boolean, Required): Whether multiple instances of this item can occupy a single inventory slot.
*   `durability` (Integer, Optional): The maximum durability of the item. If omitted, the item may be considered indestructible or durability is not applicable.
*   `tags` (List of Strings, Optional): A list of tags used for categorization, filtering, or applying specific game logic (e.g., `["metal", "sword", "quest_item"]`).

### Example (Short Sword from base_weapons.json)

```json
 {
     "id": "template_sword_short",
     "name": "Short Sword",
     "description": "A simple one-handed sword designed for close combat.",
     "item_type": "weapon",
     "rarity": "common",
     "weight": 2.0,
     "value": 1000,
     "is_equippable": true,
     "equip_slots": ["main_hand", "off_hand"],
     "stats": [
         {
             "name": "damage",
             "value": 5,
             "display_name": "Damage"
         },
         {
             "name": "attack_speed",
             "value": 1.2,
             "display_name": "Attack Speed"
         }
     ],
     "is_stackable": false,
     "durability": 100,
     "tags": ["weapon", "sword", "metal", "one-handed"]
 }
```

## Adding or Modifying Items

To add a new item:
1.  Determine the appropriate category (weapon, armor, consumable, misc) and open the corresponding `.json` file (e.g., `base_weapons.json`).
2.  Add a new JSON object to the list, following the format described above.
3.  Ensure the `id` field is unique across all item configuration files.
4.  Fill in all required fields and any relevant optional fields.

To modify an existing item:
1.  Locate the item's definition within the relevant `.json` file using its `id` or `name`.
2.  Modify the desired key-value pairs, ensuring the structure remains valid JSON.

## Usage

These item templates are typically loaded by an `ItemFactory` or similar system at game startup. This factory is then used to create specific instances of items based on their template `id`.

Example (Conceptual Python):
```python
from core.inventory.item_factory import ItemFactory # Assuming this path

# Create an item factory instance
item_factory = ItemFactory()

# Load item templates from the config/items directory
item_factory.load_templates_from_directory("config/items")

# Create an item instance from a template
short_sword_instance = item_factory.create_item("template_sword_short")

print(f"Created item: {short_sword_instance.name}")
```
*(Note: The exact class names and methods might differ in the actual implementation.)*

## Item Generation

The game uses these templates in several ways:

1.  Direct creation of specific items (e.g., quest rewards, shop inventory).
2.  As a base for generating variations with randomized properties (e.g., magical affixes).
3.  As base templates or references for LLM-generated items, ensuring consistency.
4.  Populating loot tables and treasure chests.

## Narrative Item Integration

Templates can serve as references for systems like a `NarrativeItemManager` when creating items based on narrative descriptions or player actions. This helps to:

1.  Match narrative descriptions to existing item types.
2.  Determine appropriate stats and properties based on the template.
3.  Generate variations consistent with the game world and narrative context.
4.  Maintain game balance and item consistency.

```

### File: config\README.md

```markdown
# Configuration Module

The `config` directory contains configuration files for various aspects of the game. This document focuses on the main configuration files located directly within this directory. Configuration for specific modules like items, combat, etc., can be found in their respective subdirectories.

## Main Configuration Files

These files control core aspects of the game and system:

*   **`game_config.json`**: Defines general game settings.
    *   `version`: The current game version.
    *   `title`: The title displayed for the game window.
    *   `default_save_slot`: The save slot used by default (e.g., for auto-saves).
    *   `auto_save_interval`: How often the game auto-saves (in seconds).
    *   `max_save_slots`: The maximum number of manual save slots available.
*   **`gui_config.json`**: Controls settings related to the Graphical User Interface (GUI).
    *   `resolution`: The display resolution (width and height).
    *   `fullscreen`: Whether the game runs in fullscreen mode.
    *   `theme`: The visual theme used for the GUI.
    *   `font_size`: The default font size for UI elements.
    *   `show_fps`: Whether to display the current frames per second.
*   **`llm_config.json`**: Manages settings for Large Language Model (LLM) integration.
    *   `enabled`: A simple flag to enable or disable all LLM features globally. More detailed LLM configurations are likely found in the `llm/` subdirectory.
*   **`system_config.json`**: Contains system-level configurations.
    *   `log_level`: The minimum severity level for log messages (e.g., INFO, DEBUG).
    *   `log_to_file`: Whether logs should be written to a file.
    *   `log_to_console`: Whether logs should be output to the console.
    *   `debug_mode`: Enables or disables general debug features.
    *   `save_dir`: The directory where save game files are stored (relative to the project root).
    *   `log_dir`: The directory where log files are stored (relative to the project root).

## Configuration Format

All configuration files use JSON format for easy editing and parsing. Most configuration files follow a similar structure:

```json
{
  "version": "1.0",
  "name": "Configuration Name",
  "description": "Description of the configuration",
  "settings": {
    "setting1": "value1",
    "setting2": "value2",
    "nested_setting": {
      "subsetting1": "value3"
    }
  }
}
```

## Usage

Configuration files are typically loaded by their respective modules at startup. For example:

*   Game configuration might be loaded by a central game manager.
*   GUI settings are likely loaded by the GUI initialization module.
*   System settings are used by logging and file management components.

## Editing Configuration

Configuration files can be edited manually with a text editor. Ensure the JSON format remains valid after editing. Some settings might also be adjustable through in-game menus.

```

### File: config\skills.json

```json
{
  "skills": {
    "acrobatics": {
      "name": "Acrobatics",
      "primary_stat": "DEXTERITY",
      "category": "PHYSICAL",
      "description": "Performing agile maneuvers, balancing, tumbling, and reducing fall damage."
    },
    "appraisal": {
      "name": "Appraisal",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Determining the value, authenticity, and properties of items, artifacts, or goods."
    },
    "arcana": {
      "name": "Arcana",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge about magic, magical traditions, spells, arcane symbols, and supernatural effects."
    },
    "athletics": {
      "name": "Athletics",
      "primary_stat": "STRENGTH",
      "category": "PHYSICAL",
      "description": "Performing physical activities like running, jumping, swimming, climbing, and feats of raw power."
    },
    "crafting_basic": {
      "name": "Crafting (Basic)",
      "primary_stat": "INTELLIGENCE",
      "category": "UTILITY",
      "description": "Basic ability to create, repair, or modify simple items and equipment."
    },
    "crafting_metallurgy": {
      "name": "Crafting (Metallurgy)",
      "primary_stat": "INTELLIGENCE",
      "category": "UTILITY",
      "description": "Specialized skill in working with metals, including forging, smithing, and understanding alloys."
    },
    "deception": {
      "name": "Deception",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Misleading others through lies, trickery, disguises, and manipulation of truth."
    },
    "diplomacy": {
      "name": "Diplomacy",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Influencing others through negotiation, tact, and understanding of social etiquette."
    },
    "dodge": {
      "name": "Dodge",
      "primary_stat": "DEXTERITY",
      "category": "COMBAT",
      "description": "Avoiding attacks and obstacles through quick movements."
    },
    "endurance": {
      "name": "Endurance",
      "primary_stat": "CONSTITUTION",
      "category": "PHYSICAL",
      "description": "Withstanding prolonged physical exertion, fatigue, hardship, and resisting exhaustion."
    },
    "history": {
      "name": "History",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge of past events, civilizations, historical figures, and the study of recorded history."
    },
    "history_oral": {
      "name": "History (Oral)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge of past events, legends, and traditions passed down verbally, common in cultures without extensive written records."
    },
    "insight": {
      "name": "Insight",
      "primary_stat": "INSIGHT",
      "category": "MENTAL",
      "description": "Discerning true intentions, detecting lies, sensing emotions, and understanding underlying truths or motives."
    },
    "insight_probability": {
      "name": "Insight (Probability)",
      "primary_stat": "INSIGHT",
      "category": "MENTAL",
      "description": "Intuitive understanding of chance, luck, predicting random outcomes, and sensing probability currents."
    },
    "insight_risk_assessment": {
      "name": "Insight (Risk Assessment)",
      "primary_stat": "INSIGHT",
      "category": "MENTAL",
      "description": "Specifically assessing potential dangers, evaluating probabilities of failure/success, and calculating risks in various situations."
    },
    "intimidation": {
      "name": "Intimidation",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Influencing others through threats, fear, force of presence, or hostile actions."
    },
    "investigation": {
      "name": "Investigation",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Finding clues, deducing information, examining details, and solving mysteries or puzzles."
    },
    "mathematics_basic": {
      "name": "Mathematics (Basic)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Basic understanding and application of mathematical principles, logic, and calculations."
    },
    "medicine": {
      "name": "Medicine",
      "primary_stat": "WISDOM",
      "category": "UTILITY",
      "description": "Diagnosing illnesses, treating wounds, administering first aid, and knowledge of remedies."
    },
    "melee_attack": {
      "name": "Melee Attack",
      "primary_stat": "STRENGTH",
      "category": "COMBAT",
      "description": "Physical close-range combat attacks."
    },
    "nature": {
      "name": "Nature",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Knowledge about flora, fauna, weather, natural terrain, and survival in natural environments."
    },
    "navigation": {
      "name": "Navigation",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Finding one's way through various terrains, using maps, stars, or natural signs."
    },
    "perception": {
      "name": "Perception",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Noticing details in your surroundings, detecting hidden objects, and general awareness of your environment."
    },
    "persuasion": {
      "name": "Persuasion",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Convincing others through reasoning, charm, debate, or emotional appeals."
    },
    "planar_lore": {
      "name": "Planar Lore",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "General knowledge about the different planes of existence, their properties, inhabitants, and planar travel."
    },
    "planar_lore_basic": {
      "name": "Planar Lore (Basic)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Basic understanding of the different planes of existence, their interactions, and common phenomena."
    },
    "planar_lore_rumors": {
      "name": "Planar Lore (Rumors)",
      "primary_stat": "INTELLIGENCE",
      "category": "KNOWLEDGE",
      "description": "Knowledge of hearsay, gossip, unverified information, and local legends about the planes."
    },
    "ranged_attack": {
      "name": "Ranged Attack",
      "primary_stat": "DEXTERITY",
      "category": "COMBAT",
      "description": "Physical ranged combat attacks."
    },
    "religion": {
      "name": "Religion",
      "primary_stat": "WILLPOWER",
      "category": "KNOWLEDGE",
      "description": "Knowledge about deities, religious rites, holy symbols, mythology, and theological matters. Also represents strength of faith."
    },
    "spell_attack": {
      "name": "Spell Attack",
      "primary_stat": "INTELLIGENCE",
      "category": "COMBAT",
      "description": "Magical attacks using spells or arcane abilities."
    },
    "stealth": {
      "name": "Stealth",
      "primary_stat": "DEXTERITY",
      "category": "COVERT",
      "description": "Moving silently, avoiding detection, and hiding effectively."
    },
    "streetwise_harmonia": {
      "name": "Streetwise (Harmonia)",
      "primary_stat": "CHARISMA",
      "category": "SOCIAL",
      "description": "Knowledge of the streets, local customs, influential figures, and underworld of Harmonia."
    },
    "survival": {
      "name": "Survival",
      "primary_stat": "WISDOM",
      "category": "EXPLORATION",
      "description": "Thriving in the wild by tracking, foraging, finding shelter, and navigating harsh environments."
    },
    "unarmed_attack": {
      "name": "Unarmed Attack",
      "primary_stat": "STRENGTH",
      "category": "COMBAT",
      "description": "Combat attacks without weapons, such as punches and kicks."
    }
  }
}
```

### File: core\README.md

```markdown
# Core Module

The `core` module serves as the heart of the game engine, containing the primary logic, data structures, and systems that drive the gameplay experience. It is designed with a modular approach, organizing distinct functionalities into specific sub-modules.

## Overview

This module encapsulates the fundamental mechanics of the game, including state management, character representation, combat resolution, inventory handling, interaction with Large Language Models (LLMs), and various utility functions. The sub-modules are designed to interact with each other to create a cohesive game world.

## Architecture

The core module emphasizes modularity and separation of concerns. Key architectural patterns include:
*   **State Management:** Centralized handling of game, world, and player states within the `base/state` submodule.
*   **Command Pattern:** Processing player and system actions via a command system in `base/commands.py`.
*   **Agent-Based Systems:** Utilizing LLM-powered agents (`agents/`) for dynamic content generation and rule enforcement.
*   **Component-Based Structure:** Various managers (Inventory, Stats, Character, Combat, LLM) handle specific domains.

## Sub-Modules

Below is a breakdown of the primary sub-modules within `core`:

### `agents/`

Contains LLM-powered game agents responsible for:
*   Generating narrative content and descriptions (`narrator.py`).
*   Enforcing game rules and validating actions (`rule_checker.py`).
*   Evaluating game context (`context_evaluator.py`).
*   Coordinating agent interactions (`agent_manager.py`).

### `base/`

Provides the foundational engine components:
*   Main game engine logic (`engine.py`).
*   Game loop and time management (`game_loop.py`).
*   Command processing infrastructure (`commands.py`).
*   Configuration loading (`config.py`).
*   **`base/state/`**: Manages the different states of the game, including `game_state.py`, `player_state.py`, and `world_state.py`, coordinated by `state_manager.py`.

### `character/`

Manages all aspects of characters, both player and non-player characters (NPCs):
*   NPC creation, logic, memory, and persistence (`npc_*.py` files).
*   Character background generation (`background_generator.py`).
*   Overall coordination of character-related systems (`npc_system.py`, `npc_manager.py`).

### `combat/`

Handles the systems and logic required for combat encounters:
*   Defining combat actions (`combat_action.py`).
*   Representing entities involved in combat (`combat_entity.py`).
*   Managing the flow and rules of combat (`combat_manager.py`).

### `inventory/`

Manages all item-related functionality:
*   Core inventory and equipment management (`inventory_manager.py`, `equipment_manager.py`).
*   Item representation and creation (`item.py`, `item_factory.py`).
*   Currency management (`currency_manager.py`).
*   Dynamic item creation based on narrative context (`narrative_item_manager.py`).

### `llm/`

Integrates with Large Language Models (LLMs):
*   Manages interactions with different LLM providers (`llm_manager.py`, `provider_manager.py`).
*   Handles LLM settings and configuration (`settings_manager*.py`).

### `stats/`

Defines and manages statistics for characters and potentially items:
*   Base stat definitions and management (`stats_base.py`, `stats_manager.py`).
*   Handling of temporary or permanent modifiers (`modifier.py`, `modifier_manager.py`).
*   Calculation of derived statistics (`derived_stats.py`).
*   Skill check resolution (`skill_check.py`).
*   Combat-related effects tied to stats (`combat_effects.py`).

### `utils/`

Contains common utility functions and classes used across the core module:
*   Dice rolling (`dice.py`).
*   Data structures (`dotdict.py`).
*   Serialization/JSON handling (`json_utils.py`).
*   Logging setup (`logging_config.py`).
*   Saving and loading game state (`save_manager.py`).
*   Time-related functions (`time_utils.py`).

```

### File: core\inventory\README.md

```markdown
# Inventory Module

The `inventory` module manages all item-related functionality in the game, including items, equipment, and currency.

## Key Components

### Item System

- `item.py` - Defines the `Item` class and related data structures
- `item_enums.py` - Enumerations for item types, rarities, equipment slots, etc.
- `item_stat.py` - Item statistics and properties
- `item_modifier.py` - Modifiers that can be applied to items
- `item_factory.py` - Creates items from templates or specifications
- `item_template_loader.py` - Loads item templates from configuration files
- `item_variation_generator.py` - Generates variations of items with different properties
- `item_serialization.py` - Handles serialization/deserialization of items for saving/loading

### Inventory Management

- `inventory_manager.py` - Main inventory management class
- `inventory_base.py` - Base inventory functionality
- `inventory_item_operations.py` - Item operations like adding, removing, etc.
- `inventory_limits.py` - Weight and slot limits for inventory
- `equipment_manager.py` - Manages equipment slots and equipped items
- `currency_manager.py` - Manages in-game currency (copper, silver, gold)

### Narrative Item System

- `narrative_item_manager.py` - Main class for narrative-based item creation
- `narrative_item_creation.py` - Creates items from narrative descriptions
- `narrative_item_discovery.py` - Manages item discovery and property revelation
- `narrative_item_mappings.py` - Maps narrative descriptions to item properties

### Command Handlers

- `inventory_commands.py` - Command handlers for inventory-related commands
- `inventory_commands_2.py` - Additional command handlers
- `inventory_commands_3.py` - Additional command handlers

## Current Functionality

1. Item creation from templates and specifications
2. Item management (add, remove, equip, unequip)
3. Currency management
4. Equipment slot management with proper handling of two-handed weapons
5. Item damage and destruction
6. Item discovery (revealing item properties over time)
7. Narrative-driven item creation through LLM integration
8. Combat loot generation
9. Item parsing from narrative text

## Planned Features

1. Advanced item crafting
2. Item decay and maintenance
3. Magic item effects
4. More sophisticated item generation algorithms
5. Enhanced item UI representation

## Usage Example

```python
from core.inventory.inventory_manager import InventoryManager
from core.inventory.item_factory import ItemFactory

# Create an inventory manager
inventory = InventoryManager()

# Create an item factory
item_factory = ItemFactory()
item_factory.load_templates()

# Create an item
sword = item_factory.create_item_from_spec("iron_sword")

# Add to inventory
inventory.add_item(sword)

# Equip the item
inventory.equip_item(sword.id, "main_hand")
```

```

### File: core\llm\README.md

```markdown
# LLM Module

The `llm` module manages the integration with large language models (LLMs) for narrative generation and game content creation.

## Key Components

### llm_manager.py

The `LLMManager` class is the main interface for LLM interactions:

- Sends prompts to LLM providers
- Receives and processes LLM responses
- Manages context window size and token usage
- Handles rate limiting and retries
- Provides diagnostic functions

### provider_manager.py

The `ProviderManager` class manages different LLM providers:

- Initializes provider clients with appropriate API keys
- Selects the appropriate provider based on configuration
- Handles provider-specific parameters and features
- Manages fallback between providers
- Validates provider availability

### settings_manager.py

The `SettingsManager` class manages LLM settings:

- Loads settings from configuration files
- Provides access to LLM parameters (temperature, top_p, etc.)
- Validates and sanitizes settings
- Manages provider-specific settings

### settings_cli.py

Provides a command-line interface for managing LLM settings:

- Viewing current settings
- Modifying provider settings
- Testing provider connections
- Running diagnostics

## Current Functionality

1. Support for multiple LLM providers (OpenAI, Anthropic, Google)
2. Configuration management for LLM parameters
3. Fallback mechanisms when providers are unavailable
4. Diagnostic tools for testing and troubleshooting
5. Token usage tracking and optimization
6. Command-line utility for settings management

## Planned Features

1. More sophisticated context management
2. Dynamic prompt generation based on game state
3. Enhanced error handling and recovery
4. Support for additional LLM providers
5. Better token usage optimization

## Usage Example

```python
from core.llm.llm_manager import LLMManager
from core.llm.settings_manager import SettingsManager

# Create a settings manager
settings_manager = SettingsManager()
settings_manager.load_settings()

# Create an LLM manager
llm_manager = LLMManager(settings_manager)

# Get a completion
prompt = "Describe a dark forest at night."
response = llm_manager.get_completion(prompt)

# Display the response
print(response)
```

## LLM Toggle Command

The game includes a special command `/llm` that can be used to:

- Check the current LLM status
- Toggle LLM on/off during gameplay
- Switch between different LLM providers

This allows for fallback to a non-LLM gameplay mode when needed.

```

### File: web\layout_edit_instr.md

```markdown
# Layout Editing Tools — How to Use

This document explains every feature of the in‑browser layout editor available in developer mode, including how to move/resize elements, save/restore snapshots, reset to defaults, and use Undo/Redo.

Where to find the tools
- Open Settings → Style Tools.
- Use the toggles to enable the inspector, grid, and the Element Resize Mode. Optional: Enable Move Mode to allow dragging the selection.

Main concepts
- Selection: Click any element on the page to select it. Ctrl+Click adds/removes items to a multi‑selection. When selected, a blue frame with round handles appears.
- Overlay toolbar: Appears above the selection with controls: Unlock, Reset WH, Reset Pos, Clear Sel, Undo, Redo, Save Layout, Restore, Reset All.
- Persistence: Edits are saved live into localStorage (per browser). The Save Layout button stores an additional snapshot that can be restored later.

Controls in Settings → Style Tools
- Enable Layout Inspector: Shows a hover tooltip that displays element info and layout variables. You can edit layout variables there or in the form fields.
- Show Grid Overlay: Draws a grid over the UI; grid size is configurable.
- Enable Element Resize Mode: Shows selection overlay and handles.
- Enable Move Mode: Allows dragging the selection via the overlay’s center area.
- Grid Size / Left Menu Width / Right Panel Width / Content Gap / Right Panel Pane Max Height: Live‑edit these CSS variables. Values are persisted.
- Reset Layout to Defaults: Full reset to CSS defaults and clears all local overrides.
- Restore Layout From Saved Snapshot: Applies the last snapshot created with Save Layout.

Overlay toolbar buttons (developer mode)
- Unlock: Hides the overlay and exits the current selection.
- Reset WH: Clears inline width/height for selected element(s).
- Reset Pos: Clears inline position/left/top/zIndex of selected element(s).
- Clear Sel: Reduces multi‑selection to only the anchor element.
- Undo / Redo: Steps backward/forward through your last editor actions (resize/move/reset/inspector edits). Shortcuts: Ctrl+Z and Ctrl+Shift+Z (or Ctrl+Y).
- Save Layout: Stores a snapshot (layout variables + element inline styles) under localStorage key rpg_layout_saved. This does not change the UI.
- Restore: Restores from the saved snapshot. Useful as a safety net during editing.
- Reset All: Same as the Settings reset — clears all overrides, turns off editor/move, and returns the layout to defaults.

Moving elements
- Enable Element Resize Mode and Move Mode.
- Select an element (or multi‑select with Ctrl+Click).
- Drag inside the blue frame (not the handles) to move.
- Snap‑to‑grid: Hold Shift while dragging to snap movement to the grid size set in Style Tools.

Resizing elements
- Enable Element Resize Mode.
- Drag any of the round handles (sides/corners) to resize.
- Inspector numeric inputs: With a selection, the inspector panel shows Width, Height, Max Height, and OverflowY — edits here also record Undo/Redo actions.

Multi‑selection
- Ctrl+Click multiple elements to select several items. Dragging will move them as a group. Reset WH/Pos applies to all selected.

Saving and restoring
- Save Layout (toolbar): Saves a snapshot with current CSS variables and the inline styles of edited elements. The app keeps using your live edits.
- Restore (toolbar) or Restore Layout From Saved Snapshot (Settings): Applies the saved snapshot and updates inputs/overlays accordingly.

Resetting to defaults
- Use Reset All (toolbar) or Reset Layout to Defaults (Settings). This clears all local overrides and resets CSS variables to defaults. Editor/move modes are disabled.

Troubleshooting
- Can’t move elements? Ensure:
  - Element Resize Mode is ON, Move Mode is ON, and the element is selected (blue frame visible).
  - If toggling Move Mode didn’t change the cursor, toggle it off/on once — the overlay now refreshes pointer state automatically.
- UI looks broken? Use Reset Layout to Defaults. If that fails, reload the page and try again.
- Nothing happens on Restore? Make sure you previously clicked Save Layout to create a snapshot.

Storage keys (for reference)
- rpg_element_styles: live per‑selector style overrides
- rpg_layout_saved: snapshot payload (vars + element_styles)
- rpg_layout_left, rpg_layout_right, rpg_layout_gap, rpg_rp_max, rpg_grid_size: variable overrides
- rpg_grid_enabled, rpg_dev_inspector_enabled, rpg_dev_editor_enabled, rpg_dev_move_enabled: feature toggles

Notes
- All data is stored in your browser’s localStorage for this origin. Snapshots and edits are per‑browser and per‑machine. If you need cross‑machine persistence, consider exporting these keys and committing them to version control or wiring a server API.


```

### File: web\README.md

```markdown
# Web Module

The `web` module provides a web-based interface for interacting with the RPG game. It allows users to play the game through a standard web browser, offering an alternative to the desktop GUI.

## Architecture

The web interface follows a client-server architecture:

*   **Server (`server/`)**: A Python backend built with the **FastAPI** framework and served using **Uvicorn**. It handles game logic by interacting with the `core` module, manages game sessions, processes player commands, handles saving/loading, manages LLM settings, and provides real-time updates via **WebSockets**.
*   **Client (`client/`)**: A standard frontend built with **HTML**, **CSS**, and **JavaScript**. It communicates with the server via REST API calls for actions and WebSockets for receiving real-time game state updates.

## Key Features & Functionality

*   **Game Interaction**: Start new games, process player commands, and receive game world updates.
*   **Real-time Updates**: Uses WebSockets to push game state changes (player stats, location, game time, messages) to the client in real-time.
*   **Session Management**: Creates and manages unique game sessions for each connected client.
*   **Save/Load**: API endpoints to save the current game state and load previous saves.
*   **LLM Integration**: API endpoints to view and manage LLM provider and agent settings, and toggle LLM functionality per session (interacts with `core.llm.settings_manager`).
*   **Character Creation**: Basic character details (name, race, path, etc.) can be provided when starting a new game. Includes support for selecting character icons.
*   **Static File Serving**: Serves the client-side HTML, CSS, JS files, and images (including character icons from `images/character_icons`).

## Technologies Used

*   **Backend**:
    *   Python 3
    *   FastAPI (Web framework)
    *   Uvicorn (ASGI server)
    *   WebSockets (Real-time communication)
    *   Pydantic (Data validation)
*   **Frontend**:
    *   HTML5
    *   CSS3
    *   JavaScript (Vanilla)

## Setup and Running

1.  **Install Dependencies**: Navigate to the `web/server/` directory and install the required Python packages:
    ```bash
    cd web/server
    pip install -r requirements.txt
    cd ../.. 
    ```
    *(Ensure you are in the project root or have the `core` module accessible in your Python path, as the server imports from it).*

2.  **Run the Server**: From the project root directory (`new project/`), run the server using Uvicorn:
    ```bash
    python web/server/server.py 
    ```
    Alternatively, run Uvicorn directly (also from the project root):
    ```bash
    uvicorn web.server.server:app --reload --host 0.0.0.0 --port 8000
    ```

3.  **Access the Interface**: Open your web browser and navigate to `http://localhost:8000`.

## Interaction with Other Modules

*   **`core/`**: The server heavily relies on the `core` module. It imports and uses:
    *   `core.base.engine.GameEngine`: To manage the main game loop and state.
    *   `core.base.state`: For game state representation.
    *   `core.base.commands`: To process commands.
    *   `core.utils.logging_config`: For logging.
    *   `core.llm.settings_manager`: To manage LLM configurations.
    *   `core.utils.save_manager`: To handle game saving and loading metadata.
*   **`images/`**: The server mounts the `images/` directory (specifically `images/character_icons/`) to serve character portraits to the client.
*   **`config/`**: Indirectly uses configuration files loaded by the `core` module.

## Dependencies

Key Python dependencies (see `web/server/requirements.txt` for full list):
*   `fastapi`
*   `uvicorn`
*   `websockets`
*   `pydantic`
*   `python-dotenv`

```

### File: world_configurator\main.py

```python
#!/usr/bin/env python
"""
World Configurator Tool for the RPG Project.

This tool allows creating and editing world configuration for the RPG game.
"""

import os
import sys
import logging

# Add the project root to the Python path so we can use absolute imports
project_root = os.path.dirname(os.path.abspath(__file__))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from PySide6.QtWidgets import QApplication

from ui.main_window import MainWindow
from utils.logging_setup import setup_logging

def main():
    """
    Main entry point for the World Configurator Tool.
    """
    # Setup logging
    setup_logging()
    logger = logging.getLogger("world_configurator")
    logger.info("Starting World Configurator Tool")
    
    # Create application
    app = QApplication(sys.argv)
    app.setApplicationName("World Configurator")
    app.setApplicationVersion("1.0.0")
    
    # Create main window
    window = MainWindow()
    window.show()
    
    # Run application
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

```

### File: world_configurator\README.md

```markdown
# World Configurator Tool

## Overview

The World Configurator Tool is a desktop application built with **PySide6** designed for game designers and content creators to define, edit, and manage the world configuration data for the RPG project. It provides a user-friendly graphical interface for creating and modifying various aspects of the game world, ensuring data consistency and facilitating the content creation pipeline.

The tool works primarily with **JSON** data files, loading from and exporting to the main game's configuration directory (`config/`), making the generated data directly usable by the core game engine.

## Key Features

*   **Comprehensive World Editing:** Tabbed editors for managing:
    *   **Cultures:** Define cultural groups, values, traditions, and naming conventions.
    *   **Races:** Create and edit playable or NPC races with their attributes.
    *   **Classes:** Define character classes, abilities, and progression.
    *   **Locations:** Design game areas, points of interest, connections, and associated cultures.
    *   **World History:** Create historical eras and significant events.
    *   **Origins:** Define starting scenarios, locations, and conditions for new characters.
    *   **Quests:** Design quests, objectives, and storylines.
    *   **Magic Systems:** Define the rules and elements of magic within the world.
*   **Project Management:**
    *   Create new world configuration projects.
    *   Open, save, and manage project files (`.wcproj` structure, containing JSON data).
*   **Direct Game Integration:**
    *   **Load from Game:** Import existing configuration data directly from the game's `config/` directory (e.g., `config/cultures.json`, `config/locations.json`) into the tool for editing.
    *   **Export to Game:** Export the edited configuration data back to the appropriate JSON files within the game's `config/` directory. Automatic backups of existing files are created during export.
*   **Data Viewing:** View the raw JSON data for different configuration types within the tool.
*   **Settings:** Configure tool-specific settings (future implementation).

## Installation and Dependencies

1.  **Prerequisites:** Ensure you have Python 3.9+ installed.
2.  **Main Project Dependencies:** Install all dependencies for the main RPG project first by running `pip install -r requirements.txt` in the project root directory (`new project/`). The World Configurator relies on packages installed there.
3.  **PySide6:** The primary dependency for the GUI is PySide6, which should be included in the main `requirements.txt`. If not, install it via `pip install PySide6`.
4.  **Editable Install (Optional but Recommended):** For development, you can install the tool in editable mode from the `new project/` directory:
    ```bash
    pip install -e ./world_configurator
    ```
    Alternatively, use the provided batch script:
    ```bash
    install_world_configurator.bat
    ```

## Running the Tool

Launch the tool from the project root directory (`new project/`) using:

```bash
python world_configurator/main.py
```

Or, if installed via `pip install -e`:

```bash
python -m world_configurator.main
```

## Project Structure (`world_configurator/`)

*   `main.py`: Main application entry point.
*   `README.md`: This file.
*   `models/`: Pydantic data models defining the structure for world elements (cultures, locations, origins, etc.).
    *   `base_models.py`: Base Pydantic models and shared structures.
    *   `world_config.py`: Manages the overall world configuration state and managers.
    *   `*_data.py`: Specific data models (e.g., `location_data.py`, `origin_data.py`).
*   `ui/`: PySide6 user interface components.
    *   `main_window.py`: The main application window containing tabs and menus.
    *   `editors/`: Widgets for editing specific data types (e.g., `CultureEditor`, `LocationEditor`).
    *   `dialogs/`: Dialog windows for actions like New Project, Export, Settings.
*   `utils/`: Utility functions.
    *   `file_manager.py`: Handles loading/saving project files and interacting with game config files.
    *   `logging_setup.py`: Configures application logging.
    *   `data_validator.py`: (If present) Utilities for validating data consistency.
*   `data/`: (If used) Default or example data for the tool.
*   `logs/`: Contains log files generated by the tool.

## Usage Workflow

1.  **Launch** the World Configurator.
2.  **Load Data:**
    *   Use **File > Load from Game** to import the current configuration directly from the game's `config/` directory. This is useful for editing existing game data.
    *   Or, use **File > Open Project** to load a previously saved World Configurator project (`.wcproj`).
    *   Or, use **File > New Project** to start a fresh configuration.
3.  **Edit Data:** Navigate through the tabs (Cultures, Locations, Quests, etc.) to add, remove, or modify entries using the specific editors.
4.  **Save Progress:**
    *   Use **File > Save** or **File > Save As...** to save your work as a World Configurator project. This saves the current state within the tool but does *not* update the main game files yet.
5.  **Export to Game:**
    *   When ready to apply changes to the main game, use **File > Export to Game**.
    *   Select the specific components (e.g., Cultures, Locations) you wish to export.
    *   Confirm the export. The tool will write the updated data to the relevant JSON files in the `config/` directory, creating timestamped backups of the original files first.

## Data Integration with the Main Game (`core`)

The World Configurator acts as a dedicated editor for the configuration files located in the main project's `config/` directory (e.g., `config/cultures.json`, `config/locations.json`, `config/quests.json`, etc.).

*   **Loading:** The "Load from Game" feature reads these JSON files directly.
*   **Exporting:** The "Export to Game" feature writes the edited data back into these same JSON files.
*   **Core Engine:** The main game engine (`core/`) is designed to load its world definition, character options, quest data, etc., by reading these JSON files from the `config/` directory at startup or as needed.

Therefore, any data created or modified using the World Configurator and then exported will directly affect the game world experienced by the player when the main game is run.

## Developer Notes

*   **GUI Framework:** PySide6
*   **Data Models:** Pydantic
*   **Data Format:** JSON
*   **Game Config Path:** Interacts with files in the main project's `config/` directory (and its subdirectories like `config/items/`, `config/world/` if they exist and are targeted by specific managers). Backups are created in corresponding `backup/` subfolders within `config/`.
*   **Logging:** Configured via `utils/logging_setup.py`, outputting to `world_configurator/logs/`.

```

### File: web\client\css\style.css

```css
/* 
 * RPG Adventure - Main Stylesheet
 * A fantasy-themed game interface with responsive design
 */

/* ===== Base Styles ===== */
:root {
    /* Main color palette */
    --color-primary: #503a65;
    --color-primary-dark: #3a2a4a;
    --color-secondary: #7b5c9e;
    --color-accent: #c79f27;
    --color-text: #333;
    --color-text-light: #f0f0f0;
    --color-bg: #f9f7f2;
    --color-bg-dark: #e1d9cc;
    --color-border: #d0c2a5;
    
    /* UI specific colors */
    --color-success: #4caf50;
    --color-info: #2196f3;
    --color-warning: #ff9800;
    --color-error: #f44336;
    
    /* Font settings */
    --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    --font-game: 'Palatino Linotype', 'Book Antiqua', Palatino, serif;
    
    /* Spacing and sizing */
    --header-height: 100px;
    --footer-height: 40px;
    --border-radius: 5px;
    --transition-speed: 0.3s;

    /* Layout variables (editable in Style Tools) */
    --left-menu-width: 180px;
    --right-panel-width: 420px;
    --content-gap: 10px;
    --rp-pane-max: none; /* e.g., 520px or none */

    /* Grid overlay */
    --grid-size: 16px;
    --grid-color: rgba(255,255,255,0.08);
    --grid-color-2: rgba(255,255,255,0.04);
}

/* Dark theme variables - will be applied with .dark-theme class */
.dark-theme {
    --color-primary: #3a2a4a;
    --color-primary-dark: #221b2d;
    --color-secondary: #5a4378;
    --color-accent: #ffcc33;
    --color-text: #e0e0e0;
    --color-text-light: #f8f8f8;
    --color-bg: #282633;
    --color-bg-dark: #1e1c28;
    --color-border: #444;
}

/* Fantasy theme variables - will be applied with .fantasy-theme class */
.fantasy-theme {
    --color-primary: #654321;
    --color-primary-dark: #3e2912;
    --color-secondary: #886644;
    --color-accent: #ffd700;
    --color-text: #4a2d0d;
    --color-text-light: #fff8e8;
    --color-bg: #fff3db;
    --color-bg-dark: #f0e0c0;
    --color-border: #d2b48c;
}

/* Custom scrollbar styling */
.game-output::-webkit-scrollbar,
.right-panel::-webkit-scrollbar,
.rp-tab-pane::-webkit-scrollbar {
    width: 8px;
}

.game-output::-webkit-scrollbar-track,
.right-panel::-webkit-scrollbar-track,
.rp-tab-pane::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}

.game-output::-webkit-scrollbar-thumb,
.right-panel::-webkit-scrollbar-thumb,
.rp-tab-pane::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    transition: background 0.2s ease;
}

.game-output::-webkit-scrollbar-thumb:hover,
.right-panel::-webkit-scrollbar-thumb:hover,
.rp-tab-pane::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.5);
}

/* Firefox scrollbar styling */
.game-output,
.right-panel,
.rp-tab-pane {
    scrollbar-width: thin;
    scrollbar-color: rgba(0, 0, 0, 0.3) rgba(0, 0, 0, 0.1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-main);
    background-color: var(--color-bg);
    color: var(--color-text);
    line-height: 1.6;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* ===== Layout Containers ===== */
.app-container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    width: 100%;
    max-width: none; /* allow full-width on desktop */
    margin: 0 auto;
    padding: 0 10px;
}

/* ===== Header ===== */
.game-header {
    background-color: var(--color-primary);
    color: var(--color-text-light);
    padding: 1rem;
    border-radius: 0 0 var(--border-radius) var(--border-radius);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.game-title {
    font-family: var(--font-game);
    font-size: 1.8rem;
    font-weight: bold;
    text-align: center;
}

.game-info {
    display: flex;
    justify-content: space-around;
    flex-wrap: wrap;
    font-size: 0.9rem;
    padding: 0.5rem 0;
}

.menu-buttons {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.menu-btn {
    background-color: var(--color-secondary);
    color: var(--color-text-light);
    border: none;
    border-radius: var(--border-radius);
    padding: 0.5rem 1rem;
    cursor: pointer;
    transition: all var(--transition-speed);
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 0.3rem;
}

.menu-btn:hover {
    background-color: var(--color-primary-dark);
}

.menu-btn i {
    font-size: 0.85em;
}

/* ===== Main Content ===== */
.game-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    margin-top: 1rem;
    background-color: var(--color-bg-dark);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

/* Game Output Area */
.game-output {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    background-color: var(--color-bg);
    font-family: var(--font-game);
    min-height: 300px;
    max-height: calc(100vh - var(--header-height) - 80px);
    border-bottom: 1px solid var(--color-border);
}

.welcome-message {
    text-align: center;
    padding: 2rem;
}

.welcome-message h2 {
    font-family: var(--font-game);
    font-size: 1.6rem;
    color: var(--color-primary);
    margin-bottom: 1rem;
}

.message {
    margin-bottom: 1rem;
    padding: 0.5rem;
    border-radius: var(--border-radius);
    border-left: 3px solid transparent;
}

.message.system {
    background-color: rgba(0, 0, 0, 0.03);
    border-left-color: var(--color-info);
    font-style: italic;
    color: #666;
}

.message.player {
    border-left-color: var(--color-primary);
    background-color: rgba(80, 58, 101, 0.05);
}

.message.game {
    border-left-color: var(--color-accent);
    background-color: rgba(199, 159, 39, 0.05);
}

/* Command Input */
.command-input-container {
    display: flex;
    padding: 0.5rem;
    background-color: var(--color-bg-dark);
}

.command-input {
    flex: 1;
    padding: 0.5rem 1rem;
    font-family: var(--font-main);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius) 0 0 var(--border-radius);
    outline: none;
}

.command-input:focus {
    border-color: var(--color-secondary);
}

.command-input:disabled {
    background-color: #f0f0f0;
    cursor: not-allowed;
}

.send-command-btn {
    background-color: var(--color-primary);
    color: var(--color-text-light);
    border: none;
    border-radius: 0 var(--border-radius) var(--border-radius) 0;
    padding: 0.5rem 1rem;
    cursor: pointer;
    transition: background-color var(--transition-speed);
}

.send-command-btn:hover:not(:disabled) {
    background-color: var(--color-secondary);
}

.send-command-btn:disabled {
    background-color: #aaa;
    cursor: not-allowed;
}

/* ===== Modals ===== */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.modal.active {
    display: flex;
}

.modal-content {
    background-color: var(--bg-modal);
    border-radius: 10px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
    width: 100%;
    max-width: 600px;
    animation: modalFadeIn 0.3s;
    overflow: hidden;
}

@keyframes modalFadeIn {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

.modal-header {
    background-color: var(--color-primary);
    color: var(--color-text-light);
    padding: 1rem;
    border-radius: var(--border-radius) var(--border-radius) 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h2 {
    font-size: 1.2rem;
    font-weight: bold;
}

.close-modal {
    font-size: 1.5rem;
    cursor: pointer;
}

.modal-body {
    padding: 1rem;
    max-height: 400px;
    overflow-y: auto;
}

.modal-footer {
    padding: 1rem;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    border-top: 1px solid var(--color-border);
}

/* Form Elements */
.form-group {
    margin-bottom: 1rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.3rem;
    font-weight: bold;
}

.form-group input, .form-group select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
}

/* Buttons */
.primary-btn, .cancel-btn {
    padding: 0.5rem 1rem;
    border-radius: var(--border-radius);
    border: none;
    cursor: pointer;
    transition: background-color var(--transition-speed);
}

.primary-btn {
    background-color: var(--color-primary);
    color: var(--color-text-light);
}

.primary-btn:hover:not(:disabled) {
    background-color: var(--color-secondary);
}

.primary-btn:disabled {
    background-color: #aaa;
    cursor: not-allowed;
}

.cancel-btn {
    background-color: #ccc;
    color: #333;
}

.cancel-btn:hover {
    background-color: #bbb;
}

/* Settings Tabs */
.settings-tabs {
    display: flex;
    flex-direction: column;
}

.tab-buttons {
    display: flex;
    border-bottom: 1px solid var(--color-border);
    margin-bottom: 1rem;
}

.tab-btn {
    padding: 0.5rem 1rem;
    background: none;
    border: none;
    cursor: pointer;
    font-weight: bold;
    color: var(--color-text);
    position: relative;
    transition: color var(--transition-speed);
}

.tab-btn:hover {
    color: var(--color-primary);
}

.tab-btn.active {
    color: var(--color-primary);
}

.tab-btn.active::after {
    content: '';
    position: absolute;
    bottom: -1px;
    left: 0;
    width: 100%;
    height: 3px;
    background-color: var(--color-primary);
}

.tab-content {
    flex: 1;
}

.tab-pane {
    display: none;
}

.tab-pane.active {
    display: block;
}

/* Toggle Switch */
.toggle-switch {
    display: flex;
    align-items: center;
    cursor: pointer;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: relative;
    display: inline-block;
    width: 40px;
    height: 20px;
    background-color: #ccc;
    border-radius: 20px;
    margin-right: 10px;
    transition: background-color var(--transition-speed);
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    border-radius: 50%;
    transition: transform var(--transition-speed);
}

input:checked + .toggle-slider {
    background-color: var(--color-primary);
}

input:checked + .toggle-slider:before {
    transform: translateX(20px);
}

.toggle-label {
    font-weight: normal;
}

/* Provider and Agent Settings */
.settings-section {
    margin-bottom: 1.5rem;
}

.settings-section h3 {
    margin-bottom: 1rem;
    color: var(--color-primary);
    border-bottom: 1px solid var(--color-border);
    padding-bottom: 0.5rem;
}

.provider-section, .agent-section {
    background-color: var(--color-bg-dark);
    border-radius: var(--border-radius);
    padding: 1rem;
    margin-bottom: 1rem;
}

.provider-section h4, .agent-section h4 {
    margin-bottom: 0.8rem;
    color: var(--color-secondary);
}

/* Password Field with Show/Hide Button */
.form-group {
    position: relative;
}

.form-group input[type="password"] {
    padding-right: 40px;
}

.show-hide-btn {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    cursor: pointer;
    color: var(--color-text);
    padding: 0.3rem;
    margin-top: 10px;
}

.show-hide-btn:hover {
    color: var(--color-primary);
}

/* Saves List */
.saves-list {
    max-height: 300px;
    overflow-y: auto;
}

.save-item {
    padding: 0.8rem;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    margin-bottom: 0.5rem;
    cursor: pointer;
    transition: background-color var(--transition-speed);
}

.save-item:hover {
    background-color: rgba(0, 0, 0, 0.03);
}

.save-item.selected {
    background-color: rgba(var(--color-primary), 0.1);
    border-color: var(--color-primary);
}

.save-item-header {
    display: flex;
    justify-content: space-between;
}

.save-item-name {
    font-weight: bold;
}

.save-item-details {
    font-size: 0.85rem;
    margin-top: 0.3rem;
    color: #666;
}

/* Loading indicator */
.loading-saves {
    text-align: center;
    padding: 1rem;
    font-style: italic;
    color: #777;
}

/* Notification System */
.notification-container {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 1100;
    max-width: 300px;
}

.notification {
    margin-bottom: 0.5rem;
    padding: 0.8rem 1rem;
    border-radius: var(--border-radius);
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
    animation: notificationFadeIn 0.3s;
}

@keyframes notificationFadeIn {
    from { opacity: 0; transform: translateX(30px); }
    to { opacity: 1; transform: translateX(0); }
}

.notification.success {
    border-left: 4px solid var(--color-success);
}

.notification.info {
    border-left: 4px solid var(--color-info);
}

.notification.warning {
    border-left: 4px solid var(--color-warning);
}

.notification.error {
    border-left: 4px solid var(--color-error);
}

.notification-close {
    cursor: pointer;
    padding: 0.2rem;
    font-weight: bold;
}

/* ===== Character Creator Styles ===== */
.character-creator-container {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
}

.character-info-section {
    flex: 1;
    min-width: 200px;
}

.character-icon-section {
    flex: 0 0 200px;
    display: flex;
    flex-direction: column;
}

.icon-display-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.icon-display {
    width: 100%;
    height: 200px;
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    background-color: #f5f5f5;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
}

.icon-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.icon-nav-btn {
    background-color: var(--color-primary);
    color: var(--color-text-light);
    border: none;
    border-radius: var(--border-radius);
    padding: 0.3rem 0.7rem;
    cursor: pointer;
}

.icon-nav-btn:hover {
    background-color: var(--color-secondary);
}

.loading-icons, .no-icons-message {
    text-align: center;
    color: #777;
    font-style: italic;
}

/* ===== Responsive Design ===== */
@media (min-width: 768px) {
    .game-header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
    }
    
    .game-title {
        text-align: left;
    }
    
    .game-info {
        justify-content: center;
        flex-grow: 1;
    }
    
    .menu-buttons {
        justify-content: flex-end;
    }
}

@media (max-width: 767px) {
    .game-info {
        flex-direction: column;
        align-items: center;
    }
    
    .game-title {
        margin-bottom: 0.5rem;
    }
    
    .menu-buttons {
        margin-top: 0.5rem;
    }
}

@media (max-width: 480px) {
    .menu-btn {
        padding: 0.4rem 0.7rem;
        font-size: 0.8rem;
    }
    
    .modal-content {
        width: 95%;
        max-width: none;
    }
}

/* Extra layout for origin details/backstory */
.origin-and-backstory { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 10px; }
.origin-and-backstory h3 { margin: 6px 0; }
.origin-text { background:#f7f7f7; border:1px solid var(--color-border); border-radius: var(--border-radius); padding: 8px; min-height: 48px; }
.origin-backstory-card textarea { width: 100%; border:1px solid var(--color-border); border-radius: var(--border-radius); padding: 8px; }

/* Character Creator tabs */
.cc-tabs { display: flex; gap: 6px; margin-bottom: 10px; }
.cc-tab-btn { background: #444; color: #eee; border: none; padding: 6px 10px; border-radius: 6px; cursor: pointer; }
.cc-tab-btn.active { background: var(--color-primary); color: var(--color-text-light); }
.cc-step { }

/* Stats grid */
#cc-stats-grid { display: grid; grid-template-columns: 1.2fr 0.6fr 0.7fr 0.7fr 0.7fr 0.7fr 0.8fr; gap: 6px; align-items: center; }
.cc-stat-row { display: contents; }
.cc-stat-name { font-weight: bold; color: var(--color-text); }
.cc-stat-base, .cc-stat-adjust, .cc-stat-race, .cc-stat-class, .cc-stat-total, .cc-stat-mod { text-align: center; color: var(--color-text); }
.cc-stat-controls { display:flex; justify-content:center; gap:4px; }
.cc-stat-btn { padding: 2px 8px; }
.cc-points-remaining { color: var(--color-text); margin: 6px 0; font-weight: bold; }
.cc-pos { color: var(--color-success); font-weight: 600; }
.cc-neg { color: var(--color-error); font-weight: 600; }

/* Dev grid and inspector */
#layout-grid-overlay { position: fixed; inset: 0; pointer-events: none; z-index: 9998; background-image:
    linear-gradient(var(--grid-color) 1px, transparent 1px),
    linear-gradient(90deg, var(--grid-color) 1px, transparent 1px),
    linear-gradient(var(--grid-color-2) 1px, transparent 1px),
    linear-gradient(90deg, var(--grid-color-2) 1px, transparent 1px);
    background-size: var(--grid-size) var(--grid-size), var(--grid-size) var(--grid-size), calc(var(--grid-size)*4) calc(var(--grid-size)*4), calc(var(--grid-size)*4) calc(var(--grid-size)*4);
}
#layout-hover-overlay { position: fixed; pointer-events: none; z-index: 9999; border: 2px dashed rgba(255,255,0,0.7); background: rgba(255,255,0,0.1); }
#layout-inspector { position: fixed; pointer-events: auto; z-index: 10000; background: rgba(0,0,0,0.85); color:#fff; font-size:12px; padding:8px 10px; border-radius:6px; max-width: 360px; box-shadow: 0 2px 8px rgba(0,0,0,0.4); }
#layout-inspector .insp-row { display:flex; align-items:center; gap:6px; margin-top:4px; }
#layout-inspector .insp-row label { min-width: 70px; font-weight: bold; }
#layout-inspector .insp-row input { width: 80px; padding:2px 4px; border-radius:4px; border: 1px solid #555; background:#222; color:#fff; }

/* Element resize overlay */
#layout-resize-overlay { position: fixed; inset:auto; pointer-events: none; z-index: 10001; border: 2px solid rgba(0, 200, 255, 0.8); box-shadow: inset 0 0 0 2px rgba(0,200,255,0.2); }
#layout-resize-overlay .handle { position:absolute; width: 14px; height:14px; background: #00c8ff; border:2px solid #fff; border-radius: 50%; pointer-events:auto; cursor: pointer; }
#layout-resize-overlay .handle.n { top:-8px; left:50%; transform:translate(-50%, -50%); cursor: ns-resize; }
#layout-resize-overlay .handle.s { bottom:-8px; left:50%; transform:translate(-50%, 50%); cursor: ns-resize; }
#layout-resize-overlay .handle.e { right:-8px; top:50%; transform:translate(50%, -50%); cursor: ew-resize; }
#layout-resize-overlay .handle.w { left:-8px; top:50%; transform:translate(-50%, -50%); cursor: ew-resize; }
#layout-resize-overlay .handle.ne { right:-8px; top:-8px; transform:translate(50%, -50%); cursor: nesw-resize; }
#layout-resize-overlay .handle.nw { left:-8px; top:-8px; transform:translate(-50%, -50%); cursor: nwse-resize; }
#layout-resize-overlay .handle.se { right:-8px; bottom:-8px; transform:translate(50%, 50%); cursor: nwse-resize; }
#layout-resize-overlay .handle.sw { left:-8px; bottom:-8px; transform:translate(-50%, 50%); cursor: nesw-resize; }
#layout-resize-overlay .toolbar { position:absolute; top:-28px; right:0; pointer-events:auto; display:flex; gap:6px; }
#layout-resize-overlay .toolbar button { background:#00c8ff; color:#000; border:none; border-radius:4px; padding:2px 6px; font-size:12px; cursor:pointer; }
#layout-resize-overlay .toolbar button:hover { background:#4dd6ff; }
#layout-resize-overlay .toolbar button.save { background:#ffca28; color:#000; font-weight:bold; }
#layout-resize-overlay .toolbar button.danger { background:#f44336; color:#fff; }
#layout-resize-overlay .toolbar button:disabled { opacity:0.6; cursor:not-allowed; }
#layout-resize-overlay .drag-surface { position:absolute; inset:0; pointer-events:none; cursor: default; background: transparent; }

/* ----- Py GUI Parity Layout ----- */
body { background-color: #1E1E1E; }
body.has-bg::before {
    content: "";
    position: fixed;
    inset: 0;
    background-image: var(--bg-image-url);
    background-size: cover;
    background-position: center;
    z-index: -1;
}

.game-frame {
    display: grid;
    /* Match Py GUI proportions: configurable via variables */
    grid-template-columns: var(--left-menu-width) 1fr var(--right-panel-width);
    grid-template-rows: auto 1fr auto;
    gap: var(--content-gap);
    min-height: 100vh;
    padding: 10px;
    /* Prevent horizontal overflow - ensure frame fits viewport */
    width: 100%;
    max-width: 100vw;
    box-sizing: border-box;
    overflow-x: hidden;
}

/* Hard layout anchors to prevent accidental swapping */
.left-menu { 
    grid-column: 1 !important;
    /* Prevent left menu from forcing grid expansion */
    min-width: 0 !important;
    max-width: var(--left-menu-width);
}
.center-stack { 
    grid-column: 2 !important; 
    display: grid; 
    grid-template-rows: var(--center-output-track, 1fr) auto;
    /* Critical: Allow center to shrink to prevent overflow */
    min-width: 0 !important;
    overflow: hidden;
}
.right-panel { 
    grid-column: 3 !important;
    /* Prevent right panel from forcing grid expansion */
    min-width: 0 !important;
    max-width: var(--right-panel-width);
}
.banner-bar { 
    grid-column: 1 / 4 !important;
    /* Critical: Prevent banner from forcing grid expansion */
    min-width: 0 !important;
    overflow: hidden;
}
.status-bar { 
    grid-column: 1 / 4 !important;
    /* Critical: Prevent status bar from forcing grid expansion */
    min-width: 0 !important;
    overflow: hidden;
}

/* Ensure correct ordering inside the center stack */
.center-stack > .game-output { grid-row: 1 !important; }
.center-stack > .command-input-container { grid-row: 2 !important; position: static !important; }

.banner-bar {
    grid-column: 1 / 4;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    padding-top: 6px;
}
.title-banner img { max-height: 100px; width: auto; }
.music-controls { position: absolute; right: 8px; top: 8px; display: flex; gap: 6px; }
.music-controls .music-btn { width: 32px; height: 32px; background: transparent; border: none; border-radius: 16px; cursor: pointer; }
.music-controls .music-btn:hover { background: rgba(255,255,255,0.1); }
.music-controls img { width: 24px; height: 24px; }

.left-menu { grid-column: 1; display:flex; flex-direction:column; align-items:center; }
.left-menu .menu-buttons { display:flex; flex-direction:column; gap:12px; width: calc(var(--left-menu-width) - 40px); padding-top:10px; }
.left-menu .menu-btn { width: 100%; height:50px; background-color: transparent; color:#000000; border:none; font-weight:bold; }
.left-menu .menu-btn { background-image: url('/images/gui/button_normal.png'); background-position:center; background-repeat:no-repeat; }
.left-menu .menu-btn:hover { background-image: url('/images/gui/button_hover.png'); }
.left-menu .menu-btn:active { background-image: url('/images/gui/button_pressed.png'); color:#FF0000; }
.center-stack { grid-column: 2; display: grid; grid-template-rows: var(--center-output-track, 1fr) auto; gap: 8px; }
.right-panel {
    grid-column: 3 !important;
    background: rgba(51,51,51,0.85);
    border: 2px solid #333333;
    border-radius: 8px;
    padding: 10px 10px 8px 10px;
    /* ensure inner content fills the wider column cleanly */
    box-sizing: border-box;
    /* Enable scrolling when content overflows */
    overflow-y: auto;
    overflow-x: hidden;
    /* Ensure smooth scrolling */
    scroll-behavior: smooth;
    /* Set max height to fit within the grid container */
    max-height: calc(100vh - var(--header-height, 100px) - var(--footer-height, 40px) - var(--content-gap, 10px) * 2);
}
.status-bar {
    grid-column: 1 / 4;
    background: rgba(51,51,51,0.9);
    color: #ddd;
    border-radius: 8px;
    border: 1px solid #333333;
    padding: 6px 10px;
    font-family: Garamond, 'Palatino Linotype', Palatino, serif;
    /* Prevent status text from forcing horizontal expansion */
    min-width: 0 !important;
    overflow: hidden;
}

/* Ensure status text doesn't overflow */
.status-text {
    min-width: 0 !important;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Output styling to match Py defaults */
.game-output {
    background: var(--output-bg, #D2B48C);
    border: 2px solid #333333;
    border-radius: 8px;
    padding: 12px;
    font-family: Garamond, 'Palatino Linotype', Palatino, serif;
    max-height: none;
    /* Enable scrolling when content overflows */
    overflow-y: auto;
    overflow-x: hidden;
    /* Ensure smooth scrolling */
    scroll-behavior: smooth;
    /* Critical: Prevent game output from forcing horizontal expansion */
    min-width: 0 !important;
    /* Ensure text wraps properly instead of expanding container */
    overflow-wrap: anywhere;
    word-break: break-word;
}

/* Command input look-and-feel */
.command-input-container {
    background-color: rgba(51,51,51,1.0);
    border-radius: 10px;
    padding: 5px;
    border: 2px solid #333333;
    position: static !important; /* never float to top */
}
.command-input-container .command-input {
    background-color: rgba(255,255,255,0.7);
    color: #0d47a1;
    border: 1px solid #c4b59d;
    border-radius: 4px;
    padding: 8px;
    font-family: Garamond, 'Palatino Linotype', Palatino, serif;
    font-size: 14px;
    margin-left: 5px;
    margin-right: 5px;
}

.right-tabs .tab-buttons.small-tabs .rp-tab-btn { padding: 0.35rem 0.8rem; font-size: 0.95rem; }
.right-tabs .rp-tab-btn { background: none; border: none; cursor: pointer; color: #eee; }
.right-tabs .rp-tab-btn.active { color: #fff; border-bottom: 2px solid #c4b59d; }
.right-tabs .rp-tab-pane { 
    display: none; 
    max-height: var(--rp-pane-max, none); 
    overflow-y: auto;
    overflow-x: hidden;
    /* Ensure smooth scrolling within tab panes */
    scroll-behavior: smooth;
    /* When max-height is set, ensure content is accessible */
    box-sizing: border-box;
}
.right-tabs .rp-tab-pane.active { display: block; }
.right-tabs .placeholder { color: #ddd; font-style: italic; padding: 8px; }
/* ===== ENHANCED DESIGN SYSTEM ===== */
:root {
    /* Text colors - improved contrast */
    --text-primary: #FFFFFF;
    --text-secondary: #E8E8E8;
    --text-tertiary: #CCCCCC;
    --text-muted: #999999;
    --text-disabled: #666666;
    
    /* Currency colors */
    --currency-gold: #FFD700;
    --currency-silver: #C0C0C0;
    --currency-copper: #CD7F32;
    
    /* Status colors */
    --status-success: #4CAF50;
    --status-error: #F44336;
    --status-warning: #FF9800;
    --status-info: #2196F3;
    
    /* Background colors */
    --bg-section: rgba(44,44,44,0.95);
    --bg-panel: rgba(51,51,51,0.85);
    --bg-hover: rgba(255,255,255,0.08);
    --bg-active: rgba(255,255,255,0.12);
    --bg-modal: #FFFFFF;
    
    /* Border colors */
    --border-main: #666666;
    --border-light: #555555;
    --border-accent: #C4B59D;
    
    /* Typography */
    --font-size-h1: 1.4rem;
    --font-size-h2: 1.15rem;
    --font-size-body: 0.95rem;
    --font-size-small: 0.85rem;
}

/* Combat log line styling */
#tab-combat .combat-log-line { color: var(--text-secondary); padding: 2px 0; line-height: 1.25; }
#tab-combat .combat-log-line.cl-round { color: #FFD700; font-weight: 700; }
#tab-combat .combat-log-line.cl-turnorder { color: #87CEFA; font-weight: 600; }
#tab-combat .combat-log-line.cl-turn { color: #00BFFF; font-weight: 600; }
#tab-combat .combat-log-line.cl-attack { color: #FF69B4; }
#tab-combat .combat-log-line.cl-miss { color: #B0B0B0; font-style: italic; }
#tab-combat .combat-log-line.cl-damage { color: #FF5555; font-weight: 600; }
#tab-combat .combat-log-line.cl-heal { color: #C0F75B; font-weight: 600; }
#tab-combat .combat-log-line.cl-status { color: #FFA500; }
#tab-combat .combat-log-line.cl-defend { color: #9ACD32; }
#tab-combat .combat-log-line.cl-generic { color: var(--text-secondary); }

/* Right panel content blocks - ENHANCED */
.rp-header {
    margin-bottom: 12px; 
    padding-bottom: 8px;
    border-bottom: 2px solid var(--border-accent);
}
.rp-name { 
    font-weight: bold; 
    font-size: 1.2rem; 
    color: var(--text-primary);
    text-shadow: 0 1px 3px rgba(0,0,0,0.6);
    margin-bottom: 4px;
}
.rp-sub { 
    color: var(--text-secondary); 
    font-size: 0.95rem;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

/* Section grouping (like QGroupBox) */
.rp-section {
    background: var(--bg-section);
    border: 1px solid var(--border-main);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.rp-section-title {
    font-weight: bold;
    font-size: var(--font-size-h2);
    color: var(--text-primary);
    margin-bottom: 8px;
    padding-bottom: 4px;
    border-bottom: 1px solid var(--border-light);
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.rp-group { 
    background: var(--bg-section); 
    border: 1px solid var(--border-light); 
    border-radius: 6px; 
    margin: 8px 0; 
    padding: 10px;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
}

.rp-title { 
    color: var(--text-primary); 
    font-weight: bold; 
    font-size: 1.05rem;
    margin-bottom: 6px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.rp-subtitle {
    color: var(--text-secondary);
    font-weight: 600;
    font-size: 0.9rem;
    margin-top: 8px;
    margin-bottom: 4px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.rp-row { 
    display: flex; 
    justify-content: space-between; 
    color: var(--text-secondary); 
    padding: 4px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    transition: background-color 0.2s;
}

.rp-row:hover {
    background-color: var(--bg-hover);
}

.rp-row:last-child {
    border-bottom: none;
}

.rp-row > span:first-child {
    color: var(--text-tertiary);
    font-weight: 600;
}

.rp-row > span:last-child {
    color: var(--text-primary);
    font-weight: normal;
}

.rp-empty { 
    color: var(--text-muted); 
    font-style: italic;
    text-align: center;
    padding: 12px;
}

.rp-columns { 
    display: flex; 
    gap: 12px; 
}

.rp-col { 
    flex: 1; 
}

/* Resource bars - ENHANCED with gradients */
.rp-bar { 
    margin: 8px 0; 
}

.rp-bar-title { 
    color: var(--text-primary); 
    font-weight: bold; 
    font-size: 0.9rem;
    margin-bottom: 4px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.rp-bar-track { 
    height: 18px; 
    background: #1a1a1a; 
    border: 1px solid var(--border-light); 
    border-radius: 9px; 
    overflow: hidden;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
}

.rp-bar-fill { 
    height: 100%; 
    transition: width 0.3s ease;
    position: relative;
    box-shadow: inset 0 2px 4px rgba(255,255,255,0.2);
}

/* Health bar gradient - red */
.rp-bar-fill[data-bar-type="health"] {
    background: linear-gradient(to bottom, #ff4444, #cc0000);
}

/* Mana bar gradient - blue */
.rp-bar-fill[data-bar-type="mana"] {
    background: linear-gradient(to bottom, #4488ff, #0044cc);
}

/* Stamina bar gradient - green */
.rp-bar-fill[data-bar-type="stamina"] {
    background: linear-gradient(to bottom, #44ff44, #00cc00);
}

/* Resolve bar gradient - purple */
.rp-bar-fill[data-bar-type="resolve"] {
    background: linear-gradient(to bottom, #cc44ff, #8800cc);
}
/* ===== CURRENCY DISPLAY ===== */
.currency-section {
    background: var(--bg-section);
    border: 1px solid var(--border-main);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
}

.currency-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
}

.currency-item {
    text-align: center;
}

.currency-label {
    font-size: 0.85rem;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    margin-bottom: 4px;
}

.currency-value {
    font-size: 1.1rem;
    font-weight: bold;
    text-shadow: 0 1px 3px rgba(0,0,0,0.6);
}

.currency-gold .currency-label,
.currency-gold .currency-value {
    color: var(--currency-gold);
}

.currency-silver .currency-label,
.currency-silver .currency-value {
    color: var(--currency-silver);
}

.currency-copper .currency-label,
.currency-copper .currency-value {
    color: var(--currency-copper);
}

/* Weight display */
.weight-section {
    background: var(--bg-section);
    border: 1px solid var(--border-main);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
    text-align: center;
}

.weight-label {
    color: var(--text-tertiary);
    font-size: 0.85rem;
    margin-bottom: 4px;
}

.weight-value {
    color: var(--text-primary);
    font-size: 1.1rem;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.weight-value.over-limit {
    color: var(--status-error);
}

/* ===== INVENTORY ===== */
.inventory-filters {
    background: var(--bg-section);
    border: 1px solid var(--border-main);
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 12px;
    display: flex;
    gap: 10px;
    align-items: center;
}

.inventory-filters label {
    color: var(--text-tertiary);
    font-weight: 600;
    font-size: 0.9rem;
}

.inventory-filters select,
.inventory-filters input {
    background: #2a2a2a;
    border: 1px solid var(--border-light);
    border-radius: 4px;
    color: var(--text-secondary);
    padding: 6px 10px;
}

.inventory-filters select:focus,
.inventory-filters input:focus {
    outline: none;
    border-color: var(--border-accent);
}

.inv-row { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    border-bottom: 1px solid rgba(255,255,255,0.05); 
    padding: 8px 6px;
    transition: background-color 0.2s;
}

.inv-row:hover {
    background-color: var(--bg-hover);
}

.inv-row:nth-child(even) {
    background-color: rgba(255,255,255,0.02);
}

.inv-name { 
    color: var(--text-primary);
    font-weight: 500;
    flex: 1;
}

.inv-equipped {
    color: var(--status-success);
    font-size: 0.75rem;
    font-weight: bold;
    margin-right: 8px;
}

.inv-actions { 
    display: flex; 
    gap: 6px; 
}

.inv-btn { 
    background: #3a3a3a; 
    color: var(--text-secondary); 
    border: 1px solid var(--border-light); 
    border-radius: 4px; 
    padding: 4px 10px; 
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
}

.inv-btn:hover { 
    background: #4a4a4a;
    color: var(--text-primary);
    border-color: var(--border-accent);
}

/* ===== INVENTORY GRID SYSTEM ===== */
.inventory-grid-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 8px;
}

.inventory-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
    gap: 6px;
    padding: 8px;
    background: rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    max-height: 600px;
    overflow-y: auto;
}

.inventory-cell {
    position: relative;
    aspect-ratio: 1;
    min-width: 54px;
    min-height: 54px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    overflow: hidden;
}

.inventory-cell.empty {
    opacity: 0.5;
}

.inventory-cell:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
}

.inventory-cell.dragging {
    opacity: 0.5;
    transform: scale(0.9);
}

.inventory-cell-icon {
    width: 100%;
    height: 100%;
    object-fit: contain;
    padding: 4px;
}

/* Rarity borders */
.inventory-cell[data-rarity="common"] {
    border-color: #c0c0c0;
}

.inventory-cell[data-rarity="uncommon"] {
    border-color: #00ff00;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.3);
}

.inventory-cell[data-rarity="rare"] {
    border-color: #0070dd;
    box-shadow: 0 0 8px rgba(0, 112, 221, 0.3);
}

.inventory-cell[data-rarity="epic"] {
    border-color: #a335ee;
    box-shadow: 0 0 8px rgba(163, 53, 238, 0.3);
}

.inventory-cell[data-rarity="legendary"] {
    border-color: #ff8000;
    box-shadow: 0 0 10px rgba(255, 128, 0, 0.4);
    animation: glow-legendary 2s ease-in-out infinite;
}

.inventory-cell[data-rarity="artifact"] {
    border-color: #e6cc80;
    box-shadow: 0 0 10px rgba(230, 204, 128, 0.4);
    animation: glow-artifact 2s ease-in-out infinite;
}

@keyframes glow-legendary {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 128, 0, 0.4); }
    50% { box-shadow: 0 0 20px rgba(255, 128, 0, 0.6); }
}

@keyframes glow-artifact {
    0%, 100% { box-shadow: 0 0 10px rgba(230, 204, 128, 0.4); }
    50% { box-shadow: 0 0 20px rgba(230, 204, 128, 0.6); }
}

/* Item overlays */
.item-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.item-stack-count {
    position: absolute;
    bottom: 2px;
    right: 4px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 11px;
    font-weight: bold;
    padding: 2px 4px;
    border-radius: 3px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
}

.item-durability-badge {
    position: absolute;
    bottom: 2px;
    right: 2px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 10px;
    font-weight: bold;
    padding: 2px 4px;
    border-radius: 3px;
    z-index: 2;
}

.item-durability-badge.low {
    background: rgba(255, 0, 0, 0.8);
}

.item-durability-badge.medium {
    background: rgba(255, 165, 0, 0.8);
}

.item-durability-badge.high {
    background: rgba(0, 255, 0, 0.8);
}

.item-quest-marker {
    position: absolute;
    top: 2px;
    right: 2px;
    color: gold;
    font-size: 14px;
    text-shadow: 0 0 4px rgba(255, 215, 0, 0.8);
}

.item-equipped-marker {
    position: absolute;
    top: 2px;
    left: 2px;
    color: #00ff00;
    font-size: 12px;
    text-shadow: 0 0 4px rgba(0, 255, 0, 0.8);
}

/* ===== PAPERDOLL SYSTEM ===== */
.paperdoll-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px 8px;
    background: rgba(0, 0, 0, 0.05);
    border-radius: 12px;
    margin: 12px 0;
}

.paperdoll-wrapper {
    position: relative;
    width: 100%;
    max-width: 400px;
    aspect-ratio: 2/3;
    margin: 0 auto;
}

.paperdoll-silhouette {
    width: 100%;
    height: 100%;
    object-fit: fill;
    opacity: 0.8;
    transition: opacity 0.3s ease;
}

.paperdoll-container:hover .paperdoll-silhouette {
    opacity: 1;
}

.paperdoll-slots {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.equipment-slot {
    position: absolute;
    width: 48px;
    height: 48px;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    cursor: pointer;
    pointer-events: all;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.equipment-slot:hover {
    background: rgba(0, 0, 0, 0.8);
    border-color: rgba(255, 255, 255, 0.6);
    transform: scale(1.1);
    z-index: 10;
    box-shadow: 0 0 12px rgba(255, 255, 255, 0.4);
}

.equipment-slot.empty {
    opacity: 0.5;
}

.equipment-slot.empty:hover {
    opacity: 0.8;
}

.equipment-slot.has-item {
    background: rgba(50, 50, 50, 0.8);
    border-color: rgba(100, 200, 255, 0.5);
}

.equipment-slot-icon {
    width: 100%;
    height: 100%;
    object-fit: contain;
    padding: 4px;
}

.equipment-slot-label {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 100;
    margin-bottom: 4px;
}

.equipment-slot:hover .equipment-slot-label {
    opacity: 1;
}

/* Equipment slot positioning (percentage-based for responsiveness) */
.equipment-slot[data-slot="head"] { top: 8%; left: 50%; transform: translateX(-50%); }
.equipment-slot[data-slot="neck"] { top: 16%; left: 50%; transform: translateX(-50%); }
.equipment-slot[data-slot="shoulders"] { top: 22%; left: 28%; }
.equipment-slot[data-slot="chest"] { top: 30%; left: 50%; transform: translateX(-50%); }
.equipment-slot[data-slot="back"] { top: 30%; left: 75%; }
.equipment-slot[data-slot="wrists"] { top: 45%; left: 72%; width: 40px; height: 40px; }
.equipment-slot[data-slot="hands"] { top: 50%; left: 50%; transform: translateX(-50%); width: 40px; height: 40px; }
.equipment-slot[data-slot="waist"] { top: 55%; left: 50%; transform: translateX(-50%); }
.equipment-slot[data-slot="legs"] { top: 70%; left: 50%; transform: translateX(-50%); }
.equipment-slot[data-slot="feet"] { top: 88%; left: 50%; transform: translateX(-50%); }

/* Hand slots */
.equipment-slot[data-slot="main_hand"] { top: 58%; left: 70%; }
.equipment-slot[data-slot="off_hand"] { top: 58%; left: 30%; }
.equipment-slot[data-slot="ranged"] { top: 45%; left: 25%; }

/* Trinkets */
.equipment-slot[data-slot="trinket_1"] { top: 12%; left: 15%; width: 36px; height: 36px; }
.equipment-slot[data-slot="trinket_2"] { top: 12%; left: 85%; transform: translateX(-100%); width: 36px; height: 36px; }

/* Finger slots (compact, vertical stacks on sides) */
.equipment-slot[data-slot^="finger"] { 
    width: 28px; 
    height: 28px;
    border-radius: 50%;
}

/* Left hand fingers */
.equipment-slot[data-slot="finger_1"] { top: 44%; left: 10%; }
.equipment-slot[data-slot="finger_2"] { top: 50%; left: 10%; }
.equipment-slot[data-slot="finger_3"] { top: 56%; left: 10%; }
.equipment-slot[data-slot="finger_4"] { top: 62%; left: 10%; }
.equipment-slot[data-slot="finger_5"] { top: 68%; left: 10%; }

/* Right hand fingers */
.equipment-slot[data-slot="finger_6"] { top: 44%; right: 10%; }
.equipment-slot[data-slot="finger_7"] { top: 50%; right: 10%; }
.equipment-slot[data-slot="finger_8"] { top: 56%; right: 10%; }
.equipment-slot[data-slot="finger_9"] { top: 62%; right: 10%; }
.equipment-slot[data-slot="finger_10"] { top: 68%; right: 10%; }

/* Paperdoll rarity highlights */
.equipment-slot[data-rarity="uncommon"] {
    border-color: #00ff00;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.4);
}

.equipment-slot[data-rarity="rare"] {
    border-color: #0070dd;
    box-shadow: 0 0 6px rgba(0, 112, 221, 0.4);
}

.equipment-slot[data-rarity="epic"] {
    border-color: #a335ee;
    box-shadow: 0 0 8px rgba(163, 53, 238, 0.4);
}

.equipment-slot[data-rarity="legendary"] {
    border-color: #ff8000;
    box-shadow: 0 0 10px rgba(255, 128, 0, 0.5);
    animation: glow-legendary 2s ease-in-out infinite;
}

.equipment-slot[data-rarity="artifact"] {
    border-color: #e6cc80;
    box-shadow: 0 0 10px rgba(230, 204, 128, 0.5);
    animation: glow-artifact 2s ease-in-out infinite;
}

/* Paperdoll info */
.paperdoll-info {
    text-align: center;
    margin-top: 12px;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.paperdoll-race-class {
    font-weight: bold;
    color: var(--text-primary);
    margin-bottom: 4px;
}

/* Responsive paperdoll */
@media (max-width: 768px) {
    .paperdoll-wrapper {
        max-width: 300px;
    }
    
    .equipment-slot {
        width: 36px;
        height: 36px;
    }
    
    .equipment-slot[data-slot^="finger"] {
        width: 22px;
        height: 22px;
    }
    
    .equipment-slot[data-slot="trinket_1"],
    .equipment-slot[data-slot="trinket_2"] {
        width: 28px;
        height: 28px;
    }
}

/* ===== ITEM INFO MODAL ENHANCEMENTS ===== */
#item-info-modal .modal-content {
    max-width: 550px;
}

#item-info-body {
    background: #f5f5f5;
    color: #333;
}

#item-info-body h3 {
    color: #222;
    font-size: 1.3rem;
    margin-bottom: 16px;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--border-accent);
    text-shadow: none;
}

/* Override .rp-row styles for light background in item info modal */
#item-info-body .rp-row {
    color: #333;
    border-bottom: 1px solid #e0e0e0;
}

#item-info-body .rp-row:hover {
    background-color: #f9f9f9;
}

#item-info-body .rp-row > span:first-child {
    color: #222;
    font-weight: 600;
}

#item-info-body .rp-row > span:last-child {
    color: #333;
    font-weight: normal;
}

#item-info-body .rp-subtitle {
    color: #222;
    font-weight: 600;
    font-size: 1rem;
    margin-top: 12px;
    margin-bottom: 6px;
    text-shadow: none;
}

#item-info-body ul {
    background: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    padding: 10px;
    margin-top: 8px;
    list-style: none;
}

#item-info-body ul li {
    color: #555;
    padding: 4px 0;
    border-bottom: 1px solid #f0f0f0;
}

#item-info-body ul li:last-child {
    border-bottom: none;
}

.item-info-section {
    background: #f8f8f8;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 12px;
}

.item-info-row {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px solid #eee;
}

.item-info-row:last-child {
    border-bottom: none;
}

.item-info-label {
    font-weight: bold;
    color: #222;
    min-width: 120px;
}

.item-info-value {
    color: #333;
    text-align: right;
}

.item-stats-list,
.item-properties-list {
    background: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    padding: 10px;
    margin-top: 8px;
}

.item-stats-list li,
.item-properties-list li {
    color: #555;
    padding: 4px 0;
    border-bottom: 1px solid #f0f0f0;
}

.item-stats-list li:last-child,
.item-properties-list li:last-child {
    border-bottom: none;
}

/* Quest styling */
.quest-row {
    padding: 8px;
    margin: 4px 0;
    border-radius: 4px;
    border-left: 3px solid transparent;
    cursor: pointer;
    transition: all 0.2s;
}

.quest-row.active {
    border-left-color: var(--status-info);
    background: var(--bg-hover);
}

.quest-row.completed {
    border-left-color: var(--status-success);
    opacity: 0.8;
}

.quest-row.failed {
    border-left-color: var(--status-error);
    opacity: 0.7;
}

.quest-row:hover {
    background: var(--bg-active);
}

.quest-title {
    font-weight: bold;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.quest-status {
    font-size: 0.85rem;
    color: var(--text-tertiary);
}

.quest-objective {
    padding: 4px 8px;
    margin: 4px 0;
    border-left: 2px solid var(--border-light);
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.quest-objective.completed {
    color: var(--status-success);
    text-decoration: line-through;
}

.quest-objective.failed {
    color: var(--status-error);
    text-decoration: line-through;
}

/* Stat value indicators */
.stat-positive {
    color: var(--status-success) !important;
}

.stat-negative {
    color: var(--status-error) !important;
}

.stat-modifier {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-left: 4px;
}

/* ===== Critical Layout Overflow Fixes ===== */
/* Prevent any element from forcing horizontal overflow */
body {
    overflow-x: hidden !important;
    max-width: 100vw !important;
}

/* Ensure all text content wraps properly */
.game-output *,
.status-bar *,
.banner-bar * {
    max-width: 100%;
    overflow-wrap: break-word;
    word-wrap: break-word;
}

/* Force images and media to scale down if too wide */
.game-output img,
.game-output video,
.game-output iframe {
    max-width: 100%;
    height: auto;
}

/* Ensure pre-formatted text doesn't break layout */
.game-output pre,
.game-output code {
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
}

```

### File: gui\README.md

```markdown
# GUI Module

## Purpose

The `gui` module provides the primary desktop graphical user interface (GUI) for the RPG game. It allows players to interact with the game world, manage their character, view game output, and access various game functions like saving, loading, and settings configuration.

## Framework and Dependencies

*   **Framework:** The GUI is built using the **PySide6** library, the official Python bindings for the Qt framework.
*   **Core Dependency:** It relies heavily on the `core` module, particularly `core.base.engine.GameEngine`, for game logic, state management, and processing player commands.
*   **Other Libraries:** Standard Python libraries (`os`, `logging`, `concurrent.futures`, etc.).

## GUI Structure

The main interface is organized within the `MainWindow` (`main_window.py`) and consists of several key areas:

1.  **Main Window (`MainWindow`):** The top-level container holding all other UI elements. It manages the overall layout, window properties, and connections between components and the game engine.
2.  **Left Menu Panel (`components/menu_panel.py`):** A collapsible panel on the left side providing access to main game actions: New Game, Save Game, Load Game, Settings, LLM Settings, and Exit.
3.  **Center Area:**
    *   **Game Output (`components/game_output.py`):** A styled, scrollable text area displaying narrative, system messages, and game master descriptions.
    *   **Command Input (`components/command_input.py`):** A text field at the bottom for players to enter commands, with history functionality.
4.  **Right Panel (`components/right_panel.py`):** A collapsible, tabbed panel on the right side displaying dynamic game information:
    *   Character Sheet (`components/character_sheet.py`)
    *   Inventory (`components/inventory_panel.py`)
    *   Journal (`components/journal_panel.py`)
5.  **Status Bar (`components/status_bar.py`):** Located at the bottom of the window, displaying current game status like location, time, and game speed.
6.  **Dialogs (`dialogs/`):** Modal windows for specific interactions like character creation, saving/loading, and configuring settings.

## Directory Structure

*   **`main_window.py`**: Defines the `MainWindow` class, the central hub of the GUI application.
*   **`components/`**: Contains reusable UI widgets that make up the main interface:
    *   `character_sheet.py`: Displays player character stats, attributes, and other details.
    *   `combat_display.py`: (Likely) Widget for displaying combat information.
    *   `command_input.py`: The input field for player commands.
    *   `game_menu.py`: (Likely related to the main menu panel or in-game menus).
    *   `game_output.py`: The styled text area for displaying game narrative and messages.
    *   `inventory_panel.py`: Displays and manages the player's inventory.
    *   `journal_panel.py`: Displays quests and player notes.
    *   `menu_panel.py`: The main collapsible menu on the left.
    *   `right_panel.py`: The collapsible, tabbed panel on the right.
    *   `skill_check_display.py`: (Likely) Widget for displaying skill check results.
    *   `stat_allocation_widget.py`: Interactive widget for allocating stat points during character creation.
    *   `status_bar.py`: The status bar at the bottom of the window.
*   **`dialogs/`**: Contains modal dialog windows for specific tasks:
    *   `character_creation_dialog.py`: Handles the process of creating a new character, including stat allocation.
    *   `load_game_dialog.py`: Allows players to select and load a saved game.
    *   `new_game_dialog.py`: (Potentially simpler or older version of character creation).
    *   `save_game_dialog.py`: Allows players to name and save the current game state.
    *   `settings/`: Subdirectory containing dialogs and components for configuring game and LLM settings (`settings_dialog.py`, `llm_settings_dialog.py`, etc.).
*   **`utils/`**: Contains utility functions and classes supporting the GUI:
    *   `init_settings.py`: Initializes default application settings.
    *   `resource_manager.py`: Manages loading and access to UI resources like icons and images.

## Interaction with Core Engine

The GUI interacts with the `core.base.engine.GameEngine` in the following ways:

1.  **Sending Commands:** User input from `CommandInputWidget` is sent to the `GameEngine.process_command()` method. This processing happens in a separate thread (`CommandWorker` in `main_window.py`) using `QThread` to prevent freezing the UI during potentially long operations (like LLM calls).
2.  **Receiving Updates:** The `GameEngine` uses signals (specifically `output_generated`) to send game output (narrative, system messages) back to the `MainWindow`. The `MainWindow` then directs this output to the appropriate widget (`GameOutputWidget`).
3.  **State Display:** The `MainWindow` periodically checks the `GameEngine`'s state (`state_manager`) to update UI elements like the character sheet, inventory, journal (in the `RightPanel`), and the `StatusBar`. Signals/slots and timers (`QTimer`) are used for efficient updates.

## Current Functionality

*   **Themed Game Interface:** Stylized with thematic elements, custom graphics, and configurable appearance via settings.
*   **Character Creation System:** Full character creation with race/path selection, stat allocation, descriptions, and optional LLM integration.
*   **Main Game Loop Interface:** Displays game output, accepts player commands.
*   **Dynamic Information Panels:** Collapsible right panel with tabs for Character Sheet, Inventory, and Journal, updated based on game state.
*   **Game Management:** Dialogs for starting new games, saving progress, and loading saved games.
*   **Settings Configuration:** Dialogs to adjust display, style, and LLM provider settings.
*   **LLM Integration:** Threaded AI processing for narrative generation and gameplay assistance, toggleable via settings.
*   **Status Display:** Status bar showing current location, game time, and speed.
*   **Music Controls:** Basic controls for background music playback.

## Planned Features (Review Needed)

*   Level-up stat allocation dialog.
*   Enhanced inventory visualization with equipment slots.
*   Quest log interface with filtering.
*   Map/location visualization.
*   Additional character appearance customization.
*   (Time progression system with visual indicators - Already partially implemented in status bar).
*   (Journal system with categorized entries - Basic journal exists).

## Usage

The GUI is typically launched using the main project entry point or a dedicated script:

```bash
python main.py
```

or

```bash
python run_gui.py
```

## Implementation Details

*   **Pattern:** Follows principles similar to Model-View-Controller (MVC), where the `GameEngine` acts as the Model, UI components are the View, and `MainWindow` and component logic serve as Controllers.
*   **Asynchronicity:** Uses PySide6's signal/slot mechanism and `QThread` for handling background tasks (like command processing) without blocking the main UI thread.
*   **Styling:** Leverages Qt's stylesheet system (`.qss`, similar to CSS) and custom widgets for a consistent and themeable look and feel, managed partly through `utils/resource_manager.py` and settings.
*   **Modularity:** UI elements are broken down into reusable components within the `components/` directory.

```

### File: gui\components\character_sheet.py

```python
#!/usr/bin/env python3
"""
Character sheet widget for the RPG game GUI.
This module provides a widget for displaying the player character's information.
"""

import logging
import re
from typing import Optional, Dict, Any, List, Union, Callable
from PySide6.QtWidgets import (QListWidget,QListWidgetItem,
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, QTextEdit,
    QScrollArea, QFrame, QGroupBox, QProgressBar, QMenu, QToolTip
)
from PySide6.QtCore import Qt, Slot, Signal, QPoint
from PySide6.QtGui import QFont, QPixmap, QCursor, QMouseEvent,QColor

from core.base.state import get_state_manager
from core.interaction.enums import InteractionMode
from core.inventory.item import Item
from core.inventory.item_enums import EquipmentSlot
from core.inventory.item_manager import get_inventory_manager
from core.stats.modifier import StatModifier
from core.stats.stats_base import StatType, DerivedStatType, Stat, StatCategory
from core.stats.stats_manager import get_stats_manager
from core.utils.logging_config import get_logger

logger = get_logger("GUI")

class StatLabel(QLabel):
    """A label for displaying a stat that shows details on right-click."""
    
    def __init__(self, text: str, stat_name: str, parent=None):
        """
        Initialize the stat label.

        Args:
            text: The initial text to display.
            stat_name: The name of the stat this label represents (e.g., "STR", "MELEE_ATTACK").
            parent: The parent widget.
        """
        super().__init__(text, parent)
        # Store the enum name (e.g., "STR") for consistency with StatsManager keys
        self.stat_name_key = stat_name # Keep the original key passed in
        self.description = ""
        self.base_value = 0
        self.current_value = 0
        # Modifiers will be fetched dynamically for tooltip
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Handle mouse press events to show tooltips."""
        if event.button() == Qt.RightButton:
            self.show_tooltip(event.globalPos())
        super().mousePressEvent(event)
    
    def _fetch_modifiers(self) -> List[Dict[str, Any]]:
        """Fetch the list of modifiers for this stat."""
        try:
            # Get the StatsManager instance
            stats_manager = get_stats_manager()
            if not stats_manager:
                return []

            # Convert the stored stat_name_key back to the enum type if possible
            stat_type_enum = None
            try:
                stat_type_enum = StatType[self.stat_name_key]
            except KeyError:
                try:
                    stat_type_enum = DerivedStatType[self.stat_name_key]
                except KeyError:
                    logging.warning(f"Could not convert stat key '{self.stat_name_key}' to StatType or DerivedStatType for fetching modifiers.")
                    return []

            # Check if ModifierManager has a method to get the list
            # Assuming a method get_modifiers_for_stat exists or can be added
            if hasattr(stats_manager.modifier_manager, 'get_modifiers_for_stat'):
                # This method should return List[StatModifier] or List[Dict]
                mods = stats_manager.modifier_manager.get_modifiers_for_stat(stat_type_enum)
                # Convert StatModifier objects to dicts if necessary
                if mods and isinstance(mods[0], StatModifier):
                     return [mod.to_dict() for mod in mods] # Assuming StatModifier has to_dict()
                elif mods and isinstance(mods, list):
                     return mods # Assume it's already a list of dicts
                else:
                     return []
            else:
                # Fallback or log warning if the method doesn't exist
                logging.warning(f"ModifierManager lacks 'get_modifiers_for_stat' method.")
                return []

        except Exception as e:
            logging.error(f"Error fetching modifiers for {self.stat_name_key}: {e}")
            return []

    def show_tooltip(self, position: QPoint) -> None:
        """Show detailed tooltip for the stat."""
        # Fetch modifiers dynamically
        modifiers = self._fetch_modifiers()

        # Get the display name (e.g., "Strength") if available, otherwise use the key
        display_name = self.stat_name_key  # Default to key
        if hasattr(self, 'display_name_override'):  # Check if set by update_stat_data
            display_name = self.display_name_override

        tooltip_text = f"<b>{display_name}</b><hr>"

        if self.description:
            tooltip_text += f"{self.description}<br><br>"

        # Base / Total / Delta header with color-coded delta
        try:
            delta_val = (self.current_value or 0) - (self.base_value or 0)
        except Exception:
            delta_val = 0
        delta_sign = "+" if delta_val > 0 else ""
        delta_color = "#69c45f" if delta_val > 0 else ("#c45f5f" if delta_val < 0 else "#cccccc")
        tooltip_text += f"Base: {self.base_value}<br>"
        tooltip_text += f"Total: {self.current_value}"
        if delta_val != 0:
            tooltip_text += f" <span style='color:{delta_color}'>({delta_sign}{int(delta_val)})</span>"
        tooltip_text += "<br>"

        # Detailed modifiers list with color-coded values
        if modifiers:
            tooltip_text += "<br><b>Modifiers:</b><br>"
            for mod in modifiers:
                # Access modifier data assuming it's a dictionary now
                mod_source = mod.get('source_name') or mod.get('source') or 'Unknown'
                mod_value = mod.get('value', 0)
                mod_is_percentage = mod.get('is_percentage', False)
                mod_duration = mod.get('duration', None)

                sign = "+" if isinstance(mod_value, (int, float)) and mod_value > 0 else ""
                color = "#69c45f" if (isinstance(mod_value, (int, float)) and mod_value > 0) else ("#c45f5f" if (isinstance(mod_value, (int, float)) and mod_value < 0) else "#cccccc")
                val_text = f"<span style='color:{color}'>{sign}{mod_value}{'%' if mod_is_percentage else ''}</span>"
                dur_text = f" ({mod_duration} turns)" if (mod_duration is not None) else ""
                tooltip_text += f"{mod_source}: {val_text}{dur_text}<br>"
        else:
            tooltip_text += "<br>No active modifiers.<br>"

        QToolTip.showText(position, tooltip_text)

    def show_context_menu(self, position: QPoint) -> None:
        """Show context menu for the stat."""
        # Get the display name (e.g., "Strength") if available, otherwise use the key
        display_name = self.stat_name_key # Default to key
        if hasattr(self, 'display_name_override'): # Check if set by update_stat_data
            display_name = self.display_name_override

        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30; /* Dark background */
                color: #E0E0E0; /* Light text */
                border: 1px solid #555555; /* Subtle border */
                padding: 2px; /* Padding around all items */
            }
            QMenu::item {
                padding: 5px 20px 5px 20px; /* Top, Right, Bottom, Left padding */
                border: 1px solid transparent; /* Spacing between items */
            }
            QMenu::item:selected {
                background-color: #0E639C; /* Selection color */
                color: #FFFFFF;
            }
            QMenu::separator {
                height: 1px;
                background: #555555;
                margin-left: 10px;
                margin-right: 5px;
            }
        """)
        menu.addAction(f"{display_name} Details", lambda: self.show_tooltip(QCursor.pos()))
        menu.exec_(self.mapToGlobal(position))

    def update_stat_data(self, stat_data: Dict[str, Any]) -> None:
        """
        Update the stat data stored in the label for tooltip display.

        Args:
            stat_data: Dictionary containing stat information from StatsManager.
        """
        # Store the display name ("Strength") if provided, distinct from the key ("STR")
        if 'name' in stat_data:
            self.display_name_override = str(stat_data['name'])

        if 'description' in stat_data:
            self.description = stat_data['description']
        if 'base_value' in stat_data:
            self.base_value = stat_data['base_value']
        if 'value' in stat_data:
            self.current_value = stat_data['value']
        # We no longer store modifiers here, they are fetched dynamically


class CharacterSheetWidget(QScrollArea):
    """Widget for displaying character information."""

    item_unequip_from_slot_requested = Signal(EquipmentSlot)
    item_examine_requested = Signal(str) 
    item_drop_from_slot_requested = Signal(EquipmentSlot, str)
    
    def __init__(self, parent: Optional[QWidget] = None):
            """Initialize the character sheet widget."""
            super().__init__(parent)

            self.setWidgetResizable(True)
            self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.setStyleSheet("""
                QScrollArea {
                    background-color: #2D2D30;
                    border: none;
                }
            """)

            self.character_widget = QWidget()
            self.setWidget(self.character_widget)
            self.state_manager = get_state_manager()
            self._signal_connected = False

            self._pending_player_bar_updates: Dict[str, Dict[str, Any]] = {} 

            self._setup_ui() 
            self._clear_stat_displays()
            
    def _setup_ui(self):

        # Create the main layout
        self.main_layout = QVBoxLayout(self.character_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Initialize dictionaries for stat labels
        self.primary_stat_labels = {}
        self.derived_stat_labels = {}
        
        # Create character header
        self._create_header()
        
        # Create stats section
        self._create_stats_section()
        
        # Create skills section
        self._create_skills_section()
        
        # Create equipment section
        self._create_equipment_section()        
    
    def _create_header(self):
        """Create the character header section."""
        # Group box for character header
        header_group = QGroupBox("Character")
        header_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        header_layout = QHBoxLayout(header_group)
        
        # Character portrait frame
        portrait_frame = QFrame()
        portrait_frame.setFrameShape(QFrame.StyledPanel)
        portrait_frame.setFixedSize(100, 100)
        portrait_frame.setStyleSheet("""
            QFrame {
                border: 1px solid #555555;
                background-color: #222222;
            }
        """)
        
        # Character portrait label - this will be replaced with the actual image when available
        self.portrait_label = QLabel("Portrait")
        self.portrait_label.setAlignment(Qt.AlignCenter)
        self.portrait_label.setStyleSheet("color: #888888;")
        self.portrait_label.setScaledContents(True)  # Make the image scale to fit the label
        
        portrait_layout = QVBoxLayout(portrait_frame)
        portrait_layout.addWidget(self.portrait_label)
        
        # Character info
        info_layout = QVBoxLayout()
        
        # Create labels for character info
        self.name_label = QLabel("Name: Unknown")
        self.name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #E0E0E0;")
        
        self.race_class_label = QLabel("Race: Unknown | Class: Unknown")
        self.race_class_label.setStyleSheet("font-size: 12pt; color: #CCCCCC;")
        
        self.level_exp_label = QLabel("Level: 1 | Experience: 0/100")
        self.level_exp_label.setStyleSheet("font-size: 11pt; color: #BBBBBB;")
        
        # Experience bar
        self.exp_bar = QProgressBar()
        self.exp_bar.setRange(0, 100)
        self.exp_bar.setValue(0)
        self.exp_bar.setTextVisible(True)
        self.exp_bar.setStyleSheet("""
            QProgressBar {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                color: white;
            }
            QProgressBar::chunk {
                background-color: #006699;
                border-radius: 3px;
            }
        """)
        
        # Add widgets to layout
        info_layout.addWidget(self.name_label)
        info_layout.addWidget(self.race_class_label)
        info_layout.addWidget(self.level_exp_label)
        info_layout.addWidget(self.exp_bar)
        
        # Add layouts to header
        header_layout.addWidget(portrait_frame)
        header_layout.addLayout(info_layout, 1)  # 1 is the stretch factor
        
        # Add header to main layout
        self.main_layout.addWidget(header_group)
    
    def _create_stats_section(self):
        """Create the character stats section."""

        # --- Create Primary Stats Group Box ---
        primary_stats_group = QGroupBox("Primary Stats")
        primary_stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        primary_stats_layout = QGridLayout(primary_stats_group)
        primary_stats_layout.setColumnStretch(0, 1)
        primary_stats_layout.setColumnStretch(1, 1)

        # Add primary stats - Using Enum Name as stat_id
        self._add_stat(primary_stats_layout, 0, 0, StatType.STRENGTH.name, "Strength", "")
        self._add_stat(primary_stats_layout, 0, 1, StatType.DEXTERITY.name, "Dexterity", "")
        self._add_stat(primary_stats_layout, 1, 0, StatType.CONSTITUTION.name, "Constitution", "")
        self._add_stat(primary_stats_layout, 1, 1, StatType.INTELLIGENCE.name, "Intelligence", "")
        self._add_stat(primary_stats_layout, 2, 0, StatType.WISDOM.name, "Wisdom", "")
        self._add_stat(primary_stats_layout, 2, 1, StatType.CHARISMA.name, "Charisma", "")
        self._add_stat(primary_stats_layout, 3, 0, StatType.WILLPOWER.name, "Willpower", "")
        self._add_stat(primary_stats_layout, 3, 1, StatType.INSIGHT.name, "Insight", "")

        # --- Create Resources Group Box ---
        resources_group = QGroupBox("Resources")
        resources_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        resources_layout = QVBoxLayout(resources_group)

        # Create resource bars
        self.resource_bars = {}
        self._add_resource_bar(resources_layout, "Health", 100, 100, "#CC3333")
        self._add_resource_bar(resources_layout, "Mana", 50, 50, "#3366CC")
        self._add_resource_bar(resources_layout, "Stamina", 100, 100, "#66CC33")

        # --- Create Combat Status Group Box (Modified to be Turn Order / Initiative only) ---
        combat_info_group = QGroupBox("Combat Info") # Renamed for clarity
        combat_info_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        combat_info_layout = QVBoxLayout(combat_info_group)

        # Status Effects section
        status_label = QLabel("Status Effects:")
        status_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        combat_info_layout.addWidget(status_label)

        self.status_effects_list = QTextEdit()
        self.status_effects_list.setReadOnly(True)
        self.status_effects_list.setMaximumHeight(60) # Keep height manageable
        self.status_effects_list.setStyleSheet("""
            QTextEdit {
                background-color: #222222;
                border: 1px solid #444444;
                color: #E0E0E0;
                padding: 3px;
            }
        """)
        combat_info_layout.addWidget(self.status_effects_list)
        
        # Turn Order section (kept for consistency, but might be less prominent if combat display is primary)
        turn_label = QLabel("Turn Order:")
        turn_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        combat_info_layout.addWidget(turn_label)

        self.turn_order_list = QTextEdit()
        self.turn_order_list.setReadOnly(True)
        self.turn_order_list.setMaximumHeight(80) # Increased height for better visibility
        self.turn_order_list.setStyleSheet("""
            QTextEdit {
                background-color: #222222;
                border: 1px solid #444444;
                color: #E0E0E0;
                padding: 3px;
                line-height: 1.2; /* Adjust line height for readability */
            }
        """)
        combat_info_layout.addWidget(self.turn_order_list)

        # Initiative label
        initiative_layout = QHBoxLayout()
        initiative_title_label = QLabel("Initiative:") # Changed variable name to avoid conflict
        initiative_title_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.initiative_value = QLabel("0")
        self.initiative_value.setStyleSheet("color: #E0E0E0;")
        self.initiative_value.setAlignment(Qt.AlignRight)
        initiative_layout.addWidget(initiative_title_label)
        initiative_layout.addWidget(self.initiative_value)
        combat_info_layout.addLayout(initiative_layout)


        # --- Create Derived Stats Group Box ---
        derived_stats_group = QGroupBox("Derived Stats")
        derived_stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        derived_stats_layout = QGridLayout(derived_stats_group)
        derived_stats_layout.setColumnStretch(0, 1)
        derived_stats_layout.setColumnStretch(1, 1)

        # Add derived stats - Using Enum Name as stat_id
        self._add_stat(derived_stats_layout, 0, 0, DerivedStatType.MELEE_ATTACK.name, "Melee Attack", "")
        self._add_stat(derived_stats_layout, 0, 1, DerivedStatType.RANGED_ATTACK.name, "Ranged Attack", "")
        self._add_stat(derived_stats_layout, 1, 0, DerivedStatType.MAGIC_ATTACK.name, "Magic Attack", "")
        self._add_stat(derived_stats_layout, 1, 1, DerivedStatType.DEFENSE.name, "Defense", "")
        self._add_stat(derived_stats_layout, 2, 0, DerivedStatType.MAGIC_DEFENSE.name, "Magic Defense", "")
        # Initiative is now in Combat Info, removing from here to avoid duplication
        # self._add_stat(derived_stats_layout, 2, 1, DerivedStatType.INITIATIVE.name, "Initiative", "")
        self._add_stat(derived_stats_layout, 3, 0, DerivedStatType.CARRY_CAPACITY.name, "Carry Capacity", "")
        self._add_stat(derived_stats_layout, 3, 1, DerivedStatType.MOVEMENT.name, "Movement", "")
        self._add_stat(derived_stats_layout, 2, 1, DerivedStatType.DAMAGE_REDUCTION.name, "Damage Reduction", "") # Added DR

        # --- Add the group boxes to the main layout ---
        self.main_layout.addWidget(resources_group)
        self.main_layout.addWidget(combat_info_group) # Add the renamed group
        self.main_layout.addWidget(primary_stats_group)
        self.main_layout.addWidget(derived_stats_group)

    def _add_stat(self, layout, row, col, stat_id, stat_name, value):
            """Add a stat to the stats layout."""
            # Create label
            label = QLabel(f"{stat_name}:") # Use descriptive name for the row label
            label.setStyleSheet("color: #BBBBBB; font-weight: bold;")

            # Create value label - use the Enum Name (stat_id) as the key
            value_label = StatLabel(value, stat_id) # Pass Enum Name ("STR", "MELEE_ATTACK")
            # Ensure HTML (for colored deltas) is rendered
            try:
                value_label.setTextFormat(Qt.RichText)
            except Exception:
                pass
            # Set minimum width and restore original color
            value_label.setStyleSheet("color: #E0E0E0; min-width: 30px;")
            value_label.setAlignment(Qt.AlignRight)

            # Store the value label using the Enum Name as the key
            if stat_id in [s.name for s in StatType]:
                self.primary_stat_labels[stat_id] = value_label
            else:
                self.derived_stat_labels[stat_id] = value_label

            # Add to layout
            layout.addWidget(label, row, col * 2)
            layout.addWidget(value_label, row, col * 2 + 1)
    
    def _add_resource_bar(self, layout, name, value, max_value, color):
        """Add a resource bar to the layout."""
        # Create container
        container = QWidget()
        container_layout = QVBoxLayout(container)
        container_layout.setContentsMargins(0, 0, 0, 0)
        container_layout.setSpacing(2)
        
        # Create label
        label = QLabel(f"{name}: {value}/{max_value}")
        label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        
        # Create progress bar
        progress_bar = QProgressBar()
        progress_bar.setRange(0, max_value)
        progress_bar.setValue(value)
        progress_bar.setTextVisible(True)
        progress_bar.setFormat(f"%v/%m")
        progress_bar.setStyleSheet(f"""
            QProgressBar {{
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                color: white;
            }}
            QProgressBar::chunk {{
                background-color: {color};
                border-radius: 3px;
            }}
        """)
        
        # Add to container
        container_layout.addWidget(label)
        container_layout.addWidget(progress_bar)
        
        # Store the bar
        self.resource_bars[name.lower()] = (label, progress_bar)
        
        # Add to layout
        layout.addWidget(container)
    
    def _create_skills_section(self):
        """Create the character skills section."""
        # Group box for skills
        skills_group = QGroupBox("Skills")
        skills_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        skills_layout = QVBoxLayout(skills_group)
        
        # Create a label for when no skills are available
        self.no_skills_label = QLabel("No skills available yet.")
        self.no_skills_label.setStyleSheet("color: #888888; font-style: italic;")
        self.no_skills_label.setAlignment(Qt.AlignCenter)
        
        skills_layout.addWidget(self.no_skills_label)
        
        # Add skills to main layout
        self.main_layout.addWidget(skills_group)
    
    def _create_equipment_section(self):
        """Create the character equipment section using QGridLayout and self.equip_labels."""
        equipment_group = QGroupBox("Equipment")
        equipment_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        equipment_layout = QGridLayout(equipment_group)
        equipment_layout.setSpacing(5) 
        
        self.equip_labels: Dict[str, CharacterSheetWidget.EquippedItemLabel] = {} 
        slots_to_display = [
            EquipmentSlot.HEAD, EquipmentSlot.NECK,
            EquipmentSlot.CHEST, EquipmentSlot.BACK,
            EquipmentSlot.SHOULDERS, EquipmentSlot.WRISTS,
            EquipmentSlot.HANDS, EquipmentSlot.WAIST,
            EquipmentSlot.LEGS, EquipmentSlot.FEET,
            EquipmentSlot.MAIN_HAND, EquipmentSlot.OFF_HAND,
            EquipmentSlot.FINGER_1, EquipmentSlot.FINGER_2,
            EquipmentSlot.TRINKET_1, EquipmentSlot.TRINKET_2
        ]

        num_cols = 2 
        for i, slot_enum in enumerate(slots_to_display):
            row = i // num_cols
            col = i % num_cols
            
            slot_display_name = slot_enum.value.replace('_', ' ').title()
            
            slot_label_widget = QLabel(f"{slot_display_name}:")
            slot_label_widget.setStyleSheet("color: #BBBBBB; font-weight: bold; padding-right: 5px;")
            slot_label_widget.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
            
            # Use the new EquippedItemLabel
            value_label_widget = CharacterSheetWidget.EquippedItemLabel("None", slot_enum, None, self)
            value_label_widget.set_item_data("None", None) # Initial state
            value_label_widget.setMinimumWidth(120) 
            value_label_widget.setWordWrap(True)
            value_label_widget.context_menu_requested_for_slot.connect(self._handle_equipped_item_context_menu)
            
            self.equip_labels[slot_enum.value] = value_label_widget
            
            equipment_layout.addWidget(slot_label_widget, row, col * 2)     
            equipment_layout.addWidget(value_label_widget, row, col * 2 + 1) 
        
        self.main_layout.addWidget(equipment_group)

    def update_character(self, character=None):
            """
            Update the character sheet with character data.

            Args:
                character: The character data object (PlayerState). If None, uses current state.
            """
            if not self._signal_connected:
                self._connect_stats_signal()

            try:
                if character is None:
                    if self.state_manager and self.state_manager.current_state:
                        character = self.state_manager.current_state.player
                    else:
                        logger.warning("No character data available to update character sheet")
                        self._clear_stat_displays()
                        return

                self.name_label.setText(f"Name: {character.name}")
                self.race_class_label.setText(f"Race: {character.race} | Class: {character.path}")
                exp_current = character.experience
                exp_next = character.experience_to_next_level
                self.level_exp_label.setText(f"Level: {character.level} | Experience: {exp_current}/{exp_next}")
                self.exp_bar.setRange(0, exp_next if exp_next > 0 else 100) 
                self.exp_bar.setValue(exp_current)

                if self.state_manager and self.state_manager.stats_manager:
                    stats_manager = self.state_manager.stats_manager
                    all_stats = stats_manager.get_all_stats()

                    if 'primary' in all_stats:
                        self._update_primary_stats(all_stats["primary"])
                    else:
                        logger.warning("Primary stats category not found in stats data.")

                    for category in ["combat", "social", "other"]: 
                        if category in all_stats:
                            self._update_derived_stats(all_stats[category], category)
                        else:
                            logger.warning(f"Derived stats category '{category}' not found in stats data.")

                    if "resources" in all_stats:
                        self._update_resources(all_stats["resources"], all_player_stats=all_stats)
                    else:
                        logger.warning("Resources category not found in stats data.")
                    self._update_combat_status(character)
                else:
                    logger.warning("Stats manager not available during update_character, stats will not be displayed.")
                    self._clear_stat_displays()

                inventory_manager = get_inventory_manager()
                if inventory_manager:
                    for slot_key_str, label_widget in self.equip_labels.items():
                        # Reset with default text and no item_id
                        label_widget.set_item_data("None", None) 
                    
                    if hasattr(inventory_manager, 'equipment'):
                        two_handed_weapon_equipped: Optional[Item] = None
                        # inventory_manager.equipment is Dict[EquipmentSlot, Optional[Item]]
                        potential_two_handed_item_obj = inventory_manager.equipment.get(EquipmentSlot.TWO_HAND)
                        if potential_two_handed_item_obj and isinstance(potential_two_handed_item_obj, Item):
                             two_handed_weapon_equipped = potential_two_handed_item_obj

                        for slot_enum, item_obj_from_inv_mgr in inventory_manager.equipment.items():
                            slot_key = slot_enum.value 
                            if item_obj_from_inv_mgr and isinstance(item_obj_from_inv_mgr, Item) and slot_key in self.equip_labels:
                                current_label_widget = self.equip_labels[slot_key]
                                if two_handed_weapon_equipped and item_obj_from_inv_mgr.id == two_handed_weapon_equipped.id:
                                    if EquipmentSlot.MAIN_HAND.value in self.equip_labels:
                                        self.equip_labels[EquipmentSlot.MAIN_HAND.value].set_item_data(f"{item_obj_from_inv_mgr.name} (2H)", item_obj_from_inv_mgr.id)
                                        self.equip_labels[EquipmentSlot.MAIN_HAND.value].setToolTip(item_obj_from_inv_mgr.description or item_obj_from_inv_mgr.name)
                                    if EquipmentSlot.OFF_HAND.value in self.equip_labels:
                                        self.equip_labels[EquipmentSlot.OFF_HAND.value].set_item_data(f"- (2H: {item_obj_from_inv_mgr.name}) -", None) # No item_id for placeholder
                                        self.equip_labels[EquipmentSlot.OFF_HAND.value].setStyleSheet("color: #777777;")
                                        self.equip_labels[EquipmentSlot.OFF_HAND.value].setToolTip(f"Occupied by Two-Handed: {item_obj_from_inv_mgr.name}")
                                    if EquipmentSlot.TWO_HAND.value in self.equip_labels:
                                         self.equip_labels[EquipmentSlot.TWO_HAND.value].set_item_data(item_obj_from_inv_mgr.name, item_obj_from_inv_mgr.id)
                                         self.equip_labels[EquipmentSlot.TWO_HAND.value].setToolTip(item_obj_from_inv_mgr.description or item_obj_from_inv_mgr.name)
                                elif slot_enum == EquipmentSlot.MAIN_HAND and two_handed_weapon_equipped:
                                    continue 
                                elif slot_enum == EquipmentSlot.OFF_HAND and two_handed_weapon_equipped:
                                    continue
                                else: 
                                    current_label_widget.set_item_data(item_obj_from_inv_mgr.name, item_obj_from_inv_mgr.id)
                                    current_label_widget.setToolTip(item_obj_from_inv_mgr.description or item_obj_from_inv_mgr.name)
                else:
                    logger.warning("CharacterSheetWidget: InventoryManager not available for equipment update.")

                if hasattr(character, 'character_image') and character.character_image:
                    try:
                        pixmap = QPixmap(character.character_image)
                        if not pixmap.isNull():
                            scaled_pixmap = pixmap.scaled(self.portrait_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                            self.portrait_label.setPixmap(scaled_pixmap)
                            self.portrait_label.setStyleSheet("")
                        else:
                            self.portrait_label.setText("Portrait")
                            self.portrait_label.setStyleSheet("color: #888888;")
                    except Exception as image_err:
                        logging.error(f"Error loading character portrait: {image_err}")
                        self.portrait_label.setText("Portrait")
                        self.portrait_label.setStyleSheet("color: #888888;")
                else:
                    self.portrait_label.setText("Portrait")
                    self.portrait_label.setStyleSheet("color: #888888;")

            except Exception as e:
                logger.error(f"Error updating character sheet: {e}", exc_info=True)

    def _update_combat_status(self, character):
        """Update combat status information.
        This method is now less critical for turn order if TURN_ORDER_UPDATE events are used,
        but kept for fallback and status effects.
        Args:
            character: The player character instance.
        """
        if not character:
            return
            
        from core.base.state import get_state_manager # Local import
        state_manager = get_state_manager()
        if not state_manager or not state_manager.current_state:
            self.status_effects_list.clear()
            self.turn_order_list.setText("Turn Order: N/A") # Default text
            self.initiative_value.setText("0")
            return
            
        game_state = state_manager.current_state
        combat_manager = getattr(game_state, 'combat_manager', None)
        
        # Update status effects (Logic for status effects seems okay, no changes here unless explicitly requested)
        self.status_effects_list.clear()
        status_text = ""
        player_entity_for_effects = None

        if combat_manager:
            player_id_for_lookup = getattr(character, 'id', None) or getattr(character, 'stats_manager_id', None)
            if player_id_for_lookup and player_id_for_lookup in combat_manager.entities:
                player_entity_for_effects = combat_manager.entities[player_id_for_lookup]
        
        source_for_effects = player_entity_for_effects if player_entity_for_effects else character

        if hasattr(source_for_effects, 'status_effects'):
            effects_data = source_for_effects.status_effects
            if isinstance(effects_data, dict):
                for effect_name, duration_data in effects_data.items():
                    duration = None
                    if isinstance(duration_data, int): 
                        duration = duration_data
                    
                    if duration is not None and duration > 0 : 
                        status_text += f"{effect_name} ({duration} turns)\n"
                    elif duration is None: 
                        status_text += f"{effect_name}\n"
            elif isinstance(effects_data, (list, set)):
                for effect_name in effects_data:
                    status_text += f"{effect_name}\n"
        
        self.status_effects_list.setText(status_text.strip())
        
        # Turn order display will be primarily handled by handle_turn_order_update event.
        # This section can act as a fallback or for initial display if no event received yet.
        if not combat_manager:
            self.turn_order_list.setText("Turn Order: N/A (Not in Combat)")
            self.initiative_value.setText("0")
        elif not hasattr(self, '_last_turn_order_event_data') or not self._last_turn_order_event_data:
            # Fallback logic if no TURN_ORDER_UPDATE event has populated the display yet
            logger.debug("CharacterSheet: _update_combat_status using fallback for turn order.")
            turn_text = ""
            if getattr(combat_manager, '_is_surprise_round', False) and hasattr(combat_manager, '_surprise_round_entities') and combat_manager._surprise_round_entities:
                turn_text += "[Surprise Round]\n"
                current_actor_id_for_highlight = getattr(combat_manager, '_active_entity_id', None)
                for entity_id_in_surprise_order in combat_manager._surprise_round_entities:
                    if entity_id_in_surprise_order in combat_manager.entities:
                        entity = combat_manager.entities[entity_id_in_surprise_order]
                        prefix = "→ " if entity_id_in_surprise_order == current_actor_id_for_highlight else "  "
                        turn_text += f"{prefix}{getattr(entity, 'combat_name', entity.name)}\n"
            elif hasattr(combat_manager, 'turn_order') and combat_manager.turn_order: # Regular round
                current_turn_idx = getattr(combat_manager, 'current_turn_index', 0)
                for i, entity_id_in_order in enumerate(combat_manager.turn_order):
                    if entity_id_in_order in combat_manager.entities:
                        entity = combat_manager.entities[entity_id_in_order]
                        is_current_actor_by_index = (i == current_turn_idx)
                        prefix = "→ " if is_current_actor_by_index else "  "
                        turn_text += f"{prefix}{getattr(entity, 'combat_name', entity.name)}\n"
            else:
                turn_text = "Turn Order: Initializing..."
            self.turn_order_list.setText(turn_text.strip())

            player_id_for_initiative = getattr(character, 'id', None) or getattr(character, 'stats_manager_id', None)
            entity_for_initiative_display = combat_manager.entities.get(player_id_for_initiative)
            if entity_for_initiative_display and hasattr(entity_for_initiative_display, 'initiative'):
                initiative_value = getattr(entity_for_initiative_display, 'initiative', 0)
                self.initiative_value.setText(str(int(initiative_value)))
            else:
                self.initiative_value.setText("N/A")

    def _connect_stats_signal(self):
        """Connect to the stats_changed signal of the StatsManager."""
        if self._signal_connected:
            logging.debug("Signal already connected, skipping.")
            return

        try:
            if self.state_manager and self.state_manager.stats_manager:
                stats_manager = self.state_manager.stats_manager
                signal_exists = hasattr(stats_manager, 'stats_changed')

                if signal_exists:
                    try:
                        # Disconnect first to avoid duplicates if connection attempt repeats
                        stats_manager.stats_changed.disconnect(self._update_from_stats)
                    except (TypeError, RuntimeError): # Catch specific Qt signal errors
                        pass # Ignore if not connected

                    stats_manager.stats_changed.connect(self._update_from_stats)
                    self._signal_connected = True
                    logging.info("Connected CharacterSheetWidget to stats_changed signal")
            else:
                 logging.debug("StatsManager not yet available for signal connection.")

        except Exception as e:
            logging.error(f"Failed to connect to stats_changed signal: {e}")
    
    def _update_from_stats(self, stats_data):
        """Update the character sheet directly from stats data provided by the signal."""
        logging.info("Updating character sheet from stats_changed signal")

        try:
            # Provide detailed logging about the stats data received
            if isinstance(stats_data, dict):
                category_counts = {k: len(v) for k, v in stats_data.items() if isinstance(v, dict)}
                logging.info(f"Stats data categories from signal: {category_counts}")
                # ...(rest of logging as before)...

                # Check for empty or invalid stats before proceeding
                has_valid_stats = any(
                    category in stats_data and isinstance(stats_data[category], dict) and stats_data[category]
                    for category in ['primary', 'resources', 'combat', 'social', 'other']
                )

                if not has_valid_stats:
                    logging.warning("Stats data from signal appears empty or invalid.")
                    # Optionally, could trigger a full update here, but might cause loops
                    # self.update_character()
                    return

                # Update primary stats
                if 'primary' in stats_data:
                    self._update_primary_stats(stats_data['primary'])
                    logging.info(f"Updated {len(stats_data['primary'])} primary stats from signal")

                # Update derived stats including combat, social, other
                for category in ['combat', 'social', 'other']:
                    if category in stats_data:
                        self._update_derived_stats(stats_data[category], category)
                        logging.info(f"Updated {len(stats_data[category])} {category} stats from signal")

                # Update resource bars (HP, Mana, Stamina)
                if 'resources' in stats_data:
                    # Pass the full stats_data (which is all_stats) to _update_resources
                    self._update_resources(stats_data['resources'], all_player_stats=stats_data)
                    logging.info(f"Updated {len(stats_data['resources'])} resources from signal")
                
                # Update combat status (turn order, status effects) if player data is available
                if self.state_manager and self.state_manager.current_state and self.state_manager.current_state.player:
                    self._update_combat_status(self.state_manager.current_state.player)
                    logging.info("Updated combat status from stats_changed signal context.")
                else:
                    logging.warning("Could not update combat status from signal: player state unavailable.")


                logging.info("Character sheet updated directly from stats data via signal")
            else:
                # Fallback to full update if data format isn't as expected (less likely now)
                logging.warning(f"Stats data from signal is not a dict: {type(stats_data)}, falling back to full update")
                self.update_character() # Trigger full refresh as fallback

        except Exception as e:
            logging.error(f"Error updating from stats signal: {e}", exc_info=True)
            # Fallback to full update on error
            try:
                self.update_character()
            except Exception as update_err:
                logging.error(f"Fallback update after signal error also failed: {update_err}")
                
    def _update_primary_stats(self, primary_stats):
        """Update just the primary stats from stats data, showing colored deltas."""
        for stat_name, stat_data in primary_stats.items():
            # stat_name here is expected to be "STR", "DEX", etc.
            if stat_name in self.primary_stat_labels:
                try:
                    value = int(stat_data.get('value', 0))
                    base = int(stat_data.get('base_value', value))
                    delta = value - base
                    delta_sign = "+" if delta > 0 else ""
                    delta_color = "#69c45f" if delta > 0 else ("#c45f5f" if delta < 0 else "#E0E0E0")

                    # Compose HTML with colored delta
                    new_text = f"{value}"
                    if delta != 0:
                        new_text += f" <span style='color:{delta_color}'>({delta_sign}{delta})</span>"

                    old_text = self.primary_stat_labels[stat_name].text()
                    if old_text != new_text:
                        self.primary_stat_labels[stat_name].setText(new_text)
                        logging.info(f"Updated primary stat {stat_name} from '{old_text}' to '{new_text}'")

                    # Update tooltip data regardless
                    self.primary_stat_labels[stat_name].update_stat_data(stat_data)
                except Exception as e:
                    logging.error(f"Error updating primary stat {stat_name}: {e}", exc_info=True)
            else:
                logging.warning(f"Stat key '{stat_name}' from primary stats data not found in UI labels.")
    
    def _update_derived_stats(self, derived_stats, category):
        """Update derived stats from stats data, showing colored deltas."""
        for stat_name, stat_data in derived_stats.items():
            # stat_name here is expected to be "MELEE_ATTACK", "DEFENSE", etc.
            if stat_name in self.derived_stat_labels:
                try:
                    value = int(stat_data.get('value', 0))
                    base = int(stat_data.get('base_value', value))
                    delta = value - base
                    delta_sign = "+" if delta > 0 else ""
                    delta_color = "#69c45f" if delta > 0 else ("#c45f5f" if delta < 0 else "#E0E0E0")

                    new_text = f"{value}"
                    if delta != 0:
                        new_text += f" <span style='color:{delta_color}'>({delta_sign}{delta})</span>"

                    old_text = self.derived_stat_labels[stat_name].text()
                    if old_text != new_text:
                        self.derived_stat_labels[stat_name].setText(new_text)
                        logging.info(f"Updated {category} stat {stat_name} from '{old_text}' to '{new_text}'")

                    # Update tooltip data regardless
                    self.derived_stat_labels[stat_name].update_stat_data(stat_data)

                    # Special case for initiative display
                    if stat_name == "INITIATIVE":
                        if self.initiative_value.text() != str(value):
                            self.initiative_value.setText(str(value))
                            logging.info(f"Updated initiative display to {value}")
                except Exception as e:
                    logging.error(f"Error updating derived stat {stat_name}: {e}", exc_info=True)
            else:
                logging.warning(f"Stat key '{stat_name}' from {category} stats data not found in UI labels.")
    
    def _update_resources(self, resources: Dict[str, Any], all_player_stats: Optional[Dict[str, Any]] = None):
        """
        Update resource bars. During COMBAT, current values for HP, Mana, Stamina are primarily
        updated via orchestrated events (player_resource_bar_update_phaseX). This method will
        still update MAX values and, outside of combat, current values directly.
        """
        resource_key_map = {
            "HEALTH": "health", "MANA": "mana", "STAMINA": "stamina",
            "RESOLVE": "resolve" 
        }
        max_resource_map = {
            "HEALTH": "MAX_HEALTH", "MANA": "MAX_MANA", 
            "STAMINA": "MAX_STAMINA", "RESOLVE": "MAX_RESOLVE" 
        }

        for stat_name_key, resource_data in resources.items():
            ui_key = resource_key_map.get(stat_name_key.upper()) 

            if ui_key and ui_key in self.resource_bars:
                label, bar = self.resource_bars[ui_key]
                
                game_mode = InteractionMode.NARRATIVE # Default
                if self.state_manager and self.state_manager.current_state:
                    game_mode = self.state_manager.current_state.current_mode
                
                try:
                    current_value_from_model = int(resource_data.get('value', 0)) # Actual current value from stats model
                    max_stat_name_key = max_resource_map.get(stat_name_key.upper())
                    
                    # Determine Max Value (this should always reflect the true current max)
                    max_value_from_model = bar.maximum() if bar.maximum() > 0 else 100 
                    if all_player_stats and max_stat_name_key:
                        found_max_in_all_stats = False
                        for category_key in ['resources', 'other', 'primary', 'combat', 'social']: 
                            if category_key in all_player_stats and max_stat_name_key in all_player_stats[category_key]:
                                max_value_from_model = int(all_player_stats[category_key][max_stat_name_key].get('value', max_value_from_model))
                                found_max_in_all_stats = True
                                break
                        if not found_max_in_all_stats:
                           logger.warning(f"MAX stat {max_stat_name_key} not found in all_player_stats for {stat_name_key} in _update_resources. Using bar's current max.")
                    elif 'base_value' in resource_data and stat_name_key.upper().startswith("MAX_"): 
                         max_value_from_model = int(resource_data.get('base_value', max_value_from_model))
                    
                    max_value_from_model = max(1, max_value_from_model) 
                    display_name = resource_data.get("name", ui_key.capitalize()) 

                    # Always update the bar's range if the max value from model has changed
                    if bar.maximum() != max_value_from_model:
                        bar.setRange(0, max_value_from_model)
                        logger.info(f"CharacterSheet: {ui_key} bar max updated to {max_value_from_model} via _update_resources (model changed).")
                        # If max changed, the label will need updating too, unless an animation is active
                        if not (game_mode == InteractionMode.COMBAT and ui_key in self._pending_player_bar_updates):
                            current_display_val = bar.value() if game_mode == InteractionMode.COMBAT and ui_key in self._pending_player_bar_updates and self._pending_player_bar_updates[ui_key].get('phase1_preview_value') is not None else current_value_from_model
                            label.setText(f"{display_name}: {int(current_display_val)}/{max_value_from_model}")


                    # Handle current value updates
                    if game_mode == InteractionMode.COMBAT:
                        # In COMBAT, current value updates for HP, Mana, Stamina are driven by phase1/phase2 events.
                        # This method, when called by stats_changed, should not directly set the current value
                        # for these, to avoid conflicts with the animation.
                        # It only ensures MAX is correct. Resolve, if not animated, could be updated here.
                        if ui_key == "resolve": # Example: Resolve updates directly if not animated
                             if bar.value() != current_value_from_model: bar.setValue(current_value_from_model)
                             label.setText(f"{display_name}: {current_value_from_model}/{max_value_from_model}")
                        else:
                             logger.debug(f"CharacterSheet: In COMBAT, _update_resources deferring current value update for {ui_key} to orchestration.")
                             # If a phase1 animation is active, the label might show "X -> Y".
                             # If max_value changed, it's already updated above.
                             # If no animation is active, the label might be stale until phase1/2.
                             # Let's ensure label reflects at least the old value against new max if max changed.
                             if bar.maximum() == max_value_from_model and ui_key not in self._pending_player_bar_updates:
                                  current_on_bar = bar.value() # What the bar visually shows
                                  if label.text() != f"{display_name}: {int(current_on_bar)}/{max_value_from_model}":
                                       label.setText(f"{display_name}: {int(current_on_bar)}/{max_value_from_model}")


                    else: # Not in COMBAT mode, update directly
                        if bar.value() != current_value_from_model:
                            bar.setValue(current_value_from_model)
                        
                        new_text_direct = f"{display_name}: {current_value_from_model}/{max_value_from_model}"
                        if label.text() != new_text_direct:
                            label.setText(new_text_direct)
                        
                        # If there was any pending animation from a previous mode (unlikely but possible), clear it.
                        if ui_key in self._pending_player_bar_updates:
                            self._pending_player_bar_updates.pop(ui_key, None)
                        
                        logger.debug(f"CharacterSheet: Directly updated {ui_key} to {current_value_from_model}/{max_value_from_model} via _update_resources (not in combat).")
                    
                except Exception as e:
                    logging.error(f"CharacterSheet: Error updating resource bar for {stat_name_key} in _update_resources: {e}", exc_info=True)
            elif ui_key:
                logging.warning(f"UI key '{ui_key}' (from resource '{stat_name_key}') not found in self.resource_bars.")

    def _clear_stat_displays(self):
        """Helper method to reset all stat displays to default/empty."""
        logging.debug("Clearing character sheet stat displays.")
        # Clear primary stats
        for label in self.primary_stat_labels.values():
            label.setText("0") # Or "?" or ""
            label.update_stat_data({}) # Clear tooltip data

        # Clear derived stats
        for label in self.derived_stat_labels.values():
            label.setText("0") # Or "?" or ""
            label.update_stat_data({}) # Clear tooltip data

        # Clear resource bars
        for label, bar in self.resource_bars.values():
            label.setText(f"{label.text().split(':')[0]}: 0/0") # Keep name, reset values
            bar.setRange(0, 100) # Reset range
            bar.setValue(0) # Reset value

        # Clear initiative display
        self.initiative_value.setText("0")

        # Clear combat status
        self.status_effects_list.clear()
        self.turn_order_list.clear()
    
    def showEvent(self, event):
        """Handler called when widget is shown."""
        super().showEvent(event)

    @Slot(str, dict)
    def animate_resource_bar_ui_bar_update_phase1(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a bar update: show impending loss/gain.
        bar_type_key: "hp", "stamina", "mana", "resolve"
        update_data: { "old_value": X, "new_value_preview": Y, "max_value": M }
        """
        bar_type_key_internal = bar_type_key
        if bar_type_key == "hp": # Normalize "hp" to "health" for internal lookup
            bar_type_key_internal = "health"
        
        if bar_type_key_internal not in self.resource_bars:
            logging.warning(f"CharacterSheet: Bar type '{bar_type_key_internal}' (from original key '{bar_type_key}') not found for phase 1 animation.")
            return

        label, bar = self.resource_bars[bar_type_key_internal]
        new_value_preview = update_data.get("new_value_preview")
        max_value = update_data.get("max_value")
        
        if new_value_preview is None or max_value is None:
            logging.error(f"CharacterSheet: Missing new_value_preview or max_value for phase 1 of {bar_type_key_internal}")
            return
            
        is_loss = new_value_preview < bar.value()

        logging.debug(f"CharacterSheet: Phase 1 Anim for {bar_type_key_internal} - Preview: {new_value_preview}/{max_value}")

        display_name = label.text().split(':')[0] 
        label.setText(f"{display_name}: {bar.value()}/{max_value} -> {new_value_preview}/{max_value}")
        
        self._pending_bar_updates[bar_type_key_internal] = {
            "final_value": new_value_preview,
            "max_value": max_value,
            "is_loss": is_loss
        }

    @Slot(str, dict)
    def animate_resource_bar_ui_bar_update_phase2(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a bar update: finalize the bar to its new value.
        bar_type_key: "hp", "stamina", "mana", "resolve"
        update_data: { "final_new_value": Y, "max_value": M } (or use stored from pending)
        """
        bar_type_key_internal = bar_type_key
        if bar_type_key == "hp": # Normalize "hp" to "health" for internal lookup
            bar_type_key_internal = "health"

        if bar_type_key_internal not in self.resource_bars:
            logging.warning(f"CharacterSheet: Bar type '{bar_type_key_internal}' (from original key '{bar_type_key}') not found for phase 2 animation.")
            return
        
        pending_data = self._pending_bar_updates.pop(bar_type_key_internal, None)
        final_value = update_data.get("final_new_value", pending_data.get("final_value") if pending_data else None)
        max_value = update_data.get("max_value", pending_data.get("max_value") if pending_data else None)

        if final_value is None or max_value is None:
            # Attempt to get current value from bar if update_data is incomplete and no pending_data
            label_fallback, bar_fallback = self.resource_bars[bar_type_key_internal]
            final_value_fb = bar_fallback.value()
            max_value_fb = bar_fallback.maximum()

            if final_value is None: final_value = final_value_fb
            if max_value is None: max_value = max_value_fb
            
            logging.warning(f"CharacterSheet: Missing final_value or max_value for phase 2 of {bar_type_key_internal}. Using current/fallback: {final_value}/{max_value}")
            # Do not return; attempt to update with best available info.

        logging.debug(f"CharacterSheet: Phase 2 Anim for {bar_type_key_internal} - Final: {final_value}/{max_value}")

        label, bar = self.resource_bars[bar_type_key_internal]
        # Try to get original name part, handle cases where "->" might not be present
        original_name_part_match = re.match(r"([^:]+):", label.text())
        display_name = original_name_part_match.group(1).strip() if original_name_part_match else bar_type_key_internal.capitalize()


        label.setText(f"{display_name}: {int(final_value)}/{int(max_value)}")
        if bar.maximum() != int(max_value):
            bar.setRange(0, int(max_value))
        bar.setValue(int(final_value))

        logging.debug(f"CharacterSheet: {bar_type_key_internal} bar finalized to {int(final_value)}/{int(max_value)}")

    def _finalize_bar_animation(self, bar_type_key: str):
        """Helper to finalize a bar after a QTimer, if used internally (less common now)."""
        # This method is less likely to be used if Orchestrator handles delays.
        # Kept for potential future internal animation needs.
        if bar_type_key in self._pending_bar_updates:
            data = self._pending_bar_updates.pop(bar_type_key)
            self.animate_resource_bar_ui_bar_update_phase2(bar_type_key, {"final_new_value": data["final_value"], "max_value": data["max_value"]})

    @Slot(dict)
    def handle_turn_order_update(self, event_data: Dict[str, Any]):
        """
        Handles TURN_ORDER_UPDATE events from the orchestrator to update
        the turn order display and player initiative.
        """
        logger.info(f"CharacterSheet received TURN_ORDER_UPDATE: {event_data}")
        self._last_turn_order_event_data = event_data # Store for fallback if needed

        turn_text = ""
        is_surprise = event_data.get("is_surprise", False)
        round_num = event_data.get("round_number", "")
        turn_order_display_list = event_data.get("turn_order_display_list", []) # This should contain pre-formatted strings with "→"
        active_entity_name = event_data.get("active_entity_combat_name", "") # For initiative context

        if is_surprise:
            turn_text += f"[Surprise Round]\n"
        elif round_num:
            turn_text += f"Round {round_num}\n"
        
        if turn_order_display_list:
            turn_text += "\n".join(turn_order_display_list)
        else:
            turn_text += "Turn order not yet determined."

        self.turn_order_list.setText(turn_text.strip())

        # Update player's initiative display
        # If player is in the turn_order_display_list, try to extract their initiative
        # This assumes player's combat name is consistent
        player_id = getattr(self.state_manager.current_state.player, 'id', None) or getattr(self.state_manager.current_state.player, 'stats_manager_id', None)
        player_combat_name = getattr(self.state_manager.current_state.player, 'name', "Player") # Fallback
        
        # Get CombatManager to access player's CombatEntity for initiative
        combat_manager = getattr(self.state_manager.current_state, 'combat_manager', None)
        if combat_manager and player_id:
            player_combat_entity = combat_manager.entities.get(player_id)
            if player_combat_entity and hasattr(player_combat_entity, 'initiative'):
                self.initiative_value.setText(str(int(player_combat_entity.initiative)))
            else:
                self.initiative_value.setText("N/A")
        elif combat_manager: # Player ID not found, but CM exists
             self.initiative_value.setText("N/A (Player not in combat)")
        else: # Not in combat
            self.initiative_value.setText("0")

    @Slot(str, dict)
    def player_resource_bar_update_phase1(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a player's resource bar update: show impending loss/gain in label.
        bar_type_key: "hp", "stamina", "mana", "resolve" (from event metadata)
        update_data: { "old_value": X, "new_value_preview": Y, "max_value": M, "entity_id": player_id }
        """
        logger.debug(f"CharacterSheet: Player Phase 1 Anim for event bar_type '{bar_type_key}' - Data: {update_data}")
        
        event_to_internal_key_map = {"hp": "health", "mp": "mana", "stamina": "stamina", "resolve": "resolve"}
        internal_ui_key = event_to_internal_key_map.get(bar_type_key.lower(), bar_type_key.lower())

        if internal_ui_key not in self.resource_bars:
            logging.warning(f"CharacterSheet: Player bar type '{internal_ui_key}' (mapped from event '{bar_type_key}') not found for phase 1 animation.")
            return

        label, bar = self.resource_bars[internal_ui_key]
        
        new_value_preview = update_data.get("new_value_preview")
        max_value = update_data.get("max_value")
        
        if new_value_preview is None or max_value is None:
            logging.error(f"CharacterSheet: Missing new_value_preview or max_value for player phase 1 of {internal_ui_key}")
            return
        
        current_bar_visual_value = bar.value() 
        
        display_name_match = re.match(r"([^:]+):", label.text())
        display_name = display_name_match.group(1).strip() if display_name_match else internal_ui_key.capitalize()
        
        label.setText(f"{display_name}: {int(current_bar_visual_value)}/{int(max_value)} -> {int(new_value_preview)}/{int(max_value)}")
        
        if bar.maximum() != int(max_value):
            bar.setRange(0, int(max_value))
            logger.info(f"CharacterSheet (Phase1): {internal_ui_key} bar max updated to {max_value}")

        self._pending_player_bar_updates[internal_ui_key] = {
            "final_value": new_value_preview, 
            "max_value": max_value,
            "phase1_preview_value": current_bar_visual_value 
        }

        # Signal orchestrator completion to avoid stalls when no CombatEntityWidget animation handles it
        try:
            from core.base.engine import get_game_engine
            from PySide6.QtCore import QTimer
            eng = get_game_engine()
            if eng and hasattr(eng, "_combat_orchestrator"):
                logger.debug("CharacterSheet: Signaling orchestrator visual completion for Phase 1 player bar update")
                QTimer.singleShot(0, eng._combat_orchestrator._handle_visual_display_complete)
        except Exception:
            pass

    @Slot(str, dict)
    def player_resource_bar_update_phase2(self, bar_type_key: str, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a player's resource bar update: finalize the bar to its new value.
        bar_type_key: "hp", "stamina", "mana", "resolve" (from event metadata)
        update_data: { "final_new_value": Y, "max_value": M, "entity_id": player_id }
        """
        event_to_internal_key_map = {"hp": "health", "mp": "mana", "stamina": "stamina", "resolve": "resolve"}
        internal_ui_key = event_to_internal_key_map.get(bar_type_key.lower(), bar_type_key.lower())

        logger.debug(f"CharacterSheet: Player Phase 2 Anim for internal_ui_key '{internal_ui_key}' (from event '{bar_type_key}') - Data: {update_data}")

        if internal_ui_key not in self.resource_bars:
            logging.warning(f"CharacterSheet: Player bar type '{internal_ui_key}' (mapped from event '{bar_type_key}') not found for phase 2 animation.")
            if internal_ui_key in self._pending_player_bar_updates:
                self._pending_player_bar_updates.pop(internal_ui_key, None)
            return
        
        pending_data = self._pending_player_bar_updates.pop(internal_ui_key, None)
        
        label, bar = self.resource_bars[internal_ui_key]

        final_value = update_data.get("final_new_value")
        max_val = update_data.get("max_value")

        if final_value is None:
            if pending_data and "final_value" in pending_data:
                final_value = pending_data["final_value"]
            else: 
                final_value = bar.value() 
                logger.warning(f"CharacterSheet (Phase2): for {internal_ui_key} missing final_new_value. Using current bar value {final_value}.")
        
        if max_val is None:
            if pending_data and "max_value" in pending_data:
                max_val = pending_data["max_value"]
            else: 
                max_val = bar.maximum()
                logger.warning(f"CharacterSheet (Phase2): for {internal_ui_key} missing max_value. Using current bar max {max_val}.")
        
        final_value = int(final_value)
        max_val = int(max_val)
        max_val = max(1, max_val)

        current_label_text = label.text()
        display_name_match = re.match(r"([^:]+):", current_label_text)
        display_name = display_name_match.group(1).strip() if display_name_match else internal_ui_key.capitalize()

        label.setText(f"{display_name}: {final_value}/{max_val}")
        if bar.maximum() != max_val: 
            bar.setRange(0, max_val)
        bar.setValue(final_value)

        logger.debug(f"CharacterSheet: Player {internal_ui_key} bar finalized to {final_value}/{max_val}")
        logging.info(f"CharacterSheet (Phase2 player): set {internal_ui_key} to {final_value}/{max_val}")

        # Signal orchestrator completion to avoid stalls when CharacterSheet handles the update without a CombatEntityWidget animation
        try:
            from core.base.engine import get_game_engine
            from PySide6.QtCore import QTimer
            eng = get_game_engine()
            if eng and hasattr(eng, "_combat_orchestrator"):
                logger.debug("CharacterSheet: Signaling orchestrator visual completion for Phase 2 player bar update")
                QTimer.singleShot(0, eng._combat_orchestrator._handle_visual_display_complete)
        except Exception:
            pass

    @Slot(QPoint, EquipmentSlot, str)
    def _handle_equipped_item_context_menu(self, global_pos: QPoint, slot: EquipmentSlot, item_id: str):
        inventory_manager = get_inventory_manager()
        item_obj = inventory_manager.get_item(item_id)
        if not item_obj:
            logger.error(f"[CHAR_SHEET_CTX] Item ID {item_id} not found for context menu in slot {slot.value}.")
            return

        logger.info(f"[CHAR_SHEET_CTX] Context menu for equipped item: '{item_obj.name}' in slot {slot.value}")

        context_menu = QMenu(self)
        # Apply styling similar to InventoryPanelWidget's context menu
        context_menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30; /* Dark background */
                color: #E0E0E0; /* Light text */
                border: 1px solid #555555; /* Subtle border */
                padding: 2px; /* Padding around all items */
            }
            QMenu::item {
                padding: 5px 20px 5px 20px; /* Top, Right, Bottom, Left padding */
                border: 1px solid transparent; /* Spacing between items */
            }
            QMenu::item:selected {
                background-color: #0E639C; /* Selection color */
                color: #FFFFFF;
            }
            QMenu::separator {
                height: 1px;
                background: #555555;
                margin-left: 10px;
                margin-right: 5px;
            }
        """)

        unequip_action = context_menu.addAction(f"Unequip {item_obj.name}")
        info_action = context_menu.addAction("Item Information")
        drop_action = context_menu.addAction(f"Drop {item_obj.name}")
        
        action = context_menu.exec_(global_pos)

        if action == unequip_action:
            self.item_unequip_from_slot_requested.emit(slot)
        elif action == info_action:
            self.item_examine_requested.emit(item_id)
        elif action == drop_action:
            self.item_drop_from_slot_requested.emit(slot, item_id)
            
    class EquippedItemLabel(QLabel):
        context_menu_requested_for_slot = Signal(QPoint, EquipmentSlot, str) # Global pos, slot, item_id

        def __init__(self, text: str, slot: EquipmentSlot, item_id: Optional[str] = None, parent: Optional[QWidget] = None):
            super().__init__(text, parent)
            self.slot = slot
            self.item_id = item_id
            self.setContextMenuPolicy(Qt.CustomContextMenu)
            self.customContextMenuRequested.connect(self.show_context_menu_slot)

        def set_item_data(self, text: str, item_id: Optional[str]):
            self.setText(text)
            self.item_id = item_id
            if item_id:
                self.setCursor(Qt.PointingHandCursor)
                self.setStyleSheet("color: #E0E0E0;") # Normal color for equipped item
            else:
                self.setCursor(Qt.ArrowCursor)
                self.setStyleSheet("color: #888888; font-style: italic;") # Dim for "None"

        def show_context_menu_slot(self, position: QPoint):
            if self.item_id: # Only show menu if an item is equipped
                self.context_menu_requested_for_slot.emit(self.mapToGlobal(position), self.slot, self.item_id)
        
        # Optional: Make left-click also trigger "Item Information" if desired
        # def mousePressEvent(self, event: QMouseEvent) -> None:
        #     if event.button() == Qt.LeftButton and self.item_id:
        #         # Potentially emit a signal for MainWindow to show ItemInfoDialog
        #         # For now, focusing on context menu for actions.
        #         pass
        #     super().mousePressEvent(event)
```

### File: gui\components\combat_display.py

```python
#!/usr/bin/env python3
"""
Combat display component for the RPG game.

This module provides a GUI component for displaying combat status and log,
with customizable appearance settings.
"""

import json
import logging
import os
import re # Added for stylesheet manipulation
from typing import Dict, Iterator, List, Any, Optional, Callable, Tuple
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit,
    QGroupBox, QProgressBar, QScrollArea, QFrame, QSizePolicy, QPushButton,
    QDialog # Added for placeholder dialog
)
from PySide6.QtCore import QSettings, Signal, Slot, QTimer
from PySide6.QtGui import QColor, QTextCharFormat, QFont, QTextCursor, QFontDatabase

from core.base.engine import get_game_engine
from core.interaction.enums import InteractionMode # Added QFontDatabase
from ..dialogs.combat_settings_dialog import CombatSettingsDialog

# Assuming core is in the parent directory of gui
# Adjust if your project structure is different
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))

# Configuration Constants - Adjusted paths based on project structure
CONFIG_DIR = os.path.join(project_root, "config")
SETTINGS_FILE = os.path.join(CONFIG_DIR, "combat_display_settings.json")
IMAGE_DIR = os.path.join(project_root, "images", "gui", "combat_display") # Path to background images

# Ensure directories exist
os.makedirs(CONFIG_DIR, exist_ok=True)
os.makedirs(IMAGE_DIR, exist_ok=True) # Create image dir if it doesn't exist

# Import after defining project_root if necessary for other modules
from core.utils.logging_config import get_logger
from core.combat.enums import CombatState
from core.combat.combat_entity import EntityType
from core.stats.stats_base import DerivedStatType
from core.base.state import GameState
from core.stats.stats_manager import get_stats_manager

# Get the module logger
logger = get_logger("GUI")

class CombatEntityWidget(QWidget):
    """Widget for displaying a combat entity status."""

    def __init__(self, entity_id: str, name: str, settings: dict, is_player: bool = False, parent=None):
        """Initialize the combat entity widget."""
        super().__init__(parent)

        self.entity_id = entity_id
        self.is_player = is_player
        self.settings = settings

        self._bar_animation_timer = QTimer(self)
        self._bar_animation_timer.setSingleShot(True)
        self._bar_animation_timer.timeout.connect(self._finalize_bar_update)
        self._pending_bar_update_data: Optional[Dict[str, Any]] = None


        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(2)

        self.name_label = QLabel(name)
        layout.addWidget(self.name_label)

        # HP Bar
        self.hp_widget_container = QWidget() # Container for HP bar and label
        hp_layout = QHBoxLayout(self.hp_widget_container)
        hp_layout.setContentsMargins(0, 0, 0, 0); hp_layout.setSpacing(5)
        self.hp_bar = QProgressBar()
        self.hp_bar.setRange(0, 100); self.hp_bar.setValue(100) 
        self.hp_bar.setTextVisible(True); self.hp_bar.setFormat("%v / %m")
        self.hp_label = QLabel("HP:")
        hp_layout.addWidget(self.hp_label); hp_layout.addWidget(self.hp_bar)
        layout.addWidget(self.hp_widget_container) # Add container to main layout

        # Stamina Bar
        self.stamina_widget_container = QWidget() # Container for stamina bar and label
        stamina_layout = QHBoxLayout(self.stamina_widget_container)
        stamina_layout.setContentsMargins(0, 0, 0, 0); stamina_layout.setSpacing(5)
        self.stamina_bar = QProgressBar() 
        self.stamina_bar.setRange(0, 100); self.stamina_bar.setValue(100) 
        self.stamina_bar.setTextVisible(True); self.stamina_bar.setFormat("%v / %m")
        self.stamina_label = QLabel("Stamina:") 
        stamina_layout.addWidget(self.stamina_label); stamina_layout.addWidget(self.stamina_bar)
        layout.addWidget(self.stamina_widget_container) # Add container to main layout

        # Mana Bar 
        self.mana_widget_container = QWidget() # Container for mana bar and label
        mana_layout = QHBoxLayout(self.mana_widget_container) 
        mana_layout.setContentsMargins(0, 0, 0, 0); mana_layout.setSpacing(5)
        self.mana_bar = QProgressBar()
        self.mana_bar.setRange(0, 1); self.mana_bar.setValue(0) # Default to 0/1
        self.mana_bar.setTextVisible(True); self.mana_bar.setFormat("%v / %m")
        self.mana_label = QLabel("Mana:")
        mana_layout.addWidget(self.mana_label); mana_layout.addWidget(self.mana_bar)
        layout.addWidget(self.mana_widget_container) # Add container to main layout

        # Status Effects
        self.status_widget_container = QWidget() # Container for status label and text
        status_layout = QHBoxLayout(self.status_widget_container)
        status_layout.setContentsMargins(0, 0, 0, 0); status_layout.setSpacing(5)
        self.status_label_title = QLabel("Status:")
        status_layout.addWidget(self.status_label_title)
        self.status_text = QLabel("") 
        status_layout.addWidget(self.status_text); status_layout.addStretch()
        layout.addWidget(self.status_widget_container) # Add container to main layout

        self.setMinimumHeight(110) 
        self.setMinimumWidth(250 if is_player else 200)
        self.update_style(self.settings)

    def update_stats(self, current_hp: int, max_hp: int,
                    current_stamina: int, max_stamina: int,
                    status_effects: Optional[List[str]] = None,
                    current_mana: Optional[int] = None, max_mana: Optional[int] = None):
        """Update the entity stats display. This is now the final update (Phase 2)."""
        
        old_hp = self.hp_bar.value()
        # Ensure HP bar is always visible if HP stat is relevant
        self.hp_widget_container.setVisible(True) # Make container visible
        self.hp_bar.setRange(0, max_hp if max_hp > 0 else 1) 
        self.hp_bar.setValue(current_hp)
        self.hp_bar.setFormat(f"{current_hp} / {max_hp}")
        self._update_hp_bar_color(current_hp, max_hp) 

        if old_hp != current_hp:
            logger.debug(f"EntityWidget {self.entity_id} HP directly updated to {current_hp}/{max_hp}")

        old_stamina = self.stamina_bar.value()
        if max_stamina > 0:
            self.stamina_widget_container.setVisible(True) # Make container visible
            self.stamina_bar.setRange(0, max_stamina)
            self.stamina_bar.setValue(current_stamina)
            self.stamina_bar.setFormat(f"{current_stamina} / {max_stamina}")
        else: 
            self.stamina_widget_container.setVisible(False) # Hide whole container
        
        if old_stamina != current_stamina:
            logger.debug(f"EntityWidget {self.entity_id} Stamina directly updated to {current_stamina}/{max_stamina}")

        if current_mana is not None and max_mana is not None:
            old_mana = self.mana_bar.value()
            if max_mana > 0:
                self.mana_widget_container.setVisible(True) # Make container visible
                self.mana_bar.setRange(0, max_mana)
                self.mana_bar.setValue(current_mana)
                self.mana_bar.setFormat(f"{current_mana} / {max_mana}")
            else: 
                self.mana_widget_container.setVisible(False) # Hide whole container
            
            if old_mana != current_mana:
                logger.debug(f"EntityWidget {self.entity_id} Mana directly updated to {current_mana}/{max_mana}")
        else: 
            self.mana_widget_container.setVisible(False) # Hide container if no mana data

        if status_effects:
            self.status_widget_container.setVisible(True) # Make container visible
            self.status_text.setText(", ".join(status_effects))
        else:
            self.status_widget_container.setVisible(True) # Still show "Status: None"
            self.status_text.setText("None")

    def _update_hp_bar_color(self, current_hp: int, max_hp: int):
        """Helper method to update HP bar color based on settings."""
        hp_percent = (current_hp / max_hp) * 100 if max_hp > 0 else 0
        style_sheet = self.hp_bar.styleSheet() # Get current base style
        chunk_style = ""

        # Use settings for colors
        critical_color = self.settings.get("color_hp_bar_chunk_critical", "#990000")
        low_color = self.settings.get("color_hp_bar_chunk_low", "#cc0000")
        normal_color = self.settings.get("color_hp_bar_chunk_normal", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)")

        if hp_percent < self.settings.get("hp_threshold_critical", 25): # Make threshold configurable? (Future idea)
            chunk_color = critical_color
        elif hp_percent < self.settings.get("hp_threshold_low", 50): # Make threshold configurable? (Future idea)
            chunk_color = low_color
        else:
            chunk_color = normal_color

        chunk_style = f"background-color: {chunk_color};"

        # Find and replace the chunk part of the stylesheet
        # This assumes the base style is set correctly in update_style
        new_style_sheet = re.sub(r"(QProgressBar::chunk\s*{)[^}]*(})",
                                 r"\1 " + chunk_style + r" \2",
                                 style_sheet, count=1, flags=re.IGNORECASE | re.DOTALL)

        if new_style_sheet != style_sheet: # Apply only if changed
            self.hp_bar.setStyleSheet(new_style_sheet)

    def setFrameStyle(self, active=False):
        """Set the frame style based on entity type, active state, and settings."""
        if self.is_player:
            if active:
                bg_color = self.settings.get("color_entity_player_bg_active", "rgba(200, 220, 255, 80)")
                border_color = self.settings.get("color_entity_player_border_active", "#00aaff")
                border_width = 3
            else:
                bg_color = self.settings.get("color_entity_player_bg", "rgba(200, 220, 255, 30)")
                border_color = self.settings.get("color_entity_player_border", "#0077cc")
                border_width = 2
        else: # Enemy
            if active:
                bg_color = self.settings.get("color_entity_enemy_bg_active", "rgba(255, 200, 200, 80)")
                border_color = self.settings.get("color_entity_enemy_border_active", "#ff5500")
                border_width = 3
            else:
                bg_color = self.settings.get("color_entity_enemy_bg", "rgba(255, 200, 200, 30)")
                border_color = self.settings.get("color_entity_enemy_border", "#cc0000")
                border_width = 2

        explicit_text_color = self.settings.get("color_groupbox_title_text", "#FFFFFF")

        self.setStyleSheet(f"""
            CombatEntityWidget {{
                border: {border_width}px solid {border_color};
                border-radius: 5px;
                background-color: {bg_color};
                /* color: {explicit_text_color}; */ /* Removing this default color for the widget itself */
            }}
            /* QLabel styling will be handled in update_style or by direct application */
        """)
        
        self.name_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.hp_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.stamina_label.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.status_label_title.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")
        self.status_text.setStyleSheet(f"color: {explicit_text_color}; background-color: transparent;")

    def highlight_active(self, active: bool = True):
        """Highlight the entity if it's their turn, using settings."""
        self.setFrameStyle(active=active)

    def update_style(self, settings: dict):
        """Update the widget's style based on the provided settings."""
        self.settings = settings
        # is_active_currently = False # Not needed here, setFrameStyle handles active state

        base_font_family = self.settings.get("font_family", "Arial")
        base_font_size = self.settings.get("font_size", 10)

        label_text_color = self.settings.get("color_groupbox_title_text", "#FFFFFF")

        name_font = QFont(base_font_family, base_font_size)
        name_font.setBold(True)
        if self.is_player: name_font.setPointSize(base_font_size + self.settings.get("font_size_player_name_offset", 1))
        self.name_label.setFont(name_font)
        self.name_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")


        base_font = QFont(base_font_family, base_font_size)
        self.hp_label.setFont(base_font)
        self.hp_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.stamina_label.setFont(base_font) 
        self.stamina_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")
        
        self.mana_label.setFont(base_font) 
        self.mana_label.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.status_label_title.setFont(base_font)
        self.status_label_title.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        self.status_text.setFont(base_font)
        self.status_text.setStyleSheet(f"color: {label_text_color}; background-color: transparent;")

        hp_chunk_normal = self.settings.get("color_hp_bar_chunk_normal", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)")
        stamina_chunk = self.settings.get("color_stamina_bar_chunk", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #66CC33, stop:1 #44AA22)")
        mana_chunk = self.settings.get("color_mana_bar_chunk", "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #3366CC, stop:1 #2244AA)") 
        pb_text_color = self.settings.get("color_progressbar_text", "#FFFFFF") 
        pb_bg_color = self.settings.get("color_progressbar_bg", "#555555") 

        pb_base_style = f"""
            QProgressBar {{
                border: 1px solid #444; border-radius: 3px; text-align: center;
                height: 18px; color: {pb_text_color}; background-color: {pb_bg_color};
            }}
        """
        self.hp_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {hp_chunk_normal}; }}")
        self.stamina_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {stamina_chunk}; }}")
        self.mana_bar.setStyleSheet(f"{pb_base_style} QProgressBar::chunk {{ background-color: {mana_chunk}; }}") 

        self.setFrameStyle(active=False) # Apply default inactive frame style

        current_hp = self.hp_bar.value(); max_hp = self.hp_bar.maximum()
        self._update_hp_bar_color(current_hp, max_hp)
        self.update()
        
    @Slot(dict)
    def animate_ui_bar_update_phase1(self, update_data: Dict[str, Any]):
        """
        Handles Phase 1 of a bar update: show impending loss.
        update_data: { "bar_type": "hp"|"stamina"|"mana", "old_value": X, "new_value_preview": Y, "max_value": M }
        """
        bar_type = update_data.get("bar_type")
        new_value_preview = update_data.get("new_value_preview") 
        max_value = update_data.get("max_value")

        logger.debug(f"EntityWidget {self.entity_id} PHASE 1 ANIM: {bar_type} to preview {new_value_preview}/{max_value}")

        target_bar = None
        original_stylesheet = ""
        bleak_color_key_suffix = "_bleak" # e.g. color_hp_bar_chunk_normal_bleak

        if bar_type == "hp": 
            target_bar = self.hp_bar
            hp_percent_preview = (new_value_preview / max_value) * 100 if max_value > 0 else 0
            if hp_percent_preview < self.settings.get("hp_threshold_critical", 25): bleak_color_key = "color_hp_bar_chunk_critical" + bleak_color_key_suffix
            elif hp_percent_preview < self.settings.get("hp_threshold_low", 50): bleak_color_key = "color_hp_bar_chunk_low" + bleak_color_key_suffix
            else: bleak_color_key = "color_hp_bar_chunk_normal" + bleak_color_key_suffix
        elif bar_type == "stamina": 
            target_bar = self.stamina_bar
            bleak_color_key = "color_stamina_bar_chunk" + bleak_color_key_suffix
        elif bar_type == "mana": # NEW for Mana
            target_bar = self.mana_bar
            bleak_color_key = "color_mana_bar_chunk" + bleak_color_key_suffix # Assuming similar setting key
        else:
            logger.warning(f"EntityWidget {self.entity_id}: Unknown bar_type '{bar_type}' for phase 1 animation.")
            if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'): # Ensure orchestrator can proceed
                QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
            return

        if target_bar and new_value_preview is not None and max_value is not None:
            original_stylesheet = target_bar.styleSheet() # Store current full stylesheet
            
            bleak_color = self.settings.get(bleak_color_key, "#777777A0") # Default semi-transparent gray

            new_chunk_style = f"background-color: {bleak_color};"
            # Replace only the background-color of the chunk part
            updated_stylesheet = re.sub(r"(QProgressBar::chunk\s*{\s*background-color:\s*)[^;]+(;[^}]*})",
                                        rf"\1{bleak_color}\2",
                                        original_stylesheet, count=1, flags=re.IGNORECASE | re.DOTALL)
            if not re.search(r"QProgressBar::chunk\s*{", updated_stylesheet, re.IGNORECASE): # If no chunk style existed
                base_pb_style = re.match(r"(QProgressBar\s*{[^}]*})", original_stylesheet, re.IGNORECASE | re.DOTALL)
                if base_pb_style:
                    updated_stylesheet = base_pb_style.group(1) + f" QProgressBar::chunk {{ {new_chunk_style} }}"
                else: # Fallback: just append
                    updated_stylesheet = original_stylesheet + f" QProgressBar::chunk {{ {new_chunk_style} }}"


            target_bar.setStyleSheet(updated_stylesheet)
            target_bar.setFormat(f"{new_value_preview} / {max_value} (...)") # Indicate change

            self._pending_bar_update_data = {
                "bar_type": bar_type,
                "final_value": new_value_preview, # This is preview, Phase2 will get actual final
                "max_value": max_value,
                "original_stylesheet": original_stylesheet 
            }
        else:
            logger.warning(f"Could not animate phase 1 for {self.entity_id}, bar_type: {bar_type}, data: {update_data}")

        # Visual update is considered complete for Phase 1 after style is set.
        if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
            QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
    @Slot(dict)
    def animate_ui_bar_update_phase2(self, update_data: Dict[str, Any]):
        """
        Handles Phase 2 of a bar update: finalize the bar to its new value.
        update_data: { "bar_type": "hp"|"stamina"|"mana", "final_new_value": Y, "max_value": M }
        """
        bar_type = update_data.get("bar_type")
        final_value = update_data.get("final_new_value")
        max_value = update_data.get("max_value")
        
        logger.debug(f"EntityWidget {self.entity_id} PHASE 2 ANIM: {bar_type} to final {final_value}/{max_value}")

        target_bar = None
        if bar_type == "hp": target_bar = self.hp_bar
        elif bar_type == "stamina": target_bar = self.stamina_bar
        elif bar_type == "mana": target_bar = self.mana_bar # NEW for Mana
        else:
            logger.warning(f"EntityWidget {self.entity_id}: Unknown bar_type '{bar_type}' for phase 2 animation.")
            if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
                QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)
            return

        if target_bar and final_value is not None and max_value is not None:
            # Restore original base stylesheet if it was stored and modified for bleak color
            if self._pending_bar_update_data and self._pending_bar_update_data.get("bar_type") == bar_type:
                original_style = self._pending_bar_update_data.get("original_stylesheet")
                if original_style:
                    target_bar.setStyleSheet(original_style) # Restore base before applying final color logic
            
            # Call update_stats to set value and apply final color logic
            # Need to fetch other stats if update_stats requires all of them
            # For simplicity, assuming update_stats can handle partial updates or we reconstruct args
            if bar_type == "hp":
                self.update_stats(final_value, max_value, self.stamina_bar.value(), self.stamina_bar.maximum(), current_mana=self.mana_bar.value(), max_mana=self.mana_bar.maximum())
            elif bar_type == "stamina":
                self.update_stats(self.hp_bar.value(), self.hp_bar.maximum(), final_value, max_value, current_mana=self.mana_bar.value(), max_mana=self.mana_bar.maximum())
            elif bar_type == "mana": # NEW for Mana
                self.update_stats(self.hp_bar.value(), self.hp_bar.maximum(), self.stamina_bar.value(), self.stamina_bar.maximum(), current_mana=final_value, max_mana=max_value)

            
            target_bar.setFormat(f"{final_value} / {max_value}") # Ensure format is correct
            logger.debug(f"EntityWidget {self.entity_id} {bar_type} bar finalized to {final_value}/{max_value}")
        else:
            logger.warning(f"Could not animate phase 2 for {self.entity_id}, bar_type: {bar_type}, data: {update_data}")
            
        self._pending_bar_update_data = None 
        
        if hasattr(get_game_engine()._combat_orchestrator, '_handle_visual_display_complete'):
            QTimer.singleShot(0, get_game_engine()._combat_orchestrator._handle_visual_display_complete)

    @Slot()
    def _finalize_bar_update(self):
        """Actually updates the bar value and color after the delay (Old method, for reference if needed)."""
        # This method is less used now as Orchestrator controls delays and Phase 2 trigger.
        # Kept for potential direct use or if animation needs its own timer.
        if self._pending_bar_update_data:
            bar_type = self._pending_bar_update_data["bar_type"]
            final_value = self._pending_bar_update_data["final_value"]
            max_value = self._pending_bar_update_data["max_value"]
            # original_stylesheet = self._pending_bar_update_data["original_stylesheet"] # Not used if update_stats handles colors

            target_bar = None
            if bar_type == "hp": target_bar = self.hp_bar
            elif bar_type == "stamina": target_bar = self.stamina_bar

            if target_bar:
                # target_bar.setStyleSheet(original_stylesheet) # Restore base if needed
                target_bar.setValue(final_value)
                target_bar.setFormat(f"{final_value} / {max_value}")
                if bar_type == "hp": self._update_hp_bar_color(final_value, max_value)
                # Add similar for stamina if it has dynamic coloring

            self._pending_bar_update_data = None

class CombatDisplay(QWidget):
    """Widget for displaying combat status and log."""

    # --- ECFA Change: Add visualDisplayComplete signal ---
    visualDisplayComplete = Signal()
    # --- End ECFA Change ---

    def __init__(self, parent=None):
        """Initialize the combat display widget."""
        super().__init__(parent)

        self.setObjectName("combatDisplayWidget")

        self.entity_widgets: Dict[str, CombatEntityWidget] = {}
        self.combat_active = False 
        self.stats_manager = get_stats_manager() 
        self.current_settings: Dict[str, Any] = {} 

        self.load_settings()

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0) 
        main_layout.setSpacing(0)
        
        self.content_frame = QFrame()
        self.content_frame.setObjectName("combatContentFrame") 
        self.content_frame.setFrameShape(QFrame.Shape.StyledPanel) 
        self.content_frame.setFrameShadow(QFrame.Shadow.Raised) 
        main_layout.addWidget(self.content_frame) 

        layout = QVBoxLayout(self.content_frame) 
        layout.setContentsMargins(10, 10, 10, 10) 
        layout.setSpacing(10) 

        status_layout = QHBoxLayout()
        status_layout.setContentsMargins(0, 0, 0, 0)
        status_layout.setSpacing(10)

        self.status_label = QLabel("Status: Narrative") 
        self.status_label.setObjectName("statusLabel")
        status_layout.addWidget(self.status_label)

        self.round_label = QLabel("Round: 0")
        self.round_label.setVisible(False) 
        self.round_label.setObjectName("roundLabel")
        status_layout.addWidget(self.round_label)

        status_layout.addStretch()

        self.settings_button = QPushButton("⚙️")
        self.settings_button.setToolTip("Combat Display Settings")
        self.settings_button.setFixedSize(25, 25)
        self.settings_button.clicked.connect(self.open_settings_dialog)
        status_layout.addWidget(self.settings_button)

        # Developer controls (hidden unless dev mode enabled)
        self.dev_controls_container = QWidget()
        dev_controls_layout = QHBoxLayout(self.dev_controls_container)
        dev_controls_layout.setContentsMargins(0, 0, 0, 0)
        dev_controls_layout.setSpacing(6)
        self.dev_step_mode_btn = QPushButton("Step Mode")
        self.dev_step_mode_btn.setCheckable(True)
        self.dev_next_step_btn = QPushButton("Next Step")
        self.dev_next_step_btn.setEnabled(False)
        dev_controls_layout.addWidget(self.dev_step_mode_btn)
        dev_controls_layout.addWidget(self.dev_next_step_btn)
        status_layout.addWidget(self.dev_controls_container)

        layout.addLayout(status_layout)

        self.entities_frame = QFrame() 
        self.entities_frame.setFrameShape(QFrame.Shape.NoFrame) 
        self.entities_frame.setFrameShadow(QFrame.Shadow.Plain) 
        self.entities_frame.setObjectName("entitiesFrame")
        entities_layout = QVBoxLayout(self.entities_frame)
        entities_layout.setContentsMargins(0,0,0,0) 
        entities_layout.setSpacing(10) 

        self.player_group = QGroupBox("Player") 
        self.player_group.setObjectName("playerGroup")
        player_layout = QHBoxLayout(self.player_group)
        player_layout.setContentsMargins(5, 10, 5, 5) 
        player_layout.setSpacing(5)
        self.player_layout = player_layout
        entities_layout.addWidget(self.player_group)

        self.enemies_group = QGroupBox("Enemies") 
        self.enemies_group.setObjectName("enemiesGroup")
        enemies_layout = QHBoxLayout(self.enemies_group)
        enemies_layout.setContentsMargins(5, 10, 5, 5) 
        enemies_layout.setSpacing(5)
        self.enemies_layout = enemies_layout
        entities_layout.addWidget(self.enemies_group)

        layout.addWidget(self.entities_frame)

        self.log_group = QGroupBox("Combat Log") 
        self.log_group.setObjectName("logGroup")
        log_layout = QVBoxLayout(self.log_group)
        log_layout.setContentsMargins(5, 10, 5, 5) 
        log_layout.setSpacing(0)

        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setMinimumHeight(150)
        self.log_text.setObjectName("combatLogText")
        log_layout.addWidget(self.log_text)

        layout.addWidget(self.log_group)

        self.last_log_index = -1 

        self._gradual_log_iterator: Optional[Iterator[str]] = None
        self._gradual_log_format: Optional[QTextCharFormat] = None
        self._gradual_log_timer: Optional[QTimer] = None
        self._is_gradual_log_active: bool = False
        self._pending_log_messages: List[Tuple[str, QTextCharFormat, bool]] = [] 

        self.apply_settings()
        self.clear_display()
        
        # Suppress visualComplete during batched replays
        self._suppress_visual_complete: bool = False

        # Initialize dev controls visibility from QSettings
        self._init_dev_controls()

    def load_settings(self):
        """Load settings from JSON file or use defaults."""
        self.current_settings = self.get_default_settings() # Start with defaults
        logger.info(f"Loading combat display settings from: {SETTINGS_FILE}")
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r') as f:
                    loaded_settings = json.load(f)
                    logger.debug(f"Loaded settings: {loaded_settings}")
                    # Merge loaded settings carefully, only overwriting defaults
                    for key, value in loaded_settings.items():
                         # Check if key exists in defaults OR if it's a known pattern (future-proofing slightly)
                         if key in self.current_settings or key.startswith("color_") or key.startswith("font_"):
                             self.current_settings[key] = value
                         else:
                             logger.warning(f"Ignoring unknown setting '{key}' from file.")
            else:
                logger.info("Settings file not found. Using default settings.")
        except (IOError, json.JSONDecodeError) as e:
            logger.error(f"Error loading combat display settings: {e}. Using defaults.")
        logger.info(f"Final settings after load: {self.current_settings}")


    def get_default_settings(self):
        """Return a dictionary of default settings."""
        default_font = QFontDatabase.systemFont(QFontDatabase.GeneralFont)
        return {
            # Background
            "background_image": None,
            # Fonts
            "font_family": default_font.family(),
            "font_size": default_font.pointSize() if default_font.pointSize() > 0 else 10,
            "font_size_player_name_offset": 1,
            "font_size_status_offset": 2,
            # Log Colors
            "color_log_damage": "#C80000",
            "color_log_heal": "#009600",
            "color_log_crit": "#FF0000", # Brighter red for crits
            "color_log_miss": "#969696",
            "color_log_roll": "#C87800",
            "color_log_turn": "#0064C8",
            "color_log_round": "#0064FF",
            "color_log_dev": "#646464",
            "color_log_header": "#A0A0A0", 
            "color_log_default": "#E0E0E0", 
            "color_log_combat_event": "#FFFFFF", 
            "color_log_system_message": "#FFFF00", # Default Yellow for system messages
            "color_log_narrative": "#FFD700", # Default Golden for narrative/GM messages
            "color_log_group_bg": "rgba(40, 40, 40, 0.75)", 
            "color_log_text_bg": "rgba(25, 25, 25, 0.85)", # Slightly darker text edit bg
            # General UI Colors
            "color_status_text": "#FFFFFF", 
            "color_round_text": "#E0E0E0", 
            "color_groupbox_title_text": "#FFFFFF", 
            "color_groupbox_title_bg": "rgba(0, 0, 0, 0.6)", 
            # Section Background Colors 
            "color_player_group_bg": "rgba(60, 80, 120, 0.7)", 
            "color_enemies_group_bg": "rgba(120, 60, 60, 0.7)", 
            # Entity Colors
            "color_entity_player_bg": "rgba(200, 220, 255, 0.3)",
            "color_entity_player_border": "#0077cc",
            "color_entity_player_bg_active": "rgba(200, 220, 255, 0.8)",
            "color_entity_player_border_active": "#00aaff",
            "color_entity_enemy_bg": "rgba(255, 200, 200, 0.3)",
            "color_entity_enemy_border": "#cc0000",
            "color_entity_enemy_bg_active": "rgba(255, 200, 200, 0.8)",
            "color_entity_enemy_border_active": "#ff5500",
            # Progress Bar Colors
            "color_hp_bar_chunk_normal": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #ff0000, stop:1 #aa0000)",
            "color_hp_bar_chunk_low": "#cc0000",
            "color_hp_bar_chunk_critical": "#990000",
            "color_hp_bar_chunk_normal_bleak": "#AA0000A0", 
            "color_hp_bar_chunk_low_bleak": "#880000A0",   
            "color_hp_bar_chunk_critical_bleak": "#600000A0",
            "color_stamina_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #66CC33, stop:1 #44AA22)",
            "color_stamina_bar_chunk_bleak": "#44AA22A0",
            "color_mana_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #3366CC, stop:1 #2244AA)", # Added Mana Chunk
            "color_mana_bar_chunk_bleak": "#2244AAA0",  # Added Mana Bleak
            "color_resolve_bar_chunk": "qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #9b59b6, stop:1 #8e44ad)",
            "color_progressbar_text": "#FFFFFF", 
            "color_progressbar_bg": "#555555",

            "gradual_text_combat_log": True, 
            "display_text_speed_delay": 30,
        }

    def save_settings(self):
        """Save current settings to JSON file."""
        logger.info(f"Saving combat display settings to: {SETTINGS_FILE}")
        try:
            # Ensure config directory exists before writing
            os.makedirs(CONFIG_DIR, exist_ok=True)
            with open(SETTINGS_FILE, 'w') as f:
                json.dump(self.current_settings, f, indent=4)
            logger.info("Settings saved successfully.")
        except IOError as e:
            logger.error(f"Error saving combat display settings: {e}")

    def _init_dev_controls(self):
        """Initialize dev controls based on QSettings and wire their signals."""
        try:
            settings = QSettings("RPGGame", "Settings")
            dev_enabled = settings.value("dev/enabled", False, type=bool)
        except Exception:
            dev_enabled = False
        self.dev_controls_container.setVisible(bool(dev_enabled))
        # Wire buttons to orchestrator
        try:
            engine = get_game_engine()
            orch = getattr(engine, '_combat_orchestrator', None)
            if orch:
                # Disconnect existing to avoid duplicates
                try:
                    self.dev_step_mode_btn.toggled.disconnect(orch.toggle_dev_step_mode)
                except Exception:
                    pass
                try:
                    self.dev_next_step_btn.clicked.disconnect(orch.dev_release_next_step)
                except Exception:
                    pass
                self.dev_step_mode_btn.toggled.connect(orch.toggle_dev_step_mode)
                self.dev_next_step_btn.clicked.connect(orch.dev_release_next_step)
                # Listen to waiting state to enable/disable Next button
                try:
                    orch.dev_waiting_state_changed.disconnect(self._on_orchestrator_dev_waiting_changed)
                except Exception:
                    pass
                orch.dev_waiting_state_changed.connect(self._on_orchestrator_dev_waiting_changed)
        except Exception as e:
            logger.warning(f"Failed initializing dev controls: {e}")

    @Slot(bool)
    def _on_orchestrator_dev_waiting_changed(self, waiting: bool):
        self.dev_next_step_btn.setEnabled(bool(waiting))

    def apply_settings(self):
        """Apply loaded or default settings to the combat display UI."""
        if not self.current_settings:
            logger.warning("Attempted to apply settings before loading. Loading defaults.")
            self.load_settings() # This populates self.current_settings

        logger.debug(f"Applying settings to CombatDisplay: {self.current_settings}")

        # --- ECFA Change: Ensure text speed setting is loaded into self.current_settings ---
        # If load_settings doesn't get specific combat speed, use general one.
        q_settings = QSettings("RPGGame", "Settings")
        general_text_speed = q_settings.value("display/text_speed_delay", 30, type=int)
        self.current_settings.setdefault("display_text_speed_delay_combat", general_text_speed)
        # --- End ECFA Change ---

        bg_image_relative = self.current_settings.get("background_image")
        main_widget_style_parts = [] 
        image_path_for_log = "None" 
        if bg_image_relative:
            image_path = os.path.join(IMAGE_DIR, bg_image_relative).replace("\\", "/")
            image_path_for_log = image_path 
            if os.path.exists(image_path):
                main_widget_style_parts.append(f"border-image: url(\"{image_path}\") 0 0 0 0 stretch stretch;")
                logger.info(f"Applying background image using border-image: {image_path}")
            else:
                logger.warning(f"Background image not found: {image_path}")
                main_widget_style_parts.append("border-image: none;")
        else:
             main_widget_style_parts.append("border-image: none;")
             logger.info("No background image selected, applying 'border-image: none;'")

        try:
            fallback_bg_color_str = self.current_settings.get("color_fallback_bg", "rgba(30, 30, 30, 0.9)")
            QColor(fallback_bg_color_str) 
        except (ValueError, TypeError):
            logger.warning(f"Invalid fallback background color '{fallback_bg_color_str}'. Using default.")
            fallback_bg_color_str = "rgba(30, 30, 30, 0.9)"
        main_widget_style_parts.append(f"background-color: {fallback_bg_color_str};")

        main_widget_style = "\n    ".join(main_widget_style_parts)

        def get_safe_color(key, default):
            color_str = self.current_settings.get(key, default)
            try:
                QColor(color_str); return color_str
            except (ValueError, TypeError):
                logger.warning(f"Invalid color value '{color_str}' for key '{key}'. Using default '{default}'.")
                return default

        player_group_bg = get_safe_color("color_player_group_bg", "rgba(60, 80, 120, 0.7)")
        enemies_group_bg = get_safe_color("color_enemies_group_bg", "rgba(120, 60, 60, 0.7)")
        log_group_bg = get_safe_color("color_log_group_bg", "rgba(40, 40, 40, 0.75)")
        log_default_text_color = get_safe_color("color_log_default", "#E0E0E0")
        log_text_bg_color = get_safe_color("color_log_text_bg", "rgba(255, 255, 255, 0.05)") # Ensure this is a valid key or provide default
        groupbox_title_text = get_safe_color("color_groupbox_title_text", "#FFFFFF")
        groupbox_title_bg = get_safe_color("color_groupbox_title_bg", "rgba(0, 0, 0, 0.6)")
        status_text_color = get_safe_color("color_status_text", "#FFFFFF")
        round_text_color = get_safe_color("color_round_text", "#E0E0E0")


        full_stylesheet = f"""
            QWidget#{self.objectName()} {{ background-color: transparent; border: none; }}
            QFrame#combatContentFrame {{ {main_widget_style} background-clip: padding-box; background-origin: border-box; border-radius: 5px; }}
            QFrame#{self.entities_frame.objectName()} {{ background-color: transparent; border: none; }}
            QGroupBox#{self.player_group.objectName()} {{ background-color: {player_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox#{self.enemies_group.objectName()} {{ background-color: {enemies_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox#{self.log_group.objectName()} {{ background-color: {log_group_bg}; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 15px; padding-top: 5px; }}
            QGroupBox::title {{ color: {groupbox_title_text}; background-color: {groupbox_title_bg}; padding: 3px 8px; border-radius: 3px; subcontrol-origin: margin; subcontrol-position: top left; margin-left: 5px; }}
            QTextEdit#{self.log_text.objectName()} {{ background-color: {log_text_bg_color}; color: {log_default_text_color}; border: 1px solid rgba(0, 0, 0, 0.2); border-radius: 3px; padding: 2px; }}
            QLabel#{self.status_label.objectName()} {{ background-color: transparent; color: {status_text_color}; padding: 2px; }}
            QLabel#{self.round_label.objectName()} {{ background-color: transparent; color: {round_text_color}; padding: 2px; }}
        """
        self.setStyleSheet(full_stylesheet)

        font_family = self.current_settings.get("font_family", "Arial")
        font_size = self.current_settings.get("font_size", 10)
        
        status_font_size_offset = self.current_settings.get("font_size_status_offset", 2)
        status_font = QFont(font_family, font_size + status_font_size_offset)
        status_font.setBold(True)
        self.status_label.setFont(status_font)

        round_font = QFont(font_family, font_size)
        self.round_label.setFont(round_font)

        log_font = QFont(font_family, font_size)
        self.log_text.setFont(log_font) 

        title_font = QFont(font_family, font_size) 
        title_font.setBold(True) 
        self.player_group.setFont(title_font)
        self.enemies_group.setFont(title_font)
        self.log_group.setFont(title_font)

        for entity_widget in self.entity_widgets.values():
            entity_widget.update_style(self.current_settings)
        self.update()
        logger.info("Combat display settings applied.")

    def clear_display(self):
        """Clear the display and set to inactive/narrative state."""
        self.combat_active = False
        self.status_label.setText("Status: Narrative")
        self.round_label.setText("Round: 0")
        self.round_label.setVisible(False) # Hide round counter
        self.last_log_index = -1

        # Clear the combat log text content as well
        try:
            self.clear_log()
        except Exception:
            pass

        # Clear entity widgets
        self._clear_entity_widgets()

        # Hide the entities frame and log_group for clean UI
        if hasattr(self, 'entities_frame'):
            self.entities_frame.setVisible(False)
        if hasattr(self, 'log_group'):
            self.log_group.setVisible(False)

    @Slot(GameState)
    def update_display(self, game_state: GameState):
        """Update the display based on the current GameState."""
        if game_state is None:
            logger.warning("CombatDisplay.update_display received None GameState, clearing display.")
            self.clear_display()
            return

        current_mode_enum = getattr(game_state, 'current_mode', InteractionMode.NARRATIVE)
        mode = current_mode_enum.name if hasattr(current_mode_enum, 'name') else str(current_mode_enum)
        
        logger.info(f"CombatDisplay.update_display called. Game Mode: {mode}")

        if mode in ["COMBAT", "SOCIAL_CONFLICT"]:
            # Update dev controls visibility on entering these modes
            try:
                settings = QSettings("RPGGame", "Settings")
                dev_enabled = settings.value("dev/enabled", False, type=bool)
                self.dev_controls_container.setVisible(bool(dev_enabled))
            except Exception:
                self.dev_controls_container.setVisible(False)
            self.setVisible(True) # Ensure the CombatDisplay widget itself is visible
            initial_setup_done_this_call = False
            if not self.combat_active: 
                logger.info(f"CombatDisplay: First entry into {mode} view. Setting up UI visibility and styles.")
                if hasattr(self, 'entities_frame'): self.entities_frame.setVisible(True)
                if hasattr(self, 'log_group'): self.log_group.setVisible(True)
                if hasattr(self, 'player_group'): self.player_group.setVisible(True)
                if hasattr(self, 'enemies_group'): self.enemies_group.setVisible(True)
                self.combat_active = True
                self.apply_settings() # Apply styles
                initial_setup_done_this_call = True
            
            combat_manager = getattr(game_state, 'combat_manager', None)
            if not combat_manager:
                logger.warning(f"CombatDisplay: {mode} mode active but no CombatManager found. Clearing entity widgets.")
                self.status_label.setText(f"Status: {mode} (Error - No Manager)")
                self._clear_entity_widgets() 
                return
            
            logger.info(f"CombatDisplay: CombatManager found (ID: {getattr(combat_manager, 'id', 'N/A')}). Entities in CM: {len(getattr(combat_manager, 'entities', {}))}")

            round_num = getattr(combat_manager, 'round_number', 0)
            cm_state_attr = getattr(combat_manager, 'state', None)
            cm_state_name = cm_state_attr.name if hasattr(cm_state_attr, 'name') else "Unknown State"

            if mode == "COMBAT":
                self.round_label.setVisible(True)
                self.round_label.setText(f"Round: {round_num}")
                if cm_state_name == "IN_PROGRESS": self.status_label.setText("Status: Combat Active")
                elif cm_state_name == "PLAYER_VICTORY": self.status_label.setText("Status: Victory!")
                elif cm_state_name == "PLAYER_DEFEAT": self.status_label.setText("Status: Defeat!")
                elif cm_state_name == "FLED": self.status_label.setText("Status: Fled from Combat")
                else: self.status_label.setText(f"Status: Combat - {cm_state_name}")
            else: 
                self.status_label.setText("Status: Social Conflict")
                self.round_label.setVisible(False)

            current_turn_id = getattr(combat_manager, 'get_current_entity_id', lambda: None)()
            combatants_widget_data = {}
            cm_entities = getattr(combat_manager, 'entities', {})
            if cm_entities:
                logger.debug(f"CombatDisplay: Building combatants_widget_data from CM entities. Count: {len(cm_entities)}")
                for entity_id, combat_entity in cm_entities.items():
                    if not getattr(combat_entity, 'is_active_in_combat', True):
                        logger.debug(f"CombatDisplay: Skipping display of inactive entity: {getattr(combat_entity, 'combat_name', entity_id)}")
                        if entity_id in self.entity_widgets: 
                            widget_to_remove = self.entity_widgets.pop(entity_id)
                            if widget_to_remove.parentWidget() and widget_to_remove.parentWidget().layout():
                                widget_to_remove.parentWidget().layout().removeWidget(widget_to_remove)
                            widget_to_remove.deleteLater()
                        continue

                    raw_status_effects = getattr(combat_entity, 'status_effects', {})
                    display_status_effects = []
                    if isinstance(raw_status_effects, dict):
                        display_status_effects = [f"{name}({dur})" if dur not in [None, float('inf')] else name for name, dur in raw_status_effects.items()]
                    elif isinstance(raw_status_effects, (list, set)):
                        display_status_effects = [str(eff_name) for eff_name in raw_status_effects]
                    
                    entity_type_enum = getattr(combat_entity, 'entity_type', None)

                    combatants_widget_data[entity_id] = {
                        "id": entity_id, 
                        "name": getattr(combat_entity, 'name', 'N/A'), 
                        "combat_name": getattr(combat_entity, 'combat_name', 'N/A'), 
                        "current_hp": getattr(combat_entity, 'current_hp', 0), 
                        "max_hp": getattr(combat_entity, 'max_hp', 1) if getattr(combat_entity, 'max_hp', 0) > 0 else 1,
                        "current_stamina": getattr(combat_entity, 'current_stamina', 0), 
                        "max_stamina": getattr(combat_entity, 'max_stamina', 1) if getattr(combat_entity, 'max_stamina', 0) > 0 else 1,
                        "current_mana": getattr(combat_entity, 'current_mp', 0),
                        "max_mana": getattr(combat_entity, 'max_mp', 1) if getattr(combat_entity, 'max_mp', 0) > 0 else 1,
                        "status_effects": display_status_effects,
                        "is_player": entity_type_enum == EntityType.PLAYER if entity_type_enum else False,
                        "entity_type_str": entity_type_enum.name if hasattr(entity_type_enum, 'name') else str(entity_type_enum)
                    }
            else:
                logger.warning("CombatDisplay: combat_manager has no 'entities' or it's empty.")

            if not combatants_widget_data:
                logger.warning("CombatDisplay: combatants_widget_data is empty. No entity widgets will be updated/created for this call.")
                if initial_setup_done_this_call:
                    self._clear_entity_widgets() 
            else:
                logger.info(f"CombatDisplay: Queuing _update_entity_widgets with {len(combatants_widget_data)} entries. Current turn ID: {current_turn_id}")
                is_combat_mode = (mode == "COMBAT")
                QTimer.singleShot(0, lambda data=combatants_widget_data.copy(), turn_id=current_turn_id, is_combat=is_combat_mode: self._update_entity_widgets(data, turn_id, is_combat))

        elif self.combat_active: 
            logger.info(f"CombatDisplay: Exiting {mode} view (was active). Clearing display.")
            self.clear_display() 
            self.setVisible(False) # Hide the CombatDisplay widget when not in combat
            
    def _clear_entity_widgets(self):
        """Clear all entity widgets."""
        layouts_to_clear = [self.player_layout, self.enemies_layout]
        for layout in layouts_to_clear:
            if not layout: continue
            # Remove stretch item first if it exists
            stretch_index = -1
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.spacerItem():
                    stretch_index = i
                    break
            if stretch_index != -1:
                layout.takeAt(stretch_index) # Remove stretch

            # Remove widgets
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()
                if widget:
                    widget.deleteLater()

        self.entity_widgets.clear()

    def _update_entity_widgets(self, combatants_data: Dict[str, Dict[str, Any]], current_turn_id: Optional[str], is_combat_mode: bool):
        """Update entity widgets based on combatant data."""
        logger.info(f"CombatDisplay._update_entity_widgets: Received {len(combatants_data)} combatants. Current turn: {current_turn_id}")
        if not combatants_data:
            logger.warning("CombatDisplay._update_entity_widgets: combatants_data is empty. Clearing existing widgets if any.")
            self._clear_entity_widgets() # Clear if no data
            return

        existing_ids_in_data = set(combatants_data.keys())
        current_widget_ids = set(self.entity_widgets.keys())

        # Remove widgets for entities no longer in combatants_data
        for entity_id_to_remove in current_widget_ids - existing_ids_in_data:
            if entity_id_to_remove in self.entity_widgets:
                widget = self.entity_widgets.pop(entity_id_to_remove)
                parent_layout = widget.parentWidget().layout() if widget.parentWidget() else None
                if parent_layout: parent_layout.removeWidget(widget)
                widget.deleteLater()
                logger.info(f"CombatDisplay: Removed entity widget for no longer present/active entity: {entity_id_to_remove}")

        player_widgets_present = False
        enemy_widgets_present = False

        for entity_id, entity_data in combatants_data.items():
            is_player = entity_data.get("is_player", False)
            entity_type_str = entity_data.get("entity_type_str", "UNKNOWN") # For logging
            logger.debug(f"CombatDisplay: Processing entity widget for ID {entity_id}, Name: {entity_data.get('combat_name', 'N/A')}, IsPlayer: {is_player}, Type: {entity_type_str}")
            
            is_active_turn = entity_id == current_turn_id
            display_name = entity_data.get("combat_name", entity_data.get("name", entity_id))
            
            current_hp = int(entity_data.get("current_hp", 0)) 
            max_hp = int(entity_data.get("max_hp", 1)) 
            current_stamina = int(entity_data.get("current_stamina", 0)) 
            max_stamina = int(entity_data.get("max_stamina", 1))
            current_mana = int(entity_data.get("current_mana", 0))
            max_mana = int(entity_data.get("max_mana", 1))
            status_effects = entity_data.get("status_effects", [])

            if entity_id in self.entity_widgets:
                widget = self.entity_widgets[entity_id]
                logger.debug(f"CombatDisplay: Updating existing widget for {display_name}")
                widget.name_label.setText(display_name)
                widget.update_style(self.current_settings)
                # In COMBAT mode, do NOT override current values for existing widgets; only update max ranges and labels
                if is_combat_mode:
                    try:
                        # Update ranges only; keep current values as shown (driven by PHASE events)
                        widget.hp_bar.setRange(0, max_hp if max_hp > 0 else 1)
                        widget.stamina_bar.setRange(0, max_stamina if max_stamina > 0 else 1)
                        widget.mana_bar.setRange(0, max_mana if max_mana > 0 else 1)
                        # Update status effects text
                        if status_effects:
                            widget.status_text.setText(", ".join(status_effects))
                        else:
                            widget.status_text.setText("None")
                    except Exception as e:
                        logger.warning(f"CombatDisplay: Failed to apply COMBAT safe update for {display_name}: {e}")
                else:
                    widget.update_stats(current_hp, max_hp, current_stamina, max_stamina, status_effects, current_mana, max_mana)
                widget.highlight_active(is_active_turn)
            else:
                logger.info(f"CombatDisplay: Creating NEW widget for {display_name} (ID: {entity_id}, IsPlayer: {is_player})")
                widget = CombatEntityWidget(entity_id=entity_id, name=display_name, settings=self.current_settings, is_player=is_player)
                # On first creation, seed values fully
                widget.update_stats(current_hp, max_hp, current_stamina, max_stamina, status_effects, current_mana, max_mana)
                widget.highlight_active(is_active_turn)
                
                target_layout = self.player_layout if is_player else self.enemies_layout
                if target_layout:
                    # Remove existing stretch if present before adding widget
                    stretch_item = target_layout.takeAt(target_layout.count() -1) if target_layout.count() >0 and target_layout.itemAt(target_layout.count()-1).spacerItem() else None

                    target_layout.addWidget(widget) # Add the new widget

                    if stretch_item: # Add stretch back if it was removed
                        target_layout.addSpacerItem(stretch_item)
                    else: # Or ensure stretch is there if layout was empty
                        target_layout.addStretch()

                    logger.debug(f"CombatDisplay: Added widget for {display_name} to {'player' if is_player else 'enemies'} layout.")
                else:
                    logger.error(f"CombatDisplay: Target layout (player/enemy) not found for {display_name}!")
                self.entity_widgets[entity_id] = widget
            
            if is_player: player_widgets_present = True
            else: enemy_widgets_present = True

        # This ensures layouts with no widgets don't have a lingering stretch
        self._ensure_stretch(self.player_layout, player_widgets_present)
        self._ensure_stretch(self.enemies_layout, enemy_widgets_present)
        logger.info(f"CombatDisplay._update_entity_widgets: Finished. Player widgets: {player_widgets_present}, Enemy widgets: {enemy_widgets_present}. Total widgets in dict: {len(self.entity_widgets)}")

    def _ensure_stretch(self, layout: Optional[QHBoxLayout], widgets_present: bool):
        """Adds or removes stretch item from a layout as needed."""
        if not layout: return

        stretch_index = -1
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.spacerItem():
                stretch_index = i
                break

        if widgets_present and stretch_index == -1:
            layout.addStretch() # Add stretch if needed
        elif not widgets_present and stretch_index != -1:
            layout.takeAt(stretch_index) # Remove stretch if no widgets

    def _update_combat_log(self, log_entries: List[str]): # Added type hint
        """Update the combat log incrementally with new entries."""
        if not log_entries:
            return
        # Gate [DEV] lines if dev mode is disabled
        try:
            settings = QSettings("RPGGame", "Settings")
            dev_enabled = settings.value("dev/enabled", False, type=bool)
            if not dev_enabled:
                log_entries = [e for e in log_entries if not (isinstance(e, str) and e.strip().startswith("[DEV]"))]
                if not log_entries:
                    return
        except Exception:
            pass

        scrollbar = self.log_text.verticalScrollBar()
        at_bottom = scrollbar.value() >= scrollbar.maximum() - 10 # Is the user scrolled near the bottom?

        start_index = self.last_log_index + 1
        if start_index >= len(log_entries):
            return

        new_entries_to_process = log_entries[start_index:]
        logger.debug(f"Processing {len(new_entries_to_process)} new log entries (from index {start_index})")

        new_entries_added = False
        for entry_index, entry in enumerate(new_entries_to_process):
            # Determine color/format based on entry content and settings
            color_hex = self.current_settings.get("color_log_default", "#E0E0E0")
            is_bold = False
            is_italic = False
            is_narrative = True # Assume GM/Narrative by default

            entry_lower = entry.lower()

            # Simplified system message check (more robust checks might be needed)
            if entry.startswith("[SYSTEM]") or \
            "roll" in entry_lower and "vs" in entry_lower or \
            "takes" in entry_lower and "damage" in entry_lower or \
            "misses" in entry_lower or \
            "defeated" in entry_lower or \
            "fumble" in entry_lower or \
            "critical hit" in entry_lower or \
            "status expire" in entry_lower or \
            "turn." in entry_lower or \
            "round" in entry_lower and "begins" in entry_lower or \
            entry.startswith("Turn order:") or \
            "Stamina Cost:" in entry: # Check for stamina cost message
                is_narrative = False # Mark as system message

            # --- Color/Style Logic (using settings) ---
            # (Keep existing color logic)
            if entry.startswith("[DEV]"): color_hex = self.current_settings.get("color_log_dev", "#888888"); is_italic = True; is_narrative = False
            elif "critical hit" in entry_lower or "defeated!" in entry_lower or "was defeated" in entry_lower: color_hex = self.current_settings.get("color_log_crit", "#FF4444"); is_bold = True; is_narrative = False
            elif "healed" in entry_lower or "gains" in entry_lower and ("hp" in entry_lower or "stamina" in entry_lower): color_hex = self.current_settings.get("color_log_heal", "#44FF44"); is_narrative = False # Healing is often systemic
            elif "round" in entry_lower and "begins" in entry_lower: color_hex = self.current_settings.get("color_log_round", "#66AAFF"); is_bold = True; is_narrative = False
            elif "turn" in entry_lower or "'s turn" in entry_lower: color_hex = self.current_settings.get("color_log_turn", "#88CCFF"); is_narrative = False
            elif "combat started" in entry_lower or "combat ended" in entry_lower or "victory!" in entry_lower or "defeat!" in entry_lower or "fled!" in entry_lower or "surrender" in entry_lower: color_hex = self.current_settings.get("color_log_combat_event", "#FFFFFF"); is_bold = True; is_narrative = False
            elif "misses" in entry_lower or "fails" in entry_lower or "resisted" in entry_lower or "escape fails" in entry_lower: color_hex = self.current_settings.get("color_log_miss", "#AAAAAA"); is_italic = True; is_narrative = False
            elif "damage" in entry_lower or "loses" in entry_lower and ("hp" in entry_lower or "resolve" in entry_lower): color_hex = self.current_settings.get("color_log_damage", "#FF8888"); is_narrative = False
            elif "roll" in entry_lower or "vs" in entry_lower: color_hex = self.current_settings.get("color_log_roll", "#FFCC66"); is_narrative = False

            # Append with determined format and gradual flag
            text_format = QTextCharFormat()
            try:
                text_format.setForeground(QColor(color_hex))
            except ValueError:
                logger.warning(f"Invalid color hex '{color_hex}' for log entry. Using default.")
                text_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0")))

            if is_bold: text_format.setFontWeight(QFont.Weight.Bold)
            if is_italic: text_format.setFontItalic(True)

            # Use gradual display ONLY for narrative messages
            self._append_formatted_text(entry, text_format, gradual=is_narrative) # Pass gradual flag
            new_entries_added = True

            # Update last processed index
            self.last_log_index = start_index + entry_index

    def _append_formatted_text(self, text: str, text_format: QTextCharFormat, gradual: bool = False):
        """Appends text to the log, either immediately or gradually."""
        use_gradual = gradual and self.current_settings.get("gradual_text_combat_log", True) # Check setting

        if not text.strip(): # Don't append empty or whitespace-only lines
            logger.debug("Skipping append of empty/whitespace log message.")
            self.visualDisplayComplete.emit() # Emit completion even for skipped empty text
            return

        if not text.endswith('\n'):
            text += '\n'

        if self._is_gradual_log_active:
            logger.debug(f"Queueing log message (Gradual: {use_gradual}): '{text[:50]}...'")
            self._pending_log_messages.append((text, text_format, use_gradual))
            return

        if not use_gradual:
            logger.debug(f"Appending immediate log message: '{text[:50]}...'")
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            cursor.insertText(text, text_format)
            self.log_text.setTextCursor(cursor) 
            self.log_text.ensureCursorVisible()
            if not getattr(self, '_suppress_visual_complete', False):
                logger.info(f"CombatDisplay: immediate display complete; emitting visualDisplayComplete for id={getattr(self, '_current_text_event_id', None)}")
                self.visualDisplayComplete.emit() # --- ECFA Change: Emit signal ---
                # Event-based direct notify to orchestrator as well
                try:
                    from core.base.engine import get_game_engine
                    eng = get_game_engine()
                    if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                        logger.debug(f"CombatDisplay: immediate direct orchestrator complete for id={getattr(self, '_current_text_event_id', None)}")
                        eng._combat_orchestrator._handle_visual_display_complete()
                except Exception:
                    pass
            self._process_next_pending_log_message()
            return

        logger.debug(f"Starting gradual log display: '{text[:50]}...'")
        self._is_gradual_log_active = True
        self._gradual_log_iterator = iter(text)
        self._gradual_log_format = text_format

        cursor = self.log_text.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.log_text.setTextCursor(cursor)

        if not self._gradual_log_timer:
            self._gradual_log_timer = QTimer(self)
            self._gradual_log_timer.setSingleShot(True)
            self._gradual_log_timer.timeout.connect(self._display_next_log_char)

        QTimer.singleShot(1, self._display_next_log_char)

    @Slot()
    def _display_next_log_char(self):
        """Displays the next character for the combat log gradual display."""
        if not self._is_gradual_log_active or not self._gradual_log_iterator:
            if self._is_gradual_log_active: 
                self._is_gradual_log_active = False
                if not getattr(self, '_suppress_visual_complete', False):
                    self.visualDisplayComplete.emit() 
                self._process_next_pending_log_message()
            return

        try:
            char = next(self._gradual_log_iterator)
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            if self._gradual_log_format:
                cursor.insertText(char, self._gradual_log_format)
            else:
                cursor.insertText(char) 
            self.log_text.setTextCursor(cursor) 
            self.log_text.ensureCursorVisible() 

            # --- ECFA Change: Use unified settings key from self.current_settings ---
            char_delay = self.current_settings.get("display_text_speed_delay", 30) 
            # --- End ECFA Change ---
            char_delay = max(5, int(char_delay)) 
            if self._gradual_log_timer: 
                self._gradual_log_timer.start(char_delay)

        except StopIteration:
            self._is_gradual_log_active = False
            self._gradual_log_iterator = None
            self._gradual_log_format = None
            logger.info(f"CombatDisplay: gradual display finished; emitting visualDisplayComplete for id={getattr(self, '_current_text_event_id', None)}")
            if not getattr(self, '_suppress_visual_complete', False):
                self.visualDisplayComplete.emit() 
                # Event-based direct notify to orchestrator as well
                try:
                    from core.base.engine import get_game_engine
                    eng = get_game_engine()
                    if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                        logger.debug(f"CombatDisplay: gradual direct orchestrator complete for id={getattr(self, '_current_text_event_id', None)}")
                        eng._combat_orchestrator._handle_visual_display_complete()
                except Exception:
                    pass
            self._process_next_pending_log_message()

        except Exception as e:
            logger.error(f"Error during gradual log display: {e}", exc_info=True)
            self._is_gradual_log_active = False
            self._gradual_log_iterator = None
            self._gradual_log_format = None
            if self._gradual_log_timer and self._gradual_log_timer.isActive():
                self._gradual_log_timer.stop()
            if not getattr(self, '_suppress_visual_complete', False):
                logger.info(f"CombatDisplay: gradual error path; emitting visualDisplayComplete for id={getattr(self, '_current_text_event_id', None)}")
                self.visualDisplayComplete.emit() 
                # Event-based direct notify to orchestrator as well
                try:
                    from core.base.engine import get_game_engine
                    eng = get_game_engine()
                    if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                        logger.debug(f"CombatDisplay: error direct orchestrator complete for id={getattr(self, '_current_text_event_id', None)}")
                        eng._combat_orchestrator._handle_visual_display_complete()
                except Exception:
                    pass
            self._pending_log_messages.clear() 
            self._process_next_pending_log_message() # Process queue even on error

    def _process_next_pending_log_message(self):
        """Processes the next message in the pending queue."""
        if not self._is_gradual_log_active and self._pending_log_messages:
            text, text_format, is_gradual = self._pending_log_messages.pop(0)
            logger.debug(f"Processing pending log message (Gradual: {is_gradual}): '{text[:50]}...'")
            # Call _append_formatted_text again - it will handle starting gradual or immediate append
            self._append_formatted_text(text, text_format, gradual=is_gradual)

    def clear_log(self):
        """Clear the combat log."""
        self.log_text.clear()
        logger.info("Combat log cleared.")
        # Add header back immediately after clearing?
        # header_format = QTextCharFormat()
        # header_format.setFontWeight(QFont.Bold)
        # header_format.setForeground(QColor(self.current_settings.get("color_log_header", "#A0A0A0")))
        # self._append_formatted_text("===== COMBAT LOG =====", header_format)


    def open_settings_dialog(self):
        """Opens the settings dialog to customize the combat display."""
        logger.info("Opening Combat Display Settings dialog.")

        if not self.current_settings:
            logger.error("Cannot open settings dialog: current_settings not loaded.")
            self.load_settings() # Try loading defaults if missing

        # Pass a copy of current settings to avoid modifying originals unless saved
        dialog = CombatSettingsDialog(self.current_settings.copy(), IMAGE_DIR, self)

        # Execute the dialog modally
        if dialog.exec(): # Returns True if accepted (e.g., Save clicked)
            new_settings = dialog.get_settings()
            if new_settings != self.current_settings:
                logger.info("Settings changed. Saving and applying...")
                self.current_settings = new_settings
                self.save_settings()
                self.apply_settings() # Re-apply all settings
            else:
                logger.info("Settings dialog closed without changes.")
        else:
            logger.info("Settings dialog cancelled.")

    def append_buffered_messages(self, messages: List[str], gradual: bool):
        """
        Appends a list of messages, typically from the combat_narrative_buffer.
        The visualDisplayComplete signal will be emitted after the *last* message in the list
        has finished displaying.
        """
        if not messages:
            self.visualDisplayComplete.emit() # Emit if buffer is empty
            return

        logger.debug(f"Appending {len(messages)} buffered messages. Gradual: {gradual}")
        
        # Use default GM format for buffered messages (usually narrative)
        # This format should be configurable or passed with the event in a richer system
        from PySide6.QtGui import QFont, QColor # Local import for safety
        gm_format = QTextCharFormat()
        gm_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0"))) # Example color
        # font_family = self.current_settings.get("font_family", "Arial")
        # font_size = self.current_settings.get("font_size", 10)
        # gm_format.setFont(QFont(font_family, font_size))


        for i, message_content in enumerate(messages):
            is_last_message = (i == len(messages) - 1)
            
            # If it's the last message, its completion will trigger the main visualDisplayComplete.
            # For other messages, we don't want them to trigger the orchestrator's main logic.
            # This requires _append_formatted_text to know if it's part of a batch.
            # Simpler for now: _append_formatted_text always emits. Orchestrator ignores intermediate ones
            # if it knows it's processing a BUFFER_FLUSH event with multiple items.
            # This detail depends on how Orchestrator handles BUFFER_FLUSH DisplayEvents.

            # For now, let's assume _append_formatted_text handles queuing and will eventually
            # emit visualDisplayComplete after the *entire sequence* of buffered messages.
            # This means _append_formatted_text needs to be smarter or we need a different approach.

            # Refined approach: _append_formatted_text queues. The final visualDisplayComplete
            # will be emitted when the *last* character of the *last* message is displayed.
            self._append_formatted_text(message_content, gm_format, gradual)

    def stop_gradual_display(self):
        """Immediately stops any ongoing gradual text display and processes pending messages quickly."""
        logger.info("Stopping current gradual display and flushing pending messages.")
        if self._gradual_log_timer and self._gradual_log_timer.isActive():
            self._gradual_log_timer.stop()
        
        # If an iterator was active, display remaining text immediately
        if self._gradual_log_iterator:
            remaining_text = "".join(list(self._gradual_log_iterator))
            if remaining_text:
                cursor = self.log_text.textCursor()
                cursor.movePosition(QTextCursor.MoveOperation.End)
                if self._gradual_log_format:
                    cursor.insertText(remaining_text, self._gradual_log_format)
                else:
                    cursor.insertText(remaining_text)
                self.log_text.setTextCursor(cursor)
                self.log_text.ensureCursorVisible()
            self._gradual_log_iterator = None
            self._gradual_log_format = None

        self._is_gradual_log_active = False # Mark as not active
        
        # Process all pending messages immediately (non-gradual)
        while self._pending_log_messages:
            text, text_format, _ = self._pending_log_messages.pop(0) # Ignore original gradual flag
            logger.debug(f"Flushing pending message immediately: '{text[:50]}...'")
            if not text.endswith('\n'): text += '\n'
            cursor = self.log_text.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            cursor.insertText(text, text_format)
            self.log_text.setTextCursor(cursor)
            self.log_text.ensureCursorVisible()
            
        self.visualDisplayComplete.emit()

    def append_orchestrated_event_content(self, event_content: str, event_role: str, is_gradual: bool, event_id: Optional[str] = None):
        """
        Appends orchestrated event content to the combat log, using CombatDisplay's
        own settings for color formatting.
        """
        # Track current event id for logging/diagnostics
        try:
            self._current_text_event_id = event_id
            logger.info(f"CombatDisplay: render string event id={event_id} gradual={bool(is_gradual)} len={len(event_content) if isinstance(event_content, str) else 'N/A'}")
        except Exception:
            pass
        
        # Hide [DEV] lines unless dev mode is enabled
        try:
            if isinstance(event_content, str) and event_content.strip().startswith("[DEV]"):
                settings = QSettings("RPGGame", "Settings")
                if not settings.value("dev/enabled", False, type=bool):
                    # Consider visual complete so orchestrator does not stall
                    self.visualDisplayComplete.emit()
                    # Also directly notify orchestrator in case signal path is disrupted
                    try:
                        from core.base.engine import get_game_engine
                        eng = get_game_engine()
                        if eng and hasattr(eng, '_combat_orchestrator') and eng._combat_orchestrator.is_waiting_for_visual:
                            logger.debug(f"CombatDisplay: Direct notify orchestrator complete for DEV-suppressed id={event_id}")
                            eng._combat_orchestrator._handle_visual_display_complete()
                    except Exception:
                        pass
                    return
        except Exception:
            pass
        # Determine color/format based on event_role, event_content, and self.current_settings
        color_hex = self.current_settings.get("color_log_default", "#E0E0E0") # Default
        is_bold = False
        is_italic = False

        # Standardize role for key lookup
        role_lower = event_role.lower() if event_role else "system"
        content_lower = event_content.lower()

        # Precedence: Specific keywords first, then role-based, then default.
        if "critical hit" in content_lower or "defeated!" in content_lower or "was defeated" in content_lower:
            color_hex = self.current_settings.get("color_log_crit", "#FF0000") # Default red for crit
            is_bold = True
        elif "healed" in content_lower or ("gains" in content_lower and ("hp" in content_lower or "stamina" in content_lower)):
            color_hex = self.current_settings.get("color_log_heal", "#009600") # Default green for heal
        elif "round" in content_lower and "begins" in content_lower:
            color_hex = self.current_settings.get("color_log_round", "#0064FF") # Default blue for round
            is_bold = True
        elif "turn" in content_lower or "'s turn" in content_lower: # General turn info
            color_hex = self.current_settings.get("color_log_turn", "#0064C8") # Default light blue for turn
        elif "combat started" in content_lower or "combat ended" in content_lower or "victory!" in content_lower or "defeat!" in content_lower or "fled!" in content_lower or "surrender" in content_lower:
            color_hex = self.current_settings.get("color_log_combat_event", "#FFFFFF") # Default white for major combat events
            is_bold = True
        elif "misses" in content_lower or "fails" in content_lower or "resisted" in content_lower or "escape fails" in content_lower or "fumble" in content_lower:
            color_hex = self.current_settings.get("color_log_miss", "#969696") # Default gray for miss/fail
            is_italic = True
        elif "damage" in content_lower or ("loses" in content_lower and ("hp" in content_lower or "resolve" in content_lower)):
            color_hex = self.current_settings.get("color_log_damage", "#C80000") # Default dark red for damage
        elif "roll" in content_lower or "vs" in content_lower: # Dice rolls
            color_hex = self.current_settings.get("color_log_roll", "#C87800") # Default orange for rolls
        elif role_lower == "system":
            color_hex = self.current_settings.get("color_log_system_message", self.current_settings.get("color_log_default", "#E0E0E0"))
        elif role_lower == "gm": # Narrative content
            color_hex = self.current_settings.get("color_log_narrative", self.current_settings.get("color_log_default", "#E0E0E0"))
        elif event_content.startswith("[DEV]"): # Dev messages
            color_hex = self.current_settings.get("color_log_dev", "#646464"); is_italic = True;

        text_format = QTextCharFormat()
        try:
            text_format.setForeground(QColor(color_hex))
        except ValueError: # Fallback if color_hex is invalid
            logger.warning(f"Invalid color hex '{color_hex}' for combat log. Using default.")
            text_format.setForeground(QColor(self.current_settings.get("color_log_default", "#E0E0E0")))

        if is_bold: text_format.setFontWeight(QFont.Weight.Bold)
        if is_italic: text_format.setFontItalic(True)
        
        # Use the existing method to append with the determined format
        self._append_formatted_text(event_content, text_format, gradual=is_gradual)
```

### File: gui\components\command_input.py

```python
#!/usr/bin/env python3
"""
Command input widget for the RPG game GUI.
This module provides a widget for entering commands.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QLineEdit, QPushButton, 
    QCompleter, QVBoxLayout, QListWidget, QFrame
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QIcon, QPalette, QBrush, QPixmap

from gui.utils.resource_manager import get_resource_manager

class CommandInputWidget(QFrame):
    """Widget for entering commands."""
    
    # Signal emitted when a command is submitted
    command_submitted = Signal(str)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the command input widget."""
        super().__init__(parent)
        
        # Set frame properties
        self.setFrameShape(QFrame.StyledPanel)
        self.setContentsMargins(0, 0, 0, 0)
        
        # Command history
        self.command_history: List[str] = []
        self.history_index = -1
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Set frame background to transparent
        self.setStyleSheet("""
            CommandInputWidget {
                background-color: transparent;
                border: none;
            }
        """)
        
        # Create the command line edit with semi-transparent white background
        self.command_edit = QLineEdit()
        self.command_edit.setPlaceholderText("Enter a command or type 'help'...")
        self.command_edit.setStyleSheet("""
            QLineEdit {
                background-color: rgba(255, 255, 255, 0.7);
                color: #2e2e2e;
                border: 1px solid #c4b59d;
                border-radius: 4px;
                padding: 8px;
                font-family: 'Garamond', serif;
                font-size: 14pt;
                margin-left: 5px;
                margin-right: 5px;
            }
        """)
        
        # Create the submit button with generic button styling
        self.submit_button = QPushButton("Enter")
        self.submit_button.setStyleSheet("""
            QPushButton {
                background-image: url('images/gui/button_normal.png');
                background-position: center;
                background-repeat: no-repeat;
                background-color: transparent;
                color: #2e2e2e;
                border: none;
                padding: 8px 15px;
                font-weight: bold;
                font-family: 'Times New Roman', serif;
                min-width: 80px;
                min-height: 30px;
                max-width: 100px;
                margin-right: 5px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-image: url('images/gui/button_hover.png');
            }
            QPushButton:pressed {
                background-image: url('images/gui/button_pressed.png');
                color: #FF0000;
                font-weight: bold;
            }
        """)
        # Add widgets to the layout
        layout.addWidget(self.command_edit, 1)
        layout.addWidget(self.submit_button)
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Connect the submit button click
        self.submit_button.clicked.connect(self._submit_command)
        
        # Connect the command edit return key
        self.command_edit.returnPressed.connect(self._submit_command)
        
        # Connect the command edit key press event
        self.command_edit.keyPressEvent = self._command_key_press
    
    def _submit_command(self):
        """Submit the current command."""
        # Get the command text
        command = self.command_edit.text().strip()
        
        # Skip if empty
        if not command:
            return
        
        # Add to history
        if not self.command_history or self.command_history[-1] != command:
            self.command_history.append(command)
            if len(self.command_history) > 50:
                self.command_history.pop(0)
        
        # Reset history index
        self.history_index = -1
        
        # Emit signal
        self.command_submitted.emit(command)
        
        # Clear the edit
        self.command_edit.clear()
    
    def _command_key_press(self, event):
        """Handle key press events for the command edit."""
        # Check for up/down arrow keys for command history
        if event.key() == Qt.Key_Up:
            self._navigate_history(1)
        elif event.key() == Qt.Key_Down:
            self._navigate_history(-1)
        else:
            # Default handling
            QLineEdit.keyPressEvent(self.command_edit, event)
    
    def _navigate_history(self, direction: int):
        """Navigate the command history.
        
        Args:
            direction: 1 for older commands, -1 for newer commands.
        """
        if not self.command_history:
            return
        
        # Update history index
        new_index = self.history_index + direction
        
        # Clamp index
        if new_index >= len(self.command_history):
            new_index = len(self.command_history) - 1
        elif new_index < -1:
            new_index = -1
        
        self.history_index = new_index
        
        # Set text from history or clear
        if self.history_index == -1:
            self.command_edit.clear()
        else:
            self.command_edit.setText(self.command_history[-(self.history_index+1)])
            self.command_edit.selectAll()
    
    def clear(self):
        """Clear the command input."""
        self.command_edit.clear()

```

### File: gui\components\game_menu.py

```python
#!/usr/bin/env python3
"""
Game menu widget for the RPG game GUI.
This module provides a widget for game menu options.
"""

import logging
from typing import Optional

from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QPushButton, QButtonGroup, 
    QMenu, QToolButton, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon

class GameMenuWidget(QWidget):
    """Widget for game menu options."""
    
    # Signals for menu actions
    new_game_requested = Signal()
    save_game_requested = Signal()
    load_game_requested = Signal()
    settings_requested = Signal()
    llm_settings_requested = Signal()
    exit_requested = Signal()
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the game menu widget."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 5, 0, 5)
        
        # Style for buttons
        button_style = """
            QPushButton, QToolButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                font-weight: bold;
            }
            QPushButton:hover, QToolButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed, QToolButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
        """
        
        # Create menu buttons
        self.new_game_button = QPushButton("New Game")
        self.new_game_button.setStyleSheet(button_style)
        self.new_game_button.clicked.connect(self.new_game_requested.emit)
        
        # Save game button
        self.save_button = QPushButton("Save")
        self.save_button.setStyleSheet(button_style)
        self.save_button.clicked.connect(self.save_game_requested.emit)
        
        # Load game button
        self.load_button = QPushButton("Load")
        self.load_button.setStyleSheet(button_style)
        self.load_button.clicked.connect(self.load_game_requested.emit)
        
        # Settings button with dropdown
        self.settings_button = QToolButton()
        self.settings_button.setText("Settings")
        self.settings_button.setStyleSheet(button_style)
        self.settings_button.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        
        self.settings_menu = QMenu(self.settings_button)
        self.settings_action = self.settings_menu.addAction("Game Settings")
        self.settings_action.triggered.connect(self.settings_requested.emit)
        
        self.llm_settings_action = self.settings_menu.addAction("LLM Settings")
        self.llm_settings_action.triggered.connect(self.llm_settings_requested.emit)
        
        self.graphics_action = self.settings_menu.addAction("Graphics Settings")
        self.sound_action = self.settings_menu.addAction("Sound Settings")
        
        self.settings_button.setMenu(self.settings_menu)
        self.settings_button.setPopupMode(QToolButton.InstantPopup)
        
        # Exit button
        self.exit_button = QPushButton("Exit")
        self.exit_button.setStyleSheet(button_style)
        self.exit_button.clicked.connect(self.exit_requested.emit)
        
        # Add spacer to push buttons to the left
        layout.addWidget(self.new_game_button)
        layout.addWidget(self.save_button)
        layout.addWidget(self.load_button)
        layout.addWidget(self.settings_button)
        layout.addStretch()
        layout.addWidget(self.exit_button)

```

### File: gui\components\game_output.py

```python
# --- START OF FILE game_output.py ---

"""
Game output widget for the RPG game GUI.
This module provides a widget for displaying game output.
"""

import logging
from typing import List, Optional, Dict, Any, Iterator, Tuple

from PySide6.QtWidgets import QTextEdit, QWidget, QVBoxLayout, QStackedLayout, QHBoxLayout, QFrame, QColorDialog
from PySide6.QtGui import QTextCursor, QColor, QTextCharFormat, QFont, QPalette, QPixmap, QBrush
from PySide6.QtCore import Qt, QTimer, Signal, QSettings

from core.utils.logging_config import get_logger
from gui.components.skill_check_display import SkillCheckDisplay
from gui.utils.resource_manager import get_resource_manager
from core.stats.skill_check import SkillCheckResult

logger = get_logger("GUI")

class GameOutputWidget(QFrame):
    """Widget for displaying game output."""

    # --- ECFA Change: Add visualDisplayComplete signal ---
    visualDisplayComplete = Signal()
    # --- End ECFA Change ---

    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the game output widget."""
        super().__init__(parent)

        self.setFrameShape(QFrame.StyledPanel)
        self.setContentsMargins(0, 0, 0, 0)
        self.setStyleSheet("""
            GameOutputWidget {
                background-color: transparent;
                border: none;
            }
        """)

        self.resource_manager = get_resource_manager()
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setAcceptRichText(True)

        self.settings = QSettings("RPGGame", "Settings") 

        system_color = self.settings.value("style/system_msg_color", "#FF0000")
        font_color = self.settings.value("style/font_color", "#000000")
        font_family = self.settings.value("style/font_family", "Garamond")
        font_size = int(self.settings.value("style/font_size", 14))

        self.system_format = QTextCharFormat()
        self.system_format.setForeground(QColor(system_color))
        self.system_format.setFontWeight(QFont.Bold)

        self.gm_format = QTextCharFormat()
        self.gm_format.setForeground(QColor(font_color))
        gm_font = QFont(font_family, font_size)
        self.gm_format.setFont(gm_font)

        user_input_font_family = self.settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(self.settings.value("style/user_input_font_size", 14))
        user_input_font_color = self.settings.value("style/user_input_font_color", "#0d47a1")

        self.player_format = QTextCharFormat()
        self.player_format.setForeground(QColor(user_input_font_color))
        player_font = QFont(user_input_font_family, user_input_font_size)
        player_font.setItalic(True)  
        self.player_format.setFont(player_font)

        self.default_format = QTextCharFormat()
        self.default_format.setForeground(QColor(font_color))  
        default_font = QFont(font_family, font_size)
        self.default_format.setFont(default_font)

        self._setup_background()

        self.skill_check_display = SkillCheckDisplay()
        self.skill_check_display.setVisible(False)
        self.skill_check_display.display_finished.connect(self._on_skill_check_finished)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(0)

        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.addWidget(self.text_edit)

        self.skill_check_layout = QHBoxLayout()
        self.skill_check_layout.setContentsMargins(0, 0, 0, 0)
        self.skill_check_layout.setAlignment(Qt.AlignCenter)
        self.skill_check_layout.addWidget(self.skill_check_display)
        self.content_layout.addLayout(self.skill_check_layout)

        self.main_layout.addWidget(self.content_widget)

        self._gradual_text_iterator: Optional[Iterator[str]] = None
        self._gradual_text_format: Optional[QTextCharFormat] = None
        self._gradual_timer: Optional[QTimer] = None 
        self._is_gradual_display_active: bool = False
        self._pending_immediate_messages: List[Tuple[str, QTextCharFormat]] = [] # Changed to list for queueing

    def _update_formats(self):
        """Update text formats based on current settings."""
        settings = self.settings # Use self.settings

        # Update system message format
        system_color = settings.value("style/system_msg_color", "#FF0000")
        self.system_format.setForeground(QColor(system_color))

        # Update GM/narrator format
        font_color = settings.value("style/font_color", "#000000")
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))

        self.gm_format.setForeground(QColor(font_color))
        gm_font = QFont(font_family, font_size)
        self.gm_format.setFont(gm_font)

        # Update player format
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")

        self.player_format.setForeground(QColor(user_input_font_color))
        player_font = QFont(user_input_font_family, user_input_font_size)
        player_font.setItalic(True)
        self.player_format.setFont(player_font)

        # Update default format
        self.default_format.setForeground(QColor(font_color))
        default_font = QFont(font_family, font_size)
        self.default_format.setFont(default_font)

    def _setup_background(self):
        """Set up the styled background for the game output."""
        settings = self.settings # Use self.settings

        # Get background color, font family, font size, and font color from settings
        bg_color = settings.value("style/output_bg_color", "#D2B48C")
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        font_color = settings.value("style/font_color", "#000000")
        texture_name = settings.value("style/texture_name", "subtle_noise")
        output_opacity = int(settings.value("style/output_opacity", 100))

        # Calculate background opacity
        opacity_percent = output_opacity / 80.0

        # Create a frame around the text edit with decorative border
        self.setStyleSheet(f"""
            GameOutputWidget {{
                background-color: transparent;
                border: 2px solid #333333; /* Dark gray border to match panels */
                border-radius: 18px;
                padding: 3px;
            }}
        """)

        # Create a background-image URL based on texture name
        texture_path = ""
        if texture_name != "none":
            texture_path = f"background-image: url('images/gui/textures/{texture_name}.png');\n                background-repeat: repeat;\n"

        # Apply styled background with rounded edges
        self.text_edit.setStyleSheet(f"""
            QTextEdit {{
                background-color: rgba({int(QColor(bg_color).red())},
                                    {int(QColor(bg_color).green())},
                                    {int(QColor(bg_color).blue())},
                                    {opacity_percent});
                {texture_path}
                color: {font_color};
                border: none;
                border-radius: 15px;
                font-family: '{font_family}';
                font-size: {font_size}pt;
                padding: 20px;
                margin-left: 5px;
                margin-right: 5px;
            }}
            QScrollBar:vertical {{
                border: none;
                background-color: rgba(0, 0, 0, 20);
                width: 12px;
                border-radius: 6px;
                margin: 0px;
            }}
            QScrollBar::handle:vertical {{
                background-color: rgba(80, 80, 80, 150);
                min-height: 20px;
                border-radius: 6px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                height: 0px;
            }}
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {{
                background: none;
            }}
        """)

    def append_text(self, text: str, format: Optional[QTextCharFormat] = None, gradual: bool = True):
        """Append text to the output with the specified format.

        Args:
            text: The text to append
            format: The text format to apply
            gradual: Whether to display the text gradually (respects settings)
        """
        format_name = "None" # For logging
        if format == self.gm_format: format_name = "gm_format"
        elif format == self.system_format: format_name = "system_format"
        elif format == self.player_format: format_name = "player_format"
        elif format == self.default_format: format_name = "default_format"
        logging.debug(f"GameOutputWidget.append_text: Format: '{format_name}', Requested Gradual: {gradual}, Active Gradual: {self._is_gradual_display_active}, Text: '{text[:50]}...'")

        # Determine if gradual display should actually be used based on request AND global setting
        gradual_display_enabled_by_setting = self.settings.value("display/gradual_text_narrative", True, type=bool)
        effective_gradual = gradual and gradual_display_enabled_by_setting
        
        # Override for specific welcome/background texts to always be immediate
        if "CHARACTER BACKGROUND" in text.upper() or "WELCOME TO YOUR ADVENTURE" in text.upper() or "WELCOME BACK" in text.upper():
            logging.info("Special text detected, forcing immediate display for GameOutputWidget.")
            effective_gradual = False

        if not text.strip():
            logging.warning("GameOutputWidget: Attempting to append empty text, ignoring.")
            self.visualDisplayComplete.emit() 
            return

        if not effective_gradual and self._is_gradual_display_active:
            logging.info(f"GameOutputWidget: Queueing immediate message '{text[:50]}...' as a gradual display is active.")
            self._pending_immediate_messages.append((text, format if format else self.default_format))
            return

        if not self._is_gradual_display_active: # Can only start new display if not already active
            if not effective_gradual:
                logging.debug("GameOutputWidget: Appending immediate message directly.")
                self._insert_text_immediately(text, format) 
                self.visualDisplayComplete.emit() 
                self._process_pending_immediate_messages() 
            else:
                logging.debug(f"GameOutputWidget: Starting gradual display: '{text[:50]}...'")
                self._is_gradual_display_active = True
                # Ensure pending immediate queue is cleared *before* starting new gradual display
                # if any were processed just before this.
                if self._pending_immediate_messages:
                    logger.warning("GameOutputWidget: Starting new gradual display while pending immediate messages existed. This might indicate a logic flaw if they weren't processed.")
                    # self._process_pending_immediate_messages() # Process them now before starting new gradual one.

                self._gradual_text_iterator = iter(text)
                self._gradual_text_format = format if format else self.default_format

                cursor = self.text_edit.textCursor()
                cursor.movePosition(QTextCursor.End)
                self.text_edit.setTextCursor(cursor)

                if not self._gradual_timer:
                     self._gradual_timer = QTimer(self)
                     self._gradual_timer.setSingleShot(True)
                     self._gradual_timer.timeout.connect(self._display_next_char)
                
                char_delay_initial = self.settings.value("display/text_speed_delay_narrative", 30, type=int)
                char_delay_initial = max(1, char_delay_initial) # Ensure at least 1ms for timer
                QTimer.singleShot(char_delay_initial, self._display_next_char) # Start with configured delay
        else: # Gradual display is already active
            if effective_gradual: 
                logger.warning(f"GameOutputWidget: Ignoring NEW gradual text '{text[:30]}' because a gradual display is ALREADY active. This text should have been queued by the Orchestrator.")
                # To prevent stalling, immediately emit completion for this ignored text.
                self.visualDisplayComplete.emit()
            # If it was an *immediate* message while gradual was active, it was already queued above.

    def _insert_text_immediately(self, text: str, format: Optional[QTextCharFormat]):
        """Helper to append text immediately and add newlines."""
        cursor = self.text_edit.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.text_edit.setTextCursor(cursor)
        
        current_format = format if format else self.default_format
        cursor.setCharFormat(current_format)
        
        cursor.insertText(text)
        if not text.endswith('\n'):
            cursor.insertText('\n')
        cursor.insertText('\n') # Extra blank line
        self.text_edit.ensureCursorVisible()

    def _process_pending_immediate_messages(self):
        """Processes any queued immediate messages if gradual display is not active."""
        if self._is_gradual_display_active:
            return # Don't process if gradual is still running
        
        while self._pending_immediate_messages:
            text, text_format = self._pending_immediate_messages.pop(0)
            logging.info(f"GameOutputWidget: Processing pending immediate message '{text[:50]}...'")
            self._insert_text_immediately(text, text_format)
            # Emitting visualDisplayComplete for each processed pending message
            # might be too chatty for the orchestrator.
            # The orchestrator should ideally wait for the original gradual display to finish,
            # then this queue is flushed, and *then* the "overall" completion is signaled.
            # However, for simplicity, let's emit for each. Orchestrator must handle this.
            self.visualDisplayComplete.emit()

    def _display_next_char(self):
        """Displays the next character from the iterator and schedules the next call."""
        if not self._is_gradual_display_active or not self._gradual_text_iterator:
            if self._is_gradual_display_active: 
                self._is_gradual_display_active = False
                self.visualDisplayComplete.emit()
                self._process_pending_immediate_messages() 
            return

        try:
            char = next(self._gradual_text_iterator)
            cursor = self.text_edit.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.text_edit.setTextCursor(cursor)

            if self._gradual_text_format:
                cursor.setCharFormat(self._gradual_text_format)
            cursor.insertText(char)
            self.text_edit.ensureCursorVisible()

            # --- ECFA Change: Use unified settings key ---
            char_delay = self.settings.value("display/text_speed_delay", 30, type=int) 
            # --- End ECFA Change ---
            char_delay = max(5, char_delay)
            
            if self._gradual_timer: 
                self._gradual_timer.start(char_delay)

        except StopIteration:
            logging.debug("GameOutputWidget: Gradual display finished for one segment.")
            cursor = self.text_edit.textCursor()
            cursor.movePosition(QTextCursor.End)
            self.text_edit.setTextCursor(cursor)
            if not self.text_edit.toPlainText().endswith('\n\n'): 
                 if self.text_edit.toPlainText().endswith('\n'):
                     cursor.insertText('\n')
                 else:
                     cursor.insertText('\n\n')
            self.text_edit.ensureCursorVisible()

            self._is_gradual_display_active = False
            self._gradual_text_iterator = None
            self._gradual_text_format = None
            
            self.visualDisplayComplete.emit() 
            
            self._process_pending_immediate_messages()

        except Exception as e:
             logging.error(f"GameOutputWidget: Error during gradual display: {e}", exc_info=True)
             self._is_gradual_display_active = False
             self._gradual_text_iterator = None
             self._gradual_text_format = None
             if self._gradual_timer and self._gradual_timer.isActive():
                 self._gradual_timer.stop()
             self.visualDisplayComplete.emit() 
             self._pending_immediate_messages.clear()
             self._process_pending_immediate_messages() 
             
    def _insert_text(self, text: str, format: Optional[QTextCharFormat] = None):
        """Helper method to insert text directly with a format."""
        cursor = self.text_edit.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.text_edit.setTextCursor(cursor)
        if format:
            cursor.setCharFormat(format)
        else:
            cursor.setCharFormat(self.default_format) # Fallback to default
        cursor.insertText(text)
        self.text_edit.ensureCursorVisible()

    def append_system_message(self, message: str, gradual: bool = False):
        """Append a system message."""
        logging.debug(f"GAME_OUTPUT: append_system_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        self.append_text("[SYSTEM] " + message, self.system_format, gradual=gradual)

    def append_gm_message(self, message: str, gradual: bool = True):
        """Append a game master message."""
        logging.debug(f"GAME_OUTPUT: append_gm_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        
        # Special logging for reintroductory narrative debugging
        if "night air" in message.lower() or "find yourself" in message.lower():
            logging.info(f"LIFECYCLE_DEBUG: append_gm_message - This appears to be reintroductory narrative")
            logging.info(f"LIFECYCLE_DEBUG: Message length: {len(message)}")
            logging.info(f"LIFECYCLE_DEBUG: Gradual setting: {gradual}")
            logging.info(f"LIFECYCLE_DEBUG: Current gradual display active: {self._is_gradual_display_active}")
            logging.info(f"LIFECYCLE_DEBUG: Message preview: '{message[:200]}...'")
        
        processed_message = "\n".join(message.split("\n"))
        if "===== CHARACTER BACKGROUND =====" in message:
            logging.info("Character background detected, using immediate display for GM message")
            gradual = False
            
        logging.info(f"LIFECYCLE_DEBUG: About to call append_text with gradual={gradual}")
        self.append_text(processed_message, self.gm_format, gradual=gradual)
        logging.info(f"LIFECYCLE_DEBUG: append_text call completed")

    def append_player_message(self, message: str, gradual: bool = False):
        """Append a player message."""
        logging.debug(f"GAME_OUTPUT: append_player_message called. Gradual: {gradual}, Content: '{message[:50]}...'")
        self.append_text("You: " + message, self.player_format, gradual=gradual)

    def clear(self):
        """Clear the output."""
        # Stop any gradual display and clear state before clearing
        if self._gradual_timer and self._gradual_timer.isActive():
            self._gradual_timer.stop()
        self._is_gradual_display_active = False
        self._gradual_text_iterator = None
        self._gradual_text_format = None
        self._pending_immediate_message = None
        # Clear the text edit
        self.text_edit.clear()

    def show_skill_check(self, result: SkillCheckResult, context: str = "", duration_ms: int = 3000) -> None:
        """
        Display a skill check result with animation.

        Args:
            result: The SkillCheckResult object containing the check details
            context: Optional context description for the check
            duration_ms: How long to display the result (in milliseconds)
        """
        # Stop any gradual display and clear state before showing skill check
        if self._gradual_timer and self._gradual_timer.isActive():
            logging.debug("Stopping gradual display for skill check.")
            self._gradual_timer.stop()
        self._is_gradual_display_active = False
        self._gradual_text_iterator = None
        self._gradual_text_format = None
        self._pending_immediate_message = None

        # Show the skill check
        self.skill_check_display.show_check_result(result, context, duration_ms)

    def _on_skill_check_finished(self) -> None:
        """
        Handler for when the skill check display is finished.
        Returns focus to the text edit.
        """
        # Ensure the text edit is visible and has focus
        self.text_edit.setFocus()

    def process_skill_check_command(self, command: str) -> bool:
        """
        Process a skill check command from the narrative.

        Args:
            command: The command string in format {STAT_CHECK:<stat>:<difficulty>:<context>}

        Returns:
            True if the command was processed successfully, False otherwise
        """
        from core.agents.rule_checker import get_rule_checker_agent

        try:
            # Parse the command format {STAT_CHECK:<stat>:<difficulty>:<context>}
            parts = command.strip().split(':')
            if len(parts) < 3:
                logging.warning(f"Invalid STAT_CHECK command format: {command}")
                return False

            stat_type = parts[1].strip().upper()
            difficulty = int(parts[2].strip())
            context = parts[3].strip() if len(parts) > 3 else ""

            # Get the rule checker agent to perform the skill check
            rule_checker = get_rule_checker_agent()
            check_result = rule_checker.perform_skill_check(stat_type, difficulty, context)

            if not check_result["success"]:
                logging.error(f"Skill check failed: {check_result.get('error', 'Unknown error')}")
                return False

            # Display the skill check result
            self.show_skill_check(check_result["result"], check_result["context"])

            return True

        except Exception as e:
            logging.error(f"Error processing skill check command: {e}")
            return False

    def stop_gradual_display(self):
        """Immediately stops any ongoing gradual text display and processes pending messages quickly."""
        logging.info("GameOutputWidget: Stopping current gradual display and flushing pending messages.")
        if self._gradual_timer and self._gradual_timer.isActive():
            self._gradual_timer.stop()
        
        # If an iterator was active, display remaining text immediately
        if self._gradual_text_iterator:
            remaining_text = "".join(list(self._gradual_text_iterator))
            if remaining_text:
                self._insert_text_immediately(remaining_text, self._gradual_text_format)
            self._gradual_text_iterator = None
            self._gradual_text_format = None

        self._is_gradual_display_active = False # Mark as not active
        
        # Process all pending immediate messages
        self._process_pending_immediate_messages()
            
        # Emit completion after flushing everything, if no pending messages started new gradual display
        if not self._is_gradual_display_active:
            self.visualDisplayComplete.emit()
```

### File: gui\components\inventory_panel.py

```python
#!/usr/bin/env python3
"""
Inventory panel widget for the RPG game GUI.
This module provides a widget for displaying and interacting with the player's inventory.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QScrollArea, QFrame, QGroupBox, QListWidget, QListWidgetItem,
    QPushButton, QMenu, QToolButton, QSizePolicy, QComboBox, QLineEdit
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QFont, QPixmap, QIcon, QCursor, QColor

from core.inventory.item_manager import get_inventory_manager
from core.inventory.item_enums import ItemType
from core.utils.logging_config import get_logger

logger = get_logger("INVENTORY")

class InventoryPanelWidget(QScrollArea):
    """Widget for displaying and interacting with inventory."""
    
    # Signals for inventory actions
    item_use_requested = Signal(str)
    item_examine_requested = Signal(str)
    item_equip_requested = Signal(str)
    item_unequip_requested = Signal(str)
    item_drop_requested = Signal(str)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the inventory panel widget."""
        super().__init__(parent)
        
        # Set up the scroll area
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.setStyleSheet("""
            QScrollArea {
                background-color: #2D2D30;
                border: none;
            }
        """)
        
        # Create the main widget
        self.inventory_widget = QWidget()
        self.setWidget(self.inventory_widget)
        
        # Initialize item list
        self.items = []
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self.inventory_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Create inventory header
        self._create_header()
        
        # Create item list section
        self._create_item_list()
        
        # Create item details section
        self._create_item_details()
    
    def _create_header(self):
        """Create the inventory header section."""
        # Create header layout
        header_layout = QHBoxLayout()
        
        # Create currency group
        currency_group = QGroupBox("Currency")
        currency_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        currency_layout = QHBoxLayout(currency_group)
        
        # Create labels for currency
        gold_label = QLabel("Gold:")
        gold_label.setStyleSheet("color: #FFD700; font-weight: bold;")
        self.gold_value = QLabel("0")
        self.gold_value.setStyleSheet("color: #FFD700;")
        
        silver_label = QLabel("Silver:")
        silver_label.setStyleSheet("color: #C0C0C0; font-weight: bold;")
        self.silver_value = QLabel("0")
        self.silver_value.setStyleSheet("color: #C0C0C0;")
        
        copper_label = QLabel("Copper:")
        copper_label.setStyleSheet("color: #B87333; font-weight: bold;")
        self.copper_value = QLabel("0")
        self.copper_value.setStyleSheet("color: #B87333;")
        
        # Add currency labels to layout
        currency_layout.addWidget(gold_label)
        currency_layout.addWidget(self.gold_value)
        currency_layout.addWidget(silver_label)
        currency_layout.addWidget(self.silver_value)
        currency_layout.addWidget(copper_label)
        currency_layout.addWidget(self.copper_value)
        
        # Create weight group
        weight_group = QGroupBox("Weight")
        weight_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        weight_layout = QHBoxLayout(weight_group)
        
        # Create labels for weight
        current_weight_label = QLabel("Current:")
        current_weight_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.current_weight_value = QLabel("0.0")
        self.current_weight_value.setStyleSheet("color: #E0E0E0;")
        
        max_weight_label = QLabel("Max:")
        max_weight_label.setStyleSheet("color: #BBBBBB; font-weight: bold;")
        self.max_weight_value = QLabel("50.0")
        self.max_weight_value.setStyleSheet("color: #E0E0E0;")
        
        # Add weight labels to layout
        weight_layout.addWidget(current_weight_label)
        weight_layout.addWidget(self.current_weight_value)
        weight_layout.addWidget(max_weight_label)
        weight_layout.addWidget(self.max_weight_value)
        
        # Add groups to header layout
        header_layout.addWidget(currency_group)
        header_layout.addWidget(weight_group)
        
        # Add header layout to main layout
        self.main_layout.addLayout(header_layout)
    
    def _create_item_list(self):
        """Create the item list section."""
        # Create item list group
        item_list_group = QGroupBox("Items")
        item_list_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        item_list_layout = QVBoxLayout(item_list_group)
        
        # Create filter layout
        filter_layout = QHBoxLayout()
        
        # Create filter combobox
        filter_label = QLabel("Type:")
        filter_label.setStyleSheet("color: #BBBBBB;")
        
        self.filter_combo = QComboBox()
        # Populate from ItemType enum; store enum value as userData, None for All
        self.filter_combo.addItem("All", None)
        for itype in ItemType:
            label = itype.value.replace('_', ' ').title()
            self.filter_combo.addItem(label, itype.value)
        self.filter_combo.setStyleSheet("""
            QComboBox {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QComboBox::drop-down {
                border: none;
                border-left: 1px solid #555555;
            }
            QComboBox QAbstractItemView {
                background-color: #2D2D30;
                color: #E0E0E0;
                selection-background-color: #0E639C;
            }
        """)
        
        # Add a name search field
        search_label = QLabel("Search:")
        search_label.setStyleSheet("color: #BBBBBB;")
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Type to filter by item name...")
        self.search_edit.setStyleSheet("""
            QLineEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
        """)
        # Connect filter changes
        self.filter_combo.currentIndexChanged.connect(self._on_filter_changed)
        self.search_edit.textChanged.connect(self._on_filter_changed)
        
        # Add filter components to layout
        filter_layout.addWidget(filter_label)
        filter_layout.addWidget(self.filter_combo)
        filter_layout.addWidget(search_label)
        filter_layout.addWidget(self.search_edit, 1)
        
        # Create item list
        self.item_list = QListWidget()
        self.item_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.item_list.setAlternatingRowColors(True)
        self.item_list.setSelectionMode(QListWidget.SingleSelection)
        
        # Add the filter layout and item list to the item list layout
        item_list_layout.addLayout(filter_layout)
        item_list_layout.addWidget(self.item_list)
        
        # Create action buttons layout (for Use, Examine, Equip, Drop)
        action_button_layout = QHBoxLayout()
        action_button_layout.setSpacing(5)
        
        # Style for buttons
        button_style = """
            QPushButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                min-height: 25px; /* Ensure consistent height */
            }
            QPushButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
            QPushButton:disabled {
                background-color: #2A2A2A;
                color: #666666;
                border-color: #444444;
            }
        """
        
        # Create action buttons
        self.use_button = QPushButton("Use")
        self.use_button.setStyleSheet(button_style)
        self.use_button.clicked.connect(self._on_use_clicked)
        
        self.examine_button = QPushButton("Examine")
        self.examine_button.setStyleSheet(button_style)
        self.examine_button.clicked.connect(self._on_examine_clicked)
        
        self.equip_button = QPushButton("Equip")
        self.equip_button.setStyleSheet(button_style)
        self.equip_button.clicked.connect(self._on_equip_clicked)
        
        self.drop_button = QPushButton("Drop")
        self.drop_button.setStyleSheet(button_style)
        self.drop_button.clicked.connect(self._on_drop_clicked)
        
        # Disable buttons initially
        self.use_button.setEnabled(False)
        self.examine_button.setEnabled(False)
        self.equip_button.setEnabled(False)
        self.drop_button.setEnabled(False)
        
        # Add buttons to button layout
        action_button_layout.addWidget(self.use_button)
        action_button_layout.addWidget(self.examine_button)
        action_button_layout.addWidget(self.equip_button)
        action_button_layout.addWidget(self.drop_button)
        
        # Add action button layout to item list layout
        item_list_layout.addLayout(action_button_layout)

        # Create and add the "Collect Dropped Items" button
        self.collect_items_button = self._create_collect_items_button()
        item_list_layout.addWidget(self.collect_items_button)
        
        # Add item list group to main layout
        self.main_layout.addWidget(item_list_group)
        
        # Connect item selection signal
        self.item_list.itemSelectionChanged.connect(self._on_item_selection_changed)
        
        # Connect right-click context menu
        self.item_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.item_list.customContextMenuRequested.connect(self._show_context_menu)
        
    def _on_filter_changed(self):
        """Refresh the displayed inventory when filter changes."""
        try:
            inv_manager = get_inventory_manager()
            self.update_inventory(inv_manager)
        except Exception:
            # Safe fallback if inventory not available yet
            pass
        
    def _create_item_details(self):
        """Create the item details section."""
        # Create item details group
        item_details_group = QGroupBox("Item Details")
        item_details_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        
        item_details_layout = QVBoxLayout(item_details_group)
        
        # Create labels for item details
        self.item_name_label = QLabel("No item selected")
        self.item_name_label.setStyleSheet("font-size: 14pt; font-weight: bold; color: #E0E0E0;")
        
        self.item_type_label = QLabel("")
        self.item_type_label.setStyleSheet("font-size: 12pt; color: #CCCCCC;")
        
        self.item_description_label = QLabel("")
        self.item_description_label.setStyleSheet("color: #BBBBBB;")
        self.item_description_label.setWordWrap(True)
        
        # Add labels to item details layout
        item_details_layout.addWidget(self.item_name_label)
        item_details_layout.addWidget(self.item_type_label)
        item_details_layout.addWidget(self.item_description_label)
        
        # Create stats layout
        stats_layout = QGridLayout()
        
        # Add stats layout to item details layout
        item_details_layout.addLayout(stats_layout)
        
        # Add item details group to main layout
        self.main_layout.addWidget(item_details_group)
        
        # Add a stretch to push everything up
        self.main_layout.addStretch(1)
    
    def _on_item_selection_changed(self):
        """Handle item selection change."""
        logger.info("[INVENTORY] _on_item_selection_changed called.")
        selected_list_items = self.item_list.selectedItems()
        
        if not selected_list_items:
            logger.info("[INVENTORY] No item selected in QListWidget.")
            self.use_button.setEnabled(False)
            self.examine_button.setEnabled(False)
            self.equip_button.setEnabled(False)
            self.drop_button.setEnabled(False)
            self.item_name_label.setText("No item selected")
            self.item_type_label.setText("")
            self.item_description_label.setText("")
            logger.info("[INVENTORY] Buttons disabled, details cleared.")
            return
        
        list_item = selected_list_items[0]
        selected_item_id = list_item.data(Qt.UserRole) # Retrieve item_id
        logger.info(f"[INVENTORY] QListWidget selected item_id: {selected_item_id}")

        # Find the corresponding item dict in self.items (list of dicts)
        selected_item_dict = None
        for item_d in self.items:
            if item_d['id'] == selected_item_id:
                selected_item_dict = item_d
                break
        
        if not selected_item_dict:
            logger.error(f"[INVENTORY] CRITICAL: Selected item ID {selected_item_id} not found in internal self.items list. This should not happen if update_inventory is correct.")
            # Clear details and disable buttons as a fallback
            self.use_button.setEnabled(False); self.examine_button.setEnabled(False)
            self.equip_button.setEnabled(False); self.drop_button.setEnabled(False)
            self.item_name_label.setText("Error: Item not found"); self.item_type_label.setText(""); self.item_description_label.setText("")
            logger.info("[INVENTORY] Buttons disabled due to item not found in self.items.")
            return

        logger.info(f"[INVENTORY] Found item in self.items: {selected_item_dict.get('name')}")
        self.examine_button.setEnabled(True)
        self.drop_button.setEnabled(True)
        
        item_type_val = selected_item_dict.get('type', 'miscellaneous')
        is_equipped_val = selected_item_dict.get('equipped', False)

        can_use = item_type_val == 'consumable'
        self.use_button.setEnabled(can_use)
        
        can_be_equipped = item_type_val in ['weapon', 'armor', 'shield', 'accessory']
        if can_be_equipped:
            self.equip_button.setEnabled(True)
            self.equip_button.setText("Unequip" if is_equipped_val else "Equip")
        else:
            self.equip_button.setEnabled(False)
            self.equip_button.setText("Equip") 
        
        logger.info(f"[INVENTORY] Button states: Examine={self.examine_button.isEnabled()}, Drop={self.drop_button.isEnabled()}, Use={self.use_button.isEnabled()}, Equip={self.equip_button.isEnabled()} (Text: {self.equip_button.text()})")
            
        self.item_name_label.setText(selected_item_dict.get('name', 'Unknown Item'))
        self.item_type_label.setText(f"Type: {item_type_val.capitalize()}")
        
        inv_manager = get_inventory_manager() 
        full_item_obj = inv_manager.get_item(selected_item_id)
        if full_item_obj:
            self.item_description_label.setText(getattr(full_item_obj, 'description', 'No description available.'))
        else:
            self.item_description_label.setText(selected_item_dict.get('description', 'No description available.'))
            logger.warning(f"[INVENTORY] Could not fetch full Item object for ID {selected_item_id} to display description.")
            
    def _show_context_menu(self, position):
        """Show the context menu for the item list."""
        list_widget_item = self.item_list.itemAt(position)
        if not list_widget_item:
            return
        
        selected_item_id = list_widget_item.data(Qt.UserRole)
        if not selected_item_id:
            logger.warning("[INVENTORY] Context menu triggered on item with no ID.")
            return

        # Find the item dict in self.items to get its properties like type and equipped status
        item_dict = next((it_d for it_d in self.items if it_d['id'] == selected_item_id), None)
        if not item_dict:
            logger.error(f"[INVENTORY] Context menu: Item ID {selected_item_id} not found in internal self.items list.")
            return
        
        item_type_val = item_dict.get('type', 'miscellaneous')
        is_equipped_val = item_dict.get('equipped', False)
        item_name_for_log = item_dict.get('name', 'Unknown Item')

        logger.info(f"[INVENTORY] Showing context menu for item: '{item_name_for_log}' (ID: {selected_item_id})")

        context_menu = QMenu(self)
        context_menu.setStyleSheet("""
            QMenu {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #555555;
            }
            QMenu::item {
                padding: 5px 20px;
            }
            QMenu::item:selected {
                background-color: #0E639C;
            }
        """)
        
        examine_action = context_menu.addAction("Examine")
        use_action = None
        if item_type_val == 'consumable':
            use_action = context_menu.addAction("Use")
        
        equip_action = None
        can_be_equipped = item_type_val in ['weapon', 'armor', 'shield', 'accessory']
        if can_be_equipped:
            equip_action_text = "Unequip" if is_equipped_val else "Equip"
            equip_action = context_menu.addAction(equip_action_text)
        
        drop_action = context_menu.addAction("Drop")
        
        action = context_menu.exec_(QCursor.pos())
        
        if action == examine_action:
            logger.info(f"[INVENTORY] Context menu: Examine selected for {selected_item_id}")
            self.item_examine_requested.emit(selected_item_id)
        elif use_action and action == use_action:
            logger.info(f"[INVENTORY] Context menu: Use selected for {selected_item_id}")
            self.item_use_requested.emit(selected_item_id)
        elif equip_action and action == equip_action:
            if is_equipped_val:
                logger.info(f"[INVENTORY] Context menu: Unequip selected for {selected_item_id}")
                self.item_unequip_requested.emit(selected_item_id) 
            else:
                logger.info(f"[INVENTORY] Context menu: Equip selected for {selected_item_id}")
                self.item_equip_requested.emit(selected_item_id)
        elif action == drop_action:
            logger.info(f"[INVENTORY] Context menu: Drop selected for {selected_item_id}")
            self.item_drop_requested.emit(selected_item_id)
        else:
            logger.debug(f"[INVENTORY] Context menu dismissed or unknown action for {selected_item_id}")
            
    def _on_use_clicked(self):
        """Handle use button click."""
        logger.info("[INVENTORY] _on_use_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Use clicked, but no item selected.")
            return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            logger.info(f"[INVENTORY] Emitting item_use_requested for item ID: {selected_item_id}")
            self.item_use_requested.emit(selected_item_id)
        else:
            logger.warning("[INVENTORY] Use clicked, selected item has no ID.")
    
    def _on_examine_clicked(self):
        """Handle examine button click."""
        logger.info("[INVENTORY] _on_examine_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Examine clicked, but no item selected.")
            return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            logger.info(f"[INVENTORY] Emitting item_examine_requested for item ID: {selected_item_id}")
            self.item_examine_requested.emit(selected_item_id)
        else:
            logger.warning("[INVENTORY] Examine clicked, selected item has no ID.")
    
    def _on_equip_clicked(self):
        """Handle equip/unequip button click."""
        logger.info("[INVENTORY] _on_equip_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Equip/Unequip clicked, but no item selected.")
            return
        
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if not selected_item_id: 
            logger.warning("[INVENTORY] Equip/Unequip clicked, selected item has no ID.")
            return

        item_dict = next((it_d for it_d in self.items if it_d['id'] == selected_item_id), None)
        if not item_dict: 
            logger.error(f"[INVENTORY] Equip/Unequip clicked, but item ID {selected_item_id} not found in self.items.")
            return

        # Directly emit signals, MainWindow will handle mechanically
        if item_dict.get('equipped', False):
            logger.info(f"[INVENTORY] Emitting item_unequip_requested for item ID: {selected_item_id} (from button)")
            self.item_unequip_requested.emit(selected_item_id) 
        else:
            logger.info(f"[INVENTORY] Emitting item_equip_requested for item ID: {selected_item_id} (from button)")
            self.item_equip_requested.emit(selected_item_id)

    def _on_unequip_clicked(self):
        """Handle unequip button click."""
        self._get_selected_item_id(self.item_unequip_requested)
    
    def _on_drop_clicked(self):
        """Handle drop button click."""
        logger.info("[INVENTORY] _on_drop_clicked called.")
        selected_list_items = self.item_list.selectedItems()
        if not selected_list_items: 
            logger.warning("[INVENTORY] Drop clicked, but no item selected.")
            return
        selected_item_id = selected_list_items[0].data(Qt.UserRole)
        if selected_item_id:
            logger.info(f"[INVENTORY] Emitting item_drop_requested for item ID: {selected_item_id}")
            self.item_drop_requested.emit(selected_item_id)
        else:
            logger.warning("[INVENTORY] Drop clicked, selected item has no ID.")
    
    def _get_selected_item_id(self, signal):
        """Get the selected item ID and emit the signal."""
        # Get the selected item
        selected_items = self.item_list.selectedItems()
        
        if not selected_items:
            return
        
        # Get the item data
        item_index = self.item_list.row(selected_items[0])
        item = self.items[item_index]
        
        # Emit the signal with the item ID
        signal.emit(item.get('id', ''))
    
    def update_inventory(self, inventory_manager_instance: Optional[Any]): # Renamed for clarity
        """Update the inventory panel with inventory data.
        
        Args:
            inventory_manager_instance: The InventoryManager instance.
        """
        # Temporarily disconnect the signal to prevent issues during list update
        try:
            self.item_list.itemSelectionChanged.disconnect(self._on_item_selection_changed)
            logger.debug("InventoryPanelWidget: Disconnected itemSelectionChanged for update.")
        except (TypeError, RuntimeError):  # Catch if not connected or other Qt errors
            logger.debug("InventoryPanelWidget: itemSelectionChanged was not connected or error on disconnect.")
            pass 

        if not inventory_manager_instance:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")
            self.current_weight_value.setText("0.0")
            self.max_weight_value.setText("0.0") 
            self.item_list.clear()
            self.items = [] 
            # Reconnect the signal after clearing and before manual trigger
            self.item_list.itemSelectionChanged.connect(self._on_item_selection_changed)
            logger.debug("InventoryPanelWidget: Reconnected itemSelectionChanged after clear (no inventory manager).")
            self._on_item_selection_changed() 
            logger.warning("InventoryPanelWidget.update_inventory called with no InventoryManager instance.")
            return

        inv_manager = inventory_manager_instance
        logger.info(f"InventoryPanelWidget: Updating with InventoryManager instance ID: {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")


        if hasattr(inv_manager, 'currency') and inv_manager.currency:
            currency_obj = inv_manager.currency
            self.gold_value.setText(str(getattr(currency_obj, 'gold', 0)))
            self.silver_value.setText(str(getattr(currency_obj, 'silver', 0)))
            total_copper_val = getattr(currency_obj, '_copper', 0) 
            copper_per_silver_val = getattr(currency_obj, '_copper_per_silver', 100)
            self.copper_value.setText(str(total_copper_val % copper_per_silver_val))
        else:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")

        current_weight = getattr(inv_manager, 'get_current_weight', lambda: 0.0)()
        weight_limit = getattr(inv_manager, 'weight_limit', 0.0)
        self.current_weight_value.setText(f"{current_weight:.1f}")
        self.max_weight_value.setText(f"{weight_limit:.1f}")
        
        self.items = [] 
        self.item_list.clear()

        actual_item_objects = getattr(inv_manager, 'items', []) 
        
        logger.debug(f"InventoryPanel: Found {len(actual_item_objects)} item objects from InventoryManager instance {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}.")

        for item_obj in actual_item_objects:
            if not hasattr(item_obj, 'id') or not hasattr(item_obj, 'name') or not hasattr(item_obj, 'item_type'):
                logger.warning(f"InventoryPanel: Skipping item object due to missing attributes: {item_obj}")
                continue

            is_equipped_flag = False
            if hasattr(inv_manager, 'is_item_equipped'):
                is_equipped_flag = inv_manager.is_item_equipped(item_obj.id)
            
            gui_item_dict = {
                'id': item_obj.id,
                'name': item_obj.name,
                'type': item_obj.item_type.value.lower() if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type).lower(),
                'description': getattr(item_obj, 'description', ''),
                'count': getattr(item_obj, 'quantity', 1),
                'equipped': is_equipped_flag,
            }
            self.items.append(gui_item_dict) 

            # Unified filter: type (from ItemType) AND name query
            selected_type = self.filter_combo.currentData() if hasattr(self, 'filter_combo') else None
            item_type_for_filter = gui_item_dict.get('type', '').lower()
            name_query = (self.search_edit.text().strip().lower() if hasattr(self, 'search_edit') and self.search_edit else '')

            type_match = (selected_type is None) or (item_type_for_filter == str(selected_type).lower())
            item_name_display = gui_item_dict.get('name', 'Unknown Item')
            name_match = (not name_query) or (name_query in item_name_display.lower())

            if type_match and name_match:
                item_count_display = gui_item_dict.get('count', 1)
                list_widget_item = QListWidgetItem()
                display_text = item_name_display
                if item_count_display > 1 and getattr(item_obj, 'is_stackable', False):
                    display_text += f" ({item_count_display})"
                if gui_item_dict.get('equipped', False):
                    display_text += " (Equipped)"
                    list_widget_item.setForeground(QColor('#4CAF50')) 
                list_widget_item.setText(display_text)
                list_widget_item.setData(Qt.UserRole, gui_item_dict['id']) 
                self.item_list.addItem(list_widget_item)
        
        # Reconnect the signal and manually trigger update for item details
        self.item_list.itemSelectionChanged.connect(self._on_item_selection_changed)
        logger.debug("InventoryPanelWidget: Reconnected itemSelectionChanged after repopulation.")
        self._on_item_selection_changed() # Manually trigger to update details for the current selection (or no selection)

        logger.info(f"InventoryPanel updated with manager {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}. Displaying {self.item_list.count()} items after filter. Internal self.items count: {len(self.items)}.")
        """Update the inventory panel with inventory data.
        
        Args:
            inventory_manager_instance: The InventoryManager instance.
        """
        if not inventory_manager_instance:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")
            self.current_weight_value.setText("0.0")
            self.max_weight_value.setText("0.0") 
            self.item_list.clear()
            self.items = [] 
            self._on_item_selection_changed() 
            logger.warning("InventoryPanelWidget.update_inventory called with no InventoryManager instance.")
            return

        inv_manager = inventory_manager_instance
        logger.info(f"InventoryPanelWidget: Updating with InventoryManager instance ID: {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")


        if hasattr(inv_manager, 'currency') and inv_manager.currency:
            currency_obj = inv_manager.currency
            self.gold_value.setText(str(getattr(currency_obj, 'gold', 0)))
            self.silver_value.setText(str(getattr(currency_obj, 'silver', 0)))
            total_copper_val = getattr(currency_obj, '_copper', 0) 
            copper_per_silver_val = getattr(currency_obj, '_copper_per_silver', 100)
            self.copper_value.setText(str(total_copper_val % copper_per_silver_val))
        else:
            self.gold_value.setText("0")
            self.silver_value.setText("0")
            self.copper_value.setText("0")

        current_weight = getattr(inv_manager, 'get_current_weight', lambda: 0.0)()
        weight_limit = getattr(inv_manager, 'weight_limit', 0.0)
        self.current_weight_value.setText(f"{current_weight:.1f}")
        self.max_weight_value.setText(f"{weight_limit:.1f}")
        
        self.items = [] 
        self.item_list.clear()

        actual_item_objects = getattr(inv_manager, 'items', []) 
        
        logger.debug(f"InventoryPanel: Found {len(actual_item_objects)} item objects from InventoryManager instance {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}.")

        for item_obj in actual_item_objects:
            if not hasattr(item_obj, 'id') or not hasattr(item_obj, 'name') or not hasattr(item_obj, 'item_type'):
                logger.warning(f"InventoryPanel: Skipping item object due to missing attributes: {item_obj}")
                continue

            is_equipped_flag = False
            if hasattr(inv_manager, 'is_item_equipped'):
                is_equipped_flag = inv_manager.is_item_equipped(item_obj.id)
            
            gui_item_dict = {
                'id': item_obj.id,
                'name': item_obj.name,
                'type': item_obj.item_type.value.lower() if hasattr(item_obj.item_type, 'value') else str(item_obj.item_type).lower(),
                'description': getattr(item_obj, 'description', ''),
                'count': getattr(item_obj, 'quantity', 1),
                'equipped': is_equipped_flag,
            }
            self.items.append(gui_item_dict) 

            # Unified filter: type (from ItemType) AND name query
            selected_type = self.filter_combo.currentData() if hasattr(self, 'filter_combo') else None
            item_type_for_filter = gui_item_dict.get('type', '').lower()
            name_query = (self.search_edit.text().strip().lower() if hasattr(self, 'search_edit') and self.search_edit else '')

            type_match = (selected_type is None) or (item_type_for_filter == str(selected_type).lower())
            item_name_display = gui_item_dict.get('name', 'Unknown Item')
            name_match = (not name_query) or (name_query in item_name_display.lower())

            if type_match and name_match:
                item_count_display = gui_item_dict.get('count', 1)
                list_widget_item = QListWidgetItem()
                display_text = item_name_display
                if item_count_display > 1 and getattr(item_obj, 'is_stackable', False):
                    display_text += f" ({item_count_display})"
                if gui_item_dict.get('equipped', False):
                    display_text += " (Equipped)"
                    list_widget_item.setForeground(QColor('#4CAF50')) 
                list_widget_item.setText(display_text)
                list_widget_item.setData(Qt.UserRole, gui_item_dict['id']) 
                self.item_list.addItem(list_widget_item)
        
        self._on_item_selection_changed()
        logger.info(f"InventoryPanel updated with manager {getattr(inv_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}. Displaying {self.item_list.count()} items after filter. Internal self.items count: {len(self.items)}.")

    def _create_collect_items_button(self):
        """Creates the 'Collect Items' button."""
        self.collect_button = QPushButton("Collect Dropped Items")
        self.collect_button.setStyleSheet(self.use_button.styleSheet()) # Reuse style
        self.collect_button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed) # Expand horizontally
        self.collect_button.clicked.connect(self._on_collect_items_clicked)
        self.collect_button.setEnabled(True) # Assuming always enabled, logic can be added if needed
        return self.collect_button
    
    def _on_collect_items_clicked(self):
        """Handle the 'Collect Dropped Items' button click."""
        logger.info("[INVENTORY] Collect Dropped Items button clicked.")
        # This is where the dialog for showing dropped items at the current location would be displayed.
        # For now, let's log and maybe show a placeholder message.
        
        # Placeholder for actual dialog:
        from PySide6.QtWidgets import QMessageBox
        QMessageBox.information(self, "Collect Items", "Functionality to show and collect dropped items at this location is not yet implemented.")
        
        # Future implementation would involve:
        # 1. Get current player location from GameState.
        # 2. Access a (new) system that tracks dropped items per location (e.g., LocationItemManager).
        # 3. Populate a dialog (e.g., DroppedItemsDialog) with these items.
        # 4. DroppedItemsDialog would have its own "Examine" and "Collect" actions.
        #    - "Collect" would move the item from the location's dropped list to player inventory.
```

### File: gui\components\journal_panel.py

```python
#!/usr/bin/env python3
"""
Journal panel widget for the RPG game GUI.
This module provides a widget for displaying and editing the player's journal.
"""

import logging
from typing import Optional, Dict, Any, List
from enum import Enum

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QScrollArea, QFrame, QGroupBox, QListWidget, QListWidgetItem,
    QPushButton, QTabWidget, QTextEdit, QSplitter, QTabBar
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QFont, QTextCharFormat, QColor

from core.base.state import get_state_manager
from gui.utils.resource_manager import get_resource_manager


class JournalSectionType(Enum):
    """Types of journal sections."""
    CHARACTER = 0
    QUESTS = 1
    NOTES = 2


class JournalPanelWidget(QScrollArea):
    """Widget for displaying and editing the journal."""
    
    # Signals for journal actions
    journal_updated = Signal(dict)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the journal panel widget."""
        super().__init__(parent)
        
        # Set up the scroll area
        self.setWidgetResizable(True)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setStyleSheet("""
            QScrollArea {
                background-color: #2D2D30;
                border: none;
            }
        """)
        
        # Create the main widget
        self.journal_widget = QWidget()
        self.setWidget(self.journal_widget)
        
        # Journal data structure
        self.journal_data = {
            "character": "",
            "quests": {},
            "notes": []
        }
        
        # Get state manager
        self.state_manager = get_state_manager()
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self.journal_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(15)
        
        # Create tab widget for sections
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
            }
            QTabWidget::pane {
                background-color: #333333;
                border: 1px solid #555555;
                border-top: none;
                border-radius: 0 0 5px 5px;
            }
            QTabBar::tab {
                background-color: #444444;
                color: #BBBBBB;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                padding: 8px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #333333;
                color: #E0E0E0;
                border-bottom: none;
            }
            QTabBar::tab:hover:!selected {
                background-color: #505050;
            }
        """)
        
        # Add tabs for each section
        self._setup_character_tab()
        self._setup_quests_tab()
        self._setup_notes_tab()
        
        # Add tab widget to main layout
        self.main_layout.addWidget(self.tab_widget)
    
    def _setup_character_tab(self):
        """Set up the character information tab."""
        # Create character tab
        character_tab = QWidget()
        character_layout = QVBoxLayout(character_tab)
        
        # Create character info editor
        self.character_info_editor = QTextEdit()
        self.character_info_editor.setPlaceholderText("Character bio and information will appear here...")
        self.character_info_editor.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
        """)
        self.character_info_editor.textChanged.connect(self._on_character_info_changed)
        
        # Add editor to layout
        character_layout.addWidget(self.character_info_editor)
        
        # Add tab to tab widget
        self.tab_widget.addTab(character_tab, "Character")
    
    def _setup_quests_tab(self):
        """Set up the quests tab."""
        # Create quests tab
        quests_tab = QWidget()
        quests_layout = QVBoxLayout(quests_tab)
        
        # Create quest status tabs
        self.quest_status_tabs = QTabWidget()
        self.quest_status_tabs.setStyleSheet("""
            QTabBar::tab {
                background-color: #333333;
                color: #BBBBBB;
                border: 1px solid #444444;
                border-bottom: none;
                border-top-left-radius: 3px;
                border-top-right-radius: 3px;
                padding: 5px 10px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2D2D30;
                color: #E0E0E0;
                border-bottom: none;
            }
            QTabBar::tab:hover:!selected {
                background-color: #3A3A3A;
            }
        """)
        
        # Create lists for active, completed, and failed quests
        self.active_quests_list = QListWidget()
        self.active_quests_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.active_quests_list.setAlternatingRowColors(True)
        self.active_quests_list.itemClicked.connect(self._on_quest_selected)
        self.active_quests_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.active_quests_list.customContextMenuRequested.connect(self._show_active_context_menu)
        
        self.completed_quests_list = QListWidget()
        self.completed_quests_list.setStyleSheet(self.active_quests_list.styleSheet())
        self.completed_quests_list.setAlternatingRowColors(True)
        self.completed_quests_list.itemClicked.connect(self._on_quest_selected)
        self.completed_quests_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.completed_quests_list.customContextMenuRequested.connect(lambda pos: self._show_notes_only_context_menu(self.completed_quests_list, pos))
        
        self.failed_quests_list = QListWidget()
        self.failed_quests_list.setStyleSheet(self.active_quests_list.styleSheet())
        self.failed_quests_list.setAlternatingRowColors(True)
        self.failed_quests_list.itemClicked.connect(self._on_quest_selected)
        self.failed_quests_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.failed_quests_list.customContextMenuRequested.connect(lambda pos: self._show_notes_only_context_menu(self.failed_quests_list, pos))
        
        # Add lists to quest status tabs
        self.quest_status_tabs.addTab(self.active_quests_list, "Active")
        self.quest_status_tabs.addTab(self.completed_quests_list, "Completed")
        self.quest_status_tabs.addTab(self.failed_quests_list, "Failed")
        
        # Create quest details view
        self.quest_details = QTextEdit()
        self.quest_details.setReadOnly(True)
        self.quest_details.setPlaceholderText("Select a quest to view details...")
        self.quest_details.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
            /* Colored spans for objective states */
            .obj-done { color: #90EE90; } /* light green */
            .obj-failed { color: #FF7F7F; } /* light red */
            .obj-pending { color: #E0E0E0; }
            .obj-mandatory { color: #FFD27F; } /* amber M/O tags */
        """)
        
        # Create splitter for quest list and details
        quests_splitter = QSplitter(Qt.Vertical)
        quests_splitter.addWidget(self.quest_status_tabs)
        quests_splitter.addWidget(self.quest_details)
        quests_splitter.setSizes([int(quests_tab.height() * 0.4), int(quests_tab.height() * 0.6)])
        
        # Add splitter to layout
        quests_layout.addWidget(quests_splitter)
        
        # Add tab to tab widget
        self.tab_widget.addTab(quests_tab, "Quests")
    
    def _setup_notes_tab(self):
        """Set up the personal notes tab."""
        # Create notes tab
        notes_tab = QWidget()
        notes_layout = QVBoxLayout(notes_tab)
        
        # Create notes list
        self.notes_list = QListWidget()
        self.notes_list.setStyleSheet("""
            QListWidget {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        self.notes_list.setAlternatingRowColors(True)
        self.notes_list.itemClicked.connect(self._on_note_selected)
        
        # Create note editor
        self.note_editor = QTextEdit()
        self.note_editor.setPlaceholderText("Select a note to edit or create a new one...")
        self.note_editor.setStyleSheet("""
            QTextEdit {
                background-color: #2D2D30;
                color: #E0E0E0;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px;
            }
        """)
        self.note_editor.textChanged.connect(self._on_note_text_changed)
        
        # Create buttons for note management
        button_layout = QHBoxLayout()
        
        # Style for buttons
        button_style = """
            QPushButton {
                background-color: #333333;
                color: #E0E0E0;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
            }
            QPushButton:hover {
                background-color: #444444;
                border-color: #666666;
            }
            QPushButton:pressed {
                background-color: #222222;
                border-color: #777777;
            }
            QPushButton:disabled {
                background-color: #2A2A2A;
                color: #666666;
                border-color: #444444;
            }
        """
        
        # Create buttons
        self.new_note_button = QPushButton("New Note")
        self.new_note_button.setStyleSheet(button_style)
        self.new_note_button.clicked.connect(self._on_new_note_clicked)
        
        self.delete_note_button = QPushButton("Delete Note")
        self.delete_note_button.setStyleSheet(button_style)
        self.delete_note_button.clicked.connect(self._on_delete_note_clicked)
        self.delete_note_button.setEnabled(False)
        
        self.save_note_button = QPushButton("Save Note")
        self.save_note_button.setStyleSheet(button_style)
        self.save_note_button.clicked.connect(self._on_save_note_clicked)
        self.save_note_button.setEnabled(False)
        
        # Add buttons to layout
        button_layout.addWidget(self.new_note_button)
        button_layout.addWidget(self.delete_note_button)
        button_layout.addStretch()
        button_layout.addWidget(self.save_note_button)
        
        # Create splitter for notes list and editor
        notes_splitter = QSplitter(Qt.Vertical)
        notes_splitter.addWidget(self.notes_list)
        
        # Create editor container with buttons
        editor_container = QWidget()
        editor_layout = QVBoxLayout(editor_container)
        editor_layout.setContentsMargins(0, 0, 0, 0)
        editor_layout.addWidget(self.note_editor)
        editor_layout.addLayout(button_layout)
        
        notes_splitter.addWidget(editor_container)
        notes_splitter.setSizes([int(notes_tab.height() * 0.3), int(notes_tab.height() * 0.7)])
        
        # Add splitter to layout
        notes_layout.addWidget(notes_splitter)
        
        # Add tab to tab widget
        self.tab_widget.addTab(notes_tab, "Notes")
    
    def _on_character_info_changed(self):
        """Handle character info text changes."""
        # Update journal data
        self.journal_data["character"] = self.character_info_editor.toPlainText()
        
        # Emit journal updated signal
        self._emit_journal_updated()
    
    def _on_quest_selected(self, item: QListWidgetItem):
        """Handle quest selection."""
        # Get the quest ID from the item
        quest_id = item.data(Qt.UserRole)
        
        # Get the quest data
        quest_status = self._get_current_quest_status()
        if quest_status and quest_id in self.journal_data["quests"]:
            quest_data = self.journal_data["quests"][quest_id]
            
            # Update quest details
            self.quest_details.clear()
            
            # Inline CSS to ensure colors are applied consistently
            style = (
                "<style>"
                ".obj-done{color:#6ac46a;}"
                ".obj-failed{color:#ff6b6b;}"
                ".obj-pending{color:#d0d0d0;}"
                ".obj-mandatory{color:#aaaaaa;font-style:italic;margin-left:6px;}"
                "</style>"
            )
            # Format the quest details
            html = style + f"<h2>{quest_data['title']}</h2>"
            html += f"<p><b>Status:</b> {quest_status}</p>"
            
            if "description" in quest_data:
                html += f"<p>{quest_data['description']}</p>"
            
            if "objectives" in quest_data and quest_data["objectives"]:
                html += "<h3>Objectives:</h3>"
                html += "<ul>"
                for objective in quest_data["objectives"]:
                    desc = objective.get('description', '')
                    completed = objective.get('completed', False)
                    failed = objective.get('failed', False)
                    mandatory = objective.get('mandatory', True)
                    tag = "(M)" if mandatory else "(O)"
                    # Build line with state class
                    cls = 'obj-pending'
                    if completed:
                        cls = 'obj-done'
                    elif failed:
                        cls = 'obj-failed'
                    # Tooltip for tag
                    tooltip = "Mandatory requirement" if mandatory else "Optional objective"
                    html += f"<li><span class='{cls}'>"
                    if completed:
                        html += f"<s>{desc}</s> <span class='obj-mandatory' title='{tooltip}'>{tag}</span>"
                    else:
                        html += f"{desc} <span class='obj-mandatory' title='{tooltip}'>{tag}</span>"
                    html += "</span></li>"
                html += "</ul>"
            
            if "rewards" in quest_data and quest_data["rewards"]:
                html += "<h3>Rewards:</h3>"
                html += "<ul>"
                for reward in quest_data["rewards"]:
                    html += f"<li>{reward}</li>"
                html += "</ul>"
            
            if "notes" in quest_data and quest_data["notes"]:
                html += "<h3>Notes:</h3>"
                html += f"<p>{quest_data['notes']}</p>"
            
            self.quest_details.setHtml(html)
    
    def _get_current_quest_status(self) -> Optional[str]:
        """Get the currently selected quest status tab."""
        current_tab_index = self.quest_status_tabs.currentIndex()
        if current_tab_index == 0:
            return "active"
        elif current_tab_index == 1:
            return "completed"
        elif current_tab_index == 2:
            return "failed"
        return None
    
    def _on_note_selected(self, item: QListWidgetItem):
        """Handle note selection."""
        # Get the note index from the item
        note_index = item.data(Qt.UserRole)
        
        # Enable delete and save buttons
        self.delete_note_button.setEnabled(True)
        self.save_note_button.setEnabled(True)
        
        # Get the note data
        if 0 <= note_index < len(self.journal_data["notes"]):
            note_data = self.journal_data["notes"][note_index]
            
            # Update note editor
            self.note_editor.setPlainText(note_data["content"])
            
            # Store the current note index
            self.note_editor.setProperty("note_index", note_index)
    
    def _on_note_text_changed(self):
        """Handle note text changes."""
        # Enable the save button if there is text
        self.save_note_button.setEnabled(bool(self.note_editor.toPlainText()))
    
    def _on_new_note_clicked(self):
        """Handle new note button click."""
        # Create a new note with a timestamp
        from datetime import datetime
        
        # Create new note with current time
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        new_note = {
            "title": f"Note {len(self.journal_data['notes']) + 1}",
            "timestamp": timestamp,
            "content": ""
        }
        
        # Add to journal data
        self.journal_data["notes"].append(new_note)
        
        # Add to list
        self._update_notes_list()
        
        # Select the new note
        self.notes_list.setCurrentRow(len(self.journal_data["notes"]) - 1)
        
        # Set focus to the editor
        self.note_editor.clear()
        self.note_editor.setFocus()
        
        # Store the current note index
        self.note_editor.setProperty("note_index", len(self.journal_data["notes"]) - 1)
        
        # Enable delete and save buttons
        self.delete_note_button.setEnabled(True)
        self.save_note_button.setEnabled(False)
    
    def _on_delete_note_clicked(self):
        """Handle delete note button click."""
        # Get the current note index
        note_index = self.note_editor.property("note_index")
        
        if note_index is not None and 0 <= note_index < len(self.journal_data["notes"]):
            # Remove from journal data
            self.journal_data["notes"].pop(note_index)
            
            # Update list
            self._update_notes_list()
            
            # Clear editor
            self.note_editor.clear()
            self.note_editor.setProperty("note_index", None)
            
            # Disable delete and save buttons
            self.delete_note_button.setEnabled(False)
            self.save_note_button.setEnabled(False)
            
            # Emit journal updated signal
            self._emit_journal_updated()
    
    def _on_save_note_clicked(self):
        """Handle save note button click."""
        # Get the current note index
        note_index = self.note_editor.property("note_index")
        
        if note_index is not None and 0 <= note_index < len(self.journal_data["notes"]):
            # Update note content
            self.journal_data["notes"][note_index]["content"] = self.note_editor.toPlainText()
            
            # Update the list item title (first line of content)
            content = self.note_editor.toPlainText()
            first_line = content.split("\n")[0][:30]
            if len(first_line) < len(content.split("\n")[0]):
                first_line += "..."
            
            self.journal_data["notes"][note_index]["title"] = first_line
            
            # Update list
            self._update_notes_list()
            
            # Reselect the note
            self.notes_list.setCurrentRow(note_index)
            
            # Emit journal updated signal
            self._emit_journal_updated()
    
    def _update_notes_list(self):
        """Update the notes list with current journal data.
        
        This list is intended to show only the user's free-form journal notes.
        Structured entries (e.g., objective notes saved with _type="objective_note")
        may be present in journal_data["notes"], but they don't have 'title'/'timestamp'.
        We skip any entries missing those keys to avoid KeyError and to keep the
        list focused.
        """
        # Save the currently selected row
        current_row = self.notes_list.currentRow()
        
        # Clear the list
        self.notes_list.clear()
        
        # Add notes to the list (only those with required fields)
        for i, note in enumerate(self.journal_data.get("notes", [])):
            title = note.get("title")
            timestamp = note.get("timestamp")
            if title is None or timestamp is None:
                # Skip structured notes (like objective notes) or malformed entries
                continue
            # Create list item
            item = QListWidgetItem(f"{title} - {timestamp}")
            item.setData(Qt.UserRole, i)
            
            # Add to list
            self.notes_list.addItem(item)
        
        # Restore selection if possible
        if 0 <= current_row < self.notes_list.count():
            self.notes_list.setCurrentRow(current_row)
    
    def _update_quests_lists(self):
        """Update the quest lists with current journal data."""
        # Save the currently selected items
        active_item = self.active_quests_list.currentItem()
        active_quest_id = active_item.data(Qt.UserRole) if active_item else None
        
        completed_item = self.completed_quests_list.currentItem()
        completed_quest_id = completed_item.data(Qt.UserRole) if completed_item else None
        
        failed_item = self.failed_quests_list.currentItem()
        failed_quest_id = failed_item.data(Qt.UserRole) if failed_item else None
        
        # Clear the lists
        self.active_quests_list.clear()
        self.completed_quests_list.clear()
        self.failed_quests_list.clear()
        
        # Add quests to the appropriate lists
        for quest_id, quest_data in self.journal_data["quests"].items():
            # Determine status: completed tab only if ALL mandatory objectives completed and none failed
            status = quest_data.get("status", "active")
            objectives = quest_data.get("objectives", [])
            mandatory_total = sum(1 for o in objectives if o.get('mandatory', True)) or 0
            mandatory_completed = sum(1 for o in objectives if o.get('mandatory', True) and o.get('completed', False))
            any_failed = any(o.get('failed', False) for o in objectives)
            fully_completed = (mandatory_total == mandatory_completed) and not any_failed
            if quest_data.get("abandoned"):
                status = "failed"
            elif fully_completed:
                status = "completed"
            elif any_failed:
                # Keep as active unless all failed or explicit fail policy
                status = "active"

            # Create list item (append ABANDONED suffix if applicable)
            base_title = quest_data.get("title", quest_id)
            if quest_data.get("abandoned") and status == "failed":
                base_title += " (ABANDONED)"
            item = QListWidgetItem(base_title)
            item.setData(Qt.UserRole, quest_id)
            
            # Add to the appropriate list based on status
            if status == "active":
                self.active_quests_list.addItem(item)
            elif status == "completed":
                self.completed_quests_list.addItem(item)
            elif status == "failed":
                self.failed_quests_list.addItem(item)
        
        # Restore selections if possible
        if active_quest_id:
            for i in range(self.active_quests_list.count()):
                if self.active_quests_list.item(i).data(Qt.UserRole) == active_quest_id:
                    self.active_quests_list.setCurrentRow(i)
                    break
        
        if completed_quest_id:
            for i in range(self.completed_quests_list.count()):
                if self.completed_quests_list.item(i).data(Qt.UserRole) == completed_quest_id:
                    self.completed_quests_list.setCurrentRow(i)
                    break
        
        if failed_quest_id:
            for i in range(self.failed_quests_list.count()):
                if self.failed_quests_list.item(i).data(Qt.UserRole) == failed_quest_id:
                    self.failed_quests_list.setCurrentRow(i)
                    break
    
    def _emit_journal_updated(self):
        """Emit the journal updated signal."""
        self.journal_updated.emit(self.journal_data)

    def clear_all(self):
        """Clear all journal UI content to a blank state (used before loading a save)."""
        self.journal_data = {"character": "", "quests": {}, "notes": []}
        self.character_info_editor.clear()
        self.active_quests_list.clear()
        self.completed_quests_list.clear()
        self.failed_quests_list.clear()
        self.quest_details.clear()
        self.notes_list.clear()

    def _show_active_context_menu(self, pos):
        """Show context menu for active quest list to manage objectives and notes."""
        item = self.active_quests_list.itemAt(pos)
        if not item:
            return
        quest_id = item.data(Qt.UserRole)
        quest = self.journal_data.get("quests", {}).get(quest_id)
        if not quest:
            return
        # Build a menu of objectives first
        from PySide6.QtWidgets import QMenu
        menu = QMenu(self)
        # Ensure opaque, dark context menu styling consistent with app theme
        menu.setStyleSheet(
            """
            QMenu {
                background-color: #2b2b2b; /* opaque dark background */
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
            }
            QMenu::item {
                background-color: transparent;
                padding: 6px 12px;
            }
            QMenu::item:selected {
                background-color: #3a3a3a; /* selection color */
            }
            QMenu::separator {
                height: 1px;
                background: #3a3a3a;
                margin: 4px 6px;
            }
            """
        )
        # For simplicity, act on currently selected quest objective via details text selection not implemented; offer global options
        complete_sub = menu.addMenu("Mark Objective as Completed")
        fail_sub = menu.addMenu("Mark Objective as Failed")
        notes_sub = menu.addMenu("See Notes for Objective")
        # Ensure submenus inherit opaque style (Qt sometimes needs explicit set)
        submenu_style = menu.styleSheet()
        complete_sub.setStyleSheet(submenu_style)
        fail_sub.setStyleSheet(submenu_style)
        notes_sub.setStyleSheet(submenu_style)
        # Developer and general quest actions
        menu.addSeparator()
        abandon_action = menu.addAction("Abandon Quest")
        abandon_action.triggered.connect(lambda: self._abandon_quest(quest_id))
        menu.addSeparator()
        dev_complete = menu.addAction("(dev) Mark Quest Completed")
        dev_failed = menu.addAction("(dev) Mark Quest Failed")
        dev_complete.triggered.connect(lambda: self._mark_quest_status(quest_id, "completed"))
        dev_failed.triggered.connect(lambda: self._mark_quest_status(quest_id, "failed"))
        # Add per-objective actions
        def add_actions_for_objectives(submenu, handler):
            for obj in quest.get("objectives", []):
                obj_id = obj.get("id")
                desc = obj.get("description", obj_id)
                act = submenu.addAction(desc)
                act.triggered.connect(lambda checked=False, qid=quest_id, oid=obj_id: handler(qid, oid))
        add_actions_for_objectives(complete_sub, self._mark_objective_completed)
        add_actions_for_objectives(fail_sub, self._mark_objective_failed)
        add_actions_for_objectives(notes_sub, self._open_objective_notes)
        menu.exec(self.active_quests_list.mapToGlobal(pos))

    def _mark_objective_completed(self, quest_id: str, objective_id: str):
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        for o in q.get("objectives", []):
            if o.get("id") == objective_id:
                o["completed"] = True
                o["failed"] = False
                break
        # Refresh details view to update colors/strikethrough
        self._update_quests_lists()
        self._refresh_current_quest_details(quest_id)
        self._emit_journal_updated()

    def _mark_objective_failed(self, quest_id: str, objective_id: str):
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        for o in q.get("objectives", []):
            if o.get("id") == objective_id:
                o["failed"] = True
                o["completed"] = False
                break
        # Refresh details view to update colors/strikethrough
        self._update_quests_lists()
        self._refresh_current_quest_details(quest_id)
        self._emit_journal_updated()

    def _open_objective_notes(self, quest_id: str, objective_id: str):
        # Minimal inline notes implementation: store under journal["notes"] as structured entries
        from PySide6.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton, QHBoxLayout
        dlg = QDialog(self)
        dlg.setWindowTitle("Objective Notes")
        layout = QVBoxLayout(dlg)
        editor = QTextEdit()
        # Load existing note if present
        notes_key = (quest_id, objective_id)
        existing = None
        if isinstance(self.journal_data.get("notes"), list):
            for n in self.journal_data["notes"]:
                if n.get("_type") == "objective_note" and n.get("quest_id") == quest_id and n.get("objective_id") == objective_id:
                    existing = n
                    break
        if existing:
            editor.setPlainText(existing.get("content", ""))
        layout.addWidget(editor)
        btns = QHBoxLayout()
        save_btn = QPushButton("Save")
        close_btn = QPushButton("Close")
        btns.addWidget(save_btn)
        btns.addStretch()
        btns.addWidget(close_btn)
        layout.addLayout(btns)
        
        def _save():
            content = editor.toPlainText()
            # Update or append note
            if existing:
                existing["content"] = content
            else:
                self.journal_data.setdefault("notes", []).append({
                    "_type": "objective_note",
                    "quest_id": quest_id,
                    "objective_id": objective_id,
                    "content": content,
                })
            self._emit_journal_updated()
            dlg.accept()
        save_btn.clicked.connect(_save)
        close_btn.clicked.connect(dlg.reject)
        dlg.exec()
    
    def _show_notes_only_context_menu(self, list_widget: QListWidget, pos):
        """Show a notes-only context menu for Completed/Failed lists."""
        item = list_widget.itemAt(pos)
        if not item:
            return
        quest_id = item.data(Qt.UserRole)
        quest = self.journal_data.get("quests", {}).get(quest_id)
        if not quest:
            return
        from PySide6.QtWidgets import QMenu
        menu = QMenu(self)
        # Ensure opaque styling matches active menu
        menu.setStyleSheet(
            """
            QMenu { background-color: #2b2b2b; color: #e0e0e0; border: 1px solid #3a3a3a; }
            QMenu::item { padding: 6px 12px; }
            QMenu::item:selected { background-color: #3a3a3a; }
            QMenu::separator { height: 1px; background: #3a3a3a; margin: 4px 6px; }
            """
        )
        notes_sub = menu.addMenu("See Notes for Objective")
        # Build set of objectives that actually have saved notes
        existing_obj_notes = set()
        try:
            for n in self.journal_data.get("notes", []):
                if n.get("_type") == "objective_note" and n.get("quest_id") == quest_id:
                    content = n.get("content", "")
                    if isinstance(content, str) and content.strip():
                        existing_obj_notes.add(n.get("objective_id"))
        except Exception:
            pass
        
        # Populate menu: clickable only for objectives with saved notes; others are disabled text
        from PySide6.QtGui import QAction
        any_clickable = False
        for obj in quest.get("objectives", []):
            obj_id = obj.get("id")
            desc = obj.get("description", obj_id)
            if obj_id in existing_obj_notes:
                act = notes_sub.addAction(desc)
                act.triggered.connect(lambda checked=False, qid=quest_id, oid=obj_id: self._open_objective_notes(qid, oid))
                any_clickable = True
            else:
                # Add a disabled action to show as plain text
                text_act = QAction(desc, notes_sub)
                text_act.setEnabled(False)
                notes_sub.addAction(text_act)
        if not any_clickable:
            placeholder = QAction("No notes available", notes_sub)
            placeholder.setEnabled(False)
            notes_sub.addAction(placeholder)
        menu.exec(list_widget.mapToGlobal(pos))
    
    def _mark_quest_status(self, quest_id: str, status: str):
        """Developer helper to set a quest's status directly (completed/failed)."""
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        if status == "completed":
            for o in q.get("objectives", []):
                if o.get("mandatory", True):
                    o["completed"] = True
                    o["failed"] = False
            q["status"] = "completed"
            q.pop("abandoned", None)
        elif status == "failed":
            # Mark as failed without changing individual objectives
            q["status"] = "failed"
            q.pop("abandoned", None)
        self._update_quests_lists()
        self._refresh_current_quest_details(quest_id)
        self._emit_journal_updated()

    def _abandon_quest(self, quest_id: str):
        """Abandon a quest after user confirmation: moves it to Failed and flags as abandoned."""
        from PySide6.QtWidgets import QMessageBox
        q = self.journal_data.get("quests", {}).get(quest_id)
        if not q:
            return
        title = q.get("title", quest_id)
        reply = QMessageBox.question(
            self,
            "Abandon Quest",
            f"Are you sure you want to abandon '{title}'? This will move it to Failed.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No,
        )
        if reply == QMessageBox.Yes:
            q["status"] = "failed"
            q["abandoned"] = True
            self._update_quests_lists()
            self._refresh_current_quest_details(quest_id)
            self._emit_journal_updated()
    
    def _refresh_current_quest_details(self, quest_id: str):
        """If the provided quest_id is currently selected in any tab, rebuild its details HTML.
        This ensures the colors for completed/failed objectives refresh immediately.
        """
        # Determine which list contains the quest
        for lst in (self.active_quests_list, self.completed_quests_list, self.failed_quests_list):
            for i in range(lst.count()):
                it = lst.item(i)
                if it.data(Qt.UserRole) == quest_id and it.isSelected():
                    # Rebuild by calling the selection handler
                    self._on_quest_selected(it)
                    return

    def update_journal(self, journal_data: Dict[str, Any] = None):
        """
        Update the journal panel with journal data.
        
        Args:
            journal_data: The journal data to display.
        """
        # If no journal data is provided, use the current state
        if journal_data is None:
            if self.state_manager and self.state_manager.current_state:
                if hasattr(self.state_manager.current_state, "journal"):
                    journal_data = self.state_manager.current_state.journal
                else:
                    logging.warning("No journal data available to update journal panel")
                    return
            else:
                logging.warning("No state available to update journal panel")
                return
        
        # Update journal data
        self.journal_data = journal_data
        
        # Update character info
        self.character_info_editor.setPlainText(journal_data.get("character", ""))
        
        # Update quests lists
        self._update_quests_lists()
        # If a quest is selected, refresh its details to ensure colors/styles render
        cur = self.active_quests_list.currentItem() or self.completed_quests_list.currentItem() or self.failed_quests_list.currentItem()
        if cur:
            self._on_quest_selected(cur)
        else:
            self.quest_details.clear()
        
        # Update notes list
        self._update_notes_list()

```

### File: gui\components\menu_panel.py

```python
#!/usr/bin/env python3
"""
Menu panel widget for the RPG game GUI.
This module provides a collapsible left menu panel.
"""

import logging
from typing import Optional, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QFrame, 
    QToolButton, QLabel, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QSize, QEasingCurve, Property
from PySide6.QtGui import QIcon, QPixmap

from gui.utils.resource_manager import get_resource_manager

class MenuPanelWidget(QFrame):
    """Collapsible left menu panel for the RPG game GUI."""
    
    # Signals for menu actions
    new_game_requested = Signal()
    save_game_requested = Signal()
    load_game_requested = Signal()
    settings_requested = Signal()
    llm_settings_requested = Signal()
    exit_requested = Signal()
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the menu panel widget."""
        super().__init__(parent)

        # Set the desired opacity (0 = fully transparent, 100 = fully opaque)
        menu_panel_opacity_percent = 50 # Example: 85% opaque (adjust as needed)

        # Convert percentage to alpha value (0.0 to 1.0)
        alpha_value = menu_panel_opacity_percent / 100.0

        # Define the base background color RGB values (from #333333)
        base_r, base_g, base_b = 51, 51, 51
        
        # Set frame properties using rgba for background
        self.setFrameShape(QFrame.StyledPanel)
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.setStyleSheet(f"""
            MenuPanelWidget {{
                /* Use rgba for background color with transparency */
                background-color: rgba({base_r}, {base_g}, {base_b}, {alpha_value}); 
                
                /* Keep other styles */
                border: 1px solid #555555; 
                border-radius: 5px;
            }}
            /* Ensure buttons inside the panel remain opaque (using their own styles) */
            /* No changes needed here as buttons have specific styles set later */
        """)
        

        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Create animation properties
        self._expanded = True
        self._animation = None
        self._expanded_width = 150  # Increase width from 100 to 120
        self._collapsed_width = 40  # Increase collapsed width from 30 to 40
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(5, 5, 10, 5)
        self.main_layout.setSpacing(10)
        
        # Create toggle button
        self.toggle_button = QToolButton()
        self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
        self.toggle_button.setIconSize(QSize(16, 16))
        self.toggle_button.setStyleSheet("""
            QToolButton {
                background-color: #444444;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QToolButton:hover {
                background-color: #555555;
            }
            QToolButton:pressed {
                background-color: #333333;
            }
        """)
        self.toggle_button.clicked.connect(self.toggle_expanded)
        
        # Create menu buttons
        self.new_game_button = self._create_menu_button("New Game", "new_game")
        self.new_game_button.clicked.connect(self.new_game_requested.emit)
        
        self.save_button = self._create_menu_button("Save", "save_game")
        self.save_button.clicked.connect(self.save_game_requested.emit)
        
        self.load_button = self._create_menu_button("Load", "load_game")
        self.load_button.clicked.connect(self.load_game_requested.emit)
        
        # Settings button
        self.settings_button = self._create_menu_button("Settings", "settings")
        self.settings_button.clicked.connect(self.settings_requested.emit)
        
        self.llm_settings_button = self._create_menu_button("LLM", "llm_settings")
        self.llm_settings_button.clicked.connect(self.llm_settings_requested.emit)
        
        self.exit_button = self._create_menu_button("Exit", "exit")
        self.exit_button.clicked.connect(self.exit_requested.emit)
        
        # Add buttons to layout
        self.main_layout.addWidget(self.toggle_button, 0, Qt.AlignRight)
        self.main_layout.addSpacing(50)
        self.main_layout.addWidget(self.new_game_button)
        self.main_layout.addWidget(self.save_button)
        self.main_layout.addWidget(self.load_button)
        self.main_layout.addWidget(self.settings_button)
        self.main_layout.addWidget(self.llm_settings_button)
        self.main_layout.addSpacing(100)
        self.main_layout.addWidget(self.exit_button)
        self.main_layout.addStretch(1)  
        
        # Set initial width
        self.setFixedWidth(self._expanded_width)
    
    def _create_menu_button(self, text: str, icon_name: str) -> QPushButton:
        """Create a styled menu button.
        
        Args:
            text: The button text
            icon_name: The icon name (without path or extension)
            
        Returns:
            The created button
        """
        button = QPushButton(text)
        button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        
        # Use generic button backgrounds instead of specific ones
        button.setStyleSheet("""
            QPushButton {
                background-image: url('images/gui/button_normal.png');
                background-position: center;
                background-repeat: no-repeat;
                background-color: transparent;

                color: #E0E0E0;
                border: none;
                padding: 8px;
                text-align: center;
                min-width: 100px;
                max-width: 110px;
                min-height: 35px;
                border-radius: 5px;
                margin-left: 5px;
                margin-right: 10px;
            }
            QPushButton:hover {
                background-image: url('images/gui/button_hover.png');
            }
            QPushButton:pressed {
                background-image: url('images/gui/button_pressed.png');
                color: #FF0000;
                font-weight: bold;
            }
        """)
        
        return button
    
    def toggle_expanded(self):
        """Toggle the expanded/collapsed state of the panel."""
        self.setExpanded(not self._expanded)
    
    def setExpanded(self, expanded: bool):
        """Set the expanded/collapsed state of the panel.
        
        Args:
            expanded: True to expand, False to collapse
        """
        if self._expanded == expanded:
            return
        
        # Update state
        self._expanded = expanded
        
        # Update toggle button icon
        if expanded:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
        else:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right"))
        
        # Hide/show buttons when collapsed/expanded
        for button in [
            self.new_game_button,
            self.save_button,
            self.load_button,
            self.settings_button,
            self.llm_settings_button,
            self.exit_button
        ]:
            # Store original text when collapsing
            if expanded:
                button.setText(button.property("original_text"))
                button.setVisible(True)
            else:
                if not button.property("original_text"):
                    button.setProperty("original_text", button.text())
                button.setText("")
                button.setVisible(False)
        
        # Only toggle button remains visible when collapsed
        if not expanded:
            self.toggle_button.setVisible(True)
        
        # Animate width change
        target_width = self._expanded_width if expanded else self._collapsed_width
        
        if self._animation:
            self._animation.stop()
        
        self._animation = QPropertyAnimation(self, b"minimumWidth")
        self._animation.setDuration(300)
        self._animation.setStartValue(self.width())
        self._animation.setEndValue(target_width)
        self._animation.setEasingCurve(QEasingCurve.InOutCubic)
        self._animation.start()
    
    def isExpanded(self) -> bool:
        """Get the expanded/collapsed state of the panel.
        
        Returns:
            True if expanded, False if collapsed
        """
        return self._expanded
    
    def sizeHint(self) -> QSize:
        """Get the recommended size for the widget.
        
        Returns:
            The recommended size
        """
        if self._expanded:
            return QSize(self._expanded_width, super().sizeHint().height())
        else:
            return QSize(self._collapsed_width, super().sizeHint().height())

```

### File: gui\components\right_panel.py

```python
#!/usr/bin/env python3
"""
Right panel widget for the RPG game GUI.
This module provides a collapsible, tabbed right panel.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QTabWidget, QFrame, 
    QHBoxLayout, QPushButton, QStackedWidget, QToolButton, QTabBar, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QSize, QEasingCurve, Property
from PySide6.QtGui import QIcon, QPixmap, QCursor

from gui.utils.resource_manager import get_resource_manager
from gui.components.character_sheet import CharacterSheetWidget
from gui.components.inventory_panel import InventoryPanelWidget
from gui.components.journal_panel import JournalPanelWidget

class CustomTabBar(QTabBar):
    """Custom tab bar that emits a signal when the selected tab is clicked again."""
    
    tab_clicked_twice = Signal(int)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._last_index = -1
    
    def mousePressEvent(self, event):
        """Handle mouse press events to detect double clicks on selected tabs."""
        index = self.tabAt(event.pos())
        
        if index != -1 and index == self.currentIndex():
            self.tab_clicked_twice.emit(index)
        
        # Let the normal event processing happen
        super().mousePressEvent(event)

class CollapsibleRightPanel(QFrame):
    """Collapsible, tabbed right panel for the RPG game GUI."""
    
    # Signals
    tab_changed = Signal(int)
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the right panel widget."""
        super().__init__(parent)
        
        # Set the desired opacity (0 = fully transparent, 100 = fully opaque)
        right_panel_opacity_percent = 50
        
        # Convert percentage to alpha value (0.0 to 1.0)
        alpha_value = right_panel_opacity_percent / 100.0

        # Define the base background color RGB values (from #333333)
        base_r, base_g, base_b = 51, 51, 51
        
        # Set frame properties using rgba for background
        self.setFrameShape(QFrame.StyledPanel)
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.setStyleSheet(f"""
            CollapsibleRightPanel {{
                /* Use rgba for background color with transparency */
                background-color: rgba({base_r}, {base_g}, {base_b}, {alpha_value}); 
                
                /* Keep other styles */
                border: 1px solid #555555; 
                border-radius: 5px;
            }}
            /* Child widgets like QTabWidget will have their own styles set below */
        """)
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Create animation properties
        self._expanded = True
        self._animation = None
        self._expanded_width = 480
        self._collapsed_width = 30
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)
        
        # Create tab widget with custom tab bar
        self.tab_widget = QTabWidget()
        self.custom_tab_bar = CustomTabBar()
        self.tab_widget.setTabBar(self.custom_tab_bar)
        
        # Connect custom tab bar signal
        self.custom_tab_bar.tab_clicked_twice.connect(self.toggle_expanded)
        
        # Style the tab widget
        self.tab_widget.setStyleSheet("""
            QTabWidget,
            QTabWidget QWidget, /* Target widgets directly inside QTabWidget */
            QTabWidget QScrollArea,
            QTabWidget QScrollArea > QWidget > QFrame, /* Target frames within scroll areas */
            QTabWidget QScrollArea > QWidget { /* Target viewport widget */
                background-color: transparent; /* Make immediate children transparent */
                color: #E0E0E0;
                border: none;
            }
            QTabWidget::pane { /* The area behind the tabs' content */
                background-color: #2E2E2E; /* Opaque dark color - slightly different from panel bg */
                border: 1px solid #444444;
                border-top: none; /* Remove top border as it's covered by tabs */
                border-radius: 0px; /* Pane doesn't need radius if panel has it */
                padding: 5px; /* Add some padding for content */
                margin: 0px;
            }
            QTabBar::tab { /* Individual tabs */
                background-color: #444444; /* Opaque tab background */
                color: #BBBBBB;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
                padding: 8px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected { /* Selected tab */
                background-color: #2E2E2E; /* Match the pane background */
                color: #E0E0E0;
                border-bottom: 1px solid #2E2E2E; /* Make it look connected */
            }
            QTabBar::tab:hover:!selected { /* Hovered non-selected tab */
                background-color: #505050;
            }
            /* Ensure specific content widgets (like CharacterSheetWidget) have transparent backgrounds */
            /* if you want the pane background (#2E2E2E) to show through */
            CharacterSheetWidget, InventoryPanelWidget, JournalPanelWidget {
                 background-color: transparent;
            }
        """)
        
        # Create tabs
        self.character_sheet = CharacterSheetWidget()
        self.inventory_panel = InventoryPanelWidget()
        self.journal_panel = JournalPanelWidget()
        
        # Add tabs
        self.tab_widget.addTab(self.character_sheet, "Character")
        self.tab_widget.addTab(self.inventory_panel, "Inventory")
        self.tab_widget.addTab(self.journal_panel, "Journal")
        
        # Create toggle button (only visible when collapsed)
        self.toggle_button = QToolButton()
        self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right")) # This icon might need to change based on state
        self.toggle_button.setIconSize(QSize(16, 16))
        self.toggle_button.setStyleSheet("""
            QToolButton {
                background-color: #444444;
                border: 1px solid #555555;
                border-radius: 3px;
                padding: 3px;
            }
            QToolButton:hover {
                background-color: #555555;
            }
            QToolButton:pressed {
                background-color: #333333;
            }
        """)
        self.toggle_button.clicked.connect(self.toggle_expanded)
        
        # Always show the toggle button
        self.toggle_button.setVisible(True)
        
        # Create stacked widget to switch between tab widget and collapsed view
        self.stacked_widget = QStackedWidget()
        self.stacked_widget.addWidget(self.tab_widget)  # Index 0: Expanded view with tabs
        
        # We don't use a separate collapsed view anymore
        # Instead, just modify the width of the panel while keeping tabs visible
        # This way, users can always see tab headers and expand the panel by clicking on them
        
        # Add toggle button directly to the main layout
        toggle_container = QWidget()
        toggle_layout = QHBoxLayout(toggle_container) # Changed to QHBoxLayout for horizontal alignment
        toggle_layout.setContentsMargins(0, 5, 5, 0) # Add right margin
        toggle_layout.addStretch() # Push button to the right
        toggle_layout.addWidget(self.toggle_button) # No alignment needed if stretch is used
        
        # Add toggle container to top of main layout
        self.main_layout.addWidget(toggle_container) # Add the container
        
        # Add stacked widget to main layout
        self.main_layout.addWidget(self.stacked_widget)
        
        # Set initial width
        self.setFixedWidth(self._expanded_width)
        
        # Connect tab changed signal
        self.tab_widget.currentChanged.connect(self._handle_tab_change)

    def _handle_tab_change(self, index):
        """Handle tab change event."""
        # Emit signal
        self.tab_changed.emit(index)
    
    def toggle_expanded(self, index=None):
        """Toggle the expanded/collapsed state of the panel."""
        self.setExpanded(not self._expanded)
    
    def setExpanded(self, expanded: bool):
        """Set the expanded/collapsed state of the panel.
        
        Args:
            expanded: True to expand, False to collapse
        """
        if self._expanded == expanded:
            return
        
        # Update state
        self._expanded = expanded
        
        # When collapsing, don't switch to the collapsed widget view
        # Instead, just resize the panel, keeping the tabs visible
        # This ensures users can still see and click on tabs
        
        # Animate width change
        target_width = self._expanded_width if expanded else self._collapsed_width
        
        if self._animation:
            self._animation.stop()
        
        # Animate the panel's fixedWidth property
        self._animation = QPropertyAnimation(self, b"fixedWidth") # Animate fixedWidth
        self._animation.setDuration(300)
        self._animation.setStartValue(self.width())
        self._animation.setEndValue(target_width)
        self._animation.setEasingCurve(QEasingCurve.InOutCubic)
        self._animation.start()

        # Update toggle button icon
        if self._expanded:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_right"))
            self.toggle_button.setToolTip("Collapse Panel")
        else:
            self.toggle_button.setIcon(self.resource_manager.get_icon("toggle_button_left"))
            self.toggle_button.setToolTip("Expand Panel")
    
    def isExpanded(self) -> bool:
        """Get the expanded/collapsed state of the panel.
        
        Returns:
            True if expanded, False if collapsed
        """
        return self._expanded
    
    def sizeHint(self) -> QSize:
        """Get the recommended size for the widget.
        
        Returns:
            The recommended size
        """
        if self._expanded:
            return QSize(self._expanded_width, super().sizeHint().height())
        else:
            return QSize(self._collapsed_width, super().sizeHint().height())
    
    def update_character(self, character=None):
        """Update the character sheet tab with character data."""
        # If character is provided directly, update with it
        if character:
            self.character_sheet.update_character(character)
            return
        
        # Otherwise get current character from game state
        from core.base.state import get_state_manager
        state_manager = get_state_manager()
        if state_manager and state_manager.current_state and state_manager.current_state.player:
            # First ensure stats manager is initialized
            if state_manager.stats_manager:
                # Trigger an update with current state's player
                self.character_sheet.update_character(state_manager.current_state.player)
    
    def update_inventory(self, inventory=None):
        """Update the inventory tab with inventory data."""
        self.inventory_panel.update_inventory(inventory)
    
    def update_journal(self, journal_data=None):
        """Update the journal tab with journal data."""
        self.journal_panel.update_journal(journal_data)

```

### File: gui\components\skill_check_display.py

```python
#!/usr/bin/env python3
"""
Skill check display widget for the RPG game GUI.
This module provides a widget for displaying skill check results in a visual way.
"""

import logging
from typing import Optional, Dict, Any, List, Union
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, 
    QProgressBar, QGroupBox, QGraphicsOpacityEffect
)
from PySide6.QtCore import Qt, Signal, Slot, QPropertyAnimation, QTimer, QSize, Property
from PySide6.QtGui import QFont, QColor, QPainter, QPen, QBrush

from core.stats.skill_check import SkillCheckResult


class DiceWidget(QWidget):
    """Widget for displaying a dice roll result with animation."""
    
    def __init__(self, parent=None):
        """Initialize the dice widget."""
        super().__init__(parent)
        self.setMinimumSize(60, 60)
        self.setMaximumSize(60, 60)
        
        self._value = 1
        self._rolling = False
        self._roll_timer = QTimer(self)
        self._roll_timer.timeout.connect(self._update_rolling_value)
        
        # Set the background to be transparent
        self.setAttribute(Qt.WA_TranslucentBackground)
    
    def get_value(self) -> int:
        """Get the current dice value."""
        return self._value
    
    def set_value(self, value: int) -> None:
        """Set the dice value."""
        self._value = max(1, min(value, 20))  # Ensure value is between 1 and 20
        self.update()
    
    value = Property(int, get_value, set_value)
    
    def roll_animation(self, final_value: int, duration_ms: int = 1000) -> None:
        """
        Animate a dice roll to the final value.
        
        Args:
            final_value: The final dice value to show
            duration_ms: Duration of the animation in milliseconds
        """
        self._rolling = True
        self._final_value = max(1, min(final_value, 20))
        self._roll_timer.start(50)  # Update every 50ms
        
        # Set a timer to stop the rolling animation
        QTimer.singleShot(duration_ms, self._stop_rolling)
    
    def _update_rolling_value(self) -> None:
        """Update the dice value during rolling animation."""
        import random
        self.set_value(random.randint(1, 20))
    
    def _stop_rolling(self) -> None:
        """Stop the rolling animation and set the final value."""
        self._rolling = False
        self._roll_timer.stop()
        self.set_value(self._final_value)
    
    def paintEvent(self, event) -> None:
        """Paint the dice."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Define the dice colors based on the value
        if self._value == 20:
            # Critical success - gold
            bg_color = QColor(255, 215, 0)
            text_color = QColor(0, 0, 0)
        elif self._value == 1:
            # Critical failure - red
            bg_color = QColor(200, 0, 0)
            text_color = QColor(255, 255, 255)
        else:
            # Normal roll - white
            bg_color = QColor(240, 240, 240)
            text_color = QColor(0, 0, 0)
        
        # Draw the dice (d20 is icosahedron, but we'll draw a simplified pentagon)
        rect = self.rect().adjusted(2, 2, -2, -2)
        
        # Draw the background
        painter.setBrush(QBrush(bg_color))
        painter.setPen(QPen(QColor(20, 20, 20), 2))
        
        # Draw a circle as the dice
        painter.drawEllipse(rect)
        
        # Draw the value
        painter.setPen(QPen(text_color))
        font = QFont("Arial", 18, QFont.Bold)
        painter.setFont(font)
        painter.drawText(rect, Qt.AlignCenter, str(self._value))


class SkillCheckDisplay(QWidget):
    """Widget for displaying skill check results."""
    
    # Signal emitted when the display is finished
    display_finished = Signal()
    
    def __init__(self, parent=None):
        """Initialize the skill check display widget."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
        
        # Hide the widget by default
        self.setVisible(False)
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(5)
        
        # Create the title label
        self.title_label = QLabel("Skill Check")
        self.title_label.setStyleSheet("""
            font-size: 18px;
            font-weight: bold;
            color: #E0E0E0;
        """)
        self.title_label.setAlignment(Qt.AlignCenter)
        
        # Create the stat and difficulty display
        self.stat_layout = QHBoxLayout()
        
        self.stat_label = QLabel("Stat: STR")
        self.stat_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #BBBBBB;
        """)
        
        self.difficulty_label = QLabel("Difficulty: 15")
        self.difficulty_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #BBBBBB;
        """)
        
        self.stat_layout.addWidget(self.stat_label)
        self.stat_layout.addStretch(1)
        self.stat_layout.addWidget(self.difficulty_label)
        
        # Create the dice display
        self.dice_layout = QHBoxLayout()
        self.dice_layout.setAlignment(Qt.AlignCenter)
        
        self.dice_widget = DiceWidget()
        
        self.dice_layout.addWidget(self.dice_widget)
        
        # Create the result display
        self.result_layout = QHBoxLayout()
        
        self.mod_label = QLabel("Modifier: +0")
        self.mod_label.setStyleSheet("""
            font-size: 14px;
            color: #BBBBBB;
        """)
        
        self.total_label = QLabel("Total: 10")
        self.total_label.setStyleSheet("""
            font-size: 14px;
            font-weight: bold;
            color: #E0E0E0;
        """)
        
        self.success_label = QLabel("SUCCESS")
        self.success_label.setStyleSheet("""
            font-size: 16px;
            font-weight: bold;
            color: #66CC33;
        """)
        self.success_label.setAlignment(Qt.AlignCenter)
        
        self.result_layout.addWidget(self.mod_label)
        self.result_layout.addStretch(1)
        self.result_layout.addWidget(self.total_label)
        
        # Create the context display
        self.context_label = QLabel("Attempting to climb the steep cliff")
        self.context_label.setStyleSheet("""
            font-size: 14px;
            font-style: italic;
            color: #CCCCCC;
        """)
        self.context_label.setAlignment(Qt.AlignCenter)
        self.context_label.setWordWrap(True)
        
        # Add all elements to the main layout
        self.main_layout.addWidget(self.title_label)
        self.main_layout.addLayout(self.stat_layout)
        self.main_layout.addLayout(self.dice_layout)
        self.main_layout.addLayout(self.result_layout)
        self.main_layout.addWidget(self.success_label)
        self.main_layout.addWidget(self.context_label)
        
        # Set the widget styling
        self.setStyleSheet("""
            background-color: #333333;
            border: 2px solid #555555;
            border-radius: 8px;
        """)
        
        # Set a fixed size for the widget
        self.setFixedSize(300, 250)
    
    def show_check_result(self, result: SkillCheckResult, context: str = "", duration_ms: int = 3000) -> None:
        """
        Display a skill check result with animation.
        
        Args:
            result: The SkillCheckResult object containing the check details
            context: Optional context description for the check
            duration_ms: How long to display the result (in milliseconds)
        """
        # Update the labels with the check information
        self.title_label.setText(f"Skill Check: {result.stat_type}")
        self.stat_label.setText(f"Stat: {result.stat_type} ({int(result.stat_value)})")
        self.difficulty_label.setText(f"Difficulty: {result.difficulty}")
        self.mod_label.setText(f"Modifier: {'+' if result.modifier >= 0 else ''}{result.modifier}")
        self.total_label.setText(f"Total: {result.roll + result.modifier}")
        
        # Set success/failure display
        if result.success:
            if result.roll == 20:
                self.success_label.setText("CRITICAL SUCCESS!")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #FFD700;  /* Gold */
                """)
            else:
                self.success_label.setText("SUCCESS")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #66CC33;  /* Green */
                """)
        else:
            if result.roll == 1:
                self.success_label.setText("CRITICAL FAILURE!")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #CC3333;  /* Red */
                """)
            else:
                self.success_label.setText("FAILURE")
                self.success_label.setStyleSheet("""
                    font-size: 16px;
                    font-weight: bold;
                    color: #CC3333;  /* Red */
                """)
        
        # Set the context text
        self.context_label.setText(context)
        
        # Make the widget visible
        self.setVisible(True)
        
        # Create fade-in animation
        self.fade_in_effect = QGraphicsOpacityEffect(self)
        self.setGraphicsEffect(self.fade_in_effect)
        self.fade_in_effect.setOpacity(0)
        
        self.fade_in = QPropertyAnimation(self.fade_in_effect, b"opacity")
        self.fade_in.setDuration(300)
        self.fade_in.setStartValue(0)
        self.fade_in.setEndValue(1)
        self.fade_in.start()
        
        # Start the dice roll animation
        self.dice_widget.roll_animation(result.roll, 800)
        
        # Create a timer to hide the widget after duration_ms
        QTimer.singleShot(duration_ms, self._fade_out)
    
    def _fade_out(self) -> None:
        """Create and start a fade-out animation."""
        self.fade_out = QPropertyAnimation(self.fade_in_effect, b"opacity")
        self.fade_out.setDuration(500)
        self.fade_out.setStartValue(1)
        self.fade_out.setEndValue(0)
        self.fade_out.start()
        
        # Hide the widget after the animation finishes
        self.fade_out.finished.connect(self._hide_widget)
    
    def _hide_widget(self) -> None:
        """Hide the widget and emit the finished signal."""
        self.setVisible(False)
        self.display_finished.emit()


# For testing purposes
if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication
    from core.stats.stats_base import StatType
    
    # Create a test application
    app = QApplication(sys.argv)
    
    # Create a mock skill check result
    test_result = SkillCheckResult(
        stat_type=StatType.STRENGTH,
        stat_value=15,
        difficulty=12,
        roll=18,
        modifier=3,
        success=True,
        advantage=False,
        disadvantage=False
    )
    
    # Create and show the widget
    widget = SkillCheckDisplay()
    widget.show_check_result(test_result, "Attempting to lift the heavy boulder")
    widget.show()
    
    # Run the application
    sys.exit(app.exec())

```

### File: gui\components\stat_allocation_widget.py

```python
#!/usr/bin/env python3
"""
Stat allocation widget for character creation and level-up.
"""

import os
import json
import logging
from typing import Dict, List, Optional, Any, Tuple, Callable

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, 
    QFrame, QGroupBox, QPushButton, QToolTip, QSizePolicy,
    QSpacerItem, QDialog, QFrame 
)
from PySide6.QtCore import Qt, Signal, Slot, QPoint, QSize, QEvent
from PySide6.QtGui import QFont, QColor, QPalette, QMouseEvent, QIcon, QPixmap, QCursor

from core.stats.stats_base import StatType
from core.stats.stat_allocation import StatPointAllocator
from core.stats.stats_manager import StatsManager
from core.stats.stat_modifier_info import StatModifierInfo
from core.utils.logging_config import get_logger, log_migration_fix

# Log the import fix
log_migration_fix(
    "gui.components.stat_allocation_widget", 
    "from core.utils.logging_config import get_logger, LogCategory\nlogger = get_logger(LogCategory.GUI)", 
    "from core.utils.logging_config import get_logger\nlogger = get_logger(\"GUI\")"
)

logger = get_logger("GUI")


class TooltipLabel(QLabel):
    """A custom label that shows a tooltip when hovered over."""
    
    def __init__(self, text="", tooltip="", parent=None):
        super().__init__(text, parent)
        self.tooltip_text = tooltip
        self.setMouseTracking(True)
    
    def enterEvent(self, event):
        """Show tooltip when mouse enters label area."""
        if self.tooltip_text:
            QToolTip.showText(QCursor.pos(), self.tooltip_text, self)
        super().enterEvent(event)
    
    def leaveEvent(self, event):
        """Hide tooltip when mouse leaves label area."""
        if self.tooltip_text:
            QToolTip.hideText()
        super().leaveEvent(event)
    
    def setTooltipText(self, text):
        """Set the tooltip text."""
        self.tooltip_text = text


class StatInfoDialog(QDialog):
    """Dialog for displaying detailed information about a stat."""
    
    def __init__(self, stat_name: str, stat_value: int, modifier_info: StatModifierInfo, parent=None):
        super().__init__(parent)

        # Configure dialog
        self.setWindowTitle(f"{stat_name} Stat Information")
        self.setFixedSize(400, 400)
        self.setModal(True)
        self.setStyleSheet("""
            QDialog {
                background-color: #333333;
                color: #E0E0E0;
            }
        """)

        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(10)

        # Stat title
        title_label = QLabel(f"<h2>{stat_name}</h2>")
        title_label.setStyleSheet("color: #E0E0E0;")
        layout.addWidget(title_label)

        # Stat description
        stat_descriptions = {
            "STR": "<b>Strength</b> represents physical power and affects melee damage, carrying capacity, and physical force.",
            "DEX": "<b>Dexterity</b> represents agility, reflexes, and balance. It affects initiative, ranged attacks, and ability to dodge.",
            "CON": "<b>Constitution</b> represents health, stamina, and vital force. It affects hit points, resistance to poison, and fatigue.",
            "INT": "<b>Intelligence</b> represents reasoning, memory, and learning ability. It affects spell power, knowledge skills, and ability to analyze.",
            "WIS": "<b>Wisdom</b> represents intuition, perception, and willpower. It affects magical resistance, perception checks, and survival skills.",
            "CHA": "<b>Charisma</b> represents force of personality, persuasiveness, and leadership. It affects social interactions, prices, and follower loyalty.",
            # --- MODIFICATION: Add descriptions for WIL and INS ---
            "WIL": "<b>Willpower</b> represents mental fortitude, focus, and resistance to stress or mental influence. It affects concentration, resisting fear, and pushing through mental challenges.",
            "INS": "<b>Insight</b> represents understanding, intuition, and awareness of subtle details in situations and people. It affects perception checks, reading motives, and making intuitive leaps."
            # --- END MODIFICATION ---
        }

        description = stat_descriptions.get(stat_name, "")
        desc_label = QLabel(description)
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("color: #E0E0E0; background-color: #2D2D2D; padding: 10px; border-radius: 5px;")
        layout.addWidget(desc_label)

        # Current values section
        values_group = QGroupBox("Current Values")
        values_group.setStyleSheet("""
            QGroupBox {
                background-color: #2D2D2D;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        values_layout = QVBoxLayout(values_group)

        # Base value
        base_value = stat_value
        race_mod = modifier_info.race_modifiers.get(stat_name, 0)
        class_mod = modifier_info.class_modifiers.get(stat_name, 0)
        total_value = base_value + race_mod + class_mod
        ability_mod = (total_value - 10) // 2
        min_req = modifier_info.minimum_requirements.get(stat_name, 0)

        values_text = f"""<p><b>Base Value:</b> {base_value}</p>
        <p><b>Race Modifier:</b> <span style='color: {'#4CAF50' if race_mod > 0 else ('#F44336' if race_mod < 0 else '#CCCCCC')}'>{'+'+ str(race_mod) if race_mod > 0 else race_mod if race_mod != 0 else '0'}</span> ({modifier_info.race_name})</p>
        <p><b>Class Modifier:</b> <span style='color: {'#2196F3' if class_mod > 0 else ('#F44336' if class_mod < 0 else '#CCCCCC')}'>{'+'+ str(class_mod) if class_mod > 0 else class_mod if class_mod != 0 else '0'}</span> ({modifier_info.class_name})</p>
        <p><b>Total Value:</b> {total_value}</p>
        <p><b>Ability Modifier:</b> <span style='color: {'#4CAF50' if ability_mod > 0 else ('#F44336' if ability_mod < 0 else '#CCCCCC')}'>{'+'+ str(ability_mod) if ability_mod > 0 else ability_mod if ability_mod != 0 else '0'}</span></p>"""

        # Add minimum requirement if it exists
        if min_req > 0:
            values_text += f"""<p><b>Minimum Requirement:</b> <span style='color: {'#4CAF50' if total_value >= min_req else '#F44336'}>{min_req}</span> ({modifier_info.class_name})</p>"""

        values_label = QLabel(values_text)
        values_label.setWordWrap(True)
        values_layout.addWidget(values_label)
        layout.addWidget(values_group)

        # Game effects section
        effects_group = QGroupBox("Game Effects")
        effects_group.setStyleSheet("""
            QGroupBox {
                background-color: #2D2D2D;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)
        effects_layout = QVBoxLayout(effects_group)

        # Effects based on the stat
        effects = {
            "STR": ["Melee attack damage", "Carrying capacity", "Breaking objects", "Grappling"],
            "DEX": ["Ranged attack accuracy", "Initiative in combat", "Dodge chance", "Stealth"],
            "CON": ["Hit points", "Resistance to poison", "Stamina and fatigue", "Survival in harsh conditions"],
            "INT": ["Spell power", "Knowledge and lore", "Language comprehension", "Puzzle solving"],
            "WIS": ["Magical resistance", "Perception", "Survival skills", "Willpower checks"],
            "CHA": ["NPC reactions", "Prices when buying/selling", "Leadership", "Persuasion attempts"],
            # --- MODIFICATION: Add effects for WIL and INS ---
            "WIL": ["Resisting mental attacks/control", "Maintaining concentration (spells)", "Enduring stress/fear", "Pushing through fatigue"],
            "INS": ["Detecting lies/motives", "Noticing hidden details", "Understanding complex situations", "Making intuitive connections"]
            # --- END MODIFICATION ---
        }

        effects_text = "<p>This stat affects:</p><ul>"
        for effect in effects.get(stat_name, []):
            modifier_text = "+" if ability_mod > 0 else "-" if ability_mod < 0 else "±"
            effects_text += f"<li>{effect} <span style='color: {'#4CAF50' if ability_mod > 0 else ('#F44336' if ability_mod < 0 else '#CCCCCC')}'>({modifier_text})</span></li>"
        effects_text += "</ul>"

        effects_label = QLabel(effects_text)
        effects_label.setWordWrap(True)
        effects_layout.addWidget(effects_label)
        layout.addWidget(effects_group)

        # Class importance
        importance = "Unknown"
        importance_color = "#CCCCCC"

        if stat_name in modifier_info.recommended_stats.get("primary", []):
            importance = "Primary"
            importance_color = "#4CAF50"  # Green
        elif stat_name in modifier_info.recommended_stats.get("secondary", []):
            importance = "Secondary"
            importance_color = "#FFC107"  # Amber
        elif stat_name in modifier_info.recommended_stats.get("tertiary", []):
            importance = "Tertiary"
            importance_color = "#F44336"  # Red

        importance_text = f"<p><b>Importance for {modifier_info.class_name}:</b> <span style='color: {importance_color}'>{importance}</span></p>"
        importance_label = QLabel(importance_text)
        importance_label.setWordWrap(True)
        layout.addWidget(importance_label)

        # Close button
        close_button = QPushButton("Close")
        close_button.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #0b7dda;
            }
            QPushButton:pressed {
                background-color: #0a5999;
            }
        """)
        close_button.clicked.connect(self.accept)
        layout.addWidget(close_button, 0, Qt.AlignCenter)


class StatRow:
    """A class to hold UI elements for a stat row."""
    
    def __init__(self):
        self.name_label = None
        self.info_button = None
        self.base_label = None
        self.increase_button = None
        self.decrease_button = None
        self.race_mod_label = None
        self.class_mod_label = None
        self.total_label = None
        self.mod_label = None


class StatAllocationWidget(QWidget):
    """Widget for allocating stat points during character creation or level-up."""
    
    # Signal emitted when stats change
    stats_changed = Signal(dict)
    allocation_complete = Signal()
    
    def __init__(
        self, 
        stats_manager: StatsManager,
        race_name: str = "Human",
        class_name: str = "Warrior",
        total_points: int = 27,
        min_value: int = 8,
        max_value: int = 15,
        parent: Optional[QWidget] = None
    ):
        """
        Initialize the stat allocation widget.
        
        Args:
            stats_manager: The stats manager to modify
            race_name: The character's race
            class_name: The character's class
            total_points: Total points available for allocation
            min_value: Minimum stat value
            max_value: Maximum stat value
            parent: The parent widget
        """
        super().__init__(parent)
        
        # Set up the stat allocator
        self.stats_manager = stats_manager
        self.allocator = StatPointAllocator(stats_manager, total_points, min_value, max_value)
        
        # Load race and class modifiers
        self.modifier_info = StatModifierInfo()
        self.modifier_info.load_modifiers(race_name, class_name)
        
        # Create UI elements dictionary
        self.stat_rows = {}
        
        # Create the UI elements
        self._setup_ui()
        
        # Update the display
        self._update_all_stat_displays()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # Create the stats info header
        header_layout = QHBoxLayout()

        # Points remaining label
        self.points_label = QLabel(f"Points Remaining: {self.allocator.get_remaining_points()}")
        self.points_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                font-weight: bold;
                color: #E0E0E0;
            }
        """)
        header_layout.addWidget(self.points_label)

        # Add spacer
        header_layout.addStretch()

        # Add reset button
        self.reset_button = QPushButton("Reset")
        self.reset_button.setToolTip("Reset all stats to minimum values")
        self.reset_button.setFixedWidth(80)
        self.reset_button.clicked.connect(self._reset_stats)
        header_layout.addWidget(self.reset_button)

        # Add header to main layout
        main_layout.addLayout(header_layout)

        # Create the stat grid
        stats_group = QGroupBox("Character Stats")
        stats_group.setStyleSheet("""
            QGroupBox {
                background-color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
        """)

        stats_layout = QGridLayout(stats_group)
        stats_layout.setContentsMargins(15, 20, 15, 15)
        stats_layout.setHorizontalSpacing(5) # Reduced horizontal spacing
        stats_layout.setVerticalSpacing(10) # Keep vertical spacing reasonable

        col1_start = 0
        col2_start = 8
        separator_col = 7
        num_cols_per_stat = 7
        num_stats_per_col = 4 

        headers = ["Stat", "Base", "Adjust", "Race", "Class", "Total", "Mod"]
        mod_tooltip = (
            "<b>Ability Score Modifier</b><br>"
            "This is calculated as: (Total Stat Value - 10) ÷ 2, rounded down.<br><br>"
            "It represents the bonus or penalty applied to actions using this stat.<br>"
            "For example, a Strength of 14 gives a +2 modifier to melee attacks.<br><br>"
            "<i>Note: This is not the same as Race/Class modifiers, which directly modify the stat value.</i>"
        )

        for col_offset in [col1_start, col2_start]:
            for i, header_text in enumerate(headers):
                if header_text == "Mod":
                    header_widget = TooltipLabel(header_text, mod_tooltip)
                    header_widget.setStyleSheet("font-weight: bold; color: #CCCCCC; text-decoration: underline dotted;")
                    header_widget.setCursor(Qt.WhatsThisCursor)
                else:
                    header_widget = QLabel(header_text)
                    header_widget.setStyleSheet("font-weight: bold; color: #CCCCCC;")
                stats_layout.addWidget(header_widget, 0, col_offset + i, alignment=Qt.AlignCenter)

        all_stat_types = list(StatType) # Get all stat types
        for index, stat_type in enumerate(all_stat_types):
            stat_name = str(stat_type)

            # Determine row and column offset
            row = (index % num_stats_per_col) + 1 # Row index (1-based)
            col_offset = col1_start if index < num_stats_per_col else col2_start

            # Create row object to hold UI elements
            stat_row = StatRow()

            # Create stat name layout with info icon and impact indicators
            stat_name_layout = QHBoxLayout()
            stat_name_layout.setSpacing(2)
            stat_name_layout.setContentsMargins(0, 0, 0, 0)

            # Create stat name label with importance coloring
            stat_row.name_label = QLabel(stat_name)
            name_color = "#E0E0E0"
            if stat_name in self.modifier_info.recommended_stats.get("primary", []): name_color = "#4CAF50"
            elif stat_name in self.modifier_info.recommended_stats.get("secondary", []): name_color = "#FFD700"
            elif stat_name in self.modifier_info.recommended_stats.get("tertiary", []): name_color = "#E65100"
            stat_row.name_label.setStyleSheet(f"color: {name_color}; font-weight: bold;")
            stat_row.name_label.setCursor(Qt.PointingHandCursor)
            stat_row.name_label.mousePressEvent = lambda event, s=stat_type: self._show_stat_info(s)

            # Define icons and their individual tooltips
            impact_icons = {
                "STR": [("⚔️", "Melee Combat Damage"), ("🏋️", "Carrying Capacity")],
                "DEX": [("🏹", "Ranged Attack Accuracy"), ("👟", "Initiative/Dodge")], 
                "CON": [("❤️", "Health Points"), ("🛡️", "Damage Resistance")],
                "INT": [("📚", "Knowledge & Learning"), ("✨", "Spell Power")],
                "WIS": [("👁️", "Perception"), ("🙏", "Magical Resistance")], 
                "CHA": [("💬", "Persuasion"), ("👑", "Leadership/Prices")],
                "WIL": [("🧠", "Mental Fortitude"), ("🛡️", "Resist Influence")],
                "INS": [("💡", "Intuition/Problem Solving"), ("🧐", "Reading People/Situations")] 

            }

            stat_icons = impact_icons.get(stat_name, [])
            icons_layout = QHBoxLayout()
            icons_layout.setSpacing(1)
            icons_layout.setContentsMargins(0, 0, 0, 0)
            for icon, tooltip in stat_icons:
                icon_label = TooltipLabel(icon, tooltip)
                icon_label.setStyleSheet("font-size: 12px;")
                icon_label.setFixedWidth(20)
                icon_label.setAlignment(Qt.AlignCenter)
                icons_layout.addWidget(icon_label)
            icons_widget = QWidget()
            icons_widget.setLayout(icons_layout)
            icons_widget.setFixedWidth(45)
            icons_widget.setMouseTracking(True)

            # Create info icon button
            stat_row.info_button = QPushButton()
            stat_row.info_button.setIcon(self._create_info_icon())
            stat_row.info_button.setIconSize(QSize(16, 16))
            stat_row.info_button.setFixedSize(20, 20)
            stat_row.info_button.setStyleSheet("""
                QPushButton { background-color: transparent; border: none; }
                QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); border-radius: 10px; }
            """)
            stat_row.info_button.setCursor(Qt.PointingHandCursor)
            stat_row.info_button.setToolTip("Click for detailed information")
            stat_row.info_button.clicked.connect(lambda checked=False, s=stat_type: self._show_stat_info(s))

            # Add to name layout
            stat_name_layout.addWidget(stat_row.name_label)
            stat_name_layout.addWidget(icons_widget)
            stat_name_layout.addWidget(stat_row.info_button)

            # Create base value label
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            stat_row.base_label = QLabel(str(base_value))
            stat_row.base_label.setStyleSheet("color: #E0E0E0;")
            stat_row.base_label.setAlignment(Qt.AlignCenter)

            # Create adjustment buttons layout
            adjust_layout = QHBoxLayout()
            adjust_layout.setSpacing(2)
            project_root = os.path.normpath(os.path.join(os.path.dirname(__file__), '..', '..'))
            left_arrow_path = os.path.join(project_root, "images", "icons", "left_arrow.svg")
            right_arrow_path = os.path.join(project_root, "images", "icons", "right_arrow.svg")
            stat_row.decrease_button = QPushButton()
            stat_row.decrease_button.setIcon(QIcon(left_arrow_path))
            stat_row.decrease_button.setIconSize(QSize(16, 16)); stat_row.decrease_button.setFixedSize(24, 24)
            stat_row.decrease_button.setStyleSheet("QPushButton { background-color: #AA4444; color: white; font-weight: bold; border-radius: 4px; border: none; } QPushButton:hover { background-color: #CC5555; } QPushButton:pressed { background-color: #993333; } QPushButton:disabled { background-color: #555555; color: #888888; }")
            stat_row.decrease_button.clicked.connect(lambda checked=False, s=stat_type: self._decrease_stat(s))
            stat_row.increase_button = QPushButton()
            stat_row.increase_button.setIcon(QIcon(right_arrow_path))
            stat_row.increase_button.setIconSize(QSize(16, 16)); stat_row.increase_button.setFixedSize(24, 24)
            stat_row.increase_button.setStyleSheet("QPushButton { background-color: #4CAF50; color: white; font-weight: bold; border-radius: 4px; border: none; } QPushButton:hover { background-color: #66BB69; } QPushButton:pressed { background-color: #3B8C3E; } QPushButton:disabled { background-color: #555555; color: #888888; }")
            stat_row.increase_button.clicked.connect(lambda checked=False, s=stat_type: self._increase_stat(s))
            adjust_layout.addWidget(stat_row.decrease_button)
            adjust_layout.addWidget(stat_row.increase_button)

            # Create race modifier label
            race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
            mod_text = f"{race_mod:+d}" if race_mod != 0 else "0"
            stat_row.race_mod_label = QLabel(mod_text)
            stat_row.race_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'race')};")
            stat_row.race_mod_label.setAlignment(Qt.AlignCenter)

            # Create class modifier label
            class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
            mod_text = f"{class_mod:+d}" if class_mod != 0 else "0"
            stat_row.class_mod_label = QLabel(mod_text)
            stat_row.class_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'class')};")
            stat_row.class_mod_label.setAlignment(Qt.AlignCenter)

            # Create total value label
            total_value = base_value + race_mod + class_mod
            stat_row.total_label = QLabel(str(total_value))
            stat_row.total_label.setStyleSheet("color: #E0E0E0; font-weight: bold;")
            stat_row.total_label.setAlignment(Qt.AlignCenter)

            # Create modifier label
            modifier = (total_value - 10) // 2
            mod_text = f"{modifier:+d}" if modifier != 0 else "0"
            stat_row.mod_label = QLabel(mod_text)
            stat_row.mod_label.setStyleSheet(f"color: {'#4CAF50' if modifier > 0 else ('#F44336' if modifier < 0 else '#CCCCCC')};")
            stat_row.mod_label.setAlignment(Qt.AlignCenter)

            # Add mouseover tooltip to the entire row
            tooltip_text = self.modifier_info.get_tooltip_text(stat_name, base_value)
            for widget in [stat_row.name_label, stat_row.base_label, stat_row.race_mod_label,
                          stat_row.class_mod_label, stat_row.total_label, stat_row.mod_label]:
                if widget: widget.setToolTip(tooltip_text)

            # Add widgets to the grid using the calculated row and column offset
            stats_layout.addLayout(stat_name_layout, row, col_offset + 0)
            stats_layout.addWidget(stat_row.base_label, row, col_offset + 1, alignment=Qt.AlignCenter)
            stats_layout.addLayout(adjust_layout, row, col_offset + 2)
            stats_layout.addWidget(stat_row.race_mod_label, row, col_offset + 3, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.class_mod_label, row, col_offset + 4, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.total_label, row, col_offset + 5, alignment=Qt.AlignCenter)
            stats_layout.addWidget(stat_row.mod_label, row, col_offset + 6, alignment=Qt.AlignCenter)

            # Store the row for later reference
            self.stat_rows[stat_type] = stat_row

        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        separator.setStyleSheet("color: #555555;") # Make it visible
        stats_layout.addWidget(separator, 1, separator_col, num_stats_per_col, 1) # Span rows

        # Give more space to name columns, less to modifiers/buttons
        for col_offset in [col1_start, col2_start]:
            stats_layout.setColumnStretch(col_offset + 0, 3) # Name
            stats_layout.setColumnStretch(col_offset + 1, 1) # Base
            stats_layout.setColumnStretch(col_offset + 2, 2) # Adjust
            stats_layout.setColumnStretch(col_offset + 3, 1) # Race
            stats_layout.setColumnStretch(col_offset + 4, 1) # Class
            stats_layout.setColumnStretch(col_offset + 5, 1) # Total
            stats_layout.setColumnStretch(col_offset + 6, 1) # Mod
        stats_layout.setColumnStretch(separator_col, 0) # No stretch for separator
        # --- END MODIFICATION ---

        # Add stat color explanation (adjust row index)
        stat_colors_explanation = QLabel("* Stat colors: Green = Primary, Gold = Secondary, Dark Orange = Tertiary for your class")
        stat_colors_explanation.setStyleSheet("color: #AAAAAA; font-size: 10px; font-style: italic;")
        # Place below the grid, spanning all columns used
        stats_layout.addWidget(stat_colors_explanation, num_stats_per_col + 1, 0, 1, col2_start + num_cols_per_stat, Qt.AlignLeft)

        # Add the stats group to the main layout
        main_layout.addWidget(stats_group)

        # Create preset buttons (remains the same)
        presets_group = QGroupBox("Quick Presets")
        presets_group.setStyleSheet("""
            QGroupBox { background-color: #333333; border: 1px solid #555555; border-radius: 5px; margin-top: 15px; font-weight: bold; color: #E0E0E0; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top center; padding-left: 10px; padding-right: 10px; }
        """)
        presets_layout = QHBoxLayout(presets_group)
        presets_layout.setContentsMargins(15, 20, 15, 15); presets_layout.setSpacing(10)
        self.preset_buttons = {}
        for preset_name in self.modifier_info.archetype_presets:
            preset_button = QPushButton(preset_name)
            preset_button.setToolTip(self.modifier_info.archetype_presets[preset_name].get("description", ""))
            preset_button.clicked.connect(lambda checked=False, p=preset_name: self._apply_preset(p))
            presets_layout.addWidget(preset_button)
            self.preset_buttons[preset_name] = preset_button
        if not self.preset_buttons:
            balanced_button = QPushButton("Balanced"); balanced_button.setToolTip("Apply a balanced distribution of stats")
            balanced_button.clicked.connect(lambda: self._auto_allocate(balanced=True)); presets_layout.addWidget(balanced_button)
            focused_button = QPushButton("Focused"); focused_button.setToolTip("Focus on primary stats for your class")
            focused_button.clicked.connect(lambda: self._auto_allocate(balanced=False)); presets_layout.addWidget(focused_button)
        main_layout.addWidget(presets_group)

        # Add information about race/class effects (remains the same)
        info_text = f"""
        <p><b>{self.modifier_info.race_name}:</b> {self.modifier_info.race_description}</p>
        <p><b>{self.modifier_info.class_name}:</b> {self.modifier_info.class_description}</p>
        """
        info_label = QLabel(info_text); info_label.setWordWrap(True)
        info_label.setStyleSheet("QLabel { color: #CCCCCC; background-color: #2D2D2D; padding: 10px; border-radius: 5px; }")
        main_layout.addWidget(info_label)

        # Add stretcher to push everything up
        main_layout.addStretch(1)
    
    def _increase_stat(self, stat_type: StatType) -> None:
        """
        Increase a stat by one point.

        Args:
            stat_type: The stat to increase
        """
        if self.allocator.increase_stat(stat_type):
            # Update stat display
            self._update_stat_display(stat_type)

            # Update points remaining label
            remaining_points = self.allocator.get_remaining_points() # Get remaining points
            self.points_label.setText(f"Points Remaining: {remaining_points}")

            # Emit signal with current stats
            self._emit_stats_changed()

            # --- EMIT COMPLETION SIGNAL ---
            if remaining_points == 0:
                self.allocation_complete.emit()
    
    def _decrease_stat(self, stat_type: StatType) -> None:
        """
        Decrease a stat by one point.

        Args:
            stat_type: The stat to decrease
        """
        # --- GET PREVIOUS REMAINING ---
        prev_remaining_points = self.allocator.get_remaining_points()
        # --- END GET PREVIOUS REMAINING ---

        if self.allocator.decrease_stat(stat_type):
            # Update stat display
            self._update_stat_display(stat_type)

            # Update points remaining
            remaining_points = self.allocator.get_remaining_points() # Get remaining points
            self.points_label.setText(f"Points Remaining: {remaining_points}")

            # Emit signal with current stats
            self._emit_stats_changed()

            # --- EMIT COMPLETION SIGNAL (Check if went FROM 0) ---

            if remaining_points == 0 and prev_remaining_points != 0:
                 self.allocation_complete.emit()
            elif remaining_points != 0 and prev_remaining_points == 0:

                 pass 
            # --- END EMIT COMPLETION SIGNAL ---

    def are_points_fully_allocated(self) -> bool:
        """Checks if all available points have been allocated."""
        # Ensure allocator exists before calling its method
        return hasattr(self, 'allocator') and self.allocator.get_remaining_points() == 0

    def get_remaining_points(self) -> int:
        """Returns the number of points remaining to be allocated."""
         # Ensure allocator exists before calling its method
        return self.allocator.get_remaining_points() if hasattr(self, 'allocator') else 0
    
    def _update_stat_display(self, stat_type: StatType) -> None:
        """
        Update the display for a specific stat.
        
        Args:
            stat_type: The stat to update
        """
        if stat_type not in self.stat_rows:
            return
        
        stat_row = self.stat_rows[stat_type]
        stat_name = str(stat_type)
        
        # Get current values
        base_value = int(self.stats_manager.get_stat_value(stat_type))
        race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
        class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
        total_value = base_value + race_mod + class_mod
        modifier = (total_value - 10) // 2
        
        # Update labels
        stat_row.base_label.setText(str(base_value))
        stat_row.total_label.setText(str(total_value))
        
        mod_text = f"{modifier:+d}" if modifier != 0 else "0"
        stat_row.mod_label.setText(mod_text)
        stat_row.mod_label.setStyleSheet(f"color: {'#4CAF50' if modifier > 0 else ('#F44336' if modifier < 0 else '#CCCCCC')};")
        
        # Update tooltips with new values
        tooltip_text = self.modifier_info.get_tooltip_text(stat_name, base_value)
        for widget in [stat_row.name_label, stat_row.base_label, stat_row.race_mod_label, 
                      stat_row.class_mod_label, stat_row.total_label, stat_row.mod_label]:
            widget.setToolTip(tooltip_text)
        
        # Update button states
        stat_row.increase_button.setEnabled(self.allocator.can_increase_stat(stat_type))
        stat_row.decrease_button.setEnabled(self.allocator.can_decrease_stat(stat_type))
        
        # Check if total meets minimum requirement
        min_req = self.modifier_info.minimum_requirements.get(stat_name, 0)
        if min_req > 0 and total_value < min_req:
            stat_row.total_label.setStyleSheet(f"color: {self.modifier_info.below_minimum_color}; font-weight: bold;")
        else:
            stat_row.total_label.setStyleSheet("color: #E0E0E0; font-weight: bold;")
    
    def _update_all_stat_displays(self) -> None:
        """Update all stat displays."""
        for stat_type in StatType:
            self._update_stat_display(stat_type)
        
        # Update points remaining
        self.points_label.setText(f"Points Remaining: {self.allocator.get_remaining_points()}")
    
    def _reset_stats(self) -> None:
        """Reset all stats to minimum values."""
        self.allocator.reset_to_minimum()
        self._update_all_stat_displays()
        self._emit_stats_changed()
    
    def _apply_preset(self, preset_name: str) -> None:
        """
        Apply a preset stat distribution.
        
        Args:
            preset_name: The name of the preset to apply
        """
        preset_stats = self.modifier_info.apply_preset(preset_name)
        if not preset_stats:
            return
        
        # Reset stats first
        self.allocator.reset_to_minimum()
        
        # Apply preset values
        for stat_name, value in preset_stats.items():
            try:
                stat_type = StatType.from_string(stat_name)
                current_value = int(self.stats_manager.get_stat_value(stat_type))
                
                # Increase the stat until it reaches the preset value or we can't increase anymore
                while current_value < value and self.allocator.can_increase_stat(stat_type):
                    self.allocator.increase_stat(stat_type)
                    current_value = int(self.stats_manager.get_stat_value(stat_type))
            except ValueError:
                logger.warning(f"Unknown stat in preset: {stat_name}")
        
        # Update all displays
        self._update_all_stat_displays()
        self._emit_stats_changed()
    
    def _auto_allocate(self, balanced: bool = True) -> None:
        """
        Automatically allocate points.
        
        Args:
            balanced: If True, use balanced distribution; otherwise prioritize primary stats
        """
        # Get the recommended stats order
        priority_stats = []
        
        if self.modifier_info.recommended_stats:
            # Add primary stats first
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("primary", [])])
            
            # Then secondary stats
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("secondary", [])])
            
            # Then tertiary stats
            priority_stats.extend([StatType.from_string(s) for s in self.modifier_info.recommended_stats.get("tertiary", [])])
            
        # If no priorities defined, use a standard order
        if not priority_stats:
            priority_stats = list(StatType)
        
        # Reset to minimum first
        self.allocator.reset_to_minimum()
        
        # Apply automatic allocation
        self.allocator.allocate_points_automatically(priority_stats, balanced)
        
        # Update displays
        self._update_all_stat_displays()
        
        # Emit signal with current stats
        self._emit_stats_changed()
    
    def _emit_stats_changed(self) -> None:
        """Emit the stats_changed signal with current stats."""
        # Get current stats with modifiers applied
        stats = {}
        for stat_type in StatType:
            stat_name = str(stat_type)
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
            stats[stat_name] = {
                "base": base_value,
                "total": total_value,
                "modifier": (total_value - 10) // 2
            }
        
        # Emit the signal
        self.stats_changed.emit(stats)
    
    def update_race_class(self, race_name: str, class_name: str) -> None:
        """
        Update the race and class modifiers.
        
        Args:
            race_name: The new race name
            class_name: The new class name
        """
        logger.info(f"Updating race to {race_name} and class to {class_name}")
        
        # Check if we're already using this race/class combination
        if race_name == self.modifier_info.race_name and class_name == self.modifier_info.class_name:
            logger.debug(f"Race and class already set to {race_name} and {class_name}, skipping update")
            return
        
        # Re-create the modifier info with new race/class to ensure fresh loading
        self.modifier_info = StatModifierInfo()
        self.modifier_info.load_modifiers(race_name, class_name)
        
        # Update UI for each stat
        for stat_type in StatType:
            if stat_type in self.stat_rows:
                stat_name = str(stat_type)
                stat_row = self.stat_rows[stat_type]
                
                # Update race modifier label
                race_mod = self.modifier_info.race_modifiers.get(stat_name, 0)
                mod_text = f"{race_mod:+d}" if race_mod != 0 else "0"
                stat_row.race_mod_label.setText(mod_text)
                stat_row.race_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'race')}; text-align: center;")
                
                # Update class modifier label
                class_mod = self.modifier_info.class_modifiers.get(stat_name, 0)
                mod_text = f"{class_mod:+d}" if class_mod != 0 else "0"
                stat_row.class_mod_label.setText(mod_text)
                stat_row.class_mod_label.setStyleSheet(f"color: {self.modifier_info.get_stat_modifier_color(stat_name, 'class')}; text-align: center;")
                
                # Update stat name color based on importance for current class
                name_color = "#E0E0E0"  # Default color
                if stat_name in self.modifier_info.recommended_stats.get("primary", []):
                    name_color = "#4CAF50"  # Green for primary stats
                elif stat_name in self.modifier_info.recommended_stats.get("secondary", []):
                    name_color = "#FFD700"  # Brighter yellow for secondary stats
                elif stat_name in self.modifier_info.recommended_stats.get("tertiary", []):
                    name_color = "#E65100"  # Darker orange for tertiary stats
                
                # Properly update style
                stat_row.name_label.setStyleSheet(f"color: {name_color}; font-weight: bold;")
                # Make sure cursor is maintained
                stat_row.name_label.setCursor(Qt.PointingHandCursor)
        
        # Update all displays to reflect changes
        self._update_all_stat_displays()
        
        # Update preset buttons
        self._update_preset_buttons()
        
        # Update race/class info
        self._update_race_class_info()
    
    def _update_preset_buttons(self) -> None:
        """Update the preset buttons based on current class."""
        # Clear existing buttons
        for button in self.preset_buttons.values():
            button.setParent(None)
            button.deleteLater()
        
        # Reset buttons dictionary
        self.preset_buttons = {}
        
        # Get the presets group
        presets_group = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item.widget() and isinstance(item.widget(), QGroupBox) and item.widget().title() == "Quick Presets":
                presets_group = item.widget()
                break
        
        if not presets_group:
            return
        
        # Get the layout
        presets_layout = presets_group.layout()
        if not presets_layout:
            return
        
        # Clear the layout
        while presets_layout.count():
            item = presets_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Add new preset buttons
        for preset_name in self.modifier_info.archetype_presets:
            preset_button = QPushButton(preset_name)
            preset_button.setToolTip(self.modifier_info.archetype_presets[preset_name].get("description", ""))
            preset_button.clicked.connect(lambda checked=False, p=preset_name: self._apply_preset(p))
            presets_layout.addWidget(preset_button)
            self.preset_buttons[preset_name] = preset_button
        
        # Add balanced preset if no archetypes found
        if not self.preset_buttons:
            balanced_button = QPushButton("Balanced")
            balanced_button.setToolTip("Apply a balanced distribution of stats")
            balanced_button.clicked.connect(lambda: self._auto_allocate(balanced=True))
            presets_layout.addWidget(balanced_button)
            
            focused_button = QPushButton("Focused")
            focused_button.setToolTip("Focus on primary stats for your class")
            focused_button.clicked.connect(lambda: self._auto_allocate(balanced=False))
            presets_layout.addWidget(focused_button)
    
    def _update_race_class_info(self) -> None:
        """Update the race/class information label."""
        info_text = f"""
        <p><b>{self.modifier_info.race_name}:</b> {self.modifier_info.race_description}</p>
        <p><b>{self.modifier_info.class_name}:</b> {self.modifier_info.class_description}</p>
        """
        
        # Find the info label
        info_label = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item.widget() and isinstance(item.widget(), QLabel) and "background-color: #2D2D2D" in item.widget().styleSheet():
                info_label = item.widget()
                break
        
        if info_label:
            info_label.setText(info_text)
    
    def get_current_stats(self) -> Dict[str, Dict[str, int]]:
        """
        Get the current stat values.
        
        Returns:
            Dictionary of stat names and their values
        """
        stats = {}
        for stat_type in StatType:
            stat_name = str(stat_type)
            base_value = int(self.stats_manager.get_stat_value(stat_type))
            total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
            stats[stat_name] = {
                "base": base_value,
                "total": total_value,
                "modifier": (total_value - 10) // 2
            }
        return stats
    
    def meets_requirements(self) -> bool:
        """
        Check if the current stats meet all class minimum requirements.
        
        Returns:
            True if all requirements are met, False otherwise
        """
        for stat_type in StatType:
            stat_name = str(stat_type)
            min_req = self.modifier_info.minimum_requirements.get(stat_name, 0)
            if min_req > 0:
                base_value = int(self.stats_manager.get_stat_value(stat_type))
                total_value = base_value + self.modifier_info.get_combined_modifier(stat_name)
                if total_value < min_req:
                    return False
        return True
        
    def _create_info_icon(self) -> QIcon:
        """
        Create an information icon.

        Returns:
            QIcon: The information icon
        """
        # Create a pixmap
        pixmap = QPixmap(24, 24)
        pixmap.fill(Qt.transparent)

        # Draw an info icon using code
        import math
        from PySide6.QtGui import QPainter, QPen, QBrush
        from PySide6.QtCore import QRect

        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)

        # Draw circle
        pen = QPen(QColor("#2196F3"))
        pen.setWidth(2)
        painter.setPen(pen)
        painter.setBrush(QBrush(QColor("#2196F3").darker(150)))
        painter.drawEllipse(2, 2, 20, 20)

        # Draw "i" character
        pen = QPen(QColor("white"))
        painter.setPen(pen)
        painter.setFont(QFont("Arial", 14, QFont.Bold))
        painter.drawText(QRect(0, 0, 24, 24), Qt.AlignCenter, "i")

        painter.end()

        return QIcon(pixmap)
    
    def _show_stat_info(self, stat_type: StatType) -> None:
        """
        Show detailed information about a stat.

        Args:
            stat_type: The stat to show information for
        """
        stat_name = str(stat_type)
        base_value = int(self.stats_manager.get_stat_value(stat_type))

        # Create and show the dialog
        dialog = StatInfoDialog(stat_name, base_value, self.modifier_info, self)
        dialog.exec_()

    def get_allocated_stats(self) -> Dict[str, int]:
        """
        Retrieves the current base stat values as allocated by the user.

        Returns:
            A dictionary mapping stat names (e.g., "STR") to their current base integer values.
        """
        allocated_stats = {}
        for stat_type in StatType:
            # Get the current BASE value directly from the stats manager
            # as the allocator modifies the manager's state
            base_value = self.stats_manager.get_stat(stat_type).base_value
            allocated_stats[str(stat_type)] = int(base_value) # Ensure it's an integer
        return allocated_stats
```

### File: gui\components\status_bar.py

```python
#!/usr/bin/env python3
"""
Status bar for the RPG game GUI.
This module provides a status bar widget for displaying game status information.
"""

import logging
from typing import Optional
from enum import Enum

from PySide6.QtWidgets import QStatusBar, QLabel, QWidget, QHBoxLayout, QFrame
from PySide6.QtCore import Qt
from PySide6.QtGui import QPixmap

from gui.utils.resource_manager import get_resource_manager

class GameMode(Enum):
    """Different game modes that affect time progression."""
    NORMAL = "Normal"
    COMBAT = "Combat"
    BARTER = "Barter"

class GameStatusBar(QStatusBar):
    """Status bar for displaying game status information."""
    
    def __init__(self, parent: Optional[QWidget] = None):
        """Initialize the status bar."""
        super().__init__(parent)
        
        # Get resource manager
        self.resource_manager = get_resource_manager()
        
        # Apply styling
        self.setStyleSheet("""
            QStatusBar {
                background-color: #333333;
                color: #E0E0E0;
                border-top: 1px solid #555555;
            }
            QStatusBar::item {
                border: none;
            }
            QLabel {
                color: #E0E0E0;
                padding: 2px 10px;
                font-family: 'Times New Roman', serif;
            }
        """)
        
        # Current game mode
        self.current_mode = GameMode.NORMAL
        
        # Create status labels
        self.location_label = QLabel("Location: Not in game")
        self.time_label = QLabel("Time: Not in game")
        self.calendar_label = QLabel("Calendar: -")
        self.mode_label = QLabel("Mode: Normal")
        
        # Add permanent widgets
        self.addPermanentWidget(self.location_label)
        self.addPermanentWidget(self.time_label)
        self.addPermanentWidget(self.calendar_label)
        self.addPermanentWidget(self.mode_label)
    
    def update_status(self, location: str = "", game_time: str = "", calendar: str = "", mode: str = ""):
        """Update the status bar with the provided information.
        
        Args:
            location: The current location name.
            game_time: The current game time.
            mode: The current game mode (Normal, Combat, Barter).
        """
        if location:
            self.location_label.setText(f"Location: {location}")
        
        if game_time:
            capitalized_time = game_time.capitalize()
            self.time_label.setText(f"Time: {capitalized_time}")
        
        if calendar:
            self.calendar_label.setText(f"Calendar: {calendar}")
        
        # Update mode if provided
        if mode:
            try:
                self.current_mode = GameMode(mode)
                self.mode_label.setText(f"Mode: {self.current_mode.value}")
            except ValueError:
                # If invalid mode name, default to Normal
                self.current_mode = GameMode.NORMAL
                self.mode_label.setText(f"Mode: {self.current_mode.value}")

```

### File: gui\dialogs\settings\__init__.py

```python
"""
Settings dialogs for the RPG game GUI.
This package provides dialogs for configuring game settings.
"""

from gui.dialogs.settings.llm_settings_dialog import LLMSettingsDialog
from gui.dialogs.settings.settings_dialog import SettingsDialog

__all__ = ['LLMSettingsDialog', 'SettingsDialog']

```

### File: gui\dialogs\settings\agent_setup_tab.py

```python
#!/usr/bin/env python3
"""
Agent setup tab for the RPG game GUI.
This module provides a tab for configuring which LLM provider and model to use for each agent.
"""

import logging
from typing import Dict, Any, List, Optional, Tuple
import json
import os

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel, QPushButton,
    QComboBox, QTableWidget, QTableWidgetItem, QHeaderView, QSpinBox,
    QDoubleSpinBox, QGroupBox, QDialog, QDialogButtonBox
)
from PySide6.QtCore import Qt, Signal

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.settings_manager import get_settings_manager

# Get the module logger
logger = logging.getLogger("GUI")

class AgentSetupDialog(QDialog):
    """Dialog for configuring an agent's LLM settings."""
    
    def __init__(self, parent=None, agent_name: str = "", agent_settings: Dict[str, Any] = None):
        """Initialize the dialog.
        
        Args:
            parent: Parent widget.
            agent_name: Name of the agent being configured.
            agent_settings: Current agent settings.
        """
        super().__init__(parent)
        
        self.agent_name = agent_name
        self.agent_settings = agent_settings or {}
        self.provider_manager = get_provider_manager()
        self.settings_manager = get_settings_manager()
        
        self.setWindowTitle(f"Configure {agent_name.capitalize()} Agent")
        self.setMinimumWidth(450)
        
        self._setup_ui()
        self._populate_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Form layout
        form_layout = QFormLayout()
        
        # Provider dropdown
        self.provider_combo = QComboBox()
        self._populate_providers()
        form_layout.addRow("Provider:", self.provider_combo)
        
        # Model dropdown
        self.model_combo = QComboBox()
        form_layout.addRow("Model:", self.model_combo)
        
        # Temperature setting
        self.temperature_spin = QDoubleSpinBox()
        self.temperature_spin.setRange(0.0, 1.0)
        self.temperature_spin.setSingleStep(0.1)
        self.temperature_spin.setDecimals(2)
        form_layout.addRow("Temperature:", self.temperature_spin)
        
        # Max tokens
        self.max_tokens_spin = QSpinBox()
        self.max_tokens_spin.setRange(100, 8000)
        self.max_tokens_spin.setSingleStep(100)
        form_layout.addRow("Max Tokens:", self.max_tokens_spin)
        
        # Timeout
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(10, 120)
        self.timeout_spin.setSingleStep(5)
        form_layout.addRow("Timeout (seconds):", self.timeout_spin)
        
        # Connect signals
        self.provider_combo.currentIndexChanged.connect(self._on_provider_changed)
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Add layouts
        layout.addLayout(form_layout)
        layout.addWidget(button_box)
    
    def _populate_providers(self):
        """Populate the providers dropdown."""
        self.provider_combo.clear()
        
        # Get available providers
        available_providers = self.provider_manager.get_available_providers()
        
        # Add each provider to the dropdown
        for provider in available_providers:
            self.provider_combo.addItem(provider.name.capitalize(), provider.name)
        
        # Add a placeholder if no providers are available
        if not available_providers:
            self.provider_combo.addItem("No providers available", "")
    
    def _on_provider_changed(self, index):
        """Handle provider selection change."""
        self.model_combo.clear()
        
        # Get selected provider type
        if index < 0:
            self.model_combo.addItem("Select a provider first", "")
            return
        
        provider_name = self.provider_combo.itemData(index)
        
        # Handle None or empty provider name
        if not provider_name:
            self.model_combo.addItem("Invalid provider", "")
            return
            
        try:
            provider_type = ProviderType[provider_name]
            
            # Get available models for this provider
            models = self.settings_manager.get_available_models(provider_type)
            
            # Add models to the dropdown
            for model in models:
                self.model_combo.addItem(model, model)
            
            # Add a placeholder if no models are available
            if not models:
                self.model_combo.addItem("No models available", "")
                
        except (KeyError, ValueError):
            logger.error(f"Invalid provider type: {provider_name}")
            self.model_combo.addItem("Error loading models", "")
    
    def _populate_settings(self):
        """Populate the dialog with current settings."""
        # Set provider
        provider_type_str = self.agent_settings.get("provider_type", "OPENAI")
        
        # Check if provider_type_str is None and provide a default
        if provider_type_str is None:
            provider_type_str = "OPENAI"
        
        for i in range(self.provider_combo.count()):
            if self.provider_combo.itemData(i) == provider_type_str:
                self.provider_combo.setCurrentIndex(i)
                break
        
        # Model will be populated by _on_provider_changed
        
        # Make sure to call provider change handler to populate the model dropdown
        self._on_provider_changed(self.provider_combo.currentIndex())
        
        # If we have a specific model, select it
        model = self.agent_settings.get("model", "")
        if model:
            for i in range(self.model_combo.count()):
                if self.model_combo.itemData(i) == model:
                    self.model_combo.setCurrentIndex(i)
                    break
        
        # Set other settings
        self.temperature_spin.setValue(self.agent_settings.get("temperature", 0.7))
        self.max_tokens_spin.setValue(self.agent_settings.get("max_tokens", 1000))
        self.timeout_spin.setValue(self.agent_settings.get("timeout_seconds", 30))
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the settings from the dialog.
        
        Returns:
            Dictionary of agent settings.
        """
        # Get provider type
        provider_index = self.provider_combo.currentIndex()
        provider_type_str = self.provider_combo.itemData(provider_index)
        
        # Get model
        model_index = self.model_combo.currentIndex()
        model = self.model_combo.itemData(model_index)
        
        # Build settings dictionary
        settings = {
            "provider_type": provider_type_str,
            "model": model,
            "temperature": self.temperature_spin.value(),
            "max_tokens": self.max_tokens_spin.value(),
            "timeout_seconds": self.timeout_spin.value(),
        }
        
        return settings


class AgentSetupTab(QWidget):
    """Tab for configuring agent LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the agent setup tab."""
        super().__init__(parent)
        
        self.settings_manager = get_settings_manager()
        self.provider_manager = get_provider_manager()
        
        # Store agent settings
        self.agent_settings = {}
        
        self._setup_ui()
        self._load_agent_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Description
        description = QLabel(
            "Configure which LLM provider and model to use for each agent in the game. "
            "Each agent can use a different provider and model configuration."
        )
        description.setWordWrap(True)
        layout.addWidget(description)
        
        # Agents table
        self.agents_table = QTableWidget()
        self.agents_table.setColumnCount(5)
        self.agents_table.setHorizontalHeaderLabels([
            "Agent", "Provider", "Model", "Temperature", "Configure"
        ])
        
        # Set table properties
        header = self.agents_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.Stretch)
        header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)
        
        layout.addWidget(self.agents_table)
    
    def _load_agent_settings(self):
        """Load agent settings and populate the table."""
        # Clear the table
        self.agents_table.setRowCount(0)
        
        # Get available agents
        agents = self.settings_manager.list_available_agents()
        
        # Populate table
        for i, agent_name in enumerate(agents):
            # Get agent settings
            settings = self.settings_manager.get_agent_settings(agent_name)
            self.agent_settings[agent_name] = settings
            
            # Add row
            self.agents_table.insertRow(i)
            
            # Agent name
            name_item = QTableWidgetItem(agent_name.capitalize())
            name_item.setFlags(name_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 0, name_item)
            
            # Provider
            provider_type_str = settings.get("provider_type", "OPENAI")
            # Check if provider_type_str is None and provide a default
            if provider_type_str is None:
                provider_type_str = "OPENAI"
            provider_item = QTableWidgetItem(provider_type_str.capitalize())
            provider_item.setFlags(provider_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 1, provider_item)
            
            # Model
            model = settings.get("model", "default")
            model_item = QTableWidgetItem(model)
            model_item.setFlags(model_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 2, model_item)
            
            # Temperature
            temp = settings.get("temperature", 0.7)
            temp_item = QTableWidgetItem(f"{temp:.2f}")
            temp_item.setFlags(temp_item.flags() & ~Qt.ItemIsEditable)
            self.agents_table.setItem(i, 3, temp_item)
            
            # Configure button
            self.agents_table.setCellWidget(i, 4, self._create_configure_button(agent_name))
    
    def _create_configure_button(self, agent_name: str) -> QPushButton:
        """Create a configure button for an agent.
        
        Args:
            agent_name: Name of the agent.
            
        Returns:
            Configure button widget.
        """
        button = QPushButton("Configure")
        button.clicked.connect(lambda: self._configure_agent(agent_name))
        return button
    
    def _configure_agent(self, agent_name: str) -> None:
        """Open the agent configuration dialog.
        
        Args:
            agent_name: Name of the agent to configure.
        """
        # Get agent settings
        settings = self.agent_settings.get(agent_name, {})
        
        # Create and show the dialog
        dialog = AgentSetupDialog(self, agent_name, settings)
        
        if dialog.exec():
            # Get updated settings
            updated_settings = dialog.get_settings()
            
            # Update in-memory settings
            self.agent_settings[agent_name] = updated_settings
            
            # Save settings to disk
            success = self.settings_manager.update_agent_settings(agent_name, updated_settings)
            
            if success:
                logger.info(f"Updated settings for agent {agent_name}")
            else:
                logger.error(f"Failed to update settings for agent {agent_name}")
            
            # Reload table
            self._load_agent_settings()
    
    def save_settings(self) -> bool:
        """Save all agent settings.
        
        Returns:
            True if successful, False otherwise.
        """
        success = True
        
        for agent_name, settings in self.agent_settings.items():
            # Save settings to disk
            result = self.settings_manager.update_agent_settings(agent_name, settings)
            
            if not result:
                success = False
                logger.error(f"Failed to save settings for agent {agent_name}")
        
        return success

```

### File: gui\dialogs\settings\anthropic_tab.py

```python
#!/usr/bin/env python3
"""
Anthropic provider tab for the RPG game GUI.
This module provides a tab for configuring Anthropic LLM provider settings.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import QFormLayout
from PySide6.QtCore import Qt

from gui.dialogs.settings.llm_provider_tab import LLMProviderTab
from gui.dialogs.settings.model_management_widget import ModelManagementWidget
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = logging.getLogger("GUI")

class AnthropicTab(LLMProviderTab):
    """Tab for Anthropic settings."""
    
    def __init__(self, parent=None):
        """Initialize the Anthropic settings tab."""
        super().__init__(parent, provider_name="Anthropic")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.ANTHROPIC, "Anthropic")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("Anthropic's Claude models provide thoughtful, creative, and reliable AI assistant capabilities.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Set models in model manager
        self.model_manager.set_models(models)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings

```

### File: gui\dialogs\settings\background_tab.py

```python
#!/usr/bin/env python3
"""
Background selection tab for the settings dialog.
"""

import logging
import os
from typing import List, Optional, Tuple # Added Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize
from PySide6.QtGui import QPixmap, QMovie # Added QMovie

from gui.utils.resource_manager import get_resource_manager

logger = logging.getLogger(__name__)

class BackgroundTab(QWidget):
    """Widget for selecting the main window background."""

    # Signal emitted when the user previews a different background
    # Argument is the full filename of the background (e.g., 'my_bg.gif')
    preview_background_changed = Signal(str)

    def __init__(self, parent=None):
        """Initialize the background tab."""
        super().__init__(parent)

        self.resource_manager = get_resource_manager()
        self.backgrounds: List[Tuple[str, str]] = [] # Stores (name, ext) tuples
        self.current_index: int = -1
        # Default should ideally include extension, but resource manager might find it
        self.default_background_filename = "main_background.png"

        self._setup_ui()
        self._load_available_backgrounds()

    def _setup_ui(self):
        """Set up the user interface for the tab."""
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Preview Area
        preview_layout = QVBoxLayout()
        preview_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.preview_label = QLabel("Background Preview")
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_label.setMinimumSize(400, 225) # Aspect ratio 16:9
        self.preview_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.preview_label.setStyleSheet("border: 1px solid gray; background-color: #333;")
        preview_layout.addWidget(self.preview_label)

        self.name_label = QLabel("Background: N/A")
        self.name_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        preview_layout.addWidget(self.name_label)

        layout.addLayout(preview_layout)

        # Navigation Controls
        nav_layout = QHBoxLayout()
        nav_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self.prev_button = QPushButton("< Prev")
        self.prev_button.clicked.connect(self._show_previous_background)
        self.prev_button.setFixedWidth(100)

        self.next_button = QPushButton("Next >")
        self.next_button.clicked.connect(self._show_next_background)
        self.next_button.setFixedWidth(100)

        nav_layout.addWidget(self.prev_button)
        nav_layout.addStretch()
        nav_layout.addWidget(self.next_button)

        layout.addLayout(nav_layout)
        layout.addStretch() # Push controls to the top

    def _load_available_backgrounds(self):
        """Load the list of available background image/animation names and extensions."""
        self.backgrounds = self.resource_manager.list_background_names()
        logger.info(f"Found backgrounds: {self.backgrounds}")
        if not self.backgrounds:
            logger.warning("No background images or GIFs found in images/gui/background/")
            self.prev_button.setEnabled(False)
            self.next_button.setEnabled(False)
        else:
            # Try to set initial index based on saved setting later in load_settings
            self.prev_button.setEnabled(len(self.backgrounds) > 1)
            self.next_button.setEnabled(len(self.backgrounds) > 1)

    def _update_preview(self):
        """Update the preview label with the current background (PNG or GIF)."""
        # Stop any existing movie
        current_movie = self.preview_label.movie()
        if current_movie:
            current_movie.stop()
            self.preview_label.setMovie(None) # Clear movie reference

        # Clear existing pixmap
        self.preview_label.setPixmap(QPixmap())

        if 0 <= self.current_index < len(self.backgrounds):
            name, ext = self.backgrounds[self.current_index]
            filename = f"{name}{ext}"
            self.name_label.setText(f"Background: {filename}")

            if ext.lower() == ".png":
                pixmap = self.resource_manager.get_background_pixmap(name)
                if not pixmap.isNull():
                    scaled_pixmap = pixmap.scaled(self.preview_label.size(),
                                                  Qt.AspectRatioMode.KeepAspectRatio,
                                                  Qt.TransformationMode.SmoothTransformation)
                    self.preview_label.setPixmap(scaled_pixmap)
                else:
                    self.preview_label.setText(f"Failed to load:\n{filename}")

            elif ext.lower() == ".gif":
                movie = self.resource_manager.get_background_movie(name)
                if movie.isValid():
                    self.preview_label.setMovie(movie)
                    # Scale movie if possible (QMovie doesn't scale directly like QPixmap)
                    # We might need to adjust label size policy or container layout
                    # For now, just set it and start
                    movie.setScaledSize(self.preview_label.size()) # Attempt scaling
                    movie.start()
                else:
                    self.preview_label.setText(f"Failed to load:\n{filename}")

            # Emit signal for live preview in main window with full filename
            self.preview_background_changed.emit(filename)
        else:
            self.name_label.setText("Background: N/A")
            self.preview_label.setText("No Background Selected")
            # Ensure both pixmap and movie are cleared
            self.preview_label.setPixmap(QPixmap())
            self.preview_label.setMovie(None)

    def _show_previous_background(self):
        """Navigate to the previous background image/animation."""
        if not self.backgrounds:
            return
        self.current_index = (self.current_index - 1) % len(self.backgrounds)
        self._update_preview()

    def _show_next_background(self):
        """Navigate to the next background image/animation."""
        if not self.backgrounds:
            return
        self.current_index = (self.current_index + 1) % len(self.backgrounds)
        self._update_preview()

    def load_settings(self, settings: QSettings):
        """Load the saved background setting (full filename). Defaults to first available if saved is invalid."""
        # Save/Load the full filename now, e.g., "my_background.gif"
        saved_filename = settings.value("style/background_filename", None)
        logger.info(f"Attempting to load background setting: '{saved_filename}'")

        self.current_index = -1 # Reset index

        if saved_filename:
            # Find the index corresponding to the saved filename
            found = False
            for i, (name, ext) in enumerate(self.backgrounds):
                if f"{name}{ext}" == saved_filename:
                    self.current_index = i
                    logger.info(f"Found saved background '{saved_filename}' at index {self.current_index}")
                    found = True
                    break
            if not found:
                 logger.warning(f"Saved background '{saved_filename}' not found in available list: {self.backgrounds}")
                 if self.backgrounds:
                     self.current_index = 0 # Fallback to first available
                     logger.info(f"Falling back to first available: '{self.backgrounds[self.current_index][0]}{self.backgrounds[self.current_index][1]}'")

        elif self.backgrounds:
            # No setting saved, use the first available
            self.current_index = 0
            logger.info(f"No background setting saved. Using first available: '{self.backgrounds[self.current_index][0]}{self.backgrounds[self.current_index][1]}'")
        else:
            # No setting saved and no backgrounds available
             logger.warning("No saved background setting and no backgrounds available.")
             self.current_index = -1

        # Update preview even if index is -1 (will show N/A)
        self._update_preview()

    def save_settings(self, settings: QSettings):
        """Save the currently selected background filename."""
        if 0 <= self.current_index < len(self.backgrounds):
            selected_name, selected_ext = self.backgrounds[self.current_index]
            selected_filename = f"{selected_name}{selected_ext}"
            settings.setValue("style/background_filename", selected_filename)
            logger.info(f"Saving background setting: '{selected_filename}'")
        else:
            # If somehow no valid index, try saving the default filename
            settings.setValue("style/background_filename", self.default_background_filename)
            logger.warning(f"No valid background selected, saving default filename: {self.default_background_filename}")
```

### File: gui\dialogs\settings\base_settings_dialog.py

```python
#!/usr/bin/env python3
"""
Base settings dialog for the RPG game GUI.
This module provides a base dialog class for settings dialogs.
"""

import os
import json
import logging
from typing import Dict, Any, Optional

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QTabWidget, QWidget
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QIcon

# Get the module logger
logger = logging.getLogger("GUI")

class BaseSettingsDialog(QDialog):
    """Base dialog for settings dialogs."""
    
    # Signal emitted when settings are saved
    settings_saved = Signal()
    
    def __init__(self, parent=None, title="Settings"):
        """Initialize the base settings dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle(title)
        self.setMinimumWidth(700)
        self.setMinimumHeight(500)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QLineEdit, QComboBox, QSpinBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QComboBox:focus, QSpinBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QPushButton.danger {
                background-color: #D32F2F;
            }
            QPushButton.danger:hover {
                background-color: #F44336;
            }
            QPushButton.danger:pressed {
                background-color: #B71C1C;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
                color: #E0E0E0;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
            }
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #2D2D30;
            }
            QTabWidget::tab-bar {
                left: 5px;
            }
            QTabBar::tab {
                background-color: #333333;
                border: 1px solid #555555;
                border-bottom-color: #555555;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 10px;
                color: #CCCCCC;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #0E639C;
                color: white;
            }
            QTabBar::tab:!selected {
                margin-top: 2px;
            }
            QCheckBox {
                color: #E0E0E0;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 1px solid #555555;
                border-radius: 2px;
                background-color: #1E1E1E;
            }
            QCheckBox::indicator:checked {
                background-color: #0E639C;
                border-color: #0E639C;
            }
        """)
        
        # Create the main layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(20, 20, 20, 20)
        self.main_layout.setSpacing(15)
        
        # Set up the bottom button layout
        self._setup_button_layout()
    
    def _setup_button_layout(self):
        """Set up the bottom button layout."""
        # Create bottom button layout
        self.button_layout = QHBoxLayout()
        self.button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create save button
        self.save_button = QPushButton("Save Settings")
        self.save_button.clicked.connect(self._on_save)
        
        # Add buttons to layout
        self.button_layout.addStretch()
        self.button_layout.addWidget(self.cancel_button)
        self.button_layout.addWidget(self.save_button)
    
    def add_button_layout(self):
        """Add the button layout to the main layout."""
        self.main_layout.addLayout(self.button_layout)
    
    def add_left_button(self, button):
        """Add a button to the left side of the button layout."""
        self.button_layout.insertWidget(0, button)
    
    def _on_save(self):
        """Handle save button click."""
        # Save settings
        if self.save_settings():
            # Emit signal
            self.settings_saved.emit()
            
            # Accept dialog
            self.accept()
    
    def save_settings(self) -> bool:
        """
        Save settings.
        
        This method should be implemented by subclasses.
        
        Returns:
            True if settings were saved successfully, False otherwise.
        """
        return True

```

### File: gui\dialogs\settings\llm_general_tab.py

```python
#!/usr/bin/env python3
"""
LLM general settings tab for the RPG game GUI.
This module provides a tab for configuring general LLM settings.
"""

import logging
from typing import Dict, Any

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QGroupBox, 
    QComboBox, QCheckBox, QSpinBox
)
from PySide6.QtCore import Qt

# Get the module logger
logger = logging.getLogger("GUI")

class LLMGeneralTab(QWidget):
    """Tab for general LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the general settings tab."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        
        # Create general settings group
        general_group = QGroupBox("General LLM Settings")
        general_layout = QFormLayout(general_group)
        general_layout.setFieldGrowthPolicy(QFormLayout.AllNonFixedFieldsGrow)
        
        # Create default provider setting
        self.default_provider_combo = QComboBox()
        self.default_provider_combo.addItem("OpenAI", "OPENAI")
        self.default_provider_combo.addItem("Google", "GOOGLE")
        self.default_provider_combo.addItem("OpenRouter", "OPENROUTER")
        general_layout.addRow("Default Provider:", self.default_provider_combo)
        
        # Create LLM toggle checkbox
        self.llm_enabled_check = QCheckBox("Enable LLM Processing")
        self.llm_enabled_check.setToolTip("Toggle LLM processing for game input")
        general_layout.addRow("", self.llm_enabled_check)
        
        # Create diagnostics at startup checkbox
        self.diagnostics_check = QCheckBox("Run diagnostics at startup")
        self.diagnostics_check.setToolTip("Test LLM connections when the application starts")
        general_layout.addRow("", self.diagnostics_check)
        
        # Create advanced settings group
        advanced_group = QGroupBox("Advanced Settings")
        advanced_layout = QFormLayout(advanced_group)
        
        # Create timeout setting
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(5, 120)
        self.timeout_spin.setSuffix(" seconds")
        self.timeout_spin.setToolTip("Maximum time to wait for LLM response")
        advanced_layout.addRow("Request Timeout:", self.timeout_spin)
        
        # Create retry attempts setting
        self.retry_spin = QSpinBox()
        self.retry_spin.setRange(1, 10)
        self.retry_spin.setToolTip("Number of retry attempts for failed requests")
        advanced_layout.addRow("Retry Attempts:", self.retry_spin)
        
        # Create retry delay setting
        self.retry_delay_spin = QSpinBox()
        self.retry_delay_spin.setRange(1, 30)
        self.retry_delay_spin.setSuffix(" seconds")
        self.retry_delay_spin.setToolTip("Delay between retry attempts")
        advanced_layout.addRow("Retry Delay:", self.retry_delay_spin)
        
        # Create temperature setting
        self.temperature_combo = QComboBox()
        self.temperature_combo.addItem("Low (0.3) - More focused, less creative", 0.3)
        self.temperature_combo.addItem("Medium (0.7) - Balanced", 0.7)
        self.temperature_combo.addItem("High (1.0) - More creative, less focused", 1.0)
        self.temperature_combo.setToolTip("Controls randomness of LLM responses")
        advanced_layout.addRow("Default Temperature:", self.temperature_combo)
        
        # Add groups to layout
        layout.addWidget(general_group)
        layout.addWidget(advanced_group)
        layout.addStretch(1)
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings.
        
        Args:
            settings: Dictionary with settings values
        """
        # Set provider type
        provider_type = settings.get("default_provider_type", "OPENAI")
        index = self.default_provider_combo.findData(provider_type)
        if index >= 0:
            self.default_provider_combo.setCurrentIndex(index)
        
        # Set checkboxes
        self.llm_enabled_check.setChecked(settings.get("llm_enabled", False))
        self.diagnostics_check.setChecked(settings.get("run_diagnostics_on_start", False))
        
        # Set spin boxes
        self.timeout_spin.setValue(settings.get("timeout_seconds", 30))
        self.retry_spin.setValue(settings.get("retry_attempts", 3))
        self.retry_delay_spin.setValue(settings.get("retry_delay_seconds", 2))
        
        # Set temperature combo
        temp = settings.get("default_temperature", 0.7)
        if temp <= 0.3:
            self.temperature_combo.setCurrentIndex(0)
        elif temp >= 1.0:
            self.temperature_combo.setCurrentIndex(2)
        else:
            self.temperature_combo.setCurrentIndex(1)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab.
        
        Returns:
            Dictionary with current settings values
        """
        return {
            "default_provider_type": self.default_provider_combo.currentData(),
            "default_temperature": self.temperature_combo.currentData(),
            "timeout_seconds": self.timeout_spin.value(),
            "retry_attempts": self.retry_spin.value(),
            "retry_delay_seconds": self.retry_delay_spin.value(),
            "run_diagnostics_on_start": self.diagnostics_check.isChecked(),
            "llm_enabled": self.llm_enabled_check.isChecked()
        }

```

### File: gui\dialogs\settings\llm_provider_tab.py

```python
#!/usr/bin/env python3
"""
LLM provider settings tab for the RPG game GUI.
This module provides a base tab for configuring LLM provider settings.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QFormLayout, QGroupBox, 
    QLineEdit, QComboBox, QCheckBox, QLabel
)
from PySide6.QtCore import Qt

# Get the module logger
logger = logging.getLogger("GUI")

class LLMProviderTab(QWidget):
    """Base tab for provider LLM settings."""
    
    def __init__(self, parent=None, provider_name="Provider"):
        """Initialize the provider settings tab."""
        super().__init__(parent)
        
        # Provider properties
        self.provider_name = provider_name
        self.api_key_setting_name = "api_key"
        self.models = []  # Will be set by subclasses: List of (display_name, value) tuples
        
        # Set up the UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create layout
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(10)
        
        # Create API settings group
        api_group = QGroupBox(f"{self.provider_name} API Settings")
        api_layout = QFormLayout(api_group)
        
        # Create enabled checkbox
        self.enabled_check = QCheckBox(f"Enable {self.provider_name}")
        self.enabled_check.setToolTip(f"Enable/disable {self.provider_name} provider")
        self.enabled_check.toggled.connect(self._toggle_fields)
        api_layout.addRow("", self.enabled_check)
        
        # Create API key field
        self.api_key_edit = QLineEdit()
        self.api_key_edit.setPlaceholderText(f"Enter your {self.provider_name} API key")
        self.api_key_edit.setEchoMode(QLineEdit.Password)
        api_layout.addRow("API Key:", self.api_key_edit)
        
        # Add info section (to be overridden by subclasses)
        self.info_label = QLabel("")
        self.info_label.setWordWrap(True)
        self.info_label.setStyleSheet("color: #AAAAAA; font-style: italic;")
        
        # Add groups to layout
        self.main_layout.addWidget(api_group)
        self.main_layout.addWidget(self.info_label)
        self.main_layout.addStretch(1)
    
    def add_models(self, models: List[Tuple[str, str]]):
        """Store models data.
        
        Args:
            models: List of (display_name, value) tuples
        """
        self.models = models
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        self.api_key_edit.setEnabled(enabled)
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings.
        
        Args:
            settings: Dictionary with settings values
        """
        # Set enabled checkbox
        self.enabled_check.setChecked(settings.get("enabled", True))
        
        # Set API key
        self.api_key_edit.setText(settings.get(self.api_key_setting_name, ""))
        
        # Toggle fields based on enabled state
        self._toggle_fields(self.enabled_check.isChecked())
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab.
        
        Returns:
            Dictionary with current settings values
        """
        settings = {
            "enabled": self.enabled_check.isChecked(),
            self.api_key_setting_name: self.api_key_edit.text()
        }
        
        return settings

```

### File: gui\dialogs\settings\llm_settings_dialog.py

```python
#!/usr/bin/env python3
"""
LLM settings dialog for the RPG game GUI.
This module provides a dialog for configuring LLM settings.
"""

import os
import json
import logging
from typing import Dict, Any
import shutil
from datetime import datetime

from PySide6.QtWidgets import (
    QTabWidget, QMessageBox, QPushButton
)
from PySide6.QtCore import QSettings

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.llm_manager import get_llm_manager

from gui.dialogs.settings.base_settings_dialog import BaseSettingsDialog
from gui.dialogs.settings.llm_general_tab import LLMGeneralTab
from gui.dialogs.settings.provider_tabs import OpenAITab, GoogleTab, OpenRouterTab
from gui.dialogs.settings.anthropic_tab import AnthropicTab
from gui.dialogs.settings.agent_setup_tab import AgentSetupTab

# Get the module logger
logger = logging.getLogger("GUI")

class LLMSettingsDialog(BaseSettingsDialog):
    """Dialog for configuring LLM settings."""
    
    def __init__(self, parent=None):
        """Initialize the LLM settings dialog."""
        super().__init__(parent, title="LLM Settings")
        
        # Get provider manager
        self.provider_manager = get_provider_manager()
        
        # Get LLM manager
        self.llm_manager = get_llm_manager()

        # Get settings manager
        from core.llm.settings_manager import get_settings_manager # Add import if not already present
        self.settings_manager = get_settings_manager()

        # Load settings using SettingsManager
        self.provider_settings = self.settings_manager.get_provider_settings()
        self.base_settings = self.settings_manager.get_llm_settings() # Load base settings directly

        # Remove QSettings dependency entirely
        # self.qsettings = QSettings("RPG_Game", "LLM_Settings_Base")

        # Set up the UI
        self._setup_ui()
        
        # Populate the UI with settings
        self._populate_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create tab widget
        self.tab_widget = QTabWidget()
        
        # Create tabs
        self.general_tab = LLMGeneralTab()
        self.openai_tab = OpenAITab()
        self.google_tab = GoogleTab()
        self.anthropic_tab = AnthropicTab()
        self.openrouter_tab = OpenRouterTab()
        self.agent_setup_tab = AgentSetupTab()
        
        # Add tabs to widget
        self.tab_widget.addTab(self.general_tab, "General")
        self.tab_widget.addTab(self.openai_tab, "OpenAI")
        self.tab_widget.addTab(self.google_tab, "Google")
        self.tab_widget.addTab(self.anthropic_tab, "Anthropic")
        self.tab_widget.addTab(self.openrouter_tab, "OpenRouter")
        self.tab_widget.addTab(self.agent_setup_tab, "Agent Setup")
        
        # Add tab widget to main layout
        self.main_layout.addWidget(self.tab_widget)
        
        # Create reset button
        self.reset_button = QPushButton("Reset to Default")
        self.reset_button.setStyleSheet("QPushButton { background-color: #D32F2F; }")
        self.reset_button.clicked.connect(self._reset_settings)
        
        # Create test button
        self.test_button = QPushButton("Test Connections")
        self.test_button.clicked.connect(self._test_connections)
        
        # Add buttons to left side
        self.add_left_button(self.test_button)
        self.add_left_button(self.reset_button)
        
        # Add button layout
        self.add_button_layout()

    # _load_provider_settings method removed - SettingsManager handles loading in __init__
    # _load_base_settings method definition removed below

    def _populate_settings(self):
        """Populate the UI with current settings."""
        # Always refresh settings from disk because model widgets may seed defaults on init
        self.provider_settings = self.settings_manager.get_provider_settings()
        self.base_settings = self.settings_manager.get_llm_settings()

        # Populate general settings
        self.general_tab.set_settings(self.base_settings)
        
        # Populate provider settings (freshly loaded)
        self.openai_tab.set_settings(self.provider_settings.get("openai", {}))
        self.google_tab.set_settings(self.provider_settings.get("google", {}))
        self.anthropic_tab.set_settings(self.provider_settings.get("anthropic", {}))
        self.openrouter_tab.set_settings(self.provider_settings.get("openrouter", {}))
    
    def _reset_settings(self):
        """Reset settings to default."""
        # Ask for confirmation
        result = QMessageBox.question(
            self, 
            "Reset Settings", 
            "Are you sure you want to reset all LLM settings to default?\n\nThis will remove all API keys and custom configurations.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        try:
            # --- Removed QSettings clear ---
            # self.qsettings.clear()

            # Reset config files
            config_dir = os.path.join("config", "llm")
            
            # Create backup of current config
            backup_dir = os.path.join(config_dir, "backup")
            os.makedirs(backup_dir, exist_ok=True)
            
            # Backup providers.json if it exists
            providers_file = os.path.join(config_dir, "providers.json")
            if os.path.exists(providers_file):
                backup_file = os.path.join(backup_dir, f"providers_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
                shutil.copy2(providers_file, backup_file)
                logger.info(f"Backed up providers.json to {backup_file}")
            
            # Backup base_config.json if it exists
            base_file = os.path.join(config_dir, "base_config.json")
            if os.path.exists(base_file):
                backup_file = os.path.join(backup_dir, f"base_config_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json")
                shutil.copy2(base_file, backup_file)
                logger.info(f"Backed up base_config.json to {backup_file}")
            
            # Create default provider settings file
            default_providers = {
                "openai": {
                    "api_key": "",
                    "organization": "",
                    "api_base": "https://api.openai.com/v1",
                    "default_model": "gpt-4o-mini",
                    "available_models": [
                        "gpt-4.1-nano",
                        "gpt-4.1-mini",
                        "gpt-4.1",
                        "gpt-5-mini",
                        "gpt-4o",
                        "gpt-4o-mini"
                    ],
                    "enabled": True
                },
                "google": {
                    "api_key": "",
                    "default_model": "gemini-2.0-flash",
                    "available_models": [
                        "gemini-2.5-flash-preview-05-20",
                        "gemini-2.5-flash",
                        "gemini-2.0-flash",
                        "gemini-2.0-flash-lite"
                    ],
                    "enabled": True
                },
                "openrouter": {
                    "api_key": "",
                    "api_base": "https://openrouter.ai/api/v1",
                    "default_model": "mistralai/mistral-small-3.1-24b-instruct:free",
                    "available_models": [
                        "deepseek/deepseek-v3-base:free",
                        "google/gemini-2.5-pro-exp-03-25:free",
                        "meta-llama/llama-4-maverick:free",
                        "deepseek/deepseek-r1-0528:free",
                        "mistralai/mistral-small-3.1-24b-instruct:free",
                        "meta-llama/llama-4-scout:free",
                        "nvidia/llama-3.1-nemotron-nano-8b-v1:free",
                        "openrouter/quasar-alpha:free",
                        "moonshotai/kimi-vl-a3b-thinking:free",
                        "qwen/qwen2.5-vl-3b-instruct:free"
                    ],
                    "enabled": True
                },
                "anthropic": {
                    "api_key": "",
                    "api_base": "https://api.anthropic.com",
                    "default_model": "claude-3-5-haiku-latest",
                    "available_models": [
                        "claude-3-5-haiku-latest",
                        "claude-3-7-sonnet-latest",
                        "claude-sonnet-4-20250514-v1:0"
                    ],
                    "enabled": True
                }
            }

            with open(providers_file, 'w', encoding='utf-8') as f:
                json.dump(default_providers, f, indent=4)
            
            # Create default base settings file
            default_base = {
                "default_provider_type": "OPENAI",
                "default_temperature": 0.7,
                "timeout_seconds": 30,
                "retry_attempts": 3,
                "retry_delay_seconds": 2,
                "run_diagnostics_on_start": False,
                "log_prompts": True,
                "log_completions": True,
                "cost_tracking_enabled": True
            }
            
            with open(base_file, 'w', encoding='utf-8') as f:
                json.dump(default_base, f, indent=4)

            # Reload settings using SettingsManager
            self.provider_settings = self.settings_manager.get_provider_settings()
            self.base_settings = self.settings_manager.get_llm_settings()

            # Repopulate UI
            self._populate_settings()
            
            # Show success message
            QMessageBox.information(
                self,
                "Settings Reset",
                "LLM settings have been reset to default values.\nPrevious settings were backed up in the config/llm/backup directory."
            )
            
        except Exception as e:
            logger.error(f"Error resetting settings: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred while resetting settings: {str(e)}"
            )
    
    def _test_connections(self):
        """Test LLM connections."""
        try:
            # Save current settings temporarily
            self.save_settings(show_success=False)
            
            # Reinitialize provider manager
            self.provider_manager = get_provider_manager()
            
            # Run diagnostics
            diagnostics = self.llm_manager.run_llm_diagnostics()
            
            # Build results message
            message = f"LLM Diagnostics: {diagnostics['status']}\n\n"
            
            for provider_name, provider_result in diagnostics.get("providers", {}).items():
                status = provider_result.get("status", "unknown")
                status_text = "✓ Success" if status == "success" else "✗ Failed"
                
                message += f"{provider_name}: {status_text}\n"
                
                if status == "success":
                    model = provider_result.get("model", "unknown")
                    message += f"  Model: {model}\n"
                    message += f"  Response: {provider_result.get('response_content', '')[:50]}...\n"
                else:
                    message += f"  Error: {provider_result.get('error', 'Unknown error')}\n"
                
                message += "\n"
            
            # Show results
            QMessageBox.information(
                self,
                "Connection Test Results",
                message
            )
            
        except Exception as e:
            logger.error(f"Error testing connections: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred while testing connections: {str(e)}"
            )
    
    def save_settings(self, show_success=True) -> bool:
        """Save settings to configuration files and QSettings.
        
        Args:
            show_success: Whether to show a success message
            
        Returns:
            True if settings were saved successfully, False otherwise
        """
        try:
            # Get settings from UI
            
            # Get settings from UI
            base_settings = self.general_tab.get_settings()
            
            # Get provider settings
            provider_settings = {
                "openai": self.openai_tab.get_settings(),
                "anthropic": self.anthropic_tab.get_settings(),
                "google": self.google_tab.get_settings(),
                "openrouter": self.openrouter_tab.get_settings()
            }
            
            # Save agent settings (This saves agent JSON files via SettingsManager)
            self.agent_setup_tab.save_settings()

            # --- Removed saving provider settings to QSettings ---
            # Provider settings are now saved directly to providers.json
            # by the ModelManagementWidget and provider tabs via SettingsManager.
            # The loop below updates the ProviderManager instance, which relies
            # on SettingsManager having already saved the JSON.

            # Save base settings using SettingsManager
            if self.settings_manager.update_llm_settings(base_settings):
                logger.info("Successfully saved base LLM settings to JSON.")
            else:
                logger.error("Failed to save base LLM settings to JSON.")
                # Optionally raise an error or show a specific message

            # --- Removed saving base settings to QSettings ---
            # self.qsettings.beginGroup("base")
            # for key, value in base_settings.items():
            #     self.qsettings.setValue(key, value)
            # self.qsettings.endGroup()

            # Update provider manager (This updates the in-memory state of the manager)
            for provider_type_name, provider_name in [
                (ProviderType.OPENAI, "openai"),
                (ProviderType.GOOGLE, "google"),
                (ProviderType.OPENROUTER, "openrouter")
            ]:
                # Update provider settings
                if provider_name in provider_settings:
                    self.provider_manager.update_provider_settings(
                        provider_type_name, 
                        provider_settings[provider_name]
                    )
            
            # Set LLM enabled state (if explicitly toggled)
            from core.base.engine import get_game_engine
            engine = get_game_engine()
            if "llm_enabled" in base_settings:
                engine.set_llm_enabled(base_settings["llm_enabled"])
            
            # Ensure live agents pick up new provider/model settings immediately
            try:
                engine.reload_llm_settings()
            except Exception as e:
                logger.error(f"Error reloading LLM agent settings: {e}")
            
            # Show success message
            if show_success:
                QMessageBox.information(
                    self,
                    "Settings Saved",
                    "LLM settings have been saved successfully."
                )
            
            return True
            
        except Exception as e:
            logger.error(f"Error saving settings: {e}")
            
            if show_success:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"An error occurred while saving settings: {str(e)}"
                )
            
            return False


# For testing
if __name__ == "__main__":
    import sys
    from PySide6.QtWidgets import QApplication
    from core.utils.logging_config import setup_logging
    
    # Set up logging
    setup_logging()
    
    # Create application
    app = QApplication(sys.argv)
    
    # Create dialog
    dialog = LLMSettingsDialog()
    
    # Show dialog
    dialog.exec()

```

### File: gui\dialogs\settings\model_management_widget.py

```python
#!/usr/bin/env python3
"""
Model management widget for LLM settings.

This module provides a widget for adding, removing, and modifying
available LLM models for each provider.
"""

import logging
import os
import json
from typing import List, Dict, Any, Callable, Optional, Tuple

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem,
    QPushButton, QLabel, QLineEdit, QMessageBox, QDialog, QFormLayout,
    QDialogButtonBox, QGroupBox
)
from PySide6.QtCore import Qt, Signal

from core.llm.provider_manager import ProviderType, get_provider_manager
from core.llm.settings_manager import get_settings_manager

# Get the module logger
logger = logging.getLogger("GUI")

class AddEditModelDialog(QDialog):
    """Dialog for adding or editing a model."""
    
    def __init__(self, parent=None, edit_data: Optional[Tuple[str, str]] = None):
        """Initialize the dialog.
        
        Args:
            parent: Parent widget.
            edit_data: Tuple of (display_name, model_id) if editing, None if adding.
        """
        super().__init__(parent)
        
        self.edit_data = edit_data
        self.setWindowTitle("Add Model" if not edit_data else "Edit Model")
        self.setMinimumWidth(350)
        
        self._setup_ui()
        
        if edit_data:
            self._populate_edit_data(edit_data)
    
    def _setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Form layout for inputs
        form_layout = QFormLayout()
        
        # Model display name field
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Display name shown in UI")
        form_layout.addRow("Display Name:", self.name_edit)
        
        # Model ID/Value field
        self.value_edit = QLineEdit()
        self.value_edit.setPlaceholderText("Actual model ID/name used in API calls")
        form_layout.addRow("Model ID:", self.value_edit)
        
        # Add help text
        help_label = QLabel(
            "Note: Model ID should match the exact identifier expected by the API. "
            "For example: 'gpt-4o' for OpenAI or 'gemini-2.0-flash' for Google."
        )
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #666; font-style: italic; font-size: 10px;")
        
        # Button box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Add layouts to main layout
        layout.addLayout(form_layout)
        layout.addWidget(help_label)
        layout.addWidget(button_box)
    
    def _populate_edit_data(self, edit_data: Tuple[str, str]):
        """Populate the dialog with data for editing."""
        display_name, model_id = edit_data
        self.name_edit.setText(display_name)
        self.value_edit.setText(model_id)
    
    def get_model_data(self) -> Tuple[str, str]:
        """Get the model data entered by the user.
        
        Returns:
            Tuple of (display_name, model_id).
        """
        return (self.name_edit.text(), self.value_edit.text())


class ModelManagementWidget(QWidget):
    """Widget for managing LLM models for a provider."""
    
    # Signal emitted when models are updated
    models_updated = Signal(list)  # List of (display_name, model_id) tuples
    
    def __init__(self, parent=None, provider_type: ProviderType = None, provider_name: str = "Provider"):
        """Initialize the widget.
        
        Args:
            parent: Parent widget.
            provider_type: The type of provider.
            provider_name: Human-readable name of the provider.
        """
        super().__init__(parent)
        
        self.provider_type = provider_type
        self.provider_name = provider_name
        self.settings_manager = get_settings_manager()
        self.provider_manager = get_provider_manager()
        
        # Current models list [(display_name, model_id), ...]
        self.models = []
        
        self._setup_ui()
        self._load_models()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Main layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Group box
        group_box = QGroupBox(f"{self.provider_name} Models")
        group_layout = QVBoxLayout(group_box)
        
        # Description
        description = QLabel(f"Manage available models for {self.provider_name}:")
        description.setWordWrap(True)
        group_layout.addWidget(description)
        
        # List and buttons layout
        list_buttons_layout = QHBoxLayout()
        
        # Model list
        self.model_list = QListWidget()
        self.model_list.setMinimumHeight(150)
        self.model_list.itemSelectionChanged.connect(self._handle_selection_changed)
        list_buttons_layout.addWidget(self.model_list)
        
        # Buttons layout
        buttons_layout = QVBoxLayout()
        
        self.add_button = QPushButton("Add")
        self.add_button.clicked.connect(self._handle_add)
        
        self.edit_button = QPushButton("Edit")
        self.edit_button.clicked.connect(self._handle_edit)
        self.edit_button.setEnabled(False)
        
        self.remove_button = QPushButton("Remove")
        self.remove_button.clicked.connect(self._handle_remove)
        self.remove_button.setEnabled(False)
        
        self.set_default_button = QPushButton("Set Default")
        self.set_default_button.clicked.connect(self._handle_set_default)
        self.set_default_button.setEnabled(False)
        
        buttons_layout.addWidget(self.add_button)
        buttons_layout.addWidget(self.edit_button)
        buttons_layout.addWidget(self.remove_button)
        buttons_layout.addWidget(self.set_default_button)
        buttons_layout.addStretch()
        
        list_buttons_layout.addLayout(buttons_layout)
        
        # Default model info
        self.default_model_label = QLabel("Default model: None")
        
        # Add widgets to layout
        group_layout.addLayout(list_buttons_layout)
        group_layout.addWidget(self.default_model_label)
        
        # Add group box to main layout
        layout.addWidget(group_box)
    
    def _load_models(self):
        """Load models from settings."""
        if not self.provider_type:
            return
        
        # Get provider settings
        settings = self.settings_manager.get_provider_settings(self.provider_type)
        available_models = settings.get("available_models", [])
        default_model = settings.get("default_model", "")

        # Seed from master models if empty/missing
        if not available_models:
            try:
                master_path = os.path.join("config", "llm", "models.json")
                if os.path.exists(master_path):
                    with open(master_path, "r", encoding="utf-8") as f:
                        master = json.load(f)
                    provider_map = {
                        ProviderType.OPENAI: "openai",
                        ProviderType.GOOGLE: "google",
                        ProviderType.OPENROUTER: "openrouter",
                        ProviderType.ANTHROPIC: "anthropic"
                    }
                    key = provider_map.get(self.provider_type)
                    if key and key in master:
                        seed = [m.get("id") for m in master[key] if isinstance(m, dict) and m.get("id")]
                        if seed:
                            available_models = seed
                            # Persist the seed so it sticks
                            self.settings_manager.update_provider_settings(
                                self.provider_type, {"available_models": available_models}
                            )
                            logger.info(f"Seeded {self.provider_name} models from master list: {len(seed)} items")
            except Exception as e:
                logger.warning(f"Could not seed models from master list: {e}")
        
        # Clear current models
        self.models = []
        self.model_list.clear()
        
        # Simple case: just model IDs in the list
        if all(isinstance(model, str) for model in available_models):
            for model_id in available_models:
                # Use the model ID as display name too
                self.models.append((model_id, model_id))
                item = QListWidgetItem(model_id)
                item.setData(Qt.UserRole, model_id)
                self.model_list.addItem(item)
        
        # Update default model label
        if default_model:
            self.default_model_label.setText(f"Default model: {default_model}")
        else:
            self.default_model_label.setText("Default model: None")
    
    def _handle_selection_changed(self):
        """Handle selection change in the model list."""
        selected = self.model_list.selectedItems()
        has_selection = len(selected) > 0
        
        self.edit_button.setEnabled(has_selection)
        self.remove_button.setEnabled(has_selection)
        self.set_default_button.setEnabled(has_selection)
    
    def _handle_add(self):
        """Handle add button click."""
        dialog = AddEditModelDialog(self)
        if dialog.exec():
            display_name, model_id = dialog.get_model_data()
            
            # Validate input
            if not display_name or not model_id:
                QMessageBox.warning(self, "Invalid Input", "Both display name and model ID are required.")
                return
            
            # Check for duplicates
            for _, existing_id in self.models:
                if existing_id == model_id:
                    QMessageBox.warning(
                        self, 
                        "Duplicate Model", 
                        f"A model with ID '{model_id}' already exists."
                    )
                    return
            
            # Add to list
            self.models.append((display_name, model_id))
            item = QListWidgetItem(display_name)
            item.setData(Qt.UserRole, model_id)
            self.model_list.addItem(item)
            
            # Update settings
            self._save_models()
    
    def _handle_edit(self):
        """Handle edit button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        display_name = item.text()
        model_id = item.data(Qt.UserRole)
        
        dialog = AddEditModelDialog(self, (display_name, model_id))
        if dialog.exec():
            new_display_name, new_model_id = dialog.get_model_data()
            
            # Validate input
            if not new_display_name or not new_model_id:
                QMessageBox.warning(self, "Invalid Input", "Both display name and model ID are required.")
                return
            
            # Check for duplicates if model ID changed
            if new_model_id != model_id:
                for _, existing_id in self.models:
                    if existing_id == new_model_id:
                        QMessageBox.warning(
                            self, 
                            "Duplicate Model", 
                            f"A model with ID '{new_model_id}' already exists."
                        )
                        return
            
            # Update list
            index = self.model_list.row(item)
            self.models[index] = (new_display_name, new_model_id)
            
            item.setText(new_display_name)
            item.setData(Qt.UserRole, new_model_id)
            
            # Update settings
            self._save_models()
    
    def _handle_remove(self):
        """Handle remove button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        display_name = item.text()
        model_id = item.data(Qt.UserRole)
        
        # Confirm removal
        result = QMessageBox.question(
            self,
            "Remove Model",
            f"Are you sure you want to remove the model '{display_name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if result != QMessageBox.Yes:
            return
        
        # Check if it's the default model
        provider_settings = self.settings_manager.get_provider_settings(self.provider_type)
        default_model = provider_settings.get("default_model", "")
        
        if model_id == default_model:
            result = QMessageBox.question(
                self,
                "Remove Default Model",
                f"This model is currently set as the default model. "
                f"If you remove it, you'll need to select a new default model. "
                f"Do you want to continue?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if result != QMessageBox.Yes:
                return
        
        # Remove from list
        index = self.model_list.row(item)
        self.model_list.takeItem(index)
        self.models.pop(index)
        
        # Update settings
        self._save_models()
        
        # Reset default model if needed
        if model_id == default_model and self.models:
            self._set_default_model(self.models[0][1])  # Use first model as default
    
    def _handle_set_default(self):
        """Handle set default button click."""
        selected = self.model_list.selectedItems()
        if not selected:
            return
        
        item = selected[0]
        model_id = item.data(Qt.UserRole)
        
        self._set_default_model(model_id)
    
    def _set_default_model(self, model_id: str):
        """Set the default model.
        
        Args:
            model_id: The model ID to set as default.
        """
        if not self.provider_type:
            return
        
        # Update settings
        self.settings_manager.update_provider_settings(
            self.provider_type,
            {"default_model": model_id}
        )
        
        # Update UI
        self.default_model_label.setText(f"Default model: {model_id}")
        
        logger.info(f"Set default model for {self.provider_name} to {model_id}")
    
    def _save_models(self):
        """Save the current models to settings."""
        if not self.provider_type:
            return
        
        # Extract model IDs
        model_ids = [model_id for _, model_id in self.models]
        
        # Update settings
        self.settings_manager.update_provider_settings(
            self.provider_type,
            {"available_models": model_ids}
        )
        
        # Emit signal
        self.models_updated.emit(self.models)
        
        logger.info(f"Updated models for {self.provider_name}: {model_ids}")
    
    def set_models(self, models: List[Tuple[str, str]]):
        """Set the models list.
        
        Args:
            models: List of (display_name, model_id) tuples.
        """
        self.models = models.copy()
        self.model_list.clear()
        
        for display_name, model_id in self.models:
            item = QListWidgetItem(display_name)
            item.setData(Qt.UserRole, model_id)
            self.model_list.addItem(item)
        
        # Notify listeners so parent tabs keep their internal state in sync
        self.models_updated.emit(self.models)

```

### File: gui\dialogs\settings\provider_tabs.py

```python
#!/usr/bin/env python3
"""
LLM provider-specific tabs for the RPG game GUI.
This module provides tabs for different LLM providers.
"""

import logging
from typing import Dict, Any, List, Tuple

from PySide6.QtWidgets import (
    QFormLayout, QLineEdit, QLabel, QVBoxLayout
)
from PySide6.QtCore import Qt

from gui.dialogs.settings.llm_provider_tab import LLMProviderTab
from gui.dialogs.settings.model_management_widget import ModelManagementWidget
from core.llm.provider_manager import ProviderType

# Get the module logger
logger = logging.getLogger("GUI")

class OpenAITab(LLMProviderTab):
    """Tab for OpenAI settings."""
    
    def __init__(self, parent=None):
        """Initialize the OpenAI settings tab."""
        super().__init__(parent, provider_name="OpenAI")
        
        # Add OpenAI specific properties
        self.api_key_setting_name = "api_key"
        
        # Add OpenAI specific fields
        form_layout = self.findChild(QFormLayout)
        
        # Organization field
        self.org_edit = QLineEdit()
        self.org_edit.setPlaceholderText("Organization ID (optional)")
        form_layout.insertRow(2, "Organization:", self.org_edit)
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.OPENAI, "OpenAI")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("OpenAI's GPT models are powerful general-purpose models with varying capabilities.")
        
        # Connect signals
        self.enabled_check.toggled.connect(self._toggle_openai_fields)
    
    def _toggle_openai_fields(self, enabled: bool):
        """Toggle OpenAI-specific fields."""
        self.org_edit.setEnabled(enabled)
        self.model_manager.setEnabled(enabled)
        
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set OpenAI-specific settings
        self.org_edit.setText(settings.get("organization", ""))
        self.org_edit.setEnabled(self.enabled_check.isChecked())
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Keep the tab's internal model list in sync so saving doesn't wipe it
        self.models = models
        
        # Set models in model manager
        self.model_manager.set_models(models)
    
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add OpenAI-specific settings
        settings["organization"] = self.org_edit.text()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings


class GoogleTab(LLMProviderTab):
    """Tab for Google settings."""
    
    def __init__(self, parent=None):
        """Initialize the Google settings tab."""
        super().__init__(parent, provider_name="Google AI")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.GOOGLE, "Google AI")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("Google's Gemini models provide strong multilingual capabilities and state-of-the-art performance.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Keep the tab's internal model list in sync so saving doesn't wipe it
        self.models = models
        
        # Set models in model manager
        self.model_manager.set_models(models)
        
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings


class OpenRouterTab(LLMProviderTab):
    """Tab for OpenRouter settings."""
    
    def __init__(self, parent=None):
        """Initialize the OpenRouter settings tab."""
        super().__init__(parent, provider_name="OpenRouter")
        
        # Create model management widget
        self.model_manager = ModelManagementWidget(self, ProviderType.OPENROUTER, "OpenRouter")
        self.model_manager.models_updated.connect(self._on_models_updated)
        
        # Add model manager to the main layout
        self.main_layout.insertWidget(self.main_layout.count() - 1, self.model_manager)
        
        # Set info text
        self.info_label.setText("OpenRouter allows access to multiple AI models from different providers through a single API. Create an account at openrouter.ai to get started.")
    
    def _toggle_fields(self, enabled: bool):
        """Toggle fields based on enabled state."""
        super()._toggle_fields(enabled)
        self.model_manager.setEnabled(enabled)
    
    def _on_models_updated(self, models: List[Tuple[str, str]]):
        """Handle models updated from model manager.
        
        Args:
            models: List of (display_name, value) tuples
        """
        # Just store the models
        self.models = models
    
    def set_settings(self, settings: Dict[str, Any]):
        """Set the tab settings."""
        super().set_settings(settings)
        
        # Set up models for model management widget
        available_models = settings.get("available_models", [])
        models = []
        for model in available_models:
            # Use the model ID as the display name as well
            models.append((model, model))
            
        # Keep the tab's internal model list in sync so saving doesn't wipe it
        self.models = models
        
        # Set models in model manager
        self.model_manager.set_models(models)
        
    def get_settings(self) -> Dict[str, Any]:
        """Get the current settings from the tab."""
        settings = super().get_settings()
        
        # Add models
        model_ids = [model_id for _, model_id in self.models]
        settings["available_models"] = model_ids
        
        return settings

```

### File: gui\dialogs\settings\settings_dialog.py

```python
# --- START OF FILE settings_dialog.py ---

#!/usr/bin/env python3
"""
Settings dialog for the RPG game GUI.
This module provides a dialog for configuring game settings.
"""

import logging
import json
import os
from typing import Dict, Any
from core.base.config import get_config

from gui.dialogs.base_dialog import BaseDialog
from gui.dialogs.settings.style_tab import StyleTab
from gui.dialogs.settings.background_tab import BackgroundTab 

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox,
    QPushButton, QTabWidget, QWidget, QFormLayout,
    QCheckBox, QSpinBox, QGroupBox, QRadioButton, QButtonGroup,
    QSlider 
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize, Slot
from PySide6.QtGui import QColor 

class SettingsDialog(BaseDialog):
    """Dialog for configuring game settings."""

    # Signal emitted when settings are saved
    settings_saved = Signal()

    # Signal emitted when a background preview is requested by the BackgroundTab
    background_preview_requested = Signal(str)

    def __init__(self, parent=None):
        """Initialize the settings dialog."""
        super().__init__(parent)


        # # --- ADDED: Ensure dialog has a default background --- 
        # self.setAutoFillBackground(True)
        # palette = self.palette()
        # # Use a light color that usually contrasts well with default black text
        # palette.setColor(self.backgroundRole(), QColor("#F0F0F0")) 
        # self.setPalette(palette)
        # # --- END ADDED --- 

        # Set dialog properties
        self.setWindowTitle("Game Settings")
        self.setMinimumWidth(500)

        # Load current settings
        self.settings = QSettings("RPGGame", "Settings")

        # Set up the UI
        self._setup_ui()

        # Load settings into the UI
        self._load_settings()

    def _setup_ui(self):
        """Set up the user interface."""
        # Create main layout
        layout = QVBoxLayout(self)

        # Create tab widget for settings categories
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget::pane { /* The area where tab pages are displayed */
                border: 1px solid #555555;
                background-color: #2D2D30; /* Dark background for the content pane */
                border-top: 1px solid #555555; /* Ensure top border is visible */
            }
            QTabBar::tab { /* Style for individual tabs */
                background-color: #333333; /* Dark background for non-selected tabs */
                color: #CCCCCC; /* Light text for non-selected tabs */
                border: 1px solid #555555;
                border-bottom: none; /* Remove bottom border for non-selected tabs */
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 12px; /* Adjusted padding */
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2D2D30; /* Match pane background for selected tab */
                color: #E0E0E0; /* Brighter text for selected tab */
                border-bottom: 1px solid #2D2D30; /* Blend selected tab with pane */
            }
            QTabBar::tab:!selected:hover {
                background-color: #454545; /* Slightly lighter for hover on non-selected tabs */
            }
            QTabWidget QWidget { /* Ensure widgets inside tabs also have transparent background if needed */
                 background-color: transparent; /* Or match #2D2D30 if transparency causes issues */
            }
        """)

        # Set up tabs
        self._setup_display_tab()
        self._setup_sound_tab()
        self._setup_gameplay_tab()
        self._setup_style_tab()
        self._setup_background_tab()

        # Add tab widget to layout
        layout.addWidget(self.tab_widget)

        # Create button box
        button_layout = QHBoxLayout()

        # Save button
        self.save_button = QPushButton("Save")
        self.save_button.clicked.connect(self._save_settings)

        # Cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)

        # Add buttons to layout
        button_layout.addStretch()
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.cancel_button)

        # Add button layout to main layout
        layout.addLayout(button_layout)

    def _setup_display_tab(self):
        """Set up the display settings tab."""
        # Create display tab
        display_tab = QWidget()
        display_layout = QVBoxLayout(display_tab)

        # Create form layout for settings
        form_layout = QFormLayout()

        # --- Window Mode Setting ---
        display_mode_group = QGroupBox("Display Mode")
        display_mode_layout = QVBoxLayout(display_mode_group)
        self.display_mode_group = QButtonGroup(self) # Group for radio buttons

        self.windowed_radio = QRadioButton("Windowed")
        self.windowed_fullscreen_radio = QRadioButton("Windowed Fullscreen (Maximized)")
        self.fullscreen_radio = QRadioButton("Fullscreen")

        self.display_mode_group.addButton(self.windowed_radio, 0)
        self.display_mode_group.addButton(self.windowed_fullscreen_radio, 1)
        self.display_mode_group.addButton(self.fullscreen_radio, 2)

        display_mode_layout.addWidget(self.windowed_radio)
        display_mode_layout.addWidget(self.windowed_fullscreen_radio)
        display_mode_layout.addWidget(self.fullscreen_radio)

        # --- Resolution Setting (Enabled only for Windowed) ---
        resolution_layout = QHBoxLayout()
        self.resolution_label = QLabel("Resolution (Windowed):") # Label clarifies when it applies
        self.resolution_combo = QComboBox()
        self.resolution_combo.addItem("800x600", QSize(800, 600))
        self.resolution_combo.addItem("1024x768", QSize(1024, 768))
        self.resolution_combo.addItem("1280x720", QSize(1280, 720))
        self.resolution_combo.addItem("1366x768", QSize(1366, 768))
        self.resolution_combo.addItem("1600x900", QSize(1600, 900))
        self.resolution_combo.addItem("1920x1080", QSize(1920, 1080))
        # Add more resolutions if needed
        resolution_layout.addWidget(self.resolution_label)
        resolution_layout.addWidget(self.resolution_combo)

        # Connect radio button toggle to enable/disable resolution combo
        self.windowed_radio.toggled.connect(self._update_resolution_state)

        # Add display mode and resolution to the form layout
        display_layout.addWidget(display_mode_group)
        display_layout.addLayout(resolution_layout) # Add the HBox layout

        # --- UI Scale Setting ---
        self.ui_scale_combo = QComboBox()
        self.ui_scale_combo.addItem("100%", 1.0)
        self.ui_scale_combo.addItem("125%", 1.25)
        self.ui_scale_combo.addItem("150%", 1.5)
        self.ui_scale_combo.addItem("175%", 1.75)
        self.ui_scale_combo.addItem("200%", 2.0)
        # Add UI Scale to its own layout or directly if preferred
        ui_scale_layout = QHBoxLayout()
        ui_scale_layout.addWidget(QLabel("UI Scale:"))
        ui_scale_layout.addWidget(self.ui_scale_combo)
        display_layout.addLayout(ui_scale_layout)

        # --- Text Speed Setting ---
        text_speed_layout = QHBoxLayout()
        text_speed_layout.addWidget(QLabel("Gradual Text Speed:"))
        self.text_speed_slider = QSlider(Qt.Horizontal)
        self.text_speed_slider.setRange(5, 100)
        self.text_speed_slider.setTickPosition(QSlider.TicksBelow)
        self.text_speed_slider.setTickInterval(10)
        self.text_speed_label = QLabel("30 ms")
        self.text_speed_slider.valueChanged.connect(
            lambda value: self.text_speed_label.setText(f"{value} ms")
        )
        text_speed_layout.addWidget(self.text_speed_slider)
        text_speed_layout.addWidget(self.text_speed_label)
        display_layout.addLayout(text_speed_layout)

        display_layout.addStretch()

        # Add display tab to tab widget
        self.tab_widget.addTab(display_tab, "Display")

    @Slot(bool)
    def _update_resolution_state(self, checked):
        """Enable/disable resolution combo based on Windowed mode selection."""
        is_windowed = self.windowed_radio.isChecked()
        self.resolution_label.setEnabled(is_windowed)
        self.resolution_combo.setEnabled(is_windowed)

    def _setup_sound_tab(self):
        """Set up the sound settings tab."""
        # Create sound tab
        sound_tab = QWidget()
        sound_layout = QVBoxLayout(sound_tab)

        # Create form layout for settings
        form_layout = QFormLayout()

        # Create master volume setting
        self.master_volume_spin = QSpinBox()
        self.master_volume_spin.setRange(0, 100)
        self.master_volume_spin.setSuffix("%")
        form_layout.addRow("Master Volume:", self.master_volume_spin)

        # Create music volume setting
        self.music_volume_spin = QSpinBox()
        self.music_volume_spin.setRange(0, 100)
        self.music_volume_spin.setSuffix("%")
        form_layout.addRow("Music Volume:", self.music_volume_spin)

        # Create sound effects volume setting
        self.effects_volume_spin = QSpinBox()
        self.effects_volume_spin.setRange(0, 100)
        self.effects_volume_spin.setSuffix("%")
        form_layout.addRow("Sound Effects Volume:", self.effects_volume_spin)

        # Create sound enabled checkbox
        self.sound_enabled_check = QCheckBox("Enable Sound")

        # Add form layout to sound layout
        sound_layout.addLayout(form_layout)
        sound_layout.addWidget(self.sound_enabled_check)
        sound_layout.addStretch()

        # Add sound tab to tab widget
        self.tab_widget.addTab(sound_tab, "Sound")

    def _setup_gameplay_tab(self):
        """Set up the gameplay settings tab."""
        # Create gameplay tab
        gameplay_tab = QWidget()
        gameplay_layout = QVBoxLayout(gameplay_tab)

        # Developer Mode group
        dev_group = QGroupBox("Developer Mode")
        dev_layout = QVBoxLayout(dev_group)
        self.dev_mode_checkbox = QCheckBox("Enable Developer Mode (show debug UI and controls)")
        dev_layout.addWidget(self.dev_mode_checkbox)
        gameplay_layout.addWidget(dev_group)

        # Create form layout for settings
        form_layout = QFormLayout()

        # Create difficulty setting (aligned with families generation rules)
        self.difficulty_combo = QComboBox()
        self.difficulty_combo.addItem("Story")
        self.difficulty_combo.addItem("Normal")
        self.difficulty_combo.addItem("Hard")
        self.difficulty_combo.addItem("Expert")
        form_layout.addRow("Difficulty:", self.difficulty_combo)

        # Encounter size setting
        self.encounter_combo = QComboBox()
        self.encounter_combo.addItem("Solo")
        self.encounter_combo.addItem("Pack")
        self.encounter_combo.addItem("Mixed")
        form_layout.addRow("Encounter Size:", self.encounter_combo)

        # Create auto-save interval setting (turn-based)
        self.autosave_combo = QComboBox()
        # Off = 0 turns; provide common presets
        self.autosave_combo.addItem("Off", 0)
        self.autosave_combo.addItem("Every 1 turn", 1)
        self.autosave_combo.addItem("Every 3 turns", 3)
        self.autosave_combo.addItem("Every 5 turns", 5)
        self.autosave_combo.addItem("Every 10 turns", 10)
        self.autosave_combo.addItem("Every 20 turns", 20)
        self.autosave_combo.addItem("Every 50 turns", 50)
        form_layout.addRow("Auto-save:", self.autosave_combo)

        # Create tutorial checkbox
        self.tutorial_check = QCheckBox("Show Tutorial Tips")

        # Add form layout to gameplay layout
        gameplay_layout.addLayout(form_layout)
        gameplay_layout.addWidget(self.tutorial_check)
        gameplay_layout.addStretch()

        # Add gameplay tab to tab widget
        self.tab_widget.addTab(gameplay_tab, "Gameplay")

    def _load_settings(self):
        """Load settings from QSettings to the UI."""
        # Load display settings
        window_state = self.settings.value("display/window_state", "windowed")
        if window_state == "fullscreen":
            self.fullscreen_radio.setChecked(True)
        elif window_state == "maximized": # Changed key to 'maximized'
            self.windowed_fullscreen_radio.setChecked(True)
        else: # Default to windowed
            self.windowed_radio.setChecked(True)

        # Update resolution combo state initially
        self._update_resolution_state(self.windowed_radio.isChecked())

        # Load windowed resolution (even if not currently windowed)
        default_size = QSize(1280, 720)
        resolution = self.settings.value("display/windowed_size", default_size)
        # Ensure resolution is QSize
        if not isinstance(resolution, QSize):
            if isinstance(resolution, (tuple, list)) and len(resolution) == 2:
                resolution = QSize(resolution[0], resolution[1])
            elif isinstance(resolution, str):
                try:
                    parts = resolution.strip('()').split(',')
                    resolution = QSize(int(parts[0]), int(parts[1]))
                except Exception:
                    resolution = default_size # Fallback on parse error
            else:
                 resolution = default_size # Fallback if type is unexpected

        resolution_str = f"{resolution.width()}x{resolution.height()}"
        found = False
        for i in range(self.resolution_combo.count()):
            if self.resolution_combo.itemText(i) == resolution_str:
                self.resolution_combo.setCurrentIndex(i)
                found = True
                break
        if not found: # If saved resolution isn't in the list, add it? Or default?
            # Option 1: Add it (might make combo long)
            # self.resolution_combo.addItem(resolution_str, resolution)
            # self.resolution_combo.setCurrentIndex(self.resolution_combo.count() - 1)
            # Option 2: Default to first item if not found
             self.resolution_combo.setCurrentIndex(0)
             logging.warning(f"Saved windowed resolution {resolution_str} not found in options. Defaulting.")


        # Load UI scale (unchanged)
        ui_scale = self.settings.value("display/ui_scale", 1.0)
        for i in range(self.ui_scale_combo.count()):
            if self.ui_scale_combo.itemData(i) == ui_scale:
                self.ui_scale_combo.setCurrentIndex(i)
                break

        # Load text speed setting (unchanged)
        text_speed_delay = self.settings.value("display/text_speed_delay", 30, int)
        self.text_speed_slider.setValue(text_speed_delay)
        self.text_speed_label.setText(f"{text_speed_delay} ms")

        # Load sound settings (unchanged)
        self.master_volume_spin.setValue(int(self.settings.value("sound/master_volume", 100)))
        self.music_volume_spin.setValue(int(self.settings.value("sound/music_volume", 100)))
        self.effects_volume_spin.setValue(int(self.settings.value("sound/effects_volume", 100)))
        sound_enabled = self.settings.value("sound/enabled", True)
        if isinstance(sound_enabled, str): sound_enabled = sound_enabled.lower() == "true"
        self.sound_enabled_check.setChecked(sound_enabled)

        # Load gameplay settings
        # Map legacy values if needed ("Easy" -> "Story")
        difficulty = self.settings.value("gameplay/difficulty", "Normal")
        if difficulty == "Easy":
            difficulty = "Story"
        found = False
        for i in range(self.difficulty_combo.count()):
            if self.difficulty_combo.itemText(i) == difficulty:
                self.difficulty_combo.setCurrentIndex(i)
                found = True
                break
        if not found:
            # Default to Normal if unmatched
            for i in range(self.difficulty_combo.count()):
                if self.difficulty_combo.itemText(i) == "Normal":
                    self.difficulty_combo.setCurrentIndex(i)
                    break

        encounter = self.settings.value("gameplay/encounter_size", "Solo")
        found_e = False
        for i in range(self.encounter_combo.count()):
            if self.encounter_combo.itemText(i) == encounter:
                self.encounter_combo.setCurrentIndex(i)
                found_e = True
                break
        if not found_e:
            # Default to Solo
            for i in range(self.encounter_combo.count()):
                if self.encounter_combo.itemText(i) == "Solo":
                    self.encounter_combo.setCurrentIndex(i)
                    break

        # Load autosave (turns). Backward-compat: if value was minutes, treat as off
        autosave_turns = int(self.settings.value("gameplay/autosave_interval", 0))
        # Find matching index; default to Off if not found
        found_idx = -1
        for i in range(self.autosave_combo.count()):
            if int(self.autosave_combo.itemData(i)) == autosave_turns:
                found_idx = i
                break
        self.autosave_combo.setCurrentIndex(found_idx if found_idx >= 0 else 0)
        tutorial_enabled = self.settings.value("gameplay/tutorial_enabled", True)
        if isinstance(tutorial_enabled, str): tutorial_enabled = tutorial_enabled.lower() == "true"
        self.tutorial_check.setChecked(tutorial_enabled)

        # Load dev mode
        dev_enabled = self.settings.value("dev/enabled", False)
        if isinstance(dev_enabled, str):
            dev_enabled = dev_enabled.lower() == "true"
        self.dev_mode_checkbox.setChecked(bool(dev_enabled))

        # Load style settings
        if hasattr(self, 'style_tab'):
            self.style_tab._load_settings() 

        if hasattr(self, 'background_tab'):
             self.background_tab.load_settings(self.settings)

    def _setup_style_tab(self):
        """Set up the style settings tab."""
        # Create style tab
        self.style_tab = StyleTab()

        # Add style tab to tab widget
        self.tab_widget.addTab(self.style_tab, "Style")


    def _setup_background_tab(self):
        """Set up the background selection tab."""
        # Create background tab
        self.background_tab = BackgroundTab()

        # Connect the preview signal from the tab to this dialog's signal
        self.background_tab.preview_background_changed.connect(self.background_preview_requested)

        # Add background tab to tab widget
        self.tab_widget.addTab(self.background_tab, "Background")

    def _save_settings(self):
        """Save settings from the UI to QSettings."""
        # Save window state
        window_state_str = "windowed" # Default
        if self.fullscreen_radio.isChecked():
            window_state_str = "fullscreen"
        elif self.windowed_fullscreen_radio.isChecked():
            window_state_str = "maximized" # Use 'maximized' internally
        self.settings.setValue("display/window_state", window_state_str)

        # Save windowed resolution *only* if windowed mode is selected
        if window_state_str == "windowed":
            selected_resolution = self.resolution_combo.currentData()
            if isinstance(selected_resolution, QSize): # Store QSize directly if possible
                self.settings.setValue("display/windowed_size", selected_resolution)
            else: # Fallback to storing tuple if currentData wasn't QSize
                resolution_text = self.resolution_combo.currentText()
                try:
                    w, h = map(int, resolution_text.split('x'))
                    self.settings.setValue("display/windowed_size", (w, h))
                except ValueError:
                    logging.error(f"Could not parse resolution text '{resolution_text}' during save.")
                    # Optionally save a default or skip saving resolution

        # Save UI scale (unchanged)
        self.settings.setValue("display/ui_scale", self.ui_scale_combo.currentData())

        # Save text speed setting (unchanged)
        self.settings.setValue("display/text_speed_delay", self.text_speed_slider.value())

        # Save sound settings (unchanged)
        self.settings.setValue("sound/master_volume", self.master_volume_spin.value())
        self.settings.setValue("sound/music_volume", self.music_volume_spin.value())
        self.settings.setValue("sound/effects_volume", self.effects_volume_spin.value())
        self.settings.setValue("sound/enabled", self.sound_enabled_check.isChecked())

        # Save gameplay settings
        self.settings.setValue("gameplay/difficulty", self.difficulty_combo.currentText())
        self.settings.setValue("gameplay/encounter_size", self.encounter_combo.currentText())
        # Save autosave turns (0=Off)
        self.settings.setValue("gameplay/autosave_interval", int(self.autosave_combo.currentData()))
        self.settings.setValue("gameplay/tutorial_enabled", self.tutorial_check.isChecked())

        # Reflect gameplay settings into in-memory GameConfig for immediate effect
        try:
            cfg = get_config()
            cfg._config_data.setdefault("game", {})
            # Map UI labels to config tokens expected by generator
            diff_map = {"Story": "story", "Normal": "normal", "Hard": "hard", "Expert": "expert"}
            enc_map = {"Solo": "solo", "Pack": "pack", "Mixed": "mixed"}
            cfg._config_data["game"]["difficulty"] = diff_map.get(self.difficulty_combo.currentText(), "normal")
            cfg._config_data["game"]["encounter_size"] = enc_map.get(self.encounter_combo.currentText(), "solo")
        except Exception:
            # Non-fatal if config is unavailable here
            pass

        # Save dev mode
        self.settings.setValue("dev/enabled", self.dev_mode_checkbox.isChecked())

        # Save style settings (unchanged)
        if hasattr(self, 'style_tab'):
            self.style_tab.save_settings()

        # Save background settings (unchanged)
        if hasattr(self, 'background_tab'):
            self.background_tab.save_settings(self.settings)

        # Sync settings to disk
        self.settings.sync()

        # Emit signal
        self.settings_saved.emit()

        # Close dialog
        self.accept()

    @staticmethod
    def get_settings():
        """Get the current settings.

        Returns:
            Dict[str, Any]: The current settings.
        """
        settings = QSettings("RPGGame", "Settings")
        # ... (rest of the method implementation) ...

        # Helper to convert loaded QSize to tuple if needed
        def size_to_tuple(size_val):
            if isinstance(size_val, QSize):
                return (size_val.width(), size_val.height())
            # Handle tuple/list potentially saved previously
            elif isinstance(size_val, (tuple, list)) and len(size_val) == 2:
                return tuple(size_val)
            # Handle string format
            elif isinstance(size_val, str):
                try:
                    parts = size_val.strip('()').split(',')
                    return (int(parts[0]), int(parts[1]))
                except Exception:
                    return (1280, 720) # Fallback
            return (1280, 720) # Default fallback

        return {
            "display": {
                "window_state": settings.value("display/window_state", "windowed"),
                "windowed_size": size_to_tuple(settings.value("display/windowed_size", QSize(1280, 720))), # Get saved windowed size
                "ui_scale": settings.value("display/ui_scale", 1.0),
                "text_speed_delay": settings.value("display/text_speed_delay", 30, int)
            },
            "sound": {
                "master_volume": settings.value("sound/master_volume", 100),
                "music_volume": settings.value("sound/music_volume", 100),
                "effects_volume": settings.value("sound/effects_volume", 100),
                "enabled": settings.value("sound/enabled", True)
            },
            "gameplay": {
                "difficulty": settings.value("gameplay/difficulty", "Normal"),
                "autosave_interval": settings.value("gameplay/autosave_interval", 0),
                "tutorial_enabled": settings.value("gameplay/tutorial_enabled", True)
            },
            "style": {
                "output_bg_color": settings.value("style/output_bg_color", "#D2B48C"),
                "system_msg_color": settings.value("style/system_msg_color", "#FF0000"),
                "font_family": settings.value("style/font_family", "Garamond"),
                "font_size": settings.value("style/font_size", 14),
                "font_color": settings.value("style/font_color", "#000000"),
                "user_input_font_family": settings.value("style/user_input_font_family", "Garamond"),
                "user_input_font_size": settings.value("style/user_input_font_size", 14),
                "user_input_font_color": settings.value("style/user_input_font_color", "#0d47a1"),
                "background_filename": settings.value("style/background_filename", None), # Load filename string
                "texture_name": settings.value("style/texture_name", "subtle_noise"),
                "output_opacity": settings.value("style/output_opacity", 100, int),
                "input_opacity": settings.value("style/input_opacity", 100, int)
            }
        }
```

### File: gui\dialogs\settings\style_tab.py

```python
#!/usr/bin/env python3
"""
Style settings tab for the RPG game GUI.
This module provides a tab for configuring UI style settings.
"""

import os
import logging
from typing import Dict, Any

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, 
    QPushButton, QFormLayout, QGroupBox, QRadioButton, 
    QButtonGroup, QColorDialog, QFontDialog, QGridLayout,
    QFrame, QSlider
)
from PySide6.QtCore import Qt, Signal, QSettings, QSize
from PySide6.QtGui import QFont, QColor, QPixmap, QIcon

class StyleTab(QWidget):
    """Tab for configuring UI style settings."""
    
    def __init__(self, parent=None):
        """Initialize the style tab."""
        super().__init__(parent)
        
        # Set up the UI
        self._setup_ui()
        
        # Load settings
        self._load_settings()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create main layout
        layout = QVBoxLayout(self)
        
        # Create form layout for settings
        form_layout = QFormLayout()
        
        # Output area background color
        self.output_bg_group = QGroupBox("Output Area Background")
        self.output_bg_layout = QVBoxLayout(self.output_bg_group)
        
        # Predefined colors
        self.predefined_colors_layout = QGridLayout()
        self.predefined_colors_layout.setSpacing(5)
        
        # Add predefined color options
        self.color_buttons = {}
        predefined_colors = [
            ("Light Brown", "#D2B48C"),
            ("Dark Brown", "#8B4513"),
            ("Beige", "#F5F5DC"),
            ("Cream", "#FFFDD0"),
            ("Tan", "#D2B48C"),
            ("Ivory", "#FFFFF0"),
            ("Light Gray", "#D3D3D3"),
            ("Light Blue", "#ADD8E6"),
            ("Light Green", "#90EE90"),
            ("Light Red", "#FFCCCB"),
        ]
        
        # Create a button group for color selection
        self.bg_color_group = QButtonGroup(self)
        self.bg_color_group.setExclusive(True)
        
        # Add color buttons to grid
        row, col = 0, 0
        for i, (color_name, color_hex) in enumerate(predefined_colors):
            button = QRadioButton(color_name)
            # Set a background color style for the button
            button.setStyleSheet(f"QRadioButton {{ background-color: {color_hex}; padding: 5px; border-radius: 3px; }}")
            button.setProperty("color_hex", color_hex)
            
            self.predefined_colors_layout.addWidget(button, row, col)
            self.color_buttons[color_name] = button
            self.bg_color_group.addButton(button)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Custom color picker
        self.custom_color_layout = QHBoxLayout()
        self.custom_color_radio = QRadioButton("Custom:")
        self.bg_color_group.addButton(self.custom_color_radio)
        
        self.custom_color_button = QPushButton("Choose...")
        self.custom_color_button.clicked.connect(self._choose_custom_bg_color)
        
        self.custom_color_preview = QFrame()
        self.custom_color_preview.setFixedSize(20, 20)
        self.custom_color_preview.setFrameShape(QFrame.StyledPanel)
        self.custom_color_preview.setStyleSheet("background-color: #D2B48C; border: 1px solid gray;")
        
        self.custom_color_layout.addWidget(self.custom_color_radio)
        self.custom_color_layout.addWidget(self.custom_color_button)
        self.custom_color_layout.addWidget(self.custom_color_preview)
        self.custom_color_layout.addStretch()
        
        # Add layouts to output bg group
        self.output_bg_layout.addLayout(self.predefined_colors_layout)
        self.output_bg_layout.addLayout(self.custom_color_layout)
        
        # System message color
        self.system_msg_group = QGroupBox("System Message Color")
        self.system_msg_layout = QVBoxLayout(self.system_msg_group)
        
        # Predefined system colors
        self.sys_colors_layout = QGridLayout()
        self.sys_colors_layout.setSpacing(5)
        
        # Add predefined system color options
        self.sys_color_buttons = {}
        predefined_sys_colors = [
            ("Red", "#FF0000"),
            ("Orange", "#FFA500"),
            ("Yellow", "#FFFF00"),
            ("Green", "#00FF00"),
            ("Blue", "#0000FF"),
            ("Purple", "#800080"),
            ("Pink", "#FFC0CB"),
            ("Black", "#000000"),
        ]
        
        # Create a button group for system color selection
        self.sys_color_group = QButtonGroup(self)
        self.sys_color_group.setExclusive(True)
        
        # Add system color buttons to grid
        row, col = 0, 0
        for i, (color_name, color_hex) in enumerate(predefined_sys_colors):
            button = QRadioButton(color_name)
            # Set a foreground color style for the button
            button.setStyleSheet(f"QRadioButton {{ color: {color_hex}; font-weight: bold; }}")
            button.setProperty("color_hex", color_hex)
            
            self.sys_colors_layout.addWidget(button, row, col)
            self.sys_color_buttons[color_name] = button
            self.sys_color_group.addButton(button)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Custom system color picker
        self.custom_sys_color_layout = QHBoxLayout()
        self.custom_sys_color_radio = QRadioButton("Custom:")
        self.sys_color_group.addButton(self.custom_sys_color_radio)
        
        self.custom_sys_color_button = QPushButton("Choose...")
        self.custom_sys_color_button.clicked.connect(self._choose_custom_sys_color)
        
        self.custom_sys_color_preview = QFrame()
        self.custom_sys_color_preview.setFixedSize(20, 20)
        self.custom_sys_color_preview.setFrameShape(QFrame.StyledPanel)
        self.custom_sys_color_preview.setStyleSheet("background-color: #FF0000; border: 1px solid gray;")
        
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_radio)
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_button)
        self.custom_sys_color_layout.addWidget(self.custom_sys_color_preview)
        self.custom_sys_color_layout.addStretch()
        
        # Add layouts to system msg group
        self.system_msg_layout.addLayout(self.sys_colors_layout)
        self.system_msg_layout.addLayout(self.custom_sys_color_layout)
        
        # Output Text Font settings
        self.font_group = QGroupBox("Output Text Font")
        self.font_layout = QVBoxLayout(self.font_group)
        
        self.font_button = QPushButton("Choose Font...")
        self.font_button.clicked.connect(self._choose_font)
        
        self.font_preview = QLabel("AaBbCcDdEe 12345")
        self.font_preview.setAlignment(Qt.AlignCenter)
        self.font_preview.setFrameShape(QFrame.StyledPanel)
        self.font_preview.setMinimumHeight(40)
        
        self.font_layout.addWidget(self.font_button)
        self.font_layout.addWidget(self.font_preview)
        
        # Font color
        self.font_color_layout = QHBoxLayout()
        self.font_color_label = QLabel("Font Color:")
        self.font_color_button = QPushButton("Choose...")
        self.font_color_button.clicked.connect(self._choose_font_color)
        
        self.font_color_preview = QFrame()
        self.font_color_preview.setFixedSize(20, 20)
        self.font_color_preview.setFrameShape(QFrame.StyledPanel)
        self.font_color_preview.setStyleSheet("background-color: #000000; border: 1px solid gray;")
        
        self.font_color_layout.addWidget(self.font_color_label)
        self.font_color_layout.addWidget(self.font_color_button)
        self.font_color_layout.addWidget(self.font_color_preview)
        self.font_color_layout.addStretch()
        
        self.font_layout.addLayout(self.font_color_layout)
        
        # User Input Text Font settings
        self.user_input_font_group = QGroupBox("User Input Text Font")
        self.user_input_font_layout = QVBoxLayout(self.user_input_font_group)
        
        self.user_input_font_button = QPushButton("Choose Font...")
        self.user_input_font_button.clicked.connect(self._choose_user_input_font)
        
        self.user_input_font_preview = QLabel("AaBbCcDdEe 12345")
        self.user_input_font_preview.setAlignment(Qt.AlignCenter)
        self.user_input_font_preview.setFrameShape(QFrame.StyledPanel)
        self.user_input_font_preview.setMinimumHeight(40)
        
        self.user_input_font_layout.addWidget(self.user_input_font_button)
        self.user_input_font_layout.addWidget(self.user_input_font_preview)
        
        # User input font color
        self.user_input_font_color_layout = QHBoxLayout()
        self.user_input_font_color_label = QLabel("Font Color:")
        self.user_input_font_color_button = QPushButton("Choose...")
        self.user_input_font_color_button.clicked.connect(self._choose_user_input_font_color)
        
        self.user_input_font_color_preview = QFrame()
        self.user_input_font_color_preview.setFixedSize(20, 20)
        self.user_input_font_color_preview.setFrameShape(QFrame.StyledPanel)
        self.user_input_font_color_preview.setStyleSheet("background-color: #0d47a1; border: 1px solid gray;")
        
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_label)
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_button)
        self.user_input_font_color_layout.addWidget(self.user_input_font_color_preview)
        self.user_input_font_color_layout.addStretch()
        
        self.user_input_font_layout.addLayout(self.user_input_font_color_layout)
        
        # Add all settings to the form layout
        layout.addWidget(self.output_bg_group)
        layout.addWidget(self.system_msg_group)
        layout.addWidget(self.font_group)
        layout.addWidget(self.user_input_font_group)
        
        # Add texture and transparency settings
        self._setup_texture_settings(layout)
        self._setup_transparency_settings(layout)
        
        layout.addStretch()
    
    def _setup_texture_settings(self, parent_layout):
        """Set up texture settings."""
        # Create a group box for texture settings
        self.texture_group = QGroupBox("Background Texture")
        texture_layout = QVBoxLayout(self.texture_group)
        
        # Create radio buttons for texture selection
        self.texture_radio_group = QButtonGroup(self)
        self.texture_radio_group.setExclusive(True)
        
        # Define available textures
        textures = [
            ("None", "none"),
            ("Subtle Noise", "subtle_noise"),
            ("Parchment", "parchment"),
            ("Leather", "leather"),
            ("Stone", "stone")
        ]
        
        # Create a grid layout for texture options
        texture_grid = QGridLayout()
        texture_grid.setSpacing(10)
        
        # Create radio buttons for each texture
        self.texture_buttons = {}
        row, col = 0, 0
        for i, (display_name, texture_name) in enumerate(textures):
            button = QRadioButton(display_name)
            button.setProperty("texture_name", texture_name)
            self.texture_buttons[texture_name] = button
            self.texture_radio_group.addButton(button)
            
            texture_grid.addWidget(button, row, col)
            
            col += 1
            if col > 2:  # 3 columns per row
                col = 0
                row += 1
        
        # Add grid to layout
        texture_layout.addLayout(texture_grid)
        
        # Add group to parent layout
        parent_layout.addWidget(self.texture_group)
    
    def _setup_transparency_settings(self, parent_layout):
        """Set up transparency settings."""
        # Create group box
        self.transparency_group = QGroupBox("Transparency Settings")
        transparency_layout = QFormLayout(self.transparency_group)
        
        # Create output transparency slider
        self.output_transparency_slider = QSlider(Qt.Horizontal)
        self.output_transparency_slider.setRange(0, 100)
        self.output_transparency_slider.setValue(100)  # Default to fully opaque
        self.output_transparency_slider.setTickPosition(QSlider.TicksBelow)
        self.output_transparency_slider.setTickInterval(10)
        
        # Create input transparency slider
        self.input_transparency_slider = QSlider(Qt.Horizontal)
        self.input_transparency_slider.setRange(0, 100)
        self.input_transparency_slider.setValue(100)  # Default to fully opaque
        self.input_transparency_slider.setTickPosition(QSlider.TicksBelow)
        self.input_transparency_slider.setTickInterval(10)
        
        # Add sliders to layout
        transparency_layout.addRow("Output Area Opacity:", self.output_transparency_slider)
        transparency_layout.addRow("Command Input Opacity:", self.input_transparency_slider)
        
        # Add value labels
        self.output_transparency_value = QLabel("100%")
        self.input_transparency_value = QLabel("100%")
        
        transparency_layout.addRow("", self.output_transparency_value)
        transparency_layout.addRow("", self.input_transparency_value)
        
        # Connect sliders to update value labels
        self.output_transparency_slider.valueChanged.connect(
            lambda v: self.output_transparency_value.setText(f"{v}%")
        )
        self.input_transparency_slider.valueChanged.connect(
            lambda v: self.input_transparency_value.setText(f"{v}%")
        )
        
        # Add group to parent layout
        parent_layout.addWidget(self.transparency_group)
    
    def _choose_custom_bg_color(self):
        """Open color dialog for custom background color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/output_bg_color", "#D2B48C"))
        
        color = QColorDialog.getColor(current_color, self, "Select Background Color")
        if color.isValid():
            # Update preview
            self.custom_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Select custom radio button
            self.custom_color_radio.setChecked(True)
            # Store color hex
            self.custom_color_radio.setProperty("color_hex", color.name())
    
    def _choose_custom_sys_color(self):
        """Open color dialog for custom system message color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/system_msg_color", "#FF0000"))
        
        color = QColorDialog.getColor(current_color, self, "Select System Message Color")
        if color.isValid():
            # Update preview
            self.custom_sys_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Select custom radio button
            self.custom_sys_color_radio.setChecked(True)
            # Store color hex
            self.custom_sys_color_radio.setProperty("color_hex", color.name())
    
    def _choose_font(self):
        """Open font dialog."""
        settings = QSettings("RPGGame", "Settings")
        current_font = QFont()
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        current_font.setFamily(font_family)
        current_font.setPointSize(font_size)
        
        ok, font = QFontDialog.getFont(current_font, self, "Select Font")
        if ok:
            # Update preview
            self.font_preview.setFont(font)
            # Store font
            self.font_preview.setProperty("selected_font", font)
    
    def _choose_user_input_font(self):
        """Open font dialog for user input text."""
        settings = QSettings("RPGGame", "Settings")
        current_font = QFont()
        font_family = settings.value("style/user_input_font_family", "Garamond")
        font_size = int(settings.value("style/user_input_font_size", 14))
        current_font.setFamily(font_family)
        current_font.setPointSize(font_size)
        
        ok, font = QFontDialog.getFont(current_font, self, "Select User Input Font")
        if ok:
            # Update preview
            self.user_input_font_preview.setFont(font)
            # Store font
            self.user_input_font_preview.setProperty("selected_font", font)
    
    def _choose_user_input_font_color(self):
        """Open color dialog for user input font color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/user_input_font_color", "#0d47a1"))
        
        color = QColorDialog.getColor(current_color, self, "Select User Input Font Color")
        if color.isValid():
            # Update preview
            self.user_input_font_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Update font preview
            self.user_input_font_preview.setStyleSheet(f"color: {color.name()};")
            # Store color
            self.user_input_font_color_preview.setProperty("color_hex", color.name())
    
    def _choose_font_color(self):
        """Open color dialog for font color."""
        settings = QSettings("RPGGame", "Settings")
        current_color = QColor(settings.value("style/font_color", "#000000"))
        
        color = QColorDialog.getColor(current_color, self, "Select Font Color")
        if color.isValid():
            # Update preview
            self.font_color_preview.setStyleSheet(f"background-color: {color.name()}; border: 1px solid gray;")
            # Update font preview
            self.font_preview.setStyleSheet(f"color: {color.name()};")
            # Store color
            self.font_color_preview.setProperty("color_hex", color.name())
    
    def _load_settings(self):
        """Load settings from QSettings to the UI."""
        settings = QSettings("RPGGame", "Settings")
        
        # Load output background color
        bg_color = settings.value("style/output_bg_color", "#D2B48C")
        
        # Check if it's one of the predefined colors
        found_predefined = False
        for button in self.color_buttons.values():
            if button.property("color_hex") == bg_color:
                button.setChecked(True)
                found_predefined = True
                break
        
        # If not found, use custom color
        if not found_predefined:
            self.custom_color_radio.setChecked(True)
            self.custom_color_preview.setStyleSheet(f"background-color: {bg_color}; border: 1px solid gray;")
            self.custom_color_radio.setProperty("color_hex", bg_color)
        
        # Load system message color
        sys_color = settings.value("style/system_msg_color", "#FF0000")
        
        # Check if it's one of the predefined colors
        found_predefined = False
        for button in self.sys_color_buttons.values():
            if button.property("color_hex") == sys_color:
                button.setChecked(True)
                found_predefined = True
                break
        
        # If not found, use custom color
        if not found_predefined:
            self.custom_sys_color_radio.setChecked(True)
            self.custom_sys_color_preview.setStyleSheet(f"background-color: {sys_color}; border: 1px solid gray;")
            self.custom_sys_color_radio.setProperty("color_hex", sys_color)
        
        # Load output font settings
        font_family = settings.value("style/font_family", "Garamond")
        font_size = int(settings.value("style/font_size", 14))
        font = QFont(font_family, font_size)
        self.font_preview.setFont(font)
        self.font_preview.setProperty("selected_font", font)
        
        # Load output font color
        font_color = settings.value("style/font_color", "#000000")
        self.font_color_preview.setStyleSheet(f"background-color: {font_color}; border: 1px solid gray;")
        self.font_preview.setStyleSheet(f"color: {font_color};")
        self.font_color_preview.setProperty("color_hex", font_color)
        
        # Load user input font settings
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font = QFont(user_input_font_family, user_input_font_size)
        self.user_input_font_preview.setFont(user_input_font)
        self.user_input_font_preview.setProperty("selected_font", user_input_font)
        
        # Load user input font color
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")
        self.user_input_font_color_preview.setStyleSheet(f"background-color: {user_input_font_color}; border: 1px solid gray;")
        self.user_input_font_preview.setStyleSheet(f"color: {user_input_font_color};")
        self.user_input_font_color_preview.setProperty("color_hex", user_input_font_color)
        
        # Load texture setting
        texture_name = settings.value("style/texture_name", "subtle_noise")
        if texture_name in self.texture_buttons:
            self.texture_buttons[texture_name].setChecked(True)
        else:
            # Default to subtle noise
            self.texture_buttons["subtle_noise"].setChecked(True)
        
        # Load transparency settings
        output_opacity = int(settings.value("style/output_opacity", 100))
        input_opacity = int(settings.value("style/input_opacity", 100))
        
        self.output_transparency_slider.setValue(output_opacity)
        self.input_transparency_slider.setValue(input_opacity)
        self.output_transparency_value.setText(f"{output_opacity}%")
        self.input_transparency_value.setText(f"{input_opacity}%")
    
    def save_settings(self):
        """Save settings from the UI to QSettings."""
        settings = QSettings("RPGGame", "Settings")
        
        # Save output background color
        if self.custom_color_radio.isChecked():
            bg_color = self.custom_color_radio.property("color_hex")
        else:
            # Get selected button
            for button in self.color_buttons.values():
                if button.isChecked():
                    bg_color = button.property("color_hex")
                    break
            else:
                # Default if none selected
                bg_color = "#D2B48C"
        
        settings.setValue("style/output_bg_color", bg_color)
        
        # Save system message color
        if self.custom_sys_color_radio.isChecked():
            sys_color = self.custom_sys_color_radio.property("color_hex")
        else:
            # Get selected button
            for button in self.sys_color_buttons.values():
                if button.isChecked():
                    sys_color = button.property("color_hex")
                    break
            else:
                # Default if none selected
                sys_color = "#FF0000"
        
        settings.setValue("style/system_msg_color", sys_color)
        
        # Save output font settings
        font = self.font_preview.property("selected_font")
        if font:
            settings.setValue("style/font_family", font.family())
            settings.setValue("style/font_size", font.pointSize())
        
        # Save output font color
        font_color = self.font_color_preview.property("color_hex")
        if font_color:
            settings.setValue("style/font_color", font_color)
            
        # Save user input font settings
        user_input_font = self.user_input_font_preview.property("selected_font")
        if user_input_font:
            settings.setValue("style/user_input_font_family", user_input_font.family())
            settings.setValue("style/user_input_font_size", user_input_font.pointSize())
        
        # Save user input font color
        user_input_font_color = self.user_input_font_color_preview.property("color_hex")
        if user_input_font_color:
            settings.setValue("style/user_input_font_color", user_input_font_color)
        
        # Save texture setting
        for button in self.texture_buttons.values():
            if button.isChecked():
                texture_name = button.property("texture_name")
                settings.setValue("style/texture_name", texture_name)
                break
        
        # Save transparency settings
        output_opacity = self.output_transparency_slider.value()
        input_opacity = self.input_transparency_slider.value()
        
        settings.setValue("style/output_opacity", output_opacity)
        settings.setValue("style/input_opacity", input_opacity)

```

### File: gui\dialogs\__init__.py

```python
"""
Dialog modules for the RPG game GUI.
This package provides various dialog windows for the game.
"""

```

### File: gui\dialogs\base_dialog.py

```python
#gui/dialogs/base_dialog.py
from PySide6.QtWidgets import QDialog
from PySide6.QtCore import QSize
from PySide6.QtGui import QScreen # Correct import for QScreen

class BaseDialog(QDialog):
    """Base class for dialogs to enforce maximum size constraints."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Common dialog settings can go here if needed

    def showEvent(self, event):
        """Override showEvent to adjust maximum size safely."""
        # Let the default showEvent run first to ensure widgets are likely created
        super().showEvent(event)

        # Check if the dialog has already been adjusted in this show cycle
        # Use a flag that persists across show calls within a single instance lifecycle if needed,
        # but for maximum size constraint, checking per show is fine.
        # Let's rename the flag for clarity.
        if hasattr(self, '_constrained_to_screen') and self._constrained_to_screen:
             return

        try:
            screen = self.screen() # Get the screen the dialog is *currently* on
            if screen:
                available_geo = screen.availableGeometry()

                # Calculate max size (e.g., 95% of available space)
                max_w = int(available_geo.width() * 0.95)
                max_h = int(available_geo.height() * 0.95)

                # Only set maximum size if it's reasonable (avoid tiny max sizes)
                if max_w > 100 and max_h > 100:
                    self.setMaximumSize(max_w, max_h)
                else:
                    logger.warning(f"Calculated maximum size ({max_w}x{max_h}) is too small. Skipping setMaximumSize.")

                # Check current size against the calculated maximum
                current_w = self.width()
                current_h = self.height()

                # Calculate the ideal size based on content, but capped by max size
                hint_w = self.sizeHint().width()
                hint_h = self.sizeHint().height()
                ideal_w = min(max(current_w, hint_w), max_w) # Use size hint but respect current size if larger
                ideal_h = min(max(current_h, hint_h), max_h)

                # Resize *only* if the current size exceeds the calculated max size
                resize_needed = False
                if current_w > max_w:
                    current_w = max_w
                    resize_needed = True
                if current_h > max_h:
                    current_h = max_h
                    resize_needed = True

                if resize_needed:
                     logger.info(f"Dialog '{self.windowTitle()}' exceeds screen bounds. Resizing to fit ({current_w}x{current_h}).")
                     self.resize(current_w, current_h) # Resize down to max limits

            else:
                 logger.warning(f"Could not get screen for dialog '{self.windowTitle()}' during showEvent.")

            # Mark as constrained for this show event
            self._constrained_to_screen = True

        except Exception as e:
            logger.error(f"Error adjusting dialog size in BaseDialog.showEvent for '{self.windowTitle()}': {e}", exc_info=True)
            # Ensure the flag is set even on error to prevent repeated attempts
            self._constrained_to_screen = True


    def exec(self):
         """Override exec to ensure size adjustment flag is reset before showing."""
         # Reset the flag before showing modally
         self._constrained_to_screen = False
         # Let the default exec handle showing the dialog, which will trigger our showEvent
         return super().exec()

    def open(self):
        """Override open to ensure size adjustment flag is reset before showing."""
         # Reset the flag before showing modelessly
        self._constrained_to_screen = False
         # Let the default open handle showing the dialog, which will trigger our showEvent
        return super().open()
```

### File: gui\dialogs\character_creation_dialog.py

```python
#!/usr/bin/env python3
"""
Enhanced character creation dialog with Origin selection and stat allocation for the RPG game GUI.
"""

import os
import json
import logging
from typing import Dict, Optional, Any, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QComboBox,
    QPushButton, QGroupBox, QTextEdit, QTabWidget, QWidget, QMessageBox,
    QCheckBox, QFormLayout
)
from PySide6.QtCore import Qt, Signal, Slot, QSize
from PySide6.QtGui import QPixmap, QIcon

from gui.dialogs.new_game_dialog import NewGameDialog
from gui.components.stat_allocation_widget import StatAllocationWidget
from core.stats.stats_manager import StatsManager
from core.utils.logging_config import get_logger
from core.agents.narrator import get_narrator_agent 
from core.agents.base_agent import AgentContext 
from core.base.config import get_config 

logger = get_logger("GUI")

class CharacterCreationDialog(NewGameDialog):
    """Extended dialog for creating a new game character with Origin selection and stat allocation."""

    def __init__(self, parent=None):
        """Initialize the character creation dialog."""
        # We call QDialog's init directly as we heavily override the UI from NewGameDialog
        QDialog.__init__(self, parent)

        # Set window properties from NewGameDialog if desired
        self.setWindowTitle("Create New Character")
        self.setMinimumWidth(800)
        # --- MODIFICATION: Reduced height ---
        self.setMinimumHeight(550) # Adjusted height (was 650)
        # --- END MODIFICATION ---
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
                padding-top: 3px;
            }
            QLineEdit, QTextEdit, QComboBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 10px 0 10px;
                color: #E0E0E0;
            }
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #333333;
                border-radius: 5px;
            }
            QTabBar::tab {
                background-color: #444444;
                color: #CCCCCC;
                border: 1px solid #555555;
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 10px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #333333;
                color: #E0E0E0;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            #OriginDetailsLabel {
                color: #CCCCCC;
                padding-left: 5px;
                padding-top: 0px;
            }
        """)

        # Load data dynamically
        self.available_races = self._load_races()
        self.available_classes = self._load_classes()
        self.available_origins = self._load_origins() # Load origins
        self.available_sexes = ["Male", "Female", "Other"]

        # Initialize other state variables BEFORE UI setup that might use them
        self.llm_enabled = True
        self.selected_icon_path = None
        self.selected_origin_data = None
        self._last_generated_params = None

        # Initialize character icons list BEFORE UI setup
        self.character_icons = []
        self.current_icon_index = 0

        # Create stats manager BEFORE UI setup (StatAllocationWidget needs it)
        self.stats_manager = StatsManager()

        # Set up the UI with tabs SECOND (this creates self.icon_label etc.)
        self._setup_ui_with_tabs()

        # Scan for icons and display the first one THIRD (now self.icon_label exists)
        # Initial scan based on default selections
        self.scan_character_icons(self.race_combo.currentText(), self.path_combo.currentText(), self.sex_combo.currentText())

        # Connect signals FOURTH
        self._connect_signals()

        # Update UI based on initial race/class FIFTH (important for stat allocation)
        self._update_race_class() # This also calls _show_stat_requirements_info

        self._on_origin_selected(self.origin_combo.currentIndex())

        # Initial validation LAST
        self._validate_form()

    def _setup_ui_with_tabs(self):
        """Set up the main UI using tabs."""
        # Main layout for the dialog
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(15, 15, 15, 15)
        dialog_layout.setSpacing(10)

        # Create tab widget
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget::pane { border: 1px solid #555555; background-color: #333333; border-radius: 5px; }
            QTabBar::tab { background-color: #444444; color: #CCCCCC; border: 1px solid #555555; border-bottom: none; border-top-left-radius: 4px; border-top-right-radius: 4px; padding: 6px 10px; margin-right: 2px; }
            QTabBar::tab:selected { background-color: #333333; color: #E0E0E0; }
        """)

        # --- Tab 1: Basic Info & Origin ---
        self.basic_info_tab = QWidget()
        basic_info_main_layout = QHBoxLayout(self.basic_info_tab)
        basic_info_main_layout.setSpacing(15)

        # Left Side: Character Info & Portrait
        left_basic_layout = QVBoxLayout()

        info_group = QGroupBox("Character Information")
        info_form_layout = QFormLayout(info_group)
        info_form_layout.setContentsMargins(15, 25, 15, 15)
        info_form_layout.setSpacing(8)

        # Create UI elements (Name, Race, Class, Origin Combo, Sex, LLM Checkbox)
        self.player_name_edit = QLineEdit()
        self.player_name_edit.setPlaceholderText("Enter your character's name...")
        info_form_layout.addRow("Name:", self.player_name_edit)

        self.race_combo = QComboBox()
        self._populate_combo(self.race_combo, self.available_races, "Races") # Populate basic combos early
        info_form_layout.addRow("Race:", self.race_combo)

        self.path_combo = QComboBox() # Represents Class
        self._populate_combo(self.path_combo, self.available_classes, "Classes") # Populate basic combos early
        info_form_layout.addRow("Class:", self.path_combo)

        self.origin_combo = QComboBox() # Create the combo, but DON'T populate yet
        info_form_layout.addRow("Origin:", self.origin_combo)

        self.sex_combo = QComboBox()
        self._populate_combo(self.sex_combo, self.available_sexes, "Sexes") # Populate basic combos early
        info_form_layout.addRow("Sex:", self.sex_combo)

        self.llm_checkbox = QCheckBox("Enable LLM (AI processing)")
        self.llm_checkbox.setChecked(self.llm_enabled)
        info_form_layout.addRow("", self.llm_checkbox)

        left_basic_layout.addWidget(info_group)

        # Portrait Section
        icon_group = QGroupBox("Character Portrait")
        icon_layout = QVBoxLayout(icon_group)
        icon_layout.setContentsMargins(15, 25, 15, 15)
        icon_layout.setSpacing(8)
        self.icon_label = QLabel() # Create icon label
        self.icon_label.setAlignment(Qt.AlignCenter)
        self.icon_label.setFixedSize(150, 150)
        self.icon_label.setStyleSheet("background-color: #1E1E1E; border: 1px solid #3F3F46;")
        self.icon_label.setText("No image")
        icon_layout.addWidget(self.icon_label, 0, Qt.AlignCenter)
        nav_layout = QHBoxLayout()
        self.prev_icon_button = QPushButton("←")
        self.icon_counter_label = QLabel("0 / 0") # Create counter label
        self.icon_counter_label.setAlignment(Qt.AlignCenter)
        self.next_icon_button = QPushButton("→")
        nav_layout.addWidget(self.prev_icon_button)
        nav_layout.addWidget(self.icon_counter_label)
        nav_layout.addWidget(self.next_icon_button)
        icon_layout.addLayout(nav_layout)
        portrait_hint = QLabel("Browse available portraits")
        portrait_hint.setStyleSheet("color: #888888; font-style: italic;")
        portrait_hint.setAlignment(Qt.AlignCenter)
        icon_layout.addWidget(portrait_hint)
        left_basic_layout.addWidget(icon_group)
        left_basic_layout.addStretch(1)

        # Right Side: Origin Details & Backstory Seed
        right_basic_layout = QVBoxLayout()

        origin_details_group = QGroupBox("Origin Details")
        origin_details_layout = QVBoxLayout(origin_details_group)
        origin_details_layout.setContentsMargins(15, 25, 15, 15)
        origin_details_layout.setSpacing(8)
        origin_details_layout.addWidget(QLabel("<b>Description:</b>"))
        self.origin_desc_label = QLabel("Select an Origin to see details.") # Create desc label
        self.origin_desc_label.setObjectName("OriginDetailsLabel")
        self.origin_desc_label.setWordWrap(True)
        self.origin_desc_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(self.origin_desc_label)
        origin_details_layout.addWidget(QLabel("<b>Skill Proficiencies:</b>"))
        self.origin_skills_label = QLabel("-") # Create skills label
        self.origin_skills_label.setObjectName("OriginDetailsLabel")
        self.origin_skills_label.setWordWrap(True)
        origin_details_layout.addWidget(self.origin_skills_label)
        origin_details_layout.addWidget(QLabel("<b>Origin Traits:</b>"))
        self.origin_traits_label = QLabel("-") # Create traits label
        self.origin_traits_label.setObjectName("OriginDetailsLabel")
        self.origin_traits_label.setWordWrap(True)
        self.origin_traits_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(self.origin_traits_label)
        origin_details_layout.addStretch()

        # Backstory Seed Group
        description_group = QGroupBox("Character Backstory (Seed)")
        description_layout = QVBoxLayout(description_group)
        description_layout.setContentsMargins(15, 25, 15, 15)
        description_layout.setSpacing(5)
        description_label = QLabel("Edit the text below (loaded from Origin) to guide LLM background generation:")
        description_label.setWordWrap(True)
        description_label.setStyleSheet("color: #AAAAAA; font-style: italic;")
        self.description_edit = QTextEdit() # Create text edit
        self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
        self.description_edit.setMinimumHeight(120)
        description_layout.addWidget(description_label)
        description_layout.addWidget(self.description_edit)

        # AI Buttons for Backstory
        ai_button_layout = QHBoxLayout()
        icon_path_improve = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "ai_improve.svg")
        self.improve_background_button = QPushButton()
        self.improve_background_button.setIcon(QIcon(icon_path_improve))
        self.improve_background_button.setIconSize(QSize(16, 16))
        self.improve_background_button.setToolTip("Improve Backstory Seed via AI")
        self.improve_background_button.setFixedSize(30, 30)

        icon_path_generate = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "ai_generate.svg")
        self.generate_background_button = QPushButton()
        self.generate_background_button.setIcon(QIcon(icon_path_generate))
        self.generate_background_button.setIconSize(QSize(16, 16))
        self.generate_background_button.setToolTip("Generate Backstory Seed via AI")
        self.generate_background_button.setFixedSize(30, 30)

        ai_button_layout.addStretch()
        ai_button_layout.addWidget(self.improve_background_button)
        ai_button_layout.addWidget(self.generate_background_button)
        description_layout.addLayout(ai_button_layout)

        right_basic_layout.addWidget(origin_details_group)
        right_basic_layout.addWidget(description_group)
        right_basic_layout.addStretch(1)

        basic_info_main_layout.addLayout(left_basic_layout, 1)
        basic_info_main_layout.addLayout(right_basic_layout, 2)

        # --- Tab 2: Stats --- (Will be added later by user)
        # self.stats_tab = QWidget()
        # ...

        # --- Tab 3: Stats (Renamed from Tab 2) ---
        self.stats_tab = QWidget() # Renamed variable for clarity, though index matters more
        stats_layout = QVBoxLayout(self.stats_tab)
        stats_layout.setSpacing(10)

        # Race/Class selectors
        race_class_selection_layout = QVBoxLayout()
        race_selector_layout = QHBoxLayout()
        race_selector_layout.setContentsMargins(0, 5, 0, 0); race_selector_layout.setSpacing(8)
        self.race_prev_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "left_arrow.svg")
        self.race_prev_button.setIcon(QIcon(icon_path))
        self.race_prev_button.setIconSize(QSize(16, 16)); self.race_prev_button.setFixedSize(24, 24)
        self.race_label = QLabel("Race") # Create race label
        self.race_label.setStyleSheet("color: #E0E0E0; font-weight: bold; font-size: 14px;"); self.race_label.setAlignment(Qt.AlignCenter)
        self.race_next_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "right_arrow.svg")
        self.race_next_button.setIcon(QIcon(icon_path))
        self.race_next_button.setIconSize(QSize(16, 16)); self.race_next_button.setFixedSize(24, 24)
        race_selector_layout.addWidget(self.race_prev_button); race_selector_layout.addWidget(self.race_label, 1); race_selector_layout.addWidget(self.race_next_button)
        race_class_selection_layout.addLayout(race_selector_layout)

        class_selector_layout = QHBoxLayout()
        class_selector_layout.setContentsMargins(0, 5, 0, 10); class_selector_layout.setSpacing(8)
        self.class_prev_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "left_arrow.svg")
        self.class_prev_button.setIcon(QIcon(icon_path))
        self.class_prev_button.setIconSize(QSize(16, 16)); self.class_prev_button.setFixedSize(24, 24)
        self.class_label = QLabel("Class") # Create class label
        self.class_label.setStyleSheet("color: #E0E0E0; font-weight: bold; font-size: 14px;"); self.class_label.setAlignment(Qt.AlignCenter)
        self.class_next_button = QPushButton()
        icon_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "images", "icons", "right_arrow.svg")
        self.class_next_button.setIcon(QIcon(icon_path))
        self.class_next_button.setIconSize(QSize(16, 16)); self.class_next_button.setFixedSize(24, 24)
        class_selector_layout.addWidget(self.class_prev_button); class_selector_layout.addWidget(self.class_label, 1); class_selector_layout.addWidget(self.class_next_button)
        race_class_selection_layout.addLayout(class_selector_layout)
        stats_layout.addLayout(race_class_selection_layout)

        # Stat Allocation Widget
        self.stat_allocation = StatAllocationWidget( # Create stat widget
            self.stats_manager,
            self.race_combo.currentText(),
            self.path_combo.currentText()
        )
        stats_layout.addWidget(self.stat_allocation)

        # Info Label for Stats Tab
        self.stat_info_label = QLabel() # Create stat info label
        self.stat_info_label.setWordWrap(True)
        self.stat_info_label.setStyleSheet("color: #E0E0E0; background-color: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px;")
        stats_layout.addWidget(self.stat_info_label)
        stats_layout.addStretch(1)

        # --- Tab 4: Background (Simplified) --- (Renamed from Tab 3)
        self.background_tab = QWidget()
        background_layout = QVBoxLayout(self.background_tab)
        # Maybe repurpose this tab later if needed
        background_layout.addWidget(QLabel("Review Character Summary (Optional Tab)"))
        background_layout.addStretch()

        # Add tabs to the tab widget
        self.tab_widget.addTab(self.basic_info_tab, "1. Basic Info & Origin")
        # --- MODIFICATION: Add placeholder for future Tab 2 ---
        # self.tab_widget.addTab(QWidget(), "2. Skills & Feats (TBD)") # Placeholder
        # --- END MODIFICATION ---
        # --- MODIFICATION: Renamed Stats Tab ---
        self.tab_widget.addTab(self.stats_tab, "3. Stats") # Renamed from "2. Stats"
        # --- END MODIFICATION ---
        # Connect tab changed signal
        self.tab_widget.currentChanged.connect(self._tab_changed)
        # self.tab_widget.addTab(self.background_tab, "4. Review (Optional)") # Renumbered

        dialog_layout.addWidget(self.tab_widget)

        # --- Navigation & Create Buttons ---
        bottom_button_layout = QHBoxLayout()
        self.prev_tab_button = QPushButton("< Previous")
        self.next_tab_button = QPushButton("Next >")
        self.cancel_button = QPushButton("Cancel")
        self.create_button = QPushButton("Create Character")
        self.start_game_button = QPushButton("Start Game")
        self.start_game_button.setStyleSheet("""
            QPushButton {
                background-color: #22863a;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2a9949;
            }
            QPushButton:pressed {
                background-color: #1e7e34;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
        """)
        self.start_game_button.hide()  # Initially hidden

        bottom_button_layout.addWidget(self.cancel_button)
        bottom_button_layout.addStretch()
        bottom_button_layout.addWidget(self.prev_tab_button)
        bottom_button_layout.addWidget(self.next_tab_button)
        bottom_button_layout.addWidget(self.create_button)
        # Initially hide the create button until needed
        self.create_button.hide()

        dialog_layout.addLayout(bottom_button_layout)

        # Initialize tab state
        self._tab_changed(0)

        # NOW populate the origin combo, as all widgets exist
        self._populate_origin_combo()

    def _populate_combo(self, combo: QComboBox, items: List[str], item_type: str):
        """Helper to populate QComboBox and handle empty lists."""
        combo.clear()
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItems(items)
            combo.setEnabled(True)

    def _populate_origin_combo(self):
        """
        Populate the Origin combo box, filtering based on selected Race and Class.
        """
        combo = self.origin_combo
        all_origins = self.available_origins # List of origin dicts
        item_type = "Origins"

        # Get current selections (ensure combo boxes exist first)
        selected_race = self.race_combo.currentText() if hasattr(self, 'race_combo') else None
        selected_class = self.path_combo.currentText() if hasattr(self, 'path_combo') else None

        previous_origin_id = combo.currentData()

        combo.blockSignals(True) 
        combo.clear()
        combo.addItem("--- Select an Origin ---", None) 

        if not all_origins:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
            combo.blockSignals(False)
            self._on_origin_selected(0) 
            return

        if not selected_race or not selected_class:
            combo.addItem("Select Race/Class first")
            combo.setEnabled(False)
            combo.blockSignals(False)
            self._on_origin_selected(0) 
            return

        # --- Filtering Logic ---
        suitable_origins = []
        for origin_data in all_origins:
            races_ok = True 
            if origin_data.get("suitable_races"): 
                races_ok = selected_race in origin_data["suitable_races"]

            classes_ok = True 
            if origin_data.get("suitable_classes"): 
                classes_ok = selected_class in origin_data["suitable_classes"]

            if races_ok and classes_ok:
                suitable_origins.append(origin_data)
        # --- End Filtering Logic ---

        if not suitable_origins:
            combo.addItem(f"No suitable {item_type} found")
            combo.setEnabled(False)
        else:
            reselect_index = 0 # Default to placeholder
            for index, origin_data in enumerate(suitable_origins):
                origin_id = origin_data.get('id')
                origin_name = origin_data.get('name', 'Unknown Origin')
                # Add item with name as text and id as data
                combo.addItem(origin_name, origin_id)
                # Check if this was the previously selected origin
                if origin_id == previous_origin_id:
                    reselect_index = index + 1

            combo.setEnabled(True)
            combo.setCurrentIndex(reselect_index)

        combo.blockSignals(False) # Re-enable signals
        self._on_origin_selected(combo.currentIndex())

    def _toggle_llm(self, state):
        """Toggle LLM enabled state."""
        self.llm_enabled = bool(state)
        # Enable/disable AI buttons based on LLM state
        self.improve_background_button.setEnabled(self.llm_enabled)
        self.generate_background_button.setEnabled(self.llm_enabled)

    # --- Data Loading --- (Keep as is)
    def _load_races(self) -> List[str]:
        races = []
        try:
            config = get_config()
            loaded_races_data = config.get_all("races")
            if loaded_races_data:
                race_names = sorted([data.get('name', race_id) for race_id, data in loaded_races_data.items()])
                if race_names: races = race_names
            if not races: logger.warning("Race config not found or empty.")
        except Exception as e: logger.error(f"Error loading races: {e}.")
        return races if races else ["Human"]

    def _load_classes(self) -> List[str]:
        classes = []
        try:
            config = get_config()
            loaded_classes_data = config.get_all("classes")
            if loaded_classes_data:
                class_names = sorted([data.get('name', class_id) for class_id, data in loaded_classes_data.items()])
                if class_names: classes = class_names
            if not classes: logger.warning("Class config not found or empty.")
        except Exception as e: logger.error(f"Error loading classes: {e}.")
        return classes if classes else ["Wanderer"]

    def _load_origins(self) -> List[Dict[str, Any]]:
        origins_data = []
        try:
            config = get_config()
            loaded_origins_dict = config.get_all("origins") # Load "origins" key
            if loaded_origins_dict and isinstance(loaded_origins_dict, dict):
                origins_data = list(loaded_origins_dict.values())
                origins_data.sort(key=lambda x: x.get('name', 'Unknown Origin'))
                logger.info(f"Loaded {len(origins_data)} origins from config.")
            else:
                logger.warning("Origin configuration domain ('origins') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading origins from config: {e}.")
        return origins_data

    # --- Icon Scanning & Filtering ---
    def scan_character_icons(self, race: str, class_name: str, sex: str):
        """
        Scan for character icons in the specific race/class directory
        and filter based on sex, looking for '_male' or '_female' in filenames.
        """
        self.character_icons = [] # Clear previous icons
        self.current_icon_index = 0

        if not race or not class_name or not sex or "No " in race or "No " in class_name:
            logger.warning(f"Cannot scan icons: Race ('{race}'), Class ('{class_name}'), or Sex ('{sex}') not validly selected.")
            self._display_current_icon()
            return

        try:
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            safe_race = race.replace(" ", "_")
            safe_class_name = class_name.replace(" ", "_")
            specific_icons_dir = os.path.join(project_root, "images", "character_icons", f"{safe_race}_{safe_class_name}")
            logger.debug(f"Scanning for icons in specific directory: {specific_icons_dir}")

            if not os.path.exists(specific_icons_dir):
                logger.warning(f"Icon directory not found: {specific_icons_dir}")
                self._display_current_icon()
                return

            supported_extensions = [".png", ".jpg", ".jpeg", ".gif", ".svg"]

            for filename in os.listdir(specific_icons_dir):
                if any(filename.lower().endswith(ext) for ext in supported_extensions):
                    name_part_lower = os.path.splitext(filename)[0].lower() # Filename without extension, lowercase
                    sex_lower = sex.lower()
                    include_file = False

                    # Check for specific substrings "_male" or "_female"
                    contains_male_tag = "_male" in name_part_lower
                    contains_female_tag = "_female" in name_part_lower

                    if sex_lower == "male":
                        if contains_male_tag: # Only include if it explicitly has "_male"
                            include_file = True
                    elif sex_lower == "female":
                        if contains_female_tag: # Only include if it explicitly has "_female"
                            include_file = True
                    elif sex_lower == "other":
                        # For "Other", include if either tag is present
                        if contains_male_tag or contains_female_tag:
                            include_file = True
                    
                    if include_file:
                        file_path = os.path.join(specific_icons_dir, filename)
                        self.character_icons.append({
                            "filename": filename,
                            "path": file_path
                        })

            self.character_icons.sort(key=lambda x: x["filename"])
            logger.info(f"Found {len(self.character_icons)} suitable icons in {specific_icons_dir} for sex '{sex}' (using _male/_female tags).")

        except OSError as e:
            logger.error(f"Error reading icons directory {specific_icons_dir}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error scanning icons: {e}", exc_info=True)

        self._display_current_icon()
        
    # --- Signal Connections ---
    def _connect_signals(self):
        """Connect signals to slots."""
        # Basic Info Tab
        self.player_name_edit.textChanged.connect(self._validate_form)
        self.race_combo.currentIndexChanged.connect(self._validate_form)
        self.race_combo.currentTextChanged.connect(self._update_race_class)
        self.race_combo.currentTextChanged.connect(self._populate_origin_combo) 
        self.path_combo.currentIndexChanged.connect(self._validate_form)
        self.path_combo.currentTextChanged.connect(self._update_race_class)
        self.path_combo.currentTextChanged.connect(self._populate_origin_combo) 

        # Only connect origin index change to validation and details update
        self.origin_combo.currentIndexChanged.connect(self._validate_form)
        self.origin_combo.currentIndexChanged.connect(self._on_origin_selected)

        self.sex_combo.currentIndexChanged.connect(self._validate_form)
        self.llm_checkbox.stateChanged.connect(self._toggle_llm)

        # Update icons when race, class, or sex changes
        self.race_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)
        self.path_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)
        self.sex_combo.currentIndexChanged.connect(self._update_icons_on_selection_change)

        # Portrait
        self.prev_icon_button.clicked.connect(self._show_previous_icon)
        self.next_icon_button.clicked.connect(self._show_next_icon)

        # Stats Tab
        self.race_prev_button.clicked.connect(self._previous_race)
        self.race_next_button.clicked.connect(self._next_race)
        self.class_prev_button.clicked.connect(self._previous_class)
        self.class_next_button.clicked.connect(self._next_class)
        self.stat_allocation.stats_changed.connect(self._stats_changed)

        # Backstory Seed / AI Buttons
        self.improve_background_button.clicked.connect(self._improve_background)
        self.generate_background_button.clicked.connect(self._generate_background)

        # Dialog Buttons
        self.cancel_button.clicked.connect(self.reject)
        self.create_button.clicked.connect(self._finish_character_creation) # Connect create to finish method
        self.start_game_button.clicked.connect(self._start_new_game) # Start game button triggers special method
        self.prev_tab_button.clicked.connect(self._previous_tab)
        self.next_tab_button.clicked.connect(self._next_tab)
        
        # Set tooltips for the buttons
        self.create_button.setToolTip("Create your character and prepare to start the game")
        self.start_game_button.setToolTip("Begin your adventure with this character")
        self.cancel_button.setToolTip("Cancel character creation")

        # Connect race/class/origin/sex change to clear background generation context
        self.race_combo.currentTextChanged.connect(self._check_generated_context)
        self.path_combo.currentTextChanged.connect(self._check_generated_context)
        self.origin_combo.currentTextChanged.connect(self._check_generated_context) # Keep this check
        self.sex_combo.currentTextChanged.connect(self._check_generated_context)

        # Initial UI state update
        self._toggle_llm(self.llm_checkbox.isChecked()) # Set initial AI button state

        # Connect signals that affect AI button state
        self.player_name_edit.textChanged.connect(self._update_ai_button_state)
        self.stat_allocation.stats_changed.connect(self._update_ai_button_state)
        self.stat_allocation.allocation_complete.connect(self._update_ai_button_state)

        # Initial AI button state update
        self._update_ai_button_state()

    # --- Validation ---
    def _validate_form(self):
        """Validate the form and enable/disable the create button."""
        # This validation now applies mainly to the Create button state
        has_name = bool(self.player_name_edit.text().strip())
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0 # Check for valid origin index

        can_create = (
            has_name and
            race_selected and
            class_selected and
            origin_selected
        )

        # Get current tab
        current_tab_index = self.tab_widget.currentIndex()
        
        # Set Create button state if visible
        if self.create_button.isVisible():
            logger.debug(f"Setting create button enabled state to: {can_create}")
            self.create_button.setEnabled(can_create)
            if can_create:
                self.create_button.setToolTip("Create your character")
            else:
                self.create_button.setToolTip("Please complete all required fields")

        # Enable/disable next button based on basic info validity if on first tab
        if current_tab_index == 0:
            self.next_tab_button.setEnabled(can_create)
            if can_create:
                self.next_tab_button.setToolTip("Proceed to character stats")
            else:
                self.next_tab_button.setToolTip("Please complete all required fields before proceeding")
        else:
            self.next_tab_button.setEnabled(True) # Always enabled on other tabs (except last)


    # --- Icon Display --- (Keep as is)
    def _show_previous_icon(self):
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index - 1 + len(self.character_icons)) % len(self.character_icons)
        self._display_current_icon()

    def _show_next_icon(self):
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index + 1) % len(self.character_icons)
        self._display_current_icon()

    def _display_current_icon(self):
        if not self.character_icons:
            self.selected_icon_path = None
            self.icon_label.setText("No Icons Found")
            self.icon_counter_label.setText("0 / 0")
            return

        icon_info = self.character_icons[self.current_icon_index]
        icon_path = icon_info['path']
        self.icon_counter_label.setText(f"{self.current_icon_index + 1} / {len(self.character_icons)}")

        try:
            pixmap = QPixmap(icon_path)
            if not pixmap.isNull():
                pixmap = pixmap.scaled(self.icon_label.width(), self.icon_label.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.icon_label.setPixmap(pixmap)
                self.selected_icon_path = icon_path
            else:
                self.icon_label.setText("Load Error")
                self.selected_icon_path = None
        except Exception as e:
            logger.error(f"Error loading icon '{icon_path}': {e}")
            self.icon_label.setText("Load Error")
            self.selected_icon_path = None

    # --- Get Character Data ---
    def get_character_data(self) -> Optional[Dict[str, Any]]:
        """Get the final character data from all tabs."""
        # Validate basic info first
        if not self._validate_basic_info():
             QMessageBox.warning(self, "Incomplete Information", "Please complete the basic character information.")
             self.tab_widget.setCurrentIndex(0) # Go back to first tab
             return None

        # Retrieve basic info
        name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText()
        path = self.path_combo.currentText()
        origin_id = self.origin_combo.currentData() # Get the ID stored in data
        sex = self.sex_combo.currentText()

        # Basic validation again (should pass if Create button was enabled)
        if not name or not race or not path or origin_id is None:
             logger.error("Validation failed in get_character_data despite enabled button.")
             return None

        # Retrieve backstory seed text
        # Prioritize user edited text, fallback to origin intro text
        backstory_seed = self.description_edit.toPlainText().strip()
        if not backstory_seed and self.selected_origin_data:
            backstory_seed = self.selected_origin_data.get('introduction_text', '')

        # Retrieve final stats from allocation widget
        allocated_stats = self.stat_allocation.get_allocated_stats()
        if not allocated_stats:
            logger.error("Could not retrieve allocated stats.")
            QMessageBox.critical(self, "Stat Error", "Could not retrieve final stats. Please check the Stats tab.")
            self.tab_widget.setCurrentIndex(1) # Go to stats tab
            return None

        # Build the final data dictionary
        data = {
            'name': name,
            'race': race,
            'path': path,
            'origin_id': origin_id, # Use origin ID
            'sex': sex,
            'description': backstory_seed, # The seed text for LLM
            'use_llm': self.llm_enabled,
            'character_image': self.selected_icon_path,
            'stats': allocated_stats, # Include allocated base stats
            # Add starting items/location based on selected origin
            'starting_location_id': self.selected_origin_data.get('starting_location_id', '') if self.selected_origin_data else '',
            'starting_items': self.selected_origin_data.get('starting_items', []) if self.selected_origin_data else [],
            'initial_quests': self.selected_origin_data.get('initial_quests', []) if self.selected_origin_data else []
        }

        # --- Optional: Add compatibility fields if core engine expects them ---
        # This depends on how core/base/engine.py -> start_new_game is implemented
        # If it still expects individual base stats:
        # for stat_name, value in allocated_stats.items():
        #     data[f'base_{stat_name.lower()}'] = value
        # If it expects background name (use origin name as fallback):
        # data['background'] = self.origin_combo.currentText()
        # ---------------------------------------------------------------------

        logger.info(f"Character data collected: { {k:v for k,v in data.items() if k != 'stats'} }") # Log non-stat data
        logger.debug(f"Character stats: {data.get('stats')}")
        return data


    # --- Methods inherited or potentially modified from NewGameDialog ---
    # These might need adjustments based on the tabbed layout

    def _update_race_class(self, *args):
        """Update stat allocation and labels when race or class changes."""
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()

        if hasattr(self, 'race_label'): self.race_label.setText(race)
        if hasattr(self, 'class_label'): self.class_label.setText(class_name)

        if hasattr(self, 'stat_allocation'):
            self.stat_allocation.update_race_class(race, class_name)

        self._show_stat_requirements_info(race, class_name)
        self._validate_form() # Re-validate when race/class changes

    def _previous_race(self):
        current_index = self.race_combo.currentIndex()
        if current_index > 0:
            self.race_combo.setCurrentIndex(current_index - 1)

    def _next_race(self):
        current_index = self.race_combo.currentIndex()
        if current_index < self.race_combo.count() - 1:
            self.race_combo.setCurrentIndex(current_index + 1)

    def _previous_class(self):
        current_index = self.path_combo.currentIndex()
        if current_index > 0:
            self.path_combo.setCurrentIndex(current_index - 1)

    def _next_class(self):
        current_index = self.path_combo.currentIndex()
        if current_index < self.path_combo.count() - 1:
            self.path_combo.setCurrentIndex(current_index + 1)

    def _stats_changed(self, stats: Dict[str, Dict[str, int]]):
        """Handle stat changes from allocation widget."""
        self._validate_form() # Re-validate overall form
        self._update_ai_button_state()

    def _validate_for_ai_generation(self) -> bool:
        """Checks if conditions are met for enabling AI generation buttons."""
        has_name = bool(self.player_name_edit.text().strip())
        stats_allocated = hasattr(self, 'stat_allocation') and self.stat_allocation.are_points_fully_allocated()
        return has_name and stats_allocated

    def _update_ai_button_state(self):
        """Updates the enabled state and tooltip of AI buttons."""
        can_generate = self._validate_for_ai_generation()
        tooltip_text = ""

        if not can_generate:
            missing = []
            if not bool(self.player_name_edit.text().strip()):
                missing.append("Enter a character name")
            if not (hasattr(self, 'stat_allocation') and self.stat_allocation.are_points_fully_allocated()):
                remaining = self.stat_allocation.get_remaining_points() if hasattr(self, 'stat_allocation') else 'N/A'
                missing.append(f"Allocate all stat points ({remaining} remaining)")
            tooltip_text = "Cannot generate backstory:\n- " + "\n- ".join(missing)

        # Update Improve Button
        if hasattr(self, 'improve_background_button'):
            self.improve_background_button.setEnabled(can_generate)
            self.improve_background_button.setToolTip(tooltip_text if not can_generate else "Improve Backstory Seed via AI")

        # Update Generate Button
        if hasattr(self, 'generate_background_button'):
            self.generate_background_button.setEnabled(can_generate)
            self.generate_background_button.setToolTip(tooltip_text if not can_generate else "Generate Backstory Seed via AI")
    
    def _show_stat_requirements_info(self, race: str, class_name: str):
        """Display info about race/class modifiers and requirements."""
        if not hasattr(self, 'stat_allocation') or not hasattr(self, 'stat_info_label'):
            return

        modifier_info = self.stat_allocation.modifier_info
        if not modifier_info:
            self.stat_info_label.setText("Loading stat info...")
            return

        race_mods = modifier_info.race_modifiers
        class_mods = modifier_info.class_modifiers
        reqs = modifier_info.minimum_requirements
        recomm = modifier_info.recommended_stats

        info_text = f"<div style='font-weight: bold; font-size: 13px;'>{race} {class_name} Stat Info</div><hr>"

        def format_mods(mods_dict, color_pos, color_neg):
            if not mods_dict: return "None"
            parts = []
            for stat, mod in sorted(mods_dict.items()):
                if mod != 0:
                    color = color_pos if mod > 0 else color_neg
                    parts.append(f"<span style='color: {color}'>{stat} {mod:+d}</span>")
            return ", ".join(parts) if parts else "None"

        info_text += f"<div style='margin-bottom: 8px;'><b>Race Modifiers:</b> {format_mods(race_mods, '#4CAF50', '#F44336')}</div>"
        info_text += f"<div style='margin-bottom: 8px;'><b>Class Modifiers:</b> {format_mods(class_mods, '#2196F3', '#F44336')}</div>"

        req_text = ", ".join([f"{stat} {val}" for stat, val in sorted(reqs.items())]) if reqs else "None"
        info_text += f"<div style='margin-bottom: 8px;'><b>Minimum Requirements:</b> {req_text}</div>"

        recomm_prim = ", ".join(recomm.get('primary', [])) if recomm.get('primary') else "Balanced"
        info_text += f"<div><b>Recommended Primary:</b> {recomm_prim}</div>"

        self.stat_info_label.setText(info_text)

    @Slot()
    def _improve_background(self):
        if not self._validate_for_ai_generation(): return # Check validation first

        text = self.description_edit.toPlainText().strip()
        if not text:
            QMessageBox.warning(self, "No Text", "Please enter some background seed text first.")
            return

        detailed_context = self._get_detailed_context_for_llm()
        formatted_context = self._format_context_for_llm_prompt(detailed_context)

        prompt = (
            f"Improve the following background seed text for the character described below. "
            f"Make it an engaging character description focusing on personality, motivation, and appearance, "
            f"fitting the provided context. Do not narrate actions, just describe the character.\n\n"
            f"BACKGROUND SEED:\n{text}\n\n"
            f"{formatted_context}"
        )

        logger.debug(f"Sending improve background prompt:\n{prompt}") # Log the prompt

        # Call LLM
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={}, # Minimal state needed
            player_input=prompt, # Use the constructed prompt
            conversation_history=[], relevant_memories=[], additional_context={}
        )
        # Add error handling for LLM calls
        try:
            # Disable buttons during generation
            self.improve_background_button.setEnabled(False)
            self.generate_background_button.setEnabled(False)
            self.repaint() # Force UI update

            response = get_narrator_agent().process(ctx) # Assumes this function exists

            # Re-enable buttons
            self._update_ai_button_state()

            narrative_content = response.get("narrative") if response else None
            if narrative_content:
                self.description_edit.setPlainText(narrative_content.strip())
                # Update context tracking only AFTER successful generation
                self._last_generated_params = (
                    detailed_context.get('race',{}).get('name'),
                    detailed_context.get('class',{}).get('name'),
                    detailed_context.get('origin',{}).get('name'),
                    detailed_context.get('character',{}).get('sex')
                 )
            else:
                 QMessageBox.warning(self, "AI Error", "Could not improve background. No valid response from AI.")
        except Exception as e:
            logger.error(f"Error improving background: {e}", exc_info=True)
            QMessageBox.critical(self, "AI Error", f"An error occurred while improving the background:\n{e}")
            self._update_ai_button_state() # Ensure buttons are re-enabled on error

    @Slot()
    def _generate_background(self):
        if not self._validate_for_ai_generation(): return # Check validation first

        detailed_context = self._get_detailed_context_for_llm()
        formatted_context = self._format_context_for_llm_prompt(detailed_context)

        prompt = (
            f"Generate a short, engaging character description backstory seed (personality, motivation, appearance) "
            f"for the character described below. Do not narrate actions, just describe the character based on the context.\n\n"
            f"{formatted_context}"
        )

        logger.debug(f"Sending generate background prompt:\n{prompt}") # Log the prompt

        # Call LLM
        ctx = AgentContext(
            game_state={}, player_state={}, world_state={}, # Minimal state needed
            player_input=prompt, # Use the constructed prompt
            conversation_history=[], relevant_memories=[], additional_context={}
        )
        # Add error handling for LLM calls
        try:
            # Disable buttons during generation
            self.improve_background_button.setEnabled(False)
            self.generate_background_button.setEnabled(False)
            self.repaint() # Force UI update

            response = get_narrator_agent().process(ctx) # Assumes this function exists

            # Re-enable buttons
            self._update_ai_button_state()

            narrative_content = response.get("narrative") if response else None
            if narrative_content:
                self.description_edit.setPlainText(narrative_content.strip())
                 # Update context tracking only AFTER successful generation
                self._last_generated_params = (
                    detailed_context.get('race',{}).get('name'),
                    detailed_context.get('class',{}).get('name'),
                    detailed_context.get('origin',{}).get('name'),
                    detailed_context.get('character',{}).get('sex')
                 )
            else:
                 QMessageBox.warning(self, "AI Error", "Could not generate background. No valid response from AI.")
        except Exception as e:
            logger.error(f"Error generating background: {e}", exc_info=True)
            QMessageBox.critical(self, "AI Error", f"An error occurred while generating the background:\n{e}")
            self._update_ai_button_state() # Ensure buttons are re-enabled on error

    def _check_generated_context(self):
        """Warn if selections change after background generation."""
        if self._last_generated_params:
            current = (
                self.race_combo.currentText(),
                self.path_combo.currentText(),
                self.origin_combo.currentText(), # Use origin name
                self.sex_combo.currentText()
            )
            if current != self._last_generated_params:
                QMessageBox.warning(
                    self,
                    "Background Mismatch",
                    "The backstory seed was generated for a previous selection. Please regenerate or edit to match."
                )
                # Clear the tracking so it doesn't warn repeatedly
                self._last_generated_params = None

    # --- Tab Navigation Logic ---
    def _previous_tab(self):
        current = self.tab_widget.currentIndex()
        if current > 0:
            self.tab_widget.setCurrentIndex(current - 1)

    def _next_tab(self):
        current = self.tab_widget.currentIndex()
        total = self.tab_widget.count()
        if current < total - 1:
            # Validate basic info before leaving first tab
            if current == 0 and not self._validate_basic_info():
                return # Stay on first tab if invalid
            self.tab_widget.setCurrentIndex(current + 1)
        # Note: Finishing logic is now in _finish_character_creation connected to create_button
        
    def _validate_basic_info(self) -> bool:
        """Validate the basic character information on the first tab."""
        logger.debug("Validating basic character information")
        
        # Check if name is entered
        name = self.player_name_edit.text().strip()
        if not name:
            logger.warning("Character creation validation failed: Missing name")
            QMessageBox.warning(self, "Missing Name", "Please enter a character name.")
            return False
            
        # Check if race is selected
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0
        if not race_selected:
            logger.warning("Character creation validation failed: Missing race")
            QMessageBox.warning(self, "Missing Race", "Please select a race for your character.")
            return False
            
        # Check if class is selected
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        if not class_selected:
            logger.warning("Character creation validation failed: Missing class")
            QMessageBox.warning(self, "Missing Class", "Please select a class for your character.")
            return False
            
        # Check if origin is selected (choosing the first placeholder item doesn't count)
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0
        if not origin_selected:
            logger.warning("Character creation validation failed: Missing origin")
            QMessageBox.warning(self, "Missing Origin", "Please select an origin for your character.")
            return False
            
        # All basic info is valid
        logger.debug("Basic character information validation passed")
        return True

    def _tab_changed(self, index: int):
        """Handle tab change events for button visibility."""
        logger.debug(f"Tab changed to index {index}")
        total = self.tab_widget.count()
        self.prev_tab_button.setEnabled(index > 0)

        # Find the correct QHBoxLayout holding the buttons
        bottom_layout = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if isinstance(item, QHBoxLayout):
                widget_texts = []
                for j in range(item.count()):
                    widget = item.itemAt(j).widget()
                    if isinstance(widget, QPushButton):
                        widget_texts.append(widget.text())
                if "< Previous" in widget_texts:
                    bottom_layout = item
                    break

        if not bottom_layout:
            logger.error("Could not find bottom button layout in _tab_changed")
            return


        stats_tab_index = 1 

        if index == stats_tab_index:  
            logger.debug("Showing 'Create Character' button on Stats tab")
            # Hide the next button if it's visible
            if self.next_tab_button.isVisible():
                bottom_layout.removeWidget(self.next_tab_button)
                self.next_tab_button.hide()

            # Show the create button
            if bottom_layout.indexOf(self.create_button) == -1:
                bottom_layout.addWidget(self.create_button)
            self.create_button.show()
            self._validate_form() 

        elif index < stats_tab_index:
            logger.debug(f"Showing 'Next' button on tab {index}")

            if self.create_button.isVisible():
                bottom_layout.removeWidget(self.create_button)
                self.create_button.hide()

            # Show the next button
            if bottom_layout.indexOf(self.next_tab_button) == -1:

                 stretch_index = -1
                 for i in range(bottom_layout.count()):
                     if bottom_layout.itemAt(i).spacerItem():
                         stretch_index = i
                         break
                 if stretch_index != -1:
                     insert_index = bottom_layout.indexOf(self.create_button)
                     if insert_index == -1: insert_index = stretch_index + 1 
                     bottom_layout.insertWidget(insert_index, self.next_tab_button)
                 else:  
                    bottom_layout.addWidget(self.next_tab_button)
            self.next_tab_button.show()
            self._validate_form()  

    def _finish_character_creation(self):
        """Final validation and show the start game button."""
        logger.info("Finalizing character creation")
        
        # Validate basic info again just in case
        if not self._validate_basic_info():
             logger.warning("Character creation finalization failed: Incomplete basic information")
             QMessageBox.warning(self, "Incomplete Information", "Please complete the basic character information on the first tab.")
             self.tab_widget.setCurrentIndex(0)
             return

        # Validate stats meet class requirements
        if not self.stat_allocation.meets_requirements():
            logger.warning("Character doesn't meet minimum stat requirements for selected class")
            result = QMessageBox.question(
                self,
                "Stat Requirements Not Met",
                "Your character doesn't meet the minimum stat requirements for the selected class. Continue anyway?",
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No
            )
            if result == QMessageBox.No:
                logger.debug("User chose to return to stats tab to adjust requirements")
                self.tab_widget.setCurrentIndex(1) # Go to stats tab
                return
            else:
                logger.info("User chose to continue with character despite unmet stat requirements")

        # If all checks pass, display character confirmation and show start game button
        character_name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()
        origin = self.origin_combo.currentText()
        
        logger.info(f"Character creation complete: {character_name} ({race} {class_name} from {origin})")
        
        message = f"Character Creation Complete!\n\n"
        message += f"Name: {character_name}\n"
        message += f"Race: {race}\n"
        message += f"Class: {class_name}\n"
        message += f"Origin: {origin}\n\n"
        message += f"Click 'Start Game' to begin your adventure or 'Cancel' to discard this character."
        
        QMessageBox.information(self, "Character Created", message)
        
        # Replace create button with start game button
        logger.debug("Replacing 'Create Character' button with 'Start Game' button")
        bottom_layout = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if isinstance(item, QHBoxLayout):
                widget_texts = []
                for j in range(item.count()):
                    widget = item.itemAt(j).widget()
                    if isinstance(widget, QPushButton):
                        widget_texts.append(widget.text())
                if "< Previous" in widget_texts:
                    bottom_layout = item
                    break
                    
        if bottom_layout:
            if bottom_layout.indexOf(self.create_button) != -1:
                bottom_layout.removeWidget(self.create_button)
                self.create_button.hide()
                
            if bottom_layout.indexOf(self.start_game_button) == -1:
                bottom_layout.addWidget(self.start_game_button)
            self.start_game_button.show()
            self.start_game_button.setFocus()
            logger.debug("'Start Game' button displayed and focused")
        else:
            logger.error("Could not find bottom button layout to replace buttons")

    def _start_new_game(self):
        """Accept the dialog to start a new game with the created character."""
        logger.info("Starting new game with created character")
        self.accept()
        
    def _get_detailed_context_for_llm(self) -> Dict[str, Any]:
        """Gathers detailed context about race, class, and origin for LLM prompts."""
        context = {}
        config = get_config()

        # --- Race Details ---
        race_name = self.race_combo.currentText()
        race_data = config.get(f"races.{race_name}", {}) # Assumes race name is key
        if not race_data: # Fallback if name isn't key
             all_races = config.get_all("races")
             race_data = next((r for r in all_races.values() if r.get("name") == race_name), {})

        context['race'] = {
            "name": race_name,
            "description": race_data.get('description', 'No description available.'),
            "traits": [f"{t.get('name', 'Unknown')}: {t.get('description', '-')}" for t in race_data.get('traits', [])]
        }

        # --- Class Details ---
        class_name = self.path_combo.currentText()
        class_data = config.get(f"classes.{class_name}", {}) # Assumes class name is key
        if not class_data: # Fallback if name isn't key
            all_classes = config.get_all("classes")
            class_data = next((c for c in all_classes.values() if c.get("name") == class_name), {})

        context['class'] = {
            "name": class_name,
            "description": class_data.get('description', 'No description available.'),
            "recommended_stats": class_data.get('recommended_stats', {}).get('primary', []),
            # Add proficiencies if needed:
            # "weapon_proficiencies": class_data.get('weapon_proficiencies', []),
            # "armor_proficiencies": class_data.get('armor_proficiencies', []),
        }

        # --- Origin Details ---
        origin_id = self.origin_combo.currentData()
        origin_data = self.selected_origin_data # Use stored data from selection
        if origin_data and origin_data.get('id') == origin_id:
            context['origin'] = {
                "name": origin_data.get('name', 'Unknown Origin'),
                "description": origin_data.get('description', 'No description available.'),
                "location": origin_data.get('starting_location_id', 'Unknown Location'), # Location ID
                # Add traits and skills if useful for context
                "traits": [f"{t.get('name', 'Unknown')}: {t.get('description', '-')}" for t in origin_data.get('origin_traits', [])],
                "skills": origin_data.get('skill_proficiencies', [])
            }
        else:
            context['origin'] = {"name": self.origin_combo.currentText(), "description": "Details unavailable."}


        # --- Character Info ---
        context['character'] = {
             "name": self.player_name_edit.text().strip(),
             "sex": self.sex_combo.currentText()
        }

        # --- Allocated Stats ---
        # Get base stats AFTER allocation for context (important!)
        if hasattr(self, 'stat_allocation'):
             context['stats'] = self.stat_allocation.get_allocated_stats() # Get base allocated stats

        return context

    def _format_context_for_llm_prompt(self, detailed_context: Dict[str, Any]) -> str:
        """Formats the detailed context into a string for the LLM prompt."""
        prompt_parts = ["Character Context:\n"]

        # Character Basics
        char_info = detailed_context.get('character', {})
        prompt_parts.append(f"- Name: {char_info.get('name', '(Not Set)')}")
        prompt_parts.append(f"- Sex: {char_info.get('sex', 'Unknown')}")

        # Race
        race_info = detailed_context.get('race', {})
        prompt_parts.append(f"\nRace: {race_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {race_info.get('description', 'N/A')}")
        if race_info.get('traits'):
            prompt_parts.append("  - Traits:")
            for trait in race_info['traits']:
                prompt_parts.append(f"    - {trait}")

        # Class
        class_info = detailed_context.get('class', {})
        prompt_parts.append(f"\nClass: {class_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {class_info.get('description', 'N/A')}")
        if class_info.get('recommended_stats'):
            prompt_parts.append(f"  - Recommended Primary Stats: {', '.join(class_info['recommended_stats'])}")

        # Origin
        origin_info = detailed_context.get('origin', {})
        prompt_parts.append(f"\nOrigin: {origin_info.get('name', 'Unknown')}")
        prompt_parts.append(f"  - Description: {origin_info.get('description', 'N/A')}")
        prompt_parts.append(f"  - Starting Location ID: {origin_info.get('location', 'N/A')}")
        if origin_info.get('skills'):
             prompt_parts.append(f"  - Origin Skills: {', '.join(origin_info['skills'])}")
        if origin_info.get('traits'):
            prompt_parts.append("  - Origin Traits:")
            for trait in origin_info['traits']:
                 prompt_parts.append(f"    - {trait}")

        # Allocated Stats
        stats_info = detailed_context.get('stats', {})
        if stats_info:
            prompt_parts.append("\nAllocated Base Stats:")
            stat_strs = [f"{name}: {val}" for name, val in sorted(stats_info.items())]
            prompt_parts.append(f"  - {', '.join(stat_strs)}")

        return "\n".join(prompt_parts)

    # --- New Slot for Icon Updates ---
    @Slot()
    def _update_icons_on_selection_change(self):
        """Calls scan_character_icons with current selections."""
        race = self.race_combo.currentText()
        class_name = self.path_combo.currentText()
        sex = self.sex_combo.currentText()
        self.scan_character_icons(race, class_name, sex)
```

### File: gui\dialogs\combat_settings_dialog.py

```python
# gui/dialogs/combat_settings_dialog.py

import os
import logging
from typing import Dict, Any, List, Optional

from PySide6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, QLabel,
    QPushButton, QGroupBox, QDialogButtonBox, QFontDialog, QColorDialog,
    QSizePolicy, QFrame, QScrollArea
)
from PySide6.QtGui import QPixmap, QIcon, QFont, QColor, QPalette
from PySide6.QtCore import Qt, Slot, QSize

from gui.dialogs.base_dialog import BaseDialog

# Get logger for the dialog
logger = logging.getLogger("GUI") # Use the same logger name as combat_display

class CombatSettingsDialog(BaseDialog):
    """Dialog for configuring Combat Display settings."""

    def __init__(self, current_settings: Dict[str, Any], image_dir: str, parent: Optional[QWidget] = None):
        """
        Initialize the settings dialog.

        Args:
            current_settings: A dictionary containing the current settings.
            image_dir: The absolute path to the directory containing background images.
            parent: The parent widget.
        """
        super().__init__(parent)
        self.setWindowTitle("Combat Display Settings")
        self.setMinimumHeight(550) # Increased height slightly
        self.setMinimumWidth(850) # Increased width slightly

        # Store settings and image directory
        self.settings = current_settings.copy()
        self.image_dir = image_dir
        self.available_images: List[str] = []
        self.current_image_index: int = -1
        self.color_buttons: Dict[str, QPushButton] = {}

        # Main layout
        main_layout = QVBoxLayout(self)

        # --- Sections ---
        main_layout.addWidget(self._setup_background_section())
        main_layout.addWidget(self._setup_font_section())
        color_group = self._setup_color_section()
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setWidget(color_group)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        main_layout.addWidget(scroll_area, 1) # Allow color section to expand

        # --- Dialog Buttons ---
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        main_layout.addWidget(button_box)

        # Load initial values into UI elements
        self._load_settings_to_ui()

    # --- Section Setup Methods ---

    def _setup_background_section(self) -> QGroupBox:
        """Create the GroupBox for background image settings."""
        group = QGroupBox("Main Background Image") # Renamed for clarity
        layout = QVBoxLayout(group)
        h_layout = QHBoxLayout() # Layout for controls

        # Image Preview
        self.bg_preview_label = QLabel("No Image Selected")
        self.bg_preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.bg_preview_label.setFixedSize(200, 112) # 16:9 aspect ratio approx
        self.bg_preview_label.setFrameShape(QFrame.Shape.StyledPanel)
        self.bg_preview_label.setStyleSheet("background-color: #333;") # Dark background for preview

        # Controls Layout
        controls_layout = QVBoxLayout()
        controls_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Image Filename Label
        self.bg_filename_label = QLabel("Current: None")
        self.bg_filename_label.setWordWrap(True)
        controls_layout.addWidget(self.bg_filename_label)

        # Navigation Buttons
        nav_layout = QHBoxLayout()
        prev_button = QPushButton("< Prev") # Use standard characters
        prev_button.setToolTip("Select previous background image")
        prev_button.clicked.connect(self._browse_image_left)
        next_button = QPushButton("Next >") # Use standard characters
        next_button.setToolTip("Select next background image")
        next_button.clicked.connect(self._browse_image_right)
        nav_layout.addWidget(prev_button)
        nav_layout.addWidget(next_button)
        controls_layout.addLayout(nav_layout)

        # Clear Button
        clear_button = QPushButton("Clear Background")
        clear_button.setToolTip("Remove background image selection")
        clear_button.clicked.connect(self._clear_background)
        controls_layout.addWidget(clear_button)

        # Add preview and controls to horizontal layout
        h_layout.addWidget(self.bg_preview_label)
        h_layout.addLayout(controls_layout)
        layout.addLayout(h_layout)

        # Scan for available images
        self._scan_images()

        return group

    def _setup_font_section(self) -> QGroupBox:
        """Create the GroupBox for font settings."""
        group = QGroupBox("Font Settings")
        layout = QHBoxLayout(group) # Use QHBoxLayout for side-by-side

        # Font Selection Button
        font_button = QPushButton("Choose Base Font...")
        font_button.setToolTip("Select font family and base size for most elements")
        font_button.clicked.connect(self._choose_font)
        layout.addWidget(font_button)

        # Font Preview Label
        self.font_preview_label = QLabel("Font Preview Text")
        self.font_preview_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        layout.addWidget(self.font_preview_label)

        return group

    def _setup_color_section(self) -> QGroupBox:
        """Create the GroupBox for color settings, organized into columns."""
        group = QGroupBox("Color Settings")
        main_h_layout = QHBoxLayout(group)

        categories = {
            "Log General": [
                "color_log_default", "color_log_header", "color_log_dev",
                "color_log_system_message", "color_log_narrative", "color_log_combat_event",
                "color_log_group_bg", "color_log_text_bg"
            ],
            "Log Specific Events": [
                "color_log_damage", "color_log_heal", "color_log_crit", "color_log_miss",
                "color_log_roll", "color_log_turn", "color_log_round"
            ],
            "Entity Display": [
                "color_entity_player_bg", "color_entity_player_border",
                "color_entity_player_bg_active", "color_entity_player_border_active",
                "color_entity_enemy_bg", "color_entity_enemy_border",
                "color_entity_enemy_bg_active", "color_entity_enemy_border_active"
            ],
            "Progress Bars": [
                "color_hp_bar_chunk_normal", "color_hp_bar_chunk_low", "color_hp_bar_chunk_critical",
                "color_hp_bar_chunk_normal_bleak", "color_hp_bar_chunk_low_bleak", "color_hp_bar_chunk_critical_bleak",
                "color_stamina_bar_chunk", "color_stamina_bar_chunk_bleak",
                "color_mana_bar_chunk", "color_mana_bar_chunk_bleak", # Added Mana Bleak
                "color_resolve_bar_chunk", "color_progressbar_text", "color_progressbar_bg"
            ],
            "Section & UI Text": [
                "color_player_group_bg", "color_enemies_group_bg",
                "color_groupbox_title_text", "color_groupbox_title_bg",
                "color_status_text", "color_round_text"
            ]
        }

        for category_name, keys in categories.items():
            valid_keys_in_category = [k for k in keys if k in self.settings]
            if not valid_keys_in_category:
                continue

            category_v_layout = QVBoxLayout()
            category_v_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

            category_label = QLabel(f"<b>{category_name}</b>")
            category_v_layout.addWidget(category_label)

            form_layout = QFormLayout()
            form_layout.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
            form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
            form_layout.setRowWrapPolicy(QFormLayout.RowWrapPolicy.WrapLongRows)


            valid_keys_in_category.sort() 

            for key in valid_keys_in_category:
                label_text_parts = key.replace("color_", "").replace("_", " ").split(" ")
                # Capitalize each part and join
                label_text = " ".join([part.capitalize() for part in label_text_parts]) + ":"
                
                # Specific label overrides for better readability
                if key == "color_log_default": label_text = "Log Default Text:"
                elif key == "color_log_header": label_text = "Log Header Text:"
                elif key == "color_log_dev": label_text = "Log Dev Message:"
                elif key == "color_log_system_message": label_text = "Log System Message:"
                elif key == "color_log_narrative": label_text = "Log Narrative/GM Text:"
                elif key == "color_log_combat_event": label_text = "Log Major Combat Event:"
                elif key == "color_log_group_bg": label_text = "Log Section BG:"
                elif key == "color_log_text_bg": label_text = "Log Text Area BG:"
                elif key == "color_log_damage": label_text = "Log Damage Text:"
                elif key == "color_log_heal": label_text = "Log Heal Text:"
                elif key == "color_log_crit": label_text = "Log Critical Hit:"
                elif key == "color_log_miss": label_text = "Log Miss/Fail:"
                elif key == "color_log_roll": label_text = "Log Dice Roll:"
                elif key == "color_log_turn": label_text = "Log Turn Change:"
                elif key == "color_log_round": label_text = "Log Round Change:"
                elif key == "color_entity_player_bg": label_text = "Player Entity BG:"
                elif key == "color_entity_player_border": label_text = "Player Entity Border:"
                elif key == "color_entity_player_bg_active": label_text = "Player Active BG:"
                elif key == "color_entity_player_border_active": label_text = "Player Active Border:"
                elif key == "color_entity_enemy_bg": label_text = "Enemy Entity BG:"
                elif key == "color_hp_bar_chunk_normal": label_text = "HP Bar Normal:"
                elif key == "color_hp_bar_chunk_low": label_text = "HP Bar Low:"
                elif key == "color_hp_bar_chunk_critical": label_text = "HP Bar Critical:"
                elif key == "color_hp_bar_chunk_normal_bleak": label_text = "HP Bar Normal (Bleak):"
                elif key == "color_hp_bar_chunk_low_bleak": label_text = "HP Bar Low (Bleak):"
                elif key == "color_hp_bar_chunk_critical_bleak": label_text = "HP Bar Critical (Bleak):"
                elif key == "color_stamina_bar_chunk": label_text = "Stamina Bar:"
                elif key == "color_stamina_bar_chunk_bleak": label_text = "Stamina Bar (Bleak):"
                elif key == "color_mana_bar_chunk": label_text = "Mana Bar:" # Added Mana Bar
                elif key == "color_mana_bar_chunk_bleak": label_text = "Mana Bar (Bleak):" # Added Mana Bar Bleak
                elif key == "color_resolve_bar_chunk": label_text = "Resolve Bar:"
                elif key == "color_progressbar_text": label_text = "Progress Bar Text:"
                elif key == "color_progressbar_bg": label_text = "Progress Bar BG:"
                elif key == "color_player_group_bg": label_text = "Player Section BG:"
                elif key == "color_enemies_group_bg": label_text = "Enemies Section BG:"
                elif key == "color_groupbox_title_text": label_text = "Section Title Text:"
                elif key == "color_groupbox_title_bg": label_text = "Section Title BG:"
                elif key == "color_status_text": label_text = "Status Label Text:"
                elif key == "color_round_text": label_text = "Round Label Text:"


                color_button = self._create_color_button(key)
                form_layout.addRow(label_text, color_button)
                self.color_buttons[key] = color_button

            category_v_layout.addLayout(form_layout)
            main_h_layout.addLayout(category_v_layout)

        main_h_layout.addStretch()
        return group
    # --- Helper Methods ---

    def _scan_images(self):
        """Scan the image directory for valid image files."""
        self.available_images = []
        try:
            if os.path.isdir(self.image_dir):
                for filename in sorted(os.listdir(self.image_dir)):
                    if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
                        self.available_images.append(filename)
                logger.info(f"Found {len(self.available_images)} images in {self.image_dir}")
            else:
                logger.warning(f"Image directory not found: {self.image_dir}")
        except OSError as e:
            logger.error(f"Error scanning image directory {self.image_dir}: {e}")

    def _update_background_preview(self):
        """Update the background image preview label and filename."""
        if 0 <= self.current_image_index < len(self.available_images):
            relative_path = self.available_images[self.current_image_index]
            full_path = os.path.join(self.image_dir, relative_path)
            pixmap = QPixmap(full_path)
            if not pixmap.isNull():
                scaled_pixmap = pixmap.scaled(self.bg_preview_label.size(),
                                              Qt.AspectRatioMode.KeepAspectRatioByExpanding, # Fill the space better
                                              Qt.TransformationMode.SmoothTransformation)
                # Crop the pixmap to the label size after scaling
                rect = scaled_pixmap.rect()
                rect.setSize(self.bg_preview_label.size())
                cropped_pixmap = scaled_pixmap.copy(rect)

                self.bg_preview_label.setPixmap(cropped_pixmap)
                self.bg_filename_label.setText(f"Current: {relative_path}")
                self.settings["background_image"] = relative_path # Store relative path
            else:
                logger.warning(f"Failed to load image: {full_path}")
                self._clear_background_ui() # Show error state
                self.bg_filename_label.setText(f"Error loading: {relative_path}")
        else:
            self._clear_background_ui()

    def _clear_background_ui(self):
        """Clear the background preview and filename label."""
        self.bg_preview_label.clear()
        self.bg_preview_label.setText("No Image Selected")
        self.bg_preview_label.setStyleSheet("background-color: #333;") # Reset background
        self.bg_filename_label.setText("Current: None")
        self.settings["background_image"] = None # Clear setting

    def _update_font_preview(self):
        """Update the font preview label based on current settings."""
        font_family = self.settings.get("font_family", "Arial")
        font_size = self.settings.get("font_size", 10)
        font = QFont(font_family, font_size)
        self.font_preview_label.setFont(font)
        self.font_preview_label.setText(f"{font_family}, {font_size}pt - AaBbCc") # Add sample text

    def _create_color_button(self, setting_key: str) -> QPushButton:
        """Create a button for selecting a color."""
        button = QPushButton()
        button.setProperty("setting_key", setting_key) # Store key on button
        button.setToolTip(f"Click to change color for '{setting_key}'")
        button.setMinimumHeight(25)
        button.clicked.connect(self._choose_color)
        return button

    def _update_color_button_preview(self, button: QPushButton, color_value: str):
        """Update the appearance of a color selection button."""
        try:
            qcolor = QColor(color_value)
            if qcolor.isValid():
                # Set background color
                # Determine text color based on background brightness for readability
                brightness = (qcolor.red() * 299 + qcolor.green() * 587 + qcolor.blue() * 114) / 1000
                text_color = "#000000" if brightness > 128 else "#FFFFFF"
                # Combine styles
                button.setStyleSheet(f"background-color: {color_value}; color: {text_color}; border: 1px solid #888;") # Add border for definition
                button.setText(color_value) # Display the color value
            else:
                button.setText("Invalid Color")
                button.setStyleSheet("") # Reset style
        except Exception as e:
            logger.error(f"Error updating color button preview for '{color_value}': {e}")
            button.setText("Error")
            button.setStyleSheet("")

    def _load_settings_to_ui(self):
        """Load the initial settings values into the UI controls."""
        # Background
        current_bg = self.settings.get("background_image")
        if current_bg and self.available_images: # Check if list is not empty
            try:
                self.current_image_index = self.available_images.index(current_bg)
            except ValueError:
                logger.warning(f"Saved background image '{current_bg}' not found in available images. Clearing.")
                self.current_image_index = -1 # Not found
                if "background_image" in self.settings: self.settings["background_image"] = None # Clear invalid setting
        else:
            self.current_image_index = -1
            if "background_image" in self.settings: self.settings["background_image"] = None # Ensure it's cleared if no images available
        self._update_background_preview()

        # Font
        self._update_font_preview()

        # Colors
        for key, button in self.color_buttons.items():
            # Provide a default fallback color if key is missing in settings (e.g., new setting added)
            default_color = "#FFFFFF" if "bg" in key else "#000000" # Simple default logic
            color_value = self.settings.get(key, default_color)
            self._update_color_button_preview(button, color_value)

    # --- Slots ---

    @Slot()
    def _browse_image_left(self):
        """Select the previous image."""
        if not self.available_images: return
        self.current_image_index -= 1
        if self.current_image_index < 0:
            self.current_image_index = len(self.available_images) - 1 # Wrap around
        self._update_background_preview()

    @Slot()
    def _browse_image_right(self):
        """Select the next image."""
        if not self.available_images: return
        self.current_image_index += 1
        if self.current_image_index >= len(self.available_images):
            self.current_image_index = 0 # Wrap around
        self._update_background_preview()

    @Slot()
    def _clear_background(self):
        """Clear the background image selection."""
        self.current_image_index = -1
        self._update_background_preview()

    @Slot()
    def _choose_font(self):
        """Open the QFontDialog to select a font."""
        current_family = self.settings.get("font_family", "Arial")
        current_size = self.settings.get("font_size", 10)
        current_font = QFont(current_family, current_size)

        ok, font = QFontDialog.getFont(current_font, self, "Select Base Font")
        if ok:
            self.settings["font_family"] = font.family()
            self.settings["font_size"] = font.pointSize()
            self._update_font_preview() # Update the preview label

    @Slot()
    def _choose_color(self):
        """Open the QColorDialog to select a color for the clicked button."""
        sender_button = self.sender()
        if not isinstance(sender_button, QPushButton):
            return

        setting_key = sender_button.property("setting_key")
        if not setting_key:
            logger.warning("Color button clicked without a 'setting_key' property.")
            return

        current_color_value = self.settings.get(setting_key, "#000000")
        try:
            current_qcolor = QColor(current_color_value)
            if not current_qcolor.isValid():
                logger.warning(f"Invalid current color '{current_color_value}' for key '{setting_key}'. Defaulting to black.")
                current_qcolor = QColor("#000000")
        except Exception:
             logger.warning(f"Error parsing current color '{current_color_value}' for key '{setting_key}'. Defaulting to black.")
             current_qcolor = QColor("#000000")


        # Open color dialog, always allow alpha for background colors or if current value suggests it
        options = QColorDialog.ColorDialogOption(0)
        # Enable alpha if it's a background setting OR if the current color has alpha OR if it's an rgba string
        if "bg" in setting_key.lower() or current_qcolor.alpha() < 255 or 'rgba' in current_color_value.lower():
             options = QColorDialog.ColorDialogOption.ShowAlphaChannel

        new_color = QColorDialog.getColor(current_qcolor, self, f"Select Color for {setting_key}", options=options)

        if new_color.isValid():
            # Store color. Use RGBA string if alpha is not 255, otherwise use hex.
            if new_color.alpha() < 255:
                # Store rgba string directly as it's often more CSS friendly.
                # Use integer values for RGB, float for alpha
                rgba_string = f"rgba({new_color.red()}, {new_color.green()}, {new_color.blue()}, {new_color.alphaF():.3f})"
                self.settings[setting_key] = rgba_string
                self._update_color_button_preview(sender_button, rgba_string)
            else:
                hex_name = new_color.name(QColor.NameFormat.HexRgb) # Format like #RRGGBB
                self.settings[setting_key] = hex_name
                self._update_color_button_preview(sender_button, hex_name)


    # --- Public Method ---

    def get_settings(self) -> Dict[str, Any]:
        """
        Return the modified settings dictionary.

        This should be called after the dialog has been accepted.
        """
        # The self.settings dictionary has been updated throughout interaction
        logger.info("Returning updated settings from dialog.")
        # Ensure background image is None if index is invalid or no images available
        if not self.available_images or self.current_image_index < 0 or self.current_image_index >= len(self.available_images):
            self.settings["background_image"] = None
        elif self.available_images: # Check again just in case
             self.settings["background_image"] = self.available_images[self.current_image_index]

        return self.settings


```

### File: gui\dialogs\game_over_dialog.py

```python
# gui/dialogs/game_over_dialog.py
import os
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QFrame, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QSize
from PySide6.QtGui import QFont, QColor, QPalette

class GameOverDialog(QDialog):
    """Dialog displayed when the player is defeated."""

    # Signals for button clicks
    new_game_requested = Signal()
    load_game_requested = Signal()
    load_last_save_requested = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self.setWindowTitle("Game Over")
        self.setModal(True) # Block interaction with main window
        self.setMinimumSize(400, 250)
        # Remove close button, force choice via buttons
        self.setWindowFlags(self.windowFlags() & ~Qt.WindowCloseButtonHint | Qt.FramelessWindowHint)

        # --- Styling ---
        self.setStyleSheet("""
            QDialog {
                background-color: rgba(30, 30, 30, 0.95); /* Dark semi-transparent background */
                border: 2px solid #8B0000; /* Dark red border */
                border-radius: 15px;
            }
            QLabel#GameOverTitle {
                color: #DC143C; /* Crimson red */
                font-size: 48px;
                font-weight: bold;
                qproperty-alignment: 'AlignCenter';
                padding: 20px;
            }
            QLabel#GameOverReason {
                color: #E0E0E0; /* Light gray */
                font-size: 16px;
                qproperty-alignment: 'AlignCenter';
                padding-bottom: 20px;
            }
            QPushButton {
                background-color: #555555;
                color: #FFFFFF;
                border: 1px solid #777777;
                border-radius: 5px;
                padding: 10px 20px;
                font-size: 14px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #666666;
                border: 1px solid #999999;
            }
            QPushButton:pressed {
                background-color: #444444;
            }
            QPushButton#LoadLastSaveButton {
                background-color: #4CAF50; /* Green for emphasis */
            }
            QPushButton#LoadLastSaveButton:hover {
                background-color: #66BB69;
            }
             QPushButton#LoadLastSaveButton:pressed {
                background-color: #3B8C3E;
            }
        """)

        # --- Layout ---
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        main_layout.setAlignment(Qt.AlignCenter)

        # Title Label
        title_label = QLabel("GAME OVER")
        title_label.setObjectName("GameOverTitle")
        main_layout.addWidget(title_label, 0, Qt.AlignCenter)

        # Reason Label (optional, can be set externally)
        self.reason_label = QLabel("You have been defeated!")
        self.reason_label.setObjectName("GameOverReason")
        main_layout.addWidget(self.reason_label, 0, Qt.AlignCenter)

        # Button Layout
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        button_layout.setAlignment(Qt.AlignCenter) # Center buttons horizontally

        self.new_game_button = QPushButton("New Game")
        self.load_game_button = QPushButton("Load Game")
        self.load_last_save_button = QPushButton("Load Last Save")
        self.load_last_save_button.setObjectName("LoadLastSaveButton")

        button_layout.addWidget(self.new_game_button)
        button_layout.addWidget(self.load_game_button)
        button_layout.addWidget(self.load_last_save_button)

        main_layout.addLayout(button_layout)

        # --- Connections ---
        self.new_game_button.clicked.connect(self._on_new_game)
        self.load_game_button.clicked.connect(self._on_load_game)
        self.load_last_save_button.clicked.connect(self._on_load_last_save)

    def set_reason(self, reason: str):
        """Set the reason text displayed below GAME OVER."""
        self.reason_label.setText(reason)

    def _on_new_game(self):
        self.new_game_requested.emit()
        self.accept() # Close the dialog

    def _on_load_game(self):
        self.load_game_requested.emit()
        self.accept() # Close the dialog

    def _on_load_last_save(self):
        self.load_last_save_requested.emit()
        self.accept() # Close the dialog

    # --- Optional: Centering on Show ---
    def showEvent(self, event):
        """Center the dialog when shown."""
        super().showEvent(event)
        if self.parent():
            parent_rect = self.parent().geometry()
            self.move(parent_rect.center() - self.rect().center())
```

### File: gui\dialogs\item_info_dialog.py

```python
#!/usr/bin/env python3
"""
Dialog for displaying detailed item information.
"""

import logging
from typing import Optional, Dict, Any, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout,
    QTextBrowser, QPushButton, QSizePolicy, QScrollArea, QWidget, QFrame
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QFont, QColor

from core.inventory.item import Item
from core.inventory.currency_manager import CurrencyManager 

logger = logging.getLogger("GUI")

class ItemInfoDialog(QDialog):
    """Dialog to display detailed information about an item."""

    def __init__(self, item: Optional[Item] = None, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.item = item
        self.setWindowTitle("Item Information")
        self.setMinimumSize(400, 550) # Increased min height
        self.setStyleSheet("""
            QDialog {
                background-color: #2E2E2E;
                color: #E0E0E0;
                border: 1px solid #555555;
            }
            QLabel {
                color: #E0E0E0;
                background-color: transparent;
            }
            QTextBrowser {
                background-color: #252525;
                color: #CFCFCF;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 5px; /* Added padding */
            }
            QPushButton {
                background-color: #4A4A4A;
                color: #E0E0E0;
                border: 1px solid #666666;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #5A5A5A;
            }
            QPushButton:pressed {
                background-color: #3A3A3A;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QWidget#scrollAreaWidgetContents { 
                background-color: transparent;
            }
            QGroupBox { /* Basic style for potential future group boxes */
                color: #E0E0E0;
                font-weight: bold;
                border: 1px solid #444444;
                border-radius: 3px;
                margin-top: 10px; /* Space above groupbox */
                padding-top: 15px; /* Space for title */
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 5px;
            }
        """)

        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(15, 15, 15, 15)
        self.main_layout.setSpacing(10)

        self._setup_ui()
        if self.item:
            self.populate_data()

    def _setup_ui(self):
        """Set up the UI elements for the dialog."""
        scroll_area = QScrollArea(self)
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        self.scroll_content_widget = QWidget(scroll_area)
        self.scroll_content_widget.setObjectName("scrollAreaWidgetContents")
        scroll_area.setWidget(self.scroll_content_widget)

        self.content_layout = QVBoxLayout(self.scroll_content_widget)
        self.content_layout.setSpacing(12) # Increased spacing

        # Name and Rarity
        name_rarity_layout = QHBoxLayout()
        self.name_label = QLabel("Item Name")
        self.name_label.setStyleSheet("font-size: 16pt; font-weight: bold;")
        name_rarity_layout.addWidget(self.name_label)
        name_rarity_layout.addStretch()
        self.rarity_label = QLabel("(Rarity)")
        self.rarity_label.setStyleSheet("font-size: 10pt; font-style: italic;")
        name_rarity_layout.addWidget(self.rarity_label)
        self.content_layout.addLayout(name_rarity_layout)

        # Type
        self.type_label = QLabel("Type: ?")
        self.type_label.setStyleSheet("font-size: 11pt;")
        self.content_layout.addWidget(self.type_label)
        
        self.content_layout.addWidget(self._create_separator())

        # Description
        self.description_title_label = QLabel("<b>Description:</b>")
        self.content_layout.addWidget(self.description_title_label)
        self.description_browser = QTextBrowser()
        self.description_browser.setPlaceholderText("?")
        self.description_browser.setOpenExternalLinks(True)
        self.description_browser.setMinimumHeight(60) 
        self.description_browser.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.MinimumExpanding)
        self.content_layout.addWidget(self.description_browser)

        # Grid for Weight, Value, Durability, Equip Slots
        self.grid_layout = QGridLayout()
        self.grid_layout.setSpacing(8) # Adjusted spacing
        self.grid_layout.setColumnStretch(1, 1) # Allow value column to stretch
        self.content_layout.addLayout(self.grid_layout)

        # Metrics rows
        self.weight_label = self._add_grid_row("Weight:", "?", 0)
        self.value_label = self._add_grid_row("Value:", "?", 1)
        self.quantity_label = self._add_grid_row("Quantity:", "?", 2)
        self.stack_limit_label = self._add_grid_row("Stack limit:", "?", 3)
        self.durability_label = self._add_grid_row("Durability:", "?", 4)
        self.equip_slots_label = self._add_grid_row("Equip Slots:", "?", 5)
        self.equip_slots_label.setWordWrap(True)
        
        self.content_layout.addWidget(self._create_separator())

        # Stats & Effects
        self.stats_effects_title_label = QLabel("<b>Stats & Effects:</b>")
        self.content_layout.addWidget(self.stats_effects_title_label)
        self.stats_browser = QTextBrowser()
        self.stats_browser.setPlaceholderText("?")
        self.stats_browser.setMinimumHeight(80)
        self.stats_browser.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.MinimumExpanding)
        self.content_layout.addWidget(self.stats_browser)
        
        # Custom Properties
        self.custom_props_title_label = QLabel("<b>Properties:</b>") # Changed title slightly for clarity
        self.content_layout.addWidget(self.custom_props_title_label)
        self.custom_props_browser = QTextBrowser()
        self.custom_props_browser.setPlaceholderText("?")
        self.custom_props_browser.setMinimumHeight(40)
        self.custom_props_browser.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.MinimumExpanding)
        self.content_layout.addWidget(self.custom_props_browser)

        # Tags
        self.tags_label = QLabel("Tags: ?")
        self.tags_label.setWordWrap(True)
        self.content_layout.addWidget(self.tags_label)

        self.content_layout.addStretch()
        self.main_layout.addWidget(scroll_area)

        # Close button
        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        self.main_layout.addWidget(self.close_button, 0, Qt.AlignRight)

    def _create_separator(self) -> QFrame:
        sep = QFrame()
        sep.setFrameShape(QFrame.Shape.HLine)
        sep.setFrameShadow(QFrame.Shadow.Sunken)
        sep.setStyleSheet("color: #444444;") # Make it slightly visible
        return sep

    def _add_grid_row(self, label_text: str, value_text: str, row: int) -> QLabel:
        """Helper to add a row to the grid layout."""
        label = QLabel(label_text)
        label.setStyleSheet("font-weight: bold;")
        label.setAlignment(Qt.AlignRight | Qt.AlignTop) # Align right and top for multi-line values
        value = QLabel(value_text)
        value.setWordWrap(True) # Allow values to wrap
        self.grid_layout.addWidget(label, row, 0)
        self.grid_layout.addWidget(value, row, 1)
        return value

    def populate_data(self):
        """Populate the dialog with item data."""
        if not self.item:
            self.name_label.setText("No Item Selected")
            self.description_browser.setHtml("<i>No item selected.</i>")
            self.stats_browser.setHtml("<i>No item selected.</i>")
            self.custom_props_browser.setHtml("<i>No item selected.</i>")
            self.description_title_label.setVisible(True)
            self.stats_effects_title_label.setVisible(True)
            self.custom_props_title_label.setVisible(True)
            return

        item = self.item
        known = item.known_properties

        # Name and Rarity
        title_name = item.name if "name" in known else "Unknown Item"
        if getattr(item, 'quantity', 1) > 1 and getattr(item, 'is_stackable', False):
            title_name = f"{title_name} × {int(item.quantity)}"
        self.name_label.setText(title_name)
        
        rarity_str = "?"
        rarity_color = "#CFCFCF" 
        if "rarity" in known and item.rarity:
            rarity_str = item.rarity.value.capitalize()
            rarity_color = item.rarity.color
        self.rarity_label.setText(f"({rarity_str})")
        self.rarity_label.setStyleSheet(f"font-size: 10pt; font-style: italic; color: {rarity_color};")

        # Type
        self.type_label.setText(f"Type: {item.item_type.value.capitalize() if 'item_type' in known and item.item_type else '?'}")

        # Description
        self.description_title_label.setVisible(True)
        if "description" in known:
            self.description_browser.setHtml(item.description if item.description else "<i>No description available.</i>")
        else:
            self.description_browser.setHtml("<i>Description currently unknown.</i>")


        # Weight, Value, Quantity/Stack
        if "weight" in known and item.weight is not None:
            if getattr(item, 'quantity', 1) > 1 and getattr(item, 'is_stackable', False):
                total_weight = (item.weight or 0.0) * int(item.quantity)
                self.weight_label.setText(f"{item.weight:.2f} kg (Total: {total_weight:.2f} kg)")
            else:
                self.weight_label.setText(f"{item.weight:.2f} kg")
        else:
            self.weight_label.setText("?")
        
        value_str = "?"
        if "value" in known and isinstance(item.value, int):
            cm_unit = CurrencyManager(); cm_unit.set_currency(int(item.value))
            value_str = cm_unit.get_formatted_currency()
            if getattr(item, 'quantity', 1) > 1 and getattr(item, 'is_stackable', False):
                total_val = int(item.value) * int(item.quantity)
                cm_total = CurrencyManager(); cm_total.set_currency(total_val)
                value_str = f"{value_str} (Total: {cm_total.get_formatted_currency()})"
        self.value_label.setText(value_str)

        # Quantity and Stack limit
        qty_str = str(getattr(item, 'quantity', 1)) if "quantity" in known else "?"
        self.quantity_label.setText(qty_str)
        if getattr(item, 'is_stackable', False):
            self.stack_limit_label.setText(str(getattr(item, 'stack_limit', ''))) 
        else:
            self.stack_limit_label.setText("N/A")

        durability_str = "?"
        if "durability" in known and item.durability is not None: # Check if durability itself is known
            # current_durability is also a knowable property. If item.durability is known, current_durability might also be.
            current_dur_known = "current_durability" in known
            current_dur = item.current_durability if current_dur_known and item.current_durability is not None else item.durability if item.durability is not None else "?"
            max_dur = item.durability if item.durability is not None else "?"
            if current_dur != "?" and max_dur != "?":
                durability_str = f"{current_dur} / {max_dur}"
            elif max_dur != "?": # Only max is known
                 durability_str = f"? / {max_dur}"
            else: # Neither known or only current is known (less likely)
                 durability_str = "?"

        elif "durability" not in known and item.durability is not None: # Durability exists but is not known
            durability_str = "? / ?"
        elif item.durability is None: # Item has no durability system
            durability_str = "N/A"
        self.durability_label.setText(durability_str)

        equip_slots_str = "?"
        if "is_equippable" in known: 
            if item.is_equippable:
                if "equip_slots" in known and item.equip_slots:
                    equip_slots_str = ", ".join(slot.value.replace('_', ' ').title() for slot in item.equip_slots)
                elif "equip_slots" in known: 
                     equip_slots_str = "None (Special)"
                else: 
                    equip_slots_str = "?" 
            else:
                equip_slots_str = "Not Equippable"
        self.equip_slots_label.setText(equip_slots_str)

        # Stats & Effects
        self.stats_effects_title_label.setVisible(True)
        stats_html_parts = []
        # Only try to display stats if the "stats" category itself is known
        if "stats" in known and item.stats: 
            known_item_stats_found = False
            temp_stats_list = []
            for stat_obj in item.stats:
                if f"stat_{stat_obj.name}" in known: 
                    known_item_stats_found = True
                    val_str = f"{stat_obj.value:+.1f}" if isinstance(stat_obj.value, (int, float)) and stat_obj.value != 0 else str(stat_obj.value)
                    if stat_obj.is_percentage and isinstance(stat_obj.value, (int,float)): val_str += "%"
                    display_name = stat_obj.display_name if stat_obj.display_name else stat_obj.name.replace('_', ' ').title()
                    temp_stats_list.append(f"<li><b>{display_name}:</b> {val_str}</li>")
            if known_item_stats_found:
                stats_html_parts.append("<u>Stats:</u><ul>" + "".join(temp_stats_list) + "</ul>")
        
        # Only try to display dice_roll_effects if the "dice_roll_effects" category is known
        if item.dice_roll_effects and "dice_roll_effects" in known:
            known_dice_effects_found = False
            temp_dice_effects_list = []
            for effect in item.dice_roll_effects:
                # Assume individual dice effects become known if the "dice_roll_effects" category is known
                known_dice_effects_found = True
                desc = f"{effect.dice_notation} {effect.effect_type.replace('_', ' ').title()}"
                if effect.description:
                    desc += f" <small><i>({effect.description})</i></small>"
                temp_dice_effects_list.append(f"<li>{desc}</li>")
            if known_dice_effects_found:
                 stats_html_parts.append("<u>Effects:</u><ul>" + "".join(temp_dice_effects_list) + "</ul>")
            
        if stats_html_parts:
            final_stats_html = "<br>".join(stats_html_parts)
            self.stats_browser.setHtml(final_stats_html)
        else: # No known stats or effects
            self.stats_browser.setHtml("<i>Unknown stats or effects.</i>")


        # Custom Properties
        self.custom_props_title_label.setVisible(True)
        custom_props_html = ""
        if "custom_properties" in known and item.custom_properties: 
            known_custom_prop_details = []
            for key, value in item.custom_properties.items():
                if f"custom_{key}" in known: 
                    known_custom_prop_details.append(f"<li><b>{key.replace('_', ' ').title()}:</b> {value}</li>")
            if known_custom_prop_details:
                custom_props_html = "<ul>" + "".join(known_custom_prop_details) + "</ul>"
        
        self.custom_props_browser.setHtml(custom_props_html if custom_props_html else "<i>No special properties known.</i>")


        # Tags
        self.tags_label.setVisible(True) # Always show the Tags label
        self.tags_label.setText(f"Tags: {', '.join(item.tags) if 'tags' in known and item.tags else '?'}")
```

### File: gui\dialogs\load_game_dialog.py

```python
#!/usr/bin/env python3
"""
Load game dialog for the RPG game GUI.
This module provides a dialog for loading a saved game.
"""

import logging
import os
import json
from typing import Optional, List, Dict
from datetime import datetime

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
    QPushButton, QGroupBox, QListWidget, QListWidgetItem,
    QSplitter, QWidget, QTextEdit, QHeaderView, QTableWidget,
    QTableWidgetItem, QAbstractItemView
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QIcon, QFont

from gui.dialogs.base_dialog import BaseDialog

class LoadGameDialog(BaseDialog):
    """Dialog for loading a saved game."""
    
    def __init__(self, parent=None):
        """Initialize the load game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Load Game")
        self.setMinimumWidth(600)
        self.setMinimumHeight(400)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget, QTableWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item, QTableWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected, QTableWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover, QTableWidget::item:hover {
                background-color: #383838;
            }
            QTextEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QHeaderView::section {
                background-color: #333333;
                color: #E0E0E0;
                padding: 5px;
                border: 1px solid #444444;
            }
            QSplitter::handle {
                background-color: #444444;
            }
        """)
        
        # Selected save
        self.selected_save = None
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create a splitter for the save list and details
        splitter = QSplitter(Qt.Horizontal)
        
        # Create the saves list widget
        saves_widget = QWidget()
        saves_layout = QVBoxLayout(saves_widget)
        saves_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the saves table
        self.saves_table = QTableWidget()
        self.saves_table.setColumnCount(3)
        self.saves_table.setHorizontalHeaderLabels(["Save Name", "Date", "Character"])
        self.saves_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.saves_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.saves_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.saves_table.verticalHeader().setVisible(False)
        self.saves_table.setAlternatingRowColors(True)
        self.saves_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.saves_table.setSelectionMode(QAbstractItemView.SingleSelection)
        self.saves_table.setEditTriggers(QTableWidget.NoEditTriggers)
        
        # Add saves table to layout
        saves_layout.addWidget(self.saves_table)
        
        # Create the details widget
        details_widget = QWidget()
        details_layout = QVBoxLayout(details_widget)
        details_layout.setContentsMargins(0, 0, 0, 0)
        
        # Create the details group
        details_group = QGroupBox("Save Details")
        details_group_layout = QVBoxLayout(details_group)
        
        # Create the details text
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        
        # Add details text to group layout
        details_group_layout.addWidget(self.details_text)
        
        # Add details group to layout
        details_layout.addWidget(details_group)
        
        # Add widgets to splitter
        splitter.addWidget(saves_widget)
        splitter.addWidget(details_widget)
        
        # Set initial sizes
        splitter.setSizes([int(self.width() * 0.6), int(self.width() * 0.4)])
        
        # Add splitter to main layout
        main_layout.addWidget(splitter)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create delete button
        self.delete_button = QPushButton("Delete Save")
        self.delete_button.setEnabled(False)
        # self.delete_button.clicked.connect(self._on_delete_clicked)
        
        # Create load button
        self.load_button = QPushButton("Load Game")
        self.load_button.setEnabled(False)
        self.load_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.delete_button)
        button_layout.addWidget(self.load_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load saves
        self._load_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Connect save selection
        self.saves_table.itemSelectionChanged.connect(self._on_save_selected)
        self.saves_table.doubleClicked.connect(self._on_save_double_clicked)
    
    def _load_saves(self):
        """Load saves into the table."""
        # Clear the table
        self.saves_table.setRowCount(0)
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to table
        for i, save_file in enumerate(save_files):
            # Get the full path
            save_path = os.path.join(saves_dir, save_file)
            
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Get the modification time
            mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
            mod_time_str = mod_time.strftime("%Y-%m-%d %H:%M")
            
            # Get the character name (if possible)
            character_name = self._get_character_name(save_path)
            
            # Add row to table
            self.saves_table.insertRow(i)
            self.saves_table.setItem(i, 0, QTableWidgetItem(save_name))
            self.saves_table.setItem(i, 1, QTableWidgetItem(mod_time_str))
            self.saves_table.setItem(i, 2, QTableWidgetItem(character_name))
    
    def _get_character_name(self, save_path: str) -> str:
        """Get the character name from a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The character name, or "Unknown" if not found.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Try to get the character name
                if "player" in save_data and "name" in save_data["player"]:
                    return save_data["player"]["name"]
        except Exception as e:
            pass
        
        return "Unknown"
    
    def _get_save_details(self, save_path: str) -> str:
        """Get the details for a save file.
        
        Args:
            save_path: The path to the save file.
        
        Returns:
            The save details as a formatted string.
        """
        try:
            with open(save_path, "r") as f:
                save_data = json.load(f)
                
                # Extract details
                player_data = save_data.get("player", {})
                world_data = save_data.get("world", {})
                
                # Format details
                details = []
                
                # Player details
                if player_data:
                    details.append("Character Information:")
                    details.append(f"Name: {player_data.get('name', 'Unknown')}")
                    details.append(f"Race: {player_data.get('race', 'Unknown')}")
                    details.append(f"Class: {player_data.get('path', 'Unknown')}")
                    details.append(f"Background: {player_data.get('background', 'Unknown')}")
                    details.append(f"Level: {player_data.get('level', 1)}")
                    details.append("")
                
                # World details
                if world_data:
                    details.append("World Information:")
                    details.append(f"Location: {world_data.get('current_location', 'Unknown')}")
                    details.append(f"Time: {world_data.get('game_time', 'Unknown')}")
                    details.append("")
                
                # Game details
                mod_time = datetime.fromtimestamp(os.path.getmtime(save_path))
                details.append("Save Information:")
                details.append(f"Created: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}")
                details.append(f"File: {os.path.basename(save_path)}")
                
                return "\n".join(details)
        except Exception as e:
            return f"Error loading save details: {str(e)}"
    
    def _on_save_selected(self):
        """Handle save selection."""
        # Get the selected row
        selected_rows = self.saves_table.selectedItems()
        
        if not selected_rows:
            # No selection
            self.selected_save = None
            self.details_text.clear()
            self.load_button.setEnabled(False)
            self.delete_button.setEnabled(False)
            return
        
        # Get the save name
        save_name = self.saves_table.item(selected_rows[0].row(), 0).text()
        
        # Set the selected save
        self.selected_save = save_name + ".json"
        
        # Get the save path
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        save_path = os.path.join(saves_dir, self.selected_save)
        
        # Update the details
        self.details_text.setText(self._get_save_details(save_path))
        
        # Enable buttons
        self.load_button.setEnabled(True)
        self.delete_button.setEnabled(True)
    
    def _on_save_double_clicked(self, item):
        """Handle save double click."""
        # Accept the dialog to load the selected save
        self.accept()

```

### File: gui\dialogs\new_game_dialog.py

```python
# gui/dialogs/new_game_dialog.py

import os
import json
import logging
from typing import Any, Optional, List, Dict

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QComboBox,
    QPushButton, QGroupBox, QTextEdit, QMessageBox, QFormLayout,
    QCheckBox, QScrollArea, QWidget
)
from PySide6.QtCore import Qt, Signal, Slot
from PySide6.QtGui import QPixmap
from core.base.config import get_config

# Get logger for this module
logger = logging.getLogger(__name__)

class NewGameDialog(QDialog):
    """Dialog for creating a new game character using the Origin system."""

    def __init__(self, parent=None):
        """Initialize the new game dialog."""
        super().__init__(parent)

        # Set window properties
        self.setWindowTitle("Create New Character")
        self.setMinimumWidth(700) # Increased width for more details
        self.setMinimumHeight(600) # Increased height
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
                padding-top: 3px; /* Add some vertical space */
            }
            QLineEdit, QTextEdit, QComboBox {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px; /* Reduced margin */
                padding-top: 10px; /* Add padding inside */
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding: 0 10px 0 10px;
                color: #E0E0E0;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            #OriginDetailsLabel { /* Style for the details labels */
                color: #CCCCCC;
                padding-left: 5px;
            }
        """)

        # Load data dynamically
        self.available_races = self._load_races()
        self.available_classes = self._load_classes()
        self.available_origins = self._load_origins() # Load origins instead of backgrounds
        self.available_sexes = ["Male", "Female", "Other"] # Added 'Other'

        # Set up character icon browsing
        self.character_icons = []
        self.current_icon_index = 0
        self.scan_character_icons()

        # Default to LLM enabled
        self.llm_enabled = True
        self.selected_icon_path = None
        self.selected_origin_data = None # Store full data of selected origin

        # Set up the UI
        self._setup_ui()

        # Connect signals
        self._connect_signals()

        # Initial validation
        self._validate_form()

    def _setup_ui(self):
        """Set up the user interface."""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(10) # Reduced spacing

        # Layout for character details (info, description) and portrait
        details_layout = QHBoxLayout()
        details_layout.setSpacing(15)

        # --- Left Column: Info, Origin Details, Description ---
        left_column_widget = QWidget() # Create a widget for the scroll area
        left_column_layout = QVBoxLayout(left_column_widget)
        left_column_layout.setContentsMargins(0,0,0,0)
        left_column_layout.setSpacing(10)

        # --- Character Info Group ---
        info_group = QGroupBox("Character Information")
        info_layout = QFormLayout(info_group)
        info_layout.setContentsMargins(15, 25, 15, 15) # Adjusted margins
        info_layout.setSpacing(8) # Reduced spacing

        self.player_name_edit = QLineEdit()
        self.player_name_edit.setPlaceholderText("Enter your character's name...")
        info_layout.addRow("Name:", self.player_name_edit)

        self.race_combo = QComboBox()
        self._populate_combo(self.race_combo, self.available_races, "Races")
        info_layout.addRow("Race:", self.race_combo)

        self.path_combo = QComboBox() # Represents Class
        self._populate_combo(self.path_combo, self.available_classes, "Classes")
        info_layout.addRow("Class:", self.path_combo)

        # --- Origin Selection (Replaces Background) ---
        self.origin_combo = QComboBox()
        self._populate_origin_combo() # Custom population method
        info_layout.addRow("Origin:", self.origin_combo)
        # --- End Origin Selection ---

        self.sex_combo = QComboBox()
        self._populate_combo(self.sex_combo, self.available_sexes, "Sexes")
        info_layout.addRow("Sex:", self.sex_combo)

        self.llm_checkbox = QCheckBox("Enable LLM (AI processing)")
        self.llm_checkbox.setChecked(self.llm_enabled)
        info_layout.addRow("", self.llm_checkbox)
        left_column_layout.addWidget(info_group)

        # --- Origin Details Group (NEW) ---
        origin_details_group = QGroupBox("Origin Details")
        origin_details_layout = QVBoxLayout(origin_details_group)
        origin_details_layout.setContentsMargins(15, 25, 15, 15)
        origin_details_layout.setSpacing(8)

        self.origin_desc_label = QLabel("Select an Origin to see details.")
        self.origin_desc_label.setObjectName("OriginDetailsLabel")
        self.origin_desc_label.setWordWrap(True)
        self.origin_desc_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(QLabel("<b>Description:</b>"))
        origin_details_layout.addWidget(self.origin_desc_label)

        self.origin_skills_label = QLabel("-")
        self.origin_skills_label.setObjectName("OriginDetailsLabel")
        self.origin_skills_label.setWordWrap(True)
        origin_details_layout.addWidget(QLabel("<b>Skill Proficiencies:</b>"))
        origin_details_layout.addWidget(self.origin_skills_label)

        self.origin_traits_label = QLabel("-")
        self.origin_traits_label.setObjectName("OriginDetailsLabel")
        self.origin_traits_label.setWordWrap(True)
        self.origin_traits_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        origin_details_layout.addWidget(QLabel("<b>Origin Traits:</b>"))
        origin_details_layout.addWidget(self.origin_traits_label)
        origin_details_layout.addStretch() # Push details up
        left_column_layout.addWidget(origin_details_group)


        # --- Description Group (Backstory) ---
        description_group = QGroupBox("Character Backstory (Optional Seed)")
        description_layout = QVBoxLayout(description_group)
        description_layout.setContentsMargins(15, 25, 15, 15)
        description_layout.setSpacing(5)

        description_label = QLabel("Optionally edit the text below (based on selected Origin) to guide the LLM background generation:")
        description_label.setWordWrap(True)
        description_label.setStyleSheet("color: #AAAAAA; font-style: italic;")

        self.description_edit = QTextEdit() # Player editable backstory seed
        self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
        self.description_edit.setMinimumHeight(100) # Ensure decent height

        description_layout.addWidget(description_label)
        description_layout.addWidget(self.description_edit)
        left_column_layout.addWidget(description_group)
        left_column_layout.addStretch(1) # Add stretch to push content up

        # --- Add Left Column Scroll Area ---
        left_scroll_area = QScrollArea()
        left_scroll_area.setWidgetResizable(True)
        left_scroll_area.setWidget(left_column_widget)


        # --- Right Column: Portrait ---
        right_column_widget = QWidget()
        right_column_layout = QVBoxLayout(right_column_widget)
        right_column_layout.setContentsMargins(0,0,0,0)
        right_column_layout.setSpacing(10)

        icon_group = QGroupBox("Character Portrait")
        icon_layout = QVBoxLayout(icon_group)
        icon_layout.setContentsMargins(15, 25, 15, 15)
        icon_layout.setSpacing(8)

        self.icon_label = QLabel()
        self.icon_label.setAlignment(Qt.AlignCenter)
        self.icon_label.setFixedSize(150, 150) # Fixed size for portrait
        self.icon_label.setStyleSheet("background-color: #1E1E1E; border: 1px solid #3F3F46;")
        self.icon_label.setText("No image")
        icon_layout.addWidget(self.icon_label, 0, Qt.AlignCenter) # Center the label

        nav_layout = QHBoxLayout()
        self.prev_icon_button = QPushButton("←")
        self.icon_counter_label = QLabel("0 / 0")
        self.icon_counter_label.setAlignment(Qt.AlignCenter)
        self.next_icon_button = QPushButton("→")
        nav_layout.addWidget(self.prev_icon_button)
        nav_layout.addWidget(self.icon_counter_label)
        nav_layout.addWidget(self.next_icon_button)
        icon_layout.addLayout(nav_layout)

        portrait_hint = QLabel("Browse available character portraits")
        portrait_hint.setStyleSheet("color: #888888; font-style: italic;")
        portrait_hint.setAlignment(Qt.AlignCenter)
        icon_layout.addWidget(portrait_hint)
        right_column_layout.addWidget(icon_group)
        right_column_layout.addStretch(1) # Push portrait group up


        # Add columns to main details layout
        details_layout.addWidget(left_scroll_area, 3)  # Left column takes more space
        details_layout.addWidget(right_column_widget, 1) # Right column for portrait

        main_layout.addLayout(details_layout, 1) # Make details layout stretch

        # --- Dialog Buttons ---
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        self.cancel_button = QPushButton("Cancel")
        self.create_button = QPushButton("Create Character")
        self.create_button.setEnabled(False)
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.create_button)
        main_layout.addLayout(button_layout)

    def _populate_combo(self, combo: QComboBox, items: List[str], item_type: str):
        """Helper to populate QComboBox and handle empty lists."""
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItems(items)
            combo.setEnabled(True)

    def _populate_origin_combo(self):
        """Populate the Origin combo box."""
        combo = self.origin_combo
        items = self.available_origins
        item_type = "Origins"

        combo.clear() # Clear previous items
        if not items:
            combo.addItem(f"No {item_type} Found")
            combo.setEnabled(False)
        else:
            combo.addItem("--- Select an Origin ---", None) # Placeholder item
            for origin_data in items:
                # Add item with name as text and id as data
                combo.addItem(origin_data.get('name', 'Unknown Origin'), origin_data.get('id'))
            combo.setEnabled(True)

    @Slot(int)
    def _on_origin_selected(self, index: int):
        """Update details display when an origin is selected."""
        self.selected_origin_data = None # Reset selected data
        origin_id = self.origin_combo.itemData(index)

        if origin_id is None: # Handle placeholder selection
            self.origin_desc_label.setText("Select an Origin to see details.")
            self.origin_skills_label.setText("-")
            self.origin_traits_label.setText("-")
            self.description_edit.setPlainText("") # Clear backstory seed
            self.description_edit.setPlaceholderText("Select an Origin to load starting text...")
            self._validate_form() # Re-validate as origin is deselected
            return

        # Find the full origin data using the ID
        origin = next((o for o in self.available_origins if o.get('id') == origin_id), None)

        if origin:
            self.selected_origin_data = origin # Store the full data
            self.origin_desc_label.setText(origin.get('description', 'No description available.'))

            # Format skills
            skills = origin.get('skill_proficiencies', [])
            self.origin_skills_label.setText(", ".join(skills) if skills else "None")

            # Format traits
            traits = origin.get('origin_traits', [])
            traits_text = ""
            if traits:
                trait_lines = [f"<b>{t.get('name', 'Unnamed Trait')}:</b> {t.get('description', 'No description.')}" for t in traits]
                traits_text = "<br>".join(trait_lines) # Use HTML for formatting
            else:
                traits_text = "None"
            self.origin_traits_label.setText(traits_text)

            # Pre-populate backstory seed if empty
            if not self.description_edit.toPlainText().strip():
                 self.description_edit.setPlainText(origin.get('introduction_text', ''))

        else:
            # Handle case where origin ID is found but data isn't (shouldn't happen)
            self.origin_desc_label.setText("Error: Could not load details.")
            self.origin_skills_label.setText("-")
            self.origin_traits_label.setText("-")
            self.description_edit.setPlainText("")
            logger.error(f"Could not find origin data for ID: {origin_id}")

        self._validate_form() # Re-validate after selection change


    def _toggle_llm(self, state):
        """Toggle LLM enabled state."""
        self.llm_enabled = bool(state)

    def _load_races(self) -> List[str]:
        """Load race names from the configuration."""
        races = [] # Start empty, rely on config
        try:
            config = get_config()
            loaded_races_data = config.get_all("races")
            if loaded_races_data:
                race_names = sorted([data.get('name', race_id) for race_id, data in loaded_races_data.items()])
                if race_names:
                    races = race_names
                    logger.info(f"Loaded {len(races)} races from config.")
                else:
                    logger.warning("No race names found in loaded race data.")
            else:
                logger.warning("Race configuration domain ('races') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading races from config: {e}.")
        return races if races else ["Human"] # Fallback if loading fails

    def _load_classes(self) -> List[str]:
        """Load class names from the configuration."""
        classes = [] # Start empty
        try:
            config = get_config()
            loaded_classes_data = config.get_all("classes")
            if loaded_classes_data:
                class_names = sorted([data.get('name', class_id) for class_id, data in loaded_classes_data.items()])
                if class_names:
                    classes = class_names
                    logger.info(f"Loaded {len(classes)} classes from config.")
                else:
                    logger.warning("No class names found in loaded class data.")
            else:
                logger.warning("Class configuration domain ('classes') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading classes from config: {e}.")
        return classes if classes else ["Wanderer"] # Fallback

    def _load_origins(self) -> List[Dict[str, Any]]:
        """Load origin data (id and name initially) from configuration."""
        origins_data = []
        try:
            config = get_config()
            # Assuming origins.json is loaded under the 'origins' key
            loaded_origins_dict = config.get_all("origins")
            if loaded_origins_dict and isinstance(loaded_origins_dict, dict):
                 # Store the full data for later lookup
                origins_data = list(loaded_origins_dict.values())
                # Sort by name for display
                origins_data.sort(key=lambda x: x.get('name', 'Unknown Origin'))
                logger.info(f"Loaded {len(origins_data)} origins from config.")
            else:
                logger.warning("Origin configuration domain ('origins') not found or empty.")
        except Exception as e:
            logger.error(f"Error loading origins from config: {e}.")
        return origins_data

    def scan_character_icons(self, race: str, class_name: str, sex: str):
        """
        Scan for character icons in the specific race/class directory
        and filter based on sex.
        """
        self.character_icons = [] # Clear previous icons
        self.current_icon_index = 0

        if not race or not class_name or not sex or "No " in race or "No " in class_name: # Added check for placeholder text
            logger.warning(f"Cannot scan icons: Race ('{race}'), Class ('{class_name}'), or Sex ('{sex}') not validly selected.")
            self._display_current_icon() # Display "No Icons Found" or similar
            return

        try:
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            # Construct specific directory path (e.g., images/character_icons/Human_Warrior)
            safe_race = race.replace(" ", "_")
            safe_class_name = class_name.replace(" ", "_")
            specific_icons_dir = os.path.join(project_root, "images", "character_icons", f"{safe_race}_{safe_class_name}")
            logger.debug(f"Scanning for icons in specific directory: {specific_icons_dir}")

            if not os.path.exists(specific_icons_dir):
                logger.warning(f"Icon directory not found: {specific_icons_dir}")
                self._display_current_icon() # Display "No Icons Found"
                return

            supported_extensions = [".png", ".jpg", ".jpeg", ".gif", ".svg"]

            # Scan and filter files
            for filename in os.listdir(specific_icons_dir):
                if any(filename.lower().endswith(ext) for ext in supported_extensions):
                    name_part_lower = os.path.splitext(filename)[0].lower()
                    sex_lower = sex.lower()
                    include_file = False

                    contains_male_keyword = "male" in name_part_lower
                    contains_female_keyword = "female" in name_part_lower

                    if sex_lower == "male":
                        # Include if "male" is present AND "female" is NOT present
                        if contains_male_keyword and not contains_female_keyword:
                            include_file = True
                    elif sex_lower == "female":
                        # Include if "female" is present
                        if contains_female_keyword:
                            include_file = True
                    elif sex_lower == "other":
                        # Include if either "male" or "female" is present
                        if contains_male_keyword or contains_female_keyword:
                            include_file = True
                    
                    if include_file:
                        file_path = os.path.join(specific_icons_dir, filename)
                        self.character_icons.append({
                            "filename": filename,
                            "path": file_path
                        })

            # Sort the icons by filename
            self.character_icons.sort(key=lambda x: x["filename"])

            logger.info(f"Found {len(self.character_icons)} suitable icons in {specific_icons_dir} for sex '{sex}'.")

        except OSError as e:
            logger.error(f"Error reading icons directory {specific_icons_dir}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error scanning icons: {e}", exc_info=True)

        # Display the first found icon (or "No Icons Found")
        self._display_current_icon()
    def _connect_signals(self):
        """Connect signals to slots."""
        self.player_name_edit.textChanged.connect(self._validate_form)
        self.race_combo.currentIndexChanged.connect(self._validate_form)
        self.path_combo.currentIndexChanged.connect(self._validate_form)
        self.origin_combo.currentIndexChanged.connect(self._validate_form) # Validate on origin change too
        self.origin_combo.currentIndexChanged.connect(self._on_origin_selected) # Update details on change

        self.llm_checkbox.stateChanged.connect(self._toggle_llm)
        self.prev_icon_button.clicked.connect(self._show_previous_icon)
        self.next_icon_button.clicked.connect(self._show_next_icon)

        self.cancel_button.clicked.connect(self.reject)
        self.create_button.clicked.connect(self.accept)

    def _validate_form(self):
        """Validate the form and enable/disable the create button."""
        has_name = bool(self.player_name_edit.text().strip())
        race_selected = self.race_combo.isEnabled() and self.race_combo.currentIndex() >= 0 # Check index too
        class_selected = self.path_combo.isEnabled() and self.path_combo.currentIndex() >= 0
        # Check if a valid origin (not the placeholder) is selected
        origin_selected = self.origin_combo.isEnabled() and self.origin_combo.currentIndex() > 0

        self.create_button.setEnabled(
            has_name and
            race_selected and
            class_selected and
            origin_selected
        )

    def _show_previous_icon(self):
        """Show the previous character icon."""
        # (Keep existing implementation)
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index - 1 + len(self.character_icons)) % len(self.character_icons)
        self._display_current_icon()


    def _show_next_icon(self):
        """Show the next character icon."""
        # (Keep existing implementation)
        if not self.character_icons: return
        self.current_icon_index = (self.current_icon_index + 1) % len(self.character_icons)
        self._display_current_icon()

    def _display_current_icon(self):
        """Display the current character icon."""
        # (Keep existing implementation, ensure counter updates)
        if not self.character_icons:
            self.selected_icon_path = None
            self.icon_label.setText("No Icons Found")
            self.icon_counter_label.setText("0 / 0")
            return

        icon_info = self.character_icons[self.current_icon_index]
        icon_path = icon_info['path']
        self.icon_counter_label.setText(f"{self.current_icon_index + 1} / {len(self.character_icons)}")

        try:
            pixmap = QPixmap(icon_path)
            if not pixmap.isNull():
                pixmap = pixmap.scaled(self.icon_label.width(), self.icon_label.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.icon_label.setPixmap(pixmap)
                self.selected_icon_path = icon_path
            else:
                self.icon_label.setText("Load Error")
                self.selected_icon_path = None
        except Exception as e:
            logger.error(f"Error loading icon '{icon_path}': {e}")
            self.icon_label.setText("Load Error")
            self.selected_icon_path = None

    def get_character_data(self) -> Optional[Dict[str, Any]]:
        """Get the character data from the form, including origin_id."""
        name = self.player_name_edit.text().strip()
        race = self.race_combo.currentText() if self.race_combo.isEnabled() else None
        path = self.path_combo.currentText() if self.path_combo.isEnabled() else None
        origin_id = self.origin_combo.currentData() if self.origin_combo.isEnabled() else None # Get origin ID from data

        # Basic validation
        if not name or not race or not path or origin_id is None: # Check origin_id too
             logger.error("Cannot get character data: Name, Race, Class, or Origin is missing or invalid.")
             QMessageBox.warning(self, "Missing Information", "Please select a valid Race, Class, and Origin.")
             return None

        data = {
            'name': name,
            'race': race,
            'path': path,
            'origin_id': origin_id, # Add origin ID
            'sex': self.sex_combo.currentText(),
            # Use edited description if provided, otherwise use the original intro text from selected origin
            'description': self.description_edit.toPlainText().strip() if self.description_edit.toPlainText().strip() else (self.selected_origin_data.get('introduction_text', '') if self.selected_origin_data else ''),
            'use_llm': self.llm_enabled,
            'character_image': self.selected_icon_path
        }

        return data
```

### File: gui\dialogs\save_game_dialog.py

```python
#!/usr/bin/env python3
"""
Save game dialog for the RPG game GUI.
This module provides a dialog for saving the game.
"""

import logging
import os
from typing import Optional, List

from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QPushButton, QGroupBox, QListWidget, QListWidgetItem
)
from PySide6.QtCore import Qt, Signal, Slot

class SaveGameDialog(QDialog):
    """Dialog for saving the game."""
    
    def __init__(self, parent=None):
        """Initialize the save game dialog."""
        super().__init__(parent)
        
        # Set window properties
        self.setWindowTitle("Save Game")
        self.setMinimumWidth(400)
        self.setMinimumHeight(300)
        self.setStyleSheet("""
            QDialog {
                background-color: #2D2D30;
                color: #E0E0E0;
            }
            QLabel {
                color: #E0E0E0;
            }
            QLineEdit {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                padding: 5px;
            }
            QLineEdit:focus {
                border-color: #0E639C;
            }
            QPushButton {
                background-color: #0E639C;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1177BB;
            }
            QPushButton:pressed {
                background-color: #0A4C7C;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #AAAAAA;
            }
            QGroupBox {
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 15px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top center;
                padding-left: 10px;
                padding-right: 10px;
                color: #E0E0E0;
            }
            QListWidget {
                background-color: #1E1E1E;
                color: #E0E0E0;
                border: 1px solid #3F3F46;
                border-radius: 4px;
                alternate-background-color: #383838;
            }
            QListWidget::item {
                padding: 5px;
                border-bottom: 1px solid #444444;
            }
            QListWidget::item:selected {
                background-color: #0E639C;
            }
            QListWidget::item:hover {
                background-color: #383838;
            }
        """)
        
        # Set up the UI
        self._setup_ui()
        
        # Connect signals
        self._connect_signals()
    
    def _setup_ui(self):
        """Set up the user interface."""
        # Create the main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)
        
        # Create save name input section
        name_layout = QVBoxLayout()
        
        # Create save name label
        name_label = QLabel("Save Name:")
        
        # Create save name edit
        self.save_name_edit = QLineEdit()
        self.save_name_edit.setPlaceholderText("Enter a name for this save...")
        
        # Add widgets to name layout
        name_layout.addWidget(name_label)
        name_layout.addWidget(self.save_name_edit)
        
        # Add name layout to main layout
        main_layout.addLayout(name_layout)
        
        # Create existing saves group
        existing_group = QGroupBox("Existing Saves")
        existing_layout = QVBoxLayout(existing_group)
        existing_layout.setContentsMargins(10, 20, 10, 10)
        
        # Create existing saves list
        self.saves_list = QListWidget()
        self.saves_list.setAlternatingRowColors(True)
        
        # Add saves list to existing layout
        existing_layout.addWidget(self.saves_list)
        
        # Add existing group to main layout
        main_layout.addWidget(existing_group)
        
        # Create the dialog buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(0, 10, 0, 0)
        
        # Create cancel button
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        
        # Create save button
        self.save_button = QPushButton("Save Game")
        self.save_button.setEnabled(False)  # Disable until name is entered
        self.save_button.clicked.connect(self.accept)
        
        # Add buttons to layout
        button_layout.addWidget(self.cancel_button)
        button_layout.addStretch()
        button_layout.addWidget(self.save_button)
        
        # Add button layout to main layout
        main_layout.addLayout(button_layout)
        
        # Load existing saves
        self._load_existing_saves()
    
    def _connect_signals(self):
        """Connect signals to slots."""
        # Enable/disable save button based on name field
        self.save_name_edit.textChanged.connect(self._validate_form)
        
        # Update name field when an existing save is selected
        self.saves_list.itemClicked.connect(self._on_save_selected)
    
    def _validate_form(self):
        """Validate the form and enable/disable the save button."""
        # Check if name is not empty
        has_name = bool(self.save_name_edit.text().strip())
        
        # Enable/disable save button
        self.save_button.setEnabled(has_name)
    
    def _load_existing_saves(self):
        """Load existing saves into the list."""
        # Clear the list
        self.saves_list.clear()
        
        # Get the saves directory
        saves_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "saves")
        
        # Check if the directory exists
        if not os.path.exists(saves_dir):
            return
        
        # Get all save files
        save_files = [f for f in os.listdir(saves_dir) if f.endswith(".json")]
        
        # Sort by modification time (newest first)
        save_files.sort(key=lambda x: os.path.getmtime(os.path.join(saves_dir, x)), reverse=True)
        
        # Add to list
        for save_file in save_files:
            # Get the save name without extension
            save_name = os.path.splitext(save_file)[0]
            
            # Create and add the item
            item = QListWidgetItem(save_name)
            self.saves_list.addItem(item)
    
    def _on_save_selected(self, item):
        """Handle save selection."""
        # Set the save name edit to the selected save
        self.save_name_edit.setText(item.text())

```

### File: gui\utils\__init__.py

```python
"""Utils package for the GUI module."""

```

### File: gui\utils\init_settings.py

```python
#!/usr/bin/env python3
"""
Initialize application settings with default values if they don't exist.
"""

import logging
from PySide6.QtCore import QSettings

def init_default_settings():
    """Initialize default settings if they don't exist."""

    settings = QSettings("RPGGame", "Settings")

    # Check if style settings exist and create defaults if not
    if not settings.contains("style/output_bg_color"):
        settings.setValue("style/output_bg_color", "#D2B48C")  # Light brown

    if not settings.contains("style/system_msg_color"):
        settings.setValue("style/system_msg_color", "#FF0000")  # Red

    if not settings.contains("style/font_family"):
        settings.setValue("style/font_family", "Garamond")

    if not settings.contains("style/font_size"):
        settings.setValue("style/font_size", 14)

    if not settings.contains("style/font_color"):
        settings.setValue("style/font_color", "#000000")  # Black

    # Initialize texture and transparency settings
    if not settings.contains("style/texture_name"):
        settings.setValue("style/texture_name", "subtle_noise")

    if not settings.contains("style/output_opacity"):
        settings.setValue("style/output_opacity", 100)

    if not settings.contains("style/input_opacity"):
        settings.setValue("style/input_opacity", 100)

    # Initialize display settings if they don't exist
    if not settings.contains("display/resolution"):
        settings.setValue("display/resolution", (1280, 720))

    if not settings.contains("display/mode"):
        settings.setValue("display/mode", "windowed")

    if not settings.contains("display/ui_scale"):
        settings.setValue("display/ui_scale", 1.0)
    # Initialize text speed setting
    if not settings.contains("display/text_speed_delay"):
        settings.setValue("display/text_speed_delay", 30) # Default delay in ms per character

    # Initialize sound settings if they don't exist
    if not settings.contains("sound/master_volume"):
        settings.setValue("sound/master_volume", 100)

    if not settings.contains("sound/music_volume"):
        settings.setValue("sound/music_volume", 100)

    if not settings.contains("sound/effects_volume"):
        settings.setValue("sound/effects_volume", 100)

    if not settings.contains("sound/enabled"):
        settings.setValue("sound/enabled", True)

    # Initialize gameplay settings if they don't exist
    if not settings.contains("gameplay/difficulty"):
        settings.setValue("gameplay/difficulty", "Normal")
    if not settings.contains("gameplay/encounter_size"):
        settings.setValue("gameplay/encounter_size", "Solo")

    if not settings.contains("gameplay/autosave_interval"):
        settings.setValue("gameplay/autosave_interval", 0)

    if not settings.contains("gameplay/tutorial_enabled"):
        settings.setValue("gameplay/tutorial_enabled", True)

    # Sync settings to disk
    settings.sync()

    logging.info("Default settings initialized")

```

### File: gui\utils\resource_manager.py

```python
#!/usr/bin/env python3
"""
Resource manager for the RPG game GUI.
This module provides a centralized system for loading and managing GUI resources.
"""

import os
import logging
from typing import Dict, Optional, List, Tuple

from PySide6.QtGui import QPixmap, QIcon, QMovie # Added QMovie
from PySide6.QtCore import QSize, QByteArray # Added QByteArray for QMovie

class ResourceManager:
    """Manages the loading and caching of GUI resources."""
    
    _instance = None
    
    def __new__(cls):
        """Singleton pattern implementation."""
        if cls._instance is None:
            cls._instance = super(ResourceManager, cls).__new__(cls)
            cls._instance._initialize()
        return cls._instance
    
    def _initialize(self):
        """Initialize the resource manager."""
        # Cache for loaded resources
        self._pixmap_cache: Dict[str, QPixmap] = {}
        self._icon_cache: Dict[str, QIcon] = {}
        self._movie_cache: Dict[str, QMovie] = {} # Added movie cache

        # Base paths
        self.gui_path = os.path.join("images", "gui")
        self.background_path = os.path.join(self.gui_path, "background") # --- ADDED ---
        
    def get_pixmap(self, name: str, default_size: Optional[QSize] = None) -> QPixmap:
        """
        Get a pixmap resource.
        
        Args:
            name: The resource name (without path or extension)
            default_size: Optional default size for the pixmap
            
        Returns:
            The loaded pixmap
        """
        # Check cache first
        if name in self._pixmap_cache:
            pixmap = self._pixmap_cache[name]
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
            return pixmap
        
        # Try to load the resource
        full_path = os.path.join(self.gui_path, f"{name}.png")
        
        try:
            pixmap = QPixmap(full_path)
            
            if pixmap.isNull():
                logging.warning(f"Failed to load pixmap: {full_path}")
                # Return an empty pixmap
                pixmap = QPixmap()
            else:
                # Cache the resource
                self._pixmap_cache[name] = pixmap
                
            # Scale if needed
            if default_size and not pixmap.isNull():
                pixmap = pixmap.scaled(default_size)
                
            return pixmap
            
        except Exception as e:
            logging.error(f"Error loading pixmap {full_path}: {e}")
            return QPixmap()
    
    def get_icon(self, name: str) -> QIcon:
        """
        Get an icon resource.
        
        Args:
            name: The resource name (without path or extension)
            
        Returns:
            The loaded icon
        """
        # Check cache first
        if name in self._icon_cache:
            return self._icon_cache[name]
        
        # Try to load the resource
        try:
            # For button states, check for specific state images
            states = {
                "normal": f"{name}.png",
                "hover": f"{name}_hover.png",
                "pressed": f"{name}_pressed.png",
                "disabled": f"{name}_disabled.png"
            }
            
            # Create icon
            icon = QIcon()
            
            # Add states if they exist
            for state_name, filename in states.items():
                full_path = os.path.join(self.gui_path, filename)
                if os.path.exists(full_path):
                    pixmap = QPixmap(full_path)
                    if not pixmap.isNull():
                        if state_name == "normal":
                            icon.addPixmap(pixmap, QIcon.Normal, QIcon.Off)
                        elif state_name == "hover":
                            icon.addPixmap(pixmap, QIcon.Active, QIcon.Off)
                        elif state_name == "pressed":
                            icon.addPixmap(pixmap, QIcon.Selected, QIcon.Off)
                        elif state_name == "disabled":
                            icon.addPixmap(pixmap, QIcon.Disabled, QIcon.Off)
            
            # If no states were added, try to add the base name
            if icon.isNull():
                pixmap = self.get_pixmap(name)
                if not pixmap.isNull():
                    icon.addPixmap(pixmap)
            
            # Cache the icon
            self._icon_cache[name] = icon
            
            return icon
            
        except Exception as e:
            logging.error(f"Error loading icon {name}: {e}")
            return QIcon()
    

    def list_background_names(self) -> List[Tuple[str, str]]:
        """List available background image/animation names and their extensions."""
        backgrounds = []
        if not os.path.isdir(self.background_path):
            logging.warning(f"Background directory not found: {self.background_path}")
            return backgrounds
        try:
            for filename in os.listdir(self.background_path):
                name, ext = os.path.splitext(filename)
                ext_lower = ext.lower()
                if ext_lower in [".png", ".gif"]:
                    backgrounds.append((name, ext)) # Store name and extension
        except Exception as e:
            logging.error(f"Error listing backgrounds in {self.background_path}: {e}")
        return sorted(backgrounds, key=lambda x: x[0]) # Sort by name

    def get_background_pixmap(self, name: str) -> QPixmap:
        """
        Get a pixmap resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded pixmap
        """
        cache_key = f"background_{name}"
        # Check cache first
        if cache_key in self._pixmap_cache:
            return self._pixmap_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.png")

        try:
            pixmap = QPixmap(full_path)

            if pixmap.isNull():
                logging.warning(f"Failed to load background pixmap: {full_path}")
                pixmap = QPixmap() # Return an empty pixmap
            else:
                # Cache the resource
                self._pixmap_cache[cache_key] = pixmap

            return pixmap

        except Exception as e:
            logging.error(f"Error loading background pixmap {full_path}: {e}")
            return QPixmap()

    def get_background_movie(self, name: str) -> QMovie:
        """
        Get a QMovie resource specifically from the background directory.

        Args:
            name: The resource name (without path or extension)

        Returns:
            The loaded QMovie
        """
        cache_key = f"background_movie_{name}"
        # Check cache first
        if cache_key in self._movie_cache:
            # Return a new QMovie instance pointing to the same data if needed,
            # but for simplicity, let's assume sharing the instance is okay for now.
            # If issues arise, create new QMovie(self._movie_cache[cache_key].fileName())
            return self._movie_cache[cache_key]

        # Try to load the resource
        full_path = os.path.join(self.background_path, f"{name}.gif")

        try:
            # QMovie needs the path, not raw data like QPixmap sometimes uses
            movie = QMovie(full_path)

            if not movie.isValid():
                logging.warning(f"Failed to load or invalid background movie: {full_path}")
                # Return an empty/invalid movie
                return QMovie()
            else:
                # Cache the resource
                self._movie_cache[cache_key] = movie
                return movie

        except Exception as e:
            logging.error(f"Error loading background movie {full_path}: {e}")
            return QMovie()

    def clear_cache(self):
        """Clear the resource cache."""
        self._pixmap_cache.clear()
        self._icon_cache.clear()
        self._movie_cache.clear() # Clear movie cache

# Global instance for easy access
def get_resource_manager() -> ResourceManager:
    """Get the singleton resource manager instance."""
    return ResourceManager()

```

### File: gui\main_window.py

```python
#!/usr/bin/env python3
"""
Main window for the RPG game GUI.
This module provides the MainWindow class that serves as the primary GUI container.
"""

import logging
import os
import weakref
from typing import Optional, List, Dict, Any, Tuple
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
    QStackedWidget, QDialog, QLabel, QPushButton, 
    QTextEdit, QScrollArea, QGraphicsOpacityEffect, QMessageBox, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, Slot, QTimer, QSize, QSettings, QObject, QThread, Signal, QParallelAnimationGroup, QPropertyAnimation, QEasingCurve
from PySide6.QtGui import QIcon, QPixmap, QPalette, QBrush, QColor, QMovie, QTextCursor # Added QTextCursor
from core.inventory import get_inventory_manager
from core.inventory.item import Item
from core.inventory.item_enums import EquipmentSlot
from gui.dialogs.game_over_dialog import GameOverDialog
from core.base.engine import GameEngine, get_game_engine
from core.combat.enums import CombatState, CombatStep
from core.interaction.enums import InteractionMode # Added import
from core.base.state import GameState, get_state_manager # Added imports
from core.utils.logging_config import get_logger
from gui.components.game_output import GameOutputWidget
from gui.components.command_input import CommandInputWidget
from gui.components.menu_panel import MenuPanelWidget
from gui.components.right_panel import CollapsibleRightPanel
from gui.components.status_bar import GameStatusBar
from gui.components.combat_display import CombatDisplay # Added import
from gui.utils.resource_manager import get_resource_manager
from gui.dialogs.settings.llm_settings_dialog import LLMSettingsDialog

logger = get_logger("GUI")

class MainWindow(QMainWindow):
    """Main window for the RPG game GUI."""
    
    def __init__(self):
            super().__init__()
            
            self._previous_mode = None # Track previous mode for transitions
            
            # Get resource manager
            self.resource_manager = get_resource_manager()
            
            # Get game engine
            self.game_engine = get_game_engine()

            # Register this MainWindow with the engine so orchestrator/engine can nudge UI updates
            try:
                self.game_engine.main_window_ref = weakref.ref(self)
            except Exception:
                pass

            # Set minimum size based on reasonable content size hint
            self.setMinimumSize(1024, 700) # Set a sensible minimum size

            # Store character data temporarily during animation
            self._character_data_for_new_game: Optional[Dict[str, Any]] = None

            # Set up the UI
            self._setup_ui()
            
            # Connect signals and slots
            self._connect_signals()
            
            # Apply initial styling
            self._update_styling()

            self._last_submitted_command = None

    def _apply_initial_window_state(self):
        """Apply saved window state and geometry when the window is first shown."""
        settings = QSettings("RPGGame", "Settings")
        window_state = settings.value("display/window_state", "windowed") # Default to windowed
        
        logger.info(f"Applying initial window state: {window_state}")

        if window_state == "fullscreen":
            self.showFullScreen()
        elif window_state == "maximized":
            self.showMaximized()
        else: # windowed
            # Load saved windowed size or default
            default_size = QSize(1280, 720)
            windowed_size = settings.value("display/windowed_size", default_size)
            # Ensure windowed_size is a QSize object
            if not isinstance(windowed_size, QSize):
                # Attempt conversion if it's a tuple/list or handle potential string format
                if isinstance(windowed_size, (tuple, list)) and len(windowed_size) == 2:
                    windowed_size = QSize(windowed_size[0], windowed_size[1])
                elif isinstance(windowed_size, str):
                     try:
                         parts = windowed_size.strip('()').split(',')
                         windowed_size = QSize(int(parts[0]), int(parts[1]))
                     except Exception:
                         windowed_size = default_size # Fallback on parse error
                else:
                    windowed_size = default_size # Fallback if type is unexpected

            self.showNormal() # Ensure not maximized/fullscreen first
            self.resize(windowed_size) # Apply the loaded/default size
            # Optional: Center the window
            screen_geometry = self.screen().availableGeometry()
            self.move(screen_geometry.center() - self.rect().center())        

    def showEvent(self, event):
        """Override showEvent to apply initial window state after the window is shown."""
        super().showEvent(event)
        # Apply the state only once when the window is first shown
        if not hasattr(self, '_initial_state_applied') or not self._initial_state_applied:
             self._apply_initial_window_state()
             self._initial_state_applied = True

    def closeEvent(self, event):
        """Handle window close event, saving window state."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # --- Save Window State ---
            settings = QSettings("RPGGame", "Settings")
            current_state_str = "windowed" # Default
            if self.isFullScreen():
                current_state_str = "fullscreen"
            elif self.isMaximized():
                current_state_str = "maximized"
            
            settings.setValue("display/window_state", current_state_str)
            
            # Save the *current* size only if the state is 'windowed'
            if current_state_str == "windowed":
                 settings.setValue("display/windowed_size", self.size())
            logger.info(f"Saved window state ({current_state_str}) and size ({self.size() if current_state_str == 'windowed' else 'N/A'}) on exit.")
            # --- End Save Window State ---

            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def _apply_saved_resolution(self):
        """Apply saved resolution from settings."""
        settings = QSettings("RPGGame", "Settings")
        resolution = settings.value("display/resolution", (1280, 720))
        
        # Convert to tuple if it's a string (can happen with some QSettings implementations)
        if isinstance(resolution, str):
            try:
                # Handle string format like "(1280, 720)"
                if resolution.startswith("(") and resolution.endswith(")"):
                    parts = resolution.strip("()").split(",")
                    resolution = (int(parts[0].strip()), int(parts[1].strip()))
            except:
                # Fallback to default if parsing fails
                resolution = (1280, 720)
                logging.warning("Failed to parse resolution setting, using default")
        
        # Set window size
        self.setFixedSize(*resolution)
        logging.info(f"Applied saved resolution: {resolution}")
    
    def _setup_ui(self):
        """Set up the user interface."""
        self.setWindowTitle("RPG Game")
        
        self.background_container = QWidget()
        self.setCentralWidget(self.background_container)
        self.background_container.setStyleSheet("background-color: transparent;")

        self.background_label = QLabel(self.background_container)
        self.background_label.setGeometry(0, 0, self.width(), self.height()) 
        self.background_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.background_label.setScaledContents(True) 

        self.main_content_widget = QWidget(self.background_container)
        self.main_content_widget.setGeometry(0, 0, self.width(), self.height()) 
        self.main_content_widget.setStyleSheet("background-color: transparent;") 

        self.main_layout = QVBoxLayout(self.main_content_widget)
        self.main_layout.setContentsMargins(10, 10, 10, 10) 
        self.main_layout.setSpacing(5)
        
        self.mode_stacked_widget = QStackedWidget()
        
        self.narrative_view = QWidget()
        self.narrative_layout = QVBoxLayout(self.narrative_view)
        self.narrative_layout.setContentsMargins(0, 0, 0, 0)
        self.narrative_layout.setSpacing(0)
        
        self.combat_view = QWidget()
        self.combat_layout = QVBoxLayout(self.combat_view)
        self.combat_layout.setContentsMargins(0, 0, 0, 0)
        self.combat_layout.setSpacing(0)
        
        title_pixmap = self.resource_manager.get_pixmap("title_banner")
        if not title_pixmap.isNull():
            self.title_label = QLabel()
            target_height = 100
            scaled_pixmap = title_pixmap.scaled(
                QSize(1000, target_height), 
                Qt.KeepAspectRatio,         
                Qt.SmoothTransformation     
            )
            self.title_label.setPixmap(scaled_pixmap)
            self.title_label.setAlignment(Qt.AlignCenter)
            self.title_label.setContentsMargins(0, 0, 0, 5)
            self.main_layout.addWidget(self.title_label)
        
        self.content_layout = QHBoxLayout()
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.setSpacing(10)
        
        self.menu_panel = MenuPanelWidget()
        
        self.game_output = GameOutputWidget()
        if hasattr(self.game_output, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.game_output.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected GameOutputWidget.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect GameOutputWidget.visualDisplayComplete: Attribute or slot missing.")
        self.narrative_layout.addWidget(self.game_output, 1)
        
        self.narrative_command_input = CommandInputWidget()
        self.narrative_layout.addWidget(self.narrative_command_input, 0)
        
        self.combat_display = CombatDisplay()
        if hasattr(self.combat_display, 'visualDisplayComplete') and hasattr(self.game_engine._combat_orchestrator, '_handle_visual_display_complete'):
            self.combat_display.visualDisplayComplete.connect(self.game_engine._combat_orchestrator._handle_visual_display_complete)
            logger.info("Connected CombatDisplay.visualDisplayComplete to Orchestrator.")
        else:
            logger.error("Failed to connect CombatDisplay.visualDisplayComplete: Attribute or slot missing.")
        self.combat_layout.addWidget(self.combat_display, 1)
        
        self.combat_command_input = CommandInputWidget()
        self.combat_layout.addWidget(self.combat_command_input, 0)
        
        self.mode_stacked_widget.addWidget(self.narrative_view)
        self.mode_stacked_widget.addWidget(self.combat_view)
        
        self.center_widget = QWidget()
        center_layout = QVBoxLayout(self.center_widget)
        center_layout.setContentsMargins(0, 0, 0, 0)
        center_layout.addWidget(self.mode_stacked_widget)
        
        self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
        
        self.right_panel = CollapsibleRightPanel()
        
        self.content_layout.addWidget(self.menu_panel, 0) # Stretch factor 0 for menu_panel
        self.content_layout.addWidget(self.center_widget, 1) # Stretch factor 1 for center_widget
        self.content_layout.addWidget(self.right_panel, 0) # Stretch factor 0 for right_panel
        
        self.main_layout.addLayout(self.content_layout, 1)
        
        self.music_controls = self._create_music_controls()
        
        self.status_bar = GameStatusBar()
        self.setStatusBar(self.status_bar)

        self._load_and_apply_initial_background()

        self._initialize_panel_effects() 
        
        # Initial state: center, right, and status bar are part of the layout but fully transparent and disabled.
        # setVisible(True) is important for them to be considered by the layout manager from the start.
        self.center_widget.setVisible(True) 
        self.center_widget.setEnabled(False)
        if hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False)
        if hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect.setOpacity(0.0)
            
        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False)
        if hasattr(self, 'status_bar_opacity_effect'):
             self.status_bar_opacity_effect.setOpacity(0.0)

    def _create_music_controls(self):
        """Create music control widgets."""
        # Create a widget for the music controls
        music_widget = QWidget()
        music_layout = QHBoxLayout(music_widget)
        music_layout.setContentsMargins(0, 0, 0, 0)
        music_layout.setSpacing(5)
        
        # Create music control buttons
        play_pause_button = QPushButton()
        play_pause_button.setIcon(self.resource_manager.get_icon("music_play"))
        play_pause_button.setIconSize(QSize(24, 24))
        play_pause_button.setFixedSize(32, 32)
        play_pause_button.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 16px;
            }
            QPushButton:pressed {
                background-color: rgba(255, 255, 255, 0.2);
            }
        """)
        
        next_button = QPushButton()
        next_button.setIcon(self.resource_manager.get_icon("music_next"))
        next_button.setIconSize(QSize(24, 24))
        next_button.setFixedSize(32, 32)
        next_button.setStyleSheet(play_pause_button.styleSheet())
        
        volume_button = QPushButton()
        volume_button.setIcon(self.resource_manager.get_icon("music_volume"))
        volume_button.setIconSize(QSize(24, 24))
        volume_button.setFixedSize(32, 32)
        volume_button.setStyleSheet(play_pause_button.styleSheet())
        
        # Add buttons to layout
        music_layout.addWidget(play_pause_button)
        music_layout.addWidget(next_button)
        music_layout.addWidget(volume_button)
        
        # Add music controls to the top-right corner
        self.main_layout.insertWidget(0, music_widget, 0, Qt.AlignRight)
        
        # Return the widget for reference
        return music_widget
    
    def _connect_signals(self):
        """Connect signals and slots."""
        self.narrative_command_input.command_submitted.connect(self._process_command)
        self.combat_command_input.command_submitted.connect(self._process_command)

        logger.info("Connecting GameEngine.orchestrated_event_to_ui signal to MainWindow.process_orchestrated_display_event")
        try:
            self.game_engine.orchestrated_event_to_ui.connect(self.process_orchestrated_display_event)
            logger.info("Successfully connected orchestrated_event_to_ui signal")
        except Exception as e:
            logger.error(f"Failed to connect orchestrated_event_to_ui signal: {e}")
        
        logger.info("Connecting game engine output_generated signal to _handle_game_output (for non-orchestrated events)")
        try:
            self.game_engine.output_generated.connect(self._handle_game_output)
            logger.info("Successfully connected engine.output_generated signal")
        except Exception as e:
            logger.error(f"Failed to connect output_generated signal: {e}")

        self.menu_panel.new_game_requested.connect(self._show_new_game_dialog)
        self.menu_panel.save_game_requested.connect(self._show_save_game_dialog)
        self.menu_panel.load_game_requested.connect(self._show_load_game_dialog)
        self.menu_panel.settings_requested.connect(self._show_settings_dialog)
        self.menu_panel.llm_settings_requested.connect(self._show_llm_settings_dialog)
        self.menu_panel.exit_requested.connect(self.close)

        self.right_panel.tab_changed.connect(self._handle_tab_change)

        if hasattr(self.right_panel, 'inventory_panel'):
            self.right_panel.inventory_panel.item_use_requested.connect(self._handle_item_use_requested)
            self.right_panel.inventory_panel.item_examine_requested.connect(self._handle_item_examine_requested)
            self.right_panel.inventory_panel.item_equip_requested.connect(self._handle_item_equip_requested)
            self.right_panel.inventory_panel.item_unequip_requested.connect(self._handle_item_unequip_requested)
            self.right_panel.inventory_panel.item_drop_requested.connect(self._handle_item_drop_requested)
            logger.info("[GUI] MainWindow: Connected signals from InventoryPanelWidget (via right_panel).")
        else:
            logger.error("[GUI] MainWindow: CRITICAL - self.right_panel.inventory_panel not found during signal connection.")

        # Connect signals from CharacterSheetWidget (via right_panel)
        if hasattr(self.right_panel, 'character_sheet'):
            self.right_panel.character_sheet.item_unequip_from_slot_requested.connect(self._handle_item_unequip_from_slot_requested)
            self.right_panel.character_sheet.item_examine_requested.connect(self._handle_item_examine_requested) # Can reuse the same handler
            self.right_panel.character_sheet.item_drop_from_slot_requested.connect(self._handle_item_drop_from_slot_requested)
            logger.info("[GUI] MainWindow: Connected signals from CharacterSheetWidget (via right_panel).")
        else:
            logger.error("[GUI] MainWindow: CRITICAL - self.right_panel.character_sheet not found for signal connection.")


        if self.game_engine.state_manager.stats_manager:
            try:
                self.game_engine.state_manager.stats_manager.stats_changed.disconnect(self._handle_stats_update)
            except (TypeError, RuntimeError): pass 
            self.game_engine.state_manager.stats_manager.stats_changed.connect(self._handle_stats_update)
            logger.info("Connected StatsManager stats_changed signal to MainWindow handler.")
        else:
            logger.warning("StatsManager not available at signal connection time in MainWindow.")
        
        if hasattr(self.game_engine._combat_orchestrator, 'resume_combat_manager') and hasattr(self.game_engine, 'on_orchestrator_idle_and_combat_manager_resumed'):
             self.game_engine._combat_orchestrator.resume_combat_manager.connect(self.game_engine.on_orchestrator_idle_and_combat_manager_resumed)
             logger.info("Connected orchestrator's resume_combat_manager to engine's handler for post-closing-narrative.")
        else:
             logger.error("Could not connect orchestrator's resume signal to engine.")
             
    @Slot(dict)
    def _handle_stats_update(self, stats_data: dict):
        """Handle updates received directly from StatsManager."""
        logger.debug("Received stats update signal in MainWindow")
        state = self.game_engine.state_manager.current_state
        if state:
            # Update Character Sheet (Right Panel)
            # This ensures character sheet gets all data including combat status
            if self.right_panel and hasattr(self.right_panel, 'update_character'):
                self.right_panel.update_character(state.player) # Pass player state for full context
                logger.debug("Updated CharacterSheet (RightPanel) from stats signal.")

            # Update Combat Display if in Combat Mode
            if state.current_mode == InteractionMode.COMBAT:
                logger.debug("Updating CombatDisplay from stats signal")
                self.combat_display.update_display(state) 
            
            # Any other UI elements that need to react to general stats changes can be updated here.

    def _setup_stats_refresh(self):
        """Set up player command tracking and direct signal connections instead of timer-based refresh."""
        # Store the last command submitted by the player to prevent echo
        self._last_submitted_command: Optional[str] = None
        
        # We don't need timer-based stats refresh anymore since we'll use direct signal connections
    
    # The _refresh_stats method is removed since we're using direct signal connections now
    
    def _handle_tab_change(self, index):
        """Handle tab change event."""
        # Update the active tab content
        if index == 0:  # Character tab
            self.right_panel.update_character()
        elif index == 1:  # Inventory tab
            if self.game_engine.state_manager.current_state:
                # Get inventory manager instance
                from core.inventory import get_inventory_manager
                inventory_manager = get_inventory_manager()
                
                if inventory_manager:
                    self.right_panel.update_inventory(inventory_manager)
                else:
                    logger.warning("No inventory manager available")
        elif index == 2:  # Journal tab
            if self.game_engine.state_manager.current_state:
                # Check if journal data exists, create it if not
                if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                    self.game_engine.state_manager.current_state.journal = {
                        "character": "",
                        "quests": {},
                        "notes": []
                    }
                
                self.right_panel.update_journal(
                    self.game_engine.state_manager.current_state.journal
                )
    
    # Define a worker for running commands in a separate thread
    class CommandWorker(QObject):
        finished = Signal()
        error = Signal(str)
        processing = Signal(bool)  # Signal to show/hide processing indicator
        
        def __init__(self, game_engine, command):
            super().__init__()
            self.game_engine = game_engine
            self.command = command
        
        def run(self):
            try:
                self.processing.emit(True)
                # Process input in the worker thread using the new InputRouter-based approach
                command_result = self.game_engine.process_input(self.command) # Original call
                
                # NEW: Process commands returned by LLM
                if command_result.data and "commands" in command_result.data:
                    llm_commands: List[Tuple[str, str]] = command_result.data["commands"]
                    if llm_commands:
                        logger.info(f"CommandWorker: Processing {len(llm_commands)} commands from LLM response: {llm_commands}")
                        # Ensure current_state is available
                        current_game_state = self.game_engine._state_manager.current_state
                        if not current_game_state:
                            logger.error("CommandWorker: Cannot process LLM commands, current_game_state is None.")
                        else:
                            for cmd, args_str in llm_commands:
                                try:
                                    # We need to call the central LLM command processor
                                    # command_handlers.process_llm_command takes (engine, command, args_list, game_state)
                                    # The args_str from the tuple is a single string, so wrap it in a list.
                                    logger.debug(f"CommandWorker: Executing LLM command '{cmd}' with args '{args_str}'")
                                    # Import locally if not already available or pass engine components if needed
                                    from core.game_flow.command_handlers import process_llm_command
                                    
                                    # process_llm_command itself might call engine._output, which triggers _update_ui.
                                    # This is fine, as _update_ui will reflect the state *after* each command.
                                    cmd_exec_result = process_llm_command(self.game_engine, cmd, [args_str], current_game_state)
                                    logger.info(f"CommandWorker: LLM command '{cmd}' execution result: {cmd_exec_result.message if cmd_exec_result else 'No result'}")
                                    if cmd_exec_result and not cmd_exec_result.is_success and cmd_exec_result.message:
                                        # If an LLM command itself fails, output its error message
                                        self.game_engine._output("system", f"Error processing internal command '{cmd}': {cmd_exec_result.message}")

                                except Exception as e_cmd:
                                    logger.error(f"CommandWorker: Error processing extracted LLM command '{cmd}': {e_cmd}", exc_info=True)
                                    self.game_engine._output("system", f"System error processing internal command '{cmd}'.")
                
                self.finished.emit()
            except Exception as e:
                logging.error(f"Error processing input: {e}", exc_info=True)
                self.error.emit(str(e))
            finally:
                self.processing.emit(False)
                
    def _process_command(self, command: str):
        """Process a command using the game engine in a separate thread."""
        if not command.strip():
            return
        
        # --- ECFA Change: Check if waiting for closing narrative ---
        if self.game_engine._waiting_for_closing_narrative_display:
            self.game_output.append_system_message("Please wait, concluding previous actions...", gradual=False)
            # Re-enable input field as this input is being ignored.
            if self.mode_stacked_widget.currentWidget() == self.narrative_view:
                self.narrative_command_input.setEnabled(True)
                self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            else:
                self.combat_command_input.setEnabled(True)
                self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            return
        # --- End ECFA Change ---

        # Check if this command is UI-generated and should not be echoed as player input
        is_ui_generated_command = False
        try:
            parts = command.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in ["examine", "equip", "unequip", "drop", "use"]:
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10: # Basic UUID-like check
                    is_ui_generated_command = True
        except Exception:
            pass

        # Echo player input only in narrative mode; suppress in combat mode
        try:
            state = self.game_engine.state_manager.current_state
            if not is_ui_generated_command and (not state or state.current_mode != InteractionMode.COMBAT):
                self.game_output.append_player_message(command)
            else:
                logger.info("Suppressing player echo in GameOutputWidget (combat mode or UI-generated command).")
        except Exception:
            if not is_ui_generated_command:
                self.game_output.append_player_message(command)
            
        self._last_submitted_command = command # Still store it to prevent potential echoes from engine if it's re-output
        
        active_command_input = self.narrative_command_input if self.mode_stacked_widget.currentWidget() == self.narrative_view else self.combat_command_input
        active_command_input.clear()
        active_command_input.setEnabled(False)
        active_command_input.command_edit.setPlaceholderText("Processing...")
        
        self.status_bar.showMessage("Processing command...", 0)
        
        self.worker_thread = QThread()
        self.worker = self.CommandWorker(self.game_engine, command)
        self.worker.moveToThread(self.worker_thread)
        
        self.worker_thread.started.connect(self.worker.run)
        self.worker.finished.connect(self._on_command_processed)
        self.worker.error.connect(self._on_command_error)
        self.worker.processing.connect(self._set_processing_state) 
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker_thread.finished.connect(self.worker_thread.deleteLater)
        
        self.worker_thread.start()

    def _on_command_processed(self):
        """Handle completion of command processing."""
        # Update UI components
        self._update_ui()
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
    
    def _on_command_error(self, error_msg):
        """Handle error in command processing."""
        self.game_output.append_system_message(f"Error: {error_msg}")
        self.status_bar.clearMessage()
        self.narrative_command_input.setEnabled(True)
        self.combat_command_input.setEnabled(True)
        self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
        self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")

    def _complete_if_same_event(self, event_id: str) -> None:
        """If the orchestrator is still waiting on this exact event, complete it.
        This guards against UI paths that failed to emit completion and prevents stalls.
        """
        try:
            orch = getattr(self.game_engine, '_combat_orchestrator', None)
            if orch is None:
                return
            # Only complete if we are still on the same event and waiting for visual
            if getattr(orch, 'is_processing_event', False) and getattr(orch, 'is_waiting_for_visual', False):
                current_id = getattr(orch, 'current_event_id_for_signals', None)
                if current_id == event_id:
                    logger.warning(f"Safety net: Completing UI_BAR_UPDATE event {event_id} to avoid stall.")
                    try:
                        orch._handle_visual_display_complete()
                    except Exception:
                        pass
        except Exception as e:
            logger.debug(f"_complete_if_same_event guard failed: {e}")
    
    def _set_processing_state(self, is_processing):
        """Update UI to show processing state."""
        if is_processing:
            self.status_bar.showMessage("Processing command...")
            self.narrative_command_input.command_edit.setPlaceholderText("Processing...")
            self.combat_command_input.command_edit.setPlaceholderText("Processing...")
        else:
            self.status_bar.clearMessage()
            self.narrative_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.combat_command_input.command_edit.setPlaceholderText("Enter command or type 'help'...")
            self.narrative_command_input.setEnabled(True)
            self.combat_command_input.setEnabled(True)
    
    def _handle_game_output(self, role: str, content: str):
        """
        Handle non-orchestrated output from the game engine.
        Orchestrated events are handled by `process_orchestrated_display_event`.
        This method is now for general system messages or direct player echoes
        that are NOT part of the CombatOutputOrchestrator's flow.
        """
        logger.info(f"[LEGACY_OUTPUT] Received: role='{role}', content='{content[:200]}...'")
        
        # Special logging for reintroductory narrative debugging
        if role == "gm" and ("night air" in content.lower() or "find yourself" in content.lower()):
            logger.info(f"LIFECYCLE_DEBUG: _handle_game_output - This appears to be reintroductory narrative")
            logger.info(f"LIFECYCLE_DEBUG: Content length: {len(content)}")
            logger.info(f"LIFECYCLE_DEBUG: About to route to GameOutputWidget")
        
        # Prevent echoing the player's command if it somehow comes through this path
        # This also handles the case where UI-generated commands might be echoed by the engine.
        is_ui_generated_command_pattern = False
        try:
            parts = content.split(maxsplit=1)
            if len(parts) > 0 and parts[0].lower() in ["examine", "equip", "unequip", "drop", "use"]:
                if len(parts) > 1 and '-' in parts[1] and len(parts[1]) > 10:
                    is_ui_generated_command_pattern = True
        except: # pylint: disable=bare-except
            pass

        if role == "player" and ( (self._last_submitted_command is not None and content == self._last_submitted_command) or is_ui_generated_command_pattern ):
            logger.warning(f"Skipping potential echo of last command or UI-generated command via _handle_game_output: role='{role}', content='{content[:50]}...'")
            if self._last_submitted_command == content: # Clear only if it was an exact match of last submitted
                 self._last_submitted_command = None 
            return
            
        # Clear last submitted command if this output is different, to allow next player input to be echoed
        if self._last_submitted_command is not None and content != self._last_submitted_command:
             self._last_submitted_command = None

        # Route to GameOutputWidget. The append_text method now takes 'gradual'
        # For non-orchestrated output, usually display immediately (gradual=False)
        if role == "system":
            logger.info(f"LIFECYCLE_DEBUG: Routing system message to game_output.append_system_message")
            self.game_output.append_system_message(content, gradual=False)
        elif role == "gm":
            # General GM messages not part of orchestrated combat flow
            logger.info(f"LIFECYCLE_DEBUG: Routing GM message to game_output.append_gm_message with gradual=True")
            self.game_output.append_gm_message(content, gradual=True) # Allow GM narrative to be gradual
        elif role == "player":
            # Do not echo player messages to narrative output while in COMBAT
            try:
                state = self.game_engine.state_manager.current_state
                if state and state.current_mode == InteractionMode.COMBAT:
                    logger.info("Skipping player role output to GameOutputWidget because we're in COMBAT mode.")
                    return
            except Exception:
                pass
            # This path should be rare now, as player input is directly echoed then processed.
            # This will only catch player output if it's *not* the last submitted command.
            self.game_output.append_player_message(content, gradual=False)
        else:
            self.game_output.append_text(f"[{role}] {content}", gradual=False)
                      
        self._update_ui() # Still update UI for general status, etc.
        
    def _update_ui(self):
            """Update UI components based on the current game state."""
            state = self.game_engine.state_manager.current_state
            if not state:
                logger.debug("MainWindow._update_ui: No game state to update UI from.")
                self.status_bar.update_status(location="Not in game", game_time="", calendar="", mode="N/A")
                if hasattr(self.right_panel, 'character_sheet') and self.right_panel.character_sheet: 
                    self.right_panel.character_sheet._clear_stat_displays() 
                
                inventory_manager_for_clear = get_inventory_manager() 
                logger.info(f"MainWindow._update_ui (no game state): Using InventoryManager instance ID: {getattr(inventory_manager_for_clear, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
                if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager_for_clear) 
                return

            game_over = False
            if state.current_mode == InteractionMode.COMBAT and state.combat_manager:
                if state.combat_manager.state == CombatState.PLAYER_DEFEAT:
                    game_over = True
            elif state.current_mode != InteractionMode.COMBAT: 
                try:
                    stats_manager = self.game_engine._stats_manager
                    if stats_manager:
                        from core.stats.stats_base import DerivedStatType
                        player_hp = stats_manager.get_current_stat_value(DerivedStatType.HEALTH)
                        if player_hp <= 0: game_over = True
                except Exception as e: logger.error(f"MainWindow._update_ui: Error checking player HP for game over: {e}", exc_info=True)

            if game_over and not hasattr(self, '_game_over_dialog_shown'):
                logger.info("MainWindow._update_ui: Player defeat detected. Showing Game Over dialog.")
                self._game_over_dialog_shown = True 
                self.narrative_command_input.setEnabled(False)
                self.combat_command_input.setEnabled(False)
                dialog = GameOverDialog(self)
                dialog.set_reason("You have been defeated!") 
                dialog.new_game_requested.connect(self._show_new_game_dialog)
                dialog.load_game_requested.connect(self._show_load_game_dialog)
                dialog.load_last_save_requested.connect(self._load_last_save)
                dialog.exec()
                self.narrative_command_input.setEnabled(True)
                self.combat_command_input.setEnabled(True)
                if hasattr(self, '_game_over_dialog_shown'): 
                    delattr(self, '_game_over_dialog_shown') 
                return 
            
            current_mode_enum = state.current_mode
            current_mode_name = current_mode_enum.name if hasattr(current_mode_enum, 'name') else str(current_mode_enum)
            logger.info(f"MainWindow._update_ui: Updating UI. Target mode: {current_mode_name}. Current QStackedWidget widget: {self.mode_stacked_widget.currentWidget().objectName() if self.mode_stacked_widget.currentWidget() else 'None'}")

            is_transitioning_to_combat = getattr(state, 'is_transitioning_to_combat', False)
            combat_narrative_buffer = getattr(state, 'combat_narrative_buffer', [])

            if current_mode_name == "COMBAT":
                view_switched_this_call = False
                if self.mode_stacked_widget.currentWidget() != self.combat_view:
                    logger.info(f"MainWindow._update_ui: Switching to combat_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.combat_view)
                    view_switched_this_call = True
                else:
                    logger.info("MainWindow._update_ui: combat_view is already the current widget.")

                # Ensure combat_view is visible and updated, regardless of whether it was just switched.
                self.combat_view.setVisible(True) # Explicitly ensure visibility
                self.combat_view.update() # Request a repaint of the combat_view
                self.mode_stacked_widget.update() # Request a repaint of the QStackedWidget
                
                if view_switched_this_call:
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.combat_view:
                        logger.info(f"MainWindow._update_ui: Successfully set combat_view as current widget in QStackedWidget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set combat_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                    
                    if hasattr(self.right_panel, 'tab_widget'): 
                        self.right_panel.tab_widget.setCurrentIndex(0)

                if is_transitioning_to_combat and combat_narrative_buffer:
                    logger.info(f"MainWindow._update_ui: Combat transition: Queuing {len(combat_narrative_buffer)} buffered messages with Orchestrator.")
                    from core.orchestration.events import DisplayEvent, DisplayEventType, DisplayTarget 
                    
                    buffer_event = DisplayEvent(
                        type=DisplayEventType.BUFFER_FLUSH,
                        content=list(combat_narrative_buffer), 
                        role="gm", 
                        target_display=DisplayTarget.COMBAT_LOG,
                        gradual_visual_display=True,
                        tts_eligible=True
                    )
                    self.game_engine._combat_orchestrator.add_event_to_queue(buffer_event)
                    
                    state.combat_narrative_buffer.clear() 
                    state.is_transitioning_to_combat = False 
                    logger.debug("MainWindow._update_ui: Cleared combat_narrative_buffer and reset is_transitioning_to_combat flag.")
                
                # Call combat_display.update_display to refresh its content
                logger.info("MainWindow._update_ui (COMBAT mode): Calling combat_display.update_display.")
                self.combat_display.update_display(state) 
                
                if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player) 

                combat_manager = state.combat_manager 
                if view_switched_this_call and combat_manager and combat_manager.current_step == CombatStep.STARTING_COMBAT:
                    if not self.game_engine._combat_orchestrator.is_processing_event and not self.game_engine._combat_orchestrator.event_queue:
                        logger.info(f"MainWindow._update_ui (view switched to COMBAT this call) triggering initial CombatManager.process_combat_step() as Orchestrator is idle.")
                        QTimer.singleShot(10, lambda cm=combat_manager, eng=self.game_engine: cm.process_combat_step(eng))
                elif combat_manager and combat_manager.current_step == CombatStep.AWAITING_PLAYER_INPUT:
                     logger.debug("MainWindow._update_ui: CombatManager is AWAITING_PLAYER_INPUT. No nudge needed.")


            else: # Not in Combat mode
                if self.mode_stacked_widget.currentWidget() != self.narrative_view:
                    logger.info(f"MainWindow._update_ui: Switching to narrative_view.")
                    self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
                    current_widget_after_switch = self.mode_stacked_widget.currentWidget()
                    if current_widget_after_switch == self.narrative_view:
                        logger.info(f"MainWindow._update_ui: Successfully set narrative_view as current widget.")
                    else:
                        logger.error(f"MainWindow._update_ui: FAILED to set narrative_view. Current widget is still: {current_widget_after_switch.objectName() if current_widget_after_switch else 'None'}")
                
                self.narrative_view.setVisible(True) # Ensure narrative view is visible
                self.narrative_view.update()
                self.mode_stacked_widget.update()


                if is_transitioning_to_combat: 
                    logger.warning("MainWindow._update_ui: Was transitioning to combat, but now in narrative. Resetting transition flag.")
                    state.is_transitioning_to_combat = False 
                    state.combat_narrative_buffer.clear()


            if current_mode_enum == InteractionMode.TRADE and \
               (self._previous_mode is None or self._previous_mode != InteractionMode.TRADE):
                partner_id = getattr(state, 'current_trade_partner_id', None)
                partner_name = "Unknown NPC"
                if partner_id and state.world: 
                    partner_obj = getattr(state.world, 'get_character', lambda pid: None)(partner_id)
                    if partner_obj: partner_name = getattr(partner_obj, 'name', "Unknown NPC")
                self.game_output.append_system_message(f"Trade started with {partner_name}.", gradual=False)

            self._previous_mode = current_mode_enum
            if state.player and hasattr(self.right_panel, 'update_character'): self.right_panel.update_character(state.player)

            inventory_manager = get_inventory_manager() 
            logger.info(f"MainWindow._update_ui: Using InventoryManager instance ID: {getattr(inventory_manager, 'instance_id_for_debug', 'UNKNOWN_INSTANCE')}")
            if hasattr(self.right_panel, 'update_inventory'): self.right_panel.update_inventory(inventory_manager)
            
            journal_data = getattr(state, "journal", None)
            if journal_data is not None and hasattr(self.right_panel, 'update_journal'): self.right_panel.update_journal(journal_data)

            self.status_bar.update_status(
                location=getattr(state.player, 'current_location', 'Unknown') if state.player else 'N/A',
                game_time=getattr(state.world, 'time_of_day', ''),
                calendar=getattr(state.world, 'calendar_string', ''),
                mode=current_mode_name 
            )

    def _show_game_panels_for_loaded_game(self):
        """Make game panels visible and enabled when loading a saved game."""
        self._initialize_panel_effects()
        
        # Make center widget visible and enabled
        self.center_widget.setVisible(True)
        self.center_widget.setEnabled(True)
        if hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect.setOpacity(1.0)
        
        # Make right panel visible and enabled
        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(True)
        if hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect.setOpacity(1.0)
        # Ensure right panel is in expanded state for loaded games
        if not self.right_panel.isExpanded():
            self.right_panel.setExpanded(True)
        
        # Make status bar visible and enabled
        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(True)
        if hasattr(self, 'status_bar_opacity_effect'):
            self.status_bar_opacity_effect.setOpacity(1.0)
        
        logger.info("Game panels made visible and enabled for loaded game")

    def _show_new_game_dialog(self):
        """Show dialog for creating a new game."""
        from gui.dialogs.character_creation_dialog import CharacterCreationDialog
        dialog = CharacterCreationDialog(self)
        if dialog.exec():
            character_data = dialog.get_character_data()
            if not character_data: 
                logger.warning("New game character creation cancelled or failed validation in dialog.")
                return

            logger.info(f"Character data received from dialog. Preparing to start panel animations.")
            
            # Start panel animations, passing character_data to be used after animation
            # This will eventually call _start_game_flow_after_animation
            self._start_panel_animations(character_data)
            
            # DO NOT start game engine here. It will be started by _start_game_flow_after_animation.
        else:
            logger.info("New game dialog cancelled by user.")

    def _show_save_game_dialog(self):
        """Show dialog for saving the game."""
        from gui.dialogs.save_game_dialog import SaveGameDialog
        dialog = SaveGameDialog(self)
        if dialog.exec():
            # Save the game with the provided name
            save_name = dialog.save_name_edit.text()
            # Capture current combat log HTML snapshot if in COMBAT
            try:
                state = self.game_engine.state_manager.current_state
                if state and state.current_mode.name == 'COMBAT' and state.combat_manager:
                    # Ensure current Combat Log HTML is stored for save
                    html_snapshot = ""
                    if hasattr(self, 'combat_display') and hasattr(self.combat_display, 'log_text'):
                        html_snapshot = self.combat_display.log_text.toHtml()
                    state.combat_manager.display_log_html = html_snapshot or state.combat_manager.display_log_html
            except Exception as e:
                logger.warning(f"Failed to snapshot Combat Log HTML before save: {e}")
            saved_path = self.game_engine.save_game(save_name)
            
            if saved_path:
                QMessageBox.information(
                    self, 
                    "Game Saved", 
                    f"Game saved successfully to {saved_path}"
                )
    
    def _show_load_game_dialog(self):
        """Show dialog for loading a saved game."""
        from gui.dialogs.load_game_dialog import LoadGameDialog
        dialog = LoadGameDialog(self)
        if dialog.exec():
            # Load the selected save
            save_filename = dialog.selected_save
            if save_filename:
                # Pre-clear orchestrator and displays before loading save to preserve new outputs
                try:
                    if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                        self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
                except Exception as e:
                    logger.warning(f"Failed to clear orchestrator state before load: {e}")
                try:
                    self.game_output.clear()
                except Exception as e:
                    logger.warning(f"Failed to clear GameOutputWidget before load: {e}")
                try:
                    self.combat_display.clear_display()
                except Exception as e:
                    logger.warning(f"Failed to clear CombatDisplay before load: {e}")
                self._last_submitted_command = None
                loaded_state = self.game_engine.load_game(save_filename)
                
                if loaded_state:
                    # Clear right panel tabs to avoid stale data before repopulating
                    try:
                        if hasattr(self.right_panel, 'journal_panel'):
                            self.right_panel.journal_panel.clear_all()
                        if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                            # If a clear method exists use it; otherwise update_inventory will refresh
                            try:
                                self.right_panel.inventory_panel.clear()
                            except Exception:
                                pass
                        if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                            self.right_panel.character_sheet._clear_stat_displays()
                    except Exception as e:
                        logger.warning(f"Failed to clear right panel widgets prior to load repopulation: {e}")

                    # Ensure journal exists
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": self.game_engine.state_manager.current_state.player.background,
                            "quests": {},
                            "notes": []
                        }
                    
                    # Ensure the stats manager is fully initialized
                    self.game_engine.state_manager.ensure_stats_manager_initialized()

                    # Make game panels visible and enabled for loaded games
                    self._show_game_panels_for_loaded_game()
                    
                    # Update UI
                    self._update_ui()

                    # Bind orchestrator to loaded CombatManager if save is in COMBAT
                    try:
                        state = self.game_engine.state_manager.current_state
                        if state and state.current_mode.name == 'COMBAT' and getattr(state, 'combat_manager', None):
                            if hasattr(self.game_engine, '_combat_orchestrator'):
                                self.game_engine._combat_orchestrator.set_combat_manager(state.combat_manager)
                                logger.info("Bound loaded CombatManager to Orchestrator in MainWindow (load dialog).")
                    except Exception as e:
                        logger.warning(f"Failed to bind CombatManager after load in MainWindow: {e}")

                    # Emit consolidated stats_changed to refresh UI listeners
                    try:
                        sm = self.game_engine.state_manager.stats_manager
                        if sm and hasattr(sm, 'stats_changed'):
                            sm.stats_changed.emit(sm.get_all_stats())
                            logger.info("Emitted consolidated stats_changed after load to refresh UI.")
                    except Exception as e:
                        logger.warning(f"Failed to emit stats_changed after load: {e}")
                    
                    # Force character sheet update with current player
                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                else:
                    QMessageBox.warning(
                        self, 
                        "Load Failed", 
                        f"Failed to load game from {save_filename}"
                    )
    
    def _show_settings_dialog(self):
        """Show dialog for game settings."""
        logger.info("Attempting to show SettingsDialog...") # Log entry
        from gui.dialogs.settings.settings_dialog import SettingsDialog
        logger.info("Imported SettingsDialog.") # Log import success

        try:
            dialog = SettingsDialog(self)
            logger.info("SettingsDialog instance created.") # Log instance creation
        except Exception as e:
            logger.error(f"Error INSTANTIATING SettingsDialog: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"Failed to create settings dialog:\n{e}")
            return

        # Connect the background preview signal from the BackgroundTab within the SettingsDialog
        connected = False
        if hasattr(dialog, 'background_tab') and hasattr(dialog.background_tab, 'preview_background_changed'):
            try:
                # Connect the signal that now emits the full filename
                dialog.background_tab.preview_background_changed.connect(self.update_background)
                connected = True
                logger.info("Connected background_preview_changed signal for live preview.")
            except Exception as e:
                 logger.error(f"Error connecting background_preview_changed signal: {e}")
        else:
            logger.warning("Could not find background_tab or preview_background_changed signal in SettingsDialog.")

        saved = False
        try:
            logger.info("Attempting to execute SettingsDialog...") # Log before exec
            # Execute the dialog
            result = dialog.exec()
            logger.info(f"SettingsDialog execution finished with result: {result}") # Log after exec
            if result == QDialog.Accepted: # Check result code
                saved = True
        except Exception as e:
             logger.error(f"Error EXECUTING SettingsDialog: {e}", exc_info=True)
             QMessageBox.critical(self, "Error", f"Failed to execute settings dialog:\n{e}")
        finally:
            # Disconnect signal after dialog is closed
            if connected:
                try:
                    dialog.background_tab.preview_background_changed.disconnect(self.update_background)
                    logger.info("Disconnected background_preview_changed signal.")
                except Exception as e:
                     logger.warning(f"Failed to disconnect background_preview_changed signal: {e}")

        if saved: # Process saved settings only if dialog was accepted
            logger.info("Settings dialog accepted. Applying settings...") # Log applying settings
            # Apply new settings
            settings = SettingsDialog.get_settings() # Re-fetch to be sure

            # Update dev controls visibility immediately after settings change
            try:
                q_settings = QSettings("RPGGame", "Settings")
                dev_enabled = q_settings.value("dev/enabled", False, type=bool)
                if hasattr(self, 'combat_display') and hasattr(self.combat_display, 'dev_controls_container'):
                    self.combat_display.dev_controls_container.setVisible(bool(dev_enabled))
                # Also toggle orchestrator step mode to match dev setting default (off until user toggles)
                if hasattr(self.game_engine, '_combat_orchestrator') and hasattr(self.game_engine._combat_orchestrator, 'toggle_dev_step_mode'):
                    self.game_engine._combat_orchestrator.toggle_dev_step_mode(False)
            except Exception as e:
                logger.warning(f"Failed to update dev controls visibility post settings: {e}")

            # Update resolution if needed
            resolution = settings["display"]["windowed_size"] # Use windowed_size now
            current_state = settings["display"]["window_state"]

            logger.info(f"Applying settings - State: {current_state}, Windowed Size: {resolution}")

            # Apply window state changes
            if current_state == "fullscreen":
                if not self.isFullScreen(): self.showFullScreen()
            elif current_state == "maximized":
                 if not self.isMaximized(): self.showMaximized()
            else: # windowed
                 if self.isFullScreen() or self.isMaximized(): self.showNormal()
                 # Check if size actually needs changing
                 if QSize(resolution[0], resolution[1]) != self.size():
                     self.resize(resolution[0], resolution[1]) # Use tuple values

            # Update styling (includes non-background styles)
            self._update_styling()

            # Explicitly apply the *saved* background setting after dialog closes
            q_settings = QSettings("RPGGame", "Settings")
            saved_filename = q_settings.value("style/background_filename", None)
            if saved_filename:
                 logger.info(f"Applying saved background from QSettings: {saved_filename}")
                 self.update_background(saved_filename)
            else:
                 logger.warning("Could not read saved background filename after settings dialog closed.")

            # Update UI based on new settings (e.g., status bar, panels)
            # self._update_ui() # Update UI can be complex, might re-trigger things, maybe call specific updates?
            # Let's rely on the window state change and styling update for now.

            # Reload autosave settings (turn-based) in the engine
            try:
                if hasattr(self.game_engine, 'reload_autosave_settings'):
                    self.game_engine.reload_autosave_settings()
            except Exception as e:
                logger.warning(f"Failed to reload autosave settings after saving: {e}")

            # Show confirmation
            self.game_output.append_system_message("Settings saved successfully.")
            logger.info("Settings applied successfully.")
        else:
             logger.info("Settings dialog cancelled or closed without saving.")
    
    def update_background(self, filename: Optional[str]):
        """Load and apply a new background image or GIF to the main window."""
        logger.info(f"Attempting to update background to: {filename}")

        # Stop and clear any existing movie/pixmap
        current_movie = self.background_label.movie()
        if current_movie:
            current_movie.stop()
            self.background_label.setMovie(None)
        self.background_label.setPixmap(QPixmap())
        # Reset palette to default in case previous was PNG
        self.background_container.setAutoFillBackground(False) # Important! Don't let palette fill container
        self.background_label.setProperty("current_background", None) # Store current bg filename

        if not filename:
            logger.warning("No background filename provided, clearing background.")
            # Optionally set a default color on the label if needed
            self.background_label.setStyleSheet("background-color: #1E1E1E;")
            return

        name, ext = os.path.splitext(filename)
        ext_lower = ext.lower()

        if ext_lower == ".png":
            pixmap = self.resource_manager.get_background_pixmap(name)
            if not pixmap.isNull():
                self.background_label.setPixmap(pixmap) # Label scales content
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied PNG background: {filename}")
            else:
                logger.warning(f"Failed to load PNG background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")

        elif ext_lower == ".gif":
            movie = self.resource_manager.get_background_movie(name)
            if movie.isValid():
                self.background_label.setMovie(movie)
                movie.start()
                self.background_label.setStyleSheet("") # Clear any fallback color
                self.background_label.setProperty("current_background", filename)
                logger.info(f"Successfully applied GIF background: {filename}")
            else:
                logger.warning(f"Failed to load GIF background '{filename}', applying fallback color.")
                self.background_label.setStyleSheet("background-color: #1E1E1E;")
        else:
            logger.error(f"Unsupported background file type: {filename}")
            self.background_label.setStyleSheet("background-color: #1E1E1E;") # Fallback color

    def _load_and_apply_initial_background(self):
        """Load the saved background filename from settings and apply it.
        If no valid setting is found, use the first available background alphabetically.
        """
        settings = QSettings("RPGGame", "Settings")
        # Read the full filename setting
        saved_filename = settings.value("style/background_filename", None)

        available_backgrounds = self.resource_manager.list_background_names() # Gets list of (name, ext)
        final_filename = None

        # Check if saved filename exists in the available list
        if saved_filename:
            found = False
            for name, ext in available_backgrounds:
                if f"{name}{ext}" == saved_filename:
                    final_filename = saved_filename
                    found = True
                    break
            if found:
                logger.info(f"Using saved background: {final_filename}")
            else:
                logger.warning(f"Saved background '{saved_filename}' not found in available list.")
                saved_filename = None # Treat as not found

        # If no valid saved name, use the first available background
        if not final_filename and available_backgrounds:
            first_name, first_ext = available_backgrounds[0] # Use first alphabetically
            final_filename = f"{first_name}{first_ext}"
            logger.info(f"No valid saved background found. Using first available: {final_filename}")
        elif not final_filename:
             logger.warning("No saved background setting found and no backgrounds available in images/gui/background/. Applying fallback color.")
             # update_background will handle the fallback color if name is None

        self.update_background(final_filename) # Pass None if no background is available

    def _update_styling(self):
        """Update UI styling based on saved settings."""
        # Update game output styling and formats
        self.game_output._update_formats()
        self.game_output._setup_background()
        
        # Get settings for command input styling
        settings = QSettings("RPGGame", "Settings")
        
        # Update command input styling
        user_input_font_family = settings.value("style/user_input_font_family", "Garamond")
        user_input_font_size = int(settings.value("style/user_input_font_size", 14))
        user_input_font_color = settings.value("style/user_input_font_color", "#0d47a1")
        
        # Create a dark frame around command input and enter button
        # Get transparency setting
        input_opacity = int(settings.value("style/input_opacity", 100))
        opacity_percent = input_opacity / 100.0
        
        # Calculate RGB values for the background
        bg_color_obj = QColor("#333333")
        r, g, b = bg_color_obj.red(), bg_color_obj.green(), bg_color_obj.blue()
        
        # Common style for command inputs
        command_input_style = f"""
            CommandInputWidget {{
                background-color: rgba({r}, {g}, {b}, {opacity_percent});
                border-radius: 10px;
                padding: 5px;
                border: 2px solid #333333; /* Same as left/right panels */
            }}
            QLineEdit {{
                background-color: rgba(255, 255, 255, 0.7);
                color: {user_input_font_color};
                border: 1px solid #c4b59d;
                border-radius: 4px;
                padding: 8px;
                font-family: '{user_input_font_family}';
                font-size: {user_input_font_size}pt;
                margin-left: 5px;
                margin-right: 5px;
            }}
        """
        
        # Apply style to both command inputs
        self.narrative_command_input.setStyleSheet(command_input_style)
        self.combat_command_input.setStyleSheet(command_input_style)
    
    def _show_llm_settings_dialog(self):
        """Show dialog for LLM settings."""
        dialog = LLMSettingsDialog(self)
        dialog.settings_saved.connect(self._on_llm_settings_saved)
        dialog.exec()
    
    def _on_llm_settings_saved(self):
        """Handle LLM settings saved event."""
        # Update UI elements that depend on LLM settings
        is_llm_enabled = self.game_engine._use_llm
        
        # Add UI feedback to show LLM status when explicitly changed through settings
        if is_llm_enabled:
            self.game_output.append_system_message("LLM processing is now enabled.")
        else:
            self.game_output.append_system_message("LLM processing is now disabled.")

    # Removed _delayed_character_update method - we now use direct update instead of timers
    
    def closeEvent(self, event):
        """Handle window close event."""
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 
            "Exit Game", 
            "Are you sure you want to exit? Unsaved progress will be lost.",
            QMessageBox.Yes | QMessageBox.No, 
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Stop the game engine
            self.game_engine.stop()

            # Stop background movie if playing
            bg_movie = self.background_label.movie()
            if bg_movie:
                bg_movie.stop()

            event.accept()
        else:
            event.ignore()

    def resizeEvent(self, event):
        """Handle window resize event to keep background and content sized correctly."""
        super().resizeEvent(event)
        # Keep background label and content widget filling the container
        if hasattr(self, 'background_label'): # Check if widgets exist yet
             self.background_label.setGeometry(0, 0, event.size().width(), event.size().height())
        if hasattr(self, 'main_content_widget'):
             self.main_content_widget.setGeometry(0, 0, event.size().width(), event.size().height())

    def _load_last_save(self):
        """Loads the most recent non-auto save file."""
        logger.info("Attempting to load last save.")
        from core.utils.save_manager import SaveManager # Local import
        save_manager = SaveManager()
        try:
            # Get recent saves, excluding backups and auto-saves initially
            saves = save_manager.get_recent_saves(count=10, include_backups=False) # Get a few recent ones
            last_manual_save = None
            for save in saves:
                 if not save.auto_save:
                      last_manual_save = save
                      break # Found the most recent manual save

            if last_manual_save:
                save_filename = f"{last_manual_save.save_id}/{SaveManager.STATE_FILENAME}" # Need correct path format if StateManager expects full path or just ID
                save_id = last_manual_save.save_id # Use the ID for loading
                logger.info(f"Found last manual save: {last_manual_save.save_name} (ID: {save_id})")

                # Clear any previous UI content and pending orchestrator events BEFORE loading
                try:
                    if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                        self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
                except Exception as e:
                    logger.warning(f"Failed to clear orchestrator state before load: {e}")
                
                try:
                    self.game_output.clear()
                except Exception as e:
                    logger.warning(f"Failed to clear GameOutputWidget before load: {e}")
                
                try:
                    self.combat_display.clear_display()
                except Exception as e:
                    logger.warning(f"Failed to clear CombatDisplay before load: {e}")
                
                # Also clear right panel content to avoid stale state
                try:
                    if hasattr(self.right_panel, 'journal_panel'):
                        self.right_panel.journal_panel.clear_all()
                    if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                        try:
                            self.right_panel.inventory_panel.clear()
                        except Exception:
                            pass
                    if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                        self.right_panel.character_sheet._clear_stat_displays()
                except Exception as e:
                    logger.warning(f"Failed to clear right panel widgets before load: {e}")
                
                self._last_submitted_command = None
                
                # Call engine's load_game method
                loaded_state = self.game_engine.load_game(save_id) # Pass save_id

                if loaded_state:
                    # Ensure journal exists (similar to _show_load_game_dialog)
                    if not hasattr(self.game_engine.state_manager.current_state, "journal"):
                        self.game_engine.state_manager.current_state.journal = {
                            "character": getattr(self.game_engine.state_manager.current_state.player, 'background', ''),
                            "quests": {},
                            "notes": []
                        }
                    self.game_engine.state_manager.ensure_stats_manager_initialized()

                    # Make game panels visible and enabled for loaded games
                    self._show_game_panels_for_loaded_game()
                    
                    self._update_ui() # Update UI after load

                    # Bind orchestrator to loaded CombatManager if save is in COMBAT
                    try:
                        state = self.game_engine.state_manager.current_state
                        if state and state.current_mode.name == 'COMBAT' and getattr(state, 'combat_manager', None):
                            if hasattr(self.game_engine, '_combat_orchestrator'):
                                self.game_engine._combat_orchestrator.set_combat_manager(state.combat_manager)
                                logger.info("Bound loaded CombatManager to Orchestrator in MainWindow (load last save).")
                    except Exception as e:
                        logger.warning(f"Failed to bind CombatManager after loading last save: {e}")

                    # Emit consolidated stats_changed to refresh UI listeners
                    try:
                        sm = self.game_engine.state_manager.stats_manager
                        if sm and hasattr(sm, 'stats_changed'):
                            sm.stats_changed.emit(sm.get_all_stats())
                            logger.info("Emitted consolidated stats_changed after loading last save.")
                    except Exception as e:
                        logger.warning(f"Failed to emit stats_changed after loading last save: {e}")

                    if self.game_engine.state_manager.current_state and self.game_engine.state_manager.current_state.player:
                        self.right_panel.update_character(self.game_engine.state_manager.current_state.player)
                    self.game_output.append_system_message(f"Loaded last save: {last_manual_save.save_name}")
                else:
                    QMessageBox.warning(self, "Load Failed", f"Failed to load last save: {last_manual_save.save_name}")
                    # If last save fails, open the regular load dialog
                    self._show_load_game_dialog()
            else:
                logger.warning("No manual saves found to load.")
                QMessageBox.information(self, "No Last Save", "No manual save file found. Please load manually or start a new game.")
                # Open the regular load dialog as fallback
                self._show_load_game_dialog()
        except Exception as e:
            logger.error(f"Error loading last save: {e}", exc_info=True)
            QMessageBox.critical(self, "Error", f"An error occurred while trying to load the last save:\n{e}")
            self._show_load_game_dialog() # Fallback to regular load dialog

    @Slot(object) 
    def process_orchestrated_display_event(self, event):
        """
        Handles DisplayEvents routed from the CombatOutputOrchestrator via the GameEngine.
        This method sends the content to the appropriate UI display widget.
        """
        from core.orchestration.events import DisplayEvent, DisplayTarget, DisplayEventType 
        if not isinstance(event, DisplayEvent):
            logger.error(f"MainWindow received non-DisplayEvent object: {type(event)}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()
            return

        logger.info(f"MainWindow processing orchestrated event: {event}")
        state = self.game_engine.state_manager.current_state

        target_widget = None
        # Determine primary target widget
        if event.target_display == DisplayTarget.COMBAT_LOG:
            target_widget = self.combat_display
        elif event.target_display == DisplayTarget.MAIN_GAME_OUTPUT:
            target_widget = self.game_output
            # Ensure the narrative view is visible if routing to MAIN_GAME_OUTPUT AND we are not currently in COMBAT mode
            try:
                state_for_switch = self.game_engine.state_manager.current_state
                if state_for_switch and state_for_switch.current_mode != InteractionMode.COMBAT:
                    if self.mode_stacked_widget.currentWidget() != self.narrative_view:
                        logger.info("MainWindow: MAIN_GAME_OUTPUT event and current mode not COMBAT. Switching to narrative_view.")
                        self.mode_stacked_widget.setCurrentWidget(self.narrative_view)
                        self.narrative_view.setVisible(True)
                        self.mode_stacked_widget.update()
            except Exception as e:
                logger.warning(f"Failed conditional switch to narrative_view on MAIN_GAME_OUTPUT event: {e}")
        else: # Default based on mode if target not explicit
            if state and state.current_mode == InteractionMode.COMBAT:
                target_widget = self.combat_display
            else:
                target_widget = self.game_output
        
        if not target_widget and event.type not in [DisplayEventType.TURN_ORDER_UPDATE, DisplayEventType.UI_BAR_UPDATE_PHASE1, DisplayEventType.UI_BAR_UPDATE_PHASE2]: # These might not have a primary text widget
            logger.error(f"No target widget found for orchestrated event: {event} and not a special UI event.")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete() 
            return

        # Handle event types
        if event.type == DisplayEventType.BUFFER_FLUSH:
            if isinstance(event.content, list) and target_widget == self.combat_display:
                # New: perfect fidelity replay with role per line, batched to a single completion
                try:
                    # Suppress per-line completion during batch
                    if hasattr(self.combat_display, '_suppress_visual_complete'):
                        self.combat_display._suppress_visual_complete = True
                    for item in event.content:
                        if isinstance(item, dict) and 'text' in item:
                            line_text = str(item.get('text', ''))
                            line_role = item.get('role', event.role or 'gm')
                            if line_text:
                                self.combat_display.append_orchestrated_event_content(line_text, line_role, is_gradual=False)
                        else:
                            # Fallback: treat as plain string
                            self.combat_display.append_orchestrated_event_content(str(item), event.role or 'gm', is_gradual=False)
                except Exception as e:
                    logger.error(f"Error during BUFFER_FLUSH replay: {e}", exc_info=True)
                finally:
                    if hasattr(self.combat_display, '_suppress_visual_complete'):
                        self.combat_display._suppress_visual_complete = False
                # Signal completion once for the whole batch (async to avoid re-entrancy)
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    try:
                        QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)
                    except Exception:
                        # Fallback to direct call if QTimer not available
                        self.game_engine._combat_orchestrator._handle_visual_display_complete()
            else:
                logger.error(f"Invalid content type or target for BUFFER_FLUSH event: {type(event.content)}, target: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()

        elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1 or event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
            logger.debug(f"Handling UI_BAR_UPDATE event: {event.metadata}")
            entity_id = event.metadata.get("entity_id")
            bar_type = event.metadata.get("bar_type") 
            
            # Diagnostic: player mapping and widget presence
            player_id_diag = None
            state_for_diag = self.game_engine.state_manager.current_state
            if state_for_diag and state_for_diag.player:
                player_id_diag = getattr(state_for_diag.player, 'id', getattr(state_for_diag.player, 'stats_manager_id', None))
            logger.info(f"UI_BAR_UPDATE {event.type.name}: bar={bar_type}, entity={entity_id}, is_player={(entity_id==player_id_diag)}")
            
            # Update CharacterSheet if it's the player (do this first to align visual timing with CombatDisplay)
            player_id = None
            if state and state.player:
                 player_id = getattr(state.player, 'id', getattr(state.player, 'stats_manager_id', None))

            player_bar_updated = False
            if entity_id == player_id and self.right_panel and self.right_panel.character_sheet:
                try:
                    if event.type == DisplayEventType.UI_BAR_UPDATE_PHASE1:
                        self.right_panel.character_sheet.player_resource_bar_update_phase1(bar_type, event.metadata)
                        player_bar_updated = True
                    elif event.type == DisplayEventType.UI_BAR_UPDATE_PHASE2:
                        self.right_panel.character_sheet.player_resource_bar_update_phase2(bar_type, event.metadata)
                        player_bar_updated = True
                except Exception as e:
                    logger.error(f"Error updating CharacterSheet for player bar update: {e}", exc_info=True)

            # Update CombatEntityWidget in CombatDisplay
            entity_widget_combat_display = self.combat_display.entity_widgets.get(entity_id)
            logger.info(f"CombatDisplay widget exists for entity? {bool(entity_widget_combat_display)}")
            animation_invoked = False
            if entity_widget_combat_display:
                method_name = f"animate_{event.type.name.lower()}"
                try:
                    if hasattr(entity_widget_combat_display, method_name):
                        getattr(entity_widget_combat_display, method_name)(event.metadata)
                        animation_invoked = True
                    else:
                        logger.warning(f"CombatEntityWidget missing method {method_name} for entity {entity_id}. Will complete event to prevent stall.")
                except Exception as e:
                    logger.error(f"Error invoking {method_name} on CombatEntityWidget for entity {entity_id}: {e}", exc_info=True)

            # If no animation method was invoked, or if widget is missing, proactively complete to avoid stall
            if (not entity_widget_combat_display) or (not animation_invoked):
                 if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    try:
                        QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)
                    except Exception:
                        self.game_engine._combat_orchestrator._handle_visual_display_complete()
                 if not entity_widget_combat_display:
                     logger.warning(f"UI_BAR_UPDATE for entity {entity_id} but no CombatEntityWidget found. Signalled completion to avoid stall.")
                 else:
                     logger.info(f"UI_BAR_UPDATE fallback completion invoked (no animation) for entity {entity_id}.")

            # Final safety net: if the orchestrator is still processing this same event shortly after, complete it
            try:
                QTimer.singleShot(10, lambda ev_id=event.event_id: self._complete_if_same_event(ev_id))
            except Exception:
                pass


        elif event.type == DisplayEventType.TURN_ORDER_UPDATE:
            if self.right_panel and self.right_panel.character_sheet and hasattr(self.right_panel.character_sheet, 'handle_turn_order_update'):
                self.right_panel.character_sheet.handle_turn_order_update(event.content) # event.content is the data dict
            # This event is primarily for CharacterSheet, CombatDisplay updates turn order itself.
            # Signal completion immediately as CharacterSheet update is synchronous.
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                 QTimer.singleShot(0, self.game_engine._combat_orchestrator._handle_visual_display_complete)


        elif event.type == DisplayEventType.COMBAT_LOG_SET_HTML:
            # Directly set Combat Log HTML for instant rehydration
            try:
                if target_widget == self.combat_display and isinstance(event.content, str):
                    # Freeze updates for fast set
                    self.combat_display.log_text.setUpdatesEnabled(False)
                    self.combat_display.log_text.setHtml(event.content)
                    # Move caret to end and ensure visible using correct API
                    self.combat_display.log_text.moveCursor(QTextCursor.MoveOperation.End)
                    self.combat_display.log_text.ensureCursorVisible()
                    self.combat_display.log_text.setUpdatesEnabled(True)
                else:
                    logger.error(f"COMBAT_LOG_SET_HTML received but target or content invalid: {target_widget}, {type(event.content)}")
            except Exception as e:
                logger.error(f"Error applying COMBAT_LOG_SET_HTML: {e}", exc_info=True)
            # No need to explicitly call visual completion; orchestrator doesn't wait for this type
        elif isinstance(event.content, str): # For NARRATIVE_*, SYSTEM_MESSAGE
            if target_widget == self.combat_display:
                # Log event routing for diagnostics
                logger.info(f"MainWindow: Routing string event to CombatDisplay id={event.event_id} type={event.type.name} gradual={bool(event.gradual_visual_display)}")
                self.combat_display.append_orchestrated_event_content(
                    event_content=event.content,
                    event_role=event.role or "system",
                    is_gradual=event.gradual_visual_display,
                    event_id=event.event_id
                )
            elif target_widget == self.game_output:
                text_format = None 
                if event.role == "system": text_format = self.game_output.system_format
                elif event.role == "gm": text_format = self.game_output.gm_format
                elif event.role == "player": text_format = self.game_output.player_format
                # Hide [DEV] messages unless dev mode is enabled
                try:
                    if isinstance(event.content, str) and event.content.strip().startswith("[DEV]"):
                        q_settings = QSettings("RPGGame", "Settings")
                        if not q_settings.value("dev/enabled", False, type=bool):
                            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                                self.game_engine._combat_orchestrator._handle_visual_display_complete()
                            return
                except Exception:
                    pass
                self.game_output.append_text(event.content, text_format, event.gradual_visual_display)
            elif target_widget is None and event.type == DisplayEventType.TURN_ORDER_UPDATE:
                 # This was already handled above, but log if it falls through
                 logger.debug("TURN_ORDER_UPDATE already handled for CharacterSheet, no primary text widget needed.")
            else:
                logger.error(f"Unhandled target widget for orchestrated string event: {target_widget}")
                if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                    self.game_engine._combat_orchestrator._handle_visual_display_complete()
        else:
            logger.error(f"Orchestrated event has non-string content and is not a known special type: {event}")
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator.is_waiting_for_visual:
                self.game_engine._combat_orchestrator._handle_visual_display_complete()

    def _initialize_panel_effects(self):
        """Initialize QGraphicsOpacityEffect for panels that will be animated."""
        if not hasattr(self, 'center_opacity_effect'):
            self.center_opacity_effect = QGraphicsOpacityEffect(self.center_widget)
            self.center_widget.setGraphicsEffect(self.center_opacity_effect)
            self.center_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'right_panel_opacity_effect'):
            self.right_panel_opacity_effect = QGraphicsOpacityEffect(self.right_panel)
            self.right_panel.setGraphicsEffect(self.right_panel_opacity_effect)
            self.right_panel_opacity_effect.setOpacity(0.0)

        if not hasattr(self, 'status_bar_opacity_effect'):
            self.status_bar_opacity_effect = QGraphicsOpacityEffect(self.status_bar)
            self.status_bar.setGraphicsEffect(self.status_bar_opacity_effect)
            self.status_bar_opacity_effect.setOpacity(0.0)

    def _start_panel_animations(self, character_data: Dict[str, Any]):
        """Starts the animation sequence for showing the main game panels."""
        self._character_data_for_new_game = character_data 

        self._initialize_panel_effects()

        # 1. Make panels visible (for layout) but keep them disabled and transparent
        self.center_widget.setVisible(True)
        self.center_widget.setEnabled(False) # Keep disabled during animation
        self.center_opacity_effect.setOpacity(0.0)

        self.right_panel.setVisible(True)
        self.right_panel.setEnabled(False) # Keep disabled during animation
        # Ensure right_panel is set to its desired initial expanded state before animation
        if not self.right_panel.isExpanded(): 
             self.right_panel.setExpanded(True) # Set its state, width animation will be part of its logic
        self.right_panel_opacity_effect.setOpacity(0.0)

        animation_duration = 300 

        center_anim = QPropertyAnimation(self.center_opacity_effect, b"opacity", self)
        center_anim.setDuration(animation_duration)
        center_anim.setStartValue(0.0)
        center_anim.setEndValue(1.0)
        center_anim.setEasingCurve(QEasingCurve.InOutQuad)

        right_panel_anim = QPropertyAnimation(self.right_panel_opacity_effect, b"opacity", self)
        right_panel_anim.setDuration(animation_duration)
        right_panel_anim.setStartValue(0.0)
        right_panel_anim.setEndValue(1.0)
        right_panel_anim.setEasingCurve(QEasingCurve.InOutQuad)

        self.parallel_anim_group = QParallelAnimationGroup(self)
        self.parallel_anim_group.addAnimation(center_anim)
        self.parallel_anim_group.addAnimation(right_panel_anim)

        self.parallel_anim_group.finished.connect(self._animate_status_bar_in)
        self.parallel_anim_group.start(QPropertyAnimation.DeleteWhenStopped)

    @Slot()
    def _animate_status_bar_in(self):
        """Makes the status bar visible and animates its fade-in."""
        # Enable the center and right panels now that their fade-in is complete
        self.center_widget.setEnabled(True)
        self.right_panel.setEnabled(True)
        logger.info("Center widget and Right panel enabled after fade-in.")

        self.status_bar.setVisible(True)
        self.status_bar.setEnabled(False) # Keep disabled during its own animation
        self.status_bar_opacity_effect.setOpacity(0.0)

        status_bar_anim = QPropertyAnimation(self.status_bar_opacity_effect, b"opacity", self)
        status_bar_anim.setDuration(200) 
        status_bar_anim.setStartValue(0.0)
        status_bar_anim.setEndValue(1.0)
        status_bar_anim.setEasingCurve(QEasingCurve.InOutQuad)

        status_bar_anim.finished.connect(self._start_game_flow_after_animation)
        status_bar_anim.start(QPropertyAnimation.DeleteWhenStopped) 

    @Slot()
    def _start_game_flow_after_animation(self):
        """Final step after all panel animations are complete. Starts the game engine flow."""
        self.status_bar.setEnabled(True)
        logger.info("Status bar enabled after fade-in.")
        logger.info("All panel animations complete. Starting game engine flow.")

        character_data = getattr(self, '_character_data_for_new_game', None)
        if not character_data:
            logger.error("Character data not found after animation. Cannot start new game.")
            QMessageBox.critical(self, "Error", "Failed to retrieve character data to start the game.")
            # Reset UI to pre-new-game state
            self.center_widget.setVisible(False)
            self.center_widget.setEnabled(False)
            if hasattr(self, 'center_opacity_effect'): self.center_opacity_effect.setOpacity(0.0)
            
            self.right_panel.setVisible(False)
            self.right_panel.setEnabled(False)
            if hasattr(self, 'right_panel_opacity_effect'): self.right_panel_opacity_effect.setOpacity(0.0)

            self.status_bar.setVisible(False)
            self.status_bar.setEnabled(False)
            if hasattr(self, 'status_bar_opacity_effect'): self.status_bar_opacity_effect.setOpacity(0.0)
            return

        player_name = character_data['name']
        race = character_data['race']
        path = character_data['path']
        origin_id = character_data.get('origin_id', '') # Get origin_id
        sex = character_data.get('sex', 'Male')
        # 'description' from character_data is the origin's intro_text/background
        origin_description_as_background = character_data.get('description', '') 
        character_image = character_data.get('character_image')
        use_llm = character_data.get('use_llm', True)
        custom_stats = None
        if 'stats' in character_data:
            if all(isinstance(val, int) for val in character_data['stats'].values()):
                custom_stats = character_data['stats']
            else: 
                logger.warning("Unexpected stats format from character_data, attempting to parse.")
                temp_stats = {}
                for stat_name, stat_info in character_data['stats'].items():
                    if isinstance(stat_info, dict) and 'base' in stat_info:
                        temp_stats[stat_name] = stat_info['base']
                    elif isinstance(stat_info, int):
                         temp_stats[stat_name] = stat_info
                if temp_stats: custom_stats = temp_stats
        
        logger.info(f"Starting new game with resolved data: Name={player_name}, Race={race}, Path={path}, OriginID={origin_id}, Sex={sex}, LLM={use_llm}, Stats={custom_stats is not None}")

        # Pre-clear any previous session UI and orchestrator state if starting a new game during an ongoing session
        try:
            if hasattr(self.game_engine, '_combat_orchestrator') and self.game_engine._combat_orchestrator:
                # Detach any existing CombatManager and clear queued events
                try:
                    self.game_engine._combat_orchestrator.set_combat_manager(None)
                except Exception:
                    pass
                self.game_engine._combat_orchestrator.clear_queue_and_reset_flags()
        except Exception as e:
            logger.warning(f"Failed to clear orchestrator state before starting new game: {e}")
        # Ensure any lingering closing-narrative wait flag is reset
        try:
            if hasattr(self.game_engine, '_waiting_for_closing_narrative_display'):
                self.game_engine._waiting_for_closing_narrative_display = False
        except Exception:
            pass
        # Clear visible outputs to avoid mixing old content
        try:
            self.game_output.clear()
        except Exception as e:
            logger.warning(f"Failed to clear GameOutputWidget before starting new game: {e}")
        try:
            self.combat_display.clear_display()
        except Exception as e:
            logger.warning(f"Failed to clear CombatDisplay before starting new game: {e}")
        # Clear right panel widgets to avoid stale state
        try:
            if hasattr(self.right_panel, 'journal_panel'):
                self.right_panel.journal_panel.clear_all()
            if hasattr(self.right_panel, 'inventory_panel') and hasattr(self.right_panel.inventory_panel, 'clear'):
                try:
                    self.right_panel.inventory_panel.clear()
                except Exception:
                    pass
            if hasattr(self.right_panel, 'character_sheet') and hasattr(self.right_panel.character_sheet, '_clear_stat_displays'):
                self.right_panel.character_sheet._clear_stat_displays()
        except Exception as e:
            logger.warning(f"Failed to clear right panel widgets before starting new game: {e}")
        # Reset last submitted command tracking
        self._last_submitted_command = None

        self.game_engine.start_new_game(
            player_name=player_name, 
            race=race, 
            path=path, 
            background=origin_description_as_background, # Pass origin description as background
            sex=sex,
            character_image=character_image,
            stats=custom_stats,
            origin_id=origin_id # Pass origin_id here
        )
        
        self.game_engine.set_llm_enabled(use_llm)
        
        # Ensure journal quests is a dictionary
        initial_quests_data = character_data.get('initial_quests', [])
        journal_quests = {}
        if isinstance(initial_quests_data, dict):
            journal_quests = initial_quests_data
        elif isinstance(initial_quests_data, list):
            logger.warning(f"Initial quests from origin is a list: {initial_quests_data}. Initializing journal quests as an empty dictionary. Full quest population from origin list is not yet implemented here.")
        
        current_game_state = self.game_engine.state_manager.current_state
        if current_game_state:
            if not hasattr(current_game_state, "journal") or current_game_state.journal is None:
                current_game_state.journal = {
                    "character": origin_description_as_background, # Use the same background/origin text
                    "quests": journal_quests,
                    "notes": []
                }
            # Ensure player state's origin_id is set, if GameEngine.start_new_game didn't already
            if not current_game_state.player.origin_id:
                 current_game_state.player.origin_id = origin_id
        
        self._update_ui() 
        self.game_engine.state_manager.ensure_stats_manager_initialized()
        
        if current_game_state and current_game_state.player:
            self.right_panel.update_character(current_game_state.player)

        # Clean up the temporary data
        if hasattr(self, '_character_data_for_new_game'):
            delattr(self, '_character_data_for_new_game')

    @Slot(str)
    def _handle_item_use_requested(self, item_id: str):
        """Handle item use request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item use requested for ID: {item_id}")
        # Placeholder: Implement logic to use the item via InventoryManager or GameEngine
        # For example, this might involve checking if the item is consumable,
        # applying its effects, and removing it from inventory.
        # This could also involve a command like "use <item_id>"
        
        # Example:
        # result = self.game_engine.process_command(f"use {item_id}")
        # self._update_ui() # Update UI after action
        self.game_output.append_system_message(f"Attempting to use item: {item_id} (Handler not fully implemented).")
        # This should ideally go through the command processing loop if 'use' is a player command
        self._process_command(f"use {item_id}")

    @Slot(str)
    def _handle_item_examine_requested(self, item_id: str):
        """Handle item examine request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item examine requested for ID: {item_id}")
        
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item_details_for_dialog(item_id)

        if item:
            from gui.dialogs.item_info_dialog import ItemInfoDialog # Local import
            dialog = ItemInfoDialog(item, self)
            dialog.exec()
        else:
            self.game_output.append_system_message(f"Could not find details for item ID: {item_id}", gradual=False)
            logger.error(f"Could not get item details for ID: {item_id} to show dialog.")
        
        self._update_ui() # Update UI in case item properties were discovered

    @Slot(str) 
    def _handle_item_unequip_requested(self, item_identifier: str): 
        """Handle item unequip request from inventory panel. This is now fully mechanical.
           item_identifier is expected to be an item_id from InventoryPanel.
        """
        logger.info(f"[GUI] MainWindow: Mechanical item unequip requested for ITEM_ID: {item_identifier}")
        inventory_manager = get_inventory_manager()
        
        item_to_unequip = inventory_manager.get_item(item_identifier) 
        if not item_to_unequip: 
            logger.error(f"Cannot unequip: Item ID '{item_identifier}' not found.")
            self._update_ui()
            return
        
        slot_found: Optional[EquipmentSlot] = None
        # inventory_manager.equipment is Dict[EquipmentSlot, Optional[Item]]
        for slot_enum_loop, item_obj_loop in inventory_manager.equipment.items(): 
            if item_obj_loop and isinstance(item_obj_loop, Item) and item_obj_loop.id == item_to_unequip.id:
                slot_found = slot_enum_loop
                break
        
        if not slot_found:
            logger.info(f"{item_to_unequip.name} is not currently equipped (triggered by ID from InventoryPanel).")
            self._update_ui()
            return
        
        item_name_unequipped = item_to_unequip.name
        slot_unequipped_from_str = slot_found.value.replace("_", " ")

        if inventory_manager.unequip_item(slot_found): # unequip_item takes slot
            logger.info(f"Successfully unequipped {item_name_unequipped} from {slot_unequipped_from_str}.")
        else:
            logger.warning(f"Failed to unequip {item_name_unequipped} (Identifier: {item_identifier}).")

        self._update_ui()

    @Slot(str)
    def _handle_item_drop_requested(self, item_id: str):
        """Handle item drop request from inventory panel."""
        logger.info(f"[GUI] MainWindow: Item drop requested for ID: {item_id}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id)

        if not item:
            logger.error(f"Drop requested for non-existent item ID: {item_id}")
            self._update_ui()
            return

        if inventory_manager.is_item_equipped(item_id):
            reply = QMessageBox.question(
                self,
                "Confirm Drop Equipped Item",
                f"'{item.name}' is currently equipped. Are you sure you want to drop it?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                logger.info(f"Drop cancelled by user for equipped item: {item.name}")
                return 

            slot_to_unequip: Optional[EquipmentSlot] = None
            for slot_enum, equipped_item_obj in inventory_manager.equipment.items(): 
                if equipped_item_obj and isinstance(equipped_item_obj, Item) and equipped_item_obj.id == item_id: # Check type
                    slot_to_unequip = slot_enum
                    break
            if slot_to_unequip:
                inventory_manager.unequip_item(slot_to_unequip)
                logger.info(f"Unequipped '{item.name}' from {slot_to_unequip.value} prior to dropping.")
                self._update_ui() 
            else:
                logger.error(f"Could not find slot for equipped item '{item.name}' to unequip before dropping.")
                return
        
        logger.info(f"Processing drop command for item ID: {item_id} via LLM.")
        self._process_command(f"drop {item_id}") 

    @Slot(str) 
    def _handle_item_equip_requested(self, item_id: str): 
        """Handle item equip request from inventory panel. This is now fully mechanical."""
        logger.info(f"[GUI] MainWindow: Mechanical item equip requested for ID: {item_id}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id)

        if not item:
            # self.game_output.append_system_message(f"Cannot equip: Item ID {item_id} not found.", gradual=False)
            logger.error(f"Failed to equip item {item_id}: Not found in InventoryManager.")
            self._update_ui() # Update UI to reflect potential state changes even on error
            return

        if not item.is_equippable:
            # self.game_output.append_system_message(f"Cannot equip {item.name}: It is not equippable.", gradual=False)
            logger.info(f"Cannot equip {item.name}: It is not equippable.")
            self._update_ui()
            return

        if inventory_manager.equip_item(item.id): # Preferred slot logic is inside equip_item
            equipped_slot_str = "a suitable slot"
            for slot_enum, equipped_item_id in inventory_manager.equipment.items():
                if equipped_item_id == item.id:
                    equipped_slot_str = slot_enum.value.replace("_", " ")
                    break
            logger.info(f"Successfully equipped {item.name} to {equipped_slot_str}.")
            # No direct output to GameOutputWidget here for mechanical actions
        else:
            # self.game_output.append_system_message(f"Could not equip {item.name}. No suitable slot available or other restriction.", gradual=False)
            logger.warning(f"Failed to equip {item.name} (ID: {item.id}). InventoryManager.equip_item returned false.")

        self._update_ui()

    @Slot(EquipmentSlot)
    def _handle_item_unequip_from_slot_requested(self, slot_to_unequip: EquipmentSlot):
        """Handles unequip request specifically from a known slot (e.g., CharacterSheet)."""
        logger.info(f"[GUI] MainWindow: Mechanical item unequip from slot requested: {slot_to_unequip.value}")
        inventory_manager = get_inventory_manager()
        
        item_obj_in_slot = inventory_manager.equipment.get(slot_to_unequip) # This is an Item object or None
        item_name = "Item"
        if item_obj_in_slot and isinstance(item_obj_in_slot, Item): # Check type
            item_name = item_obj_in_slot.name
        
        if inventory_manager.unequip_item(slot_to_unequip):
            logger.info(f"Successfully unequipped {item_name} from {slot_to_unequip.value}.")
        else:
            logger.warning(f"Failed to unequip item from slot: {slot_to_unequip.value}")
        
        self._update_ui()

    @Slot(EquipmentSlot, str)
    def _handle_item_drop_from_slot_requested(self, slot_to_unequip: EquipmentSlot, item_id_to_drop: str):
        """Handles drop request for an item currently equipped in a slot."""
        logger.info(f"[GUI] MainWindow: Item drop from slot requested. Slot: {slot_to_unequip.value}, Item ID: {item_id_to_drop}")
        inventory_manager = get_inventory_manager()
        item = inventory_manager.get_item(item_id_to_drop)
        item_name = item.name if item else "the item"

        reply = QMessageBox.question(
            self,
            "Confirm Drop",
            f"Are you sure you want to drop the equipped item '{item_name}' from your {slot_to_unequip.value.replace('_',' ')}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            if inventory_manager.unequip_item(slot_to_unequip):
                logger.info(f"Unequipped {item_name} from {slot_to_unequip.value} prior to dropping.")
                self._process_command(f"drop {item_id_to_drop}") 
            else:
                logger.error(f"Failed to unequip {item_name} (ID: {item_id_to_drop}) from slot {slot_to_unequip.value} before dropping.")
        else:
            logger.info(f"Drop cancelled for item {item_name} from slot {slot_to_unequip.value}.")
        
        self._update_ui()
```

### File: gui\descr.md

```markdown
Files I opened and read in full for this analysis:
- Right panel container and tabs
  - gui/components/right_panel.py
  - gui/components/character_sheet.py
  - gui/components/inventory_panel.py
  - gui/components/journal_panel.py
- Character creation and stat allocation
  - gui/dialogs/new_game_dialog.py
  - gui/dialogs/character_creation_dialog.py
  - gui/components/stat_allocation_widget.py
- Save/load dialogs
  - gui/dialogs/load_game_dialog.py
  - gui/dialogs/save_game_dialog.py
  - gui/dialogs/item_info_dialog.py
  - gui/dialogs/base_dialog.py
- Main window (signal wiring and orchestrated UI)
  - gui/main_window.py

What these GUI components actually do (ground truth)

1) CollapsibleRightPanel (gui/components/right_panel.py)
- A QFrame housing a QTabWidget (Character, Inventory, Journal).
- Custom tab bar emits “tab_clicked_twice” to toggle panel collapsed/expanded (width animation only; tabs remain visible).
- Styling matches dark panel with slightly transparent background.
- Exposes update_character(), update_inventory(), update_journal() that delegate to each tab widget.

2) CharacterSheetWidget (gui/components/character_sheet.py)
- Shows:
  - Header: portrait, name, race/class, level/exp, exp bar.
  - Resources: Health, Mana, Stamina (and Resolve), with progress bars and labels.
  - Combat Info: textual Status Effects, Turn Order list, and Initiative label.
  - Primary stat grid (STR/DEX/… incl. WIL/INS).
  - Derived stats (Melee/Ranged/Magic/Defense/Magic Defense/Damage Reduction/Carry/Movement).
  - Equipment grid by slot; each slot shows item label with context menu (Unequip, Item Info, Drop).
- Signal wiring and updates:
  - Listens to StatsManager.stats_changed to update primary/derived stats and resource maxes.
  - Actively fetches InventoryManager equipment and shows per-slot equipped items; encodes 2H weapon logic (MAIN_HAND shows “(2H)” and OFF_HAND blocked).
  - Handles orchestrated resource animations via slots:
    - player_resource_bar_update_phase1(bar_type, data)
    - player_resource_bar_update_phase2(bar_type, data)
  - Handles TURN_ORDER_UPDATE to rebuild the turn-order text and Initiative value. Uses CombatManager.entities and player’s combat entity for initiative.
  - Stat labels have dynamic tooltips; on right-click show modifiers (expects modifier_manager.get_modifiers_for_stat()).
- Emits signals (to MainWindow):
  - item_unequip_from_slot_requested(EquipmentSlot)
  - item_examine_requested(item_id)
  - item_drop_from_slot_requested(EquipmentSlot, item_id)

3) InventoryPanelWidget (gui/components/inventory_panel.py)
- Header: currency (gold/silver/copper) and weight (current/max).
- Filters: ItemType dropdown + text search field.
- Item list: shows “(Equipped)” and green color when applicable; supports right-click context menu with Examine, Use (consumables), Equip/Unequip (weapons/armor/etc.), Drop.
- Item details panel: name, type, description, placeholder grid for stats (currently not populated with item stat modifiers).
- Actions emit signals (handled by MainWindow):
  - item_use_requested(item_id)
  - item_examine_requested(item_id)
  - item_equip_requested(item_id)
  - item_unequip_requested(item_id)
  - item_drop_requested(item_id)
- update_inventory(inv_manager) reads:
  - currency gold/silver/copper (copper calculated mod copper_per_silver), current weight/limit
  - items inv_manager.items; filters by type and name; marks equipped items using inv_manager.is_item_equipped
- “Collect Dropped Items” button is a placeholder (not implemented).

4) JournalPanelWidget (gui/components/journal_panel.py)
- Tabs: Character, Quests, Notes
  - Character: free-form QTextEdit (journal_data["character"]).
  - Quests:
    - Three lists (Active, Completed, Failed) with context menus:
      - Active: per-objective actions “mark completed/failed”, open objective notes. “Abandon Quest” (moves to Failed with ABANDONED tag). Developer actions to force Completed/Failed.
      - Completed/Failed: notes-only menu listing objectives which have saved notes (disabled items when none).
    - Quest details pane with inline-styled HTML (status, objectives with strikethrough/colored states, notes, rewards).
    - Status computed: “completed” only when all mandatory objectives done and none failed; “failed” on abandoned or explicit; else “active”.
  - Notes: personal notes list + editor; add/delete/save; list items show “title - timestamp”.
- Exposes:
  - update_journal(journal_data) to set entire journal, repopulate UI.
  - clear_all() to blank all UI (used before loading saves).
  - journal_updated(dict) signal emitted on edits.

5) StatAllocationWidget (gui/components/stat_allocation_widget.py)
- Drives character creation stat allocation:
  - Depends on StatsManager + StatPointAllocator, and StatModifierInfo (race/class modifiers, min requirements, recommended stats, presets).
  - Grid with stat rows: base value, +/- buttons, race/class modifiers, total, ability mod. Tooltip on each cell explains sources.
  - Presets (from archetypes), auto/balanced allocation, reset.
  - Signals: stats_changed, allocation_complete. Provides get_allocated_stats() of base values.

6) NewGameDialog + CharacterCreationDialog (gui/dialogs/new_game_dialog.py, gui/dialogs/character_creation_dialog.py)
- Both load configuration via GameConfig (get_config()) reading local JSON:
  - Races: config.get_all("races")
  - Classes: config.get_all("classes")
  - Origins: config.get_all("origins")
- NewGameDialog gives basic form (name, race, class, origin, sex), shows origin details (description, skills, origin traits), backstory seed, portrait chooser scanning images/character_icons/<Race_Class>.
- CharacterCreationDialog extends into a tabbed flow:
  - Tab 1: Basic Info & Origin (with AI “Generate/Improve Backstory” hooks via get_narrator_agent()).
  - Tab 2/3: Stats allocation with StatAllocationWidget and stat info text (race/class modifiers, requirements, recommended).
  - Returns full character data including:
    - name, race, path, origin_id, sex, description (seed), use_llm, character_image
    - stats: allocated base stats (dict of STR/DEX/…)
    - starting_location_id, starting_items, initial_quests from selected origin
- Filtering of origins uses suitable_races and suitable_classes when populating the origin combo.
- The actual game start is triggered in MainWindow after panel fade-in, passing these values to GameEngine.start_new_game(...).

7) LoadGameDialog / SaveGameDialog / ItemInfoDialog (gui/dialogs/*.py)
- SaveGameDialog:
  - Lists existing saves by scanning /saves directory for *.json, sorted by mtime.
  - Lets user type a name and accept; MainWindow then calls engine.save_game(name).
- LoadGameDialog:
  - Scans /saves for *.json, lists in a table (save name, date, character), shows details by reading the json (player/world summary).
  - On accept, returns selected save file name; MainWindow calls engine.load_game(...)
- ItemInfoDialog:
  - Shows detailed item info (rarity, type, description, weight including total for stacks, currency value with totals, quantity, stack limit, durability current/max, equip slots, stats/effects, custom properties, tags).
  - Respects “known_properties” to hide unknown bits (fog-of-war-like reveal).

8) MainWindow (gui/main_window.py)
- Composition: MenuPanel (left), Center (Narrative/Combat stacked views with GameOutputWidget and CombatDisplay), RightPanel (CollapsibleRightPanel with Character/Inventory/Journal tabs). Title banner, music controls, status bar, background loader.
- Signal wiring:
  - Engine->UI orchestrated_event_to_ui → process_orchestrated_display_event
    - Handles BUFFER_FLUSH, UI_BAR_UPDATE_PHASE1/2 (routes to character sheet and entity widgets), TURN_ORDER_UPDATE (routes to character sheet), COMBAT_LOG_SET_HTML, and string content to either combat log or game output with gradual display flags.
  - Engine.output_generated → _handle_game_output (legacy/system messages).
  - StatsManager.stats_changed → _handle_stats_update → right_panel.update_character(state.player), combat_display.update_display if in combat.
  - RightPanel inventory signals → equip/unequip/use/drop/examine handlers; some actions route to command processing (use/drop), others call InventoryManager mechanics (equip/unequip) and then refresh UI.
- New game flow:
  - Opens CharacterCreationDialog (uses config and icons), then animates panels in, then calls GameEngine.start_new_game with name/race/path/origin_id, description as background, sex, image, and final base stats. Sets LLM enabled flag.
  - Initializes/ensures journal and stats manager; then updates UI and binds orchestrator to CombatManager if needed.
- Load/save:
  - Load dialog returns a save name; MainWindow clears orchestrator queue and both output widgets, clears right panel UI content to avoid stale data, calls engine.load_game, rebinds orchestrator if in combat, emits a consolidated stats_changed to force UI refresh, updates right panel character, etc.
  - Also a “Load last save” convenience using SaveManager.

```

