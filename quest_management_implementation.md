1) Core principles to preserve
- Objective-driven completion:
  - Quest is completed automatically when all mandatory objectives are completed and none of them are failed.
  - Quest fails immediately when any mandatory objective fails.
  - Optional objectives do not block completion; they influence rewards/outcomes.
- Determinism + flexibility:
  - Deterministic evaluation via a DSL against canonical events and signals.
  - Flexibility handled by a reference resolution layer (aliases and tag matching), and LLM is used for disambiguation where necessary, not for core evaluation.

2) The “B + C” foundation: canonical events + resolver
- Canonical event emission (B):
  - All events that matter to quests must carry canonical IDs from GameConfig:
    - EV_ENEMY_DEFEATED: entity_id + template_id + tags (species:wolf, color:white, faction:…)
    - EV_ITEM_DELTA: item_id + template_id + delta + source + tags
    - EV_LOCATION_VISITED: location_id
    - EV_DIALOGUE: dialogue_id (+ npc_id)
    - EV_INTERACTION: interaction_id (+ object_id/meta)
    - EV_FLAG_SET: key + value
  - This is the backbone that allows evaluation to be data-driven and testable.
- Reference Resolver layer (C):
  - When quests are authored by world_configurator or created/updated by the LLM, narrative handles (e.g., “white_wolf”) are resolved to canonical references.
  - Resolution pipeline:
    - Tier 1: exact canonical ID chosen in the editor (preferred).
    - Tier 2: config-driven aliases and tag recipes (config/aliases.json).
    - Tier 3: rule-based heuristics (casefold, tokenization, tag matching).
    - Tier 4: LLM-assisted resolution (structured JSON with confidence), used only if needed.
  - Persist accepted mappings per quest (e.g., journal.quests[quest_id].aliases) so runtime evaluation remains deterministic and explainable.

3) World_configurator: authoring UX that creates “correct by construction” quests
- Canonical-first objective authoring:
  - Objective types available to quest authors:
    - Kill/Defeat: choose canonical template_id(s), optionally count, tag constraints (e.g., species:wolf, color:white)
    - Collect/Obtain: choose item template_id(s), count, acquisition constraints (any/how, optional source filter)
    - Deliver: item template_id(s), quantity, target (canonical location_id or npc_id)
    - Visit/Explore: location_id/region
    - Dialogue/Interaction: dialogue_id/interaction_id
    - Flag/State: key:value predicates
    - Time windows: before/after timestamp or quest-time elapsed
  - Each objective has:
    - id (unique within quest)
    - description
    - mandatory: true/false
    - condition_dsl (auto-generated by the editor from the selected fields)
    - optional extras: count logic, tag constraints, time constraints, evidence hints, reward delta on completion.
- Tag taxonomy and catalogs:
  - Provide catalogs for canonical domains (NPC templates/entities, item templates, locations, dialogues, interactions).
  - Provide a tag taxonomy in config (species, color, faction, rarity, etc.). Authors can choose tags instead of enumerating every template.
- Visual DSL builder:
  - The editor generates a DSL object from the author’s selections (e.g., defeated_count≥N of template_id X, visited location L, delivered item I to NPC Y).
  - Show a read-only JSON panel for transparency.
- Alias authoring:
  - Optional: allow authors to add global aliases or per-quest aliases for known synonyms (“alpha wolf” → “wolf_alpha”).
  - Encourage canonical-first authoring; aliases are for LLM robustness and legacy data.
- Mandatory/optional and outcomes:
  - Mark each objective as mandatory or optional.
  - Let authors define reward/outcome variants conditioned on which optional objectives completed (e.g., tiered rewards).
  - Provide quest-level fail/abandon policies:
    - “Fail on first mandatory objective failure” (default).
    - Optional explicit fail DSL if needed (e.g., death of escort NPC).
- Live validation in configurator:
  - Validate canonical IDs exist.
  - Validate objective ids uniqueness.
  - Validate DSL is syntactically correct and references valid domains.
  - Warn if an objective is semantic-only (no DSL) because it won’t auto-complete.
- Test harness in configurator (optional but highly valuable):
  - A “Signals/Events Simulator” pane that lets the author feed mock events/signals and run the evaluator to see objective and quest status change live.
  - A “Resolution preview” that shows how narrative labels would be mapped to canonical IDs using the resolver/aliases.

4) LLM-driven quest creation during narration
- Agent output contract (structured JSON):
  - quest_id (provisional), title, description
  - objectives: array of objects:
    - id, description, mandatory (bool)
    - references: either canonical IDs (preferred if context is recognized) or narrative handles with evidence/tags
    - proposed_condition_dsl (if the agent can produce it) or structured raw intent (resolver will convert to DSL)
  - proposed_mappings: { label → {template_id, tags, confidence} }
  - constraints: time windows, counts, delivery targets, etc.
- Reference resolution at ingestion:
  - Upon receiving the LLM quest, the ReferenceResolver runs (tiered approach), producing canonical references and an objective DSL if needed.
  - Persist per-quest alias mapping; store the canonical DSL on objectives.
  - Reject or request clarification when mapping confidence is too low or ambiguous; the agent can respond with a QUEST_UPDATE/clarification payload.
- Evidence and confidence:
  - Objective completion remains automatic via events + DSL.
  - LLM-initiated state changes or objective flips require evidence checks and high confidence (as you already enforce).

5) Core auto-evaluation behavior (derivation stays as is)
- On every appended relevant event, re-evaluate objectives whose DSL predicates could be affected (Phase 1 can re-evaluate all; later index by predicate type).
- Objective transitions:
  - If a DSL flips to true: completed = true, failed = false; queue DisplayEvents and record EV_OBJECTIVE_STATUS.
  - If a DSL explicitly defines a failure condition that becomes true: failed = true (but avoid regressions that flip back).
- Quest recompute (your rule preserved):
  - If any mandatory failed → quest.status = failed.
  - Else if all mandatory completed → quest.status = completed.
  - Else → quest.status remains active.
- Optional objectives:
  - Don’t block completion. They influence rewards/outcomes:
    - Author can define reward tiers or conditional rewards in the quest config (engine grants them when quest completes).
- Explainability:
  - Store traces: which events or signals satisfied the DSL, which alias resolved a label, and confidence tiers.

6) Data shapes and where they live
- Config (world_configurator output):
  - config/quests.json (or scenarios/quests.json per your current path)
  - Each quest: id, title, description, objectives[], reward schema, failure/abandon policy, tags.
  - Each objective: id, description, mandatory, condition_dsl, optional “on_complete_effects” and “on_fail_effects,” counts, time windows.
  - Global alias dictionary: config/aliases.json for common synonyms and tag recipes.
  - Tag taxonomy/config: config/tags.json (optional).
- Runtime journal (per save):
  - journal.quests[quest_id]: transient state—objectives’ completed/failed flags, alias map (resolved), status, evidence traces, timestamps.
  - The quest instance references the static definition but holds live state and per-run alias decisions.

7) Consistency rules (edge cases handled explicitly)
- Ambiguity:
  - If a narrative label maps to multiple candidates (e.g., two similar wolves), keep objective pending and request resolution via LLM; store the decision in the alias map.
- Counts and ranges:
  - For kill/collect counts, DSL must encode gte/eq logic (extend DSL accordingly).
- Time windows and sequence:
  - For “before/after” constraints (time_before/time_after), DSL is evaluated against world time or quest clock; sequence constraints can be modeled as dependency (objective B “active” only when A completed) or explicit DSL (Phase 2).
- Failure triggers:
  - Besides objective-level DSL, provide quest-level fail conditions (e.g., escort NPC death) encoded either as objective with mandatory=true or as a quest-level fail DSL.
- Abandon:
  - Abandon sets a flag and marks quest failed (your current policy), but preserve evidence trace.

8) “Source of truth” and team workflows
- World_configurator is the source of truth for authored quests and global aliases.
- LLM creates quests at runtime using the same schema; the resolver ensures output conforms to canonical forms or raises clarifying requests.
- The evaluator logic and recompute rules remain in core, UI-agnostic and event-driven.

9) Why this aligns with your goals
- Authors can create correct quests in world_configurator without knowing internal DSL details; the editor generates it.
- LLM can create context-appropriate quests; the resolver protects determinism and integrates them seamlessly.
- Mandatory/optional and completion/failure rules are enforced centrally by the recompute logic as you require.
- The system remains testable: you can simulate events and assert objective/quest status transitions across your 25 quest types.

10) What to do first (implementation order)
- Finalize the quest/objective schema in world_configurator:
  - Canonical selector UX, DSL builder, mandatory/optional flags, reward/failure policies.
  - Add validators and a lightweight “evaluation simulator.”
- Strengthen canonical event emission (across combat/inventory/locations/dialogue/interaction).
- Implement the ReferenceResolver service:
  - Deterministic mapping + aliases + optional LLM fallback, persisting to the quest’s alias map.
- Extend DSL operators (counts, tags, delivery, time) to cover your 25 cases, keeping them minimal and composable.
- Integrate LLM agents to emit structured quest definitions and clarifications.